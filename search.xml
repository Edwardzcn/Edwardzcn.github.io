<?xml version="1.0" encoding="utf-8"?>
<search>
  <entry>
    <title><![CDATA[【UVA-11988】解题报告（链表）]]></title>
    <url>%2F2018%2F10%2F21%2F%E3%80%90UVA-11988%E3%80%91%E8%A7%A3%E9%A2%98%E6%8A%A5%E5%91%8A%EF%BC%88%E9%93%BE%E8%A1%A8%EF%BC%89%2F</url>
    <content type="text"><![CDATA[原始题目 题目大意给出一段输入，‘[’表示“Home”键，即输入跳转到开头，‘]’表示“End”键，即输入跳至结尾。输出最终实际文字。 解题思路数组形式链表模拟。加空开头和尾。 解题代码12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849#include &lt;cstdio&gt;#include &lt;bits/stdc++.h&gt;#define rep(i,a,n) for(int i=a;i&lt;n;++i)#define per(i,a,n) for(int i=n-1;i&gt;=a;--i)#define clint(x,a) memset(x,a,sizeof(int)*n)#define clll(x,a) memset(x,a,sizeof(ll)*n)#define pb push_back#define np next_permutation#define mp make_pair#define fi first#define se second#define INF 0x3f3f3f3f#define EPS 1e-8#define PI acos(-1.0)using namespace std;const int maxn=1e5+5;const int maxm=1e5+5;const int maxl=26;char ss[maxn];int nextt[maxn];int main()&#123; ios::sync_with_stdio(false); while(cin&gt;&gt;ss+1)&#123; int last=0,cur=0; memset(nextt,0,sizeof(nextt)); int len=strlen(ss+1); rep(i,1,len+1)&#123; if(ss[i]=='[')&#123; cur=0; &#125; else if(ss[i]==']') &#123; cur=last; &#125; else &#123; nextt[i]=nextt[cur]; nextt[cur]=i; if(cur==last) last=i; cur=i; &#125; &#125; for(int i=nextt[0];i!=0;i=nextt[i])&#123; cout&lt;&lt;ss[i]; &#125; cout&lt;&lt;endl; &#125;&#125; 收获与反思 数组形式链表，数组标号0作为空头结点，next[0]作为头节点的指针。 添加结点的操作为 12345next[i]=next[cur] //加入结点的指针与前一结点的指针相同next[cur]=i; //前一结点指针指向新结点//由于本题还需要记录尾结点的序号所以有//if(cur==last) last=i;cur=i; //指针移向当前结点]]></content>
      <categories>
        <category>编程</category>
        <category>ACM</category>
      </categories>
      <tags>
        <tag>算法</tag>
        <tag>ACM</tag>
        <tag>Imitation</tag>
        <tag>2018秋季训练</tag>
        <tag>UVA</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[【UVA-442】解题报告（STL，栈）]]></title>
    <url>%2F2018%2F10%2F21%2F%E3%80%90UVA-442%E3%80%91%E8%A7%A3%E9%A2%98%E6%8A%A5%E5%91%8A%EF%BC%88STL%EF%BC%8C%E6%A0%88%EF%BC%89%2F</url>
    <content type="text"><![CDATA[原始题目 题目大意给出$n$个矩阵的行数和列数（矩阵名为A到Z），再给出一些表达式，根据表达式的运算规则计算是否合法，若合法计算出乘法次数。 解题思路简单的表达式解析可以通过栈实现，输入右括号时计算，输入字母时压入栈。 解题代码12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364656667686970717273#include &lt;cstdio&gt;#include &lt;bits/stdc++.h&gt;#define rep(i,a,n) for(int i=a;i&lt;n;++i)#define per(i,a,n) for(int i=n-1;i&gt;=a;--i)#define clint(x,a) memset(x,a,sizeof(int)*n)#define clll(x,a) memset(x,a,sizeof(ll)*n)#define pb push_back#define np next_permutation#define mp make_pair#define fi first#define se second#define INF 0x3f3f3f3f#define EPS 1e-8#define PI acos(-1.0)using namespace std;const int maxn=1e5+5;const int maxm=1e5+5;const int maxl=26;typedef long long ll;typedef unsigned long long ull;typedef vector&lt;int&gt; vi;typedef pair&lt;int,int&gt; pii;typedef pair&lt;string,string&gt; pss;int t,n;struct Matrix&#123; int a,b; Matrix(int a=0,int b=0):a(a),b(b)&#123;&#125;&#125;m[26];int main()&#123; ios::sync_with_stdio(false); cin&gt;&gt;n; rep(i,0,n)&#123; char c; cin&gt;&gt;c; cin&gt;&gt;m[c-'A'].a&gt;&gt;m[c-'A'].b; &#125; string str; while(cin&gt;&gt;str)&#123; stack &lt;Matrix&gt; s; bool flag=0; int ans=0; int len=str.length(); rep(i,0,len)&#123; if(isalpha(str[i]))&#123; if(flag) break; s.push(m[str[i]-'A']); &#125; else if(str[i]==')')&#123; Matrix m1,m2; if(flag) break; m1=s.top();s.pop(); m2=s.top();s.pop(); if(m1.a!=m2.b)&#123; flag=1; break; &#125; else&#123; ans+=m2.a*m1.b*m1.a; s.push(Matrix(m2.a,m1.b)); &#125; &#125; &#125; if(flag) cout&lt;&lt;"error"&lt;&lt;endl; else cout&lt;&lt;ans&lt;&lt;endl; &#125;&#125; 收获与反思注意读题，表达式的范式。]]></content>
      <categories>
        <category>编程</category>
        <category>ACM</category>
      </categories>
      <tags>
        <tag>算法</tag>
        <tag>ACM</tag>
        <tag>2018秋季训练</tag>
        <tag>STL</tag>
        <tag>UVA</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[【UVA-10474】解题报告（STL，排序，二分）]]></title>
    <url>%2F2018%2F10%2F21%2F%E3%80%90UVA-10474%E3%80%91%E8%A7%A3%E9%A2%98%E6%8A%A5%E5%91%8A%EF%BC%88STL%EF%BC%8C%E6%8E%92%E5%BA%8F%EF%BC%8C%E4%BA%8C%E5%88%86%EF%BC%89%2F</url>
    <content type="text"><![CDATA[原始题目 题目大意有许多$N$个标有不同数字的大理石，每次按1，2，3这样从小到大的次序数。有$Q$个询问，对于每个询问，是否能数到指定数，若能输出数的次数，若不能输出not found. 解题思路排序以后利用二分查找，输出位置+1即可。 解题代码12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455#include &lt;bits/stdc++.h&gt;#define rep(i,a,n) for(int i=a;i&lt;n;++i)#define per(i,a,n) for(int i=n-1;i&gt;=a;--i)#define fi first#define se second#define mp make_pair#define pb push_back#define np next_permutation#define cl(x,a,n) memset(x,a,sizeof(int)*n)using namespace std;typedef long long ll;typedef unsigned long long ull;typedef long double ld;typedef vector&lt;int&gt; vi;typedef pair&lt;int,int&gt; pii;typedef pair&lt;string,string&gt; pss;const int maxn=1e5+5;int n,q;int cnt,a[maxn];vector&lt; pii &gt; v;bool cmp( pii a, pii b)&#123; if(a.se!=b.se) return a.se&lt;b.se; else return a.fi&lt;b.fi;&#125;int main()&#123; ios::sync_with_stdio(false); while(cin&gt;&gt;n&gt;&gt;q &amp;&amp; n+q)&#123; rep(i,0,n)&#123; cin&gt;&gt;a[i]; &#125; cout&lt;&lt;"CASE# "&lt;&lt;++cnt&lt;&lt;":"&lt;&lt;endl; sort(a,a+n); rep(i,0,q)&#123; int x; cin&gt;&gt;x; int index=lower_bound(a,a+n,x)-a; if(a[index]==x) cout&lt;&lt;x&lt;&lt;" found at "&lt;&lt;index+1&lt;&lt;endl; else cout&lt;&lt;x&lt;&lt;" not found"&lt;&lt;endl; &#125; &#125;&#125; 收获与反思排序，二分]]></content>
      <categories>
        <category>编程</category>
        <category>ACM</category>
      </categories>
      <tags>
        <tag>算法</tag>
        <tag>ACM</tag>
        <tag>2018秋季训练</tag>
        <tag>STL</tag>
        <tag>UVA</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[《金融的本质：伯南克四讲美联储》读书笔记]]></title>
    <url>%2F2018%2F10%2F17%2F%E3%80%8A%E9%87%91%E8%9E%8D%E7%9A%84%E6%9C%AC%E8%B4%A8%EF%BC%9A%E4%BC%AF%E5%8D%97%E5%85%8B%E5%9B%9B%E8%AE%B2%E7%BE%8E%E8%81%94%E5%82%A8%E3%80%8B%E8%AF%BB%E4%B9%A6%E7%AC%94%E8%AE%B0%2F</url>
    <content type="text"><![CDATA[第一讲 美联储的起源与使命本讲先说说中央银行的定一、职能、以及他是符合在美国出现的，我还会介绍美联储如何应对其第一次重大挑战，即20世纪30年代的经济大萧条。 第二讲中，回顾二战后美联储的发展状况、80年代如何战胜通胀，格林斯潘任期内的“大缓和”时期，以及1945年后发生的其它一些变化。危机如何形成，以及导致08~009年经济危机的部分原因。 第三讲中，近期发生的事件，此轮金融危机最严重的阶段，危机发生的原因和后果，还有美联储褐其他政策制定者对危机的应对等。 第四讲中，危机的后果，危机后的经济衰退和美联储的应对措施（包括货币政策），以及金融监管方面的变革。此外，还会对金融危机如何改变央行的运作方式，以及美联储未来会如何运作，进行一些前瞻性的讨论。 央行是什么中央银行的职能，第一个是维持宏观经济稳定，即追求经济稳定增长，避免大幅度波动（如衰退等），并维持低通胀，经济稳定只能。另一个职能，也是这一系列讲座重点探讨的一个功能，就是金融稳定职能，中央银行要尽可能保证金融系统的正常运作，尤其要尽可能防止金融恐慌，避免发生金融危机。 稳定经济方面的工具主要是货币政策：公开市场买卖证券来降低或提高短期利率，调整隔夜拆借利率。 应对金融恐慌的工具主要是流动性供给：短期信贷平息市场情绪，维持金融机构稳定性，“最后贷款人”工具。 第三个工具是金融监管：评估，非中央银行独有。系列讲座不予以详谈。 什么是金融恐慌 P007 “总体来说，金融恐慌是由大家对金融机构失去信心而引起的。” P009 “如果金融机构持有期限较长的非流动性资产——非流动性意味着出售这些资产（如贷款）需要花费相当多的时间和精力，而支持这些资产的资金（如发放贷款的资金）却主要来自资产负债表另一侧的短期负债（如储蓄），那么金融恐慌随时都有可能发生。” 关于央行职能和相应政策，白芝浩。 P010 “在恐慌时期，中央银行应大量放款，只要找上门来的人有抵押物，就可以放宽给他，中央银行需要持有安全的抵押物，以确保能收回贷款，因此这些抵押必须是优质安全的，否则贷款时就必须带着计算。当然中央银行还应征收惩罚税率，这样人们才不会利用这种恐慌局势来占便宜。人们愿意支付较高水平的利率，这表明他们确实急需现金。” 金本位的利与弊南北战争结束到20世纪30年代，美国实行的一直是金本位制。 P013 “真正的金本位制会创造出一个自我管理的货币体系，而这样的货币体系至少能部分替代央行的职能。” P013 “不幸的是，金本位制还远非完善的货币体系。比如，金本位制造成了极大的资源浪费，从一处地下（开采处）转移到另一处地下（美联储），除此以外，实际表明金本位制还会导致许多更严重的金融及经济问题。” 金本位带来的还有：央行货币政策工具受到限制，国家间固定汇率体系，投机冲击。 美联储的起源 P017 “1913年，在所有研究全部完成以后，国会终于通过了《联邦储备法案》，奠定了美联储成立的基础，威尔逊总统把签署《联邦储备法案》看作自己执政期间最重要的国内政治成就。” 之前有过两次尝试，但是由于以商业街为代表的普通民众和以华尔街为代表的资本家之间存在重大分歧，即美联储是否能代表整个国家的利益，前两次尝试均以失败告终。 威尔逊总统通过在各城市分散建立12个联邦储备银行，而非在华盛顿建立一家中央银行，解决了两大群体的主要纠纷。12个联邦储备区，其中每一个区都有一家联邦储备银行。华盛顿的联邦储备委员会监管着整个系统。 P019 “当美联储制定货币政策时，它会考虑整个国家所有联邦储备银行的意见，再在国家层面上制定相关政策。” 美联储的第一次大挑战面对“大萧条”，美联储在这个时期做了什么呢？不幸的是，当首次面临此类重大挑战时，美联储无论是在货币政策还是在金融稳定方面都表现得不尽如人意。原因有很多，防止股市投机，信奉清算主义，维护金本位。 最后贷款人方面，也对银行业挤兑现象反映不足，致使大量银行破产，这种反应迟钝很大程度上还是因为对清算注意的认同。 P027 “尽管罗斯福采取的许多措施并没有奏效，但在我看来，他有两项工作确实有效解决了那些由美联储造成的问题。第一项就是于1934年建立了联邦存款保险公司。从那以后，即便银行倒闭，普通储户仍然可以拿回自己的钱，这样他们就没有动机再去银行挤兑了……罗斯福做的另一件事就是废除了金本位制。废除金本位制后，他允许放松货币政策，扩张货币供给，这就结束了通货紧缩，使经济在1933到1934年间经历了一个短期的有力反弹。” 罗斯福的上述两件措施，根本上解决美联储未尽责而造成或者加重的问题。 应对首次挑战时两大职能未尽其力，当后来的危机以及2008到2009年的金融危机到来时，我们应该牢牢记住这些曾经的教训。 对话 紧缩货币政策防止股票投机的探讨，如何正确应对泡沫？ P028 “我们当然知道资产价格泡沫十分危险，也想尽可能地化解这些泡沫。但若要通过金融监管途径来解决， 那就应该采用更具针对性的解决办法，而不仅仅是提高利率水平这种带有普遍杀伤力的方法。调整保证金要求的方法 就好得多，因为至少还可以根据业务的不同制定不同的标准。” 回归金本位制有可能吗？ 金本位制从长期看可以保持价格稳定，解决通胀问题，但是短期的金矿开采等各种事情都会导致波动，逐年看就不正确了。 P029 “我认为无论从实践还是政策角度来看，金本位制都不可行。在实践方面，一个很简单的事实就是，黄金总量不足以 支持整个国际金本位体系……如今，经济史学家们认为，工人运动在‘一战’后更加强大，使得政府 对失业开始有了更多的担忧，19世纪之前，人们甚至都不会去衡量失业率，但是‘一战’后，人们开始 更多地关注失业和经济周期。” 承诺金本位制就等于承诺无论失业情况多糟糕，央行都不会采取货币政策干预。不现实也是不可能的，而且民众会因 怀疑而拿现金换黄金，从而引起冲击。 关于“大萧条”期间的二次衰退，和我们该注意的问题？ 未被普遍认可的说法，“大萧条期间”有过两次经济衰退：分别是1929至1933年和1937年至1938年。第二次衰退是由于 政策转向过早，收紧财政和货币政策导致的，当然同期还有其他事情的影响。 “大萧条”期间为什么没有更多的全球性合作？ “一战”留下的不良情绪，德国正面临不得不支付战争赔款的处境，英法在战争债务上一直有政治，国际政治环境糟糕， 并没有理想的合作空间。 P034 “同时，对于实施固定汇率的国家来说，国家间的央行合作更为重要，20世纪20年代，各国因为金本位制形成了 固定汇率体系，这就意味着一国货币政策将影响到其他国家。这是个关于央行非常有必要进行国际合作的很好的例子，但 这种合作并没有出现。” 当然在今天的灵活汇率制度下，作者认为这种合作是非常必要的。]]></content>
      <categories>
        <category>阅读</category>
      </categories>
      <tags>
        <tag>阅读</tag>
        <tag>演讲</tag>
        <tag>本·伯南克</tag>
        <tag>金融的本质</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[金融学辅修——金融学笔记（四）]]></title>
    <url>%2F2018%2F10%2F17%2F%E9%87%91%E8%9E%8D%E5%AD%A6%E8%BE%85%E4%BF%AE%E2%80%94%E2%80%94%E9%87%91%E8%9E%8D%E5%AD%A6%E7%AC%94%E8%AE%B0%EF%BC%88%E5%9B%9B%EF%BC%89%2F</url>
    <content type="text"><![CDATA[课前同学分享 金融衍生品 期权 八大特点零和博弈：金融衍生品交易净损益之和等于零跨期性：未来交易联动性高风险性高杠杆性交易的保值性 金融衍生品在我国的发展情况过去——1992年——国债期货 1994年——1998年——金融衍生品市场 发展现况市场经济的推进 对外开放和国际经济接轨 金融衍生品的功能1.风险转移2.价格发现：可以预测未来现货价格的变化3.增强流动4. 存在的问题]]></content>
      <categories>
        <category>金融</category>
        <category>金融学</category>
      </categories>
      <tags>
        <tag>课堂笔记</tag>
        <tag>辅修</tag>
        <tag>金融学</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[金融学辅修——微观经济学笔记（二）]]></title>
    <url>%2F2018%2F10%2F16%2F%E9%87%91%E8%9E%8D%E5%AD%A6%E8%BE%85%E4%BF%AE%E2%80%94%E2%80%94%E5%BE%AE%E8%A7%82%E7%BB%8F%E6%B5%8E%E5%AD%A6%E7%AC%94%E8%AE%B0%EF%BC%88%E4%BA%8C%EF%BC%89%2F</url>
    <content type="text"></content>
      <categories>
        <category>金融</category>
        <category>微观经济学</category>
      </categories>
      <tags>
        <tag>课堂笔记</tag>
        <tag>辅修</tag>
        <tag>微观经济学</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[金融学辅修——微观经济学笔记（一）]]></title>
    <url>%2F2018%2F10%2F16%2F%E9%87%91%E8%9E%8D%E5%AD%A6%E8%BE%85%E4%BF%AE%E2%80%94%E2%80%94%E5%BE%AE%E8%A7%82%E7%BB%8F%E6%B5%8E%E5%AD%A6%E7%AC%94%E8%AE%B0%EF%BC%88%E4%B8%80%EF%BC%89%2F</url>
    <content type="text"><![CDATA[第一章 导论第一节 什么是西方经济学第四节 西方经济学的主要分析方法任何一门学科都有一定的研究和分析方法。 边际分析法边际分析法的特点 其一，边际分析是一种数量分析，尤其是变量分析，运用这一方法研究数量的变动和相互关系。 边际分析法研究微增量的变化及变量之间的关系，可使经济理论精细化（差分，微分）。 边际分析法的意义 经济学研究重心发生改变，由社会性、历史性的政治学经济学转为纯粹研究如何抉择稀缺资源分配给无限而又有竞争性的用途上，以有效利用。 开创了经济学“数量化”的时代。 导致了微观经济学的形成，“个量分析”的微观经济学的诞生。 奠定了最优化理论的基础。 使实证经济学得到发展。 经济模型与抽象分析经济模型： 实证分析和规范分析 规范经济学 Normative economics 以一定的主观价值判断为基础，提出某些标准作为分析处理经济问题的根据，作为建立经济理论的前提和制定经济政策的依据，并研究如何才能符合这些标准。回答“应该是什么”的问题。（标准，应有的样子） 实证经济学 Positive economics 对经济现象进行客观描述，企图超脱或排斥一切主观价值判断。回答“是什么”的问题。 均衡分析均衡即平衡，本是物理学的一个概念 博弈论：纳什均衡 经济学中的均衡状态：各个经济决策者（消费者、生产者等等）所做出的决策正好相容，并且在外界条件不变的情况下，每个人都不愿意再调整自己的决策，从而不再改变其经济行为。（环境不改变，博弈均衡） 均衡分析就是假定经济变量达到均衡状态时所出现的情况以及实现均衡的条件。局部/一般均衡分析。 局部均衡分析：假定其他条件不变，只考虑本身的各相关变量的作用（部分忽略，考虑局部），研究该种变量如何实现均衡。局限在一个局部范围。 一般均衡分析：考虑在各种因素和变量的作用下，如何实现均衡。 静态分析、比较静态分析与动态分析 静态分析：分析均衡状态和所需要的条件，不考虑实现的过程。 比较静态分析：分析在已知条件发生后，均衡状态如何变化。（方向） 动态分析：论述均衡调整变化的实际过程，通常把经济运动过程划分为连续的分析期间，考察有关经济变量在连续时间段的变化。（加时间变量的分析） 外生变量与内生变量 内生变量（Endogenous Variables）经济模型内部结构决定的变量 外生变量（Exogenous Variable）经济模型外部的因素决定的变量 存量（Stock）一定时间存在的量 流量（Flow）一定时间内变化的量 第五节 为关于宏观经济学的基本框架微观经济学微观经济学（Micro-Economics）：研究市场经济中单个经济主体——居民与企业的经济行为以及相应的经济变量的决定。 应有内容：个量分析/单个经济单位/目标最大化/资源配置/价格理论为核心 微观经济学的假设：理性经济人假设/充分就业假设/市场出清假设/完全信息假设 微观经济学的基本内容： 价格的决定：需求和供给决定价格 需求分析：消费者行为理论 攻击分析： 生产与成本理论 市场理论：市场类型对价格和产量决定的影响 要素价格的决定：分配理论 信息经济学 一般均衡与福利经济学 市场失灵与政府失灵 理性人假设基本动力：利益最大化。基本准则：既定目标的最优化。（非理性因素：目标队员，限制性，习惯，社会政治道德等方面呢约束） 第六节 学习经济学容易犯的错误基本研究方法：给定假设，简化关系，放松假设，逼近现实 容易犯的错误：经验主义，合成谬误 第二章 需求、价格与供求关系第一节 需求需求曲线 需求 Demand：在一定时期内，各种可能的价格水平，人们愿意并且能够购买的商品量。 需求表，函数关系，来表示价格与需求量的关系 需求曲线 绘制：横轴数量，纵轴价格 一条向右下方的曲线。 需求分类 个人需求曲线与市场需求曲线：市场需求曲线由个人叠加，个人的较为陡直，市场的较平坦（对价格变化更加敏感）]]></content>
      <categories>
        <category>金融</category>
        <category>微观经济学</category>
      </categories>
      <tags>
        <tag>课堂笔记</tag>
        <tag>辅修</tag>
        <tag>微观经济学</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[【HDU-6222】解题报告（大数，打表）]]></title>
    <url>%2F2018%2F10%2F14%2F%E3%80%90HDU-6222%E3%80%91%E8%A7%A3%E9%A2%98%E6%8A%A5%E5%91%8A%EF%BC%88%E5%A4%A7%E6%95%B0%EF%BC%8C%E6%89%93%E8%A1%A8%EF%BC%89%2F</url>
    <content type="text"><![CDATA[原始题目Heron and His Triangle Time Limit: 2000/1000 MS (Java/Others) Memory Limit: 262144/262144 K (Java/Others) Total Submission(s): 2123 Accepted Submission(s): 892 Problem DescriptionA triangle is a Heron’s triangle if it satisfies that the side lengths of it are consecutive integers $ t-1, t, t+1 $ and that its area is an integer. Now, for given n you need to find a Heron’s triangle associated with the smallest $t$ biggerthan or equal to $n$. InputThe input contains multiple test cases. The first line of a multiple input is an integer $T (1 ≤ T ≤ 30000)$ followedby T lines. Each line contains an integer $N (1 ≤ N ≤ {10}^{30}) $. OutputFor each test case, output the smallest $t$ in a line. If the Heron’s triangle required does not exist, output $-1$. Sample Input4 1 2 3 4 Sample Output4 4 4 4 Source2017ACM/ICPC亚洲区沈阳站-重现赛（感谢东北大学） Recommendjiangzijing2015 题目大意输入$n$，求大于等于$n$的最小$t$满足由$t-1,t,t+1$构成的三角形面积为整数。 解题思路打表发现$t$构成数列 t[i]=4 \times t[i-1] -t[i-2]大数板子打表输出。 标程证明还没有想，待补充。 解题代码123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147148149150151152153154155156157158159160161162163164165166167168169170171172173174175176177178179180181182183184185186187188189190191192193194195196197198199200201202203204205206207208209210211212213214215216217218219220221222223224225226227228229230231232233234235236237238239240241242243244245246247248249250251252253254255256257258259260261262263264265266267268269270271272273274275276277278279280281282283284285286287288289290291292293294295296297298299300301302303304305306307308309310311312313314315316317318319320321322323324325326327328329330331332333334335336337338339340341342343344345346347348349350351352353354355356357358359360361362363364365366367368369370371372373374375376377378379380381382383384385386387388389390391392393394395396397398399400401402403404405406407408409410411412413414415416417418419420421422423424425426427428429430431432433434435436437438439440441442443444445446447448449450451452453454455456457458459460461462463464465466467468469470471472473474475476477478#include &lt;bits/stdc++.h&gt;#define rep(i,a,n) for(int i=a;i&lt;n;++i)#define per(i,a,n) for(int i=n-1;i&gt;=a;--i)#define fi first#define se secondusing namespace std;// base and base_digits must be consistentconstexpr int base = 1000000000;constexpr int base_digits = 9;struct bigint&#123; vector&lt;int&gt; z; int sign; bigint() : sign(1) &#123;&#125; bigint(long long v) &#123; *this = v; &#125; bigint&amp; operator=(long long v) &#123; sign = v &lt; 0 ? -1 : 1; v*=sign; z.clear(); for(; v &gt; 0; v = v / base) z.push_back((int)(v % base)); return *this; &#125; bigint(const string&amp; s) &#123; read(s); &#125; bigint&amp; operator+=(const bigint&amp; other) &#123; if (sign == other.sign) &#123; for (int i = 0, carry = 0; i &lt; other.z.size() || carry; ++i) &#123; if(i==z.size()) z.push_back(0); z[i] += carry + (i &lt; other.z.size() ? other.z[i] : 0); carry = z[i] &gt;= base; if(carry) z[i] -= base; &#125; &#125; else if (other != 0 /* prevent infinite loop */) &#123; *this -= -other; &#125; return *this; &#125; friend bigint operator+(bigint a, const bigint&amp; b) &#123; return a += b; &#125; bigint&amp; operator-=(const bigint&amp; other) &#123; if (sign == other.sign) &#123; if (sign == 1 &amp;&amp; *this &gt;= other || sign == -1 &amp;&amp; *this &lt;= other) &#123; for (int i = 0, carry = 0; i &lt; other.z.size() || carry; ++i) &#123; z[i] -= carry + (i &lt; other.z.size() ? other.z[i] : 0); carry = z[i] &lt; 0; if(carry) z[i] += base; &#125; trim(); &#125; else &#123; *this = other - *this; this-&gt;sign = -this-&gt;sign; &#125; &#125; else *this += -other; return *this; &#125; friend bigint operator - (bigint a,const bigint&amp; b) &#123; return a -= b; &#125; bigint&amp; operator*=(int v) &#123; if(v&lt;0) sign=-sign,v=-v; for(int i=0,carry=0;i&lt;z.size() || carry;++i) &#123; if(i==z.size()) z.push_back(0); long long cur = (long long)z[i] * v + carry; carry = (int)(cur / base); z[i] = (int)(cur % base); &#125; trim(); return *this; &#125; bigint operator*(int v) const &#123; return bigint(*this) *= v; &#125; friend pair&lt;bigint, bigint&gt; divmod(const bigint&amp; a1, const bigint&amp; b1) &#123; int norm = base / (b1.z.back() + 1); bigint a = a1.abs() * norm; bigint b = b1.abs() * norm; bigint q, r; q.z.resize(a.z.size()); for (int i = (int)a.z.size() - 1; i &gt;= 0; i--) &#123; r*=base; r+=a.z[i]; int s1 = b.z.size() &lt; r.z.size() ? r.z[b.z.size()] : 0; int s2 = b.z.size() - 1 &lt; r.z.size() ? r.z[b.z.size() - 1] : 0; int d = (int)(((long long)s1 * base + s2) / b.z.back()); r -= b * d; while(r &lt; 0) r+=b,--d; q.z[i] = d; &#125; q.sign = a1.sign * b1.sign; r.sign = a1.sign; q.trim(); r.trim(); return &#123;q, r / norm&#125;; &#125; friend bigint sqrt(const bigint&amp; a1) &#123; bigint a=a1; while(a.z.empty()||a.z.size()%2==1) a.z.push_back(0); int n = a.z.size(); int firstDigit = (int)::sqrt((double)a.z[n - 1] * base + a.z[n - 2]); int norm = base / (firstDigit + 1); a *= norm; a *= norm; while(a.z.empty()||a.z.size()%2==1) a.z.push_back(0); bigint r = (long long)a.z[n - 1] * base + a.z[n - 2]; firstDigit = (int)::sqrt((double)a.z[n - 1] * base + a.z[n - 2]); int q = firstDigit; bigint res; for (int j = n / 2 - 1; j &gt;= 0; j--) &#123; for(;;--q) &#123; bigint r1=(r-(res*2*base+q)*q)*base*base+(j&gt;0?(long long)a.z[2*j-1]*base+a.z[2*j-2]:0); if(r1&gt;=0) &#123; r=r1; break; &#125; &#125; res*=base;res+=q; if(j&gt;0) &#123; int d1 = res.z.size() + 2 &lt; r.z.size() ? r.z[res.z.size() + 2] : 0; int d2 = res.z.size() + 1 &lt; r.z.size() ? r.z[res.z.size() + 1] : 0; int d3 = res.z.size() &lt; r.z.size() ? r.z[res.z.size()]:0; q = (int)(((long long)d1*base*base+(long long)d2*base+d3)/(firstDigit*2)); &#125; &#125; res.trim(); return res / norm; &#125; bigint operator/(const bigint&amp; v) const &#123; return divmod(*this, v).first; &#125; bigint operator%(const bigint&amp; v) const &#123; return divmod(*this, v).second; &#125; bigint&amp; operator/=(int v) &#123; if(v&lt;0) sign=-sign,v=-v; for (int i = (int)z.size() - 1, rem = 0; i &gt;= 0; --i) &#123; long long cur = z[i] + rem * (long long)base; z[i] = (int)(cur / v); rem = (int)(cur % v); &#125; trim(); return *this; &#125; bigint operator/(int v) const &#123; return bigint(*this) /= v; &#125; int operator%(int v) const &#123; if(v&lt;0) v=-v; int m=0; for(int i=(int)z.size()-1;i&gt;=0;--i) m=(int)((z[i]+m*(long long)base)%v); return m * sign; &#125; bigint&amp; operator*=(const bigint&amp; v) &#123; *this = *this * v; return *this; &#125; bigint&amp; operator/=(const bigint&amp; v) &#123; *this = *this / v; return *this; &#125; bool operator&lt;(const bigint&amp; v) const &#123; if(sign!=v.sign) return sign &lt; v.sign; if(z.size()!=v.z.size()) return z.size()*sign&lt;v.z.size()*v.sign; for(int i = (int)z.size() - 1; i &gt;= 0; i--) if(z[i] != v.z[i]) return z[i] * sign &lt; v.z[i] * sign; return false; &#125; bool operator&gt;(const bigint&amp; v) const &#123; return v &lt; *this; &#125; bool operator&lt;=(const bigint&amp; v) const &#123; return !(v &lt; *this); &#125; bool operator&gt;=(const bigint&amp; v) const &#123; return !(*this &lt; v); &#125; bool operator==(const bigint&amp; v) const &#123; return !(*this &lt; v) &amp;&amp; !(v &lt; *this); &#125; bool operator!=(const bigint&amp; v) const &#123; return *this &lt; v || v &lt; *this; &#125; void trim() &#123; while(!z.empty() &amp;&amp; z.back() == 0) z.pop_back(); if(z.empty()) sign = 1; &#125; bool isZero() const &#123; return z.empty(); &#125; friend bigint operator-(bigint v) &#123; if(!v.z.empty()) v.sign = -v.sign; return v; &#125; bigint abs() const &#123; return sign == 1 ? *this : -*this; &#125; long long longValue() const &#123; long long res = 0; for(int i = (int)z.size() - 1; i &gt;= 0; i--) res = res * base + z[i]; return res * sign; &#125; friend bigint gcd(const bigint&amp; a, const bigint&amp; b) &#123; return b.isZero() ? a : gcd(b, a % b); &#125; friend bigint lcm(const bigint&amp; a, const bigint&amp; b) &#123; return a / gcd(a, b) * b; &#125; void read(const string&amp; s) &#123; sign = 1; z.clear(); int pos = 0; while(pos &lt; s.size() &amp;&amp; (s[pos] == '-' || s[pos] == '+')) &#123; if(s[pos] == '-') sign = -sign; ++pos; &#125; for(int i=(int)s.size()-1;i&gt;=pos;i-=base_digits) &#123; int x=0; for(int j=max(pos,i-base_digits+1);j&lt;=i;j++) x=x*10+s[j]-'0'; z.push_back(x); &#125; trim(); &#125; friend istream&amp; operator&gt;&gt;(istream&amp; stream, bigint&amp; v) &#123; string s; stream &gt;&gt; s; v.read(s); return stream; &#125; friend ostream&amp; operator&lt;&lt;(ostream&amp; stream, const bigint&amp; v) &#123; if(v.sign == -1) stream &lt;&lt; '-'; stream &lt;&lt; (v.z.empty() ? 0 : v.z.back()); for(int i = (int)v.z.size() - 2; i &gt;= 0; --i) stream &lt;&lt; setw(base_digits) &lt;&lt; setfill('0') &lt;&lt; v.z[i]; return stream; &#125; static vector&lt;int&gt; convert_base(const vector&lt;int&gt;&amp; a, int old_digits, int new_digits) &#123; vector&lt;long long&gt; p(max(old_digits, new_digits) + 1); p[0] = 1; for(int i=1;i&lt;p.size();i++) p[i]=p[i-1]*10; vector&lt;int&gt; res; long long cur = 0; int cur_digits = 0; for(int v : a) &#123; cur += v * p[cur_digits]; cur_digits += old_digits; while (cur_digits &gt;= new_digits) &#123; res.push_back(int(cur % p[new_digits])); cur /= p[new_digits]; cur_digits -= new_digits; &#125; &#125; res.push_back((int)cur); while(!res.empty() &amp;&amp; res.back()==0) res.pop_back(); return res; &#125; typedef vector&lt;long long&gt; vll; static vll karatsubaMultiply(const vll&amp; a, const vll&amp; b) &#123; int n=a.size(); vll res(n + n); if(n &lt;= 32) &#123; for (int i = 0; i &lt; n; i++) for (int j = 0; j &lt; n; j++) res[i + j] += a[i] * b[j]; return res; &#125; int k = n &gt;&gt; 1; vll a1(a.begin(), a.begin() + k); vll a2(a.begin() + k, a.end()); vll b1(b.begin(), b.begin() + k); vll b2(b.begin() + k, b.end()); vll a1b1 = karatsubaMultiply(a1, b1); vll a2b2 = karatsubaMultiply(a2, b2); for(int i=0;i&lt;k;i++) a2[i]+=a1[i]; for(int i=0;i&lt;k;i++) b2[i]+=b1[i]; vll r = karatsubaMultiply(a2, b2); for(int i=0;i&lt;a1b1.size();i++) r[i]-=a1b1[i]; for(int i=0;i&lt;a2b2.size();i++) r[i]-=a2b2[i]; for(int i=0;i&lt;r.size();i++) res[i+k]+=r[i]; for(int i=0;i&lt;a1b1.size();i++) res[i]+=a1b1[i]; for(int i = 0;i&lt;a2b2.size();i++) res[i+n]+=a2b2[i]; return res; &#125; bigint operator*(const bigint&amp; v) const &#123; vector&lt;int&gt; a6=convert_base(this-&gt;z,base_digits,6); vector&lt;int&gt; b6=convert_base(v.z,base_digits,6); vll a(a6.begin(),a6.end()); vll b(b6.begin(),b6.end()); while(a.size()&lt;b.size()) a.push_back(0); while(b.size()&lt;a.size()) b.push_back(0); while(a.size()&amp;(a.size()-1)) a.push_back(0),b.push_back(0); vll c=karatsubaMultiply(a, b); bigint res; res.sign = sign * v.sign; for (int i = 0, carry = 0; i &lt; c.size(); i++) &#123; long long cur = c[i] + carry; res.z.push_back((int)(cur % 1000000)); carry = (int)(cur / 1000000); &#125; res.z = convert_base(res.z, 6, base_digits); res.trim(); return res; &#125;&#125;;bigint qpow(bigint a,bigint b)&#123; bigint ans=1; while(b!=0)&#123; if(b%2)&#123; ans= ans*a; &#125; b/=2; a= a*a; &#125; return ans;&#125;struct Matrix&#123; bigint a[2][2]; Matrix() &#123; rep(i,0,2)&#123; rep(j,0,2)&#123; a[i][j]=0; &#125; &#125; &#125; Matrix operator * (const Matrix y) &#123; Matrix ans; for(int i = 0; i &lt; 2; i++) for(int j = 0; j &lt; 2; j++) for(int k = 0; k &lt; 2; k++) ans.a[i][j] = ans.a[i][j] + (a[i][k]*y.a[k][j]); return ans; &#125; Matrix operator = (const Matrix y) &#123; for(int i=0;i&lt;2;i++) for(int j=0;j&lt;2;j++) a[i][j]=y.a[i][j]; &#125; Matrix operator *= (const Matrix y) &#123; Matrix ans; for(int i=0;i&lt;2;i++) for(int j=0;j&lt;2;j++) for(int k=0;k&lt;2;k++) ans.a[i][j] = ans.a[i][j] + (a[i][k]*y.a[k][j]); for(int i=0;i&lt;2;i++) for(int j=0;j&lt;2;j++) a[i][j]=ans.a[i][j]; &#125;&#125;;Matrix qpow(bigint x)&#123; Matrix ans; ans.a[0][0]=ans.a[1][1]=1; //单位矩阵 Matrix mul; mul.a[0][0]=4; mul.a[0][1]=-1; mul.a[1][0]=1; mul.a[1][1]=0; while(x!=0) &#123; if(x%2!=0) ans = ans*mul; mul = mul* mul; x/=2; &#125; return ans;&#125;bigint ans[1005];void solve()&#123; ans[0]=(bigint)4; ans[1]=(bigint)14; ans[2]=(bigint)52; rep(i,2,200)&#123; ans[i]=(bigint)4*ans[i-1]-ans[i-2];// cout&lt;&lt;ans[i]&lt;&lt;endl; &#125;&#125;int main()&#123; solve(); int t;cin&gt;&gt;t; while(t--)&#123; bigint n; cin&gt;&gt;n; rep(i,0,200)&#123; if(ans[i]&gt;=n)&#123; cout&lt;&lt;ans[i]&lt;&lt;endl; break; &#125; &#125; &#125;&#125; 收获与反思证明待补充]]></content>
      <categories>
        <category>编程</category>
        <category>ACM</category>
      </categories>
      <tags>
        <tag>算法</tag>
        <tag>ACM</tag>
        <tag>2018秋季训练</tag>
        <tag>HDU</tag>
        <tag>大数</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[《枪炮、病菌与钢铁》读书笔记]]></title>
    <url>%2F2018%2F10%2F14%2F%E3%80%8A%E6%9E%AA%E7%82%AE%E3%80%81%E7%97%85%E8%8F%8C%E4%B8%8E%E9%92%A2%E9%93%81%E3%80%8B%E8%AF%BB%E4%B9%A6%E7%AC%94%E8%AE%B0%2F</url>
    <content type="text"><![CDATA[内容摘录与笔记前言 耶利的问题 P2“耶利的问题：‘为什么你们白人制造了那么多的货物并将它们运到新几内亚来，而我们黑人却几乎没有属于我们自己的货物呢？’” P3 “在普通新几内亚人的生活方式和普通欧洲人或普通美国人的生活方式之间仍然存在着巨大的差异。类似的差异同样把世界上其他民族的生活方式区别了开来。这些巨大的差异必定具有人们可能认为显而易见的重要原因。” P3 “关于这个问题的解决办法，专业的历史学家们仍然意见不一：大多数人甚至不再问这样的问题了。” P3 “在25年后撰写的本书就是试图对耶利的问题作出回答。” P10 “在传统的新几内亚社会中，聪明人比不那么聪明的人更有可能逃脱导致高死亡率的死因。然而，在传统的欧洲社会中，流行性疾病造成的死亡率的差异与智力几乎没有任何关系，而是与取决于人体化学细节的遗传抵抗力有关。例如，血型为B或O的人比血型为A的人对天花有更强的抵抗力。就是说，促进智力基因的自然选择，在新几内亚比在人口稠密、政治上复杂的社会可能要无情得多，因为在这样的社会里，对人体化学组成得自然选择反而更有效力。” 如果说之前读到得历史著作对历史进程必然性的分析是基于分布在各大陆的民族在政治、军事、文化等等方面的差异而来的，那么本书想要探究的则是这些差异的来源和产生模式。相较于讨论为什么欧洲人能够屠杀或者正如其他民族的直接原因，这本书着眼于分析，为什么是欧洲人而不是非洲人、亚洲人能够屠杀或者征服其他民族，这种差异是如何从零慢慢演变出来的。是对历史进程终极原因的探索。 P15 “新闻记者总使要求作者用一句话把篇幅很长的书加以概括。对本书来说，这样的一句话就是：‘不同民族的历史遵循不同的道路前进，其原因是民族环境的差异，而不是民族自身在生物学上的差异。’” 我更倾向于理解成，更主要的原因是…而不是…（阅读前） P19 “造成粮食生产传播速度差异的一个重大因素原来竟是大陆的轴线方向：欧亚大陆主要是东西向，而美洲和非洲则主要是南北向（第十章）。” P19 “第三部分（《从粮食到枪炮、病菌与钢铁》，第十一章到第十四章）从密籍人口所特有的病菌的演化开始，对从终极原因到近似原因的联系进行了考察（第十一章）。欧亚大陆的病菌杀死的印第安人和其他非欧亚大陆民族，比欧亚大陆的枪炮或钢铁武器所杀死的要多得多。相反，在新大陆，很少有或根本没有任何危险的病菌在等待未来的欧洲征服者。为什么病菌的交流这样不相等？在这里，近来分子生物学的研究成果在把病菌和粮食生产的出现相联系方面是富于启发性的，而这两者的联系在欧亚大陆要远远超过美洲。” P22 “然而，我希望我已经使读者相信，历史并不‘就是一个又一个讨厌的事实’，就像一个愤世嫉俗者说的那样。的确存在着始用于历史的广泛模式，而寻找这些模式的解释不但令人陶醉，也是大有裨益的。” 第一部分 从伊甸园到卡哈马卡第一章 走上起跑线——公元前11000年前各个大陆发生了些什么 P3 “用以比较不同大陆的历史发展的合适起点是公元前11000年左右。这个年代大致相当于世界上一些地区村社生活的开始。这时，美洲毫无疑问已经出现了首批定居者，更新世和上一次冰期已经结束，地质学家所说的全新世已经开始。在那个年代的几千年内，动植物的训话至少在世界上的一个地方开始了。从那时起，某些大陆上的族群是否已经比其他大陆上的族群领先一步或处于明显优势呢？” 本章想要探索的问题，快速浏览人类的初期历史，是否在很早期就在不同大陆上的人类演化产生了优劣之分，从而影响之后的历史进程。 P8 “我曾在《第三种黑猩猩》一书中主张，是喉的完善为现代语言提供了解剖学的基础，而发挥人的创造力是要大大依靠语言的。而另外一些人则提出，在当时脑容量不变的情况下脑组织发生的变化，使现代语言成为可能。” 大约10万年至5万年前，人类种族祖先能力发生巨大变化原因的两种解释。 在之后，4万年前，克罗马努人用他们现代人的体格，先进的文化，语言技能和智慧，或者变相利用他们身上的细菌，取代了欧洲的尼安德特人，没有证据证明两个早期人类种族的混合，更多的证据指向克罗马努人让尼安德特人不复存在。 这种种族本身的跃进和人类生存区域的重大扩张在时间上不谋而合。由非洲、亚欧大陆拓展到澳大利亚/新几内亚，以及在大陆板块快速扩散。 P9 “那时候，要从亚洲大陆到达澳大利亚/新几内亚，仍然需要渡过8个海峡，其中最宽的一个海峡至少有50英里宽。被大多数这样的海峡分隔开的岛屿彼此隔海相望，但从澳大利亚看不见印度尼西亚……因此，对澳大利亚/新几内亚的占有使一个重大事件，因为那需要有水运工具，因此这一点显然提供了关于历史上使用水运工具的最早证据” 还有人类的早期祖先们在各个大陆拓张过程中可能对一些大型哺乳动物带来的影响。 P11 “如此众多的大型动物几乎同时消失这一点引出了一个显而易见的问题：是什么造成了这种情况？一个显而易见的可能答案是：它们被首批到达的人类杀光或间接消灭了。” 由于这种大型哺乳动物灭绝不单单出现在澳大利亚/新几内亚地区，其他大陆包括后来的美洲，也同样出现了这样的灭绝现象，时间也与人类的首次到达和拓殖相差不多，更增添了这一假说的可能性。 也有一些人持气候变化印象，不过作者认为历经历史上的多次气候变化都没灭绝的一众物种都在人类足迹到达之后灭亡，难说是巧合。 P11 “我们知道，加拉帕戈斯群岛喝南极的鸟类喝哺乳动物同样也是在没有人类的情况下演化的，并且直到现代才看见了人，所以今天仍温顺得不可救药。如果不是环境保护主义者采取了保护性措施，它们可能已经很快灭绝了。在其他一些最近才发现的岛上，由于保护措施没有很快实施，消灭动物的事的确发生了：一个这样的受害者就是毛里求斯岛的渡渡鸟，渡渡鸟实际上已成了一种绝种的象征。” 很难不让人思考过去新西兰的恐鸟、马达加斯加的大狐猴喝夏威夷的巨型野鹅是不是也是由于相同原因在更早的时间灭绝。 P13 “从解剖学看，确实掌握了这种技术的现代民族（缝制衣服等抵御寒冷的技术），在大约2万年前进入西伯利亚（对此通常都有一些认为时间还要早得多的说法）。这一扩张可能就是欧亚大陆长毛象和长毛犀绝种的原因。” P19 “随着人类在美洲的定居，各个大陆和陆边岛屿以及从印度尼西亚到新几内亚东面的洋中岛，凡是可居住的大多数地区都有人类在生活。在世界上其余岛屿的定居直到现代才完成：地中海诸岛如克里特岛、塞浦路斯岛、科西嘉岛和撒丁岛约在公元前8500年到4000年之间；加勒比海诸岛从公元前4000年左右开始；波里尼西亚群岛和密克罗尼西亚群岛在公元前1200年到公元1000年之间；马达加斯加岛在公元300年到800年之间；冰岛在公元9世纪。美洲印第安人可能是现代伊努伊特人的祖先，他们大约在公元前2000年遍布北极附近地区。这样，在过去的700年中，唯一的无人居住、等待欧洲探险者光顾的地区就只剩下大西洋和印度洋中那些最偏远的岛屿（如亚速尔群岛和塞舌尔群岛）和南极大陆了。” P22 “因此，一个被送回到公元前11000年的观察者可能不会预测到哪个大陆上的人类社会会发展最快，但他可以提出充分的理由说明任何一个大陆都有这样的机会……欧亚大陆社会发展较快的真实原因根本不是我们所虚构的公元前11000年时的考古学家所猜测的那种直截了当的原因。本书以下篇幅所要研究的就是去发现那些真正的原因。” 去探索导致不同大陆发展差异，历史特殊性的真正原因。 第二章 历史的自然实验——地理因素是怎样塑造波利尼西亚群岛的社会的如果说达尔文在加拉帕戈斯群岛所观察到的“自然实验”是物种起源假说的有力证据，那本书作者对于人类社会在波利尼西亚群岛演化的“自然实验”则是为解决人类发展历史为何如此，是什么造成了历史，给出了可以分析的模式。 莫里奥里人与毛利人的冲突，虽是由相同祖先分化而来，环境的不同使两个地区的人类走上不同的演化道路，莫里奥里人回归狩猎采集的生活，坚持和平避免冲突的政策，而毛利人则走上集约农业的道路，信奉征服与掠夺。 P24 “这种相反的演化道路注定了他们最后冲突的结果。如果我们能够了解这两个岛屿社会向截然不同的方向发展的原因，我们也许就有了一个模式，用以了解各个大陆不同发展的更广泛的问题。” 这两个人类社会间的冲突又是波利尼西亚群岛这个中等规模“自然实验”下一个更微观的实验。 P28 “在波利尼西亚群岛之间，至少有6种环境可变因素促成了波利尼西亚社会之间的这些差异：岛屿气候、地址类型、海洋资源、面积、地形的破碎和隔离程度……” 第三章 卡哈马卡的冲突——为什么印加帝国皇帝阿塔瓦尔帕没有俘虏西班牙国王查理一世 P54 “因此，皮萨罗俘虏阿塔瓦尔帕这件事，表明了导致欧洲人向新大陆移民而不是美洲土著向欧洲移民的那组近似的因素。皮萨罗成功的直接原因包括：以枪炮、钢铁武器和马匹为基础的军事技术；欧亚大陆的传染性流行病；欧洲的航海技术；欧洲国家集中统一的行政组织和文字。本书的书名是这些近似因素的简略的表达，这些因素也使现代欧洲人能够去征服其他大陆的民族。” 划重点，本书的书名是这些近似因素的简略的表达。 第二部分 粮食生产的出现和传播第四章 农民的力量——枪炮、病菌与钢铁的根源 P58 “粮食生产是枪炮、病菌和钢铁发展的一个先决条件。因此，在不同大陆的族群是否或何时变成农民和牧人方面的地理差异，在很大程度上说明了他们以后截然不同的命运。” P64 “总之，动植物的驯化意味着人类的粮食越来越多，因而也就意味着人口越来越稠密。因此而带来的粮食和（在某些地区）利用畜力运输剩余量是，成了定居的、行政上集中统一的、社会等级分明额、经济上复杂的、技术上富有革新精神的社会的发展的先决条件。因此，能否利用驯化的动植物，最终说明了为什么帝国、知书写字和钢铁武器在欧亚大陆最早发展起来，而在其他大陆则发展较晚，或根本没有发展起来。” 第五章 历史上的穷与富——粮食生产开始时的地理差异 P67 “为什么粮食生产首先在看似相当贫瘠的土地上形成，只是到后来才在今天最肥沃的农田和牧场发展起来？” 确定古代遗存和年代以后，人们怎样确定这个动物或者植物是在附近驯化的，而不是在别处驯化，后来才传到这个遗址来的？ P70 “一个方法是研究这个作物或动物的野生祖先的地理分布图，并推断出驯化势必发生在野生祖先出现的地方。” P87 “确定某个作物或动物的驯化地点的第二个方法，是在地图上标出每个地区驯化物种首次出现的年代。出现年代最早的地点也许就是驯化最早的地点——而如果野生物种的祖先也在那里出现，且如果它们在其他地点首先出现的年代随着与推定的最早驯化地点距离的增加而渐次推后，从而表明驯化物种在向其他那些地点传播，情况就尤为如此。” P87 “一个极端情况是：有些地区的粮食生产完全是独立出现的……目前能够举出详细又令人信服的证据的这样的地区只有5个：西南亚，亦称近东或新月沃地；中国；中美洲（该词用来指墨西哥的中部和南部以及中美洲的毗连地区）；那美洲的安第斯山脉地区，可能还有亚马孙河流域的毗连地区；以及美国东部。在这些粮食生产中心中，有些中心或所有中心可能实际上包含了附近的几个或多或少独立出现的粮食生产的中心，如中国北方的黄河流域和中国南部的长江流域。” P92 “另一个极端情况是：有些地区的粮食生产毫无疑问不但是从外来作物和动物的引进开始的，而且也是从外来人的突然到来开始的。” 第六章 种田还是不种田——粮食生产传播的原因一个常见的错误观念：从到处流浪流浪的狩猎采集族群与定居的粮食生产者之间必定是界限分明。 P97 “粮食生产制度的渐次形成乃是许多关于时间和劳力分配的不同决定积累的结果。” P98 “觅食的人和觅食的动物一样，都在不断地按优先顺序来做出分配劳力的决定，哪怕是无意识地也是一样。他们首先集中注意力于最喜欢的食物，或者能够产生最高报偿的食物……在做出这些决定时要考虑许多问题。人们寻找食物是为了充饥果腹。他们也渴望得到一些特别的食物。如果所有其他情况相同，人们就用一种以最少的时间、最小的努力和最大的回报的方法去寻找食物。” P100 “我们必须把粮食生产同狩猎采集看作是相互竞争的供选择的方法。” 第七章 怎样识别杏仁——古代作物的无意识的发展 P110 “迄今为止，我们对野生植物演化为作物的描述的种种变化，与早期农民实际上可能已注意到的一些特征直接有关——如果实的大小、苦味、多肉、含油和纤维的长度。通过收获这些具有特别可取的品质的野生植物，古代人在无意识中传播了这些植物，使他们走上了驯化的道路。” 部分奇怪的突变本不利于植物在无人的环境下竞争，不过恰巧是这些突变利于人类对其驯化而保留了下来。 P111 “一个明显的例子就是豌豆。豌豆的种子（我们吃的豌豆）封闭在豆荚里。野豌豆要发芽生长，就必须破荚而出。为了做到这一点，豌豆就演化出一种基因，能使豆荚突然破裂，把豌豆弹射到地上。偶然产生突变的豌豆的豆荚不会爆裂。在野外，这种产生突变的豌豆一直到死都是包裹在亲株上的豆荚里面，而只有这种能爆裂的豆荚才能把它们的基因传递给后代。但与此相反的是，人类能够收获到的唯一豆荚可能就是留在植株上那些不爆裂的豆荚。因此，一旦人类开始把野豌豆带回家去吃，立刻就产生了对这种单基因突变的选择。对同样不爆裂突变进行选择的例子还有兵豆、亚麻和罂粟。” 与之相似的还有后文介绍的大麦和小麦，野生型麦秆可以自动脱落使得种子落到能够发芽生长的地面上，而突变型却保留在麦秆顶端，给人类的采集带来了方便，其后代同样保持了这样的性状，对这种突变品种的无意识选择，显然是人类对植物的第一个重大的“改良”，标志着新月沃地农业的开始。 第八章 问题在苹果还是印第安人——为什么有些地区的族群未能驯化植物 P127 “人类历史的主要事实之一，是西南亚的那个叫做新月沃地的地区在人类发展早期的重要性。那个地区似乎是包括城市、文字、帝国以及我们所说的文明（不论是福是祸）在内的一连串新情况发生的地方。而所有这些情况之所以发生，都是由于有了稠密的人口，有了剩余粮食的贮存，以及可以养活不从事农业的专门人材，凡此种种之所以可能又都是由于出现了以作物栽培和牲口饲养为形式的粮食生产。” 气候的原因——也影响了早期粮食生产基地的“选址” P146 “对美国东部驯化植物最了解的农民，就是这个地区的印第安人自己。他们在墨西哥三位一体的作物体系引进后宣判了当地驯化植物的命运：或者把它们完全抛弃，或者把它们的重要性降低。这个结果也表明了印第安人没有受到文化保守主义的束缚，而是在看到一种优良的植物时完全能够认识到它的价值。因此，同在新几内亚一样，美国东部土生土长的粮食生产所受到的限制，不是由于印第安人本身，而是完全决定于美洲的生物区系和环境。” 那么总结性的讲，限制粮食生产或者粮食生产发展水平的主要原因可以归结为下面一段话。 P147 “所有这些不存在本地粮食生产或只有有限的本地粮食生产的地区，都缺少可驯化的牲畜和谷物的野生祖先。” 关于第八章章节首部提出的问题的答案 P150 “因此，在欧洲人到达时，印第安人仍未能驯化北美的苹果，其原因不是印第安人，也不在苹果……印第安人未能驯化苹果的原因却是在于印第安人所能得到的整个野生动植物组合。这个组合的微弱的驯化潜力，就是北美粮食生产很晚才开始的主要原因。 第九章 斑马、不行的婚姻和安娜·卡列尼娜原则 P151 “可驯化的动物都是可以驯化的；不可驯化的动物各有各的不可驯化之处。” 即可以驯化的大型哺乳动物是要求符合多种条件的，这些条件都是“被驯化”这一结果的必要条件，而缺少其中任一（甚至被干扰）都会影响到大型哺乳动物的驯化。 P170 “人类同大多数动物缔结了一种不幸的婚姻，这是由于许多可能的原因中的一个或多个原因造成的：动物的日常食物、生长速度、交配习惯、性情、容易受惊的倾向以及群居组织的几个不同的特点。只有很少一部分野生哺乳动物由于在上述所有这些方面都能协调一致而最终得以和人类结成美满的婚姻” 第十章 辽阔的天空与偏斜的轴线 P173 “轴线走向影响了作物和牲口的传播速度，可能还影响文字、车轮和其他发明的传播速度。这种基本的地理特征在过去500年中队印第安人、非洲人和欧亚大陆人十分不同的经验的形成起了巨大的促进作用。” 关于“抢先驯化现象”：可以反应作物在大陆上的传播速度可以利用“抢先驯化现象”，即如果某一未驯化可利用作物的地方，当面临该作物的野生祖先和传播而来的变种（驯化）作物，可以推断出当地人类会选择后者，因而不会再进行一次其野生祖先的驯化。 因而，通过遗传分析，可以得到的结果是：欧亚大陆驯化的古代作物多数显示出只有一个不同的野生变种或不同的转化突变体，即反应出一次可利用的驯化。但新大陆的驯化作物则常常出现至少两个，即在不同场合独立的出现了驯化现象。这说明，新大陆对比欧亚大陆，前期驯化成果并没有迅速传播开来，侧面反映了粮食传播的速度差异。 进一步的 P176 “某种作物的迅速传播可能不但抢先阻止了同一植物的野生祖先在其他地方的驯化，而且也阻止了有亲缘关系的野生植物的驯化。” P180 “为什么作物从新月沃地向外传播的速度如此之快？回答部分地取决于我在本章开始时谈到的欧亚大陆的东西向周线。位于同一纬度地东西两地，白天的长度和季节的变化完全相同。在较小程度上，它们也往往具有类似的疾病、温度和雨量情势以及动植物生境或生物群落区（植被类型）。”]]></content>
      <categories>
        <category>阅读</category>
      </categories>
      <tags>
        <tag>阅读</tag>
        <tag>历史</tag>
        <tag>贾雷德·戴蒙德</tag>
        <tag>枪炮、病菌与钢铁</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[金融学辅修——金融学笔记（三）]]></title>
    <url>%2F2018%2F10%2F12%2F%E9%87%91%E8%9E%8D%E5%AD%A6%E8%BE%85%E4%BF%AE%E2%80%94%E2%80%94%E9%87%91%E8%9E%8D%E5%AD%A6%E7%AC%94%E8%AE%B0%EF%BC%88%E4%B8%89%EF%BC%89%2F</url>
    <content type="text"><![CDATA[课前同学分享 庞氏骗局 新用户的资金补贴旧用户，没有新用户加入进来的时候，资金链断裂 江小白发展困境与银行的最后贷款人功能 白芝浩 资管行业三十年蝶变 资产管理：管理资产和风险 基金崛起：公募基金2000年以前以封闭式基金为主，01年-07年黄金发展期，迅速发展，08年-13年股票型和股票型发展势头迅猛。 信托行业转向主动管理。07年至今规范化。 定位与发展 基金：银行理财：信托： 第三章 信用与信用工具什么是信用，信用形式，信用工具，信用与经济（普惠金融）。 第一节 什么是信用信用的含义 Credit，就是相信，信托和声誉。 日常生活中的信用是诚实、守信。 经济学含义是借贷活动的总称，就是债。 指不同所有者之间以偿还本金和支付利息为条件的借贷行为。是市场经济运行规则、市场经济交易方式、一种经济关系。 “信用经济”： 信用与借贷信用与债权债务时同时发生的，时借贷活动的两个方面：在借贷活动中，当事人一方为债权人，他将商品或货币贷出，称为授信；另一方面为债务人，他接受债权人的商品或货币，称为受信；债务人遵守承诺按期偿还商品或货币并支付利息，称为守信。任何时期的债务总额等于信用总量。 社会信用体系：政府信用，企业信用，个人信用。 信用的特点 以所有权与使用权相分离的资金为信用的标的 以还本付息为条件 以相互信任为基础 以收益最大化为目标 借贷双方利益最大化 5. 信用的构成要素 信用的主体：债权人（creditor）与债务人（debtor） 信用标的物：货币资金与实物资金 信用条件：期限与利息 信用工具：（金融工具：记载信用标的，保护债权人权利，具备法律效力的书面凭证） 以口头承诺，账面信用为依据。（没有工具化） 以正式的书面凭证为依据，如借贷契约。（没有流动化） 可在流通市场上转让的信用，如债券（流动化） 信用的基本功能与基本形式 基本功能 资金配置 信用创造 信息传播 宏观调控 信用形式 以期限为标准——长期信用与短期信用 以低于为标准——国内信用与国际信用 以信用主体为标准——商业信用/银行信用/消费信用/国家信用/合作信用/高利贷信用/国际信用等调控 关于高利贷信用，并非政治经济学里面贬义的意思。 官方界定上有正规、非正规、非法。高利贷信用处于非正规和非法的灰色地带。评价注意客观性。 一个企业可能取得的融资方式 企业通过签发商业票据赊账——商业信用 企业以土地等抵押给银行取得商业性贷款，或者政府取得政策性贷款——银行信用 捆包优质资产上市，以固定资产为抵押，企业债券——证券信用 股东同意，减少红利获得更多公积金——内源融资 其他国家发行外国，国际市场发行欧洲债券，背对背协议——国际融资 第二节 信用的形式商业信用 含义 工商企业之间相互提供的，与商品交易直接向联系的信用形式。 方式 赊销，赊购，分期付款。 银行信用 含义 银行信用是指各种金融机构，特别是银行，以存、放款等多种业务形式向工商企业和个人提供的货币形态 的信用，它是在商业信用基础上发展起来的一种更高层次的信用。 地位 克服了资金力量、资信程度、提供方向方面的局限性，能通过对商业票据贴现为商业信用的进一步发展提供了条件， 从而能使它成为整个经济社会信用体系中占据核心地位，成为一国信用关系中的主体。 主要作用 国家信用 国家信用 是国家（包括各级政府）作为债务人，以发行政府债券或借款的方式向国内外企事业单位、团体、居民个人等筹集资金的借贷行为。 基本方式 发行债券（国内债务和国际债务）借款 国债的主要作用 筹措战争费用（战争时期） 平衡财政赤字，缓解货币流通，保持物价稳定（赤字国债） 筹措国家建设资金，举借内债影响经济增长（建设国债） 偿还到期国债（借换国债） 财政支出=财政收入+]]></content>
      <categories>
        <category>金融</category>
        <category>金融学</category>
      </categories>
      <tags>
        <tag>课堂笔记</tag>
        <tag>辅修</tag>
        <tag>金融学</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[金融学辅修——金融学笔记（二）]]></title>
    <url>%2F2018%2F10%2F08%2F%E9%87%91%E8%9E%8D%E5%AD%A6%E8%BE%85%E4%BF%AE%E2%80%94%E2%80%94%E9%87%91%E8%9E%8D%E5%AD%A6%E7%AC%94%E8%AE%B0%EF%BC%88%E4%BA%8C%EF%BC%89%2F</url>
    <content type="text"><![CDATA[课前同学分享 离岸人民币市场离岸市场：目标货币发行国境外的货币交易中心 课后补充，美元本位？马歇尔计划？欧洲美元市场。伦敦拆借市场-&gt;欧洲货币市场。 租房贷房东，中介，用户，传统三元模式随着互联网的发展，中介的传统职能被互联网有所替代。不过新的房东，用户二元模式，又存在一些问题。 新三元模式中介面临资金链紧张的问题，故金融机构逐渐引入。租房贷的实质：中介公司 解决方式： 加强监管：透明化和规范化 风险主要分为信用风险和流动风险，信用风险一方面涉及 第四节 货币制度我国的货币制度 我国的法定货币是人民币。 人民币是我国唯一合法流通货币。 人民币的发行实行高度集中统一于中国人民银行。 人民币的发行保证是国家拥有的商品物资，黄金外汇储备主要是作为国际支付的准备金。 纸币发行准备制度的方式： 以黄金或外汇储备准备的发行 无准备发行 第二钟以港币发行为例。香港地方三家银行汇丰， 央行可以通过行政命令，直接宣布汇率变化，来影响 金属本位金银复本位 平行本位：即金银币平等，同事都是本位币，都可以自由铸造和融化自由地输出入国境，金银币的交易比率由市场决定，国家没有法律规定。 问题：由于任一商品都拥有两个价格，比例随金银比价波动，造成价格混乱，给交易带来了很多麻烦。 双本位：格雷欣法则，劣币驱逐良币 劣币驱逐良币律Gresham’s Law：金银复本位制下，两种实际价值不同而含义相同的金属铸币流通时，实际价值高的会通过熔化， 储藏或者到国外而退出流通。 跛行本位 金币可以自由铸造，但是银币不能自由铸造，只可以无限偿还。 金本位制的三种形式 金币本位：纯粹的金币本为： 自由铸造，自由兑换，自由输出入国境 金块本位：金币不再流通，黄金纸币不可自由兑换，一定限额。 两次世界大战期间英法实行，黄金储备不够不足以支持自由兑换（富人本位）。 金汇兑本位：不铸造金币，市场上不流通，本币不可兑换黄金，但本币可以以固定汇率兑换成某一实行金币或金块本位的国家的货币，并在该国兑换黄金。（无法兑换，提供其他两种本位的一个固定汇率关系） 纸币与黄金的关系进一步弱化。 第五节 国际货币体系“黄金——美元”本位制的布雷顿森立体系，美元本位制牙买加体系。 国际货币制度的研边国际金本位制度（1880-1913） =&gt; 浮动汇率制度（1914-1944） =&gt; 布雷顿森林体系（1945-1973） =&gt; 牙买加体系（1978） 国际金本位制特点： 原因 黄金产量不足，长期通货紧缩 黄金产品分布不均 第一次世界大战爆发的刺激 布雷顿森林体系的建立“双挂钩一固定” 美元同黄金挂钩，其他货币与美元挂钩。美元与黄金兑换固定（35美元1盎司）。]]></content>
      <categories>
        <category>金融</category>
        <category>金融学</category>
      </categories>
      <tags>
        <tag>课堂笔记</tag>
        <tag>辅修</tag>
        <tag>金融学</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[【UVALive-7734】解题报告（水题）]]></title>
    <url>%2F2018%2F10%2F07%2F%E3%80%90UVALive-7734%E3%80%91%E8%A7%A3%E9%A2%98%E6%8A%A5%E5%91%8A%EF%BC%88%E6%B0%B4%E9%A2%98%EF%BC%89%2F</url>
    <content type="text"><![CDATA[原始题目 题目大意给出$n$种物品每种的个数和价值，求价值总和。 解题思路求和 解题代码1234567891011121314151617181920212223242526272829303132333435363738394041#include&lt;bits/stdc++.h&gt;#include&lt;algorithm&gt;#define rep(i,a,n) for(int i=a;i&lt;n;++i)#define per(i,a,n) for(int i=n-a;i&gt;=a;--i)#define fi first#define se second#define cl(x,a) memset(x,a,sizeof(x))#define all(x) x.begin(),x.end()#define INF 0x3f3f3f3f#define EPS 1e-9#define mod 1000000007using namespace std;const int maxn=1e5+5;const int maxm=1e5+5;typedef long long ll;typedef unsigned long long ull;typedef vector&lt;int&gt; vi;typedef pair&lt;int,int&gt; pii;int t,n,m;int main()&#123; ios::sync_with_stdio(false); cin&gt;&gt;t; while(t--)&#123; cin&gt;&gt;n; ll ans=0; rep(i,0,n)&#123; int a,b; cin&gt;&gt;a&gt;&gt;b; ans+=a*b; &#125; cout&lt;&lt;ans&lt;&lt;endl; &#125;&#125; 收获与反思暂无]]></content>
      <categories>
        <category>编程</category>
        <category>ACM</category>
      </categories>
      <tags>
        <tag>算法</tag>
        <tag>ACM</tag>
        <tag>2018秋季训练</tag>
        <tag>UVALive</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[【UVALive-7737】解题报告（概率，时间独立性，暴力）]]></title>
    <url>%2F2018%2F10%2F07%2F%E3%80%90UVALive-7737%E3%80%91%E8%A7%A3%E9%A2%98%E6%8A%A5%E5%91%8A%EF%BC%88%E6%A6%82%E7%8E%87%EF%BC%8C%E6%97%B6%E9%97%B4%E7%8B%AC%E7%AB%8B%E6%80%A7%EF%BC%8C%E6%9A%B4%E5%8A%9B%EF%BC%89%2F</url>
    <content type="text"><![CDATA[原始题目 题目大意Bob想从$n$种硬币中选出一种幸运硬币。选择策略如下： 如果当前没有剩下的硬币或者只剩下一种硬币，则该硬币为幸运硬币。 否则，将现有硬币抛出后，保留所有正面朝上的硬币。 给出每种硬币抛出后正面朝上的概率，计算各种硬币成为幸运硬币的概率。 解题思路由于题目中更说明：每种硬币抛出后正面朝上的概率在0.4和0.6之间 易分析知抛得次数可能是无限的，但连续一百次正面朝上的概率已经很小（精度要求内可忽略不计），想到打表。 $alive[i][j]$ 表示第i种硬币能存留到第j次抛出之前。 $dead[i][j]$ 表示第i种硬币不能存留到第j次抛出之前。 则最终答案为 $ans[i]= \sum (alive[i][j]-alive[i][j+1])*( \sum dead[k][j]) $ 解题代码123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384#include&lt;bits/stdc++.h&gt;#include&lt;algorithm&gt;#define rep(i,a,n) for(int i=a;i&lt;n;++i)#define per(i,a,n) for(int i=n-a;i&gt;=a;--i)#define fi first#define se second#define cl(x,a) memset(x,a,sizeof(x))#define all(x) x.begin(),x.end()#define INF 0x3f3f3f3f#define EPS 1e-9#define mod 1000000007#define FF 150using namespace std;const int maxn=1e3+5;const int maxm=1e5+5;typedef long long ll;typedef unsigned long long ull;typedef vector&lt;int&gt; vi;typedef pair&lt;int,int&gt; pii;int t,n,m;int num[maxn];double p[maxn];double dead[maxn][FF];double alive[maxn][FF];double ans[maxn];double qpow(double a,int x)&#123; double ans=1.0; while(x)&#123; if(x&amp;1) ans *=a; a*=a; x&gt;&gt;=1; &#125; return ans;&#125;void solve()&#123; rep(i,1,n+1)&#123; rep(j,1,FF)&#123; double temp=qpow(p[i],j); dead[i][j]=qpow((1.0-temp),num[i]); alive[i][j]=1.0-dead[i][j]; &#125; &#125;&#125;int main()&#123; ios::sync_with_stdio(false); cin&gt;&gt;t; while(t--)&#123; cin&gt;&gt;n; rep(i,1,n+1)&#123; cin&gt;&gt;num[i]&gt;&gt;p[i]; &#125; if(n==1)&#123; cout&lt;&lt;fixed&lt;&lt;setprecision(6)&lt;&lt;1.0&lt;&lt;endl; continue; &#125; memset(alive,0,sizeof(alive)); memset(dead,0,sizeof(dead)); solve(); rep(i,1,n+1)&#123; ans[i]=0; rep(j,1,FF)&#123; double temp=1.0; rep(k,1,n+1)&#123; if(i==k) continue; else&#123; temp*=dead[k][j]; &#125; &#125; ans[i]+=temp*(alive[i][j]-alive[i][j+1]); &#125; &#125; cout&lt;&lt;fixed&lt;&lt;setprecision(6)&lt;&lt;ans[1]; rep(i,2,n+1)&#123; cout&lt;&lt;" "&lt;&lt;fixed&lt;&lt;setprecision(6)&lt;&lt;ans[i]; &#125; cout&lt;&lt;endl; &#125;&#125; 收获与反思注意分析概率的公式。]]></content>
      <categories>
        <category>编程</category>
        <category>ACM</category>
      </categories>
      <tags>
        <tag>算法</tag>
        <tag>ACM</tag>
        <tag>2018秋季训练</tag>
        <tag>UVALive</tag>
        <tag>概率</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[【CSU-1112】解题报告（模拟，水题）]]></title>
    <url>%2F2018%2F10%2F07%2F%E3%80%90CSU-1112%E3%80%91%E8%A7%A3%E9%A2%98%E6%8A%A5%E5%91%8A%EF%BC%88%E6%A8%A1%E6%8B%9F%EF%BC%8C%E6%B0%B4%E9%A2%98%EF%BC%89%2F</url>
    <content type="text"><![CDATA[原始题目1112: 机器人的指令 Time Limit: 1 Sec Memory Limit: 128 Mb Submitted: 3392 Solved: 1245 Description数轴原点有一个机器人。该机器人将执行一系列指令，你的任务是预测所有指令执行完毕之后它的位置。 LEFT：往左移动一个单位 RIGHT: 往右移动一个单位 SAME AS i: 和第i 条执行相同的动作。输入保证i 是一个正整数，且不超过之前执行指令数 Input输入第一行为数据组数$T (T≤100)$。每组数据第一行为整数 $n (1≤n≤100) $，即指令条数。以下每行一条指令。指令按照输入顺序编号为$1 \cdots n$。 Output对于每组数据，输出机器人的最终位置。每处理完一组数据，机器人应复位到数轴原点。 Sample Input2 3 LEFT RIGHT SAME AS 2 5 LEFT SAME AS 1 SAME AS 2 SAME AS 1 SAME AS 4 Sample Output1 -5 HintSource湖南省第八届大学生计算机程序设计竞赛 题目大意如题 解题思路储存每一操作，线性扫。 解题代码12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455#include &lt;cstdio&gt;#include&lt;cstring&gt;#include &lt;set&gt;#include &lt;string&gt;#include &lt;iostream&gt;#include &lt;iomanip&gt;#include &lt;queue&gt;#include &lt;vector&gt;#include &lt;map&gt;#include &lt;algorithm&gt;#define rep(i,a,n) for(int i=a;i&lt;n;++i)#define per(i,a,n) for(int i=n-1;i&gt;=a;--i)#define cl(x,a) memset(x,a,sizeof(x))#define all(x) x.begin(),x.end()#define INF 0x3f3f3f3f#define EPS 1e-9#define mod 1000000007#define fi first#define se secondusing namespace std;const int maxn=1e5+5;typedef long long ll;typedef unsigned long long ull;typedef vector&lt;int&gt; vi;typedef pair&lt;int,int&gt; pii;int t,n,m,a;int num[maxn];string ctl;int main()&#123; ios::sync_with_stdio(false); cin&gt;&gt;t; while(t--)&#123; int temp=0; cin&gt;&gt;n; rep(i,1,n+1)&#123; cin&gt;&gt;ctl; if(ctl[0]=='S')&#123; cin&gt;&gt;ctl&gt;&gt;a; num[i]=num[a]; &#125; else if(ctl[0]=='L')&#123; num[i]=-1; &#125; else num[i]=1; &#125; rep(i,1,n+1)&#123; temp+=num[i]; &#125; cout&lt;&lt;temp&lt;&lt;endl; &#125;&#125; 收获与反思暂无]]></content>
      <categories>
        <category>编程</category>
        <category>ACM</category>
      </categories>
      <tags>
        <tag>算法</tag>
        <tag>ACM</tag>
        <tag>CSU</tag>
        <tag>Imitation</tag>
        <tag>2018秋季训练</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[【CSU-1104】解题报告（博弈游戏，找规律）]]></title>
    <url>%2F2018%2F10%2F07%2F%E3%80%90CSU-1104%E3%80%91%E8%A7%A3%E9%A2%98%E6%8A%A5%E5%91%8A%EF%BC%88%E5%8D%9A%E5%BC%88%E6%B8%B8%E6%88%8F%EF%BC%8C%E6%89%BE%E8%A7%84%E5%BE%8B%EF%BC%89%2F</url>
    <content type="text"><![CDATA[原始题目]]></content>
      <categories>
        <category>编程</category>
        <category>ACM</category>
      </categories>
      <tags>
        <tag>算法</tag>
        <tag>ACM</tag>
        <tag>CSU</tag>
        <tag>博弈</tag>
        <tag>2018秋季培训</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[金融学辅修——金融学笔记（一）]]></title>
    <url>%2F2018%2F09%2F26%2F%E9%87%91%E8%9E%8D%E5%AD%A6%E8%BE%85%E4%BF%AE%E2%80%94%E2%80%94%E9%87%91%E8%9E%8D%E5%AD%A6%E7%AC%94%E8%AE%B0%EF%BC%88%E4%B8%80%EF%BC%89%2F</url>
    <content type="text"><![CDATA[第一节 什么是货币金融学的起点，也是金融学的终点。所有金融现象、金融行为都是某种程度的或大或小的货币事件。 货币就是金钱，信用就是金钱，金钱可生金钱。货币决定未来世界格局。 IMF，国际货币基金组织，成员国，运行“份子”根据本国对外贸易占世界贸易中的比重，以及GDP水平等来衡量。投票权重与“份子”相关，百分之十五决议通过，而目前美元比重占比17%，所以几乎等于断言。IMF也是随着布雷顿森林体系的建立而崛起的。 货币的产生中国古代货币起源说（解决民间秒换困难，沟通产品交换的手段）。 西方货币起源说（创造发明说，便于交换说，保存财富说）。 马克思货币起源说（货币是商品生产和商品交换发展的必然产物，是商品经济内在矛盾发展的必然结果）。 进一步解释马克思的解释： 简单的物物交换=&gt;复杂的物物交换=&gt;（规模逐渐发展，信用，复杂程度等多方面影响）=&gt;货币的产生 货币的本质货币金属说，货币名目说，劳动价值说。 货币的定义经济学中成为货币的东西，就是人们日常生活中的钱的东西。由于时代背景，观察角度、观察深度不同以及侧重于理论剖析与侧重于解决实际问题需要不同，定义表述不同。 本质定义：从商品交换中分离出来固定地充当一般等价物的特殊商品。 经济学定义：在商品或劳务支付中或债务偿还中被普遍接受的任何东西。 法定货币（法律定义）：通过立法授予某种物品具有清偿债务的合法权利。 层次定义（计量定义）： M0=流通中现金（通货） M1=M0+企业活期存款+农业存款+]]></content>
      <categories>
        <category>金融</category>
        <category>金融学</category>
      </categories>
      <tags>
        <tag>课堂笔记</tag>
        <tag>辅修</tag>
        <tag>金融学</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[【CSU-1111】解题报告（水题）]]></title>
    <url>%2F2018%2F09%2F07%2F%E3%80%90CSU-1111%E3%80%91%E8%A7%A3%E9%A2%98%E6%8A%A5%E5%91%8A%EF%BC%88%E6%B0%B4%E9%A2%98%EF%BC%89%2F</url>
    <content type="text"><![CDATA[原始题目1111: 三家人 Time Limit: 1 Sec Memory Limit: 128 Mb Submitted: 4053 Solved: 1606 Description有三户人家共拥有一座花园，每户人家的太太均需帮忙整理花园。A 太太工作了5 天，B 太太则工作了4 天，才将花园整理完毕。C 太太因为正身怀六甲无法加入她们的行列，便出了90元。请问这笔钱如何分给A、B 二位太太较为恰当？A 应得多少元？$ 5 \times \frac {90} {5+4}= 50 $？如果这么想你就上当了！正确答案是60 元。如果没想通的话再想想吧。 下面回答一个一般性的问题：假定A 太太工作了x 天，B 太太工作了y 天，C 太太出了90元，则A 太太应得多少元？输入保证二位太太均应得到非负整数元钱。三个太太工作效率相同。 友情提示：本题有个小小的陷阱哦。如果答案错的话，认真检查一下代码吧。 Input输入第一行为数据组数$T (T ≤ 20) $。每组数据仅一行，包含三个整数 $x, y, z (1 ≤ x, y ≤10,1 ≤ z ≤1000) $。 Output对于每组数据，输出一个整数，即A 太太应得的金额（单位：元）。 Sample Input2 5 4 90 8 4 123 Sample Output60 123 Hint如果使用浮点数，请小心误差，输出时尽量用四舍五入。 Source湖南省第八届大学生计算机程序设计竞赛 题目大意如题 解题思路考虑每个人都应该完成$ \frac {1}{3} $ 的工作量。再按多余完成量分配钱，注意考虑工作量不够自己应该完成的情况。 解题代码123456789101112131415161718192021222324252627282930313233#include &lt;cstdio&gt;#include &lt;cstring&gt;#include &lt;iostream&gt;#include &lt;iomanip&gt;#include &lt;cstdlib&gt;#include &lt;set&gt;#include &lt;string&gt;#include &lt;cstring&gt;#include &lt;stack&gt;#define rep(i,a,n) for(int i=a;i&lt;n;++i)#define per(i,a,n) for(int i=n-1;i&gt;=a;--i)using namespace std;const int maxn=1e5+5;const int maxl=26;int t,n;double x,y,z; int main()&#123; ios::sync_with_stdio(false); cin&gt;&gt;t; while(t--)&#123; cin&gt;&gt;x&gt;&gt;y&gt;&gt;z; double ans=(x+y)/3.0; if(ans&gt;(double)x) cout&lt;&lt;0&lt;&lt;endl; else if(ans&gt;(double)y) cout&lt;&lt;fixed&lt;&lt;setprecision(0)&lt;&lt;z&lt;&lt;endl; else &#123; x-=ans; y-=ans; cout&lt;&lt;fixed&lt;&lt;setprecision(0)&lt;&lt;z*x/(x+y)&lt;&lt;endl; &#125; &#125;&#125; 收获与反思水题]]></content>
      <categories>
        <category>编程</category>
        <category>ACM</category>
      </categories>
      <tags>
        <tag>算法</tag>
        <tag>ACM</tag>
        <tag>CSU</tag>
        <tag>2018暑假集训</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[【CSU-1115】解题报告（字典树）]]></title>
    <url>%2F2018%2F09%2F07%2F%E3%80%90CSU-1115%E3%80%91%E8%A7%A3%E9%A2%98%E6%8A%A5%E5%91%8A%EF%BC%88%E5%AD%97%E5%85%B8%E6%A0%91%EF%BC%89%2F</url>
    <content type="text"><![CDATA[原始题目1115: 最短的名字 Time Limit: 5 Sec Memory Limit: 64 Mb Submitted: 2057 Solved: 801 Description在一个奇怪的村子中，很多人的名字都很长，比如aaaaa, bbb and abababab。 名字这么长，叫全名显然起来很不方便。所以村民之间一般只叫名字的前缀。比如叫’aaaaa’的时候可以只叫’aaa’，因为没有第二个人名字的前三个字母是’aaa’。不过你不能叫’a’，因为有两个人的名字都以’a’开头。村里的人都很聪明，他们总是用最短的称呼叫人。输入保证村里不会有一个人的名字是另外一个人名字的前缀（作为推论，任意两个人的名字都不会相同）。 如果村里的某个人要叫所有人的名字（包括他自己），他一共会说多少个字母？ Input输入第一行为数据组数$T (T≤10)$。每组数据第一行为一个整数n$(1≤n≤1000)$ ，即村里的人数。以下$n$行每行为一个人的名字（仅有小写字母组成）。输入保证一个村里所有人名字的长度之和不超过 $10^{6}$。 Output对于每组数据，输出所有人名字的字母总数。 Sample Input1 3 aaaaa bbb abababab Sample Output5 HintSource湖南省第八届大学生计算机程序设计竞赛 题目大意如题 解题思路建立字典树，每个结点的value值储存单词字母的出现次数。 对于每个单词，统计第一个出现value值为1的位置（表示到这里后面没有相同单词前缀） 求和，完成任务 解题代码123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109#include &lt;cstdio&gt;#include &lt;cstring&gt;#include &lt;iostream&gt;#include &lt;cstdlib&gt;#include &lt;set&gt;#include &lt;string&gt;#include &lt;cstring&gt;#include &lt;stack&gt;#define rep(i,a,n) for(int i=a;i&lt;n;++i)#define per(i,a,n) for(int i=n-1;i&gt;=a;--i)using namespace std;const int maxn=1e5+5;const int maxl=26;typedef long long ll;typedef struct Trie&#123; int v; Trie* next[maxl];&#125;Trie; Trie *root;void iniTrie()&#123; root=(Trie*)malloc(sizeof(Trie)); for(int i=0;i&lt;maxl;i++) root-&gt;next[i]=NULL; root-&gt;v=-1;&#125;bool creTrie(string a)&#123; int l=a.length(); Trie *p=root,*q; for(int i=0;i&lt;l;i++) &#123; int id=a[i]-&apos;a&apos;; //并非前缀不能有相同，而是不能在相同的分支上。 // if(i==l-1)&#123;// if(p-&gt;next[id]!=NULL) return 0;// &#125; if(p-&gt;next[id]==NULL)&#123; q=(Trie*) malloc(sizeof(Trie)); q-&gt;v=1; for(int j=0;j&lt;maxl;j++) q-&gt;next[j]=NULL; // //结点连接到树上 p-&gt;next[id]=q; p=p-&gt;next[id]; &#125; else&#123; p=p-&gt;next[id]; p-&gt;v++; &#125; &#125; return 1;&#125;int cntTrie(string ss)&#123; int l=ss.length(); Trie *p=root,*q; for(int i=0;i&lt;l;i++) &#123; int id=ss[i]-&apos;a&apos;; p=p-&gt;next[id]; if(p-&gt;v==1) return i+1; &#125;&#125;void delTrie(Trie *p) &#123; int i; for(i=0;i&lt;maxl;i++) &#123; if(p-&gt;next[i] != NULL) delTrie(p-&gt;next[i]); &#125; free(p);// printf(&quot;1&quot;); p==NULL; return ;&#125; string s[maxn];int t,ccount,n;int main()&#123; ios::sync_with_stdio(false); cin&gt;&gt;t; while(t--)&#123; iniTrie(); cin&gt;&gt;n; rep(i,0,n)&#123; cin&gt;&gt;s[i]; creTrie(s[i]); &#125; int aans=0; rep(i,0,n)&#123; aans+=cntTrie(s[i]); &#125; cout&lt;&lt;aans&lt;&lt;endl; delTrie(root); &#125;&#125; 收获与反思灵活运用字典树的染色和统计功能]]></content>
      <categories>
        <category>编程</category>
        <category>ACM</category>
      </categories>
      <tags>
        <tag>算法</tag>
        <tag>ACM</tag>
        <tag>CSU</tag>
        <tag>2018暑假集训</tag>
        <tag>字典树</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[【CSU-1101】解题报告（水题，模拟）]]></title>
    <url>%2F2018%2F09%2F04%2F%E3%80%90CSU-1101%E3%80%91%E8%A7%A3%E9%A2%98%E6%8A%A5%E5%91%8A%EF%BC%88%E6%B0%B4%E9%A2%98%EF%BC%8C%E6%A8%A1%E6%8B%9F%EF%BC%89%2F</url>
    <content type="text"><![CDATA[原始题目1101: 报数游戏 Time Limit: 1 Sec Memory Limit: 128 Mb Submitted: 1400 Solved: 474 Descriptionn个人站成一行玩一个报数游戏。所有人从左到右编号为1到n。游戏开始时，最左边的人报1，他右边的人报2，编号为3的人报3，等等。当编号为n的人（即最右边的人）报完n之后，轮到他左边的人（即编号为n-1的人）报n+1，然后编号为n-2的人报n+2，以此类推。当最左边的人再次报数之后，报数方向又变成从左到右，依次类推。为了防止游戏太无聊，报数时有一个特例：如果应该报的数包含数字7或者是7的倍数，他应当用拍手代替报数。下表是n=4的报数情况（X表示拍手）。当编号为3的人第4次拍手的时候，他实际上数到了35。 给定$n,m,k$，你的任务是计算当编号为 $m$ 的人第 $k$ 次拍手时，他实际上数到了几。 Input输入包含不超过10组数据。每组数据占一行，包含三个整数 $n,m$ 和 $k$ $( 2 ≤ n ≤ 100, 1 ≤ m ≤n, 1 ≤ k ≤ 100)$。输入结束标志为 $n=m=k=0$。 Output对于每组数据，输出一行，即编号为 $m$ 的人第 $k$ 次拍手时，他实际上数到的那个整数。 Sample Input4 3 1 4 3 2 4 3 3 4 3 4 0 0 0 Sample Output17 21 27 35 HintSource湖南省第七届大学生计算机程序设计竞赛 题目大意如题 解题思路直接模拟 解题代码12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364656667686970#include &lt;cstdio&gt;#include &lt;cstring&gt;#include &lt;cstdlib&gt;#include &lt;string&gt;#include &lt;iostream&gt;#include &lt;iomanip&gt;#include &lt;queue&gt;#include &lt;stack&gt;#include &lt;vector&gt;#include &lt;set&gt;#include &lt;map&gt;#include &lt;algorithm&gt;#include &lt;bits/stdc++.h&gt;#define fi first#define se second#define rep(i,a,n) for(int i=a;i&lt;n;++i)#define per(i,a,n) for(int i=n-1;i&gt;=a;--i)#define cl(x,a) memset(x,a,sizeof(x)) #define all(x) x.begin,x.end()#define INF 0x3f3f3f3f#define eps 1e-8using namespace std;typedef long long ll;typedef unsigned long long ull;typedef vector&lt;int&gt; vi;typedef pair&lt;int,int&gt; pii;typedef pair&lt;string,string&gt; pss;const int maxn=1e5+5;const int maxm=1e5+5;const int maxl=26;int vis[maxn];bool check(ll num)&#123; while(num)&#123; int temp=num%10; if(temp==7) return 1; num/=10; &#125; return 0;&#125;int main()&#123; ll n,m,k,cnt=0; int flag=0; while(~scanf("%lld%lld%lld",&amp;n,&amp;m,&amp;k) &amp;&amp; n+m+k)&#123; memset(vis,0,sizeof(vis)); flag=0,cnt=0; while(vis[m]&lt;k)&#123; rep(i,1,n)&#123; if((++cnt )%7==0 || check(cnt)) &#123;// cout&lt;&lt;"i="&lt;&lt;i&lt;&lt;" cnt="&lt;&lt;cnt&lt;&lt;endl; vis[i]++; &#125; if(vis[m]==k) break; &#125; if(vis[m]==k) break; per(i,2,n+1)&#123; if((++cnt)%7==0 || check(cnt)) &#123;// cout&lt;&lt;"i="&lt;&lt;i&lt;&lt;" cnt="&lt;&lt;cnt&lt;&lt;endl; vis[i]++; &#125; if(vis[m]==k) break; &#125; &#125; cout&lt;&lt;cnt&lt;&lt;endl; &#125; &#125; 收获与反思直接模拟即可]]></content>
      <categories>
        <category>编程</category>
        <category>ACM</category>
      </categories>
      <tags>
        <tag>算法</tag>
        <tag>ACM</tag>
        <tag>CSU</tag>
        <tag>Imitation</tag>
        <tag>2018暑假集训</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[【CSU-1315】解题报告（排序，前缀和）]]></title>
    <url>%2F2018%2F09%2F03%2F%E3%80%90CSU-1315%E3%80%91%E8%A7%A3%E9%A2%98%E6%8A%A5%E5%91%8A%EF%BC%88%E6%8E%92%E5%BA%8F%EF%BC%8C%E5%89%8D%E7%BC%80%E5%92%8C%EF%BC%89%2F</url>
    <content type="text"><![CDATA[原始题目1315: 全场最水题之陈兴老师与比赛 Time Limit: 1 Sec Memory Limit: 128 Mb Submitted: 841 Solved: 280 Description大家都知道ACM比赛罚时很重要。比如说你做A题要10分钟，B题要15分钟，如果先做A题再做B题，那么在ranking上的时间就是10 + （10）+ 15 = 35。如果先做B题再做A题总罚时就是15+(15)+10=40.现在陈兴老师要做一场比赛，比赛有$n$道题， 总时间是$300$分钟。我们的陈兴老师仅仅看题目就可以知道他做每道题需要的时间，所以他想在比赛刚开始时就计算出自己的最大总做题数，以及对应的总罚时和做题顺序（当然，做题数相等时当然希望总罚时最少咯）。比如一般的比赛，陈兴老师做第一题需要1分钟，第二题2分钟，依此类推，陈兴老师只需要66分钟就可以AK一场11道题的比赛。PS: 陈兴老师做题都是1Y，膜拜陈兴老师Orz！ Input第一行是一个数字 $n (0&lt;n ≤25)$ 。 第二行是$n$个数字，第$i$个数字代表陈兴老师出编号为$i$的题所需要的时间 $t_i( 0 &lt; t_i ≤ 80)$。 Output第一行输出陈兴老师的出题数和Penalty（总时间） 以下按照顺序输出陈兴老师出题的顺序,每行一个编号。（详见输出样例）PS：时间一样的按编号升序输出。 Sample Input3 1 2 3 4 1 2 3 4 6 60 60 60 60 60 60 Sample Output3 10 1 2 3 4 20 1 2 3 4 5 900 1 2 3 4 5 HintSource题目大意原题说的不大清楚，实际上对于每到AC题目罚时累加上从开始到完成该题目的时间，比赛一共300分钟，求解题数，罚时，并输出接替顺序。（感觉整理CSU题面的时候应该再完善一下题目意思） 解题思路排序以后求前缀和，当前缀和超过300时输出 解题代码12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364656667686970717273747576#include &lt;cstdio&gt;#include &lt;cstring&gt;#include &lt;iostream&gt;#include &lt;iomanip&gt;#include &lt;set&gt;#include &lt;queue&gt;#include &lt;map&gt;#include &lt;sstream&gt;#include &lt;algorithm&gt;#include &lt;vector&gt;#include &lt;stack&gt;#include &lt;cmath&gt;#define rep(i,a,n) for(int i=a;i&lt;n;++i)#define per(i,a,n) for(int i=n-1;i&gt;=a;--i)#define fi first#define se second#define mp make_pair#define pb push_back#define np next_permutation#define all(x) x.begin(),x.end()#define insert(x) x,x.begin()#define cl(x,a) memset(x,a,sizeof(x))using namespace std;const int maxn=1e5+5;const int maxm=1e5+5;const int maxl=26;typedef long long ll;typedef unsigned long long ull;typedef vector&lt;int&gt; vi;typedef pair&lt;int,int&gt; pii;typedef pair&lt;string,string&gt; pss;bool cmp(pii a,pii b)&#123; if(a.second!=b.second) return a.second&lt;b.second; else return a.first&lt;b.first;&#125;int n,t,a[maxn];int main()&#123;// ios::sync_with_stdio(false); while(~scanf("%d",&amp;n))&#123; vector&lt;pii&gt; v; rep(i,1,n+1)&#123; int temp; scanf("%d",&amp;temp); v.pb(mp(i,temp)); &#125; sort(all(v),cmp); a[0]=v[0].second; rep(i,1,n) &#123; a[i]=a[i-1]+v[i].second;// cout&lt;&lt;"a["&lt;&lt;i&lt;&lt;"] = "&lt;&lt;a[i]&lt;&lt;endl; &#125; int panality=0,i=0,caltime=0; for(;i&lt;n&amp;&amp;caltime&lt;=300;i++)&#123; panality+=a[i]; caltime+=v[i].second; &#125; if(caltime&lt;=300) &#123;// cout&lt;&lt;n&lt;&lt;" "&lt;&lt;panality&lt;&lt;endl; printf("%d %d\n",n,panality);// rep(i,0,n) cout&lt;&lt;v[i].fi&lt;&lt;endl; rep(i,0,n) printf("%d\n",v[i].fi); &#125; else &#123; panality-=a[--i];// cout&lt;&lt;i&lt;&lt;" "&lt;&lt;panality&lt;&lt;endl; printf("%d %d\n",i,panality);// rep(i,0,n) cout&lt;&lt;v[i].fi&lt;&lt;endl; rep(j,0,i) printf("%d\n",v[j].fi); &#125; &#125;&#125; 收获与反思排序一下]]></content>
      <categories>
        <category>编程</category>
        <category>ACM</category>
      </categories>
      <tags>
        <tag>算法</tag>
        <tag>ACM</tag>
        <tag>CSU</tag>
        <tag>2018暑假集训</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[【CSU-1321】解题报告（最短路，dij）]]></title>
    <url>%2F2018%2F09%2F03%2F%E3%80%90CSU-1321%E3%80%91%E8%A7%A3%E9%A2%98%E6%8A%A5%E5%91%8A%EF%BC%88%E6%9C%80%E7%9F%AD%E8%B7%AF%EF%BC%8Cdij%EF%BC%89%2F</url>
    <content type="text"><![CDATA[原始题目1321: CX and girls Time Limit: 1 Sec Memory Limit: 128 Mb Submitted: 597 Solved: 181 DescriptionCX是要赶去上课，为了不迟到必须要以最短的路径到达教室，同时CX希望经过的路上能看到的学妹越多越好。现在把地图抽象成一个无向图，CX从$1$点出发，教室在$N$号点，告诉每个点上学妹的数量，每条边的长度。 请你求出CX以最短路径赶到教室最多能看到多少学妹。 Input多组输入数据(最多20组)，输入到文件结束。 每组数据第一行两个正整数$N,M$其中$N$代表点的个数$( 2 ≤ N ≤ 1000)$，$M$代表边的个数$(1 ≤ M ≤ 10000)$。 接下来一行$N$个数，代表着$1 \cdots N$每个点上学妹的个数，$(0 ≤ N_i \le 50)$。 接下来$M$行，每行三个数$A,B,C (1 \le A , B \le N , 0 &lt; C \le 100 )$ 代表$A,B$两点间有边，长度为$C$。(可能存在重边) Output输出CX以最短距离从$1$到$n$的情况下能看到的最多学妹数量，若从点$1$无法到达点$N$输出$-1$。 Sample Input4 4 1 2 3 4 1 2 1 1 3 1 2 4 2 3 4 2 Sample Output8 AuthorCSU_ZZY SourceCSU Monthly 2013 Oct. 题目大意如题 解题思路最短路加上对结点值的判断 解题代码123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103#include &lt;cstdio&gt;#include &lt;cstring&gt;#include &lt;string&gt;#include &lt;algorithm&gt;#include &lt;iostream&gt;#include &lt;stack&gt;#include &lt;set&gt;#include &lt;vector&gt;#include &lt;queue&gt;#include &lt;cmath&gt;#include &lt;cstdlib&gt;#include &lt;bits/stdc++.h&gt; using namespace std;#define eps 1e-8#define INF 0x3f3f3f3f#define rep(i,a,n) for(int i=a;i&lt;n;i++)#define per(i,a,n) for(int i=n-1;i&gt;=a;i--)#define all(x) x.begin(),x.end()#define pb push_back#define np next_permutation#define ms(x,a) memset((x),(a),sizeof(x))//优先队列迪杰斯特拉 const int maxn=1e5+5;struct Edge&#123; int u,v,w; Edge(int _u,int _v,int _w):u(_u),v(_v),w(_w)&#123; &#125;;&#125;;vector &lt;Edge&gt; edges[maxn];int dis[maxn],meizi[maxn],mei[maxn];bool vis[maxn];int n,m,uu,vv,ww;void init(int n)&#123; //n个结点的边集都清空 rep(i,0,maxn)&#123; edges[i].clear(); &#125;&#125;void addEdge(int u,int v,int w)&#123; edges[u].pb(Edge(u,v,w));&#125;struct Node&#123; int Id,W; Node(int _Id,int _W):Id(_Id),W(_W)&#123; &#125;; bool operator &lt; (const Node &amp;b) const &#123; return W&gt;b.W;// else return Id&lt;b.Id; &#125;&#125;;void Dijkstra(int s)&#123; ms(vis,0); ms(meizi,0); ms(dis,INF); priority_queue &lt;Node&gt; q; q.push(Node(s,0)) ; dis[s]=0;meizi[s]=mei[s]; while(!q.empty())&#123; Node now=q.top(); q.pop(); int index=now.Id; if(vis[index]) continue;// if(index==end) return; vis[index]=1; rep(i,0,edges[index].size())&#123; Edge temp=edges[index][i]; if(dis[temp.v]&gt;dis[index]+temp.w)&#123; dis[temp.v]=dis[index]+temp.w; meizi[temp.v]=meizi[index]+mei[temp.v]; q.push(Node(temp.v,dis[temp.v])); &#125; else if(dis[temp.v]==dis[index]+temp.w)&#123; if(meizi[temp.v]&lt;meizi[index]+mei[temp.v])&#123; meizi[temp.v]=meizi[index]+mei[temp.v]; q.push(Node(temp.v,dis[temp.v])); &#125; &#125; &#125; &#125;&#125;int main()&#123; ios::sync_with_stdio(false); while(cin&gt;&gt;n&gt;&gt;m)&#123; init(n); rep(i,1,n+1)&#123; cin&gt;&gt;mei[i]; &#125; rep(i,1,m+1)&#123; cin&gt;&gt;uu&gt;&gt;vv&gt;&gt;ww; addEdge(uu,vv,ww); addEdge(vv,uu,ww); &#125; Dijkstra(1); if(dis[n]&gt;100000000) cout&lt;&lt;"-1"&lt;&lt;endl; else cout&lt;&lt;meizi[n]&lt;&lt;endl; &#125; &#125; 收获与反思 模板开始错了，少了return，WA了一晚上。]]></content>
      <categories>
        <category>编程</category>
        <category>ACM</category>
      </categories>
      <tags>
        <tag>算法</tag>
        <tag>ACM</tag>
        <tag>CSU</tag>
        <tag>2018暑假集训</tag>
        <tag>Dijkstra</tag>
        <tag>最短路</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[【CSU-1323】解题报告（字典树）]]></title>
    <url>%2F2018%2F09%2F03%2F%E3%80%90CSU-1323%E3%80%91%E8%A7%A3%E9%A2%98%E6%8A%A5%E5%91%8A%EF%BC%88%E5%AD%97%E5%85%B8%E6%A0%91%EF%BC%89%2F</url>
    <content type="text"><![CDATA[原始题目1323: ZZY and his little friends Time Limit: 5 Sec Memory Limit: 256 Mb Submitted: 708 Solved: 258 Descriptionzzy养了一只小怪兽和N只凹凸曼，单挑的话每只凹凸曼都不是小怪兽的对手，所以必须由两只凹凸曼合作来和小怪兽战斗。凹凸曼A和凹凸曼B合作的战斗力为他们战斗力的异或值。现在由zzy从N只凹凸曼中选出两只来和小怪兽战斗。 请问zzy能否选出两只凹凸曼使他们能够战胜小怪兽(他们的战斗力比小怪兽大)。 Input输入有多个例子，直到文件结束。 每个例子的第一行含两个数N和M，表示有 $ N ( 2 \le N \le 10^5 )$只凹凸曼，小怪兽的战斗力为$ M (0 &lt; M \le 10^9 )$。接着有一行N个数，每个数 $ A_i ( 0 &lt; A_i &lt; M )$表示每只凹凸曼的战斗力。 Output对于每个例子输出一行，如果能选出两只凹凸曼使他们战胜小怪兽输出”YES”, 否则输出”NO”(不含引号) Sample Input2 5 1 1 2 6 5 2 Sample OutputNO YES Author CSU_CX SourceCSU Monthly 2013 Oct. 题目大意如题 解题思路01字典树，将数字转换为32位的01数字串（高位在前）储存到树中。然后扫一遍求异最大值，与题目给定的$M$比较。 接替代码123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131#include &lt;cstdio&gt;#include &lt;cstring&gt;#include &lt;cmath&gt;#include &lt;set&gt;#include &lt;queue&gt;#include &lt;map&gt;#include &lt;set&gt;#include &lt;string&gt;#include &lt;iostream&gt;#include &lt;iomanip&gt;#include &lt;stack&gt;#define rep(i,a,n) for(int i=a ; i&lt;n;++i)#define per(i,a,n) for(int i=n-1;i&gt;=a;--i)#define fi first#define se second#define cl(x,a) memset(x,a,sizeof(x)) #define all(x) x.begin(),x.end()#define insert(x) x,x.begin()#define debug printf("======================\n");#define mp make_pair#define np next_permutation#define pb push_back#define INF 0x3f3f3f3f#define eps 1e-8using namespace std;const int maxn=1e5+5;const int maxm=1e5+5;const int maxl=2;const int K=32;typedef long long ll;typedef struct Trie&#123; int v; Trie* next[maxl];&#125;Trie;Trie *root;void iniTrie()&#123; root=(Trie*) malloc(sizeof(Trie)); rep(i,0,maxl) root-&gt;next[i]=NULL; root-&gt;v=-1; &#125;bool creTrie(int a)&#123; //预处理整数为01数组 int temp[35]; int id=K-1; while(a)&#123; temp[id--]=(a&amp;1); a&gt;&gt;=1; &#125; rep(i,0,id+1) temp[i]=0; int l=K; Trie *p=root,*q; rep(i,0,l)&#123; int id=temp[i]; if(p-&gt;next[id]!=NULL)&#123; p=p-&gt;next[id]; &#125; else &#123; q=(Trie*) malloc(sizeof(Trie)); q-&gt;v=1; //新建节点染色 for(int j=0;j&lt;maxl;j++) q-&gt;next[j]=NULL; p-&gt;next[id]=q; p=p-&gt;next[id]; &#125; &#125; &#125;int findTrie(int a)&#123; int aa=a; int temp[35]; int id=K-1; while(a)&#123; temp[id--]=(a&amp;1); a&gt;&gt;=1; &#125; rep(i,0,id+1) temp[i]=0; //前面位置补0 int aans=0; Trie *p=root; int l=K; for(int i=0;i&lt;l;i++)&#123; int index= !temp[i]; if(p-&gt;next[index] !=NULL )&#123; aans=(aans&lt;&lt;1)+index; p=p-&gt;next[index]; &#125; else &#123; aans=(aans&lt;&lt;1)+temp[i]; p=p-&gt;next[temp[i]]; &#125; &#125; return aans^aa; &#125;void delTrie(Trie *p)&#123; int i; for(int i=0;i&lt;maxl;i++)&#123; if(p-&gt;next[i]!= NULL) delTrie(p-&gt;next[i]); &#125; free(p); p=NULL; return ;&#125;int a[maxn],n,m;int main()&#123; ios::sync_with_stdio(false); while(cin&gt;&gt;n&gt;&gt;m)&#123; iniTrie(); rep(i,0,n)&#123; cin&gt;&gt;a[i]; creTrie(a[i]); &#125; int fans=0; rep(i,0,n)&#123; fans=max(fans,findTrie(a[i])); &#125; if(fans&gt;m) cout&lt;&lt;"YES"&lt;&lt;endl; else cout&lt;&lt;"NO"&lt;&lt;endl; &#125; &#125; 收获与反思熟悉求异或最大值01字典树的操作。]]></content>
      <categories>
        <category>编程</category>
        <category>ACM</category>
      </categories>
      <tags>
        <tag>算法</tag>
        <tag>ACM</tag>
        <tag>CSU</tag>
        <tag>2018暑假集训</tag>
        <tag>字典树</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[【CSU-1330】解题报告（水题，字符串）]]></title>
    <url>%2F2018%2F09%2F03%2F%E3%80%90CSU-1330%E3%80%91%E8%A7%A3%E9%A2%98%E6%8A%A5%E5%91%8A%EF%BC%88%E6%B0%B4%E9%A2%98%EF%BC%8C%E5%AD%97%E7%AC%A6%E4%B8%B2%EF%BC%89%2F</url>
    <content type="text"><![CDATA[原始题目1330: 字符识别？ Time Limit: 1 Sec Memory Limit: 128 Mb Submitted: 885 Solved: 595 Description你的任务是写一个程序进行字符识别。别担心，你只需要识别1, 2, 3，如下： .*. *** *** .*. ..* ..* .*. *** *** .*. *.. ..* .*. *** *** Input输入仅包含一组数据，由$6$行组成。第一行为字符的个数 $n ( 1 \le n \le 10)$。以下$5$行每行包含$4n$个字符。每个字符恰好占$5$行$3$列，然后是一个空列（用”.”填充）。 Output输出应包含一行，即识别出的各个字符。 Sample Input3 .*..***.***. .*....*...*. .*..***.***. .*..*.....*. .*..***.***. Sample Output123 HintSource湖南省第九届大学生计算机程序设计竞赛 题目大意将一个五行宽的字符串替换成所代表的1，2，3。 解题思路水题，字符串判断一下特征字符区间即可。 解题代码1234567891011121314151617181920212223242526272829303132333435363738394041424344#include &lt;cstdio&gt;#include &lt;cstring&gt;#include &lt;cmath&gt;#include &lt;set&gt;#include &lt;queue&gt;#include &lt;map&gt;#include &lt;set&gt;#include &lt;string&gt;#include &lt;iostream&gt;#include &lt;iomanip&gt;#include &lt;stack&gt;#define rep(i,a,n) for(int i=a ; i&lt;n;++i)#define per(i,a,n) for(int i=n-1;i&gt;=a;--i)#define fi first#define se second#define cl(x,a) memset(x,a,sizeof(x)) #define all(x) x.begin(),x.end()#define insert(x) x,x.begin()#define debug printf("======================\n");#define mp make_pair#define np next_permutation#define pb push_back#define INF 0x3f3f3f3f#define eps 1e-8using namespace std;const int maxn=1e5+5;const int maxm=1e5+5;const int maxl=2;const int K=32;string word[5]; int main()&#123; ios::sync_with_stdio(false); int n; while(cin&gt;&gt;n)&#123; rep(i,0,5) cin&gt;&gt;word[i]; rep(i,0,n)&#123; int ii=i*4; if(word[2][ii]=='.' &amp;&amp; word[2][ii+1]=='*' &amp;&amp; word[2][ii+2]=='.') cout&lt;&lt;1; else if(word[3][ii]=='*' &amp;&amp; word[3][ii+1]=='.' &amp;&amp; word[3][ii+2]=='.') cout&lt;&lt;2; else if(word[3][ii]=='.' &amp;&amp; word[3][ii+1]=='.' &amp;&amp; word[3][ii+2]=='*') cout&lt;&lt;3; &#125; cout&lt;&lt;endl; &#125;&#125; 收获与反思无]]></content>
      <categories>
        <category>编程</category>
        <category>ACM</category>
      </categories>
      <tags>
        <tag>算法</tag>
        <tag>ACM</tag>
        <tag>CSU</tag>
        <tag>2018暑假集训</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[【CSU-1340】结题报告（水题）]]></title>
    <url>%2F2018%2F09%2F03%2F%E3%80%90CSU-1340%E3%80%91%E8%A7%A3%E9%A2%98%E6%8A%A5%E5%91%8A%EF%BC%88%E6%B0%B4%E9%A2%98%EF%BC%89%2F</url>
    <content type="text"><![CDATA[原始题目1340: A Sample Problem Time Limit: 1 Sec Memory Limit: 128 Mb Submitted: 706 Solved: 322 DescriptionMy girlfriend loves 7 very much, she thinks it is lucky! If an integer contains one or more 7, she will think it is lucky too! InputThe first line has one integer $T (1 \le T \le 100)$, means there are T test cases. For each test case, there is only one line with an integer $X (1 \le X \le 10^{9} )$. OutputFor each test case, if X contains one or more 7, output “Lucky” (without quotation marks), otherwise output “Unlucky” (without quotation marks). Sample Input4 7 11 568 17171 Sample OutputLucky Unlucky Unlucky Lucky Hint我们主要通过这个题目来感受一下一个完整的ACM竞赛的题目应当是什么样的。 ACM竞赛题目本身的“格式” 很明显： 第一部分是对题目的描述，会交待题目的背景，以及你需要编程完成哪些任务等等。 第二部分是对输入的约定，会告诉你题目是否有多组测试数据，每组测试数据的格式，每个参数的类型（整数，浮点数，字符串等）以及取值范围等等。 第三部分是对输出的约定，也就是你的程序应当输出哪些内容以及具体的格式是什么。 第四部分是一些样例，这些例子只是向你展示一部分测试数据以及对应的答案，目的是更好地帮助你理解题意，以及了解对输出格式的要求等。 大家也许会和我当初刚接触ACM时一样心中充满了疑问，在这里我就为大家列举几个常见的问题： 如果题目有多组数据，我们是不是也要像样例那样把所有的结果先都计算出来，然后再一起输出？ 这个是没必要的，你完全可以每处理完一组数据之后就立刻将这组数据对应的结果输出出来。 但如果你是手动去敲这些样例的话，你会发现在屏幕上输入和输出是混在一起的，并不像样例那样输入和输出是分离的，这样会不会不符合要求呢？那么请看，相信你的疑问就会被解答了。 OJ (Online Judge)怎么知道我的程序是不是写对了？ OJ并不会去智能化地分析你的代码正确与否，而是用另一种巧妙的思路来判断你的程序是否符合要求：“喂”给你的程序一些输入数据（就像你在键盘上敲一些东西后敲回车一样），之后再将你的程序“产出”的东西（就像你在屏幕上看到的你的程序输出的东西一样）和标准的答案进行对比，如果你的程序得到的答案和标准的答案一模一样，那么就算你通过了这个题目。 因此，即使你手动输入样例时屏幕上的输入和输出是混在一起也没关系，只要你的程序“产出”的东西和标准答案一模一样就可以了。 也正是这种评判机制的关系，你不应当让程序打印一些提示语句，如“Please input two integers”等等，因为凡是你的程序输出的内容都会被拿来和标准答案进行对比，一旦输出了类似这样的题目没有要求输出的语句，就会和标准答案大相径庭了，自然就会认为你的程序是不正确的了。 值得一提的是，尽管这样的评判机制似乎并不能完美地知道你的程序究竟是不是对的（想想看为什么？），不过如果测试数据足够强大的话，“你的程序是对的”的概率就会很高很高了。 为什么我的程序通过了所有的样例，但是最后还是过不了这个题目？ 题目的样例只是一小部分测试数据，目的是为了更好地帮助你理解题意，以及了解对输出格式的要求等，因此通过了样例并不能够代表能通过所有的测试数据。只有通过了所有的测试数据才能得到“Accept”，也就是通过了这个题目。 每组测试数据的答案输出完之后，是否都要换行？ 是的，即使题目里面没有明确说明，我们也应该在每组测试数据的答案输出完之后再输出一个“换行”（也就是“\n”），就像样例示意的那样。 接下来我们谈谈这个题目的思路吧，相信大家应该都想到算法了：只要依次判断读入的整数的每一位是否是7就可以了。如果觉得代码写起来会有困难的话，可以参考一下我在下面给出的示例代码，不过最后一定要按自己的思路写一个完整的代码（编写自己的代码时就不要再参考示例代码了，要一气呵成~）并获得“Accept”哟！O(∩_∩)O~ SourceACM入门示例（第一季） 题目大意如题 解题思路水题 解题代码12345678910111213141516171819202122232425262728293031#include &lt;cstdio&gt;#include &lt;cstring&gt;#include &lt;iostream&gt;#include &lt;set&gt;#include &lt;queue&gt;#include &lt;algorithm&gt;#define INF 0x3f3f3f3f#define rep(i,a,n) for(int i=a;i&lt;n;++i)#define per(i,a,n) for(int i=n-1;i&gt;=a;--i)using namespace std;const int maxn=1e5+5;typedef long long ll;ll t,n,m;int main()&#123; scanf("%lld",&amp;t); while(t--)&#123; scanf("%lld",&amp;n); int flag=0; while(n)&#123; if(n%10==7)&#123;// printf("now=%d\n",n); flag=1; break; &#125; n/=10; &#125; if(flag) printf("Lucky\n"); else printf("Unlucky\n"); &#125;&#125; 收获与反思无]]></content>
      <categories>
        <category>编程</category>
        <category>ACM</category>
      </categories>
      <tags>
        <tag>算法</tag>
        <tag>ACM</tag>
        <tag>CSU</tag>
        <tag>2018暑假集训</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[【CSU-2158】解题报告（水题）]]></title>
    <url>%2F2018%2F09%2F01%2F%E3%80%90CSU-2158%E3%80%91%E8%A7%A3%E9%A2%98%E6%8A%A5%E5%91%8A%EF%BC%88%E6%B0%B4%E9%A2%98%EF%BC%89%2F</url>
    <content type="text"><![CDATA[原始题目2158: 长门的运动会 Time Limit: 1 Sec Memory Limit: 128 Mb Submitted: 2 Solved: 2 SpecialJudge Description运动会，好开心~ CSU (California State University) 正在举行一场特殊的接力跑比赛，比赛在环形跑道上进行，同一支队伍的所有人从同一个位置向相同的方向出发，当需要接力的两个人再次相遇时，他们就要交接棒。最后总成绩是以队伍跑的总路程计算的 现在接力的第一棒在Nagato手中，需要把它交给Kyon。在长度为C的环形跑道上，他们出发了！Nagato以速度A匀速跑动，Kyon以速度B匀速跑动。他们在经过多长时间后可以再次相遇？ Input多组数据，第一行为一个整数T (1 ≤ T ≤ 106)，表示数据组数。 之后每行是一组数据，有三个整数C, A, B (1 ≤ C, A, B ≤ 109, A ≠ B)，分别表示环形跑道的长度，Nagato的速度和Kyon的速度。 Output每行输出一个数，表示再次相遇所需的时间。绝对误差或相对误差小于10−5则认为是正确的。 Sample Input2 3 1 2 5 10 7 Sample Output3.00000000 1.66666667 HintSourceAuthorYuki Nagato 题目大意如题 解题思路水题，追击运动一圈 解题代码1234567891011121314151617181920212223242526272829303132333435363738394041#include &lt;cstdio&gt;#include &lt;cstring&gt;#include &lt;iostream&gt;#include &lt;iomanip&gt;#include &lt;cmath&gt;#include &lt;sstream&gt;#include &lt;set&gt;#include &lt;vector&gt;#include &lt;stack&gt;#include &lt;queue&gt;#include &lt;map&gt;#include &lt;algorithm&gt;#define rep(i,a,n) for(int i=a;i&lt;n;++i) #define per(i,a,n) for(int i=n-1;i&gt;=a;--i)#define ms(x,a) memset((x),a,sizeof(x))#define pb push_back#define np next_permutation#define mp make_pair#define INF 0x3f3f3f3f#define eps 1e-8#define all(x) x.begin(),x.end()#define ins(x) inserter(x,x.begin())#define mod 1000000005#define K 20using namespace std;const int maxn=1e2+5;const int maxl=26;const int maxm=1e5+5;typedef long long ll;ll t,n,a;int c[K];int main()&#123; scanf("%lld",&amp;t); while(t--)&#123; int a,b,c; scanf("%d%d%d",&amp;a,&amp;b,&amp;c); if(b&lt;c) swap(b,c); double ans=double(a)/(b-c); printf("%f\n",ans); &#125;&#125; 收获与反思水题]]></content>
      <categories>
        <category>编程</category>
        <category>ACM</category>
      </categories>
      <tags>
        <tag>算法</tag>
        <tag>ACM</tag>
        <tag>CSU</tag>
        <tag>2018暑假集训</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[【UVA-12100】解题报告（STL,queue）]]></title>
    <url>%2F2018%2F08%2F29%2F%E3%80%90UVA-12100%E3%80%91%E8%A7%A3%E9%A2%98%E6%8A%A5%E5%91%8A%EF%BC%88STL-queue%EF%BC%89%2F</url>
    <content type="text"><![CDATA[原始题目 题目大意学生会里的打印机打印量巨大。现在给打印任务分配一个1到9的优先级，优先级越高表示任务越着急。 打印机的工作方式如下：首先从打印队列里取出一个任务J，如果队列里有比J更急的任务，则直接把J放到打印队列尾部，否则打印任务J（此时不会把它放到打印队列） 输入打印队列中各个任务的优先级，给定你的任务的序号，假定只有打印每个任务的时候耗时1分钟，问完成你的任务时总耗时是多少。 解题思路 利用set模拟，维护一下当前最大优先级和各优先级的任务数即可。 解题代码1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859#include &lt;cstdio&gt;#include &lt;cstring&gt;#include &lt;cmath&gt;#include &lt;iostream&gt;#include &lt;iomanip&gt;#include &lt;set&gt;#include &lt;queue&gt;#include &lt;map&gt;#include &lt;algorithm&gt;#include &lt;vector&gt;#define rep(i,a,n) for(int i=a;i&lt;n;++i)#define per(i,a,n) for(int i=n-1;i&gt;=a;--i)#define cl(x,a) memset(x,a,sizeof(x))#define all(x) x.begin(),x.end()#define pb push_back#define np next_permutation#define mp make_pair#define fi first#define se second#define INF 0x3f3f3f3f#define eps 1e-8using namespace std;const int maxn=1e5+5;const int maxl=26;const int maxm=1e5+5;typedef long long ll;typedef vector&lt;int&gt; vi;typedef pair&lt;int,int&gt; pii;int num[100];int main()&#123; ios::sync_with_stdio(false); int t,n,m,l,mmax=0; cin&gt;&gt;t; while(t--)&#123; cin&gt;&gt;n&gt;&gt;m;//自己得任务是m号 queue&lt;pii&gt; q; cl(num,0); rep(i,0,n)&#123; cin&gt;&gt;l; mmax=max(mmax,l); q.push(mp(i,l)); num[l]++; &#125; int ans=0; while(!q.empty())&#123; pii temp=q.front();q.pop(); if(temp.second&lt;mmax)&#123; q.push(temp); &#125; else&#123; ans++; if(!(--num[mmax])) while(!(num[mmax]) &amp;&amp; mmax)&#123;mmax--;&#125; if(temp.first==m) &#123;cout&lt;&lt;ans&lt;&lt;endl;break;&#125; &#125; &#125; &#125; &#125; 收获与反思 加快码速，秒之s]]></content>
      <categories>
        <category>编程</category>
        <category>ACM</category>
      </categories>
      <tags>
        <tag>算法</tag>
        <tag>ACM</tag>
        <tag>2018暑假集训</tag>
        <tag>STL</tag>
        <tag>UVA</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[【UVA-1595】解题报告（STL,Vector）]]></title>
    <url>%2F2018%2F08%2F29%2F%E3%80%90UVA-1595%E3%80%91%E8%A7%A3%E9%A2%98%E6%8A%A5%E5%91%8A%EF%BC%88STL%EF%BC%8CVector%EF%BC%89%2F</url>
    <content type="text"><![CDATA[原始题目 题目大意给出平面上N个点，问是否可以找到一条竖线，使得所有点左右对称。 解题思路纵坐标离散化后求每行得平均数，判断一下 解题代码1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465666768697071727374757677787980#include &lt;cstdio&gt;#include &lt;cstring&gt;#include &lt;cmath&gt;#include &lt;iostream&gt;#include &lt;iomanip&gt;#include &lt;set&gt;#include &lt;queue&gt;#include &lt;map&gt;#include &lt;algorithm&gt;#include &lt;vector&gt;#define rep(i,a,n) for(int i=a;i&lt;n;++i)#define per(i,a,n) for(int i=n-1;i&gt;=a;--i)#define cl(x,a) memset(x,a,sizeof(x))#define all(x) x.begin(),x.end()#define pb push_back#define np next_permutation#define mp make_pair#define fi first#define se second#define INF 0x3f3f3f3f#define eps 1e-8using namespace std;const int maxn=1e5+5;const int maxl=26;typedef long long ll;typedef vector&lt;int&gt; vi;typedef pair&lt;int,int&gt; pii;vector&lt;pii&gt; v0;vi v[1005];double ans[1005];bool cmp(pii a,pii b)&#123; if(a.first!=b.first) return a.first&lt;b.first; else return a.second&lt;b.second;&#125;int t,n,a,b;int main()&#123; ios::sync_with_stdio(false); cin&gt;&gt;t; while(t--)&#123; rep(i,0,1005) v[i].clear(); v0.clear(); cin&gt;&gt;n; rep(i,0,n) &#123;cin&gt;&gt;b&gt;&gt;a; v0.pb(mp(a,b));&#125; sort(all(v0),cmp);// rep(i,0,n) // &#123;// cout&lt;&lt;v0[i].fi&lt;&lt;" "&lt;&lt;v0[i].se&lt;&lt;endl;// &#125; int temp=INF,cnt=-1,sum=0; rep(i,0,n)&#123; if(temp!=v0[i].first)&#123; if(cnt!=-1)&#123; ans[cnt]=(double)sum/v[cnt].size();// cout&lt;&lt;"ave["&lt;&lt;cnt&lt;&lt;"]="&lt;&lt;ans[cnt]&lt;&lt;endl; &#125; temp=v0[i].first; cnt++; v[cnt].pb(v0[i].second); sum=v0[i].second; &#125; else &#123;v[cnt].pb(v0[i].second);sum+=v0[i].second;&#125; &#125; ans[cnt]=(double)sum/v[cnt].size(); cnt++; int flag=1; rep(i,1,cnt)&#123;// cout&lt;&lt;"ave["&lt;&lt;i&lt;&lt;"]="&lt;&lt;ans[i]&lt;&lt;endl; if(abs(ans[i]-ans[i-1])&gt;eps)&#123; flag=0; cout&lt;&lt;"NO"&lt;&lt;endl; break; &#125; &#125; if(flag) cout&lt;&lt;"YES"&lt;&lt;endl; &#125;&#125; 收获与反思 加快码速，秒之]]></content>
      <categories>
        <category>编程</category>
        <category>ACM</category>
      </categories>
      <tags>
        <tag>算法</tag>
        <tag>ACM</tag>
        <tag>2018暑假集训</tag>
        <tag>STL</tag>
        <tag>UVA</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[【UVA-10391】解题报告（STL）]]></title>
    <url>%2F2018%2F08%2F29%2F%E3%80%90UVA-10391%E3%80%91%E8%A7%A3%E9%A2%98%E6%8A%A5%E5%91%8A%EF%BC%88STL%EF%BC%89%2F</url>
    <content type="text"><![CDATA[原始题目 题目大意给出一个字典，找出所有的复合单词，即恰好有两个单词连接而成的单词。输入已按照字典序从小到大排序，且不超过120000个单词，输出所有复合词，按照字典序从小到大排序。 解题思路substring秒过 解题代码1234567891011121314151617181920212223242526272829303132333435363738#include &lt;cstdio&gt;#include &lt;cstring&gt;#include &lt;string&gt;#include &lt;iostream&gt;#include &lt;set&gt;#include &lt;queue&gt;#include &lt;algorithm&gt;#include &lt;map&gt;#include &lt;vector&gt;#include &lt;iomanip&gt;#include &lt;cmath&gt;using namespace std;const int maxn=2e5+5;set &lt;string&gt; s;vector &lt;string&gt; all;string a;int n; int main()&#123; while(cin&gt;&gt;a)&#123; s.insert(a); &#125; set &lt;string&gt; ::iterator it; for(it=s.begin();it!=s.end();it++)&#123; int len=(*it).size(); for(int i=1;i&lt;len;i++)&#123; //遍历每个单词从头到尾 string pre=(*it).substr(0,i); string sub=(*it).substr(i,len-i); if(s.count(pre) &amp;&amp; s.count(sub))&#123; cout&lt;&lt;*it&lt;&lt;endl; break; &#125; &#125; &#125; &#125; 收获与反思 熟悉函数 string::substr() 第一个参数为起始位置，第二个参数为长度。]]></content>
      <categories>
        <category>编程</category>
        <category>ACM</category>
      </categories>
      <tags>
        <tag>算法</tag>
        <tag>ACM</tag>
        <tag>2018暑假集训</tag>
        <tag>STL</tag>
        <tag>UVA</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[【UVA-10763】解题报告（STL）]]></title>
    <url>%2F2018%2F08%2F29%2F%E3%80%90UVA-10763%E3%80%91%E8%A7%A3%E9%A2%98%E6%8A%A5%E5%91%8A%EF%BC%88STL%EF%BC%89%2F</url>
    <content type="text"><![CDATA[原始题目 题目大意有n个学生想交换到其他学校学习。为了简单起见，规定每个象从A学校换到B学校的学生必须找一个想从B学校换到A的“搭档”。如果每个人都能找到搭档（一个人不能找多个搭档），学校就会同意他们交换。每个学生用两个整数A、B表示，你的任务是判断交换是否可以进行。 解题思路 利用multimap（多重映射）对于一组键、值对，查找有没有对应值为键，键为值得的映射，有则删除，没有的话把当前的键、值对加入multimap。最后检查是否为空 网上还有一种虽然简单优雅但是有漏洞的解法，初始赋值$ans[i]=i$输入一组$a,b$，$swap(ans[a],ans[b])$，最后检查是否复合原状态（一一匹配的话两次反转复原），不过这个解法没有考虑到三方交换的情况（即$swap(a,b),swap(b,c),swap(c,a)$）其实这是不满足题意的，但也会判YES。所以说有漏洞。 解题代码 multimap 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354#include &lt;cstdio&gt;#include &lt;cstring&gt;#include &lt;iostream&gt;#include &lt;iomanip&gt;#include &lt;cmath&gt; #include &lt;set&gt;#include &lt;vector&gt;#include &lt;string&gt;#include &lt;algorithm&gt;#include &lt;map&gt;#include &lt;sstream&gt;#include &lt;bits/stdc++.h&gt;#define rep(i,a,n) for(int i=a;i&lt;n;++i)#define per(i,a,n) for(int i=n-a;i&gt;=a;--i)#define cl(x,a) memset(x,a,sizeof(x))#define all(x) x.begin(),x.end()#define pb push_back#define np next_permutation#define mp make_pair#define INF 0x3f3f3f3f#define eps 1e-8#define K 1001#define fi first#define se secondusing namespace std;const int maxn=1e5+5;typedef vector&lt;int&gt; vi;typedef multimap &lt;int,int&gt;::const_iterator cit;int main()&#123; ios::sync_with_stdio(false); int n,a,b; while(cin&gt;&gt;n &amp;&amp; n)&#123; multimap &lt;int,int&gt; mmp; rep(i,0,n)&#123; cin&gt;&gt;a&gt;&gt;b; typedef pair&lt;cit,cit&gt; Range; Range range=mmp.equal_range(b); int flag=0; cit j=range.first; for(;j!=range.second;++j)&#123; if(j-&gt;second==a)&#123; flag=1; break; &#125; &#125; if(flag) mmp.erase(j); else mmp.insert(mp(a,b)); &#125; if(mmp.size()==0) cout&lt;&lt;"YES"&lt;&lt;endl; else cout&lt;&lt;"NO"&lt;&lt;endl; &#125;&#125; 朴素法（有漏洞） 123456789101112131415161718192021222324252627282930313233343536373839#include &lt;cstdio&gt;#include &lt;cstring&gt;#include &lt;iostream&gt;#include &lt;iomanip&gt;#include &lt;cmath&gt; #include &lt;set&gt;#include &lt;vector&gt;#include &lt;string&gt;#include &lt;algorithm&gt;#include &lt;map&gt;#include &lt;sstream&gt;#include &lt;bits/stdc++.h&gt;#define rep(i,a,n) for(int i=a;i&lt;n;++i)#define per(i,a,n) for(int i=n-a;i&gt;=a;--i)#define cl(x,a) memset(x,a,sizeof(x))#define all(x) x.begin(),x.end()#define pb push_back#define np next_permutation#define mp make_pair#define INF 0x3f3f3f3f#define eps 1e-8#define K 1001#define fi first#define se secondusing namespace std;const int maxn=5e5+5;int ans[maxn];int main()&#123; ios::sync_with_stdio(false); int n; while(cin&gt;&gt;n &amp;&amp; n)&#123; int flag=0; rep(i,1,n+1) ans[i]=i; rep(i,1,n+1) &#123;int a,b; cin&gt;&gt;a&gt;&gt;b; swap(ans[a],ans[b]);&#125; rep(i,1,n+1) &#123;if(ans[i]!=i) &#123;flag=1;break;&#125;&#125; if(flag) cout&lt;&lt;"NO"&lt;&lt;endl; else cout&lt;&lt;"YES"&lt;&lt;endl; &#125;&#125; 收获与反思 交换复原思想值得学习]]></content>
      <categories>
        <category>编程</category>
        <category>ACM</category>
      </categories>
      <tags>
        <tag>算法</tag>
        <tag>ACM</tag>
        <tag>2018暑假集训</tag>
        <tag>STL</tag>
        <tag>UVA</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[【UVA-10935】解题报告（STL，模拟）]]></title>
    <url>%2F2018%2F08%2F29%2F%E3%80%90UVA-10935%E3%80%91%E8%A7%A3%E9%A2%98%E6%8A%A5%E5%91%8A%EF%BC%88STL%EF%BC%8C%E6%A8%A1%E6%8B%9F%EF%BC%89%2F</url>
    <content type="text"><![CDATA[原始题目 题目大意桌上有n(n≤50) 张牌，从顶面开始，从上往下编号1到n。当至少剩下两张牌时进行以下操作： 把第一张牌扔掉，然后把新的第一张牌放到整叠牌的最后。 输入每行一个n，输出每次扔掉的牌以及最后剩下的牌。 解题思路 利用queue模拟操作，注意只有1张牌的时候特判。 解题代码1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950#include &lt;cstdio&gt;#include &lt;cstring&gt;#include &lt;iostream&gt;#include &lt;iomanip&gt;#include &lt;cmath&gt; #include &lt;set&gt;#include &lt;vector&gt;#include &lt;string&gt;#include &lt;algorithm&gt;#include &lt;map&gt;#include &lt;sstream&gt;#include &lt;bits/stdc++.h&gt;#define rep(i,a,n) for(int i=a;i&lt;n;++i)#define per(i,a,n) for(int i=n-a;i&gt;=a;--i)#define cl(x,a) memset(x,a,sizeof(x))#define all(x) x.begin(),x.end()#define pb push_back#define np next_permutation#define mp make_pair#define INF 0x3f3f3f3f#define eps 1e-8#define K 1001#define fi first#define se secondusing namespace std;const int maxn=1e5+5;int n;int main()&#123; ios::sync_with_stdio(false); while(cin&gt;&gt;n &amp;&amp;n)&#123; if(n==1)&#123; //1的时候特判 cout&lt;&lt;"Discarded cards:"&lt;&lt;endl; cout&lt;&lt;"Remaining card: 1"&lt;&lt;endl; continue; &#125; cout&lt;&lt;"Discarded cards: "; queue &lt;int&gt; q; rep(i,1,n+1) q.push(i); while(q.size()&gt;2)&#123; int top=q.front(); q.pop(); cout&lt;&lt;top&lt;&lt;", "; top=q.front();q.pop(); q.push(top); &#125; int top=q.front();q.pop(); cout&lt;&lt;top&lt;&lt;endl&lt;&lt;"Remaining card: "&lt;&lt;q.front()&lt;&lt;endl; &#125;&#125;]]></content>
      <categories>
        <category>编程</category>
        <category>ACM</category>
      </categories>
      <tags>
        <tag>算法</tag>
        <tag>ACM</tag>
        <tag>Imitation</tag>
        <tag>STL</tag>
        <tag>UVA</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[【UVA-11401】解题报告（数学，求和公式）]]></title>
    <url>%2F2018%2F08%2F29%2F%E3%80%90UVA-11401%E3%80%91%E8%A7%A3%E9%A2%98%E6%8A%A5%E5%91%8A%EF%BC%88%E6%95%B0%E5%AD%A6%EF%BC%8C%E6%B1%82%E5%92%8C%E5%85%AC%E5%BC%8F%EF%BC%89%2F</url>
    <content type="text"><![CDATA[原始题目 题目大意有长度分别为$1,2,3,4 \cdots n$ 的木杆各一根，问共可以组成多少个三角形。 解题思路 设$f[x]$ 表示以$x$为最长边的三角形的个数。 设另两条边为$y,z$，易知$y+z&gt;x$，所以$x-z]]></content>
      <categories>
        <category>编程</category>
        <category>ACM</category>
      </categories>
      <tags>
        <tag>算法</tag>
        <tag>ACM</tag>
        <tag>2018暑假集训</tag>
        <tag>补图</tag>
        <tag>UVA</tag>
        <tag>数学</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[【UVA-11538】解题报告（数学，组合数）]]></title>
    <url>%2F2018%2F08%2F29%2F%E3%80%90UVA-11538%E3%80%91%E8%A7%A3%E9%A2%98%E6%8A%A5%E5%91%8A%EF%BC%88%E6%95%B0%E5%AD%A6%EF%BC%8C%E7%BB%84%E5%90%88%E6%95%B0%EF%BC%89%2F</url>
    <content type="text"><![CDATA[原始题目 题目大意在$n \times m$的棋盘上放置$2$个皇后（一黑一白），问相互攻击的情况共有多少种。 解题思路 根据加法原理，总情况由下面三种子情况构成（覆盖全部切不重复）（n&lt;m) 两个皇后在同一行，情况数为$nm(m-1)$ 两个皇后在同一列，情况数为$mn(n-1)$ 两个皇后在同一斜行，情况数为$2 \times (2 \sum_{i=1}^{n-1}{i(i-1)} + (m+1-n)n(n-1)) = 2 \times( (2 \frac {n(n-1)(2n-4)}{6} )+(m-n+1)n(n-1))$ 相加即可 解题代码123456789101112131415161718192021222324252627282930313233343536373839#include &lt;cstdio&gt;#include &lt;cstring&gt;#include &lt;cmath&gt;#include &lt;iostream&gt;#include &lt;iomanip&gt;#include &lt;set&gt;#include &lt;queue&gt;#include &lt;map&gt;#include &lt;stack&gt;#include &lt;algorithm&gt;#include &lt;vector&gt;#include &lt;string&gt;#include &lt;sstream&gt;#define rep(i,a,n) for(int i=a;i&lt;n;++i)#define per(i,a,n) for(int i=n-a;i&gt;=a;--i)#define se second#define fi first#define eps 1e-8#define INF 0x3f3f3f3fusing namespace std;const int maxn=1e5+5;const int maxl=26;const int maxm=1e5+5;typedef long long ll;typedef unsigned long long ull;typedef vector&lt;int&gt; vi;typedef pair&lt;int,int&gt; pii;ll n,m;int main()&#123; ios::sync_with_stdio(false); while(cin&gt;&gt;n&gt;&gt;m&amp;&amp;n+m)&#123; if(n&gt;m) swap(n,m); ll ans=(n*m*(m-1) ); ans+=(m*n*(n-1)); ans+=(2*(n*(n-1)*(2*n-4)/6)+(m-n+1)*n*(n-1))*2; cout&lt;&lt;ans&lt;&lt;endl; &#125;&#125; 收获与反思 熟悉排列组合的加法原理与乘法原理 两个求和公式以及简单叠加 \sum {i=1}^n i = \frac {n(n+1)}{2}\sum {i=1}^n {i^2} = \frac {n(n+1)(2n+1)}{6}推导出 \sum {i=1}^n {i(i-1)} = \frac {n(n+1){n-1}{3}]]></content>
      <categories>
        <category>编程</category>
        <category>ACM</category>
      </categories>
      <tags>
        <tag>算法</tag>
        <tag>ACM</tag>
        <tag>2018暑假集训</tag>
        <tag>补图</tag>
        <tag>UVA</tag>
        <tag>数学</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[【HDU-1808】解题报告（数论，鸽巢定理）]]></title>
    <url>%2F2018%2F08%2F23%2F%E3%80%90HDU-1808%E3%80%91%E8%A7%A3%E9%A2%98%E6%8A%A5%E5%91%8A%EF%BC%88%E6%95%B0%E8%AE%BA%EF%BC%8C%E9%B8%BD%E5%B7%A2%E5%AE%9A%E7%90%86%EF%BC%89%2F</url>
    <content type="text"><![CDATA[原始题目Halloween treats Time Limit: 1000/1000 MS (Java/Others) Memory Limit: 32768/32768 K (Java/Others) Total Submission(s): 1366 Accepted Submission(s): 560 Special Judge Problem DescriptionEvery year there is the same problem at Halloween: Each neighbour is only willing to give a certain total number of sweets on that day, no matter how many children call on him, so it may happen that a child will get nothing if it is too late. To avoid conflicts, the children have decided they will put all sweets together and then divide them evenly among themselves. From last year’s experience of Halloween they know how many sweets they get from each neighbour. Since they care more about justice than about the number of sweets they get, they want to select a subset of the neighbours to visit, so that in sharing every child receives the same number of sweets. They will not be satisfied if they have any sweets left which cannot be divided. Your job is to help the children and present a solution. InputThe input contains several test cases. The first line of each test case contains two integers c and n (1 ≤ c ≤ n ≤ 100000), the number of children and the number of neighbours, respectively. The next line contains n space separated integers a1 , … , an (1 ≤ ai ≤ 100000 ), where ai represents the number of sweets the children get if they visit neighbour i. The last test case is followed by two zeros. OutputFor each test case output one line with the indices of the neighbours the children should select (here, index i corresponds to neighbour i who gives a total number of ai sweets). If there is no solution where each child gets at least one sweet, print “no sweets” instead. Note that if there are several solutions where each child gets at least one sweet, you may print any of them. Sample Input4 5 1 2 3 7 5 3 6 7 11 2 5 13 17 0 0 Sample Output3 5 2 3 4 SourceHDOJ 2007 Summer Exercise（1） Recommendlinle 题目大意题目大意，万圣节孩子们去要糖果。给定孩子数$c$，和邻居数$n$，且$n&gt;c$。每个邻居家里有糖果$a_i$，孩子们希望能找到一些家庭他们的糖果数恰好时能被$c$整除，问是否存在，不存在输出“no sweets”，存在的话输出邻居的编号。 解题思路由于$n&gt;c$，求前缀和数组sum，对于严格单调增的n个前缀和，由于鸽巢原理，必然存在至少两个模c同余。 解题代码]]></content>
      <categories>
        <category>编程</category>
        <category>ACM</category>
      </categories>
      <tags>
        <tag>算法</tag>
        <tag>ACM</tag>
        <tag>2018暑假集训</tag>
        <tag>数论</tag>
        <tag>HDU</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[【UVA-12096】解题报告（STL，stack，模拟）]]></title>
    <url>%2F2018%2F08%2F23%2F%E3%80%90UVA-12096%E3%80%91%E8%A7%A3%E9%A2%98%E6%8A%A5%E5%91%8A%EF%BC%88STL%EF%BC%8Cstack%EF%BC%8C%E6%A8%A1%E6%8B%9F%EF%BC%89%2F</url>
    <content type="text"><![CDATA[原始题目 题目大意有一个储存集合的栈，有五种操作。 压入空集合 将栈顶集合复制再加入栈 出栈栈顶两个集合，取交集后入栈 出栈栈顶两个集合，取并集后入栈 出栈栈顶两个集合，将最顶端的集合加入到次顶的集合中 给出操作，最后输出栈顶集合的元素个数。 解题思路利用set的数据结构+模拟 集合储存内部集合的编号，空集合就没有编号。 利用map把集合映射成ID，对于每个ADD操作后的新集合查找映射，没有就赋值。 模拟操作最后输出栈顶的size即可。 解题代码12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364656667686970717273747576777879808182#include &lt;cstdio&gt;#include &lt;cstring&gt;#include &lt;cmath&gt;#include &lt;iostream&gt;#include &lt;iomanip&gt;#include &lt;set&gt;#include &lt;queue&gt;#include &lt;stack&gt;#include &lt;vector&gt;#include &lt;map&gt;#include &lt;string&gt;#include &lt;sstream&gt;#include &lt;bits/stdc++.h&gt;#define rep(i,a,n) for(int i=a;i&lt;n;++i)#define per(i,a,n) for(int i=n-1;i&gt;=a;--i);#define ms(x,a) memset((x),a,sizeof((x))) #define all(x) x.begin(),x.end()#define ins(x) inserter(x,x.begin()) #define INF 0x3f3f3f3f#define eps 1e-8#define fi first#define e 2.718281828459045235360287471352662497757247093699959574966967627724076630353 #define se second#define mp make_pair#define pb push_back#define np next_permutation#define gapline cout&lt;&lt;"##======================##"&lt;&lt;endlusing namespace std;const int maxn=1e5+5;const int maxl=26;const int maxm=1e5+5;typedef long long ll;typedef unsigned long long ull;typedef set&lt;int&gt; si;map &lt;si,int&gt; IDcache; //把集合映射成IDvector &lt;si&gt; sicache; int t,n;// 查找给定集合x的ID。如果找不到，分配一个新的IDint ID(si x)&#123; if(IDcache.count(x)) return IDcache[x]; sicache.pb(x); //添加新的集合// cout&lt;&lt;"new="&lt;&lt;sicache.size()-1&lt;&lt;endl; return IDcache[x]=sicache.size()-1; //返回新的id // id 都是从 0 开始的 &#125; stack &lt;int&gt; s;//建立栈s， 里面储存不同集合的idint main()&#123; ios::sync_with_stdio(false); cin&gt;&gt;t; while(t--)&#123; while(!s.empty()) s.pop(); sicache.clear(); IDcache.clear(); cin&gt;&gt;n; string op; rep(i,0,n)&#123; cin&gt;&gt;op; if(op[0]=='P') s.push(ID(si())); //调用默认构造函数构造空集合，作为参数传给ID，判断有没有该集合，然后返回id else if(op[0]=='D') s.push(s.top()); //复制一个添加到栈顶 else&#123; si x1=sicache[s.top()];s.pop(); si x2=sicache[s.top()];s.pop(); si x;// cout&lt;&lt;"x1="&lt;&lt;ID(x1)&lt;&lt;" x2="&lt;&lt;ID(x2)&lt;&lt;endl; if(op[0]=='U') set_union(all(x1),all(x2),ins(x)); if(op[0]=='I') set_intersection(all(x1),all(x2),ins(x)); if(op[0]=='A') &#123; x=x2; x.insert(ID(x1)); &#125; s.push(ID(x)); &#125; cout&lt;&lt;sicache[s.top()].size()&lt;&lt;endl; &#125; cout&lt;&lt;"***"&lt;&lt;endl; &#125; &#125; 收获与反思 紫书说思想很重要]]></content>
      <categories>
        <category>编程</category>
        <category>ACM</category>
      </categories>
      <tags>
        <tag>算法</tag>
        <tag>ACM</tag>
        <tag>Imitation</tag>
        <tag>2018暑假集训</tag>
        <tag>补图</tag>
        <tag>STL</tag>
        <tag>UVA</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[【UVA-540】解题报告（STL，queue，模拟）]]></title>
    <url>%2F2018%2F08%2F23%2F%E3%80%90UVA-540%E3%80%91%E8%A7%A3%E9%A2%98%E6%8A%A5%E5%91%8A%EF%BC%88STL%EF%BC%8Cqueue%EF%BC%8C%E6%A8%A1%E6%8B%9F%EF%BC%89%2F</url>
    <content type="text"><![CDATA[原始题目 题目大意团队队列，给定n个团队每个团队的人员，对于一个整体队列，有入队出队两种操作。 入队：如果长队列中有将要入队成员的同团队成员，则该成员插入到同团队成员的最后方，如果没有，则插入整个队伍最后方。 出队：整体队列的队首人员出列。 解题思路 先map到自己的团队号。 建立不同团队的人员队列和团队队列（储存团队号），入队操作时检查本团队的人员队列是否为空，如果为空。那么就在团队队列插入该成员的团队号，然后本队队列入队该成员。不为空的话只在本队队列入队即可。出队操作检查出队成员所在本队队列是否为空，为空就在团队队列中也出队队伍号。 解题代码1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465666768697071727374#include &lt;cstdio&gt;#include &lt;cstring&gt;#include &lt;cmath&gt;#include &lt;iostream&gt;#include &lt;iomanip&gt;#include &lt;set&gt;#include &lt;queue&gt;#include &lt;stack&gt;#include &lt;vector&gt;#include &lt;map&gt;#include &lt;string&gt;#include &lt;sstream&gt;#include &lt;bits/stdc++.h&gt;#define rep(i,a,n) for(int i=a;i&lt;n;++i)#define per(i,a,n) for(int i=n-1;i&gt;=a;--i);#define ms(x,a) memset((x),a,sizeof((x))) #define all(x) x.begin(),x.end()#define ins(x) inserter(x,x.begin()) #define INF 0x3f3f3f3f#define eps 1e-8#define fi first#define e 2.718281828459045235360287471352662497757247093699959574966967627724076630353 #define se second#define mp make_pair#define pb push_back#define np next_permutation#define gapline cout&lt;&lt;"##======================##"&lt;&lt;endlusing namespace std;const int maxn=1e3+5;const int maxl=26;const int maxm=1e5+5;typedef long long ll;typedef unsigned long long ull;//团体队列 一个q储存团体序号， q2[i]表示i团体内的队列 // 出队时 q2[q[front]] 为空时 q.pop();// 入队时 q2[mp[number]]非空时直接插队尾， 空时 插队尾同时q.push(mp[number]) int t,n,kase;map&lt;int,int&gt; mmp;int main()&#123; ios::sync_with_stdio(false); while(cin&gt;&gt;t&amp;&amp;t)&#123; cout&lt;&lt;"Scenario #"&lt;&lt;++kase&lt;&lt;endl; mmp.clear(); int x; rep(i,0,t)&#123; cin&gt;&gt;n; rep(j,0,n)&#123; cin&gt;&gt;x; mmp[x]=i; &#125; &#125; queue&lt;int&gt; q,q2[maxn]; //q为团队队列 q2[i] 为i团队队内队列 string c; while(cin&gt;&gt;c &amp;&amp; c[0]!='S')&#123; if(c[0]=='E')&#123; cin&gt;&gt;x; int id=mmp[x]; if(q2[id].empty())&#123; q.push(id); &#125; q2[id].push(x); &#125; else&#123; int num=q2[q.front()].front(); cout&lt;&lt;num&lt;&lt;endl; q2[q.front()].pop(); if(q2[q.front()].empty()) q.pop(); &#125; &#125; cout&lt;&lt;endl; &#125;&#125; 收获与反思合理利用已有的数据结构]]></content>
      <categories>
        <category>编程</category>
        <category>ACM</category>
      </categories>
      <tags>
        <tag>算法</tag>
        <tag>ACM</tag>
        <tag>2018暑假集训</tag>
        <tag>补图</tag>
        <tag>STL</tag>
        <tag>UVA</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[【UVA-136】解题报告（STL，set，优先队列）]]></title>
    <url>%2F2018%2F08%2F23%2F%E3%80%90UVA-136%E3%80%91%E8%A7%A3%E9%A2%98%E6%8A%A5%E5%91%8A%EF%BC%88STL%EF%BC%8Cset%EF%BC%8C%E4%BC%98%E5%85%88%E9%98%9F%E5%88%97%EF%BC%89%2F</url>
    <content type="text"><![CDATA[原始题目 题目大意因子只包含2，3，5的称为丑数，打印第1500个丑数。 解题思路 优先队列维护，每次拓展2，3，5添加到优先队列中。 解题代码123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051#include &lt;cstdio&gt;#include &lt;cstring&gt;#include &lt;cmath&gt;#include &lt;iostream&gt;#include &lt;iomanip&gt;#include &lt;set&gt;#include &lt;queue&gt;#include &lt;stack&gt;#include &lt;vector&gt;#include &lt;map&gt;#include &lt;string&gt;#include &lt;sstream&gt;#include &lt;bits/stdc++.h&gt;#define rep(i,a,n) for(int i=a;i&lt;n;++i)#define per(i,a,n) for(int i=n-1;i&gt;=a;--i);#define ms(x,a) memset((x),a,sizeof((x))) #define all(x) x.begin(),x.end()#define ins(x) inserter(x,x.begin()) #define INF 0x3f3f3f3f#define eps 1e-8#define fi first#define e 2.718281828459045235360287471352662497757247093699959574966967627724076630353 #define se second#define mp make_pair#define pb push_back#define np next_permutation#define gapline cout&lt;&lt;"##======================##"&lt;&lt;endlusing namespace std;const int maxn=1e5+5;typedef long long ll;const int coeff[3]=&#123;2,3,5&#125;;int main()&#123; priority_queue&lt;ll,vector&lt;ll&gt;, greater&lt;ll&gt; &gt; pq; set&lt;ll&gt;s; pq.push(1); s.insert(1); for(int i=1;;i++)&#123; ll x=pq.top();pq.pop(); if(i==1500)&#123; cout&lt;&lt;"The 1500'th ugly number is "&lt;&lt;x&lt;&lt;".\n"; break; &#125; rep(j,0,3)&#123; ll x2=coeff[j]*x; if(!s.count(x2)) &#123;pq.push(x2);s.insert(x2);&#125; &#125; &#125;&#125; 收获与反思 水题]]></content>
      <categories>
        <category>编程</category>
        <category>ACM</category>
      </categories>
      <tags>
        <tag>算法</tag>
        <tag>ACM</tag>
        <tag>2018暑假集训</tag>
        <tag>补图</tag>
        <tag>STL</tag>
        <tag>UVA</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[【UVA-156】解题报告（STL，map）]]></title>
    <url>%2F2018%2F08%2F23%2F%E3%80%90UVA-156%E3%80%91%E8%A7%A3%E9%A2%98%E6%8A%A5%E5%91%8A%EF%BC%88STL%EF%BC%8Cmap%EF%BC%89%2F</url>
    <content type="text"><![CDATA[原始题目 题目大意输入一些单词，找出所有满足下列条件的单词：不区分大小写后不能通过重排得到文本中另一个单词。，按字典序输出复合条件的原单词。 解题思路 利用set储存每个输入单词（自动按字典序排序），将每个单词标准化后其映射值+1。 遍历set输出标准化后映射值为1（只出现过一次）的单词。 解题代码12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455#include &lt;cstdio&gt;#include &lt;cstring&gt;#include &lt;cmath&gt;#include &lt;iostream&gt;#include &lt;iomanip&gt;#include &lt;set&gt;#include &lt;queue&gt;#include &lt;stack&gt;#include &lt;vector&gt;#include &lt;string&gt;#include &lt;sstream&gt;#include &lt;bits/stdc++.h&gt;#define rep(i,a,n) for(int i=a;i&lt;n;++i)#define per(i,a,n) for(int i=n-1;i&gt;=a;--i);#define ms(x,a) memset((x),a,sizeof((x))) #define INF 0x3f3f3f3f#define eps 1e-8#define fi first#define e 2.718281828459045235360287471352662497757247093699959574966967627724076630353 #define se second#define mp make_pair#define pb push_back#define np next_permutation#define gapline cout&lt;&lt;"##======================##"&lt;&lt;endlusing namespace std;const int maxn=1e5+5;const int maxl=26;const int maxm=1e5+5;string s;set&lt;string&gt; ans;map&lt;string,int&gt; mmp;int main()&#123; ios::sync_with_stdio(false); while(cin&gt;&gt;s&amp;&amp;s[0]!='#')&#123; ans.insert(s); string temp=s; rep(i,0,temp.length())&#123; if(isupper(temp[i])) temp[i]=temp[i]-'A'+'a'; &#125; sort(temp.begin(),temp.end()); mmp[temp]++; &#125; set&lt;string&gt;::iterator it; for(it=ans.begin();it!=ans.end();it++)&#123; string temp=*it; rep(i,0,temp.length())&#123; if(isupper(temp[i])) temp[i]=temp[i]-'A'+'a'; &#125; sort(temp.begin(),temp.end()); if(mmp[temp]==1) cout&lt;&lt;*it&lt;&lt;endl; &#125; &#125; 收获与反思 寒假入门的时候做过，现在回来再快速秒之]]></content>
      <categories>
        <category>编程</category>
        <category>ACM</category>
      </categories>
      <tags>
        <tag>算法</tag>
        <tag>ACM</tag>
        <tag>2018暑假集训</tag>
        <tag>补图</tag>
        <tag>STL</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[【HDU-2048】解题报告（递推，DP，数论，错排）]]></title>
    <url>%2F2018%2F08%2F23%2F%E3%80%90HDU-2048%E3%80%91%E8%A7%A3%E9%A2%98%E6%8A%A5%E5%91%8A%EF%BC%88%E9%80%92%E6%8E%A8%EF%BC%8CDP%EF%BC%8C%E6%95%B0%E8%AE%BA%EF%BC%8C%E9%94%99%E6%8E%92%EF%BC%89%2F</url>
    <content type="text"><![CDATA[原始题目神、上帝以及老天爷 Time Limit: 2000/1000 MS (Java/Others) Memory Limit: 65536/32768 K (Java/Others) Total Submission(s): 50425 Accepted Submission(s): 20379 Problem DescriptionHDU 2006’10 ACM contest的颁奖晚会隆重开始了！为了活跃气氛，组织者举行了一个别开生面、奖品丰厚的抽奖活动，这个活动的具体要求是这样的： 首先，所有参加晚会的人员都将一张写有自己名字的字条放入抽奖箱中；然后，待所有字条加入完毕，每人从箱中取一个字条；最后，如果取得的字条上写的就是自己的名字，那么“恭喜你，中奖了！”大家可以想象一下当时的气氛之热烈，毕竟中奖者的奖品是大家梦寐以求的Twins签名照呀！不过，正如所有试图设计的喜剧往往以悲剧结尾，这次抽奖活动最后竟然没有一个人中奖！ 我的神、上帝以及老天爷呀，怎么会这样呢？ 不过，先不要激动，现在问题来了，你能计算一下发生这种情况的概率吗？ 不会算？难道你也想以悲剧结尾？！ Input输入数据的第一行是一个整数C,表示测试实例的个数，然后是C 行数据，每行包含一个整数$n(1&lt;n≤20)$,表示参加抽奖的人数。 Output对于每个测试实例，请输出发生这种情况的百分比，每个实例的输出占一行, 结果保留两位小数(四舍五入)，具体格式请参照sample output。 Sample Input1 2 Sample Output50.00% Authorlcy Source递推求解专题练习（For Beginner） Recommendlcy 题目大意如题 解题思路 DP 手动写一下如何安排参加人员都不中奖就可以发现规律。$D[i]$表示i个人符合要求的方案数目 比如计算dp[4]时，将1的纸条分给2或3或4，这三种情况下，可以变为解决子问题，比如将1的纸条分给2，之后将2、3、4的纸条分给1、3、4，与dp[3]接近，但是1位置不受限制，即1位置可以放2的纸条，这样又变为dp[2]。 故得到状态转移方程。 D[n]=(n-1)(D[n-1]+D[n-2]) 最后除以总情况数（排列），计算百分数即可。 错排公式 其实本题是一个错排公式题目，我们上面推导出来的$ D[i]=(i-1)(D[i-1]+D[i-2]) $，实际上就是错排公式的一个递推关系。 又因为$D[1]=0,D[2]=1$ 继续推导 \begin{align} D[n] & =(n-1)(D[n-1]+D[n-2]) \\ D[n] - n D[n-1] & = (-1) (D[n-1] - (n-1) D[n-2])\\ D[n] - n D[n-1] & = (-1)^{n-2} (D[2] - 2 D[1]) \\ D[n] & = n D[n-1] + (-1)^{n} \end{align} 如此我们得到了递推关系式，那么求通项公式可以用下面几种方法： 可以用母函数方法求出通项公式（还不会，待学了母函数填坑） 可以用容斥原理 最后得到错排公式为 D[n] = n!( \frac{1}{0!} - \frac{1}{1!} + \frac{1}{2!} - \cdots (-1)^{n} \frac{1}{n!} ) 再补充 简化公式 D(n) = [ \frac{n!}{e} + 0.5 ] 证明相见百度，e是自然对数的底，[x]为x的整数部分。 解题代码 DP 12345678910111213141516171819202122232425262728293031323334353637383940414243#include &lt;cstdio&gt;#include &lt;cstring&gt;#include &lt;iostream&gt;#include &lt;set&gt;#include &lt;algorithm&gt;#include &lt;queue&gt;#include &lt;map&gt;#include &lt;string&gt;#define eps 1e-8#define INF 0x3f3f3f3f#define rep(i,a,n) for(int i=a;i&lt;n;i++)#define per(i,a,n) for(int i=n-1;i&gt;=a;i--)using namespace std;const int maxn=1e5+5;typedef long long ll;ll dp[maxn],A[maxn];void solve()&#123; memset(dp,0,sizeof(dp)); dp[1]=0; dp[2]=1; A[1]=1; A[2]=2; for(ll i=3;i&lt;=20;i++)&#123; dp[i]=(i-1)*(dp[i-1]+dp[i-2]); A[i]=A[i-1]*i; // cout&lt;&lt;dp[i]&lt;&lt;" "&lt;&lt;A[i]&lt;&lt;endl; &#125;&#125;using namespace std;int main()&#123; int t; solve(); while(cin&gt;&gt;t)&#123; rep(i,0,t)&#123; ll a; cin&gt;&gt;a; double ans=(double)dp[a]/(double)A[a];// cout&lt;&lt;"dp[i]"&lt;&lt;dp[a]&lt;&lt;" "&lt;&lt;"A[i]"&lt;&lt;A[a]&lt;&lt;endl; printf("%.2lf%%\n",ans*100); &#125; &#125;&#125; 错排简化公式 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152#include &lt;cstdio&gt;#include &lt;cstring&gt;#include &lt;cmath&gt;#include &lt;iostream&gt;#include &lt;iomanip&gt;#include &lt;set&gt;#include &lt;queue&gt;#include &lt;stack&gt;#include &lt;vector&gt;#include &lt;string&gt;#include &lt;sstream&gt;#include &lt;bits/stdc++.h&gt;#define rep(i,a,n) for(int i=a;i&lt;n;++i)#define per(i,a,n) for(int i=n-1;i&gt;=a;--i);#define ms(x,a) memset((x),a,sizeof((x))) #define INF 0x3f3f3f3f#define eps 1e-8#define fi first#define e 2.718281828459045235360287471352662497757247093699959574966967627724076630353 #define se second#define mp make_pair#define pb push_back#define np next_permutation#define gapline cout&lt;&lt;"##======================##"&lt;&lt;endlusing namespace std;const int maxn=1e5+5;const int maxl=26;const int maxm=1e5+5;typedef long long ll;typedef unsigned long long ull;typedef vector&lt;int&gt; vi;typedef pair&lt;int,int&gt; pii;ll A[maxl];void solve()&#123; A[0]=1; A[1]=1; rep(i,2,maxl) A[i]=A[i-1]*i;&#125;int n; int main()&#123; ios::sync_with_stdio(false); solve(); ll t; cin&gt;&gt;t; while(t--)&#123; cin&gt;&gt;n; double ans=floor((double)A[n]/e+0.5); cout&lt;&lt;fixed&lt;&lt;setprecision(2)&lt;&lt;ans*100/A[n]&lt;&lt;"%"&lt;&lt;endl; &#125; &#125; 收获与反思 注意分析递推公式。手写前几项找规律也可以。 错排公式推导学习 挖坑母函数]]></content>
      <categories>
        <category>编程</category>
        <category>ACM</category>
      </categories>
      <tags>
        <tag>算法</tag>
        <tag>ACM</tag>
        <tag>DP</tag>
        <tag>2018暑假集训</tag>
        <tag>递推</tag>
        <tag>HDU</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[【CSU-1828】解题报告（数论，康托展开逆展开）]]></title>
    <url>%2F2018%2F08%2F23%2F%E3%80%90CSU-1828%E3%80%91%E8%A7%A3%E9%A2%98%E6%8A%A5%E5%91%8A%EF%BC%88%E6%95%B0%E8%AE%BA%EF%BC%8C%E5%BA%B7%E6%89%98%E5%B1%95%E5%BC%80%E9%80%86%E5%B1%95%E5%BC%80%EF%BC%89%2F</url>
    <content type="text"><![CDATA[原始题目1828: Dictionary Time Limit: 2 Sec Memory Limit: 128 Mb Submitted: 202 Solved: 146 DescriptionThe isolated people of MacGuffin Island have a unique culture, and one of the most interesting things about them is their language. Their alphabet consists of the first 9 letters of the Roman alphabet (a, b, c, d, e, f, g, h, i). All of their words are exactly 9 letters long and use each of these 9 letters exactly once. They have a word for every possible permutation of these letters. In the library of their most sacred temple is a dictionary, and each word in their language has its own page. By coincidence they order their words exactly as they would be in ordered in English, so the word ‘abcdefghi’ is on the first page, and the word ‘ihgfedcba’ is on the last. The question is, given a list of random words from the MacGuffin language, can you say on which page of the MacGuffin dictionary each appears? InputThe first line of the input file is a positive integer. This integer tells you how many words will follow. The upper limit for this number is 6000. Every subsequent line contains a single word from the MacGuffin language, so if the first number is 1000 there will be 1000 lines after it, each containing a single word. OutputEach line of output will contain an integer. This integer should be the page number for the corresponding word. Sample Input4 abcdefgih abcdefghi abcdefgih ihgfedcba Sample Output2 1 2 362880 HintSourceACM-ICPC Asia Thailand National On-Site Programming Contest 2015 题目大意输入一个由(a, b, c, d, e, f, g, h, i)各出现一次构成的八位字符串，求其在按字典序排列中的序号。 解题思路看作1-8的排列，利用康托展开输出序号，模板题。 解题代码1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465666768697071727374757677787980818283848586#include &lt;cstdio&gt;#include &lt;cstring&gt;#include &lt;cmath&gt;#include &lt;string&gt;#include &lt;iostream&gt;#include &lt;iomanip&gt;#include &lt;sstream&gt;#include &lt;set&gt;#include &lt;map&gt;#include &lt;queue&gt;#include &lt;vector&gt;#include &lt;bits/stdc++.h&gt;#define INF 0x3f3f3f3f#define eps 1e-8#define mp make_pair#define np next_permutation#define pb push_back#define all(x) x.begin(),x.end()#define rep(i,a,n) for(int i=a;i&lt;n;++i)#define per(i,a,n) for(int i=n-1;i&gt;=a;--i)#define ms(x,a) memset((x),a,sizeof((x))) #define mod 998244353 using namespace std;typedef long long ll;typedef unsigned long long ull;typedef vector&lt;int&gt; vi;typedef pair&lt;int,int&gt; pii;const int maxl=10;const int maxn=1e5+5;int A[maxl];//阶乘； int ans_cantor[maxl];//康托展开数组 bool vis_cantor[maxl];//康托标记数组 string ss;void init()&#123; A[0]=A[1]=1; A[2]=2; rep(i,3,maxl+1) A[i]=A[i-1]*i;&#125;//contar展开，逆展开，数组标号都是从0开始 void cantor(int contar_s[], ll num, int contar_k)&#123;//康托展开，把一个数字num展开成一个数组contar_s，contar_k是数组长度 int t; memset(vis_cantor, 0, sizeof(vis_cantor)); for(int i = 0; i &lt; contar_k; i ++)&#123; t = num / A[contar_k-i-1]; num%=A[contar_k-i-1]; int cnt_cantor=0; rep(j,0,contar_k)&#123; //计算每位的逆序数 cout&lt;&lt;"cnt="&lt;&lt;cnt_cantor&lt;&lt;"t="&lt;&lt;t&lt;&lt;"vis="&lt;&lt;vis_cantor[j]&lt;&lt;endl; if(vis_cantor[j]) continue; if(cnt_cantor==t)&#123; contar_s[i]=j+1,vis_cantor[j]=1;break; &#125; ++cnt_cantor; &#125; &#125; rep(i,0,contar_k) cout&lt;&lt;contar_s[i]&lt;&lt;endl; //输出康拖展开的结果 &#125;ll inv_cantor(int contar_s[], int contar_k)&#123;//康托逆展开，把一个数组contar_s换算成一个数字num int cnt;ll num=0; num = 0; for(int i = 0; i &lt; contar_k; i ++)&#123; cnt = 0; for(int j = i + 1; j &lt; contar_k; j ++)&#123; if(contar_s[i] &gt; contar_s[j]) cnt ++;//判断几个数小于它,即求逆序数。 &#125; num += A[contar_k-i-1] * cnt; &#125; return num;&#125; int main()&#123; ios::sync_with_stdio(false); int t; cin&gt;&gt;t; init(); while(t--)&#123; cin&gt;&gt;ss; rep(i,0,ss.length())&#123; ans_cantor[i]=ss[i]-'a'+1; //这里加不加1都行 &#125; ll num=inv_cantor(ans_cantor,ss.length()); cout&lt;&lt;num+1&lt;&lt;endl; &#125; &#125; 收获与反思 感受模板的力量= =]]></content>
      <categories>
        <category>编程</category>
        <category>ACM</category>
      </categories>
      <tags>
        <tag>算法</tag>
        <tag>ACM</tag>
        <tag>CSU</tag>
        <tag>2018暑假集训</tag>
        <tag>数论</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[【UVA-815】解题报告（贪心，二分）]]></title>
    <url>%2F2018%2F08%2F23%2F%E3%80%90UVA-815%E3%80%91%E8%A7%A3%E9%A2%98%E6%8A%A5%E5%91%8A%EF%BC%88%E8%B4%AA%E5%BF%83%EF%BC%8C%E4%BA%8C%E5%88%86%EF%BC%89%2F</url>
    <content type="text"><![CDATA[原始题目 题目大意给出$n \times m$个$10 \times 10$底面积柱子的海拔，以及洪水的总体积，计算洪水覆盖后的海拔高度以及覆盖柱子的百分比。 解题思路 首先$n*m$个柱子可以排序后看作一排。 思路一（自己的）：二分猜答案 先判断洪水是否会淹没所有柱子，如果不是的话那么二分下界为最低海拔，上界为最高海拔。二分答案判断 当前海拔下淹没体积是否达到总洪水体积（计算当前淹没体积的时候也需要二分查找，比较繁琐），这个思路 并没有很好的利用海拔随覆盖柱子数增多而增大的性质。 思路二（网络大神）：简化后贪心 先预处理成$1 \times 1$（或者说直接考虑高度），对柱子高度排序后，我们考虑洪水一定是从低到高填充，那么贪心的 让洪水只填充到当前的柱子，直至平均高度不高于下个柱子，这时候就是最终答案。（tql） 解题代码 二分： 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465666768697071727374757677787980818283848586878889#include &lt;cstdio&gt;#include &lt;cstring&gt;#include &lt;cmath&gt;#include &lt;algorithm&gt;#include &lt;set&gt;#include &lt;queue&gt;#include &lt;map&gt;#include &lt;vector&gt;#include &lt;stack&gt;#include &lt;iostream&gt;#include &lt;iomanip&gt;#include &lt;bits/stdc++.h&gt;#define rep(i,a,n) for(int i=a;i&lt;n;++i)#define per(i,a,n) for(int i=n-a;i&gt;=a;--i)#define se second#define fi first#define pb push_back#define mp make_pair#define np next_permutation#define ms(x,a) memset((x),a,sizeof((x)))#define all(x) x.begin(),x.end()#define eps 1e-9#define INF 0x3f3f3f3fusing namespace std;const int maxn=1e5+5;const int maxl=26;typedef long long ll;typedef unsigned long long ull;typedef vector&lt;int&gt; vi;typedef pair&lt;int,int&gt; pii;double a[maxn];double sum[maxn]; double allflood,maxa;int n,m;double check(double nowl, double allcubic)&#123; int index=lower_bound(a,a+m*n,nowl)-a;// cout&lt;&lt;"index="&lt;&lt;index&lt;&lt;" "; if(index==0) return allcubic; double temp=index*nowl-sum[index-1];// cout&lt;&lt;"temp="&lt;&lt;temp&lt;&lt;endl; return allcubic-(10.0*10.0*temp);&#125;int main()&#123; ios::sync_with_stdio(false); int kase=1; while(cin&gt;&gt;m&gt;&gt;n&amp;&amp;m+n)&#123; maxa=-100000; rep(i,0,m)&#123; rep(j,0,n)&#123; cin&gt;&gt;a[i*n+j]; &#125; &#125; sort(a,a+m*n); sum[0]=a[0]; rep(i,1,n*m) sum[i]=sum[i-1]+a[i]; cin&gt;&gt;allflood;// cout&lt;&lt;"mmin="&lt;&lt;a[0]&lt;&lt;" mmax="&lt;&lt;a[n*m-1]&lt;&lt;endl; //一共n*m个区域； cout&lt;&lt;"Region "&lt;&lt;kase++&lt;&lt;endl; //先判断填满是不是够 double temp=10.0*10.0*(n*m*a[n*m-1]-sum[n*m-1]); if(temp&lt;allflood)&#123; double ans=(allflood-temp)/(100.0*n*m)+a[n*m-1]; cout&lt;&lt;"Water level is "&lt;&lt;fixed&lt;&lt;setprecision(2)&lt;&lt;ans&lt;&lt;" meters."&lt;&lt;endl; cout&lt;&lt;"100.00 percent of the region is under water."&lt;&lt;endl; cout&lt;&lt;endl; continue; &#125; //不够 double l=a[0],r=a[n*m-1],mid=(l+r)/2.0; double ans=check(mid,allflood); while(abs(ans)&gt;eps)&#123; if(ans&gt;0) l=mid; else r=mid; mid=(r+l)/2.0;// cout&lt;&lt;"mid="&lt;&lt;mid&lt;&lt;" "; ans=check(mid,allflood); &#125; int index=lower_bound(a,a+m*n,mid)-a; cout&lt;&lt;"Water level is "&lt;&lt;fixed&lt;&lt;setprecision(2)&lt;&lt;mid&lt;&lt;" meters."&lt;&lt;endl; cout&lt;&lt;fixed&lt;&lt;setprecision(2)&lt;&lt;(double)index*100/(n*m)&lt;&lt;" percent of the region is under water."&lt;&lt;endl; cout&lt;&lt;endl; &#125;&#125; 贪心： 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859#include &lt;cstdio&gt;#include &lt;cstring&gt;#include &lt;cmath&gt;#include &lt;algorithm&gt;#include &lt;set&gt;#include &lt;queue&gt;#include &lt;map&gt;#include &lt;vector&gt;#include &lt;stack&gt;#include &lt;iostream&gt;#include &lt;iomanip&gt;#include &lt;bits/stdc++.h&gt;#define rep(i,a,n) for(int i=a;i&lt;n;++i)#define per(i,a,n) for(int i=n-a;i&gt;=a;--i)#define se second#define fi first#define pb push_back#define mp make_pair#define np next_permutation#define ms(x,a) memset((x),a,sizeof((x)))#define all(x) x.begin(),x.end()#define eps 1e-9#define INF 0x3f3f3f3fusing namespace std;const int maxn=1e5+5;const int maxl=26;typedef long long ll;typedef unsigned long long ull;typedef vector&lt;int&gt; vi;typedef pair&lt;int,int&gt; pii;int n,m;int a[maxn];int main()&#123; ios::sync_with_stdio(false); int kase=0; while(cin&gt;&gt;n&gt;&gt;m&amp;&amp;n+m)&#123; n*=m; rep(i,0,n) cin&gt;&gt;a[i]; sort(a,a+n); double ans; cin&gt;&gt;ans; ans/=100; a[n]=INF; int index=0; rep(i,0,n)&#123; ans+=a[i]; if(ans/(i+1)&lt;=a[i+1])&#123; ans=ans/(i+1); index=i+1; break; &#125; &#125; cout&lt;&lt;"Region "&lt;&lt;++kase&lt;&lt;endl; cout&lt;&lt;"Water level is "&lt;&lt;fixed&lt;&lt;setprecision(2)&lt;&lt;ans&lt;&lt;" meters."&lt;&lt;endl; cout&lt;&lt;fixed&lt;&lt;setprecision(2)&lt;&lt;(double)(index*100)/n&lt;&lt;" percent of the region is under water."&lt;&lt;endl; cout&lt;&lt;endl; &#125;&#125; 收获与反思 代码长度和速度高下立判啊。合理尝试贪心、二分，选择合适方法]]></content>
      <categories>
        <category>编程</category>
        <category>ACM</category>
      </categories>
      <tags>
        <tag>算法</tag>
        <tag>ACM</tag>
        <tag>二分</tag>
        <tag>Greedy</tag>
        <tag>UVA</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[【UVA-101】解题报告（模拟）]]></title>
    <url>%2F2018%2F08%2F23%2F%E3%80%90UVA-101%E3%80%91%E8%A7%A3%E9%A2%98%E6%8A%A5%E5%91%8A%EF%BC%88%E6%A8%A1%E6%8B%9F%EF%BC%89%2F</url>
    <content type="text"><![CDATA[原始题目 题目大意有$n$个积木，初始放在$0,1,2 \cdots n-1$位置上，有四种搭积木操作 move a onto b where a and b are block numbers, puts block a onto block b after returning any blocks that arestacked on top of blocks a and b to their initial positions. 把a和b上的积木放回原来位置，再将a放置到b上。 move a over b where a and b are block numbers, puts block a onto the top of the stack containing block b, afterreturning any blocks that are stacked on top of block a to their initial positions. 把a上的积木放回原来位置，再将a放置在b所在的积木堆上。 pile a onto b where a and b are block numbers, moves the pile of blocks consisting of block a, and any blocksthat are stacked above block a, onto block b. All blocks on top of block b are moved to theirinitial positions prior to the pile taking place. The blocks stacked above block a retain their orderwhen moved. 把b上的积木放回原来位置，再将a和a之上的积木块一起放在b上（保持相对顺序）。 pile a over b where a and b are block numbers, puts the pile of blocks consisting of block a, and any blocksthat are stacked above block a, onto the top of the stack containing block b. The blocks stackedabove block a retain their original order when moved. 把a和a之上的积木块一起放在b所在的积木堆上（保持相对顺序）。 直至遇到quit停止操作，输出最后每个位置上的积木状态。 解题思路 由于不涉及积木块放置在指定位置的操作，还原必定到原有位置且原有位置为空（易证），不用考虑木块放回的特殊情况。 注意判断是否在同一堆上，违法命令不进行任何实际操作 模拟四种操作即可 解题代码 数组模拟四种操作 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147148149150151152153154155156157#include &lt;cstdio&gt;#include &lt;cstring&gt;#include &lt;cmath&gt;#include &lt;algorithm&gt;#include &lt;set&gt;#include &lt;queue&gt;#include &lt;map&gt;#include &lt;vector&gt;#include &lt;stack&gt;#include &lt;iostream&gt;#include &lt;iomanip&gt;#include &lt;bits/stdc++.h&gt;#define rep(i,a,n) for(int i=a;i&lt;n;++i)#define per(i,a,n) for(int i=n-a;i&gt;=a;--i)#define se second#define fi first#define pb push_back#define mp make_pair#define np next_permutation#define ms(x,a) memset((x),a,sizeof((x)))#define all(x) x.begin(),x.end()#define eps 1e-9#define INF 0x3f3f3f3fusing namespace std;const int maxn=1e5+5;const int maxl=26;typedef long long ll;typedef unsigned long long ull;typedef vector&lt;int&gt; vi;typedef pair&lt;int,int&gt; pii;int n,m,a,b;string s1,s2;int top[maxn],bottom[maxn],place[maxn],mmp[maxn];void initial()&#123; rep(i,0,n) top[i]=bottom[i]=place[i]=i; rep(i,0,n) mmp[i]=-1;&#125;void solve(int aa,int bb,int index)&#123; switch(index)&#123; case 1: &#123; while(mmp[aa]!=-1)&#123; int next=mmp[aa]; mmp[aa]=mmp[next]; mmp[next]=-1; top[next]=bottom[next]=place[next]=next; &#125; while(mmp[bb]!=-1)&#123; int next=mmp[bb]; mmp[bb]=mmp[next]; mmp[next]=-1; top[next]=bottom[next]=place[next]=next; &#125; mmp[bb]=aa; int start=top[place[aa]]; if(start==aa) top[aa]=-1; else&#123; while(mmp[start]!=aa) start=mmp[start]; mmp[start]=-1; &#125; place[aa]=place[bb]; &#125; break; case 2: &#123; while(mmp[aa]!=-1)&#123; int next=mmp[aa]; mmp[aa]=mmp[next]; mmp[next]=-1; top[next]=bottom[next]=place[next]=next; &#125; while(mmp[bb]!=-1) bb=mmp[bb]; mmp[bb]=aa; int start=top[place[aa]]; if(start==aa) top[aa]=-1; else&#123; while(mmp[start]!=aa) start=mmp[start]; mmp[start]=-1; &#125; place[aa]=place[bb]; &#125; break; case 3: &#123; while(mmp[bb]!=-1)&#123; int next=mmp[bb]; mmp[bb]=mmp[next]; mmp[next]=-1; top[next]=bottom[next]=place[next]=next; &#125; mmp[bb]=aa; int start=top[place[aa]]; if(start==aa) top[aa]=-1; else&#123; while(mmp[start]!=aa) start=mmp[start]; mmp[start]=-1; &#125; while(mmp[bb]!=-1)&#123; place[mmp[bb]]=place[bb]; bb=mmp[bb]; &#125; &#125; break; case 4: &#123; while(mmp[bb]!=-1) bb=mmp[bb]; mmp[bb]=aa; int start=top[place[aa]]; if(start==aa) top[aa]=-1; else&#123; while(mmp[start]!=aa) start=mmp[start]; mmp[start]=-1; &#125; while(mmp[bb]!=-1)&#123; place[mmp[bb]]=place[bb]; bb=mmp[bb]; &#125; &#125; break; &#125;&#125;int main()&#123; while(cin&gt;&gt;n)&#123; initial(); while(cin&gt;&gt;s1&amp;&amp; s1[0]!='q')&#123; cin&gt;&gt;a&gt;&gt;s2&gt;&gt;b; if(place[a]==place[b]) continue; if(s1[0]=='m' &amp;&amp; s2[1]=='n') solve(a,b,1); if(s1[0]=='m' &amp;&amp; s2[1]=='v') solve(a,b,2); if(s1[0]=='p' &amp;&amp; s2[1]=='n') solve(a,b,3); if(s1[0]=='p' &amp;&amp; s2[1]=='v') solve(a,b,4); &#125; rep(i,0,n)&#123; cout&lt;&lt;i&lt;&lt;":"; if(top[i]==-1) cout&lt;&lt;endl; else &#123; int start=top[i]; cout&lt;&lt;" "&lt;&lt;start; while(mmp[start]!=-1)&#123; start=mmp[start]; cout&lt;&lt;" "&lt;&lt;start; &#125; cout&lt;&lt;endl; &#125; &#125;// cout&lt;&lt;endl; &#125;&#125; vector模拟两种操作 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778#include &lt;bits/stdc++.h&gt;#define rep(i,a,n) for(int i=a;i&lt;n;++i)#define per(i,a,n) for(int i=n-1;i&gt;=a;--i)#define fi first#define se second#define mp make_pair#define pb push_back#define np next_permutation#define cl(x,a,n) memset(x,a,sizeof(int)*n)using namespace std;typedef long long ll;typedef unsigned long long ull;typedef long double ld;typedef vector&lt;int&gt; vi;typedef pair&lt;int,int&gt; pii;typedef pair&lt;string,string&gt; pss;const int maxn=30;int n;vector&lt;int&gt; pile[maxn];void find_block(int a,int &amp;p, int &amp; h) &#123;// 引用形式返回ouke和高度 for( p=0;p&lt;n;p++)&#123; for(h=0;h&lt;pile[p].size();h++)&#123; if(pile[p][h]==a ) return; &#125; &#125;&#125;void clear_above(int p,int h)&#123; for(int i=h+1;i&lt;pile[p].size();i++)&#123; int b=pile[p][i]; pile[b].pb(b); &#125; pile[p].resize(h+1);&#125;void pile_onto(int p,int h,int p2)&#123; for(int i=h; i&lt;pile[p].size();i++)&#123; pile[p2].pb(pile[p][i]); &#125; pile[p].resize(h);&#125;void print()&#123; for(int i=0;i&lt;n;++i)&#123; printf("%d:",i); for(int j=0;j&lt;pile[i].size();j++) printf(" %d",pile[i][j]); printf("\n"); &#125;&#125;int main()&#123; int a,b; cin&gt;&gt;n; string s1,s2; rep(i,0,n) pile[i].pb(i); while(cin&gt;&gt;s1&gt;&gt;a&gt;&gt;s2&gt;&gt;b)&#123; int pa,pb,ha,hb; find_block(a,pa,ha); find_block(b,pb,hb); if(pa==pb) continue; //feifa if(s2=="onto") clear_above(pb,hb); if(s1=="move") clear_above(pa,ha); pile_onto(pa,ha,pb); &#125; print(); return 0;&#125; 收获与反思 大模拟，输出注意PE。]]></content>
      <categories>
        <category>编程</category>
        <category>ACM</category>
      </categories>
      <tags>
        <tag>算法</tag>
        <tag>ACM</tag>
        <tag>Imitation</tag>
        <tag>2018暑假集训</tag>
        <tag>UVA</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[【UVA-10815】解题报告（STL，set）]]></title>
    <url>%2F2018%2F08%2F23%2F%E3%80%90UVA-10815%E3%80%91%E8%A7%A3%E9%A2%98%E6%8A%A5%E5%91%8A%EF%BC%88STL%EF%BC%8Cset%EF%BC%89%2F</url>
    <content type="text"><![CDATA[原始题目 题目大意给定一段含标点的文章，将其中的单词全部按小写的字典序输出。 解题思路 去年做过这个题，当时入门 现在利用strig类和stringstream类可以轻松完成任务 解题代码12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849//set ssteam #include &lt;cstdio&gt;#include &lt;cstring&gt;#include &lt;cmath&gt;#include &lt;algorithm&gt;#include &lt;set&gt;#include &lt;queue&gt;#include &lt;map&gt;#include &lt;vector&gt;#include &lt;stack&gt;#include &lt;iostream&gt;#include &lt;iomanip&gt;#include &lt;sstream&gt;#include &lt;bits/stdc++.h&gt;#define rep(i,a,n) for(int i=a;i&lt;n;++i)#define per(i,a,n) for(int i=n-a;i&gt;=a;--i)#define se second#define fi first#define pb push_back#define mp make_pair#define np next_permutation#define ms(x,a) memset((x),a,sizeof((x)))#define all(x) x.begin(),x.end()#define eps 1e-9#define INF 0x3f3f3f3fusing namespace std;string s,ans;int main()&#123; ios::sync_with_stdio(false);// freopen("in.txt","r",stdin); set &lt;string&gt; sset; while(cin&gt;&gt;s)&#123; //处理一下 rep(i,0,s.length())&#123; if(!isalpha(s[i])) s[i]=' '; else s[i]=tolower(s[i]); &#125;// cout&lt;&lt;s&lt;&lt;endl; stringstream ss(s); while(ss&gt;&gt;ans)&#123; sset.insert(ans); &#125; &#125; for(set&lt;string&gt;::iterator it=sset.begin();it!=sset.end();it++)&#123; cout&lt;&lt;*it&lt;&lt;endl; &#125;&#125; 收获与反思 再多熟练运用一下stringstream]]></content>
      <categories>
        <category>编程</category>
        <category>ACM</category>
      </categories>
      <tags>
        <tag>算法</tag>
        <tag>ACM</tag>
        <tag>2018暑假集训</tag>
        <tag>STL</tag>
        <tag>UVA</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[《我辈孤雏》读书笔记]]></title>
    <url>%2F2018%2F08%2F22%2F%E3%80%8A%E6%88%91%E8%BE%88%E5%AD%A4%E9%9B%8F%E3%80%8B%E8%AF%BB%E4%B9%A6%E7%AC%94%E8%AE%B0%2F</url>
    <content type="text"><![CDATA[内容摘录与笔记第一部 P29 “我一时之间竟说不上话，后来总算把话吐出来：‘您真是太仁慈了，先生，您的协助，我感激不尽，而且我也不希望您以为我不懂事。不过有一点请您谅解，我觉得我不该在这个时候返回英国。’上校一时之间并没有反应……” 第二部 P68 “接下来是针针见血的猛烈抨击，她对督察所用的这一招，我早已熟悉，而日后也还要听她陈述其中概要好多次；她先泛泛地批评英国政府，再把火力集中到私人企业，特别是摩根洋行身上，说他们不该从印度，输入这么庞大数量地鸦片到中国，然后冷眼旁观这整个民族陷入悲惨与堕落，说的时候，母亲地声音常常高张欲裂，不过都尖而未破，她双眼始终不曾放松……” P139 “这么多年来，她让我敬畏有加，可现在我明白这一切全是装腔作势：她丝毫无法控制这个逐渐将我们吞没的混乱世界，她只是个可悲的小女人，全靠伪装在我眼中建立她的形象，当巨大势力相互冲突斗争之际，她根本贱于蝼蚁。我站在走廊上瞪着她，眼神鄙夷至极。” 第三部 再次出现系住百叶窗叶片地细绳。 P153 “因为像您这样的人才，警探先生，这样的人才实在难得。像我们这样的人，我们的职责就是打击坏人，我们……该怎么说好呢？我们就像系住百叶窗叶片的细绳。一旦我们系得不牢靠，一切都会分崩离析。您背负得责任可是相当重大啊，警探先生。” 第四部 P179 “‘不，不，先生’——格雷森先生紧张地笑了笑——‘我指地是另一个欢迎仪式。我的意思是，欢迎令尊令堂历劫多年归来地那个。’” 第五部 P183 “从我抵达地那一刻起，真正教我心里暗暗吃惊的是，这里每一个人都拒绝承认他们都罪有应得。待在这里约两周地时间里，在我所接触的所有这些英国人当中，无论地位高低，我都还没遇到——一次也没有——有谁真心感到愧疚。换言之，在这里，在这个可能吞噬整个闻名世界地大漩涡的涡眼里，大家在心照不宣中无耻可悲地集体否认现实，否认自身的责任，而这种行为转为自我封闭，变本加厉，以冠冕堂皇地自我保护表现于外，这是我经常碰到地情况。而现在眼前地这一群所谓上海的精英，如此不屑一顾地凝望他们地中国邻居在运河对岸受苦受难。” 第六部 P327 “桌上的阅读灯下有一圈温暖的光线，可是房中其他部分都一片幽暗。正当我站在那里观察周遭的情况，有个身影从书桌边站了起来，小心地绕过书桌，回头指着桌后他空出来的座位。‘怎么不过去坐那儿，小海雀？’菲利普叔叔对我说，‘你还记得吧？你以前最喜欢坐我书桌后面的位子了。’” P332 “‘那么我母亲呢？她发生了什么事？’ 菲利普叔叔向前探身，双肘撑着桌子，头部微微往后仰。‘你对于她的事，现在知道的有多少？’他问。他先前在声音里所表现的轻松已经完全消失。他现在看起来有如心事重重的老人，饱受自我悔恨的折磨。尽管他把头往后仰，却还是仔细盯着我看，桌灯的黄光照拂下，看得他白色的鼻毛突出鼻孔。我听到楼下某处，正播放着中国军歌。” P336 “我探身向他，进入桌灯炫目的光亮之中，我有种奇怪的感觉，身后的黑暗愈变愈大，此时在那里摊成了一大片幽暗无光的空间。菲利普叔叔用掌心拭去前额的汗珠。不过他现在专注地看着我，继续说：‘那天后来我去新城饭店见王顾。我尽我所能化解可能面临的灾难。不过为时已晚。他那天下午对我说的话，一点都没有生气的样子。他发现你母亲的精神——他就是这么说的，她的‘精神’——非常迷人。他已经为之倾倒，因此打算娶她为妾，带她回湖南。他说要‘驯服’她，如同对待一匹野生的母马一样。这个你得理解，小海雀，你得理解那时候在上海、在中国是什么样的局势，像王顾这样的人，若是决定要做这类的事，谁也阻止不了他。这点你必须理解。向警方或任何人要求保护你母亲，根本不会有结果。也许能暂时缓一缓，不过终究是无用。没有任何人能保护她，不让这种人得逞。不过你明白吗，我真正担心的是你，小海雀。我不确定他打算怎么处置你，这才是我求他的事。结果我们达成协议。我想办法让她落单，无人守护，而同时我又把你带离现场。我只求他这件事。我不希望他连你也带走。你母亲，只能说是在劫难逃。至于你，还有商量的余地，我就是做了这样的事。’” P338 “‘菲利普叔叔，什么财务安排？’ 他低头看着手背，端详了半晌。‘要不是为了你，她对你的爱，小海雀，我相信你母亲会毫不迟疑结束自己的生命，不会让那个恶棍碰她一下。她总会有办法，也一定会做到。可是她还得担心你。因此，到了最后，她看情势比人强，便做了安排。你将会得到财务上的供应，以换取……换取她的顺从。我亲自监督了大半的程序，经由公司来安排。公司里有个对这件事全无概念的人，还以为这是在为鸦片的安全运送做安排呢！哈！哈！真是个傻子，那个人！’菲利普叔叔摇摇头，面露笑容。接着他的表情又阴沉起来，仿佛他要回到我们原先要谈的主题。 ‘我的生活费，’我平静地说，‘我继承的财产……’‘你在英国的姑妈，她从来就没富有过。真正资助你的人，这么多年来，一直是王顾。’” 在黑夜中摸索，希望能寻得父母那一辈所遗失的真相，奈何在现实的冷酷与成熟面前，我们终究不过孤雏而已，想象不到黑暗中那股势力的强大，压垮了我们本以为还算成熟的臂膀。比起那个时代，我们算得上什么？太过渺小而已。 第七部 P363 “不过，对于我们这种人而言，我们的命运是以孤儿的眼光看待世界，长年追逐着父母消逝的暗影。我们只有尽全力把使命完成，别无解脱之途，在此之前，心中无法得到片刻的宁静。”]]></content>
      <categories>
        <category>阅读</category>
      </categories>
      <tags>
        <tag>阅读</tag>
        <tag>小说</tag>
        <tag>文学</tag>
        <tag>石黑一雄</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[【POJ-3660】解题报告（Floyd传递闭包）]]></title>
    <url>%2F2018%2F08%2F22%2F%E3%80%90POJ-3660%E3%80%91%E8%A7%A3%E9%A2%98%E6%8A%A5%E5%91%8A%EF%BC%88Floyd%E4%BC%A0%E9%80%92%E9%97%AD%E5%8C%85%EF%BC%89%2F</url>
    <content type="text"><![CDATA[原始题目Cow Contest Time Limit: 1000MS Memory Limit: 65536K Total Submissions: 15815 Accepted: 8813 DescriptionN (1 ≤ N ≤ 100) cows, conveniently numbered 1..N, are participating in a programming contest. As we all know, some cows code better than others. Each cow has a certain constant skill rating that is unique among the competitors. The contest is conducted in several head-to-head rounds, each between two cows. If cow A has a greater skill level than cow B (1 ≤ A ≤ N; 1 ≤ B ≤ N; A ≠ B), then cow A will always beat cow B. Farmer John is trying to rank the cows by skill level. Given a list the results of M (1 ≤ M ≤ 4,500) two-cow rounds, determine the number of cows whose ranks can be precisely determined from the results. It is guaranteed that the results of the rounds will not be contradictory. Input Line 1: Two space-separated integers: N and M Lines 2..M+1: Each line contains two space-separated integers that describe the competitors and results (the first integer, A, is the winner) of a single round of competition: A and B Output Line 1: A single integer representing the number of cows whose ranks can be determined Sample Input5 5 4 3 4 2 3 2 1 2 2 5 Sample Output2 SourceUSACO 2008 January Silver 题目大意一共有N头牛，现在知道M条信息，每条信息描述两头牛谁更强一些，问可以确定最多多少头牛的排名。 解题思路 还在学习中，使用Floyd算法求闭包，（A胜B，B胜C，则传递A胜C） 然后对于每头牛扫一遍是否与其他n-1头牛都有确定的胜负关系，如果有的话答案++。 还需要深入学习Floyd算法 解题代码123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960#include &lt;cstdio&gt;#include &lt;cstring&gt;#include &lt;cmath&gt;#include &lt;iostream&gt;#include &lt;iomanip&gt;#include &lt;algorithm&gt;#include &lt;set&gt;#include &lt;map&gt;#include &lt;vector&gt;#include &lt;stack&gt;#include &lt;queue&gt;#define mp make_pair#define pb push_back#define np next_permutation#define rep(i,a,n) for(int i=a;i&lt;n;++i)#define per(i,a,n) for(int i=n-1;i&gt;=a;--i)#define first fi#define second se#define eps 1e-9#define INF 0x3f3f3f3f#define ms(x,a) memset((x),a,sizeof((x)))#define all(x) x.begin(),x.end()#define gapline cout&lt;&lt;"##================##"&lt;&lt;endlusing namespace std;const int maxn=1e3+5;const int mal=26;typedef long long ll;typedef unsigned long long ull;typedef vector&lt;int&gt; vi;typedef pair&lt;int,int&gt; pii;bool ans[maxn][maxn]; int n,m;void Floyd()&#123; rep(k,1,n+1) rep(i,1,n+1) rep(j,1,n+1) ans[i][j]=ans[i][j]|(ans[i][k]&amp;ans[k][j]); &#125;int main()&#123; ios::sync_with_stdio(false); while(cin&gt;&gt;n)&#123; cin&gt;&gt;m; ms(ans,0); rep(i,0,m)&#123; int a,b; cin&gt;&gt;a&gt;&gt;b; ans[a][b]=1; &#125; Floyd(); int aans=0; rep(i,1,n+1)&#123; int ccnt=0; rep(j,1,n+1)&#123; if(ans[i][j]||ans[j][i]) ccnt++; &#125; if(ccnt==n-1) aans++; &#125; cout&lt;&lt;aans&lt;&lt;endl; &#125; &#125; 收获与反思 挖坑，加强理解Floyd最短路算法。]]></content>
      <categories>
        <category>编程</category>
        <category>ACM</category>
      </categories>
      <tags>
        <tag>算法</tag>
        <tag>ACM</tag>
        <tag>2018暑假集训</tag>
        <tag>POJ</tag>
        <tag>Floyd</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[【HDU-1548】解题报告（BFS）]]></title>
    <url>%2F2018%2F08%2F22%2F%E3%80%90HDU-1548%E3%80%91%E8%A7%A3%E9%A2%98%E6%8A%A5%E5%91%8A%EF%BC%88BFS%EF%BC%89%2F</url>
    <content type="text"><![CDATA[原始题目A strange lift Time Limit: 2000/1000 MS (Java/Others) Memory Limit: 65536/32768 K (Java/Others) Total Submission(s): 32759 Accepted Submission(s): 11752 Problem DescriptionThere is a strange lift.The lift can stop can at every floor as you want, and there is a number $K_i (0 \le K_i \le N) $ on every floor.The lift have just two buttons: up and down.When you at floor i,if you press the button “UP” , you will go up $K_i$ floor,i.e,you will go to the i+Ki th floor,as the same, if you press the button “DOWN” , you will go down $K_i$ floor,i.e,you will go to the i-Ki th floor.Of course, the lift can’t go up high than N,and can’t go down lower than 1. For example, there is a buliding with 5 floors, and $k_1 = 3, k_2 = 3 , k_3 = 1 , k_4 = 2 , k_5 = 5 . $ Begining from the 1 st floor,you can press the button “UP”, and you’ll go up to the 4 th floor,and if you press the button “DOWN”, the lift can’t do it, because it can’t go down to the -2 th floor,as you know ,the -2 th floor isn’t exist. Here comes the problem: when you are on floor A,and you want to go to floor B,how many times at least he has to press the button “UP” or “DOWN”? InputThe input consists of several test cases.,Each test case contains two lines. The first line contains three integers $N,A,B( 1 \le N,A,B \le 200)$ which describe above,The second line consist $N$ integers $k_1,k_2 \cdots k_n$ . A single 0 indicate the end of the input. OutputFor each case of the input output a interger, the least times you have to press the button when you on floor A,and you want to go to floor B.If you can’t reach floor B,printf “-1”. Sample Input5 1 5 3 3 1 2 5 0 Sample Output3 Recommend8600 题目大意有一个电梯，对于每一层$i$，只能上升或者下降$a_i$（不能低于$1$层或高于$n$层），现在给定初态层数和末态层数，问最少需要操作几次才可以达到末态层数。到达不了输出-1。 解题思路 两方向BFS，注意打标记和输出-1的情况即可。 解题代码123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566#include &lt;cstdio&gt;#include &lt;cstring&gt;#include &lt;iostream&gt;#include &lt;iomanip&gt;#include &lt;map&gt;#include &lt;set&gt;#include &lt;algorithm&gt;#include &lt;queue&gt;#include &lt;vector&gt;#include &lt;stack&gt;//#include &lt;bits/stdc++.h&gt;//#define mp make_pair#define np next_permutation#define pb push_back#define fi first#define se second#define eps 1e-8#define INF 0x3f3f3f3f#define rep(i,a,n) for(int i=a;i&lt;n;++i)#define per(i,a,n) for(int i=n-1;i&gt;=a;--i)using namespace std;typedef long long ll;typedef unsigned long long ull;typedef vector&lt;int&gt; vi;typedef pair&lt;int,int&gt; pii;const int maxn=1e4+5;int vis[maxn];int mp[maxn],n,a,b;void bfs()&#123; int ans=0; int flag=0; queue&lt;pii&gt;q; q.push(make_pair(a,0)); memset(vis,0,sizeof(vis)); vis[a]=1; while(!q.empty())&#123; pii now=q.front(); q.pop(); if(now.fi==b)&#123; cout&lt;&lt;now.second&lt;&lt;endl; flag=1; break; &#125; int down=now.fi-mp[now.fi]; int up=now.fi+mp[now.fi];// cout&lt;&lt;"up="&lt;&lt;up&lt;&lt;" down="&lt;&lt;down&lt;&lt;endl; if(down&gt;=1 &amp;&amp; !vis[down])&#123; vis[down]=1; q.push(make_pair(down,now.second+1)); &#125; if(up&lt;=n &amp;&amp; !vis[up])&#123; vis[up]=1; q.push(make_pair(up,now.second+1)); &#125; &#125; if(!flag) cout&lt;&lt;-1&lt;&lt;endl;&#125;int main()&#123; ios::sync_with_stdio(false); while(cin&gt;&gt;n&amp;&amp;n)&#123; cin&gt;&gt;a&gt;&gt;b; rep(i,1,n+1) cin&gt;&gt;mp[i]; bfs(); &#125; &#125; 收获与反思 简单bfs，注意打对标记即可。]]></content>
      <categories>
        <category>编程</category>
        <category>ACM</category>
      </categories>
      <tags>
        <tag>算法</tag>
        <tag>ACM</tag>
        <tag>2018暑假集训</tag>
        <tag>BFS</tag>
        <tag>HDU</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[【CodeForces-579A】解题报告（二进制）]]></title>
    <url>%2F2018%2F08%2F22%2F%E3%80%90CodeForces-579A%E3%80%91%E8%A7%A3%E9%A2%98%E6%8A%A5%E5%91%8A%EF%BC%88%E4%BA%8C%E8%BF%9B%E5%88%B6%EF%BC%89%2F</url>
    <content type="text"><![CDATA[原始题目A. Raising Bacteria time limit per test1 second memory limit per test256 megabytes inputstandard input outputstandard output You are a lover of bacteria. You want to raise some bacteria in a box. Initially, the box is empty. Each morning, you can put any number of bacteria into the box. And each night, every bacterium in the box will split into two bacteria. You hope to see exactly x bacteria in the box at some moment. What is the minimum number of bacteria you need to put into the box across those days? InputThe only line containing one integer x (1 ≤ x ≤ $10^9$). OutputThe only line containing one integer: the answer. Examplesinput5 output2 input8 output1 NoteFor the first sample, we can add one bacterium in the box in the first day morning and at the third morning there will be 4 bacteria in the box. Now we put one more resulting 5 in the box. We added 2 bacteria in the process so the answer is 2. For the second sample, we can put one in the first morning and in the 4-th morning there will be 8 in the box. So the answer is 1. 题目大意初始盒子是空的，每天早晨你可以放任意个细菌到盒子盒子中去，每个细菌在盒子中每天分裂成两个。现在给出x，问最少需要放多少个细菌可以使一定天数后盒子中细菌数量恰好为x。 解题思路 在不限制天数的情况下，恰巧达到x就让每个放入的细菌尽可能繁殖 将x用二进制表示，有多少个1即为答案。 解题代码123456789101112131415161718192021222324252627282930313233343536373839#include &lt;cstdio&gt;#include &lt;cstring&gt;#include &lt;iostream&gt;#include &lt;iomanip&gt;#include &lt;map&gt;#include &lt;set&gt;#include &lt;algorithm&gt;#include &lt;queue&gt;#include &lt;vector&gt;#include &lt;stack&gt;#include &lt;bits/stdc++.h&gt;#define mp make_pair#define np next_permutation#define pb push_back#define fi first#define se second#define eps 1e-8#define INF 0x3f3f3f3fusing namespace std;typedef long long ll;typedef unsigned long long ull;typedef vector&lt;int&gt; vi;typedef pair&lt;int,int&gt; pii;const int maxn=1e5+5;const int maxl=26;ll n;int main()&#123; ios::sync_with_stdio(false); while(cin&gt;&gt;n)&#123; ll ans=0; while(n)&#123; if(n&amp;1) ans++; n&gt;&gt;=1; &#125; cout&lt;&lt;ans&lt;&lt;endl; &#125; &#125; 收获与反思 思维]]></content>
      <categories>
        <category>编程</category>
        <category>ACM</category>
      </categories>
      <tags>
        <tag>算法</tag>
        <tag>ACM</tag>
        <tag>2018暑假集训</tag>
        <tag>CodeForces</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[【HDU-1430】解题报告（数论，康拓展开逆展开，简单哈希，BFS）]]></title>
    <url>%2F2018%2F08%2F22%2F%E3%80%90HDU-1430%E3%80%91%E8%A7%A3%E9%A2%98%E6%8A%A5%E5%91%8A%EF%BC%88%E6%95%B0%E8%AE%BA%EF%BC%8C%E5%BA%B7%E6%8B%93%E5%B1%95%E5%BC%80%E9%80%86%E5%B1%95%E5%BC%80%EF%BC%8C%E7%AE%80%E5%8D%95%E5%93%88%E5%B8%8C%EF%BC%8CBFS%EF%BC%89%2F</url>
    <content type="text"><![CDATA[原始题目魔板 Time Limit: 10000/5000 MS (Java/Others) Memory Limit: 65536/32768 K (Java/Others) Total Submission(s): 4318 Accepted Submission(s): 1033 Problem Description在魔方风靡全球之后不久，Rubik先生发明了它的简化版——魔板。魔板由8个同样大小的方块组成，每个方块颜色均不相同，可用数字1-8分别表示。任一时刻魔板的状态可用方块的颜色序列表示：从魔板的左上角开始，按顺时针方向依次写下各方块的颜色代号，所得到的数字序列即可表示此时魔板的状态。例如，序列(1,2,3,4,5,6,7,8)表示魔板状态为： 1 2 3 48 7 6 5 对于魔板，可施加三种不同的操作，具体操作方法如下： A: 上下两行互换,如上图可变换为状态87654321 B: 每行同时循环右移一格,如上图可变换为41236785 C: 中间4个方块顺时针旋转一格,如上图可变换为17245368 给你魔板的初始状态与目标状态，请给出由初态到目态变换数最少的变换步骤，若有多种变换方案则取字典序最小的那种。 Input每组测试数据包括两行，分别代表魔板的初态与目态。 Output对每组测试数据输出满足题意的变换步骤。 Sample Input12345678 17245368 12345678 82754631 Sample OutputC AC AuthorLL SourceACM暑期集训队练习赛（三） Recommendlinle 题目大意如题 解题思路 先考虑暴力，对于每个初态，按A，B，C的顺序BFS，到末态，输出。 不过，似乎有些问题。 问题1：如何表示状态？ 问题2：多组数据每次都BFS的话，会T，咋办？ 对于问题1，我们不难发现，不同状态其实对应了1-8的一个排列，很明显根据常识我们知道排列是有顺序的（逆序数逐渐增大）那么我们可否根据排列的数组得到他对应全排列里的序号？其实这和康托展开就搭上关系了。 康拓展开：康托展开是一个全排列到一个自然数的双射，常用于构建哈希表时的空间压缩。 康托展开的实质是计算当前排列在所有由小到大全排列中的顺序，因此是可逆的。 稍微详细点的介绍放在收获与反思里。 这样我们就解决了表示状态的问题。 那么对于问题2呢。我们会发现，魔板从初态到末态，重要的是每个板子相对位置的变化，而不是板子的数。换言之，我们可以做一个初态到’12345678’的映射，重新给板子标号，再将末态各板子按映射关系对应新的标号，即末态按照映射对应一个新标号的末态。 初态 末态 75621483 -&gt; 13846572 ↓ 映射 12345678 -&gt; 58763214 代码为 rep(i,0,len1){ hhash[raw1[i]-&#39;0&#39;]=i+1; } rep(i,0,len1){ b[i]=hhash[raw2[i]-&#39;0&#39;]; } 保留板子相对移动的位置不变化即可，这样我们只要预处理一下’12345678’到各个排列的末态，然后对每组输入，做映射到’12345678’，输出新末态的结果即可。 解题代码123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135#include &lt;cstdio&gt;#include &lt;cstring&gt;#include &lt;cmath&gt;#include &lt;string&gt;#include &lt;iostream&gt;#include &lt;iomanip&gt;#include &lt;sstream&gt;#include &lt;set&gt;#include &lt;map&gt;#include &lt;queue&gt;#include &lt;vector&gt;#include &lt;bits/stdc++.h&gt;#define INF 0x3f3f3f3f#define eps 1e-8#define mp make_pair#define np next_permutation#define pb push_back#define all(x) x.begin(),x.end()#define rep(i,a,n) for(int i=a;i&lt;n;++i)#define per(i,a,n) for(int i=n-1;i&gt;=a;--i)#define ms(x,a) memset((x),a,sizeof((x))) #define mod 998244353 #define gapline cout&lt;&lt;"##---------------##"&lt;&lt;endlusing namespace std;typedef long long ll;typedef unsigned long long ull;typedef vector&lt;int&gt; vi;typedef pair&lt;int,int&gt; pii;const int maxl=8;const int maxn=1e5+5;int A[maxl];//阶乘； int ans_cantor[maxl];//康托展开数组 int next_cantor[maxl];bool vis_cantor[maxl];//康托标记数组 bool vis[maxn];int hhash[20],b[20];string ans[maxn];string raw1,raw2;queue &lt;ll&gt; q;void prechange()&#123; int len1=raw1.length(); rep(i,0,len1)&#123; hhash[raw1[i]-'0']=i+1; &#125; rep(i,0,len1)&#123; b[i]=hhash[raw2[i]-'0']; &#125;&#125;//contar展开，逆展开，数组标号都是从0开始 void cantor(int contar_s[], ll num, int contar_k)&#123;//康托展开，把一个数字num展开成一个数组contar_s，contar_k是数组长度 int t; memset(vis_cantor, 0, sizeof(vis_cantor)); for(int i = 0; i &lt; contar_k; i ++)&#123; t = num / A[contar_k-i-1]; num%=A[contar_k-i-1]; int cnt_cantor=0; rep(j,0,contar_k)&#123; //计算每位的逆序数 if(vis_cantor[j]) continue; if(cnt_cantor==t)&#123; contar_s[i]=j+1,vis_cantor[j]=1;break; &#125; ++cnt_cantor; &#125; &#125;// rep(i,0,contar_k) cout&lt;&lt;contar_s[i]&lt;&lt;' '; //输出康拖展开的结果 // cout&lt;&lt;endl;// gapline;&#125;ll inv_cantor(int contar_s[], int contar_k)&#123;//康托逆展开，把一个数组contar_s换算成一个数字num int cnt;ll num=0; num = 0; for(int i = 0; i &lt; contar_k; i ++)&#123; cnt = 0; for(int j = i + 1; j &lt; contar_k; j ++)&#123; if(contar_s[i] &gt; contar_s[j]) cnt ++;//判断几个数小于它,即求逆序数。 &#125; num += A[contar_k-i-1] * cnt; &#125; return num;&#125;void change(int i)&#123; switch(i)&#123; case 0: //操作A rep(j,0,4) swap(next_cantor[j],next_cantor[maxl-1-j]); break; case 1: //操作B per(j,1,4) swap(next_cantor[(j+1)%4],next_cantor[j]); swap(next_cantor[4],next_cantor[7]); swap(next_cantor[5],next_cantor[4]); swap(next_cantor[6],next_cantor[5]); break; case 2: //操作C swap(next_cantor[1],next_cantor[2]); swap(next_cantor[1],next_cantor[6]); swap(next_cantor[6],next_cantor[5]); break; &#125;&#125;void bfs()&#123; A[0]=A[1]=1; A[2]=2; rep(i,3,maxl+1) A[i]=A[i-1]*i; while(!q.empty()) q.pop(); q.push(0); vis[0]=1; while(!q.empty())&#123; ll temp1=q.front();q.pop(); cantor(ans_cantor,temp1,maxl); rep(i,0,3)&#123; rep(j,0,maxl) next_cantor[j]=ans_cantor[j]; change(i); ll temp2=inv_cantor(next_cantor,maxl); if(!vis[temp2])&#123; q.push(temp2); vis[temp2]=1; ans[temp2]=ans[temp1]+(char)('A'+i); &#125; &#125; &#125;&#125; int main()&#123; ios::sync_with_stdio(false); bfs(); while(cin&gt;&gt;raw1&gt;&gt;raw2)&#123; prechange(); //b[]为最终目标态 ll cnt=inv_cantor(b,maxl); cout&lt;&lt;ans[cnt]&lt;&lt;endl; &#125; &#125; 收获与反思 本题综合应用了数论里的康托展开（用于找到状态数和排列之间的联系），hash到相同情况讨论，以及BFS，值得深入考虑 关于康托展开 https://www.cnblogs.com/linyujun/p/5205760.html 大部分是通过这篇博客以及其他资料学习的，感谢原作者！ 公式为 X = a_n \times (n-1)! + a_{n-1} \times (n-2)! + \cdots + a_2 \times 1! + a_1 \times 0! 其中$a_n$表示第i个元素在未出现的元素中排列第几（从0开始） ，也可以理解成$a_n$表示该位的逆序数。 康托展开得到的X，就是该排列在全排列中的顺序（从0开始）。 逆展开就是循环除以(n-1)!，商为第n位在未出现元素排列第几（从0开始）。模为下一位的被除数。 在详细的等开个数论专题（挖坑）。]]></content>
      <categories>
        <category>编程</category>
        <category>ACM</category>
      </categories>
      <tags>
        <tag>算法</tag>
        <tag>ACM</tag>
        <tag>2018暑假集训</tag>
        <tag>BFS</tag>
        <tag>数论</tag>
        <tag>待补充</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[【AtCoder-4247】解题报告（水题）]]></title>
    <url>%2F2018%2F08%2F22%2F%E3%80%90AtCoder-4247%E3%80%91%E8%A7%A3%E9%A2%98%E6%8A%A5%E5%91%8A%EF%BC%88%E6%B0%B4%E9%A2%98%EF%BC%89%2F</url>
    <content type="text"><![CDATA[原始题目B - 105 Time limit : 2sec / Memory limit : 1000MB Score: 200 points Problem StatementThe number 105 is quite special - it is odd but still it has eight divisors. Now, your task is this: how many odd numbers with exactly eight positive divisors are there between 1 and N (inclusive)? Constraints N is an integer between 1 and 200 (inclusive). InputInput is given from Standard Input in the following format: N OutputPrint the count. Sample Input 1105 Sample Output 11 Among the numbers between 1 and 105, the only number that is odd and has exactly eight divisors is 105. Sample Input 27 Sample Output 20 1 has one divisor. 3, 5 and 7 are all prime and have two divisors. Thus, there is no number that satisfies the condition. 题目大意给定n，求1到n恰好又8个因数的数字有多少个 集体思路 水题，预处理一下因子个数，再求一下前缀和就行。 解题代码123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960#include &lt;cstdio&gt;#include &lt;cstring&gt;#include &lt;cmath&gt;#include &lt;string&gt;#include &lt;iostream&gt;#include &lt;iomanip&gt;#include &lt;sstream&gt;#include &lt;set&gt;#include &lt;map&gt;#include &lt;queue&gt;#include &lt;vector&gt;#include &lt;bits/stdc++.h&gt;#define INF 0x3f3f3f3f#define eps 1e-8#define mp make_pair#define np next_permutation#define pb push_back#define all(x) (x.begin(),x.end())#define rep(i,a,n) for(int i=a;i&lt;n;++i)#define per(i,a,n) for(int i=n-1;i&gt;=a;--i) #define fi first#define se second using namespace std;const int maxn=1e4+5;const int maxl=26;typedef long long ll;typedef unsigned long long ull;typedef vector&lt;int&gt; vi;typedef pair&lt;int,int&gt; pii; int cnt[maxn],ans[maxn];void solve()&#123; rep(i,1,300) cnt[i]++; rep(i,2,300)&#123; for(int j=1;j*i&lt;=300;j++)&#123; cnt[i*j]++; &#125; &#125; int ccnt=0;ans[0]=0; rep(i,1,300) &#123; if(cnt[i]==8 and (i&amp;1))&#123; ans[i]=++ccnt; &#125; else ans[i]=ccnt; &#125; rep(i,1,300) &#123;// cout&lt;&lt;"ans["&lt;&lt;i&lt;&lt;"]="&lt;&lt;ans[i]&lt;&lt;endl; &#125;&#125; int a,b;int main()&#123; ios::sync_with_stdio(false); solve(); int n; while(cin&gt;&gt;n) cout&lt;&lt;ans[n]&lt;&lt;endl;&#125; 收获与反思无]]></content>
      <categories>
        <category>编程</category>
        <category>ACM</category>
      </categories>
      <tags>
        <tag>算法</tag>
        <tag>ACM</tag>
        <tag>AtCoder</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[【AtCoder-4242】解题报告（思维，水题）]]></title>
    <url>%2F2018%2F08%2F22%2F%E3%80%90AtCoder-4242%E3%80%91%E8%A7%A3%E9%A2%98%E6%8A%A5%E5%91%8A%EF%BC%88%E6%80%9D%E7%BB%B4%EF%BC%8C%E6%B0%B4%E9%A2%98%EF%BC%89%2F</url>
    <content type="text"><![CDATA[原始题目C - To Infinity Time limit : 2sec / Memory limit : 1000MB Score: 300 points Problem StatementMr. Infinity has a string S consisting of digits from 1 to 9. Each time the date changes, this string changes as follows: Each occurrence of 2 in S is replaced with 22. Similarly, each 3 becomes 333, 4 becomes 4444, 5 becomes 55555, 6 becomes 666666, 7 becomes 7777777, 8 becomes 88888888 and 9 becomes 999999999. 1 remains as 1. For example, if S is 1324, it becomes 1333224444 the next day, and it becomes 133333333322224444444444444444 the day after next. You are interested in what the string looks like after $5 \times 10^{15}$ days. What is the K-th character from the left in the string after $5 \times 10^{15}$ days? Constraints S is a string of length between 1 and 100 (inclusive). K is an integer between 1 and $10^{18}$ (inclusive). The length of the string after $5 \times 10^{15}$ days is at least K. InputInput is given from Standard Input in the following format: S K OutputPrint the K-th character from the left in Mr. Infinity’s string after 5×1015 days. Sample Input 11214 4 Sample Output 12 The string S changes as follows: Now: 1214 After one day: 12214444 After two days: 1222214444444444444444 After three days: 12222222214444444444444444444444444444444444444444444444444444444444444444 The first five characters in the string after 5×1015 days is 12222. As K=4, we should print the fourth character, 2. Sample Input 23 157 Sample Output 23 The initial string is 3. The string after 5×1015 days consists only of 3. Sample Input 3299792458 9460730472580800 Sample Output 32 题目大意给定初始的一串数字，之后每一天每个数字会复制该数字次，比如’12223’，下一天变为’1222222333’，如此类推，问经过$5 \times 10^{15}$天后第k位数字是多少。 解题思路由于天数是固定的，而且很大，即便一位2经过5×1015，位数会变为$2^{5 \times 10^{15}}$ ，远超过 $10^{18}$所以只要判断第几位非1即可。 解题代码1234567891011121314151617181920212223242526272829303132333435363738394041424344454647#include &lt;cstdio&gt;#include &lt;cstring&gt;#include &lt;cmath&gt;#include &lt;string&gt;#include &lt;iostream&gt;#include &lt;iomanip&gt;#include &lt;sstream&gt;#include &lt;set&gt;#include &lt;map&gt;#include &lt;queue&gt;#include &lt;vector&gt;#include &lt;bits/stdc++.h&gt;#define INF 0x3f3f3f3f#define eps 1e-8#define mp make_pair#define np next_permutation#define pb push_back#define all(x) (x.begin(),x.end())#define rep(i,a,n) for(int i=a;i&lt;n;++i)#define per(i,a,n) for(int i=n-1;i&gt;=a;--i) #define fi first#define se second using namespace std;const int maxn=1e4+5;const int maxl=26;typedef long long ll;typedef unsigned long long ull;typedef vector&lt;int&gt; vi;typedef pair&lt;int,int&gt; pii;int main()&#123; ios::sync_with_stdio(false); string s; ull k; while(cin&gt;&gt;s&gt;&gt;k)&#123; int index=0; for(int i=0;i&lt;s.length();i++)&#123; if(s[i]!='1')&#123; index=i; break; &#125; &#125; if(k-1&lt;index) cout&lt;&lt;1&lt;&lt;endl; else cout&lt;&lt;s[index]&lt;&lt;endl; &#125;&#125; 收获与反思 思考一下即可，不过拓展应该是天数可变的时候，有机会找一下相关题再补吧。]]></content>
      <categories>
        <category>编程</category>
        <category>ACM</category>
      </categories>
      <tags>
        <tag>算法</tag>
        <tag>ACM</tag>
        <tag>AtCoder</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[【AtCoder-4244】解题报告（暴力，DP）]]></title>
    <url>%2F2018%2F08%2F22%2F%E3%80%90AtCoder-4244%E3%80%91%E8%A7%A3%E9%A2%98%E6%8A%A5%E5%91%8A%EF%BC%88%E6%9A%B4%E5%8A%9B%EF%BC%8CDP%EF%BC%89%2F</url>
    <content type="text"><![CDATA[原始题目D - AtCoder Express 2 Time limit : 3sec / Memory limit : 1000MB Score: 400 points Problem StatementIn Takahashi Kingdom, there is a east-west railroad and N cities along it, numbered 1, 2, 3, …, N from west to east. A company called AtCoder Express possesses M trains, and the train i runs from City Li to City Ri (it is possible that Li=Ri). Takahashi the king is interested in the following Q matters: The number of the trains that runs strictly within the section from City pi to City qi, that is, the number of trains j such that pi≤Lj and Rj≤qi. Although he is genius, this is too much data to process by himself. Find the answer for each of these Q queries to help him. Constraints N is an integer between 1 and 500 (inclusive). M is an integer between 1 and 200 000 (inclusive). Q is an integer between 1 and 100 000 (inclusive). 1≤Li≤Ri≤N (1≤i≤M) 1≤pi≤qi≤N (1≤i≤Q) InputInput is given from Standard Input in the following format: N M Q L1 R1 L2 R2 : LM RM p1 q1 p2 q2 : pQ qQ OutputPrint Q lines. The i-th line should contain the number of the trains that runs strictly within the section from City pi to City qi. Sample Input 12 3 1 1 1 1 2 2 2 1 2 Sample Output 13 As all the trains runs within the section from City 1 to City 2, the answer to the only query is 3. Sample Input 210 3 2 1 5 2 8 7 10 1 7 3 10 Sample Output 21 1 The first query is on the section from City 1 to 7. There is only one train that runs strictly within that section: Train 1. The second query is on the section from City 3 to 10. There is only one train that runs strictly within that section: Train 3. Sample Input 310 10 10 1 6 2 9 4 5 4 7 4 7 5 8 6 6 6 7 7 9 10 10 1 8 1 9 1 10 2 8 2 9 2 10 3 8 3 9 3 10 1 10 Sample Output 37 9 10 6 8 9 6 7 8 10 题目大意在一条东西向的铁路上有$1,2,3 \cdots N $ 个城市，列车公司有$M$列火车，每列火车从$L_i$行驶到 $R_i( L_i \le R_i)$，现在有$Q$个询问每次询问$p_i,q_i$ 两个城市间有多少躺列车的行驶路程恰好再在两城市之间（包括端点）。 解题思路 暴力：由于只需要计数，那么以每个城市为集合，统计该城市出发的列车的行使距离，对于每次询问，遍历pi到qi城市的集合判断距离是否小于终点到遍历点的距离即可。 DP： 把列车行驶看作线段，很明显大的线段包含小的线段。由此联想可以由内向外扩展，考虑DP 以终点作为集合，元素为起始点，预处理后对每个集合排序（代码实际应用vector而非set，因为set不支持迭代器随机访问而且可能会有重复线路） $dp[i][j]$表示从i城市到j城市包含的火车线路。 则状态转移方程为$dp[i][j]=dp[i][j-1]+num[i][j]$ ，$num[i][j]$表示到达j城市且起点不在i城市之前的列车线路数。 求$num[i][j]$，用二分查找lower_bound找到j城市集合中第一个大于等于i的位置，$num[i][j]$即为size减去前缀。 预处理后直接可以输出答案 解题代码 暴力 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364656667686970#include &lt;cstdio&gt;#include &lt;cstring&gt;#include &lt;cmath&gt;#include &lt;string&gt;#include &lt;iostream&gt;#include &lt;iomanip&gt;#include &lt;sstream&gt;#include &lt;set&gt;#include &lt;map&gt;#include &lt;queue&gt;#include &lt;vector&gt;#include &lt;bits/stdc++.h&gt;#define INF 0x3f3f3f3f#define eps 1e-8#define mp make_pair#define np next_permutation#define pb push_back#define all(x) (x.begin(),x.end())#define rep(i,a,n) for(int i=a;i&lt;n;++i)#define per(i,a,n) for(int i=n-1;i&gt;=a;--i)using namespace std; const int maxn=500+5; vector &lt;int&gt; v[maxn]; bool vis[maxn]; void init()&#123; rep(i,0,maxn) v[i].clear(); memset(vis,0,sizeof(vis));&#125; void addedge(int l,int r)&#123; int len=r-l; v[l].pb(len);&#125; int checkedge(int l,int len)&#123;// if(v[l].begin()!=v[l].end()) // cout&lt;&lt;*v[l].begin()&lt;&lt;endl; int ans=upper_bound(v[l].begin(),v[l].end(),len)-v[l].begin();// cout&lt;&lt;"ans="&lt;&lt;ans&lt;&lt;endl; return ans;&#125;int n,m,q,li,ri,pi,qi; int main()&#123; ios::sync_with_stdio(false); while(cin&gt;&gt;n&gt;&gt;m&gt;&gt;q)&#123; init(); rep(i,0,m)&#123; cin&gt;&gt;li&gt;&gt;ri; addedge(li,ri); vis[li]=1; &#125; rep(i,0,maxn)&#123; if(vis[i]) sort(v[i].begin(),v[i].end()); &#125; rep(i,0,q)&#123; cin&gt;&gt;pi&gt;&gt;qi; int cnt=0; for(int i=pi;i&lt;=qi;i++)&#123; int plen=qi-i;// cout&lt;&lt;"plen="&lt;&lt;plen&lt;&lt;endl; cnt+=checkedge(i,plen); &#125; cout&lt;&lt;cnt&lt;&lt;endl; &#125; &#125; &#125; DP 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354#include &lt;cstdio&gt;#include &lt;cstring&gt;#include &lt;cmath&gt;#include &lt;string&gt;#include &lt;iostream&gt;#include &lt;iomanip&gt;#include &lt;sstream&gt;#include &lt;set&gt;#include &lt;map&gt;#include &lt;queue&gt;#include &lt;vector&gt;#include &lt;bits/stdc++.h&gt;#define INF 0x3f3f3f3f#define eps 1e-8#define mp make_pair#define np next_permutation#define pb push_back#define all(x) x.begin(),x.end()#define rep(i,a,n) for(int i=a;i&lt;n;++i)#define per(i,a,n) for(int i=n-1;i&gt;=a;--i)using namespace std; const int maxn=500+5;typedef long long ll;typedef vector&lt;int&gt; vi;typedef pair&lt;int,int&gt; pii; vi v[maxn];int dp[maxn][maxn];int n,m,q,li,ri,pi,qi;void solve()&#123; rep(i,1,n+1) sort(v[i].begin(),v[i].end()); memset(dp,0,sizeof(dp)); rep(l,1,n+1)&#123; for(int r=l;r&lt;=n;r++)&#123; dp[l][r]=dp[l][r-1];// if(r-1&lt;l) continue; dp[l][r]+=(v[r].size()-(lower_bound(v[r].begin(),v[r].end(),l)-v[r].begin())); &#125; &#125;&#125;int main()&#123; ios::sync_with_stdio(false); while(cin&gt;&gt;n&gt;&gt;m&gt;&gt;q)&#123; rep(i,0,m)&#123; cin&gt;&gt;li&gt;&gt;ri; v[ri].pb(li); &#125; solve(); rep(i,0,q)&#123; cin&gt;&gt;pi&gt;&gt;qi; cout&lt;&lt;dp[pi][qi]&lt;&lt;endl; &#125; &#125;&#125; 收获与反思 脑子里别老想着暴力，有重复计算又没有修改为什么不考虑记忆化搜索？不考虑DP？思维训练还不够 很明显的时间差异。]]></content>
      <categories>
        <category>编程</category>
        <category>ACM</category>
      </categories>
      <tags>
        <tag>算法</tag>
        <tag>ACM</tag>
        <tag>AtCoder</tag>
        <tag>DP</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[【AtCoder-4245】解题报告（水题）]]></title>
    <url>%2F2018%2F08%2F21%2F%E3%80%90AtCoder-4245%E3%80%91%E8%A7%A3%E9%A2%98%E6%8A%A5%E5%91%8A%EF%BC%88%E6%B0%B4%E9%A2%98%EF%BC%89%2F</url>
    <content type="text"><![CDATA[原始题目A - Garden Time limit : 2sec / Memory limit : 1000MB Score: 100 points Problem StatementThere is a farm whose length and width are A yard and B yard, respectively. A farmer, John, made a vertical road and a horizontal road inside the farm from one border to another, as shown below: (The gray part represents the roads.)What is the area of this yard excluding the roads? Find it. NoteIt can be proved that the positions of the roads do not affect the area. Constraints A is an integer between 2 and 100 (inclusive). B is an integer between 2 and 100 (inclusive). InputInput is given from Standard Input in the following format: A B OutputPrint the area of this yard excluding the roads (in square yards). Sample Input 12 2 Sample Output 11 In this case, the area is 1 square yard. Sample Input 25 7 Sample Output 224 In this case, the area is 24 square yards. 题目大意一个矩形哇横纵两条宽度为1的道路，问剩下的面积 解题思路小学计算题，秒之 解题代码12345678910111213141516171819202122232425262728293031323334353637#include &lt;cstdio&gt;#include &lt;cstring&gt;#include &lt;cmath&gt;#include &lt;string&gt;#include &lt;iostream&gt;#include &lt;iomanip&gt;#include &lt;sstream&gt;#include &lt;set&gt;#include &lt;map&gt;#include &lt;queue&gt;#include &lt;vector&gt;#include &lt;bits/stdc++.h&gt;#define INF 0x3f3f3f3f#define eps 1e-8#define mp make_pair#define np next_permutation#define pb push_back#define all(x) (x.begin(),x.end())#define rep(i,a,n) for(int i=a;i&lt;n;++i)#define per(i,a,n) for(int i=n-1;i&gt;=a;--i)#define ms(x,a) memset((x),a,sizeof(x))#define fi first#define se second using namespace std;const int maxn=1e5+5;const int maxl=26;typedef long long ll;typedef unsigned long long ull;typedef vector&lt;int&gt; vi;typedef pair&lt;int,int&gt; pii; int a,b;int main()&#123; while(cin&gt;&gt;a&gt;&gt;b) cout&lt;&lt;a*b-a-b+1&lt;&lt;endl;&#125; 收获与反思无]]></content>
      <categories>
        <category>编程</category>
        <category>ACM</category>
      </categories>
      <tags>
        <tag>算法</tag>
        <tag>ACM</tag>
        <tag>AtCoder</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[密码技术学习（一）——《图解密码技术》笔记]]></title>
    <url>%2F2018%2F08%2F18%2F%E5%AF%86%E7%A0%81%E6%8A%80%E6%9C%AF%E5%AD%A6%E4%B9%A0%EF%BC%88%E4%B8%80%EF%BC%89%E2%80%94%E2%80%94%E3%80%8A%E5%9B%BE%E8%A7%A3%E5%AF%86%E7%A0%81%E6%8A%80%E6%9C%AF%E3%80%8B%E7%AC%94%E8%AE%B0%2F</url>
    <content type="text"><![CDATA[第3章 对称密码（共享密钥密码）——用相同的密钥进行加密和解密一次性密码本——绝对不会被破译的密码原理： 将明文与一串随机的比特序列进行XOR运算。 完全随机，密钥空间是所有可能的01组合，所以就算破译成功了，我们也无法判断它是正确的明文。比如正确明文是code，但破译会出现从aaaa到zzzz，其中不乏有意义的book，cook等“疑似明文”，由于是完全随机带来的密钥空间有全部可能，我们无法判断真正的明文是什么。 理论上无法破译 不过这样密钥的传送也成了问题，假设我们能够安全的传送密钥，那本身这个方法可以用来安全传递我们的消息了，所以现实中除了特工配送密钥完成元首热线通话以外，一次性密码本没有很高的应用价值。 DESFeistel网络的一轮，右侧直接向下变为输出，右侧与轮密钥XOR生成左侧。 多轮操作，每轮反转左右。 解密就是重复过程（两次XOR抵消从而得到这一轮前的输入）。 三重DES如名，不过是DES加密-&gt;DES解密-&gt;DES加密（由IBM公司提出，用来兼容普通DES，比如三层都是同样的DES密钥，就是普通DES了） 解密过程为DES解密-&gt;DES加密-&gt;DES解密 目前在银行等机构还在使用，但处理速度不高，除了特别重视向下兼容性的情况以外，很少被用于新的用途。 AES取代DES在2000成为新的标准，选定的算法名为Rijndael RijndaelRijndael算法也是由多个轮构成的，其中每一轮分为SubBytes（逐字节替换）、ShiftRows（平移行）、MixColumns（混合列）、AddRoundKey（与轮密钥进行XOR）共四个不中。DES使用Feistel网络作为基本结构，而Rijndael使用SPN结构。 加密：SubBytes -&gt; ShiftRows -&gt; MixColumns -&gt; AddRoundKey 解密：AddRoundKey -&gt; InvMixColumns -&gt; InvShiftRows -&gt; InvSubBytes 破译：由于其过程可以由数学公式来表达，那么理论上可以通过数学运算来求解，意味着Rigndael能够通过数学方法进行破译。不过现在为止还没有出现针对Rigndael的有效攻击。 第4章 分组密码的模式——分组密码是如何迭代的 模式总结表格 模式名称优点缺点备注 ECB模式Electronic CodeBook 电子密码本模式简单快速支持并行计算（加密、解密）明文中的重复排列会反映在密文中通过删除、替换密文分组可以对明文进行操作对包含某些比特错误的密文进行解密时，对应的分组会出错不能抵御重放攻击 不应使用 CBC模式Cipher Block Chaining 密文分组链接模式明文的重复排列不会反映在密文中支持并行计算（仅解密）能够解密任意密文分组对包含某些错误比特的密文进行解密时，第一个分组的全部比特以及后一个分组的相应比特会出错加密不支持并行计算CRYPTREC推荐《实用密码学》推荐 CFB模式Cipher-FeedBack 密文反馈模式不需要填充（padding）支持并行计算（仅解密）能够解密任意密文分组对包含某些错误比特的密文进行解密时，第一个分组的相应比特以及后一个分组的全部比特会出错加密不支持并行计算不能抵御重放攻击CRYPTREC推荐 OFB模式Output-FeedBack 输出反馈模式不需要填充（padding）可事先进行加密、解密的准备加密、解密使用相同结构对包含某些错误比特的密文进行解密时，只有明文中相应的比特会出错不支持并行计算主动攻击者反转密文分组中的某些比特时，明文分组中相对应的比特也会被反转CRYPTREC推荐 CTR模式CounTeR 计数器模式不需要填充（padding）可实现进行加密、解密的准备加密、解密使用相同的结构对包含某些错误比特的密文进行解密时，只有明文中相对应的比特会出错支持并行计算（加密、解密）主动攻击者反转密文分组中的某些比特时，明文分组中相对应的比特也会被反转CRYPTREC推荐《实用密码学》推荐 第5章 公钥密码——用公钥加密，用私钥解密密钥配送问题 通过事先共享密钥来解决（部分场景不现实） 通过密钥分配中心来解决（中心负担大，被破坏代价大风险高） 通过Diffie-Hellman密钥交换来解决（第11章） 通过公钥密码来解决（本章后续） 公钥密码一些特征 发送者只需要加密密钥 接收者只需要解密密钥 解密密钥不可以被窃听者获取 加密密钥被窃听者获取也没问题 无法解决的问题 解决了密钥配送问题，但是无门需要判断所得到的公钥是否正确合法，这个问题被称为公钥认证问题（后面章节）。 速度是对称密的几百分之一，解决方法后面会讲到。 时钟运算补充一些数论知识 除法：在模12的条件下两个数相乘为1，“类倒数”。可以发现规律，和12的最大公约数为1的数（5，7，11），即于12互质的数，存在倒数。 乘方：可以先模再乘，应用同余的性质。 对数：时钟运算中对数成为离散对数。能快速求出离散对数的算法到现在还没有被发现，Diffie-Hellman密钥交换协议以及ElGamal公钥算法中就运用了离散对数。 RSA]]></content>
      <categories>
        <category>编程</category>
        <category>密码技术</category>
      </categories>
      <tags>
        <tag>密码技术</tag>
        <tag>图解密码技术</tag>
        <tag>结城浩</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[《银河帝国8：我，机器人》读书笔记]]></title>
    <url>%2F2018%2F08%2F10%2F%E3%80%8A%E9%93%B6%E6%B2%B3%E5%B8%9D%E5%9B%BD8%EF%BC%9A%E6%88%91%EF%BC%8C%E6%9C%BA%E5%99%A8%E4%BA%BA%E3%80%8B%E8%AF%BB%E4%B9%A6%E7%AC%94%E8%AE%B0%2F</url>
    <content type="text"><![CDATA[内容摘录机器人学三大法则 机器人不得伤害人类，或因不作为而使人类受到伤害。 除非违背第一法则，机器人必须服从人类的命令。 在不违背第一及第二法则的情况下，机器人必须保护自己。 第五篇 骗子！ P115 “‘你们的教科书里什么也没有；你们的科学知识一堆搜集来的数据，靠临时的理论粘在一起——而且全都简单到不可思议，简直真不值得我浪费时间。让我感兴趣的是你们的小说。你们会研究人类的动机以及情感的互动关系……’” P132 “厄比身子抵住了墙壁，双腿跪了下来。‘停止！’他尖叫道，‘关上你的心灵！它充满了痛苦、挫折和恨意！我不是故意的，我不骗你！我试图帮助你们，我把你们想听的话告诉你们。我不得不这样做！’” 第六篇 消失无踪 P143 “‘凯文博士，我们要么就是必须舍弃机器人，要么就是对第一法则做些修改——结果我们选择了后者。’……‘并没有取消它，只是作些修改。’寇纳尔解释道，‘这样制成的正子脑，仅含有第一法则的积极部分，也就是：机器人不得伤害人类，到此为止。不再有强迫性的要求，要他们防止外在因素伤害人类，比方说伽马射线。我这样说正确吧，玻格特博士?’” P152 “机器人心理学家说：‘假如修订型机器人从某人上方抛下一个重物，只要他在这样做的时候，明白自己具有足够的力量和反应速度，能在重物砸到那人之前将它抓走，他就不会违反第一法则。然而一旦重物离手，他就不再是主动的媒介，起作用的只剩下盲目的重力。然后那机器人久能改变心意，只要他不作为，就能让重物砸下去。修订后的第一法则允许这个行动。’” 第七篇 逃避！ P200 “接下来就很明显，那项资料进入它的计算机制后，产生了控制恒星际跃迁最短时段的方程式——这意味着人的死亡。统一公司的机器会完全崩溃，正是由于这个原因。但我已将死亡的严重性贬低——并非整个取消，因为第一法则永远无法违反——刚好足以让金头脑能对这个方程式多看一眼；足以给它时间去了解，这段时期过后，那些人会起死回生——正如太空船中的物质和能量会重新出现。换句话说，这个所谓的‘死亡’绝对只是暂时现象。你们懂了吗？”]]></content>
      <categories>
        <category>阅读</category>
      </categories>
      <tags>
        <tag>阅读</tag>
        <tag>小说</tag>
        <tag>艾萨克·阿西莫夫</tag>
        <tag>银河帝国</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[【HDU-2222】解题报告（AC自动机）]]></title>
    <url>%2F2018%2F08%2F10%2F%E3%80%90HDU-2222%E3%80%91%E8%A7%A3%E9%A2%98%E6%8A%A5%E5%91%8A%EF%BC%88AC%E8%87%AA%E5%8A%A8%E6%9C%BA%EF%BC%89%2F</url>
    <content type="text"></content>
      <categories>
        <category>编程</category>
        <category>ACM</category>
      </categories>
  </entry>
  <entry>
    <title><![CDATA[【CSU-2056】解题报告（思维，KMP，去0）]]></title>
    <url>%2F2018%2F08%2F10%2F%E3%80%90CSU-2056%E3%80%91%E8%A7%A3%E9%A2%98%E6%8A%A5%E5%91%8A%EF%BC%88%E6%80%9D%E7%BB%B4%EF%BC%8CKMP%EF%BC%8C%E5%8E%BB0%EF%BC%89%2F</url>
    <content type="text"><![CDATA[原始题目2056: a simple game Time Limit: 1 Sec Memory Limit: 128 Mb Submitted: 412 Solved: 73 Description这一天，小A和小B在玩一个游戏，他俩每人都有一个整数，然后两人轮流对他们的整数进行操作，每次在下列两个操作任选一个： （1）对整数进行翻转，如1234翻转成4321 ，1200翻转成21 （2）将整数除以10，如1234/10=123，1/10=0 当操作过程中出现a==b时，则小A就赢了，而操作一直进行下去或不能使a==b则算小B赢。 现在小A求助于你，想让你帮他在知道两人的整数时小A能不能赢，假设每次都是小A先手，并且两人都是采取最优策略 Input首先输入$ T (T \le 100)$，表示有T组数据，然后接下来有$T$行，每行有两个整数$a,b ( 0 \le a,b &lt; 10100000)$。 Output有$T$行，当小A赢了则输出”Yes”,否则输出”No” Sample Input4 1234 123 123 321 1234 12345 123 123 Sample OutputYes Yes No Yes HintSourceAuthorwsf 题目大意如题 解题思路 如果将A，B的整数看作字符串，那两种操作就是反转，去尾。 两人都采取最优策略，考虑小A什么时候输，即B可以无限翻转而A永远不能将自己的串通过两种操作达到B字符串的状态。 那么当B的串或B反转后的串是A的子串时，A就是必赢的 考虑一些特殊情况。 由于末尾0的存在会在反转中自动去掉，所以要提前预处理一下，把末尾0去掉 正方各一次KMP即可。 解题代码123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293//#include &lt;bits/stdc++.h&gt;#include &lt;cstdio&gt; #include &lt;cstring&gt;#include &lt;cstdlib&gt;#include &lt;iostream&gt;#include &lt;iomanip&gt;#include &lt;string&gt;#include &lt;map&gt;#include &lt;set&gt;#include &lt;algorithm&gt;#include &lt;queue&gt;#include &lt;vector&gt;#define pb push_back#define mp make_pairusing namespace std;typedef long long LL;typedef pair&lt;int,int&gt; PII;#define PI acos((double)-1)#define E exp(double(1))#define K 1000000+9#define rep(i,a,n) for(int i=a;i&lt;n;i++)#define per(i,a,n) for(int i=n-1;i&gt;=a;i--)#define ms(x,a) memset((x),(a),sizeof(a))const int maxn=1e6+5;int nt[maxn],nt2[maxn] ;char a[maxn],b[maxn],b2[maxn];int n,m;//参数为模板串和next数组//字符串均从下标0开始void kmpGetNext(char *s,int *Next)&#123; Next[0]=0; int len=strlen(s); for(int i=1,j=0;i&lt;len;i++) &#123; while(j&amp;&amp;s[i]!=s[j]) j=Next[j]; if(s[i]==s[j]) j++; Next[i+1]=j; &#125;// Next[len]=0;&#125;int kmp(char *ss,char *s,int *Next)&#123; kmpGetNext(s,Next);// 调试输出Next数组// int len=strlen(s);// for(int i=0;i&lt;=len;i++)// cout&lt;&lt;Next[i]&lt;&lt;" ";// cout&lt;&lt;endl; int ans=0; int len1=strlen(ss); int len2=strlen(s); for(int i=0,j=0;i&lt;len1;i++) &#123; while(j&amp;&amp;ss[i]!=s[j])j=Next[j]; if(ss[i]==s[j]) j++; if(j==len2)&#123; return 1; &#125; &#125; return 0;// return ans;&#125;int main(void)&#123;// ios::sync_with_stdio(false); int t; scanf("%d",&amp;t); while(t--) &#123; memset(nt,0,sizeof(nt)); memset(nt2,0,sizeof(nt2)); scanf("%s",a); scanf("%s",b); int len1=strlen(a); int len2=strlen(b); while (a[len1-1] == '0'&amp;&amp;len1 &gt; 1) a[--len1] = '\0'; while (b[len2-1] == '0'&amp;&amp;len2 &gt; 1) b[--len2] = '\0'; rep(i,0,len2) b2[i]=b[len2-1-i]; b2[len2]='\0'; // printf("b1= %s\nb2= %s\n",b,b2); if(kmp(a,b,nt)||kmp(a,b2,nt2)) printf("Yes\n"); else printf("No\n"); &#125; return 0;&#125; 收获与反思 思维+KMP]]></content>
      <categories>
        <category>编程</category>
        <category>ACM</category>
      </categories>
      <tags>
        <tag>算法</tag>
        <tag>ACM</tag>
        <tag>CSU</tag>
        <tag>2018暑假集训</tag>
        <tag>KMP</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[【HDU-3746】解题报告（KMP，循环节）]]></title>
    <url>%2F2018%2F08%2F10%2F%E3%80%90HDU-3746%E3%80%91%E8%A7%A3%E9%A2%98%E6%8A%A5%E5%91%8A%EF%BC%88KMP%EF%BC%8C%E5%BE%AA%E7%8E%AF%E8%8A%82%EF%BC%89%2F</url>
    <content type="text"><![CDATA[原始题目Cyclic Nacklace Time Limit: 2000/1000 MS (Java/Others) Memory Limit: 32768/32768 K (Java/Others) Total Submission(s): 14437 Accepted Submission(s): 6022 Problem DescriptionCC always becomes very depressed at the end of this month, he has checked his credit card yesterday, without any surprise, there are only 99.9 yuan left. he is too distressed and thinking about how to tide over the last days. Being inspired by the entrepreneurial spirit of “HDU CakeMan”, he wants to sell some little things to make money. Of course, this is not an easy task. As Christmas is around the corner, Boys are busy in choosing christmas presents to send to their girlfriends. It is believed that chain bracelet is a good choice. However, Things are not always so simple, as is known to everyone, girl’s fond of the colorful decoration to make bracelet appears vivid and lively, meanwhile they want to display their mature side as college students. after CC understands the girls demands, he intends to sell the chain bracelet called CharmBracelet. The CharmBracelet is made up with colorful pearls to show girls’ lively, and the most important thing is that it must be connected by a cyclic chain which means the color of pearls are cyclic connected from the left to right. And the cyclic count must be more than one. If you connect the leftmost pearl and the rightmost pearl of such chain, you can make a CharmBracelet. Just like the pictrue below, this CharmBracelet’s cycle is 9 and its cyclic count is 2: Now CC has brought in some ordinary bracelet chains, he wants to buy minimum number of pearls to make CharmBracelets so that he can save more money. but when remaking the bracelet, he can only add color pearls to the left end and right end of the chain, that is to say, adding to the middle is forbidden. CC is satisfied with his ideas and ask you for help. InputThe first line of the input is a single integer $T ( 0 &lt; T \le 100 )$ which means the number of test cases. Each test case contains only one line describe the original ordinary chain to be remade. Each character in the string stands for one pearl and there are 26 kinds of pearls being described by ‘a’ ~’z’ characters. The length of the string $Len$: $( 3 \le Len \le 100000 )$. OutputFor each case, you are required to output the minimum count of pearls added to make a CharmBracelet. Sample Input3 aaa abca abcde Sample Output0 2 5 Authorpossessor WC SourceHDU 3rd “Vegetable-Birds Cup” Programming Open Contest Recommendlcy 题目大意有一个手环，由不同珠子构成，若要让他成为一个“魅力手环”需要使手环由大于等于两个，完全相同的首尾相接的子串构成。问需要补充多少珠子使手环变为魅力手环。 解题思路 求循环节以及判断是否完全循环，求差值 解题代码1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465666768697071727374757677787980818283848586878889//#include &lt;bits/stdc++.h&gt;#include &lt;cstdio&gt; #include &lt;cstring&gt;#include &lt;cstdlib&gt;#include &lt;iostream&gt;#include &lt;iomanip&gt;#include &lt;string&gt;#include &lt;map&gt;#include &lt;set&gt;#include &lt;algorithm&gt;#include &lt;queue&gt;#include &lt;vector&gt;#define pb push_back#define mp make_pairusing namespace std;typedef long long LL;typedef pair&lt;int,int&gt; PII;#define PI acos((double)-1)#define E exp(double(1))#define K 1000000+9#define rep(i,a,n) for(int i=a;i&lt;n;i++)#define per(i,a,n) for(int i=n-1;i&gt;=a;i--)#define ms(x,a) memset((x),(a),sizeof(a))const int maxn=1e6+5; int nt[maxn];char a[maxn],b[maxn];int n;//参数为模板串和next数组//字符串均从下标0开始void kmpGetNext(char *s,int *Next)&#123; Next[0]=0; int len=strlen(s); for(int i=1,j=0;i&lt;len;i++) &#123; while(j&amp;&amp;s[i]!=s[j]) j=Next[j]; if(s[i]==s[j]) j++; Next[i+1]=j; &#125;// Next[len]=0;&#125;int kmp(char *ss,char *s,int *Next)&#123; kmpGetNext(s,Next);// 调试输出Next数组// int len=strlen(s);// for(int i=0;i&lt;=n;i++)// cout&lt;&lt;Next[i]&lt;&lt;" ";// cout&lt;&lt;endl; // int ans=0;// int len1=strlen(ss);// int len2=strlen(s); for(int i=0,j=0;i&lt;2*n;i++) //倍长 &#123; while(j&amp;&amp;ss[i%n]!=s[j])j=Next[j]; if(ss[i%n]==s[j]) j++; if(j==n)&#123; return 1; &#125; &#125; return 0;&#125;int main(void)&#123; int t; scanf("%d",&amp;t); while(t--)&#123; scanf("%s",a); memset(nt,0,sizeof(nt)); n=strlen(a); kmpGetNext(a,nt); int ans; int k = n-nt[n];//循环节大小 if(k == n) //不循环，补充相同一串 ans = n; else if(n % k == 0) //完全循环，不需要补充 ans = 0; else //补充剩下的 ans = k - (n % k); printf("%d\n",ans); // cout&lt;&lt;endl; &#125; &#125; 收获与反思 对于KMP循环节的问题 $n-nt[n]$求得最长循环节的大小（可能是自身） $n%(n-nt[n])$求剩下的尾巴大小（可用来判断是不是完全循环）]]></content>
      <categories>
        <category>编程</category>
        <category>ACM</category>
      </categories>
      <tags>
        <tag>算法</tag>
        <tag>ACM</tag>
        <tag>2018暑假集训</tag>
        <tag>KMP</tag>
        <tag>HDU</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[【HDU-1686】解题报告（KMP）]]></title>
    <url>%2F2018%2F08%2F10%2F%E3%80%90HDU-1686%E3%80%91%E8%A7%A3%E9%A2%98%E6%8A%A5%E5%91%8A%EF%BC%88KMP%EF%BC%89%2F</url>
    <content type="text"><![CDATA[原始题目Oulipo Time Limit: 3000/1000 MS (Java/Others) Memory Limit: 32768/32768 K (Java/Others) Total Submission(s): 21478 Accepted Submission(s): 8336 Problem DescriptionThe French author Georges Perec (1936–1982) once wrote a book, La disparition, without the letter ‘e’. He was a member of the Oulipo group. A quote from the book: Tout avait Pair normal, mais tout s’affirmait faux. Tout avait Fair normal, d’abord, puis surgissait l’inhumain, l’affolant. Il aurait voulu savoir où s’articulait l’association qui l’unissait au roman : stir son tapis, assaillant à tout instant son imagination, l’intuition d’un tabou, la vision d’un mal obscur, d’un quoi vacant, d’un non-dit : la vision, l’avision d’un oubli commandant tout, où s’abolissait la raison : tout avait l’air normal mais… Perec would probably have scored high (or rather, low) in the following contest. People are asked to write a perhaps even meaningful text on some subject with as few occurrences of a given “word” as possible. Our task is to provide the jury with a program that counts these occurrences, in order to obtain a ranking of the competitors. These competitors often write very long texts with nonsense meaning; a sequence of 500,000 consecutive ‘T’s is not unusual. And they never use spaces. So we want to quickly find out how often a word, i.e., a given string, occurs in a text. More formally: given the alphabet {‘A’, ‘B’, ‘C’, …, ‘Z’} and two finite strings over that alphabet, a word W and a text T, count the number of occurrences of W in T. All the consecutive characters of W must exactly match consecutive characters of T. Occurrences may overlap. InputThe first line of the input file contains a single number: the number of test cases to follow. Each test case has the following format: One line with the word W, a string over {‘A’, ‘B’, ‘C’, …, ‘Z’}, with 1 ≤ |W| ≤ 10,000 (here |W| denotes the length of the string W). One line with the text T, a string over {‘A’, ‘B’, ‘C’, …, ‘Z’}, with |W| ≤ |T| ≤ 1,000,000. OutputFor every test case in the input file, the output should contain a single number, on a single line: the number of occurrences of the word W in the text T. Sample Input3 BAPC BAPC AZA AZAZAZA VERDI AVERDXIVYERDIAN Sample Output1 3 0 Source华东区大学生程序设计邀请赛_热身赛 Recommendlcy 题目大意 计算T中W的出现次数，W的所有连续字符必须与T的连续字符完全匹配，可能重叠。 解题思路 裸KMP 解题代码123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081//#include &lt;bits/stdc++.h&gt;#include &lt;cstdio&gt; #include &lt;cstring&gt;#include &lt;cstdlib&gt;#include &lt;iostream&gt;#include &lt;iomanip&gt;#include &lt;string&gt;#include &lt;map&gt;#include &lt;set&gt;#include &lt;algorithm&gt;#include &lt;queue&gt;#include &lt;vector&gt;#define pb push_back#define mp make_pairusing namespace std;typedef long long LL;typedef pair&lt;int,int&gt; PII;#define PI acos((double)-1)#define E exp(double(1))#define K 1000000+9#define rep(i,a,n) for(int i=a;i&lt;n;i++)#define per(i,a,n) for(int i=n-1;i&gt;=a;i--)#define ms(x,a) memset((x),(a),sizeof(a))int nt[10006];char a[K],b[10005];int n,m;//参数为模板串和next数组//字符串均从下标0开始void kmpGetNext(char *s,int *Next)&#123; Next[0]=0; int len=strlen(s); for(int i=1,j=0;i&lt;len;i++) &#123; while(j&amp;&amp;s[i]!=s[j]) j=Next[j]; if(s[i]==s[j]) j++; Next[i+1]=j; &#125;// Next[len]=0;&#125;int kmp(char *ss,char *s,int *Next)&#123; kmpGetNext(s,Next);// 调试输出Next数组// int len=strlen(s);// for(int i=0;i&lt;=len;i++)// cout&lt;&lt;Next[i]&lt;&lt;" ";// cout&lt;&lt;endl; int ans=0; int len1=strlen(ss); int len2=strlen(s); for(int i=0,j=0;i&lt;len1;i++) &#123; while(j&amp;&amp;ss[i]!=s[j])j=Next[j]; if(ss[i]==s[j]) j++; if(j==len2)&#123; ans++;// return i-len2+2; &#125; &#125;// return -1; return ans;&#125;int main(void)&#123; int t; scanf("%d",&amp;t); while(t--) &#123; memset(a,0,sizeof(a)); memset(b,0,sizeof(b)); scanf("%s",b); scanf("%s",a); cout&lt;&lt; kmp(a,b,nt)&lt;&lt;endl; &#125; return 0;&#125; 收获与反思 KMP水题]]></content>
      <categories>
        <category>编程</category>
        <category>ACM</category>
      </categories>
      <tags>
        <tag>算法</tag>
        <tag>ACM</tag>
        <tag>2018暑假集训</tag>
        <tag>KMP</tag>
        <tag>HDU</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[【HDU-1358】解题报告（KMP，循环节）]]></title>
    <url>%2F2018%2F08%2F10%2F%E3%80%90HDU-1358%E3%80%91%E8%A7%A3%E9%A2%98%E6%8A%A5%E5%91%8A%EF%BC%88KMP%EF%BC%8C%E5%BE%AA%E7%8E%AF%E8%8A%82%EF%BC%89%2F</url>
    <content type="text"></content>
      <categories>
        <category>编程</category>
        <category>ACM</category>
      </categories>
  </entry>
  <entry>
    <title><![CDATA[【HDU-2087】解题报告（KMP，去重）]]></title>
    <url>%2F2018%2F08%2F10%2F%E3%80%90HDU-2087%E3%80%91%E8%A7%A3%E9%A2%98%E6%8A%A5%E5%91%8A%EF%BC%88KMP%EF%BC%8C%E5%8E%BB%E9%87%8D%EF%BC%89%2F</url>
    <content type="text"><![CDATA[原始题目剪花布条 Time Limit: 1000/1000 MS (Java/Others) Memory Limit: 32768/32768 K (Java/Others) Total Submission(s): 28902 Accepted Submission(s): 17700 Problem Description一块花布条，里面有些图案，另有一块直接可用的小饰条，里面也有一些图案。对于给定的花布条和小饰条，计算一下能从花布条中尽可能剪出几块小饰条来呢？ Input输入中含有一些数据，分别是成对出现的花布条和小饰条，其布条都是用可见ASCII字符表示的，可见的ASCII字符有多少个，布条的花纹也有多少种花样。花纹条和小饰条不会超过1000个字符长。如果遇见#字符，则不再进行工作。 Output输出能从花纹布中剪出的最多小饰条个数，如果一块都没有，那就老老实实输出0，每个结果之间应换行。 Sample Inputabcde a3 aaaaaa aa # Sample Output0 3 Authorqianneng Source冬练三九之二 Recommendlcy 题目大意如题 解题思路 模板加一句$Next[len]=0$，去重即可。 解题代码12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364656667686970717273747576777879808182//#include &lt;bits/stdc++.h&gt;#include &lt;cstdio&gt; #include &lt;cstring&gt;#include &lt;cstdlib&gt;#include &lt;iostream&gt;#include &lt;iomanip&gt;#include &lt;string&gt;#include &lt;map&gt;#include &lt;set&gt;#include &lt;algorithm&gt;#include &lt;queue&gt;#include &lt;vector&gt;#define pb push_back#define mp make_pairusing namespace std;typedef long long LL;typedef pair&lt;int,int&gt; PII;#define PI acos((double)-1)#define E exp(double(1))#define K 1000000+9#define rep(i,a,n) for(int i=a;i&lt;n;i++)#define per(i,a,n) for(int i=n-1;i&gt;=a;i--)#define ms(x,a) memset((x),(a),sizeof(a))int nt[10006];char a[K],b[10005];int n,m;//参数为模板串和next数组//字符串均从下标0开始void kmpGetNext(char *s,int *Next)&#123; Next[0]=0; int len=strlen(s); for(int i=1,j=0;i&lt;len;i++) &#123; while(j&amp;&amp;s[i]!=s[j]) j=Next[j]; if(s[i]==s[j]) j++; Next[i+1]=j; &#125;// Next[len]=0;&#125;int kmp(char *ss,char *s,int *Next)&#123; kmpGetNext(s,Next);// 调试输出Next数组// int len=strlen(s);// for(int i=0;i&lt;=len;i++)// cout&lt;&lt;Next[i]&lt;&lt;" ";// cout&lt;&lt;endl; int ans=0; int len1=strlen(ss); int len2=strlen(s); for(int i=0,j=0;i&lt;len1;i++) &#123; while(j&amp;&amp;ss[i]!=s[j])j=Next[j]; if(ss[i]==s[j]) j++; if(j==len2)&#123; ans++;// return i-len2+2; &#125; &#125;// return -1; return ans;&#125;int main(void)&#123;// ios::sync_with_stdio(false); int t; scanf("%d",&amp;t); while(t--) &#123; memset(a,0,sizeof(a)); memset(b,0,sizeof(b)); scanf("%s",a); scanf("%s",b); cout&lt;&lt; kmp(a,b,nt)&lt;&lt;endl; &#125; return 0;&#125; 收获与反思 KMP水题]]></content>
      <categories>
        <category>编程</category>
        <category>ACM</category>
      </categories>
      <tags>
        <tag>算法</tag>
        <tag>ACM</tag>
        <tag>2018暑假集训</tag>
        <tag>KMP</tag>
        <tag>HDU</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[【CSU-1598】解题报告（KMP）]]></title>
    <url>%2F2018%2F08%2F10%2F%E3%80%90CSU-1598%E3%80%91%E8%A7%A3%E9%A2%98%E6%8A%A5%E5%91%8A%EF%BC%88KMP%EF%BC%89%2F</url>
    <content type="text"><![CDATA[原始题目1598: 最长公共前缀 Time Limit: 1 Sec Memory Limit: 128 Mb Submitted: 222 Solved: 186 Description给定两个字符串$s$和$t$，现有一个扫描器，从$s$的最左边开始向右扫描，每次扫描到一个$t$就把这一段删除，输出能发现$t$的个数。 Input第一行包含一个整数$ T ( T \le 50)$ ，表示数据组数。每组数据第一行包含一个字符串$s$，第二行一个字符串$t$，字符串长度不超过$1000000$。 Output对于每组数据，输出答案。 Sample Input2 ababab ab ababab ba Sample Output 3 2 HintSource国防科学技术大学第十八届银河之光文化节ACM程序设计竞赛初赛 题目大意如题 解题思路 加一个$Next[m]=0$即匹配完成后删除这一段（去重） 不过这个题目水，不加也过了 解题代码12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364656667686970717273747576777879808182//#include &lt;bits/stdc++.h&gt;#include &lt;cstdio&gt; #include &lt;cstring&gt;#include &lt;cstdlib&gt;#include &lt;iostream&gt;#include &lt;iomanip&gt;#include &lt;string&gt;#include &lt;map&gt;#include &lt;set&gt;#include &lt;algorithm&gt;#include &lt;queue&gt;#include &lt;vector&gt;#define pb push_back#define mp make_pairusing namespace std;typedef long long LL;typedef pair&lt;int,int&gt; PII;#define PI acos((double)-1)#define E exp(double(1))#define K 1000000+9#define rep(i,a,n) for(int i=a;i&lt;n;i++)#define per(i,a,n) for(int i=n-1;i&gt;=a;i--)#define ms(x,a) memset((x),(a),sizeof(a))int nt[10006];char a[K],b[10005];int n,m;//参数为模板串和next数组//字符串均从下标0开始void kmpGetNext(char *s,int *Next)&#123; Next[0]=0; int len=strlen(s); for(int i=1,j=0;i&lt;len;i++) &#123; while(j&amp;&amp;s[i]!=s[j]) j=Next[j]; if(s[i]==s[j]) j++; Next[i+1]=j; &#125; Next[len]=0;&#125;int kmp(char *ss,char *s,int *Next)&#123; kmpGetNext(s,Next);// 调试输出Next数组// int len=strlen(s);// for(int i=0;i&lt;=len;i++)// cout&lt;&lt;Next[i]&lt;&lt;" ";// cout&lt;&lt;endl; int ans=0; int len1=strlen(ss); int len2=strlen(s); for(int i=0,j=0;i&lt;len1;i++) &#123; while(j&amp;&amp;ss[i]!=s[j])j=Next[j]; if(ss[i]==s[j]) j++; if(j==len2)&#123; ans++;// return i-len2+2; &#125; &#125;// return -1; return ans;&#125;int main(void)&#123;// ios::sync_with_stdio(false); int t; scanf("%d",&amp;t); while(t--) &#123; memset(a,0,sizeof(a)); memset(b,0,sizeof(b)); scanf("%s",a); scanf("%s",b); cout&lt;&lt; kmp(a,b,nt)&lt;&lt;endl; &#125; return 0;&#125; 收获与反思 KMP水题]]></content>
      <categories>
        <category>编程</category>
        <category>ACM</category>
      </categories>
      <tags>
        <tag>算法</tag>
        <tag>ACM</tag>
        <tag>CSU</tag>
        <tag>2018暑假集训</tag>
        <tag>KMP</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[【CSU-1581】解题报告（思维，KMP）]]></title>
    <url>%2F2018%2F08%2F10%2F%E3%80%90CSU-1581%E3%80%91%E8%A7%A3%E9%A2%98%E6%8A%A5%E5%91%8A%EF%BC%88%E6%80%9D%E7%BB%B4%EF%BC%8CKMP%EF%BC%89%2F</url>
    <content type="text"><![CDATA[原始题目Problem H: Clock Pictures1581: Clock Pictures Time Limit: 3 Sec Memory Limit: 128 Mb Submitted: 322 Solved: 82 DescriptionYou have two pictures of an unusual kind of clock. The clock has n hands, each having the same length and no kind of marking whatsoever. Also, the numbers on the clock are so faded that you can’t even tell anymore what direction is up in the picture. So the only thing that you see on the pictures, are n shades of the n hands, and nothing else. You’d like to know if both images might have been taken at exactly the same time of the day, possibly with the camera rotated at different angles. Given the description of the two images, determine whether it is possible that these two pictures could be showing the same clock displaying the same time. InputThe ﬁrst line contains a single integer $n$ $(2 ≤ n ≤ 200 000)$, the number of hands on the clock. Each of the next two lines contains n integers $a_i$ $(0 ≤ a_i &lt; 360 000)$,representing the angles of the hands of the clock on one of the images,in thousandths of a degree. The ﬁrst line represents the position of the hands on the ﬁrst image, whereas the second line corresponds to the second image. The number $a_i$ denotes the angle between the recorded position of some hand and the upward direction in the image, measured clockwise. Angles of the same clock are distinct and are not given in any speciﬁc order. OutputOutput one line containing one word: possible if the clocks could be showing the same time,impossible otherwise. Sample Input6 1 2 3 4 5 6 7 6 5 4 3 1 Sample Outputimpossible HINT题目大意 一个有$n$个指针的表盘，看不清数字，以随机顺序给出n个指针相对记录位置（不固定）的顺时针旋转角度，问两个表盘经过旋转是否能够重合（是否表示一个表盘）。 解题思路 对于相同表盘，记录位置不固定，但是两个指针间的角度差固定，判断位移后可不可以相同。 注意第一个指针和末尾指针的角度差需要补3600000 将一组倍长做KMP可以解决这个问题，若位移后可以相同，那么倍长后2倍距离必包含另一串。 解题代码12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364656667686970717273747576777879808182838485868788899091929394//#include &lt;bits/stdc++.h&gt;#include &lt;cstdio&gt; #include &lt;cstring&gt;#include &lt;cstdlib&gt;#include &lt;iostream&gt;#include &lt;iomanip&gt;#include &lt;string&gt;#include &lt;map&gt;#include &lt;set&gt;#include &lt;algorithm&gt;#include &lt;queue&gt;#include &lt;vector&gt;#define pb push_back#define mp make_pairusing namespace std;typedef long long LL;typedef pair&lt;int,int&gt; PII;#define PI acos((double)-1)#define E exp(double(1))#define K 1000000+9#define rep(i,a,n) for(int i=a;i&lt;n;i++)#define per(i,a,n) for(int i=n-1;i&gt;=a;i--)#define ms(x,a) memset((x),(a),sizeof(a))const int maxn=2e5+5; int nt[maxn];int aa[maxn],bb[maxn];int a[maxn],b[maxn];int n;//参数为模板串和next数组//字符串均从下标0开始void kmpGetNext(int *s,int *Next)&#123; Next[0]=0;// int len=strlen(s); for(int i=1,j=0;i&lt;n;i++) &#123; while(j&amp;&amp;s[i]!=s[j]) j=Next[j]; if(s[i]==s[j]) j++; Next[i+1]=j; &#125;// Next[len]=0;&#125;int kmp(int *ss,int *s,int *Next)&#123; kmpGetNext(s,Next);// 调试输出Next数组// int len=strlen(s);// for(int i=0;i&lt;=n;i++)// cout&lt;&lt;Next[i]&lt;&lt;" ";// cout&lt;&lt;endl; // int ans=0;// int len1=strlen(ss);// int len2=strlen(s); for(int i=0,j=0;i&lt;2*n;i++) //倍长 &#123; while(j&amp;&amp;ss[i%n]!=s[j])j=Next[j]; if(ss[i%n]==s[j]) j++; if(j==n)&#123; return 1; &#125; &#125; return 0;&#125;int main(void)&#123; ios::sync_with_stdio(false); while(cin&gt;&gt;n) &#123; memset(a,0,sizeof(a)); memset(b,0,sizeof(b)); rep(i,0,n) cin&gt;&gt;aa[i]; rep(i,0,n) cin&gt;&gt;bb[i]; sort(aa,aa+n); sort(bb,bb+n); rep(i,0,n-1)&#123; a[i]=aa[i+1]-aa[i]; b[i]=bb[i+1]-bb[i]; &#125; a[n-1]=360000+aa[0]-aa[n-1];// rep(i,0,n) cout&lt;&lt;a[i]&lt;&lt;" ";// cout&lt;&lt;endl; b[n-1]=360000+bb[0]-bb[n-1];// rep(i,0,n) cout&lt;&lt;b[i]&lt;&lt;" ";// cout&lt;&lt;endl; if(kmp(a,b,nt)) cout&lt;&lt;"possible"&lt;&lt;endl; else cout&lt;&lt;"impossible"&lt;&lt;endl; &#125; return 0;&#125; 收获与反思 仔细读题，分析题目 倍长KMP可以判断自身位移的情况。]]></content>
      <categories>
        <category>编程</category>
        <category>ACM</category>
      </categories>
      <tags>
        <tag>算法</tag>
        <tag>ACM</tag>
        <tag>CSU</tag>
        <tag>2018暑假集训</tag>
        <tag>KMP</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[【HDU-6373】解题报告（物理力学，模拟，2018杭电多校第六场）]]></title>
    <url>%2F2018%2F08%2F10%2F%E3%80%90HDU-6373%E3%80%91%E8%A7%A3%E9%A2%98%E6%8A%A5%E5%91%8A%EF%BC%88%E7%89%A9%E7%90%86%E5%8A%9B%E5%AD%A6%EF%BC%8C%E6%A8%A1%E6%8B%9F%EF%BC%8C2018%E6%9D%AD%E7%94%B5%E5%A4%9A%E6%A0%A1%E7%AC%AC%E5%85%AD%E5%9C%BA%EF%BC%89%2F</url>
    <content type="text"><![CDATA[原始题目Pinball Time Limit: 2000/1000 MS (Java/Others) Memory Limit: 262144/262144 K (Java/Others) Total Submission(s): 604 Accepted Submission(s): 264 Problem DescriptionThere is a slope on the 2D plane. The lowest point of the slope is at the origin. There is a small ball falling down above the slope. Your task is to find how many times the ball has been bounced on the slope. It’s guarantee that the ball will not reach the slope or ground or Y-axis with a distance of less than 1 from the origin. And the ball is elastic collision without energy loss. Gravity acceleration $g=9.8m/s^2$. InputThere are multiple test cases. The first line of input contains an integer T (1 ≤ T ≤ 100), indicating the number of test cases. The first line of each test case contains four integers a, b, x, y (1 ≤ a, b, -x, y ≤ 100), indicate that the slope will pass through the point(-a, b), the initial position of the ball is (x, y). OutputOutput the answer. It’s guarantee that the answer will not exceed 50. Sample Input1 5 1 -5 3 Sample Output2 Source2018 Multi-University Training Contest 6 Recommendchendu 题目大意 给定一个从原点向一个方向延长的斜板，以及初始小球的坐标，重力加速度。求能在斜板上弹跳几次（不考虑能量损失） 解题思路 物理题，把运动分解成沿板方向和垂直于板的方向的分运动，求出沿板子运动的时间$t1$，垂直于板子运动的（每一次上升/下降）的时间$t2$。 考虑一下，当$(2n+1)t2 \lebs t1 &lt; (2(n+1)+1)t2 $ 时，n即为答案 解题代码12345678910111213141516171819202122232425262728293031323334353637383940#include &lt;bits/stdc++.h&gt;#include &lt;cstdio&gt;#include &lt;cmath&gt;#include &lt;cstdlib&gt;#include &lt;cstring&gt;#include &lt;iostream&gt;#include &lt;set&gt;#include &lt;iomanip&gt;#include &lt;algorithm&gt;#include &lt;queue&gt;#include &lt;map&gt;#include &lt;string&gt;#define INF 0x3f3f3f3f#define rep(i,a,n) for(int i=a;i&lt;n;i++)#define per(i,a,n) for(int i=n-1;i&gt;=a;i--)#define ms(x,a) memset((x),(a),sizeof(a))using namespace std;const int maxn=1e5+5;int n,m,t;double a,b,x,y;void solve()&#123; double alfa=atan(b/a); double y1=(y-x*tan(alfa))*cos(alfa); double x1=y*sin(alfa)+x*cos(alfa);// cout&lt;&lt;y1&lt;&lt;" "&lt;&lt;x1&lt;&lt;endl; int n=floor(sqrt(x1/y1*a/b)); cout&lt;&lt;(n+1)/2&lt;&lt;endl;&#125;int main()&#123; ios::sync_with_stdio(false); cin&gt;&gt;t; while(t--)&#123; cin&gt;&gt;a&gt;&gt;b&gt;&gt;x&gt;&gt;y; x=-x; solve(); &#125;&#125; 收获与反思 分运动看时间比判断，队友想出来的= =。]]></content>
      <categories>
        <category>编程</category>
        <category>ACM</category>
      </categories>
      <tags>
        <tag>算法</tag>
        <tag>ACM</tag>
        <tag>2018暑假集训</tag>
        <tag>HDU</tag>
        <tag>2018杭电多校</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[【HDU-6362】解题报告（数学，积分，2018杭电多校第六场）]]></title>
    <url>%2F2018%2F08%2F10%2F%E3%80%90HDU-6362%E3%80%91%E8%A7%A3%E9%A2%98%E6%8A%A5%E5%91%8A%EF%BC%88%E6%95%B0%E5%AD%A6%EF%BC%8C%E7%A7%AF%E5%88%86%EF%BC%8C2018%E6%9D%AD%E7%94%B5%E5%A4%9A%E6%A0%A1%E7%AC%AC%E5%85%AD%E5%9C%BA%EF%BC%89%2F</url>
    <content type="text"><![CDATA[原始题目oval-and-rectangle Time Limit: 2000/1000 MS (Java/Others) Memory Limit: 32768/32768 K (Java/Others) Total Submission(s): 647 Accepted Submission(s): 310 Problem DescriptionPatrick Star find an oval. The half of longer axes is on the x-axis with length $a$. The half of shorter axes is on the y-axis with length $b$. Patrick Star plan to choose a real number c randomly from $[0,b]$, after that, Patrick Star will get a rectangle : The four vertexes of it are on the outline of the oval. The two sides of it parallel to coordinate axis. One of its side is $y=c$. Patrick Star want to know the expectations of the rectangle’s perimeter. InputThe first line contain a integer $T$ (no morn than 10), the following is $T$ test case, for each test case : Each line contains contains two integer $a, b (0&lt;b&lt;a&lt;105)$. Separated by an white space. OutputFor each test case output one line denotes the expectations of the rectangle’s perimeter . You should keep exactly 6 decimal digits and ignore the remain decimal digits. It is guaranted that the 7-th decimal digit of answer wont be 0 or 9. Sample Input1 2 1 Sample Output8.283185 Source2018 Multi-University Training Contest 6 Recommendchendu 题目大意 椭圆半长轴为$a$，半短轴为$b$，从区间$[0,b]$随机抽实数$c$，求过$(0,c)$点的与椭圆内切，四边与坐标轴平行的长方形周长 解题思路 是个积分题，不过直接用积分函数计算到制定精度会T（没错我就这么T了一发） 手动算一下 最后除以b得到答案 注意要求不四舍五入，精度应该输出$ans-0.0000005$ 解题代码12345678910111213141516171819202122232425262728293031#include &lt;bits/stdc++.h&gt;#include &lt;cstdio&gt;#include &lt;cmath&gt;#include &lt;cstdlib&gt;#include &lt;cstring&gt;#include &lt;iostream&gt;#include &lt;set&gt;#include &lt;iomanip&gt;#include &lt;algorithm&gt;#include &lt;queue&gt;#include &lt;map&gt;#include &lt;string&gt;#define INF 0x3f3f3f3f#define rep(i,a,n) for(int i=a;i&lt;n;i++)#define per(i,a,n) for(int i=n-1;i&gt;=a;i--)#define ms(x,a) memset((x),(a),sizeof(a))using namespace std;const int maxn=1e5+5;#define PI acos(-1.0)int n,m,t;int a,b;int main()&#123; ios::sync_with_stdio(false); cin&gt;&gt;t; while(t--)&#123; cin&gt;&gt;a&gt;&gt;b; double ans=a*PI+2*b; cout&lt;&lt;fixed&lt;&lt;setprecision(6)&lt;&lt;ans-0.0000005&lt;&lt;endl; &#125;&#125; 收获与反思 高数教做人系列]]></content>
      <categories>
        <category>编程</category>
        <category>ACM</category>
      </categories>
      <tags>
        <tag>算法</tag>
        <tag>ACM</tag>
        <tag>2018暑假集训</tag>
        <tag>HDU</tag>
        <tag>2018杭电多校</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[【UVALive-3942】解题报告（字典树，dp）]]></title>
    <url>%2F2018%2F08%2F10%2F%E3%80%90UVALive-3942%E3%80%91%E8%A7%A3%E9%A2%98%E6%8A%A5%E5%91%8A%EF%BC%88%E5%AD%97%E5%85%B8%E6%A0%91%EF%BC%8Cdfs%EF%BC%89%2F</url>
    <content type="text"><![CDATA[原始题目 题目大意 给定一个文本串和n个字符串，用这n个字符串组合成文本串有多少种可能。 解题思路 先将n个字符串储存到字典树里。 考虑DP $dp[i]$表示前i位字符进行第一次分割的可能数目 i从len-1-&gt;0逆序遍历，j从i到len-1遍历。 只要遍历j时遇到染色结点，表明可以在此再分割一次，由此推出状态转移方程。$dp[i] = (dp[i] + dp[j + 1]) % mod$ 解题代码123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145#include &lt;cstdio&gt;#include &lt;cstring&gt;#include &lt;iostream&gt;#include &lt;cstdlib&gt;#include &lt;set&gt;#include &lt;string&gt;#include &lt;cstring&gt;#include &lt;stack&gt;#define rep(i,a,n) for(int i=a;i&lt;n;i++)#define per(i,a,n) for(int i=n-1;i&gt;=a;i--)#define ms(x,a) memset((x),(a),sizeof(x))using namespace std;const int maxn=3e5+5;const int maxl=26;const int mod=20071027;typedef long long ll;typedef struct Trie&#123; int v; Trie* next[maxl];&#125;Trie; Trie *root;void iniTrie()&#123; root=(Trie*)malloc(sizeof(Trie)); for(int i=0;i&lt;maxl;i++) root-&gt;next[i]=NULL; root-&gt;v=-1;&#125;void creTrie(char* a)&#123; int l=strlen(a); Trie *p=root,*q; for(int i=0;i&lt;l;i++) &#123; int id=a[i]-'a'; //并非前缀不能有相同，而是不能在相同的分支上。 if(p-&gt;next[id]!=NULL) &#123; p=p-&gt;next[id]; if(i==l-1)&#123; p-&gt;v=1; return; &#125; &#125; else&#123; q=(Trie*)malloc(sizeof(Trie)); q-&gt;v=0; for(int j=0;j&lt;maxl;j++) q-&gt;next[j]=NULL; p-&gt;next[id]=q; p=p-&gt;next[id]; if(i==l-1)&#123; p-&gt;v=1; return; &#125; &#125; &#125;&#125;bool findTrie(string b)&#123; Trie *p=root; int l=b.length(); for(int i=0;i&lt;l;i++)&#123; int index=b[i]-'a'; if(p-&gt;next[index]!=NULL) p=p-&gt;next[index]; else return false; &#125; return p-&gt;v;&#125;void delTrie(Trie *p) &#123; int i; for(i=0;i&lt;maxl;i++) &#123; if(p-&gt;next[i] != NULL) delTrie(p-&gt;next[i]); &#125; free(p);// printf("1"); p==NULL; return ;&#125; int n,kase;int dp[maxn];char raw[maxn],s[1000];int Dp(char *s, int len) &#123; dp[len] = 1; for (int i = len - 1; i &gt;= 0; --i) &#123; Trie *pp = root;//根节点 for (int j = i; j &lt; len; ++j) &#123; int temp = s[j]-'a'; //cout &lt;&lt; s[j] &lt;&lt; endl; if (pp-&gt;next[temp] == NULL) &#123;//同dfs退出原理 break; &#125; pp = pp-&gt;next[temp]; if (pp-&gt;v == true) &#123; dp[i] = (dp[i] + dp[j + 1]) % mod;//更新方案数 //cout &lt;&lt; j + 1 &lt;&lt; " " &lt;&lt; len &lt;&lt; endl; &#125; &#125; dp[i] %= mod; &#125; return dp[0]; &#125;void solve()&#123; int ans=0; int len=strlen(raw); ms(dp,0); ans=Dp(raw,len); cout &lt;&lt; "Case " &lt;&lt; ++kase &lt;&lt; ": "; cout&lt;&lt;ans&lt;&lt;endl; &#125;int main()&#123;// freopen("in.txt", "r", stdin); ios::sync_with_stdio(false); while(cin&gt;&gt;raw)&#123; iniTrie(); cin&gt;&gt;n; rep(i,0,n)&#123; cin&gt;&gt;s; creTrie(s); &#125; solve(); delTrie(root); &#125;&#125; 收获与反思 字典树与dp结合 记忆化，dp的思想很重要！]]></content>
      <categories>
        <category>编程</category>
        <category>ACM</category>
      </categories>
      <tags>
        <tag>算法</tag>
        <tag>ACM</tag>
        <tag>DP</tag>
        <tag>2018暑假集训</tag>
        <tag>字典树</tag>
        <tag>UVALive</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[【CSU-1216】解题报告（01字典树，异或最大值）]]></title>
    <url>%2F2018%2F08%2F09%2F%E3%80%90CSU-1216%E3%80%91%E8%A7%A3%E9%A2%98%E6%8A%A5%E5%91%8A%EF%BC%8801%E5%AD%97%E5%85%B8%E6%A0%91%EF%BC%8C%E5%BC%82%E6%88%96%E6%9C%80%E5%A4%A7%E5%80%BC%EF%BC%89%2F</url>
    <content type="text"><![CDATA[原始题目1216: 异或最大值 Time Limit: 2 Sec Memory Limit: 128 Mb Submitted: 1282 Solved: 460 Description给定一些数，求这些数中两个数的异或值最大的那个值 Input多组数据。第一行为数字个数$n (1 \le n \le 10 ^ 5)$。接下来$n$行每行一个32位有符号非负整数。 Output任意两数最大异或值 Sample Input3 3 7 9 Sample Output14 HintSourceCSGrandeur的数据结构习题 题目大意如题 解题思路 和HDU-4825都是求异或最大值，裸的01字典树 正解： 每个数用二进制数表示，用32位的0、1数组（高位在前）储存到01字典树中。 对于每次询问q，将q也表示成01串，从高位到低位每次贪心的顺着字典树向下找相反的结点（0找1，1找0），因为这样可以保证让两个数的异或值尽可能地大（所以一定要从高位向下找）。 解题代码123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129#include &lt;cstdio&gt;#include &lt;cstring&gt;#include &lt;iostream&gt;#include &lt;cstdlib&gt;#include &lt;set&gt;#include &lt;string&gt;#include &lt;cstring&gt;#include &lt;stack&gt;#define rep(i,a,n) for(int i=a;i&lt;n;i++)#define per(i,a,n) for(int i=n-1;i&gt;=a;i--)#define ms(x,a) memset((x),(a),sizeof(a))#define L 32using namespace std;const int maxn=1e5+5;const int maxl=2;typedef long long ll;typedef struct Trie&#123; int v; Trie* next[maxl];&#125;Trie; Trie *root;void iniTrie()&#123; root=(Trie*)malloc(sizeof(Trie)); for(int i=0;i&lt;maxl;i++) root-&gt;next[i]=NULL; root-&gt;v=-1;&#125;void creTrie(int a)&#123; int temp[35]; int id=L-1; while(a)&#123; temp[id--]=(a&amp;1); a/=2; &#125; rep(i,0,id+1) temp[i]=0;// rep(i,0,L) cout&lt;&lt;temp[i];// cout&lt;&lt;endl&lt;&lt;endl; int l=L; Trie *p=root,*q; for(int i=0;i&lt;l;i++) &#123; int id=temp[i]; //并非前缀不能有相同，而是不能在相同的分支上。 if(p-&gt;next[id]!=NULL) &#123; p=p-&gt;next[id];// p-&gt;v++; &#125; else&#123; q=(Trie*)malloc(sizeof(Trie)); q-&gt;v=1; for(int j=0;j&lt;maxl;j++) q-&gt;next[j]=NULL; p-&gt;next[id]=q; p=p-&gt;next[id]; &#125; &#125;&#125;int findTrie(int a)&#123; int aa=a; int temp[35]; int id=L-1; while(a)&#123; temp[id--]=(a&amp;1); a/=2; &#125;// cout&lt;&lt;"#"&lt;&lt;a&lt;&lt;endl; rep(i,0,id+1) temp[i]=0; int aans=0; Trie *p=root; int l=L; for(int i=0;i&lt;l;i++)&#123; int index=!temp[i];// cout&lt;&lt;"index="&lt;&lt;index&lt;&lt;endl; if(p-&gt;next[index]!=NULL)&#123; aans=(aans&lt;&lt;1)+index; p=p-&gt;next[index]; &#125; else&#123; aans=(aans&lt;&lt;1)+temp[i]; p=p-&gt;next[temp[i]]; &#125; &#125; return aans^aa;&#125;void delTrie(Trie *p) &#123; int i; for(i=0;i&lt;maxl;i++) &#123; if(p-&gt;next[i] != NULL) delTrie(p-&gt;next[i]); &#125; free(p);// printf("1"); p==NULL; return ;&#125; int a[maxn],n;int main()&#123; ios::sync_with_stdio(false); while(cin&gt;&gt;n)&#123; iniTrie(); rep(i,0,n)&#123; cin&gt;&gt;a[i]; creTrie(a[i]); &#125; int fans=0; rep(i,0,n)&#123; fans=max(fans,findTrie(a[i])); &#125; cout&lt;&lt;fans&lt;&lt;endl; delTrie(root); &#125; &#125; 收获与反思 异或最大值可以考虑01字典树。]]></content>
      <categories>
        <category>编程</category>
        <category>ACM</category>
      </categories>
      <tags>
        <tag>算法</tag>
        <tag>ACM</tag>
        <tag>CSU</tag>
        <tag>2018暑假集训</tag>
        <tag>字典树</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[【HDU-4825】解题报告（01字典树，异或最大值）]]></title>
    <url>%2F2018%2F08%2F09%2F%E3%80%90HDU-4825%E3%80%91%E8%A7%A3%E9%A2%98%E6%8A%A5%E5%91%8A%EF%BC%8801%E5%AD%97%E5%85%B8%E6%A0%91%EF%BC%8C%E5%BC%82%E6%88%96%E6%9C%80%E5%A4%A7%E5%80%BC%EF%BC%89%2F</url>
    <content type="text"><![CDATA[原始题目Xor Sum Time Limit: 2000/1000 MS (Java/Others) Memory Limit: 132768/132768 K (Java/Others) Total Submission(s): 4756 Accepted Submission(s): 2076 Problem DescriptionZeus 和 Prometheus 做了一个游戏，Prometheus 给 Zeus 一个集合，集合中包含了$N$个正整数，随后 Prometheus 将向 Zeus 发起$M$次询问，每次询问中包含一个正整数 $S$ ，之后 Zeus 需要在集合当中找出一个正整数 $K$ ，使得 $K$ 与 $S$ 的异或结果最大。Prometheus 为了让 Zeus 看到人类的伟大，随即同意 Zeus 可以向人类求助。你能证明人类的智慧么？ Input输入包含若干组测试数据，每组测试数据包含若干行。 输入的第一行是一个整数$ T(T &lt; 10)$，表示共有$T$组数据。 每组数据的第一行输入两个正整数$N,M( 1 &lt;\le N,M \le 100000)$，接下来一行，包含$N$个正整数，代表 Zeus 的获得的集合，之后$M$行，每行一个正整数$S$，代表 Prometheus 询问的正整数。所有正整数均不超过$2^{32}$。 Output对于每组数据，首先需要输出单独一行”Case #?:”，其中问号处应填入当前的数据组数，组数从1开始计算。 对于每个询问，输出一个正整数K，使得K与S异或值最大。 Sample Input2 3 2 3 4 5 1 5 4 1 4 6 5 6 3 Sample OutputCase #1: 4 3 Case #2: 4 Source2014年百度之星程序设计大赛 - 资格赛 Recommendliuyiding 题目大意如题 解题思路 直接找的话复杂度O（m*n），会T（本题显然不可能这么简单啊） 正解： 每个数用二进制数表示，用32位的0、1数组（高位在前）储存到01字典树中。 对于每次询问q，将q也表示成01串，从高位到低位每次贪心的顺着字典树向下找相反的结点（0找1，1找0），因为这样可以保证让两个数的异或值尽可能地大（所以一定要从高位向下找）。 解题代码123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135#include &lt;cstdio&gt;#include &lt;cstring&gt;#include &lt;iostream&gt;#include &lt;cstdlib&gt;#include &lt;set&gt;#include &lt;string&gt;#include &lt;cstring&gt;#include &lt;stack&gt;#define rep(i,a,n) for(int i=a;i&lt;n;i++)#define per(i,a,n) for(int i=n-1;i&gt;=a;i--)#define ms(x,a) memset((x),(a),sizeof(a))#define debugin freopen("in.txt","r",stdin)#define debugout freopen("out.txt","w",stdout)#define L 32using namespace std;const int maxn=1e5+5;const int maxl=2;typedef long long ll;typedef struct Trie&#123; int v; Trie* next[maxl];&#125;Trie; Trie *root;void iniTrie()&#123; root=(Trie*)malloc(sizeof(Trie)); for(int i=0;i&lt;maxl;i++) root-&gt;next[i]=NULL; root-&gt;v=-1;&#125;void creTrie(int a)&#123; int temp[35]; int id=L-1; while(a)&#123; temp[id--]=(a&amp;1); a/=2; &#125; rep(i,0,id+1) temp[i]=0;// rep(i,0,L) cout&lt;&lt;temp[i];// cout&lt;&lt;endl&lt;&lt;endl; int l=L; Trie *p=root,*q; for(int i=0;i&lt;l;i++) &#123; int id=temp[i]; //并非前缀不能有相同，而是不能在相同的分支上。 if(p-&gt;next[id]!=NULL) &#123; p=p-&gt;next[id];// p-&gt;v++; &#125; else&#123; q=(Trie*)malloc(sizeof(Trie)); q-&gt;v=1; for(int j=0;j&lt;maxl;j++) q-&gt;next[j]=NULL; p-&gt;next[id]=q; p=p-&gt;next[id]; &#125; &#125;&#125;int findTrie(int a)&#123;// int aa=a; int temp[35]; int id=L-1; while(a)&#123; temp[id--]=(a&amp;1); a/=2; &#125;// cout&lt;&lt;"#"&lt;&lt;a&lt;&lt;endl; rep(i,0,id+1) temp[i]=0; int aans=0; Trie *p=root; int l=L; for(int i=0;i&lt;l;i++)&#123; int index=!temp[i];// cout&lt;&lt;"index="&lt;&lt;index&lt;&lt;endl; if(p-&gt;next[index]!=NULL)&#123; aans=(aans&lt;&lt;1)+index; p=p-&gt;next[index]; &#125; else&#123; aans=(aans&lt;&lt;1)+temp[i]; p=p-&gt;next[temp[i]]; &#125; &#125; return aans; &#125;void delTrie(Trie *p) &#123; int i; for(i=0;i&lt;maxl;i++) &#123; if(p-&gt;next[i] != NULL) delTrie(p-&gt;next[i]); &#125; free(p);// printf("1"); p==NULL; return ;&#125; int a[maxn],n,t,m;int main()&#123; ios::sync_with_stdio(false);// debugin;// debugout; cin&gt;&gt;t; rep(l,1,t+1)&#123; cout&lt;&lt;"Case #"&lt;&lt;l&lt;&lt;":"&lt;&lt;endl; cin&gt;&gt;n&gt;&gt;m; //n树m询问 iniTrie(); rep(i,0,n)&#123; cin&gt;&gt;a[i]; creTrie(a[i]); &#125; rep(i,0,m)&#123; cin&gt;&gt;a[i]; cout&lt;&lt;findTrie(a[i])&lt;&lt;endl; &#125; delTrie(root); &#125; &#125; 收获与反思 异或最大值可以考虑01字典树。]]></content>
      <categories>
        <category>编程</category>
        <category>ACM</category>
      </categories>
      <tags>
        <tag>算法</tag>
        <tag>ACM</tag>
        <tag>2018暑假集训</tag>
        <tag>字典树</tag>
        <tag>HDU</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[【HDU-1251】解题报告（字典树）]]></title>
    <url>%2F2018%2F08%2F09%2F%E3%80%90HDU-1251%E3%80%91%E8%A7%A3%E9%A2%98%E6%8A%A5%E5%91%8A%EF%BC%88%E5%AD%97%E5%85%B8%E6%A0%91%EF%BC%89%2F</url>
    <content type="text"><![CDATA[原始题目统计难题 Time Limit: 4000/2000 MS (Java/Others) Memory Limit: 131070/65535 K (Java/Others) Total Submission(s): 55180 Accepted Submission(s): 19275 Problem DescriptionIgnatius最近遇到一个难题,老师交给他很多单词(只有小写字母组成,不会有重复的单词出现),现在老师要他统计出以某个字符串为前缀的单词数量(单词本身也是自己的前缀). Input输入数据的第一部分是一张单词表,每行一个单词,单词的长度不超过10,它们代表的是老师交给Ignatius统计的单词,一个空行代表单词表的结束.第二部分是一连串的提问,每行一个提问,每个提问都是一个字符串. 注意:本题只有一组测试数据,处理到文件结束. Output对于每个提问,给出以该字符串为前缀的单词的数量. Sample Inputbanana band bee absolute acm ba b band abc Sample Output2 3 1 0 AuthorIgnatius.L RecommendIgnatius.L 题目大意如题 解题思路 字典树裸题，建立字典树时每个单词每个结点权值++ 访问的时候不在树上输出0，在的话输出结尾结点的权值。 解题代码123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107#include &lt;cstdio&gt;#include &lt;cstring&gt;#include &lt;iostream&gt;#include &lt;cstdlib&gt;#include &lt;set&gt;#include &lt;string&gt;#include &lt;cstring&gt;#include &lt;stack&gt;using namespace std;const int maxn=1e5+5;const int maxl=26;typedef long long ll;typedef struct Trie&#123; int v; Trie* next[maxl];&#125;Trie; Trie *root;void iniTrie()&#123; root=(Trie*)malloc(sizeof(Trie)); for(int i=0;i&lt;maxl;i++) root-&gt;next[i]=NULL; root-&gt;v=-1;&#125;void creTrie(char* a)&#123; int l=strlen(a); Trie *p=root,*q; for(int i=0;i&lt;l;i++) &#123; int id=a[i]-'a'; //并非前缀不能有相同，而是不能在相同的分支上。 if(p-&gt;next[id]!=NULL) &#123; p=p-&gt;next[id]; p-&gt;v++; &#125; else&#123; q=(Trie*)malloc(sizeof(Trie)); q-&gt;v=1; for(int j=0;j&lt;maxl;j++) q-&gt;next[j]=NULL; p-&gt;next[id]=q; p=p-&gt;next[id]; &#125; &#125;&#125;//void printTrie()//&#123;// Trie* p=root;// stack&lt;Trie*&gt;s;// s.push(p);// while(!s.empty())// &#123;// Trie *now=s.top();// s.pop();// if(now-&gt;v==1) printf("%d\n",now-&gt;v);// for(int i=0;i&lt;maxl;i++)// if(now-&gt;next[i]!=NULL)// s.push(now-&gt;next[i]); // &#125;//&#125;int printTrie(char* b)&#123; Trie *p=root; int l=strlen(b); for(int i=0;i&lt;l;i++)&#123; int index=b[i]-'a'; if(p-&gt;next[index]!=NULL) p=p-&gt;next[index]; else&#123; return 0; &#125; &#125; return p-&gt;v;&#125;void delTrie(Trie *p) &#123; int i; for(i=0;i&lt;maxl;i++) &#123; if(p-&gt;next[i] != NULL) delTrie(p-&gt;next[i]); &#125; free(p);// printf("1"); p==NULL; return ;&#125; int t,ccount;int main()&#123; char a[20],c; iniTrie(); while(gets(a)&amp;&amp;a[0]!='\0') creTrie(a); while(~scanf("%s",a)) printf("%d\n",printTrie(a)); delTrie(root);&#125; 收获与反思 字典树裸题，注意建立的时候怎么打标记（染色）。]]></content>
      <categories>
        <category>编程</category>
        <category>ACM</category>
      </categories>
      <tags>
        <tag>算法</tag>
        <tag>ACM</tag>
        <tag>2018暑假集训</tag>
        <tag>字典树</tag>
        <tag>HDU</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[【POJ-1200】解题报告（字符串hash，进制）]]></title>
    <url>%2F2018%2F08%2F09%2F%E3%80%90POJ-1200%E3%80%91%E8%A7%A3%E9%A2%98%E6%8A%A5%E5%91%8A%EF%BC%88%E5%AD%97%E7%AC%A6%E4%B8%B2hash%EF%BC%8C%E8%BF%9B%E5%88%B6%EF%BC%89%2F</url>
    <content type="text"><![CDATA[原始题目Crazy Search Time Limit: 1000MS Memory Limit: 65536K Total Submissions: 32268 Accepted: 8900 DescriptionMany people like to solve hard puzzles some of which may lead them to madness. One such puzzle could be finding a hidden prime number in a given text. Such number could be the number of different substrings of a given size that exist in the text. As you soon will discover, you really need the help of a computer and a good algorithm to solve such a puzzle. Your task is to write a program that given the size, N, of the substring, the number of different characters that may occur in the text, NC, and the text itself, determines the number of different substrings of size N that appear in the text. As an example, consider N=3, NC=4 and the text “daababac”. The different substrings of size 3 that can be found in this text are: “daa”; “aab”; “aba”; “bab”; “bac”. Therefore, the answer should be 5. InputThe first line of input consists of two numbers, N and NC, separated by exactly one space. This is followed by the text where the search takes place. You may assume that the maximum number of substrings formed by the possible set of characters does not exceed 16 Millions. OutputThe program should output just an integer corresponding to the number of different substrings of size N found in the given text. Sample Input3 4 daababac Sample Output5 HintHuge input,scanf is recommended. SourceSouthwestern Europe 2002 题目大意 最多由nc种字符构成的原字符串，求长度为n的子串共有多少种。解题思路 字符串hash 由于最多不超过nc种字符，把每种字符映射到1到nc，字串即可看作类似nc进制的数（不含0） 用set或者vis数组维护一下记录不同数的个数即可。解题代码1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556//#include &lt;bits/stdc++.h&gt;#include &lt;cstdio&gt;#include &lt;cmath&gt;#include &lt;cstdlib&gt;#include &lt;cstring&gt;#include &lt;iostream&gt;#include &lt;set&gt;#include &lt;iomanip&gt;#include &lt;algorithm&gt;#include &lt;queue&gt;#include &lt;map&gt;#include &lt;string&gt;#define INF 0x3f3f3f3f#define rep(i,a,n) for(int i=a;i&lt;n;i++)#define per(i,a,n) for(int i=n-1;i&gt;=a;i--)#define ms(x,a) memset((x),(a),sizeof(a))using namespace std;const int maxn=1e5+5;#define PI acos(-1.0)typedef long long ll;typedef unsigned long long ull;int letter[300];char s[1000005];bool myhash[20000005];int n,nc;int main()&#123; ios::sync_with_stdio(false); while(cin&gt;&gt;n&gt;&gt;nc&gt;&gt;s)&#123; memset(letter,0,sizeof(letter)); memset(myhash,0,sizeof(myhash)); int len=strlen(s); int cnt=0; rep(i,0,len)&#123; if(!letter[s[i]]) &#123; letter[s[i]]=++cnt; if(cnt==nc) break; &#125; &#125; int ans=0; rep(i,0,len-n+1)&#123; int sum=0; for(int j=i;j&lt;i+n;j++)&#123; sum=sum*nc+letter[s[j]]; &#125; if(!myhash[sum])&#123;// cout&lt;&lt;"i="&lt;&lt;i&lt;&lt;endl; ans++; myhash[sum]=1; &#125; else continue; &#125; cout&lt;&lt;ans&lt;&lt;endl; &#125;&#125; 收获与反思 简单字符串hash，没有涉及取模操作]]></content>
      <categories>
        <category>编程</category>
        <category>ACM</category>
      </categories>
      <tags>
        <tag>算法</tag>
        <tag>ACM</tag>
        <tag>2018暑假集训</tag>
        <tag>字符串hash</tag>
        <tag>POJ</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[【HDU-1711】解题报告（KMP模板题，字符串hash）]]></title>
    <url>%2F2018%2F08%2F09%2F%E3%80%90HDU-1711%E3%80%91%E8%A7%A3%E9%A2%98%E6%8A%A5%E5%91%8A%EF%BC%88KMP%E6%A8%A1%E6%9D%BF%E9%A2%98%EF%BC%8C%E5%AD%97%E7%AC%A6%E4%B8%B2hash%EF%BC%89%2F</url>
    <content type="text"><![CDATA[原始题目Number Sequence Time Limit: 10000/5000 MS (Java/Others) Memory Limit: 32768/32768 K (Java/Others) Total Submission(s): 39142 Accepted Submission(s): 16165 Problem DescriptionGiven two sequences of numbers : a[1], a[2], …… , a[N], and b[1], b[2], …… , b[M] (1 ≤ M ≤ 10000, 1 ≤ N ≤ 1000000). Your task is to find a number K which make a[K] = b[1], a[K + 1] = b[2], …… , a[K + M - 1] = b[M]. If there are more than one K exist, output the smallest one. InputThe first line of input is a number T which indicate the number of cases. Each case contains three lines. The first line is two numbers N and M (1 ≤ M ≤ 10000, 1 ≤ N ≤ 1000000). The second line contains N integers which indicate a[1], a[2], …… , a[N]. The third line contains M integers which indicate b[1], b[2], …… , b[M]. All integers are in the range of [-1000000, 1000000]. OutputFor each test case, you should output one line which only contain K described above. If no such K exists, output -1 instead. Sample Input2 13 5 1 2 1 2 3 1 2 3 1 3 2 1 2 1 2 3 1 3 13 5 1 2 1 2 3 1 2 3 1 3 2 1 2 1 2 3 2 1 Sample Output6 -1 SourceHDU 2007-Spring Programming Contest Recommendlcy 题目大意 给定一个数字串和一个模式串，输出最早匹配的位置，没有输出-1。 解题思路 KMP把字符匹配改成int即可。 解题代码123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869//#include &lt;bits/stdc++.h&gt;#include &lt;cstdio&gt; #include &lt;cstring&gt;#include &lt;cstdlib&gt;#include &lt;iostream&gt;#include &lt;iomanip&gt;#include &lt;string&gt;#include &lt;map&gt;#include &lt;set&gt;#include &lt;algorithm&gt;#include &lt;queue&gt;#include &lt;vector&gt;#define pb push_back#define mp make_pairusing namespace std;typedef long long LL;typedef pair&lt;int,int&gt; PII;#define PI acos((double)-1)#define E exp(double(1))#define K 1000000+9#define rep(i,a,n) for(int i=a;i&lt;n;i++)#define per(i,a,n) for(int i=n-1;i&gt;=a;i--)#define ms(x,a) memset((x),(a),sizeof(a))int nt[10006];int a[K],b[10005],n,m;//参数为模板串和next数组//字符串均从下标0开始void kmp_next(int *T,int *nt)&#123; nt[0]=0; for(int i=1,j=0;i&lt;m;i++) &#123; while(j&amp;&amp;T[i]!=T[j])j=nt[j-1]; if(T[i]==T[j])j++; nt[i]=j; &#125;&#125;int kmp(int *S,int *T,int *nt)&#123; kmp_next(T,nt); int ans=0; //n //m for(int i=0,j=0;i&lt;n;i++) &#123; while(j&amp;&amp;S[i]!=T[j])j=nt[j-1]; if(S[i]==T[j])j++; if(j==m)&#123;// ans++; return i-m+2; &#125; &#125; return -1;&#125;int main(void)&#123; ios::sync_with_stdio(false); int t;cin&gt;&gt;t; while(t--) &#123; cin&gt;&gt;n&gt;&gt;m; rep(i,0,n) cin&gt;&gt;a[i]; rep(i,0,m) cin&gt;&gt;b[i]; cout&lt;&lt; kmp(a,b,nt)&lt;&lt;endl; &#125; return 0;&#125;//1 2 1 2 3 1 2 3 1 3 2 1 2 3 1 2 3 收获与反思 单模匹配考虑KMP，熟悉模板和算法。]]></content>
      <categories>
        <category>编程</category>
        <category>ACM</category>
      </categories>
      <tags>
        <tag>算法</tag>
        <tag>ACM</tag>
        <tag>2018暑假集训</tag>
        <tag>KMP</tag>
        <tag>HDU</tag>
        <tag>字符串hash</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[【HDU-1224】解题报告（最长路，路径）]]></title>
    <url>%2F2018%2F08%2F08%2F%E3%80%90HDU-1224%E3%80%91%E8%A7%A3%E9%A2%98%E6%8A%A5%E5%91%8A%EF%BC%88%E6%9C%80%E9%95%BF%E8%B7%AF%EF%BC%8C%E8%B7%AF%E5%BE%84%EF%BC%89%2F</url>
    <content type="text"><![CDATA[原始题目Free DIY Tour Time Limit: 2000/1000 MS (Java/Others) Memory Limit: 65536/32768 K (Java/Others) Total Submission(s): 8700 Accepted Submission(s): 2805 Problem DescriptionWeiwei is a software engineer of ShiningSoft. He has just excellently fulfilled a software project with his fellow workers. His boss is so satisfied with their job that he decide to provide them a free tour around the world. It’s a good chance to relax themselves. To most of them, it’s the first time to go abroad so they decide to make a collective tour. The tour company shows them a new kind of tour circuit - DIY circuit. Each circuit contains some cities which can be selected by tourists themselves. According to the company’s statistic, each city has its own interesting point. For instance, Paris has its interesting point of 90, New York has its interesting point of 70, ect. Not any two cities in the world have straight flight so the tour company provide a map to tell its tourists whether they can got a straight flight between any two cities on the map. In order to fly back, the company has made it impossible to make a circle-flight on the half way, using the cities on the map. That is, they marked each city on the map with one number, a city with higher number has no straight flight to a city with lower number. Note: Weiwei always starts from Hangzhou(in this problem, we assume Hangzhou is always the first city and also the last city, so we mark Hangzhou both 1 and N+1), and its interesting point is always 0. Now as the leader of the team, Weiwei wants to make a tour as interesting as possible. If you were Weiwei, how did you DIY it? InputThe input will contain several cases. The first line is an integer T which suggests the number of cases. Then T cases follows. Each case will begin with an integer N(2 ≤ N ≤ 100) which is the number of cities on the map. Then N integers follows, representing the interesting point list of the cities. And then it is an integer M followed by M pairs of integers [Ai, Bi] (1 ≤ i ≤ M). Each pair of [Ai, Bi] indicates that a straight flight is available from City Ai to City Bi. OutputFor each case, your task is to output the maximal summation of interesting points Weiwei and his fellow workers can get through optimal DIYing and the optimal circuit. The format is as the sample. You may assume that there is only one optimal circuit. Output a blank line between two cases. Sample Input2 3 0 70 90 4 1 2 1 3 2 4 3 4 3 0 90 70 4 1 2 1 3 2 4 3 4 Sample OutputCASE 1# points : 90 circuit : 1-&gt;3-&gt;1 CASE 2# points : 90 circuit : 1-&gt;2-&gt;1 AuthorJGShining（极光炫影） Source杭州电子科技大学第三届程序设计大赛 RecommendIgnatius.L 题目大意 自定义旅途路线，1和n+1结点权值为0，剩下结点权值给定，有向图，求最长路。 解题思路 改了一下Dijkstra最短路算法竟然A了。 解题代码123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108#include &lt;cstdio&gt;#include &lt;cstring&gt;#include &lt;string&gt;#include &lt;algorithm&gt;#include &lt;iostream&gt;#include &lt;stack&gt;#include &lt;set&gt;#include &lt;vector&gt;#include &lt;queue&gt;#include &lt;cmath&gt;#include &lt;cstdlib&gt;#include &lt;bits/stdc++.h&gt; using namespace std;#define eps 1e-8#define INF 0x3f3f3f3f#define rep(i,a,n) for(int i=a;i&lt;n;i++)#define per(i,a,n) for(int i=n-1;i&gt;=a;i--)#define all(x) x.begin(),x.end()#define pb push_back#define np next_permutation#define ms(x,a) memset((x),(a),sizeof(x))//优先队列迪杰斯特拉 const int maxn=1e5+5;struct Edge&#123; int u,v,w; Edge(int _u,int _v,int _w):u(_u),v(_v),w(_w)&#123; &#125;;&#125;;vector &lt;Edge&gt; edges[maxn];int dis[maxn],path[maxn],num[maxn],ans[maxn];bool vis[maxn];int n,m,uu,vv,ww,t;void init()&#123; //n个结点的边集都清空 rep(i,0,maxn)&#123; edges[i].clear(); &#125; ms(vis,0); ms(dis,-INF); ms(path,0); ms(num,0);&#125;void addEdge(int u,int v,int w)&#123; edges[u].pb(Edge(u,v,w));&#125;struct Node&#123; int Id,W; Node(int _Id,int _W):Id(_Id),W(_W)&#123; &#125;; bool operator &lt; (const Node &amp;b) const &#123;W&lt;b.W;&#125;&#125;;void Dijkstra(int s)&#123; priority_queue &lt;Node&gt; q; q.push(Node(s,0)) ,dis[s]=0; while(!q.empty())&#123; Node now=q.top(); q.pop(); int index=now.Id; if(dis[index]!=now.W) continue; rep(i,0,edges[index].size())&#123;// cout&lt;&lt;"dis="&lt;&lt;dis[edges[index][i].v]&lt;&lt;" new cost="&lt;&lt;dis[index]+edges[index][i].w; if(dis[edges[index][i].v]&lt;dis[index]+edges[index][i].w)&#123; dis[edges[index][i].v]=dis[index]+edges[index][i].w; q.push(Node(edges[index][i].v,dis[edges[index][i].v])); path[edges[index][i].v]=index;// cout&lt;&lt;" #"&lt;&lt; edges[index][i].v&lt;&lt;" #"&lt;&lt;index&lt;&lt;endl; &#125; &#125; &#125;&#125;int main()&#123;// freopen("in.txt","r",stdin); ios::sync_with_stdio(false); cin&gt;&gt;t; rep(T,1,t+1)&#123; if(T!=1) cout&lt;&lt;endl; cin&gt;&gt;n; init(); rep(i,1,n+1)&#123; cin&gt;&gt;num[i]; //输入点权值 &#125; cin&gt;&gt;m; rep(i,1,m+1)&#123; cin&gt;&gt;uu&gt;&gt;vv; addEdge(uu,vv,num[uu]); &#125; Dijkstra(1); //预处理路径 int cnt=0,ini=n+1; while(1)&#123; ans[cnt++]=ini; ini=path[ini]; if(ini==1) break; &#125; ans[cnt]=1; //输出 cout&lt;&lt;"CASE "&lt;&lt;T&lt;&lt;"#"&lt;&lt;endl&lt;&lt;"points : "&lt;&lt;dis[n+1]&lt;&lt;endl; cout&lt;&lt;"circuit : "; for(int i=cnt;i&gt;0;i--) cout&lt;&lt;ans[i]&lt;&lt;"-&gt;"; cout&lt;&lt;1&lt;&lt;endl; &#125; &#125; 收获与反思 需要研究一下Dij可否算最长路]]></content>
      <categories>
        <category>编程</category>
        <category>ACM</category>
      </categories>
      <tags>
        <tag>算法</tag>
        <tag>ACM</tag>
        <tag>Dijkstra</tag>
        <tag>HDU</tag>
        <tag>最长路</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[【HDU-2544】解题报告（最短路，dij）]]></title>
    <url>%2F2018%2F08%2F08%2F%E3%80%90HDU-2544%E3%80%91%E8%A7%A3%E9%A2%98%E6%8A%A5%E5%91%8A%EF%BC%88%E6%9C%80%E7%9F%AD%E8%B7%AF%EF%BC%8Cdij%EF%BC%89%2F</url>
    <content type="text"><![CDATA[原始题目最短路 Time Limit: 5000/1000 MS (Java/Others) Memory Limit: 32768/32768 K (Java/Others) Total Submission(s): 88011 Accepted Submission(s): 38096 Problem Description在每年的校赛里，所有进入决赛的同学都会获得一件很漂亮的t-shirt。但是每当我们的工作人员把上百件的衣服从商店运回到赛场的时候，却是非常累的！所以现在他们想要寻找最短的从商店到赛场的路线，你可以帮助他们吗？ Input输入包括多组数据。每组数据第一行是两个整数N、M（N≤100，M≤10000），N表示成都的大街上有几个路口，标号为1的路口是商店所在地，标号为N的路口是赛场所在地，M则表示在成都有几条路。N=M=0表示输入结束。接下来M行，每行包括3个整数A，B，C（1≤A,B≤N,1≤C≤1000）,表示在路口A与路口B之间有一条路，我们的工作人员需要C分钟的时间走过这条路。输入保证至少存在1条商店到赛场的路线。 Output对于每组输入，输出一行，表示工作人员从商店走到赛场的最短时间 Sample Input2 1 1 2 3 3 3 1 2 5 2 3 5 3 1 2 0 0 Sample Output3 2 SourceUESTC 6th Programming Contest Online Recommendlcy 题目大意如题 解题思路 单源正权，Dijkstra最短路模板题 解题代码123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384#include &lt;cstdio&gt;#include &lt;cstring&gt;#include &lt;string&gt;#include &lt;algorithm&gt;#include &lt;iostream&gt;#include &lt;stack&gt;#include &lt;set&gt;#include &lt;vector&gt;#include &lt;queue&gt;#include &lt;cmath&gt;#include &lt;cstdlib&gt;#include &lt;bits/stdc++.h&gt; using namespace std;#define eps 1e-8#define INF 0x3f3f3f3f#define rep(i,a,n) for(int i=a;i&lt;n;i++)#define per(i,a,n) for(int i=n-1;i&gt;=a;i--)#define all(x) x.begin(),x.end()#define pb push_back#define np next_permutation#define ms(x,a) memset((x),(a),sizeof(x))//优先队列迪杰斯特拉 const int maxn=1e5+5;struct Edge&#123; int u,v,w; Edge(int _u,int _v,int _w):u(_u),v(_v),w(_w)&#123; &#125;;&#125;;vector &lt;Edge&gt; edges[maxn];int dis[maxn];bool vis[maxn];int n,m,uu,vv,ww;void init(int n)&#123; //n个结点的边集都清空 rep(i,0,maxn)&#123; edges[i].clear(); &#125;&#125;void addEdge(int u,int v,int w)&#123; edges[u].pb(Edge(u,v,w));&#125;struct Node&#123; int Id,W; Node(int _Id,int _W):Id(_Id),W(_W)&#123; &#125;; bool operator &lt; (const Node &amp;b) const &#123;W&gt;b.W;&#125;&#125;;void Dijkstra(int s)&#123; ms(vis,0); ms(dis,INF); priority_queue &lt;Node&gt; q; q.push(Node(s,0)) ,dis[s]=0; while(!q.empty())&#123; Node now=q.top(); q.pop(); int index=now.Id; if(dis[index]!=now.W) continue; rep(i,0,edges[index].size())&#123; if(dis[edges[index][i].v]&gt;dis[index]+edges[index][i].w)&#123; dis[edges[index][i].v]=dis[index]+edges[index][i].w; q.push(Node(edges[index][i].v,dis[edges[index][i].v])); &#125; &#125; &#125;&#125;int main()&#123; ios::sync_with_stdio(false); while(cin&gt;&gt;n&gt;&gt;m&amp;&amp;n+m)&#123; init(n); rep(i,1,m+1)&#123; cin&gt;&gt;uu&gt;&gt;vv&gt;&gt;ww; addEdge(uu,vv,ww); addEdge(vv,uu,ww); &#125; Dijkstra(1); cout&lt;&lt;dis[n]&lt;&lt;endl; &#125; &#125; 收获与反思 理解熟悉模板]]></content>
      <categories>
        <category>编程</category>
        <category>ACM</category>
      </categories>
      <tags>
        <tag>算法</tag>
        <tag>ACM</tag>
        <tag>2018暑假集训</tag>
        <tag>Dijkstra</tag>
        <tag>最短路</tag>
        <tag>HDU</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[《刺杀骑士团长》读书笔记]]></title>
    <url>%2F2018%2F08%2F06%2F%E3%80%8A%E5%88%BA%E6%9D%80%E9%AA%91%E5%A3%AB%E5%9B%A2%E9%95%BF%E3%80%8B%E8%AF%BB%E4%B9%A6%E7%AC%94%E8%AE%B0%2F</url>
    <content type="text"><![CDATA[内容摘录第1部 显形理念篇 P95 “免色这个人物身上，总好像有悄然潜伏的什么。那个秘密已经放进带锁的小盒，深深埋入地下。很早以前埋的，如今上面长满绵柔茂密的绿草。而知晓埋那个小盒的场所的，这个世界上唯独免色一人。我不能不在其微笑的深处感觉出拥有那一类型的秘密带来的孤独。” P193 “就是有这一种类的梦。支离破碎犬牙交错的梦。每一块碎片诚然有其量感，但因相互纠缠而抵消了一尽。” P204 “我的感情在永无休止的沉默中犹如以刀具做成的沉重的摆子一样从一个极端画着大大的弧线摆向另一个极端。” P226 “就是说，在我们的人生中，现实与非现实的界线往往很难捕捉。那条界线看上去总是经常来来去去，就像每天兴之所至地随便移动的国境线——必须好好留意其动向才行。否则，就不知道自己现在是在哪一边了。我刚才说再在洞中停留下去可能危险，就是这个意思。” P293 “晚饭时间！人们大概同家人一起面对餐桌，即将把热乎乎的饭菜放入口中。我可以从那些灯光中感受到那种微笑的温煦。” P300 “‘一个人被关在又黑又窄的地方，最可怕的不是死，而是 开始考虑自己可能要永远在这里活下去，那比什么都可怕。那么一想，就吓得透不过气，就好像周围墙壁挤压过来直接把自己压瘪挤死——便是有那样汹涌的错觉。而在那里活下去，人就必须想方设法跨越那种恐惧，即克服自己。为此就需要无限接近死亡。’‘可那伴随着危险。’‘和接近太阳的伊卡洛斯一样。至于接近的极限在哪里，分辨那条生死攸关的线并非易事。那将成为玩命作业。’‘而若回避那种接近，就不能跨越恐惧克服自己。00p’” P333 “历史之中，就那样搁置在黑暗中为好的事件多的要命。正确知识未必使人丰富。客观未必凌驾于主观之上。事实未必吹灭妄想。”]]></content>
      <categories>
        <category>阅读</category>
      </categories>
      <tags>
        <tag>阅读</tag>
        <tag>小说</tag>
        <tag>村上春树</tag>
        <tag>刺杀骑士团长</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[【CSU-1980】解题报告（区间dp，树的中序遍历）]]></title>
    <url>%2F2018%2F08%2F04%2F%E3%80%90CSU-1980%E3%80%91%E8%A7%A3%E9%A2%98%E6%8A%A5%E5%91%8A%EF%BC%88%E5%8C%BA%E9%97%B4dp%EF%BC%8C%E6%A0%91%E7%9A%84%E4%B8%AD%E5%BA%8F%E9%81%8D%E5%8E%86%EF%BC%89%2F</url>
    <content type="text"><![CDATA[原始题目1980: 不堪重负的树 Time Limit: 1 Sec Memory Limit: 128 Mb Submitted: 188 Solved: 83 Description小X非常喜欢树，然后他生成了一个大森林给自己玩。 玩着玩着，小X陷入了沉思。 一棵树由N个节点组成，编号为i的节点有一个价值Wi。 假设从树根出发前往第i个节点（可能是树根自己），一共需要经过Di个节点（包括起点和终点），那么这个节点对这棵树产生的负担就是Di与Wi的乘积。 对于一棵树而言，这棵树的负担值为所有节点对它产生的负担之和。 小X学习了dfs，如果他知道树的结构，他当然可以很容易地算出树的负担值。可是现在沉思中的小X并不知道树的结构形态，他只知道一棵二叉树的中序遍历以及每个节点的价值，那么这棵二叉树可能的最小负担值是多少呢？ Input第一行为一个正整数T(T≤20)表示数据组数。 每组数据包括三行。 第一行为一个正整数N(N≤200)。 第二行为N个正整数Wi(Wi≤108)，表示编号为i的节点的价值。 第三行为N个正整数Pi(Pi≤N)，为一个1~N的排列，表示二叉树的中序遍历结果。 Output对于每组数据，输出一行一个正整数，表示这棵树可能的最小负担值。 Sample Input2 4 1 2 3 4 1 2 3 4 7 1 1 1 1 1 1 1 4 2 3 5 7 1 6 Sample Output18 17 Hint对于第一个样例，树根为3，3的左儿子是2，3的右儿子是4，2的左儿子是1，这样构成的树可以达到最小负担。 对于第二个样例，对应的满二叉树可以达到最小负担。 Source2017年8月月赛 Authordevember 题目大意如题 解题思路 先求得中序遍历各节点的权值 预处理前缀和，以及dp数组（初始$dp[i][i]=f[i]$） 对于一棵树可以由左子树、右子树的最优解转移过来，区间dp 状态转移方程dp[i][j]=min(dp[i][k-1]+dp[k+1][j])+\sum_{m=i}^{j} f[i] (i]]></content>
      <categories>
        <category>编程</category>
        <category>ACM</category>
      </categories>
      <tags>
        <tag>算法</tag>
        <tag>ACM</tag>
        <tag>CSU</tag>
        <tag>2018暑假集训</tag>
        <tag>区间DP</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[【POJ-1651】解题报告（区间DP入门）]]></title>
    <url>%2F2018%2F08%2F04%2F%E3%80%90POJ-1651%E3%80%91%E8%A7%A3%E9%A2%98%E6%8A%A5%E5%91%8A%EF%BC%88%E5%8C%BA%E9%97%B4DP%E5%85%A5%E9%97%A8%EF%BC%89%2F</url>
    <content type="text"><![CDATA[原始题目Multiplication Puzzle Time Limit: 1000MS Memory Limit: 65536K Total Submissions: 13111 Accepted: 8035 DescriptionThe multiplication puzzle is played with a row of cards, each containing a single positive integer. During the move player takes one card out of the row and scores the number of points equal to the product of the number on the card taken and the numbers on the cards on the left and on the right of it. It is not allowed to take out the first and the last card in the row. After the final move, only two cards are left in the row. The goal is to take cards in such order as to minimize the total number of scored points. For example, if cards in the row contain numbers 10, 1, 50, 20, 5, player might take a card with 1, then 20 and 50, scoring 10*1*50 + 50*20*5 + 10*50*5 = 500+5000+2500 = 8000If he would take the cards in the opposite order, i.e. 50, then 20, then 1, the score would be 1*50*20 + 1*20*5 + 10*1*5 = 1000+100+50 = 1150 InputThe first line of the input contains the number of cards $N (3 \le N \le 100)$. The second line contains $N$ integers in the range from $1$ to $100$, separated by spaces. OutputOutput must contain a single integer - the minimal score. Sample Input6 10 1 50 50 20 5 Sample Output3650 Source Northeastern Europe 2001, Far-Eastern Subregion 题目大意 抽卡片，分数每次增加所抽卡片以及其相邻两侧的卡片的数值。不允许抽第一个和最后一个，抽到最后仅剩下这两张卡片，求最小的分数。 解题思路 每个大区间的分数都由最后抽的一张牌分成两个小区间，区间dp问题 状态转移方程dp[i][j]=min(dp[i][k]+dp[k][j]+a[i]*a[k]*a[j]) (i\leq k \leq j)解题代码12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758#include &lt;vector&gt;#include &lt;queue&gt;#include &lt;cstdio&gt;#include &lt;cstring&gt;#include &lt;cstdlib&gt;#include &lt;iostream&gt;#include &lt;algorithm&gt;//#include &lt;bits/stdc++.h&gt;#define ms(i,a) memset((i),(a),sizeof(i))#define rep(i,a,n) for (int i=a;i&lt;n;i++)#define per(i,a,n) for (int i=n-1;i&gt;=a;i--)#define pb push_back#define mp make_pair#define np next_permutation#define all(x) x.begin(),x.end()#define fi first#define se second#define SZ(x) ((int)(x).size()) #define INF 0x3f3f3f3fusing namespace std;int n,t,m; int dp[105][105],a[105],sum[105]; //前缀和 void initial()&#123; ms(dp,0); rep(i,1,n+1)&#123; rep(j,i+2,n+1)&#123; if(j==i+2) dp[i][j]=a[i]*a[i+1]*a[i+2]; else dp[i][j]=INF; &#125; &#125; &#125;int main()&#123; ios::sync_with_stdio(false);// freopen("in.txt","r",stdin); while(cin&gt;&gt;n) &#123; sum[0]=0; rep(i,1,n+1)&#123; cin&gt;&gt;a[i];// sum[i]=sum[i-1]+m; &#125; initial(); for (int len = 4; len &lt;= n; ++len)&#123; for (int i = 1; i + len - 1 &lt;= n; ++i) &#123; int j = i + len - 1; for (int k = i; k &lt;= j; ++k) dp[i][j] = min(dp[i][j], dp[i][k] + dp[k][j] + a[i] * a[k] * a[j]);// cout&lt;&lt;"i="&lt;&lt;i&lt;&lt;" j="&lt;&lt;j&lt;&lt;" dp="&lt;&lt;dp[i][j]&lt;&lt;endl; &#125; &#125; cout&lt;&lt;dp[1][n]&lt;&lt;endl; &#125; return 0;&#125; 收获与反思 注意边界条件 注意dp数组的初始化]]></content>
      <categories>
        <category>编程</category>
        <category>ACM</category>
      </categories>
      <tags>
        <tag>算法</tag>
        <tag>ACM</tag>
        <tag>2018暑假集训</tag>
        <tag>区间DP</tag>
        <tag>POJ</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[【CSU-1592】解题报告（区间DP入门）]]></title>
    <url>%2F2018%2F08%2F04%2F%E3%80%90CSU-1592%E3%80%91%E8%A7%A3%E9%A2%98%E6%8A%A5%E5%91%8A%EF%BC%88%E5%8C%BA%E9%97%B4DP%E5%85%A5%E9%97%A8%EF%BC%89%2F</url>
    <content type="text"><![CDATA[原始题目1592: 石子归并 Time Limit: 1 Sec Memory Limit: 128 Mb Submitted: 896 Solved: 421 Description现在有$n$堆石子，第$i$堆有$a_i$个石子。现在要把这些石子合并成一堆，每次只能合并相邻两个，每次合并的代价是两堆石子的总石子数。求合并所有石子的最小代价。 Input第一行包含一个整数$T ( T \le 50) $ ，表示数据组数。 每组数据第一行包含一个整数$ n ( 2 \le n \le 100 ) $，表示石子的堆数。 第二行包含$n$个正整数$ a_i ( a_i \le 100)$，表示每堆石子的石子数。 Output每组数据仅一行，表示最小合并代价。 Sample Input2 4 1 2 3 4 5 3 5 2 1 4 Sample Output19 33 HintSource国防科学技术大学第十八届银河之光文化节ACM程序设计竞赛初赛 题目大意如题 解题思路 区间dp 状态转移方程：$dp[i][j]=min(dp[i][j],dp[i][i+k]+dp[i+k+1][j]+sum[j]-sum[i-1])$; 解题代码1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859#include &lt;vector&gt;#include &lt;queue&gt;#include &lt;cstdio&gt;#include &lt;cstring&gt;#include &lt;cstdlib&gt;#include &lt;iostream&gt;#include &lt;algorithm&gt;//#include &lt;bits/stdc++.h&gt;#define ms(i,a) memset((i),(a),sizeof(i))#define rep(i,a,n) for (int i=a;i&lt;n;i++)#define per(i,a,n) for (int i=n-1;i&gt;=a;i--)#define pb push_back#define mp make_pair#define np next_permutation#define all(x) x.begin(),x.end()#define fi first#define se second#define SZ(x) ((int)(x).size()) #define INF 0x3f3f3f3fusing namespace std;int n,t,m; int dp[105][105],sum[105]; //前缀和 void initial()&#123; rep(i,1,n+1)&#123; rep(j,1,n+1)&#123; if(i==j) dp[i][j]=0; else dp[i][j]=INF; &#125; &#125; &#125;int main()&#123; ios::sync_with_stdio(false); cin&gt;&gt;t; while(t--) &#123; cin&gt;&gt;n; sum[0]=0; rep(i,1,n+1)&#123; cin&gt;&gt;m; sum[i]=sum[i-1]+m; &#125; initial(); for(int len=1; len&lt;n; len++) &#123; for(int i=1; i+len&lt;=n; i++) &#123; int j=i+len; for(int k=0; i+k&lt;j; k++) dp[i][j]=min(dp[i][j],dp[i][i+k]+dp[i+k+1][j]+sum[j]-sum[i-1]); &#125; &#125; cout&lt;&lt;dp[1][n]&lt;&lt;endl; &#125; return 0;&#125; 收获与反思 对于求区间问题最优解，考虑区间dp]]></content>
      <categories>
        <category>编程</category>
        <category>ACM</category>
      </categories>
      <tags>
        <tag>算法</tag>
        <tag>ACM</tag>
        <tag>CSU</tag>
        <tag>2018暑假集训</tag>
        <tag>区间DP</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[【HDU-1789】解题报告（贪心，多种思路）]]></title>
    <url>%2F2018%2F08%2F01%2F%E3%80%90HDU-1789%E3%80%91%E8%A7%A3%E9%A2%98%E6%8A%A5%E5%91%8A%EF%BC%88%E8%B4%AA%E5%BF%83%EF%BC%8C%E5%A4%9A%E7%A7%8D%E6%80%9D%E8%B7%AF%EF%BC%89%2F</url>
    <content type="text"><![CDATA[原始题目Doing Homework again Time Limit: 1000/1000 MS (Java/Others) Memory Limit: 32768/32768 K (Java/Others) Total Submission(s): 17643 Accepted Submission(s): 10264 Problem DescriptionIgnatius has just come back school from the 30th ACM/ICPC. Now he has a lot of homework to do. Every teacher gives him a deadline of handing in the homework. If Ignatius hands in the homework after the deadline, the teacher will reduce his score of the final test. And now we assume that doing everyone homework always takes one day. So Ignatius wants you to help him to arrange the order of doing homework to minimize the reduced score. InputThe input contains several test cases. The first line of the input is a single integer T that is the number of test cases. T test cases follow.Each test case start with a positive integer N(1≤N≤1000) which indicate the number of homework.. Then 2 lines follow. The first line contains N integers that indicate the deadlines of the subjects, and the next line contains N integers that indicate the reduced scores. OutputFor each test case, you should output the smallest total reduced score, one line per test case. Sample Input3 3 3 3 3 10 5 1 3 1 3 1 6 2 3 7 1 4 6 4 2 4 3 3 2 1 7 6 5 4 Sample Output0 3 5 Authorlcy Source2007省赛集训队练习赛（10）_以此感谢DOOMIII Recommendlcy 题目大意 某同学参加完比赛回来补作业，每种作业有ddl天数和扣分值。想让总扣分值尽量少，输出最小值。 解题思路 思路1：贪心，按分值从大到小排序，对于每份作业优先从ddl天向前安排，如果所有天都安排满了，那么ans加上该作业的扣分值（合理性：先安排的作业扣分值一定更大） 思路2：贪心+优先队列，按时间从小到大排序，按天数递增安排作业，可安排则将扣分值入队，如果安排满了，那么]]></content>
      <categories>
        <category>编程</category>
        <category>ACM</category>
      </categories>
      <tags>
        <tag>算法</tag>
        <tag>ACM</tag>
        <tag>2018暑假集训</tag>
        <tag>Greedy</tag>
        <tag>HDU</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[【CSU-1588】解题报告（贪心，水题）]]></title>
    <url>%2F2018%2F08%2F01%2F%E3%80%90CSU-1588%E3%80%91%E8%A7%A3%E9%A2%98%E6%8A%A5%E5%91%8A%EF%BC%88%E8%B4%AA%E5%BF%83%EF%BC%8C%E6%B0%B4%E9%A2%98%EF%BC%89%2F</url>
    <content type="text"><![CDATA[原始题目1588: 合并果子 Time Limit: 1 Sec Memory Limit: 128 Mb Submitted: 1907 Solved: 906 Description现在有$n$堆果子，第$i$堆有 $a_i$个果子。现在要把这些果子合并成一堆，每次合并的代价是两堆果子的总果子数。求合并所有果子的最小代价。 Input第一行包含一个整数$T(T \le 50)$，表示数据组数。 每组数据第一行包含一个整数$ n( 2 \le n \le 1000 )$ ，表示果子的堆数。 第二行包含$n$个正整数$a_i ( a_i \le 100) $，表示每堆果子的果子数。 Output每组数据仅一行，表示最小合并代价。 Sample Input2 4 1 2 3 4 5 3 5 2 1 4 Sample Output19 33 HintSource国防科学技术大学第十八届银河之光文化节ACM程序设计竞赛初赛 题目大意如题 解题思路 贪心，优先队列，每次取顶上两堆果子。 解题代码1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253//#include &lt;bits/stdc++.h&gt;#include &lt;cstdio&gt;#include &lt;cmath&gt;#include &lt;cstdlib&gt;#include &lt;cstring&gt;#include &lt;iostream&gt;#include &lt;set&gt;#include &lt;iomanip&gt;#include &lt;algorithm&gt;#include &lt;queue&gt;#include &lt;map&gt;#include &lt;string&gt;#define INF 0x3f3f3f3f#define rep(i,a,n) for(int i=a;i&lt;n;i++)#define per(i,a,n) for(int i=n-1;i&gt;=a;i--)using namespace std;const int maxn=1e5+5; typedef long long ll;ll t,n,a[maxn];priority_queue&lt;ll, vector&lt;ll&gt;, greater&lt;ll&gt; &gt; pq;int main()&#123; ios::sync_with_stdio(false); int t; cin&gt;&gt;t; while(t--)&#123; while(!pq.empty()) pq.pop(); int n; ll sum=0,sum1,a; cin&gt;&gt;n; rep(i,0,n)&#123; cin&gt;&gt;a; pq.push(a); &#125; while(!pq.empty())&#123; sum1=pq.top(); pq.pop(); sum1+=pq.top(); pq.pop(); if(pq.empty())&#123;// cout&lt;&lt;"empty"&lt;&lt;sum1&lt;&lt;endl; sum+=sum1;break; &#125; else&#123; sum+=sum1;// cout&lt;&lt;"get"&lt;&lt;sum1&lt;&lt;endl; pq.push(sum1); &#125; &#125; cout&lt;&lt;sum&lt;&lt;endl; &#125;&#125; 收获与反思水题]]></content>
      <categories>
        <category>编程</category>
        <category>ACM</category>
      </categories>
      <tags>
        <tag>算法</tag>
        <tag>ACM</tag>
        <tag>CSU</tag>
        <tag>2018暑假集训</tag>
        <tag>Greedy</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[【HDU-6325】解题报告（计算几何，2018杭电多校第三场）]]></title>
    <url>%2F2018%2F07%2F31%2F%E3%80%90HDU-6325%E3%80%91%E8%A7%A3%E9%A2%98%E6%8A%A5%E5%91%8A%EF%BC%88%E8%AE%A1%E7%AE%97%E5%87%A0%E4%BD%95%EF%BC%8C2018%E6%9D%AD%E7%94%B5%E5%A4%9A%E6%A0%A1%E7%AC%AC%E4%B8%89%E5%9C%BA%EF%BC%89%2F</url>
    <content type="text"><![CDATA[原始题目Problem G. Interstellar Travel Time Limit: 4000/2000 MS (Java/Others) Memory Limit: 524288/524288 K (Java/Others) Total Submission(s): 638 Accepted Submission(s): 137 Problem DescriptionAfter trying hard for many years, Little Q has finally received an astronaut license. To celebrate the fact, he intends to buy himself a spaceship and make an interstellar travel. Little Q knows the position of $n$ planets in space, labeled by $1$ to $n$. To his surprise, these planets are all coplanar. So to simplify, Little Q put these $n$ planets on a plane coordinate system, and calculated the coordinate of each planet $(x_i,y_i)$. Little Q plans to start his journey at the $1$-th planet, and end at the $n$-th planet. When he is at the $i$-th planet, he can next fly to the $j$-th planet only if $x_i&lt;x_j$, which will cost his spaceship $x_i\times y_j-x_j\times y_i$ units of energy. Note that this cost can be negative, it means the flight will supply his spaceship. Please write a program to help Little Q find the best route with minimum total cost. InputThe first line of the input contains an integer $T(1\leq T\leq10)$, denoting the number of test cases. In each test case, there is an integer $n(2\leq n\leq 200000)$ in the first line, denoting the number of planets. For the next n lines, each line contains $2$ integers $x_i,y_i(0\leq x_i,y_i\leq 10^9)$, denoting the coordinate of the i-th planet. Note that different planets may have the same coordinate because they are too close to each other. It is guaranteed that $y_1=y_n=0,0=x_1&lt;x_2,x_3,…,x_{n-1}&lt;x_n$. OutputFor each test case, print a single line containing several distinct integers $p_1,p_2,…,p_m(1\leq p_i\leq n)$, denoting the route you chosen is $p_1\rightarrow p_2\rightarrow…\rightarrow p_{m-1}\rightarrow p_m$. Obviously $p_1$ should be $1$ and $p_m$ should be $n$. You should choose the route with minimum total cost. If there are multiple best routes, please choose the one with the smallest lexicographically. A sequence of integers $a$ is lexicographically smaller than $a$ sequence of $b$ if there exists such index $j$ that $a_i=b_i$ for all $i&lt;j$, but $a_j&lt;b_j$. Sample Input1 3 0 0 3 0 4 0 Sample Output1 2 3 Source2018 Multi-University Training Contest 3 Recommendchendu 题目大意 给了$n$个星球的横纵坐标，从第一个星球旅行到第n个星球，消耗的燃料是叉积（可能为负） 已知$y_1=y_n=0,0=x_1&lt;x_2,x_3,…,x_{n-1}&lt;x_n$，每次旅行下一个星球的$x$坐标要大于上一个星球。 求消耗燃料的最小值，输出字典序最小的满足条件的访问顺序。 解题思路 即求从第一个点到第n个星球的上半凸包（有向面积最小，负最大） 三点共线和同点的时候要满足字典序最小的要求。 共线时判断中间点字典序是不是小于后点，共点时保留序列最小的。 解题代码123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147148149150151152153154155156157158159160161162163164165166167168169170171172173174175176177178179180181182183184185186187188189190191192193194195196197198199200201202203204205206207208209210211212213214215216217218219220221222223224225226227228229230231232#include &lt;bits/stdc++.h&gt;using namespace std;#define rep(i,a,n) for (int i=a;i&lt;n;i++)#define per(i,a,n) for (int i=n-1;i&gt;=a;i--)#define pb push_back#define mp make_pair#define np next_permutation#define all(x) x.begin(),x.end()#define fi first#define se second#define SZ(x) ((int)(x).size()) const int maxn=2e5+5;const double eps=1e-9;typedef long long ll;ll n,cnt;//有的命名为sgn函数，高精度符号判断 ll dcmp(double x)&#123; //相等函数判断，减少精度问题 if(fabs(x)&lt;eps) return 0; else return x&lt;0?-1:1;&#125;//点的定义 class Point&#123; public: ll x,y; Point (ll x=0,double y=0):x(x),y(y)&#123;&#125; //构造函数，方便代码的编写 &#125;; typedef Point Vector;// 从程序实现上，Vector只是Point的别名//运算符重载 //向量+向量=向量，点+向量=点Vector operator + (const Vector &amp;A,const Vector &amp;B) &#123; return Vector(A.x+B.x,A.y+B.y); &#125;//向量-向量=向量，点-向量-点 Vector operator - (const Vector &amp;A,const Vector &amp;B) &#123; return Vector(A.x-B.x,A.y-B.y); &#125;//向量*数=向量 （数乘） Vector operator * (const Vector &amp;A,double p) &#123; return Vector(A.x*p,A.y*p); &#125;//向量/数=向量 （数除） Vector operator / (const Vector &amp;A,double p) &#123; return Vector(A.x/p,A.y/p); &#125;//向量（点乘）向量=数 （点乘）double operator * (const Vector &amp;A,const Vector &amp;B) &#123; return A.x*B.x+A.y*B.y; &#125;double dot(const Vector &amp;A,const Vector &amp;B)&#123; return A.x*B.x+A.y*B.y; &#125;//向量（叉乘）向量=向量 （叉乘） double operator ^ (const Vector &amp;A,const Vector &amp;B)&#123; return A.x*B.y-A.y*B.x; &#125;ll cross(const Vector &amp;A,const Vector &amp;B)&#123; return A.x*B.y-A.y*B.x; &#125;//计算向量模长 double abs(const Vector &amp;A)&#123; return sqrt(dot(A,A));&#125;//计算平行四边形方向面积double area2(const Point &amp;A,const Point &amp;B,const Point &amp;C)&#123; return cross(B-A,C-A) ;&#125; //按x值递增排序 bool operator &lt; (const Point &amp;A,const Point &amp;B) &#123; return A.x==B.x?A.y&lt;B.y:A.x&lt;B.x; &#125; //判定两个点是否相同，用到dcmp精度判定 bool operator == (const Point &amp;A,const Point &amp;B) &#123; return dcmp(A.x-B.x)==0&amp;&amp; dcmp(A.y-B.y)==0; &#125; //向量旋转Vector rotate(Vector A,double rad) &#123; return Vector(A.x*cos(rad)-A.y*sin(rad),A.x*sin(rad)+A.y*cos(rad));&#125;//计算单位法线，左转90Vector normal(Vector A)&#123; double l=abs(A); return Vector(-A.y/l,A.x/l);&#125; //线段定义 class Line &#123; public: Point s,e; Line()&#123;&#125; Line(Point _s,Point _e)&#123; s=_s;e=_e; &#125; &#125;line[maxn];//判断两线段是否相交 bool inter(Line l1,Line l2)&#123;// cout&lt;&lt;"L1 "&lt;&lt;l1.e.x&lt;&lt;","&lt;&lt;l1.e.y&lt;&lt;" "&lt;&lt;l1.s.x&lt;&lt;","&lt;&lt;l1.s.y&lt;&lt;endl;// cout&lt;&lt;"L2 "&lt;&lt;l2.e.x&lt;&lt;","&lt;&lt;l2.e.y&lt;&lt;" "&lt;&lt;l2.s.x&lt;&lt;","&lt;&lt;l2.s.y&lt;&lt;endl; return ( //根据题目要求端点相交是否算作相交来决定大于等于和小于等于 //排斥实验 max(l1.s.x,l1.e.x)&gt;=min(l2.s.x,l2.e.x) &amp;&amp; max(l2.s.x,l2.e.x)&gt;=min(l1.s.x,l1.e.x) &amp;&amp; max(l1.s.y,l1.e.y)&gt;=min(l2.s.y,l2.e.y) &amp;&amp; max(l2.s.y,l2.e.y)&gt;=min(l1.s.y,l1.e.y) &amp;&amp; //跨立实验 dcmp((l2.s-l1.s)^(l1.s-l1.e))*dcmp((l2.e-l1.s)^(l1.s-l1.e))&lt;0 &amp;&amp; dcmp((l1.s-l2.s)^(l2.s-l2.e))*dcmp((l1.e-l2.s)^(l2.s-l2.e))&lt;0 ) ;&#125;bool inter(Point a1,Point a2,Point b1,Point b2)&#123; Line l1(a1,a2),l2(b1,b2); return inter(l1,l2);&#125;//求两直线交点Point getinter(Line l1,Line l2)&#123; Vector v=l1.s-l1.e; Vector w=l2.s-l2.e; Vector u=l1.e-l2.e; double t=cross(w,u)/cross(v,w); return l1.e+v*t;&#125; Point getinter(Point a1,Point a2,Point b1,Point b2)&#123; Line l1(a1,a2); Line l2(b1,b2); return getinter(l1,l2);&#125;//判定点和线段的关系，//0:不在线段所在直线上//1:在线段内（不含端点） //2:在线段端点//3:在线段两侧的射线上 ll online(Point a,Line l)&#123; if(dcmp(cross(l.s-a,l.e-a))!=0) return 0; double pans=dcmp(dot(l.s-a,l.e-a));// cout&lt;&lt;(l.s-a).x&lt;&lt;","&lt;&lt;(l.s-a).y&lt;&lt;" "&lt;&lt;(l.e-a).x&lt;&lt;","&lt;&lt;(l.e-a).y&lt;&lt;endl; if(pans&lt;0) return 1; else if(pans==0) return 2; else if(pans&gt;0) return 3;&#125;ll online(Point a,Point b1,Point b2)&#123; Line l(b1,b2); return online(a,l);&#125;class node&#123; public: ll index; Point p;&#125; point[maxn],ans[maxn],pre[maxn];bool cmp(node a, node b)&#123; if(a.p.x==b.p.x)&#123; if(a.p.y==b.p.y) return a.index&gt;b.index; return a.p.y&lt;b.p.y; &#125; else &#123; return a.p.x&lt;b.p.x; &#125;&#125;ll ConvexHull()&#123; ll flag=0; ll m=0; for(ll i=1;i&lt;=cnt;i++)&#123; if(!flag &amp;&amp; point[i].index!=1) continue; if(point[i].index==1)&#123; flag=1; &#125; while(m&gt;1 &amp;&amp; cross(ans[m-1].p-ans[m-2].p,point[i].p-ans[m-2].p)&gt;=0) &#123; if(m&gt;1 &amp;&amp; cross(ans[m-1].p-ans[m-2].p,point[i].p-ans[m-2].p)==0)&#123; //判断字典序 if(point[i].index&lt;ans[m-1].index) m--; else break; &#125; else if(m&gt;1 &amp;&amp; cross(ans[m-1].p-ans[m-2].p,point[i].p-ans[m-2].p)&gt;0)&#123; m--; &#125; &#125; ans[m].p=point[i].p; ans[m].index=point[i].index;// cout&lt;&lt;m&lt;&lt;" ans.p=("&lt;&lt;ans[m].p.x&lt;&lt;","&lt;&lt;ans[m].p.y&lt;&lt;" index="&lt;&lt;ans[m].index&lt;&lt;endl;// cout&lt;&lt;"$$$$"&lt;&lt;ans[m].index&lt;&lt;" "&lt;&lt;n&lt;&lt;"$$$$"&lt;&lt;endl; m++; if(ans[m-1].index==n) break;// cout&lt;&lt;m&lt;&lt;" ans.p=("&lt;&lt;ans[m].p.x&lt;&lt;","&lt;&lt;ans[m].p.y&lt;&lt;" index="&lt;&lt;ans[m].index&lt;&lt;endl; &#125; return m;&#125;int main()&#123; ios::sync_with_stdio(false); ll t; cin&gt;&gt;t; while(t--)&#123; cin&gt;&gt;n; cnt=0; rep(i,1,n+1)&#123; cin&gt;&gt;pre[i].p.x&gt;&gt;pre[i].p.y; pre[i].index=i; &#125; sort(pre+1,pre+n+1,cmp); rep(i,1,n+1)&#123; if(i==1) point[++cnt]=pre[i]; else if(pre[i].p.x==point[cnt].p.x) point[cnt]=pre[i]; else point[++cnt]=pre[i]; &#125; ll len=ConvexHull(); rep(i,0,len)&#123; if(i==0) cout&lt;&lt;ans[i].index; else cout&lt;&lt;" "&lt;&lt;ans[i].index; &#125; cout&lt;&lt;endl; &#125;&#125; //1//7//1 1//3 5//3 1//1 3//2 4//7 2//9 1//2 //13//1 0 //3 5//3 1//2 4//5 3//4 6//2 4//7 2//6 13//9 1//3 0//10 1//11 0 收获与反思 注意long long 可能出现共点情况，三点共线情况，都要考虑字典序的要求]]></content>
      <categories>
        <category>编程</category>
        <category>ACM</category>
      </categories>
      <tags>
        <tag>算法</tag>
        <tag>ACM</tag>
        <tag>2018暑假集训</tag>
        <tag>HDU</tag>
        <tag>2018杭电多校</tag>
        <tag>计算几何</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[【POJ-1654】解题报告（计算几何，longlong）]]></title>
    <url>%2F2018%2F07%2F31%2F%E3%80%90POJ-1654%E3%80%91%E8%A7%A3%E9%A2%98%E6%8A%A5%E5%91%8A%EF%BC%88%E8%AE%A1%E7%AE%97%E5%87%A0%E4%BD%95%EF%BC%8Clonglong%EF%BC%89%2F</url>
    <content type="text"><![CDATA[原始题目Area Time Limit: 1000MS Memory Limit: 10000K Total Submissions: 21457 Accepted: 5826 DescriptionYou are going to compute the area of a special kind of polygon. One vertex of the polygon is the origin of the orthogonal coordinate system. From this vertex, you may go step by step to the following vertexes of the polygon until back to the initial vertex. For each step you may go North, West, South or East with step length of 1 unit, or go Northwest, Northeast, Southwest or Southeast with step length of square root of 2. For example, this is a legal polygon to be computed and its area is 2.5: InputThe first line of input is an integer t (1 ≤ t ≤ 20), the number of the test polygons. Each of the following lines contains a string composed of digits 1-9 describing how the polygon is formed by walking from the origin. Here 8, 2, 6 and 4 represent North, South, East and West, while 9, 7, 3 and 1 denote Northeast, Northwest, Southeast and Southwest respectively. Number 5 only appears at the end of the sequence indicating the stop of walking. You may assume that the input polygon is valid which means that the endpoint is always the start point and the sides of the polygon are not cross to each other.Each line may contain up to 1000000 digits. OutputFor each polygon, print its area on a single line. Sample Input4 5 825 6725 6244865 Sample Output0 0 0.5 2 SourcePOJ Monthly—2004.05.15 Liu Rujia@POJ 题目大意 在二维坐标系中点向8个方向移动，经过一系列移动后回到原点，并且边不相交（构成闭合的多边形），求其面积。 解题思路 由于坐标都是整数且很大，由于精度考虑，按照long long计算最后再除以2. 解题代码123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147148149150151152153154155156157158159160161162163164165166167168//计算几何模板，二维几何基础//使用印用注意避免直接在程序中调用构造函数构造无名对象。否则可能会导致程序出错 //#include &lt;bits/stdc++.h&gt;#include &lt;cstdio&gt;#include &lt;cmath&gt;#include &lt;cstdlib&gt;#include &lt;cstring&gt;#include &lt;iostream&gt;#include &lt;set&gt;#include &lt;iomanip&gt;#include &lt;algorithm&gt;#include &lt;queue&gt;#include &lt;map&gt;#include &lt;string&gt;#define INF 0x3f3f3f3f#define rep(i,a,n) for(int i=a;i&lt;n;i++)#define per(i,a,n) for(int i=n-1;i&gt;=a;i--)using namespace std;typedef long long ll;const double eps =1e-10;const int maxn=50;int n;//有的命名为sgn函数，高精度符号判断 int dcmp(double x)&#123; //相等函数判断，减少精度问题 if(fabs(x)&lt;eps) return 0; else return x&lt;0?-1:1;&#125;//点的定义 class Point&#123; public: ll x,y; Point (ll x=0,ll y=0):x(x),y(y)&#123;&#125; //构造函数，方便代码的编写 &#125;; typedef Point Vector;// 从程序实现上，Vector只是Point的别名//运算符重载 //向量+向量=向量，点+向量=点Vector operator + (const Vector &amp;A,const Vector &amp;B) &#123; return Vector(A.x+B.x,A.y+B.y); &#125;//向量-向量=向量，点-向量-点 Vector operator - (const Vector &amp;A,const Vector &amp;B) &#123; return Vector(A.x-B.x,A.y-B.y); &#125;//向量*数=向量 （数乘） Vector operator * (const Vector &amp;A,double p) &#123; return Vector(A.x*p,A.y*p); &#125;//向量/数=向量 （数除） Vector operator / (const Vector &amp;A,double p) &#123; return Vector(A.x/p,A.y/p); &#125;//向量（点乘）向量=数 （点乘）double operator * (const Vector &amp;A,const Vector &amp;B) &#123; return A.x*B.x+A.y*B.y; &#125;double dot(const Vector &amp;A,const Vector &amp;B)&#123; return A.x*B.x+A.y*B.y; &#125;//向量（叉乘）向量=向量 （叉乘） double operator ^ (const Vector &amp;A,const Vector &amp;B)&#123; return A.x*B.y-A.y*B.x; &#125;ll cross(const Vector &amp;A,const Vector &amp;B)&#123; return A.x*B.y-A.y*B.x; &#125;//计算向量模长 double abs(const Vector &amp;A)&#123; return sqrt(dot(A,A));&#125;//计算平行四边形方向面积double area2(const Point &amp;A,const Point &amp;B,const Point &amp;C)&#123; return cross(B-A,C-A) ;&#125; //按x值递增排序 bool operator &lt; (const Point &amp;A,const Point &amp;B) &#123; return A.x==B.x?A.y&lt;B.y:A.x&lt;B.x; &#125; //判定两个点是否相同，用到dcmp精度判定 bool operator == (const Point &amp;A,const Point &amp;B) &#123; return dcmp(A.x-B.x)==0&amp;&amp; dcmp(A.y-B.y)==0; &#125; //向量旋转Vector rotate(Vector A,double rad) &#123; return Vector(A.x*cos(rad)-A.y*sin(rad),A.x*sin(rad)+A.y*cos(rad));&#125;//计算单位法线，左转90Vector normal(Vector A)&#123; double l=abs(A); return Vector(-A.y/l,A.x/l);&#125; //线段定义 class Line &#123; public: Point s,e; Line()&#123;&#125; Line(Point _s,Point _e)&#123; s=_s;e=_e; &#125; &#125;line[maxn];//判断两线段是否相交 bool inter(Line l1,Line l2)&#123;// cout&lt;&lt;"L1 "&lt;&lt;l1.e.x&lt;&lt;","&lt;&lt;l1.e.y&lt;&lt;" "&lt;&lt;l1.s.x&lt;&lt;","&lt;&lt;l1.s.y&lt;&lt;endl;// cout&lt;&lt;"L2 "&lt;&lt;l2.e.x&lt;&lt;","&lt;&lt;l2.e.y&lt;&lt;" "&lt;&lt;l2.s.x&lt;&lt;","&lt;&lt;l2.s.y&lt;&lt;endl; return ( //根据题目要求端点相交是否算作相交来决定大于等于和小于等于 //排斥实验 max(l1.s.x,l1.e.x)&gt;=min(l2.s.x,l2.e.x) &amp;&amp; max(l2.s.x,l2.e.x)&gt;=min(l1.s.x,l1.e.x) &amp;&amp; max(l1.s.y,l1.e.y)&gt;=min(l2.s.y,l2.e.y) &amp;&amp; max(l2.s.y,l2.e.y)&gt;=min(l1.s.y,l1.e.y) &amp;&amp; //跨立实验 dcmp((l2.s-l1.s)^(l1.s-l1.e))*dcmp((l2.e-l1.s)^(l1.s-l1.e))&lt;0 &amp;&amp; dcmp((l1.s-l2.s)^(l2.s-l2.e))*dcmp((l1.e-l2.s)^(l2.s-l2.e))&lt;0 ) ;&#125;bool inter(Point a1,Point a2,Point b1,Point b2)&#123; Line l1(a1,a2),l2(b1,b2); return inter(l1,l2);&#125;//求两直线交点Point getinter(Line l1,Line l2)&#123; Vector v=l1.s-l1.e; Vector w=l2.s-l2.e; Vector u=l1.e-l2.e; double t=cross(w,u)/cross(v,w); return l1.e+v*t;&#125; Point getinter(Point a1,Point a2,Point b1,Point b2)&#123; Line l1(a1,a2); Line l2(b1,b2); return getinter(l1,l2);&#125;//判定点和线段的关系，//0:不在线段所在直线上//1:在线段内（不含端点） //2:在线段端点//3:在线段两侧的射线上 int online(Point a,Line l)&#123; if(dcmp(cross(l.s-a,l.e-a))!=0) return 0; double pans=dcmp(dot(l.s-a,l.e-a));// cout&lt;&lt;(l.s-a).x&lt;&lt;","&lt;&lt;(l.s-a).y&lt;&lt;" "&lt;&lt;(l.e-a).x&lt;&lt;","&lt;&lt;(l.e-a).y&lt;&lt;endl; if(pans&lt;0) return 1; else if(pans==0) return 2; else if(pans&gt;0) return 3;&#125;int online(Point a,Point b1,Point b2)&#123; Line l(b1,b2); return online(a,l);&#125; int main()&#123; int t; cin&gt;&gt;t; while(t--)&#123; Point pnow(0,0),pnext(0,0); ll area=0; string s; cin&gt;&gt;s; int len=s.size(); rep(i,0,len)&#123; pnow=pnext; switch(s[i])&#123; case '8': pnext.y++; break; case '2': pnext.y--; break; case '6': pnext.x++; break; case '4': pnext.x--; break; case '9': pnext.x++, pnext.y++; break; case '7': pnext.x--, pnext.y++; break; case '3': pnext.x++, pnext.y--; break; case '1': pnext.x--, pnext.y--; break; default: break; &#125; area+=cross(pnext,pnow); &#125; area=(area&lt;0?(0-area):area); if(area%2==0) cout&lt;&lt;area/2&lt;&lt;endl; else cout&lt;&lt;area/2&lt;&lt;".5"&lt;&lt;endl; &#125;&#125; 收获与反思 整数坐标注意开long long。 多边形有向面积模板题。]]></content>
      <categories>
        <category>编程</category>
        <category>ACM</category>
      </categories>
      <tags>
        <tag>算法</tag>
        <tag>ACM</tag>
        <tag>2018暑假集训</tag>
        <tag>计算几何</tag>
        <tag>POJ</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[【UVA-10652】解题报告（计算几何，凸包模板）]]></title>
    <url>%2F2018%2F07%2F31%2F%E3%80%90UVA-10652%E3%80%91%E8%A7%A3%E9%A2%98%E6%8A%A5%E5%91%8A%EF%BC%88%E8%AE%A1%E7%AE%97%E5%87%A0%E4%BD%95%EF%BC%8C%E5%87%B8%E5%8C%85%E6%A8%A1%E6%9D%BF%EF%BC%89%2F</url>
    <content type="text"><![CDATA[原始题目Board Wrapping 题目大意 给出平面直角坐标系n个长方形模具的中心点，长宽以及顺时针旋转角度，求一个能包含所有模具的最小多边形，并计算模具的面积占多边形面积的百分比。 解题思路 把长方形都看成四个点，则为凸包问题，求凸包面积以及长方形面积计算百分比即可。 解题代码123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147148149150151152153154155156157158159160161162163164165166167168169170171172173//计算几何模板，二维几何基础//使用印用注意避免直接在程序中调用构造函数构造无名对象。否则可能会导致程序出错 #include &lt;bits/stdc++.h&gt;#include &lt;cstdio&gt;#include &lt;cmath&gt;#include &lt;cstdlib&gt;#include &lt;cstring&gt;#include &lt;iostream&gt;#include &lt;set&gt;#include &lt;iomanip&gt;#include &lt;algorithm&gt;#include &lt;queue&gt;#include &lt;map&gt;#include &lt;string&gt;#define INF 0x3f3f3f3f#define rep(i,a,n) for(int i=a;i&lt;n;i++)#define per(i,a,n) for(int i=n-1;i&gt;=a;i--)using namespace std;typedef long long ll;const double eps =1e-10;const int maxn=2500; //注意修改 int n;//有的命名为sgn函数，高精度符号判断 int dcmp(double x)&#123; //相等函数判断，减少精度问题 if(fabs(x)&lt;eps) return 0; else return x&lt;0?-1:1;&#125;//点的定义 class Point&#123; public: double x,y; Point (double x=0,double y=0):x(x),y(y)&#123;&#125; //构造函数，方便代码的编写 &#125;point[maxn],pafter[maxn]; typedef Point Vector;// 从程序实现上，Vector只是Point的别名//运算符重载 Vector operator + (const Vector &amp;A,const Vector &amp;B) &#123; return Vector(A.x+B.x,A.y+B.y); &#125; //向量+向量=向量，点+向量=点Vector operator - (const Vector &amp;A,const Vector &amp;B) &#123; return Vector(A.x-B.x,A.y-B.y); &#125; //向量-向量=向量，点-向量-点 Vector operator * (const Vector &amp;A,double p) &#123; return Vector(A.x*p,A.y*p); &#125; //向量*数=向量 （数乘） Vector operator / (const Vector &amp;A,double p) &#123; return Vector(A.x/p,A.y/p); &#125; //向量/数=向量 （数除）double operator * (const Vector &amp;A,const Vector &amp;B) &#123; return A.x*B.x+A.y*B.y; &#125; //向量（点乘）向量=数 （点乘）bool operator &lt; (const Point &amp;A,const Point &amp;B) &#123; return A.x==B.x?A.y&lt;B.y:A.x&lt;B.x; &#125; //按x值递增排序 bool operator == (const Point &amp;A,const Point &amp;B) &#123; return dcmp(A.x-B.x)==0&amp;&amp; dcmp(A.y-B.y)==0; &#125; //判定两个点是否相同，用到dcmp精度判定 //点乘叉乘 double dot(const Vector &amp;A,const Vector &amp;B)&#123; return A.x*B.x+A.y*B.y; &#125; //向量（叉乘）向量=向量 （叉乘） double operator ^ (const Vector &amp;A,const Vector &amp;B)&#123; return A.x*B.y-A.y*B.x; &#125;double cross(const Vector &amp;A,const Vector &amp;B)&#123; return A.x*B.y-A.y*B.x; &#125;//模长面积 double abs(const Vector &amp;A)&#123; return sqrt(dot(A,A));&#125; //计算向量模长 double area2(const Point &amp;A,const Point &amp;B,const Point &amp;C)&#123; return cross(B-A,C-A) ;&#125; //计算平行四边形方向面积double PolygonArea(Point *p,int n) &#123; double area=0; rep(i,1,n-1)&#123;area+=cross(p[i]-p[0],p[i+1]-p[0]);&#125;return area/2.0; &#125; //计算多边形的有向面积//旋转Vector rotate(Vector A,double rad) &#123; return Vector(A.x*cos(rad)-A.y*sin(rad),A.x*sin(rad)+A.y*cos(rad));&#125; //旋转rad弧度 Vector normal(Vector A)&#123;double l=abs(A);return Vector(-A.y/l,A.x/l);&#125; //计算单位法线，左转90double torad(double deg) &#123; return deg/180*acos(-1); &#125; //角度转弧度 //线段定义 class Line &#123; public: Point s,e; Line()&#123;&#125; Line(Point _s,Point _e)&#123; s=_s;e=_e; &#125; &#125;line[maxn];//判断两线段是否相交 bool inter(Line l1,Line l2)&#123;// cout&lt;&lt;"L1 "&lt;&lt;l1.e.x&lt;&lt;","&lt;&lt;l1.e.y&lt;&lt;" "&lt;&lt;l1.s.x&lt;&lt;","&lt;&lt;l1.s.y&lt;&lt;endl;// cout&lt;&lt;"L2 "&lt;&lt;l2.e.x&lt;&lt;","&lt;&lt;l2.e.y&lt;&lt;" "&lt;&lt;l2.s.x&lt;&lt;","&lt;&lt;l2.s.y&lt;&lt;endl; return ( //根据题目要求端点相交是否算作相交来决定大于等于和小于等于 //排斥实验 max(l1.s.x,l1.e.x)&gt;=min(l2.s.x,l2.e.x) &amp;&amp; max(l2.s.x,l2.e.x)&gt;=min(l1.s.x,l1.e.x) &amp;&amp; max(l1.s.y,l1.e.y)&gt;=min(l2.s.y,l2.e.y) &amp;&amp; max(l2.s.y,l2.e.y)&gt;=min(l1.s.y,l1.e.y) &amp;&amp; //跨立实验 dcmp((l2.s-l1.s)^(l1.s-l1.e))*dcmp((l2.e-l1.s)^(l1.s-l1.e))&lt;0 &amp;&amp; dcmp((l1.s-l2.s)^(l2.s-l2.e))*dcmp((l1.e-l2.s)^(l2.s-l2.e))&lt;0 ) ;&#125;bool inter(Point a1,Point a2,Point b1,Point b2)&#123; Line l1(a1,a2),l2(b1,b2); return inter(l1,l2);&#125;bool cmp(Point a,Point b)&#123; if(a.x==b.x) return a.y&lt;b.y; else return a.x&lt;b.x;&#125;//求两直线交点Point getinter(Line l1,Line l2)&#123;Vector v=l1.s-l1.e;Vector w=l2.s-l2.e;Vector u=l1.e-l2.e;double t=cross(w,u)/cross(v,w);return l1.e+v*t;&#125; Point getinter(Point a1,Point a2,Point b1,Point b2)&#123;Line l1(a1,a2);Line l2(b1,b2);return getinter(l1,l2);&#125;//判定点和线段的关系，//0:不在线段所在直线上//1:在线段内（不含端点） //2:在线段端点//3:在线段两侧的射线上 int online(Point a,Line l)&#123; if(dcmp(cross(l.s-a,l.e-a))!=0) return 0; double pans=dcmp(dot(l.s-a,l.e-a));// cout&lt;&lt;(l.s-a).x&lt;&lt;","&lt;&lt;(l.s-a).y&lt;&lt;" "&lt;&lt;(l.e-a).x&lt;&lt;","&lt;&lt;(l.e-a).y&lt;&lt;endl; if(pans&lt;0) return 1; else if(pans==0) return 2; else if(pans&gt;0) return 3;&#125;int online(Point a,Point b1,Point b2)&#123; Line l(b1,b2); return online(a,l);&#125;//凸包int ConvexHull(Point *p,int n,Point *ch)&#123; sort(p,p+n,cmp); int m=0; for(int i=0;i&lt;n;i++)&#123; while(m&gt;1 &amp;&amp; cross(ch[m-1]-ch[m-2],p[i]-ch[m-2])&lt;=0) m--; ch[m++]=p[i]; &#125; int k=m; for(int i=n-2;i&gt;=0;i--)&#123; while(m&gt;k &amp;&amp; cross(ch[m-1]-ch[m-2],p[i]-ch[m-2])&lt;=0) m--; ch[m++]=p[i]; &#125; if(n&gt;1) m--; return m;&#125; int main()&#123; int t; ios::sync_with_stdio(false); cin&gt;&gt;t; while(t--)&#123; int n,pc=0; double area1=0; cin&gt;&gt;n; rep(i,0,n)&#123; double x,y,w,h,j,ang; cin&gt;&gt;x&gt;&gt;y&gt;&gt;w&gt;&gt;h&gt;&gt;j; Point o(x,y); //原始点 ang=-torad(j); point[pc++]=o+rotate(Vector(w/2,h/2),ang); point[pc++]=o+rotate(Vector(-w/2,h/2),ang); point[pc++]=o+rotate(Vector(w/2,-h/2),ang); point[pc++]=o+rotate(Vector(-w/2,-h/2),ang); area1+= w*h; &#125;// for(int i=0;i&lt;pc;i++) cout&lt;&lt;point[i].x&lt;&lt;","&lt;&lt;point[i].y&lt;&lt;endl; int len=ConvexHull(point,pc,pafter); double area2 = PolygonArea(pafter,len);// cout&lt;&lt;"len="&lt;&lt;len&lt;&lt;" area1="&lt;&lt;area1&lt;&lt;" area2="&lt;&lt;area2&lt;&lt;endl; cout&lt;&lt;fixed&lt;&lt;setprecision(1)&lt;&lt;area1*100/area2&lt;&lt;" %"&lt;&lt;endl; &#125; &#125; 收获与反思 凸包模板]]></content>
      <categories>
        <category>编程</category>
        <category>ACM</category>
      </categories>
      <tags>
        <tag>算法</tag>
        <tag>ACM</tag>
        <tag>2018暑假集训</tag>
        <tag>计算几何</tag>
        <tag>UVA</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[【POJ-1269】解题报告（计算几何，直线相交求交点）]]></title>
    <url>%2F2018%2F07%2F31%2F%E3%80%90POJ-1269%E3%80%91%E8%A7%A3%E9%A2%98%E6%8A%A5%E5%91%8A%EF%BC%88%E8%AE%A1%E7%AE%97%E5%87%A0%E4%BD%95%EF%BC%8C%E7%9B%B4%E7%BA%BF%E7%9B%B8%E4%BA%A4%E6%B1%82%E4%BA%A4%E7%82%B9%EF%BC%89%2F</url>
    <content type="text"><![CDATA[原始题目Intersecting Lines Time Limit: 1000MS Memory Limit: 10000K Total Submissions: 18318 Accepted: 7816 DescriptionWe all know that a pair of distinct points on a plane defines a line and that a pair of lines on a plane will intersect in one of three ways:1) no intersection because they are parallel,2) intersect in a line because they are on top of one another (i.e. they are the same line),3) intersect in a point. In this problem you will use your algebraic knowledge to create a program that determines how and where two lines intersect. Your program will repeatedly read in four points that define two lines in the x-y plane and determine how and where the lines intersect. All numbers required by this problem will be reasonable, say between -1000 and 1000. InputThe first line contains an integer N between 1 and 10 describing how many pairs of lines are represented. The next N lines will each contain eight integers. These integers represent the coordinates of four points on the plane in the order x1y1x2y2x3y3x4y4. Thus each of these input lines represents two lines on the plane: the line through (x1,y1) and (x2,y2) and the line through (x3,y3) and (x4,y4). The point (x1,y1) is always distinct from (x2,y2). Likewise with (x3,y3) and (x4,y4). OutputThere should be N+2 lines of output. The first line of output should read INTERSECTING LINES OUTPUT. There will then be one line of output for each pair of planar lines represented by a line of input, describing how the lines intersect: none, line, or point. If the intersection is a point then your program should output the x and y coordinates of the point, correct to two decimal places. The final line of output should read “END OF OUTPUT”. Sample Input5 0 0 4 4 0 4 4 0 5 0 7 6 1 0 2 3 5 0 7 6 3 -6 4 -3 2 0 2 27 1 5 18 5 0 3 4 0 1 2 2 5 Sample OutputINTERSECTING LINES OUTPUT POINT 2.00 2.00 NONE LINE POINT 2.00 5.00 POINT 1.07 2.20 END OF OUTPUT SourceMid-Atlantic 1996 题目大意给出n组两点确定的直线（不是线段），判断两条直线是平行，相交（给出交点）还是同一直线。 解题思路 计算几何基础题 先求两向量$v_1,v_2$的cross（叉积），若为零则从两条直线的点各取一个构成向量$v_3$和原向量其中一个求叉积，若也为零说明共线，不为零说明平行 非上述则求交点，套模板公式即可 解题代码123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147148149150151152153154155156157158//计算几何模板，二维几何基础//使用印用注意避免直接在程序中调用构造函数构造无名对象。否则可能会导致程序出错 //#include &lt;bits/stdc++.h&gt;#include &lt;cstdio&gt;#include &lt;cmath&gt;#include &lt;cstdlib&gt;#include &lt;cstring&gt;#include &lt;iostream&gt;#include &lt;set&gt;#include &lt;iomanip&gt;#include &lt;algorithm&gt;#include &lt;queue&gt;#include &lt;map&gt;#include &lt;string&gt;#define INF 0x3f3f3f3f#define rep(i,a,n) for(int i=a;i&lt;n;i++)#define per(i,a,n) for(int i=n-1;i&gt;=a;i--)using namespace std;typedef long long ll;const double eps =1e-10;const int maxn=50;int n;//有的命名为sgn函数，高精度符号判断 int dcmp(double x)&#123; //相等函数判断，减少精度问题 if(fabs(x)&lt;eps) return 0; else return x&lt;0?-1:1;&#125;//点的定义 class Point&#123; public: double x,y; Point (double x=0,double y=0):x(x),y(y)&#123;&#125; //构造函数，方便代码的编写 &#125;point[maxn]; typedef Point Vector;// 从程序实现上，Vector只是Point的别名//运算符重载 Vector operator + (const Vector &amp;A,const Vector &amp;B) &#123; return Vector(A.x+B.x,A.y+B.y); &#125; //向量+向量=向量，点+向量=点Vector operator - (const Vector &amp;A,const Vector &amp;B) &#123; return Vector(A.x-B.x,A.y-B.y); &#125; //向量-向量=向量，点-向量-点 Vector operator * (const Vector &amp;A,double p) &#123; return Vector(A.x*p,A.y*p); &#125; //向量*数=向量 （数乘） Vector operator / (const Vector &amp;A,double p) &#123; return Vector(A.x/p,A.y/p); &#125; //向量/数=向量 （数除）double operator * (const Vector &amp;A,const Vector &amp;B) &#123; return A.x*B.x+A.y*B.y; &#125; //向量（点乘）向量=数 （点乘）bool operator &lt; (const Point &amp;A,const Point &amp;B) &#123; return A.x==B.x?A.y&lt;B.y:A.x&lt;B.x; &#125; //按x值递增排序 bool operator == (const Point &amp;A,const Point &amp;B) &#123; return dcmp(A.x-B.x)==0&amp;&amp; dcmp(A.y-B.y)==0; &#125; //判定两个点是否相同，用到dcmp精度判定 //点乘叉乘 double dot(const Vector &amp;A,const Vector &amp;B)&#123; return A.x*B.x+A.y*B.y; &#125; //向量（叉乘）向量=向量 （叉乘） double operator ^ (const Vector &amp;A,const Vector &amp;B)&#123; return A.x*B.y-A.y*B.x; &#125;double cross(const Vector &amp;A,const Vector &amp;B)&#123; return A.x*B.y-A.y*B.x; &#125;//模长面积 double abs(const Vector &amp;A)&#123; return sqrt(dot(A,A));&#125; //计算向量模长 double area2(const Point &amp;A,const Point &amp;B,const Point &amp;C)&#123; return cross(B-A,C-A) ;&#125; //计算平行四边形方向面积double PolygonArea(Point *p,int n) &#123; double area=0; rep(i,1,n-1)&#123;area+=cross(p[i]-p[0],p[i+1]-p[0]);&#125;return area/2.0; &#125; //计算多边形的有向面积//旋转Vector rotate(Vector A,double rad) &#123; return Vector(A.x*cos(rad)-A.y*sin(rad),A.x*sin(rad)+A.y*cos(rad));&#125; //旋转rad弧度 Vector normal(Vector A)&#123;double l=abs(A);return Vector(-A.y/l,A.x/l);&#125; //计算单位法线，左转90//线段定义 class Line &#123; public: Point s,e; Line()&#123;&#125; Line(Point _s,Point _e)&#123; s=_s;e=_e; &#125; &#125;line[maxn];//判断两线段是否相交 bool inter(Line l1,Line l2)&#123;// cout&lt;&lt;"L1 "&lt;&lt;l1.e.x&lt;&lt;","&lt;&lt;l1.e.y&lt;&lt;" "&lt;&lt;l1.s.x&lt;&lt;","&lt;&lt;l1.s.y&lt;&lt;endl;// cout&lt;&lt;"L2 "&lt;&lt;l2.e.x&lt;&lt;","&lt;&lt;l2.e.y&lt;&lt;" "&lt;&lt;l2.s.x&lt;&lt;","&lt;&lt;l2.s.y&lt;&lt;endl; return ( //根据题目要求端点相交是否算作相交来决定大于等于和小于等于 //排斥实验 max(l1.s.x,l1.e.x)&gt;=min(l2.s.x,l2.e.x) &amp;&amp; max(l2.s.x,l2.e.x)&gt;=min(l1.s.x,l1.e.x) &amp;&amp; max(l1.s.y,l1.e.y)&gt;=min(l2.s.y,l2.e.y) &amp;&amp; max(l2.s.y,l2.e.y)&gt;=min(l1.s.y,l1.e.y) &amp;&amp; //跨立实验 dcmp((l2.s-l1.s)^(l1.s-l1.e))*dcmp((l2.e-l1.s)^(l1.s-l1.e))&lt;0 &amp;&amp; dcmp((l1.s-l2.s)^(l2.s-l2.e))*dcmp((l1.e-l2.s)^(l2.s-l2.e))&lt;0 ) ;&#125;bool inter(Point a1,Point a2,Point b1,Point b2)&#123; Line l1(a1,a2),l2(b1,b2); return inter(l1,l2);&#125;bool cmp(Point a,Point b)&#123; if(a.x==b.x) return a.y&lt;b.y; else return a.x&lt;b.x;&#125;//求两直线交点Point getinter(Line l1,Line l2)&#123;Vector v=l1.s-l1.e;Vector w=l2.s-l2.e;Vector u=l1.e-l2.e;double t=cross(w,u)/cross(v,w);return l1.e+v*t;&#125; Point getinter(Point a1,Point a2,Point b1,Point b2)&#123;Line l1(a1,a2);Line l2(b1,b2);return getinter(l1,l2);&#125;//判定点和线段的关系，//0:不在线段所在直线上//1:在线段内（不含端点） //2:在线段端点//3:在线段两侧的射线上 int online(Point a,Line l)&#123; if(dcmp(cross(l.s-a,l.e-a))!=0) return 0; double pans=dcmp(dot(l.s-a,l.e-a));// cout&lt;&lt;(l.s-a).x&lt;&lt;","&lt;&lt;(l.s-a).y&lt;&lt;" "&lt;&lt;(l.e-a).x&lt;&lt;","&lt;&lt;(l.e-a).y&lt;&lt;endl; if(pans&lt;0) return 1; else if(pans==0) return 2; else if(pans&gt;0) return 3;&#125;int online(Point a,Point b1,Point b2)&#123; Line l(b1,b2); return online(a,l);&#125;//凸包int ConvexHull(Point *p,int n,Point *ch)&#123; sort(p,p+n,cmp); int m=0; for(int i=0;i&lt;n;i++)&#123; while(m&gt;1 &amp;&amp; cross(ch[m-1]-ch[m-2],p[i]-ch[m-2])&lt;=0) m--; ch[m++]=p[i]; &#125; int k=m; for(int i=n-2;i&gt;=0;i--)&#123; while(m&gt;k &amp;&amp; cross(ch[m-1]-ch[m-2],p[i]-ch[m-2])&lt;=0) m--; ch[m++]=p[i]; &#125; if(n&gt;1) m--; return m;&#125; int main()&#123; cin&gt;&gt;n; cout&lt;&lt;"INTERSECTING LINES OUTPUT"&lt;&lt;endl; rep(i,0,n)&#123; Line l1,l2; cin&gt;&gt;l1.e.x&gt;&gt;l1.e.y&gt;&gt;l1.s.x&gt;&gt;l1.s.y&gt;&gt;l2.e.x&gt;&gt;l2.e.y&gt;&gt;l2.s.x&gt;&gt;l2.s.y; Vector v1=l1.s-l1.e; Vector v2=l2.s-l2.e; if(dcmp(cross(v1,v2))==0) &#123; Vector v3=l1.s-l2.e; if(dcmp(cross(v1,v3))==0) cout&lt;&lt;"LINE"&lt;&lt;endl; else cout&lt;&lt;"NONE"&lt;&lt;endl; continue; &#125; Point in=getinter(l1,l2); cout&lt;&lt;"POINT "&lt;&lt;fixed&lt;&lt;setprecision(2)&lt;&lt;in.x&lt;&lt;" "&lt;&lt;in.y&lt;&lt;endl; &#125; cout&lt;&lt;"END OF OUTPUT"&lt;&lt;endl;&#125; 收获与反思 第一次接触计算几何，模板积累。]]></content>
      <categories>
        <category>编程</category>
        <category>ACM</category>
      </categories>
      <tags>
        <tag>算法</tag>
        <tag>ACM</tag>
        <tag>2018暑假集训</tag>
        <tag>计算几何</tag>
        <tag>POJ</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[【POJ-1066】解题报告（计算几何，线段交点）]]></title>
    <url>%2F2018%2F07%2F31%2F%E3%80%90POJ-1066%E3%80%91%E8%A7%A3%E9%A2%98%E6%8A%A5%E5%91%8A%EF%BC%88%E8%AE%A1%E7%AE%97%E5%87%A0%E4%BD%95%EF%BC%8C%E7%BA%BF%E6%AE%B5%E4%BA%A4%E7%82%B9%EF%BC%89%2F</url>
    <content type="text"><![CDATA[原始题目Treasure Hunt Time Limit: 1000MS Memory Limit: 10000K Total Submissions: 7927 Accepted: 3269 DescriptionArcheologists from the Antiquities and Curios Museum (ACM) have flown to Egypt to examine the great pyramid of Key-Ops. Using state-of-the-art technology they are able to determine that the lower floor of the pyramid is constructed from a series of straightline walls, which intersect to form numerous enclosed chambers. Currently, no doors exist to allow access to any chamber. This state-of-the-art technology has also pinpointed the location of the treasure room. What these dedicated (and greedy) archeologists want to do is blast doors through the walls to get to the treasure room. However, to minimize the damage to the artwork in the intervening chambers (and stay under their government grant for dynamite) they want to blast through the minimum number of doors. For structural integrity purposes, doors should only be blasted at the midpoint of the wall of the room being entered. You are to write a program which determines this minimum number of doors. An example is shown below: InputThe input will consist of one case. The first line will be an integer n (0 ≤ n ≤ 30) specifying number of interior walls, followed by n lines containing integer endpoints of each wall x1 y1 x2 y2 . The 4 enclosing walls of the pyramid have fixed endpoints at (0,0); (0,100); (100,100) and (100,0) and are not included in the list of walls. The interior walls always span from one exterior wall to another exterior wall and are arranged such that no more than two walls intersect at any point. You may assume that no two given walls coincide. After the listing of the interior walls there will be one final line containing the floating point coordinates of the treasure in the treasure room (guaranteed not to lie on a wall). OutputPrint a single line listing the minimum number of doors which need to be created, in the format shown below. Sample Input7 20 0 37 100 40 0 76 100 85 0 0 75 100 90 0 90 0 71 100 61 0 14 100 38 100 47 47 100 54.5 55.4 Sample OutputNumber of doors = 2 SourceEast Central North America 1999 题目大意在一个100*100的正方形区域中，有n条两端点均在正方形边界的墙将区域分成许多个部分（房间），已知可以破坏每个区域房间墙壁的中点，区域中某个点是宝藏，问从外界到宝藏处最少需要破坏多少个墙壁。 解题思路 由于破坏墙中点后就可以移动到左右端点，故实际上破坏位置在不在中点没有区别。 不可能绕开墙壁，所以走直线最近，每个墙壁最多只会遭遇一次。 所以等价从边界上每个墙壁的端点到宝藏位置连一条线段，和其他线段的交点（严格相交）+1就是所求答案。 利用计算几何中的判断线段是否相交的函数。 解题代码123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147148149150151152153154155156157158159160161162163164165166167168169170171172//计算几何模板，二维几何基础//使用印用注意避免直接在程序中调用构造函数构造无名对象。否则可能会导致程序出错 //#include &lt;bits/stdc++.h&gt;#include &lt;cstdio&gt;#include &lt;cmath&gt;#include &lt;cstdlib&gt;#include &lt;cstring&gt;#include &lt;iostream&gt;#include &lt;set&gt;#include &lt;iomanip&gt;#include &lt;algorithm&gt;#include &lt;queue&gt;#include &lt;map&gt;#include &lt;string&gt;#define INF 0x3f3f3f3f#define rep(i,a,n) for(int i=a;i&lt;n;i++)#define per(i,a,n) for(int i=n-1;i&gt;=a;i--)using namespace std;typedef long long ll;const double eps =1e-10;const int maxn=50;int n;//有的命名为sgn函数，高精度符号判断 int dcmp(double x)&#123; //相等函数判断，减少精度问题 if(fabs(x)&lt;eps) return 0; else return x&lt;0?-1:1;&#125;//点的定义 class Point&#123; public: double x,y; Point (double x=0,double y=0):x(x),y(y)&#123;&#125; //构造函数，方便代码的编写 &#125;point[maxn]; typedef Point Vector;// 从程序实现上，Vector只是Point的别名//运算符重载 Vector operator + (const Vector &amp;A,const Vector &amp;B) &#123; return Vector(A.x+B.x,A.y+B.y); &#125; //向量+向量=向量，点+向量=点Vector operator - (const Vector &amp;A,const Vector &amp;B) &#123; return Vector(A.x-B.x,A.y-B.y); &#125; //向量-向量=向量，点-向量-点 Vector operator * (const Vector &amp;A,double p) &#123; return Vector(A.x*p,A.y*p); &#125; //向量*数=向量 （数乘） Vector operator / (const Vector &amp;A,double p) &#123; return Vector(A.x/p,A.y/p); &#125; //向量/数=向量 （数除）double operator * (const Vector &amp;A,const Vector &amp;B) &#123; return A.x*B.x+A.y*B.y; &#125; //向量（点乘）向量=数 （点乘）bool operator &lt; (const Point &amp;A,const Point &amp;B) &#123; return A.x==B.x?A.y&lt;B.y:A.x&lt;B.x; &#125; //按x值递增排序 bool operator == (const Point &amp;A,const Point &amp;B) &#123; return dcmp(A.x-B.x)==0&amp;&amp; dcmp(A.y-B.y)==0; &#125; //判定两个点是否相同，用到dcmp精度判定 //点乘叉乘 double dot(const Vector &amp;A,const Vector &amp;B)&#123; return A.x*B.x+A.y*B.y; &#125; //向量（叉乘）向量=向量 （叉乘） double operator ^ (const Vector &amp;A,const Vector &amp;B)&#123; return A.x*B.y-A.y*B.x; &#125;double cross(const Vector &amp;A,const Vector &amp;B)&#123; return A.x*B.y-A.y*B.x; &#125;//模长面积 double abs(const Vector &amp;A)&#123; return sqrt(dot(A,A));&#125; //计算向量模长 double area2(const Point &amp;A,const Point &amp;B,const Point &amp;C)&#123; return cross(B-A,C-A) ;&#125; //计算平行四边形方向面积double PolygonArea(Point *p,int n) &#123; double area=0; rep(i,1,n-1)&#123;area+=cross(p[i]-p[0],p[i+1]-p[0]);&#125;return area/2.0; &#125; //计算多边形的有向面积//旋转Vector rotate(Vector A,double rad) &#123; return Vector(A.x*cos(rad)-A.y*sin(rad),A.x*sin(rad)+A.y*cos(rad));&#125; //旋转rad弧度 Vector normal(Vector A)&#123;double l=abs(A);return Vector(-A.y/l,A.x/l);&#125; //计算单位法线，左转90//线段定义 class Line &#123; public: Point s,e; Line()&#123;&#125; Line(Point _s,Point _e)&#123; s=_s;e=_e; &#125; &#125;line[maxn];//判断两线段是否相交 bool inter(Line l1,Line l2)&#123;// cout&lt;&lt;"L1 "&lt;&lt;l1.e.x&lt;&lt;","&lt;&lt;l1.e.y&lt;&lt;" "&lt;&lt;l1.s.x&lt;&lt;","&lt;&lt;l1.s.y&lt;&lt;endl;// cout&lt;&lt;"L2 "&lt;&lt;l2.e.x&lt;&lt;","&lt;&lt;l2.e.y&lt;&lt;" "&lt;&lt;l2.s.x&lt;&lt;","&lt;&lt;l2.s.y&lt;&lt;endl; return ( //根据题目要求端点相交是否算作相交来决定大于等于和小于等于 //排斥实验 max(l1.s.x,l1.e.x)&gt;=min(l2.s.x,l2.e.x) &amp;&amp; max(l2.s.x,l2.e.x)&gt;=min(l1.s.x,l1.e.x) &amp;&amp; max(l1.s.y,l1.e.y)&gt;=min(l2.s.y,l2.e.y) &amp;&amp; max(l2.s.y,l2.e.y)&gt;=min(l1.s.y,l1.e.y) &amp;&amp; //跨立实验 dcmp((l2.s-l1.s)^(l1.s-l1.e))*dcmp((l2.e-l1.s)^(l1.s-l1.e))&lt;0 &amp;&amp; dcmp((l1.s-l2.s)^(l2.s-l2.e))*dcmp((l1.e-l2.s)^(l2.s-l2.e))&lt;0 ) ;&#125;bool inter(Point a1,Point a2,Point b1,Point b2)&#123; Line l1(a1,a2),l2(b1,b2); return inter(l1,l2);&#125;bool cmp(Point a,Point b)&#123; if(a.x==b.x) return a.y&lt;b.y; else return a.x&lt;b.x;&#125;//求两直线交点Point getinter(Line l1,Line l2)&#123;Vector v=l1.s-l1.e;Vector w=l2.s-l2.e;Vector u=l1.e-l2.e;double t=cross(w,u)/cross(v,w);return l1.e+v*t;&#125; Point getinter(Point a1,Point a2,Point b1,Point b2)&#123;Line l1(a1,a2);Line l2(b1,b2);return getinter(l1,l2);&#125;//判定点和线段的关系，//0:不在线段所在直线上//1:在线段内（不含端点） //2:在线段端点//3:在线段两侧的射线上 int online(Point a,Line l)&#123; if(dcmp(cross(l.s-a,l.e-a))!=0) return 0; double pans=dcmp(dot(l.s-a,l.e-a));// cout&lt;&lt;(l.s-a).x&lt;&lt;","&lt;&lt;(l.s-a).y&lt;&lt;" "&lt;&lt;(l.e-a).x&lt;&lt;","&lt;&lt;(l.e-a).y&lt;&lt;endl; if(pans&lt;0) return 1; else if(pans==0) return 2; else if(pans&gt;0) return 3;&#125;int online(Point a,Point b1,Point b2)&#123; Line l(b1,b2); return online(a,l);&#125;//凸包int ConvexHull(Point *p,int n,Point *ch)&#123; sort(p,p+n,cmp); int m=0; for(int i=0;i&lt;n;i++)&#123; while(m&gt;1 &amp;&amp; cross(ch[m-1]-ch[m-2],p[i]-ch[m-2])&lt;=0) m--; ch[m++]=p[i]; &#125; int k=m; for(int i=n-2;i&gt;=0;i--)&#123; while(m&gt;k &amp;&amp; cross(ch[m-1]-ch[m-2],p[i]-ch[m-2])&lt;=0) m--; ch[m++]=p[i]; &#125; if(n&gt;1) m--; return m;&#125; int main()&#123; cin&gt;&gt;n; rep(i,0,n)&#123; cin&gt;&gt;line[i].e.x&gt;&gt;line[i].e.y&gt;&gt;line[i].s.x&gt;&gt;line[i].s.y; &#125; cin&gt;&gt;point[0].x&gt;&gt;point[0].y; if(n==0) cout&lt;&lt;"Number of doors = 1"&lt;&lt;endl; else&#123; int ans=INF; rep(i,0,n)&#123; int cnt=0; Point pn=line[i].e; Line ln(point[0],pn); rep(j,0,n)&#123; if(inter(ln,line[j])) cnt++; &#125;// cout&lt;&lt;"p1 "&lt;&lt;cnt&lt;&lt;endl; ans=min(ans,cnt); cnt=0; pn=line[i].s; ln.s=point[0];ln.e=pn; rep(j,0,n)&#123; if(inter(ln,line[j])) cnt++; &#125; ans=min(ans,cnt);// cout&lt;&lt;"p2 "&lt;&lt;cnt&lt;&lt;endl; &#125; cout&lt;&lt;"Number of doors = "&lt;&lt;ans+1&lt;&lt;endl; &#125; &#125; 收获与反思 第一次接触计算几何，模板积累。]]></content>
      <categories>
        <category>编程</category>
        <category>ACM</category>
      </categories>
      <tags>
        <tag>算法</tag>
        <tag>ACM</tag>
        <tag>2018暑假集训</tag>
        <tag>计算几何</tag>
        <tag>POJ</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[【HDU-6322】解题报告（数论，2018杭电多校第三场）]]></title>
    <url>%2F2018%2F07%2F31%2F%E3%80%90HDU-6322%E3%80%91%E8%A7%A3%E9%A2%98%E6%8A%A5%E5%91%8A%EF%BC%88%E6%95%B0%E8%AE%BA%EF%BC%8C2018%E6%9D%AD%E7%94%B5%E5%A4%9A%E6%A0%A1%E7%AC%AC%E4%B8%89%E5%9C%BA%EF%BC%89%2F</url>
    <content type="text"><![CDATA[原始题目Problem D. Euler Function Time Limit: 2000/1000 MS (Java/Others) Memory Limit: 524288/524288 K (Java/Others) Total Submission(s): 150 Accepted Submission(s): 136 Problem DescriptionIn number theory, Euler’s totient function $\varphi(n)$ counts the positive integers up to a given integer $n$ that are relatively prime to $n$. It can be defined more formally as the number of integers $k$ in the range $1\leq k\leq n$ for which the greatest common divisor $\gcd(n, k)$ is equal to $1$. For example, $\varphi(9) = 6$ because $1,2,4,5,7$ and $8$ are coprime with $9$. As another example, $\varphi(1) = 1$ since for $n = 1$ the only integer in the range from $1$ to $n$ is 1 itself, and $\gcd(1, 1) = 1$ . A composite number is a positive integer that can be formed by multiplying together two smaller positive integers. Equivalently, it is a positive integer that has at least one divisor other than $1$ and itself. So obviously $1$ and all prime numbers are not composite number. In this problem, given integer $k$, your task is to find the $k$-th smallest positive integer n, that $\varphi(n)$ is a composite number. InputThe first line of the input contains an integer $T(1\leq T\leq100000)$, denoting the number of test cases.In each test case, there is only one integer $k(1\leq k\leq 10^9)$. OutputFor each test case, print a single line containing an integer, denoting the answer. Sample Input2 1 2 Sample Output5 7 Source2018 Multi-University Training Contest 3 Recommendchendu 题目大意求第k个正整数n，其欧拉函数$\varphi(n)$为合数。 解题思路 数论题 手写一下，发现数稍微大便全是合数。反向考虑$\varphi(n)$为质数。 已知$\varphi(n) = p_1^{k_1-1}(p_1-1)p_2^{k_2-1}(p_2-1)\cdots$，其中$\gcd(p_1, p_2 \cdots)=1$。分情况讨论： 情况1：$n$为$p^k$形式，即只有一个质因子。 子情况1.1：该质因子为$2$，那么要使$\varphi(n)$为质数，则$p^{k-1}$为质数，很明显$k=1,2$，所以该情况下$n$只能为$2,4$ 子情况1.2：该质因数不为$2$，那么要使$\varphi(n)$为质数，$p-1$也得为质数，很明显成立的只有$3$（相邻两个数均为质数） 情况2：$n$由两个质因子构成。 子情况1.1：其中一个为$2$，由于另一个会贡献一个$2$，要使$\varphi(n)$为质数,则$2$质因数指数只能为$1$，另一质因数只能为$3$，指数只能为$1$。 子情况2.2：均不为$2$，那么两个质因子各贡献一个$2$，那么$\varphi(n)$一定为4的倍数，不为质数。 当$n=1,2,3,4,6$时，$\varphi(n)$为质数。 解题代码12345678910111213141516#include&lt;bits/stdc++.h&gt;using namespace std;int main()&#123; int T; long long k; cin&gt;&gt;T; while(T--) &#123; cin&gt;&gt;k; if(k==1) cout&lt;&lt;5&lt;&lt;endl; else cout&lt;&lt;k+5&lt;&lt;endl; &#125; return 0;&#125; 收获与反思 数论先推前几项再分析 掌握欧拉函数的计算方法和性质。]]></content>
      <categories>
        <category>编程</category>
        <category>ACM</category>
      </categories>
      <tags>
        <tag>算法</tag>
        <tag>ACM</tag>
        <tag>2018暑假集训</tag>
        <tag>数论</tag>
        <tag>HDU</tag>
        <tag>2018杭电多校</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[【CSU-2059】解题报告（递推，几何）]]></title>
    <url>%2F2018%2F07%2F30%2F%E3%80%90CSU-2059%E3%80%91%E8%A7%A3%E9%A2%98%E6%8A%A5%E5%91%8A%EF%BC%88%E9%80%92%E6%8E%A8%EF%BC%8C%E5%87%A0%E4%BD%95%EF%BC%89%2F</url>
    <content type="text"><![CDATA[HDU-2050变式拓展 原始题目2059: Water Problem Time Limit: 1 Sec Memory Limit: 128 Mb Submitted: 576 Solved: 199 Description​ 一条‘Z’形线可以将平面分为两个区域，那么由N条Z形线所定义的区域的最大个数是多少呢？每条Z形线由两条平行的无限半直线和一条直线段组成 Input首先输入一个数字T（T&lt;100），代表有T次询问 每次询问输入一个数字N（N&lt;1e8），代表有N条Z形线 Output对于每次询问，在一行输出N条‘Z’形线所能划分的区域的最大个数为多少 Sample Input2 1 2 Sample Output2 12 Hint SourceAuthorcsutsz 题目大意如题 解题思路 先推导递推式，由于数据量大，再推导通项公式最后直接输出。 分析：第i条z形线比第i-1条z形线新分成的最多区域数为新增最多交点个数+1 第i条线最多与前i-1条z形线交 $4*(i-1)$ 个点。dp[i]=dp[i-1]+4\*(i-1)+! , dp[1]=2 所以得到通项公式dp[i]=\frac{9\*(i-1)\*(i)}{2}+i+1 解题代码123456789101112131415161718192021222324252627#include &lt;cstdio&gt;#include &lt;cstring&gt;#include &lt;iostream&gt;#include &lt;set&gt;#include &lt;algorithm&gt;#include &lt;queue&gt;#include &lt;map&gt;#include &lt;string&gt;#define eps 1e-8#define INF 0x3f3f3f3f#define rep(i,a,n) for(int i=a;i&lt;n;i++)#define per(i,a,n) for(int i=n-1;i&gt;=a;i--)using namespace std;const int maxn=1e8+2;typedef long long ll;using namespace std;int main()&#123; int t; cin&gt;&gt;t; for(ll i=0;i&lt;t;i++)&#123; ll a; cin&gt;&gt;a; if(a==1) cout&lt;&lt;2&lt;&lt;endl; else cout&lt;&lt;9*(a-1)*(a)/2+a+1&lt;&lt;endl; &#125;&#125; 收获与反思 折线，z形线，类似的都转化到与新增交点数的关系。]]></content>
      <categories>
        <category>编程</category>
        <category>ACM</category>
      </categories>
      <tags>
        <tag>ACM</tag>
        <tag>CSU</tag>
        <tag>2018暑假集训</tag>
        <tag>递推</tag>
        <tag>几何</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[【ZOJ-1633】解题报告（字符串递推，二分查找）]]></title>
    <url>%2F2018%2F07%2F29%2F%E3%80%90ZOJ-1633%E3%80%91%E8%A7%A3%E9%A2%98%E6%8A%A5%E5%91%8A%EF%BC%88%E5%AD%97%E7%AC%A6%E4%B8%B2%E9%80%92%E6%8E%A8%EF%BC%8C%E4%BA%8C%E5%88%86%E6%9F%A5%E6%89%BE%EF%BC%89%2F</url>
    <content type="text"><![CDATA[原始题目Big String Time Limit: 2 Seconds Memory Limit: 65536 KB We will construct an infinitely long string from two short strings: A = “^__^” (four characters), and B = “T.T” (three characters). Repeat the following steps: Concatenate A after B to obtain a new string C. For example, if A = “^__^” and B = “T.T”, then C = BA = “T.T^__^”. Let A = B, B = C — as the example above A = “T.T”, B = “T.T^__^”. Your task is to find out the n-th character of this infinite string. InputThe input contains multiple test cases, each contains only one integer $N (1 \le N \le 2^{63} - 1)$. Proceed to the end of file. OutputFor each test case, print one character on each line, which is the N-th (index begins with 1) character of this infinite string. Sample Input1 2 4 8 Sample OutputT . ^ T Author:CHENG, Long Source:Zhejiang University Local Contest 2003 题目大意由A=”^__^” ， B=”T.T” ， C=BA=”T.T^__^” ，再令C=B, B=A，重复这种操作，问如此构成的字符串第n个字符是什么。 解题思路 $dp[i]$ 表示第i个字符串由多少个字符构成，已知$dp[0]=4,dp[1]=3,dp[2]=7$，根据递推规则可知$dp[i+1]=dp[i]+dp[i-1]$ 折半查找第一个比n大的dp[i]，则第i串里的第n位与第i-1串里的第n-dp[i-1]（可以保证这一项大于零）位对应字符相同。递归操作直至n&lt;7。从”T.T^__^”寻找就可以了 解题代码123456789101112131415161718192021222324252627282930313233343536#include &lt;cstdio&gt;#include &lt;cstring&gt;#include &lt;iostream&gt;#include &lt;set&gt;#include &lt;algorithm&gt;#include &lt;queue&gt;#include &lt;map&gt;#include &lt;string&gt;#define eps 1e-8#define INF 0x3f3f3f3f#define rep(i,a,n) for(int i=a;i&lt;n;i++)#define per(i,a,n) for(int i=n-1;i&gt;=a;i--)using namespace std;using namespace std;typedef long long ll;ll a[95]; //保存字符串的长度int main()&#123; string C = "T.T^__^"; a[0] = 4; a[1] = 3; int i; for(i = 2; i &lt; 90; i++) a[i] = a[i-1] + a[i-2]; ll n; while(cin &gt;&gt; n) &#123; while(n &gt; 7) &#123; int pos = lower_bound(a, a+89, n) - a; n -= a[pos-1]; &#125; cout &lt;&lt; C[n-1] &lt;&lt; endl; &#125; return 0;&#125; 收获与反思 二分查找与递推的结合]]></content>
      <categories>
        <category>编程</category>
        <category>ACM</category>
      </categories>
      <tags>
        <tag>算法</tag>
        <tag>ACM</tag>
        <tag>2018暑假集训</tag>
        <tag>递推</tag>
        <tag>ZOJ</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[【CSU-1587】解题报告（递推，水题）]]></title>
    <url>%2F2018%2F07%2F29%2F%E3%80%90CSU-1587%E3%80%91%E8%A7%A3%E9%A2%98%E6%8A%A5%E5%91%8A%EF%BC%88%E9%80%92%E6%8E%A8%EF%BC%8C%E6%B0%B4%E9%A2%98%EF%BC%89%2F</url>
    <content type="text"><![CDATA[原始题目1587: 爬楼梯 Time Limit: 1 Sec Memory Limit: 128 Mb Submitted: 867 Solved: 514 Description小时候我们都玩过爬楼梯的游戏：两人猜拳，赢了可向上爬一级，谁先到最高级则获胜。作为大学生，我们应该玩一个更有水平的游戏。现在一个人要上n级楼梯，每一步可以选择上一级或者上两级，但是不能后退。求上这n级楼梯的方案数。 Input第一行只有一个整数$T(1 \le T \le 45)$，表示数据组数。下面的T行每一行有一个整数$ n ( 1 \le n \le 45)$ ，表示有多少级楼梯。 Output对于每一组数据输出一个整数s，表示方案数。 Sample Input4 1 2 3 4 Sample Output1 2 3 5 HintSource国防科学技术大学第十八届银河之光文化节ACM程序设计竞赛初赛 题目大意如题 解题思路 到第i级阶梯可由第i-1级阶梯爬一级或由第i-2级解题爬两层。 解题代码12345678910111213141516171819202122232425262728293031323334353637#include &lt;cstdio&gt;#include &lt;cstring&gt;#include &lt;iostream&gt;#include &lt;set&gt;#include &lt;algorithm&gt;#include &lt;queue&gt;#include &lt;map&gt;#include &lt;string&gt;#define eps 1e-8#define INF 0x3f3f3f3f#define rep(i,a,n) for(int i=a;i&lt;n;i++)#define per(i,a,n) for(int i=n-1;i&gt;=a;i--)using namespace std;const int maxn=1e5+5;typedef long long ll;ll dp[maxn];void solve()&#123; memset(dp,0,sizeof(dp)); dp[1]=1; dp[2]=2; rep(i,3,50)&#123; dp[i]=dp[i-1]+dp[i-2]; &#125; &#125;using namespace std;int main()&#123; int t; solve(); while(cin&gt;&gt;t)&#123; rep(i,0,t)&#123; ll a; cin&gt;&gt;a; cout&lt;&lt;dp[a]&lt;&lt;endl; &#125; &#125;&#125; 收获与反思暂无，水题]]></content>
      <categories>
        <category>编程</category>
        <category>ACM</category>
      </categories>
      <tags>
        <tag>算法</tag>
        <tag>ACM</tag>
        <tag>CSU</tag>
        <tag>2018暑假集训</tag>
        <tag>递推</tag>
        <tag>水题</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[【UVA-12034】解题报告（递推，DP）]]></title>
    <url>%2F2018%2F07%2F28%2F%E3%80%90UVA-12034%E3%80%91%E8%A7%A3%E9%A2%98%E6%8A%A5%E5%91%8A%EF%BC%88%E9%80%92%E6%8E%A8%EF%BC%8CDP%EF%BC%89%2F</url>
    <content type="text"><![CDATA[原始题目12034 - Race Time limit: 1.000 seconds Disky and Sooma, two of the biggest mega minds of Bangladesh went to a far country. They ate, codedand wandered around, even in their holidays. They passed several months in this way. But everythinghas an end. A holy person, Munsiji came into their life. Munsiji took them to derby (horse racing).Munsiji enjoyed the race, but as usual Disky and Sooma did their as usual task instead of passing someromantic moments. They were thinking- in how many ways a race can finish! Who knows, maybe thisis their romance! In a race there are n horses. You have to output the number of ways the race can finish. Note that,more than one horse may get the same position. For example, 2 horses can finish in 3 ways. Both first horse1 first and horse2 second horse2 first and horse1 second InputInput starts with an integer T (≤ 1000), denoting the number of test cases. Each case starts with aline containing an integer n (1 ≤ n ≤ 1000). OutputFor each case, print the case number and the number of ways the race can finish. The result can bevery large, print the result modulo 10056. Sample Input3 1 2 3 Sample OutputCase 1: 1 Case 2: 3 Case 3: 13 题目大意一场赛马比赛中由n匹马，任意两匹马可以同时到达或者一先一后到达，问一共有多少种到达的可能。 解题思路 考虑dp。 $dp[i][j]$表示i匹马用j次到达的可能情况数。 考虑第i匹马的情况，可能和前i-1匹马一同到达，或者单独到达（即第i匹马到达时有并列，无并列）。$dp[i][j]=j*(dp[i-1][j]+dp[i-1][j-1])$，乘j是因为第i匹马名次有j种可能。 解题代码12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849#include &lt;cstdio&gt;#include &lt;cstring&gt;#include &lt;iostream&gt;#include &lt;set&gt;#include &lt;algorithm&gt;#include &lt;queue&gt;#include &lt;map&gt;#include &lt;string&gt;#define eps 1e-8#define INF 0x3f3f3f3f#define rep(i,a,n) for(int i=a;i&lt;n;i++)#define per(i,a,n) for(int i=n-1;i&gt;=a;i--)using namespace std;const int maxn=1e8+2;const int mod=10056;typedef long long ll;ll dp[1005][1005];ll ans[1005];int main()&#123; int t; memset(dp,0,sizeof(dp)); memset(ans,0,sizeof(ans)); dp[1][1]=1; ans[1]=1; for(int i=2;i&lt;=1000;i++)&#123; int sum=0; for(int j=1;j&lt;=i;j++)&#123; if(j==1) dp[i][j]=1; else dp[i][j]=j*(dp[i-1][j]+dp[i-1][j-1])%mod; sum=(sum+dp[i][j])%mod;// cout&lt;&lt;"ans["&lt;&lt;i&lt;&lt;"]="&lt;&lt;ans[i]&lt;&lt;endl; &#125; ans[i]=sum;// cout&lt;&lt;i&lt;&lt;" "&lt;&lt;ans[i]&lt;&lt; " "&lt;&lt;ans[i-1]&lt;&lt;endl; &#125;// for(int i=2;i&lt;=1005;i++)&#123;// cout&lt;&lt;"i="&lt;&lt;i&lt;&lt;" "&lt;&lt;ans[i]&lt;&lt;endl; // &#125; cin&gt;&gt;t; int n,cas=1; while(t--) &#123; cin&gt;&gt;n; cout&lt;&lt;"Case "&lt;&lt;cas++&lt;&lt;": " &lt;&lt;ans[n]&lt;&lt;endl; &#125;&#125; 收获与反思注意取模的运算规则，考虑dp与最终答案的关系。]]></content>
      <categories>
        <category>编程</category>
        <category>ACM</category>
      </categories>
      <tags>
        <tag>算法</tag>
        <tag>ACM</tag>
        <tag>2018暑假集训</tag>
        <tag>递推</tag>
        <tag>UVA</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[【URAL-1081】解题报告（递推，斐波那契）]]></title>
    <url>%2F2018%2F07%2F28%2F%E3%80%90URAL-1081%E3%80%91%E8%A7%A3%E9%A2%98%E6%8A%A5%E5%91%8A%EF%BC%88%E9%80%92%E6%8E%A8%EF%BC%8C%E6%96%90%E6%B3%A2%E9%82%A3%E5%A5%91%EF%BC%89%2F</url>
    <content type="text"><![CDATA[题目大意1081. Binary Lexicographic Sequence Time limit: 0.5 second Memory limit: 64 MB Consider all the sequences with length (0 &lt; N &lt; 44), containing only the elements 0 and 1, and no two ones are adjacent (110 is not a valid sequence of length 3, 0101 is a valid sequence of length 4). Write a program which finds the sequence, which is on K-th place (0 &lt; K &lt; 109) in the lexicographically sorted in ascending order collection of the described sequences. InputThe first line of input contains two positive integers N and K. OutputWrite the found sequence or −1 if the number K is larger then the number of valid sequences. Sampleinput3 1 output000 Problem Author:Emil Kelevedzhiev Problem Source:Winter Mathematical Festival Varna ‘2001 Informatics Tournament 题目大意求词典序下第K个长度为N且无相邻位置都为1的0、1序列。无解时输出-1。 解题思路 先考虑长度为n的符合要求序列有多少个。 1（2个）:0 1 2（3个）:00 01 10 3（5个）:000 001 010 100 101 4（8个）:0000 0001 0010 0100 0101 1000 1001 1010 5（13个）:00000 00001 00010 00100 00101 01000 01001 01010 10000 10001 10010 10100 10101 发现规律，个数为斐波那契数列。构成原因：dp[k+1]的前dp[k]项为前面补0，后dp[k-1]项为前面补10 解题代码12345678910111213141516171819202122232425262728293031323334353637383940414243444546#include &lt;cstdio&gt;#include &lt;cstring&gt;#include &lt;iostream&gt;#include &lt;set&gt;#include &lt;algorithm&gt;#include &lt;queue&gt;#include &lt;map&gt;#include &lt;string&gt;#define eps 1e-8#define INF 0x3f3f3f3f#define rep(i,a,n) for(int i=a;i&lt;n;i++)#define per(i,a,n) for(int i=n-1;i&gt;=a;i--)using namespace std;typedef long long ll;const int maxn=1e5+5;ll n,k;ll dp[maxn];void solve()&#123; dp[0]=1; dp[1]=2; dp[2]=3; rep(i,3,50)&#123; dp[i]=dp[i-1]+dp[i-2]; &#125;&#125;int main()&#123; solve(); while(~scanf("%lld%lld",&amp;n,&amp;k))&#123; if(k&gt;dp[n])&#123; printf("-1\n"); &#125; else &#123; while(n) &#123; n--; if(k&lt;=dp[n])printf("0"); else &#123; printf("1"); k-=dp[n]; &#125; &#125; printf("\n"); &#125; &#125;&#125; 收获与反思 注意观察斐波那契数列]]></content>
      <categories>
        <category>编程</category>
        <category>ACM</category>
      </categories>
      <tags>
        <tag>算法</tag>
        <tag>ACM</tag>
        <tag>2018暑假集训</tag>
        <tag>递推</tag>
        <tag>URAL</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[【HDU-2018】解题报告（递推，水题）]]></title>
    <url>%2F2018%2F07%2F28%2F%E3%80%90HDU-2018%E3%80%91%E8%A7%A3%E9%A2%98%E6%8A%A5%E5%91%8A%EF%BC%88%E9%80%92%E6%8E%A8%EF%BC%8C%E6%B0%B4%E9%A2%98%EF%BC%89%2F</url>
    <content type="text"><![CDATA[原始题目母牛的故事 Time Limit: 2000/1000 MS (Java/Others) Memory Limit: 65536/32768 K (Java/Others) Total Submission(s): 105012 Accepted Submission(s): 51527 Problem Description有一头母牛，它每年年初生一头小母牛。每头小母牛从第四个年头开始，每年年初也生一头小母牛。请编程实现在第n年的时候，共有多少头母牛？ Input输入数据由多个测试实例组成，每个测试实例占一行，包括一个整数n(0&lt;n&lt;55)，n的含义如题目中描述。n=0表示输入数据的结束，不做处理。 Output对于每个测试实例，输出在第n年的时候母牛的数量。每个输出占一行。 Sample Input2 4 5 0 Sample Output2 4 6 Authorlcy SourceC语言程序设计练习（三） Recommendlcy 题目大意如题 解题思路 $b[i]$表示第i年的母牛数，$s[i]$表示第i年的小牛数。有$b[i]=b[i-1]+b[i-3]$;$s[i]=s[i-1]-b[i-3]+b[i]$; 即第i年的母牛等于i-1年的母牛数加上三年前母牛产的小牛数（今年长成母牛），第i年的小牛数等于第i-1年的小牛数减去三年前新产的小牛数（今年长成母牛）加上今年新产的小牛。 输出大小牛的和解题代码123456789101112131415161718192021222324252627282930313233343536#include &lt;cstdio&gt;#include &lt;cstring&gt;#include &lt;iostream&gt;#include &lt;set&gt;#include &lt;algorithm&gt;#include &lt;queue&gt;#include &lt;map&gt;#include &lt;string&gt;#define eps 1e-8#define INF 0x3f3f3f3f#define rep(i,a,n) for(int i=a;i&lt;n;i++)#define per(i,a,n) for(int i=n-1;i&gt;=a;i--)using namespace std;const int maxn=1e8+2;typedef long long ll;int b[100],s[100];void solve()&#123; b[1]=b[2]=b[3]=b[4]=1; s[1]=0; s[2]=1; s[3]=2; s[4]=3; for(int i=5;i&lt;55;i++)&#123; b[i]=b[i-1]+b[i-3]; s[i]=s[i-1]-b[i-3]+b[i]; &#125; &#125;int n;int main()&#123; solve(); while(cin&gt;&gt;n&amp;&amp;n)&#123; cout&lt;&lt;b[n]+s[n]&lt;&lt;endl; &#125;&#125; 收获与反思暂无]]></content>
      <categories>
        <category>编程</category>
        <category>ACM</category>
      </categories>
      <tags>
        <tag>算法</tag>
        <tag>ACM</tag>
        <tag>2018暑假集训</tag>
        <tag>递推</tag>
        <tag>水题</tag>
        <tag>HDU</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[【POJ-1664】解题报告（递推，dp）]]></title>
    <url>%2F2018%2F07%2F28%2F%E3%80%90POJ-1664%E3%80%91%E8%A7%A3%E9%A2%98%E6%8A%A5%E5%91%8A%EF%BC%88%E9%80%92%E6%8E%A8%EF%BC%8Cdp%EF%BC%89%2F</url>
    <content type="text"><![CDATA[原始题目放苹果 Time Limit: 1000MS Memory Limit: 10000K Total Submissions: 37069 Accepted: 22825 Description把M个同样的苹果放在N个同样的盘子里，允许有的盘子空着不放，问共有多少种不同的分法？（用K表示）5，1，1和1，5，1 是同一种分法。 Input第一行是测试数据的数目$ t(0 \le t \le 20)$。以下每行均包含二个整数M和N，以空格分开。 $ 1 \le M , N \le 10 $。 Output对输入的每组数据M和N，用一行输出相应的K。 Sample Input1 7 3 Sample Output8 Sourcelwx@POJ 题目大意如题 解题思路 $dp[i][j]$ 表示i个苹果j个盘子的分法。 状态转移： 当$i&lt;j$时，$dp[i][j]=dp[i][i]$ （不区分盘子，所以盘子多余的情况数和盘子恰好和苹果数相等的情况数相等） 当$i\geqslantj$，$dp[i][j]=dp[i-j][j]+dp[i][j-1]$ （每个盘子都有苹果和有一个盘子没有苹果两种状况转移）注意初始的情况就好。解题代码1234567891011121314151617181920212223242526272829303132333435363738394041424344454647#include &lt;cstdio&gt;#include &lt;cstring&gt;#include &lt;iostream&gt;#include &lt;set&gt;#include &lt;algorithm&gt;#include &lt;queue&gt;#include &lt;map&gt;#include &lt;string&gt;#define eps 1e-8#define INF 0x3f3f3f3f#define rep(i,a,n) for(int i=a;i&lt;n;i++)#define per(i,a,n) for(int i=n-1;i&gt;=a;i--)using namespace std;const int maxn=1e8+2;typedef long long ll;ll dp[22][22];void solve()&#123; memset(dp,0,sizeof(dp)); dp[0][0]=1; for(int i=0;i&lt;=21;i++)&#123; for(int j=0;j&lt;=21;j++)&#123; if(i==0) dp[i][j]=1; else if(j==0) dp[i][j]=0; else if(j==1) dp[i][j]=1; else &#123; if(i&lt;j) dp[i][j]=dp[i][i]; else dp[i][j]=dp[i][j-1]+dp[i-j][j]; &#125; &#125; &#125;&#125;int main()&#123; int t; solve(); while(cin&gt;&gt;t)&#123; int m,n; rep(i,0,t)&#123; cin&gt;&gt;m&gt;&gt;n; cout&lt;&lt;dp[m][n]&lt;&lt;endl; &#125; &#125;&#125; 收获与反思注意边界情况的考量]]></content>
      <categories>
        <category>编程</category>
        <category>ACM</category>
      </categories>
      <tags>
        <tag>算法</tag>
        <tag>ACM</tag>
        <tag>2018暑假集训</tag>
        <tag>递推</tag>
        <tag>dp</tag>
        <tag>POJ</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[【HDU-2050】解题报告（递推，几何）]]></title>
    <url>%2F2018%2F07%2F28%2F%E3%80%90HDU-2050%E3%80%91%E8%A7%A3%E9%A2%98%E6%8A%A5%E5%91%8A%EF%BC%88%E9%80%92%E6%8E%A8%EF%BC%8C%E8%AE%A1%E7%AE%97%E5%87%A0%E4%BD%95%EF%BC%89%2F</url>
    <content type="text"><![CDATA[原始题目折线分割平面 Time Limit: 2000/1000 MS (Java/Others) Memory Limit: 65536/32768 K (Java/Others) Total Submission(s): 37773 Accepted Submission(s): 25282 Problem Description我们看到过很多直线分割平面的题目，今天的这个题目稍微有些变化，我们要求的是n条折线分割平面的最大数目。比如，一条折线可以将平面分成两部分，两条折线最多可以将平面分成7部分，具体如下所示。 Input输入数据的第一行是一个整数$C$,表示测试实例的个数，然后是$C$ 行数据，每行包含一个整数$n ( 0 &lt; n \le 10000)$,表示折线的数量。 Output对于每个测试实例，请输出平面的最大分割数，每个实例的输出占一行。 Sample Input2 1 2 Sample Output2 7 Authorlcy Source递推求解专题练习（For Beginner） Recommendlcy 题目大意如题 解题思路折线类题目思路： dp[i]=dp[i-1]+新增交点数+1 题目数据过大则先手算通项公式。数据小可以直接递推 解题代码 递推写法 12345678910111213141516171819202122232425262728293031323334353637#include &lt;cstdio&gt;#include &lt;cstring&gt;#include &lt;iostream&gt;#include &lt;set&gt;#include &lt;algorithm&gt;#include &lt;queue&gt;#include &lt;map&gt;#include &lt;string&gt;#define eps 1e-8#define INF 0x3f3f3f3f#define rep(i,a,n) for(int i=a;i&lt;n;i++)#define per(i,a,n) for(int i=n-1;i&gt;=a;i--)using namespace std;const int maxn=1e5+5;typedef long long ll;ll dp[maxn];void solve()&#123; memset(dp,0,sizeof(dp)); dp[1]=1; dp[2]=2; rep(i,3,50)&#123; dp[i]=dp[i-1]+dp[i-2]; &#125; &#125;using namespace std;int main()&#123; int t; solve(); while(cin&gt;&gt;t)&#123; rep(i,0,t)&#123; ll a; cin&gt;&gt;a; cout&lt;&lt;dp[a]&lt;&lt;endl; &#125; &#125;&#125; 通项写法 123456789101112131415161718192021222324252627282930#include &lt;cstdio&gt;#include &lt;cstring&gt;#include &lt;iostream&gt;#include &lt;set&gt;#include &lt;algorithm&gt;#include &lt;queue&gt;#include &lt;map&gt;#include &lt;string&gt;#define eps 1e-8#define INF 0x3f3f3f3f#define rep(i,a,n) for(int i=a;i&lt;n;i++)#define per(i,a,n) for(int i=n-1;i&gt;=a;i--)using namespace std;const int maxn=1e5+5;typedef long long ll;using namespace std;int main()&#123; int t; while(cin&gt;&gt;t)&#123; rep(i,0,t)&#123; ll a; cin&gt;&gt;a;// cout&lt;&lt;dp[a]&lt;&lt;endl; cout&lt;&lt;(2*a+1)*(a-1)+2&lt;&lt;endl; &#125; &#125;&#125; 收获与反思 Z形线拓展]]></content>
      <categories>
        <category>编程</category>
        <category>ACM</category>
      </categories>
      <tags>
        <tag>算法</tag>
        <tag>ACM</tag>
        <tag>2018暑假集训</tag>
        <tag>递推</tag>
        <tag>几何</tag>
        <tag>HDU</tag>
        <tag>待补充</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[【HDU-2044】解题报告（递推，水题）]]></title>
    <url>%2F2018%2F07%2F28%2F%E3%80%90HDU-2044%E3%80%91%E8%A7%A3%E9%A2%98%E6%8A%A5%E5%91%8A%EF%BC%88%E9%80%92%E6%8E%A8%EF%BC%8C%E6%B0%B4%E9%A2%98%EF%BC%89%2F</url>
    <content type="text"><![CDATA[原始题目一只小蜜蜂… Time Limit: 2000/1000 MS (Java/Others) Memory Limit: 65536/32768 K (Java/Others) Total Submission(s): 93384 Accepted Submission(s): 33247 Problem Description有一只经过训练的蜜蜂只能爬向右侧相邻的蜂房，不能反向爬行。请编程计算蜜蜂从蜂房a爬到蜂房b的可能路线数。其中，蜂房的结构如下所示。 Input输入数据的第一行是一个整数N,表示测试实例的个数，然后是N 行数据，每行包含两个整数a和b(0&lt;a&lt;b&lt;50)。 Output对于每个测试实例，请输出蜜蜂从蜂房a爬到蜂房b的可能路线数，每个实例的输出占一行。 Sample Input2 1 2 3 6 Sample Output1 3 Authorlcy Source递推求解专题练习（For Beginner） Recommendlcy 题目大意如题 解题思路递推，dp初步，$dp[i]=dp[i-1]+dp[i-2]$ 解题代码1234567891011121314151617181920212223242526272829303132333435363738394041#include &lt;cstdio&gt;#include &lt;cstring&gt;#include &lt;iostream&gt;#include &lt;set&gt;#include &lt;algorithm&gt;#include &lt;queue&gt;#include &lt;map&gt;#include &lt;string&gt;#define eps 1e-8#define INF 0x3f3f3f3f#define rep(i,a,n) for(int i=a;i&lt;n;i++)#define per(i,a,n) for(int i=n-1;i&gt;=a;i--)using namespace std;const int maxn=1e5+5;typedef long long ll;ll dp[100][100];int main()&#123; ll t; memset(dp,0,sizeof(dp)); dp[0][0]=dp[1][1]=0; for(ll i=1;i&lt;=50-1;i++)&#123; for(ll j=1;j&lt;=50;j++)&#123; if(i==j)dp[i][j]=0; else if(j==i+1) dp[i][j]=1; else if(j==i+2) dp[i][j]=2; else dp[i][j]=dp[i][j-1]+dp[i][j-2];// cout&lt;&lt;i&lt;&lt;" "&lt;&lt;j&lt;&lt;endl; &#125; &#125; while(cin&gt;&gt;t)&#123; ll a,b; rep(i,0,t)&#123; cin&gt;&gt;a&gt;&gt;b; cout&lt;&lt;dp[a][b]&lt;&lt;endl; &#125; &#125;&#125; 收获与反思没啥]]></content>
      <categories>
        <category>编程</category>
        <category>ACM</category>
      </categories>
      <tags>
        <tag>算法</tag>
        <tag>ACM</tag>
        <tag>2018暑假集训</tag>
        <tag>递推</tag>
        <tag>水题</tag>
        <tag>HDU</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[【POJ-3111】解题报告（二分，牛顿迭代，最大化平均值）]]></title>
    <url>%2F2018%2F07%2F25%2F%E3%80%90POJ-3111%E3%80%91%E8%A7%A3%E9%A2%98%E6%8A%A5%E5%91%8A%EF%BC%88%E4%BA%8C%E5%88%86%EF%BC%8C%E7%89%9B%E9%A1%BF%E8%BF%AD%E4%BB%A3%EF%BC%8C%E6%9C%80%E5%A4%A7%E5%8C%96%E5%B9%B3%E5%9D%87%E5%80%BC%EF%BC%89%2F</url>
    <content type="text"><![CDATA[原始题目K Best Time Limit: 8000MS Memory Limit: 65536K Total Submissions: 13510 Accepted: 3466 Case Time Limit: 2000MS Special Judge DescriptionDemy has $n$ jewels. Each of her jewels has some value $v_i$ and weight $w_i$. Since her husband John got broke after recent financial crises, Demy has decided to sell some jewels. She has decided that she would keep k best jewels for herself. She decided to keep such jewels that their specific value is as large as possible. That is, denote the specific value of some set of jewels S = {i1, i2, …, ik} as Demy would like to select such k jewels that their specific value is maximal possible. Help her to do so. InputThe first line of the input file contains $n$ — the number of jewels Demy got, and $k$ — the number of jewels she would like to keep $(1 ≤ k ≤ n ≤ 100 000)$. The following $n$ lines contain two integer numbers each — $v_i$ and $w_i$ $(0 ≤ v_i ≤ 10^6, 1 ≤ w_i ≤ 10^6$, both the sum of all $v_i$ and the sum of all $w_i$ do not exceed $10^7$). OutputOutput $k$ numbers — the numbers of jewels Demy must keep. If there are several solutions, output any one. Sample Input3 2 1 1 1 2 1 3 Sample Output1 2 SourceNortheastern Europe 2005, Northern Subregion 题目大意给定 $n$ 个珍珠的价值和重量，要求取其中 $k$ 个并使这 $k$ 个珍珠的平均单位重量价值最大。 解题思路 对平均单位重量价值二分（二分答案），每一次更新每个珍珠 $r_i=v_i-k*w_i$ 即对平均单位重量价值的差值。 排序后取差值最大的3个珍珠，若差值之和大于零（说明平均单位重量价值还不够大），left=mid，否则right=mid。逐渐逼近答案 解题代码123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657#include &lt;cstdio&gt;#include &lt;cstring&gt;#include &lt;iostream&gt;#include &lt;set&gt;#include &lt;algorithm&gt;#include &lt;queue&gt;#include &lt;map&gt;#include &lt;string&gt;#define eps 1e-8#define INF 0x3f3f3f3f#define rep(i,a,n) for(int i=a;i&lt;n;i++)#define per(i,a,n) for(int i=n-1;i&gt;=a;i--)using namespace std;const int maxn=1e5+5;double l,r,mid;int n,k;struct jewl&#123; int id; double vi,wi,ri; &#125;jewls[maxn];bool cmp(jewl a,jewl b)&#123; return a.ri&gt;b.ri;&#125;int main()&#123; while(~scanf("%d%d",&amp;n,&amp;k))&#123; rep(i,1,n+1)&#123; scanf("%lf%lf",&amp;jewls[i].vi,&amp;jewls[i].wi); jewls[i].id=i; &#125; l=0;r=INF; //开始二分寻找答案 while(r-l&gt;eps)&#123; mid=(l+r)/2; rep(i,1,n+1)&#123; jewls[i].ri=jewls[i].vi-mid*jewls[i].wi; &#125; sort(jewls+1,jewls+n+1,cmp); //寻找最大的k个 double sum=0; rep(i,1,k+1)&#123; sum+=jewls[i].ri; &#125; if(sum&gt;=0) l=mid; else r=mid; &#125; rep(i,1,k+1)&#123; if(i==1) printf("%d",jewls[i].id); else printf(" %d",jewls[i].id); &#125; printf("\n"); &#125;&#125; 收获与反思 浮点数二分 最大化平均值经典题。]]></content>
      <categories>
        <category>编程</category>
        <category>ACM</category>
      </categories>
      <tags>
        <tag>算法</tag>
        <tag>ACM</tag>
        <tag>二分</tag>
        <tag>2018暑假集训</tag>
        <tag>POJ</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[【POJ-2785】解题报告（二分水题）]]></title>
    <url>%2F2018%2F07%2F25%2F%E3%80%90POJ-2785%E3%80%91%E8%A7%A3%E9%A2%98%E6%8A%A5%E5%91%8A%EF%BC%88%E4%BA%8C%E5%88%86%E6%B0%B4%E9%A2%98%EF%BC%89%2F</url>
    <content type="text"><![CDATA[原始题目4 Values whose Sum is 0 Time Limit: 15000MS Memory Limit: 228000K Total Submissions: 28507 Accepted: 8591 Case Time Limit: 5000MS DescriptionThe SUM problem can be formulated as follows: given four lists A, B, C, D of integer values, compute how many quadruplet (a, b, c, d ) ∈ A x B x C x D are such that a + b + c + d = 0 . In the following, we assume that all lists have the same size n . InputThe first line of the input file contains the size of the lists n (this value can be as large as 4000). We then have n lines containing four integer values (with absolute value as large as $2^{28}$ ) that belong respectively to A, B, C and D . OutputFor each input file, your program has to write the number quadruplets whose sum is zero. Sample Input6 -45 22 42 -16 -41 -27 56 30 -36 53 -37 77 -36 30 -75 -46 26 -38 -10 62 -32 -54 -6 45 Sample Output5 HintSample Explanation: Indeed, the sum of the five following quadruplets is zero: (-45, -27, 42, 30), (26, 30, -10, -46), (-32, 22, 56, -46),(-32, 30, -75, 77), (-32, -54, 56, 30). SourceSouthwestern Europe 2005 题目大意给定四个长度为n的数列，从每一个数列中抽取一个数，问和为零的共有多少种可能。 解题思路 预处理出前两个数列的和sum1与后两个数列的和sum2。 对sum1排序，二分查找sum2中每个元素的相反数，累加输出 注意不要用binary_search函数，而应该用upper_bound - lower_bound ，因为可能sum1数列中有多个元素值均为 -sum2[i] 。如果用binary_search 只能得到是否有，计数会少计。 解题代码12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849#include &lt;cstdio&gt;#include &lt;cstdlib&gt;#include &lt;iostream&gt;#include &lt;cstring&gt;#include &lt;algorithm&gt;#include &lt;stack&gt;#include &lt;vector&gt;#include &lt;set&gt;#include &lt;map&gt;using namespace std;#define rep(i,a,n) for (int i=a;i&lt;n;i++)#define per(i,a,n) for (int i=n-1;i&gt;=a;i--)//#define pb push_back//#define mp make_pair//#define np next_permutation//#define all(x) x.begin(),x.end()//#define fi first//#define se second//#define SZ(x) ((int)(x).size()) //typedef vector &lt;int&gt; vi;typedef long long ll;//typedef pair &lt;int,int&gt; pii;const int mod=1e9+7;const int maxn=4100;ll sum1[maxn*maxn],sum2[maxn*maxn];ll a[maxn],b[maxn],c[maxn],d[maxn];int main()&#123; int n; while(~scanf("%d",&amp;n))&#123; rep(i,0,n)&#123; scanf("%lld %lld %lld %lld",&amp;a[i],&amp;b[i],&amp;c[i],&amp;d[i]); &#125; rep(i,0,n)&#123; rep(j,0,n)&#123; sum1[i*n+j]=a[i]+b[j]; sum2[i*n+j]=c[i]+d[j]; &#125; &#125; sort(sum1,sum1+n*n); ll ans=0; rep(i,0,n*n)&#123; ans+=(upper_bound(sum1,sum1+n*n,-sum2[i])-lower_bound(sum1,sum1+n*n,-sum2[i])); &#125; printf("%lld\n",ans); &#125;&#125; 收获与反思 加深STL里三个函数应用和相互区别。]]></content>
      <categories>
        <category>编程</category>
        <category>ACM</category>
      </categories>
      <tags>
        <tag>算法</tag>
        <tag>ACM</tag>
        <tag>二分</tag>
        <tag>水题</tag>
        <tag>POJ</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[【CodeForces-348A】解题报告（直接或二分）]]></title>
    <url>%2F2018%2F07%2F25%2F%E3%80%90CodeForces-348A%E3%80%91%E8%A7%A3%E9%A2%98%E6%8A%A5%E5%91%8A%EF%BC%88%E7%9B%B4%E6%8E%A5%E6%88%96%E4%BA%8C%E5%88%86%EF%BC%89%2F</url>
    <content type="text"><![CDATA[原始题目A. Mafia time limit per test2 seconds memory limit per test256 megabytes input：standard input output：standard output One day n friends gathered together to play “Mafia”. During each round of the game some player must be the supervisor and other n - 1 people take part in the game. For each person we know in how many rounds he wants to be a player, not the supervisor: the i-th person wants to play ai rounds. What is the minimum number of rounds of the “Mafia” game they need to play to let each person play at least as many rounds as they want? InputThe first line contains integer $n (3 ≤ n ≤ 10^5)$. The second line contains $n$ space-separated integers $a_1, a_2 \cdots a_n (1 ≤ a_i ≤ 10^9)$ — the i-th number in the list is the number of rounds the i-th person wants to play. OutputIn a single line print a single integer — the minimum number of game rounds the friends need to let the i-th person play at least ai rounds. Please, do not use the %lld specifier to read or write 64-bit integers in С++. It is preferred to use the cin, cout streams or the %I64d specifier. Examplesinput3 3 2 2 output4 input4 2 2 2 2 output3 NoteYou don’t need to know the rules of “Mafia” to solve this problem. If you’re curious, it’s a game Russia got from the Soviet times: http://en.wikipedia.org/wiki/Mafia_(party_game). 题目大意$n$ 个人进行游戏，每局游戏需要1人监管，剩下 $n-1$ 人参与游戏，现在给出 $n$ 人每人想至少参与游戏的此数，求满足每个人要求的最少游戏盘数。 解题思路水题，可以直接解或者二分 解题代码1234567891011121314151617181920212223#include &lt;iostream&gt;#include &lt;cstdio&gt;#include &lt;cstdlib&gt;#include &lt;algorithm&gt;#include &lt;cstring&gt;#include &lt;cmath&gt;using namespace std;long long a[200010];int main()&#123; int n; long long sum=0,MAX=0; scanf("%d",&amp;n); for(int i=1;i&lt;=n;i++) &#123; scanf("%I64d",a+i); sum+=a[i]; MAX=max(a[i],MAX); &#125; long long ans; if(sum%(n-1)==0) ans=sum/(n-1); else ans=sum/(n-1)+1; ans=max(MAX,ans); printf("%I64d\n",ans);&#125; 收获与反思 二分做法，下界为数列最大值，上界为数列总和，做下面划分12if(mid*(n-1)&gt;=sum) ri=mid;else le=mid+1;]]></content>
      <categories>
        <category>编程</category>
        <category>ACM</category>
      </categories>
      <tags>
        <tag>算法</tag>
        <tag>ACM</tag>
        <tag>二分</tag>
        <tag>2018暑假集训</tag>
        <tag>水题</tag>
        <tag>CodeForces</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[【CodeForces-600B】解题报告（二分，stl二分函数应用）]]></title>
    <url>%2F2018%2F07%2F25%2F%E3%80%90CodeForces-600B%E3%80%91%E8%A7%A3%E9%A2%98%E6%8A%A5%E5%91%8A%EF%BC%88%E4%BA%8C%E5%88%86%EF%BC%8Cstl%E4%BA%8C%E5%88%86%E5%87%BD%E6%95%B0%E5%BA%94%E7%94%A8%EF%BC%89%2F</url>
    <content type="text"><![CDATA[原始题目B. Queries about less or equal elements time limit per test2 seconds memory limit per test256 megabytes input：standard input output：standard output You are given two arrays of integers $a$ and $b$. For each element of the second array $b_j$ you should find the number of elements in array $a$ that are less than or equal to the value $b_j$. InputThe first line contains two integers $n, m (1 ≤ n, m ≤ 2·10^5)$ — the sizes of arrays $a$ and $b$. The second line contains n integers — the elements of array $a ( - 10^9 ≤ ai ≤ 10^9)$. The third line contains m integers — the elements of array $b ( - 10^9 ≤ bj ≤ 10^9)$. OutputPrint m integers, separated by spaces: the j-th of which is equal to the number of such elements in array $a$ that are less than or equal to the value $b_j$. Examplesinput5 4 1 3 5 7 9 6 4 2 8 output3 2 1 4 input5 5 1 2 1 2 5 3 1 4 1 5 output4 2 4 2 5 题目大意给定$a,b$两个数列，对$b$中每一项$b_i$，求$a$中小于等于$b_i$的项的个数。 解题思路 排序后二分，由于寻找小于等于$b_i$的个数，使用stl里的upper_bound函数。 解题代码12345678910111213141516171819202122232425262728293031323334353637383940414243#include &lt;bits/stdc++.h&gt;using namespace std;#define rep(i,a,n) for (int i=a;i&lt;n;i++)#define per(i,a,n) for (int i=n-1;i&gt;=a;i--)#define pb push_back#define mp make_pair#define np next_permutation#define all(x) x.begin(),x.end()#define fi first#define se second#define SZ(x) (int(x).size())typedef long long ll;typedef vector &lt;int&gt; vi;typedef pair&lt;int,int&gt; pii;const int maxn=2e5+5; vector &lt;ll&gt; va,vb;ll pa,pb;ll n,m;int main()&#123; while(~scanf("%lld%lld",&amp;n,&amp;m))&#123; va.clear(); for(ll i=1;i&lt;=n;i++)&#123; scanf("%lld",&amp;pa); va.pb(pa); &#125; sort(all(va)); for(ll i=1;i&lt;=m;i++)&#123; if(i!=1) printf(" "); scanf("%lld",&amp;pb); if(pb&gt;=*(--va.end())) printf("%lld",n); else if(pb&lt;*(va.begin())) printf("0"); else&#123; ll c=upper_bound(all(va),pb)-va.begin(); printf("%lld",c); &#125; &#125; printf("\n"); &#125;&#125; 收获与反思 二分思想练习 upper_bound 与 lower_bound 使用的一些注意 前提： 数组是一个非降序列 参数： 一个数组元素的地址（或者数组名来表示这个数组的首地址，用来表示这个数组的开头比较的元素的地址，不一定要是首地址，只是用于比较的“首”地址）， 一个数组元素的地址（对应的这个数组里边任意一个元素的地址，表示这个二分里边的比较的”结尾’地址）， 一个你要二分查找的那个数。 返回值： 是地址，不是指那个要查找的数的下标，所以就注定了在这个函数的后边就要减去一个尾巴，那就是这个数组用来比较的头地址。 upper_bound 返回的是键值为i的元素可以插入的最后一个位置（上界） lowe_bound 返回的是键值为i的元素可以插入的位置的第一个位置（下界）。 举例在升序的set里面： set里没有元素i的时候，两个元素的返回值是一样的。 1 2 4 5 这个序列，upp（3）和low（3）都返回位置2（下标） 如果只有一个元素i，low返回那个元素的位置，而upp返回那个元素的位置的后一个位置。 1 2 4 5 这个序列upp（2）返回下标2而low（2）返回下标1 多个元素i，low返回那个元素的位置，upp返回那多个元素中的最后一个的后一个位置。 1 2 2 4 5 这个序列 upp（2）返回下标3的位置，low（2）返回下标1的位置。 不存在时的情况： 特别注意：在一个升序的容器里，如果所有元素都大于i则，upp和low都返回begin。都小于i则返回end（越界了）。]]></content>
      <categories>
        <category>编程</category>
        <category>ACM</category>
      </categories>
      <tags>
        <tag>算法</tag>
        <tag>ACM</tag>
        <tag>二分</tag>
        <tag>2018暑假集训</tag>
        <tag>CodeForces</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[【CSU-2092】解题报告（模拟，物理）]]></title>
    <url>%2F2018%2F07%2F25%2F%E3%80%90CSU-2092%E3%80%91%E8%A7%A3%E9%A2%98%E6%8A%A5%E5%91%8A%EF%BC%88%E6%A8%A1%E6%8B%9F%EF%BC%8C%E7%89%A9%E7%90%86%EF%BC%89%2F</url>
    <content type="text"><![CDATA[原始题目2092: Space Golf Time Limit: 1 Sec Memory Limit: 512 Mb Submitted: 77 Solved: 35 SpecialJudge Description You surely have never heard of this new planet surface exploration scheme, as it is being carried out in a project with utmost secrecy. The scheme is expected to cut costs of conventional rover-type mobile explorers considerably, using projected-type equipment nicknamed “observation bullets”. Bullets do not have any active mobile abilities of their own, which is the main reason of their cost-efficiency. Each of the bullets, after being shot out on a launcher given its initial velocity, makes a parabolic trajectory until it touches down. It bounces on the surface and makes another parabolic trajectory. This will be repeated virtually infinitely. We want each of the bullets to bounce precisely at the respective spot of interest on the planet surface, adjusting its initial velocity. A variety of sensors in the bullet can gather valuable data at this instant of bounce, and send them to the observation base. Although this may sound like a conventional target shooting practice, there are several issues that make the problem more difficult. There may be some obstacles between the launcher and the target spot. The obstacles stand upright and are very thin that we can ignore their widths. Once the bullet touches any of the obstacles, we cannot be sure of its trajectory thereafter. So we have to plan launches to avoid these obstacles. Launching the bullet almost vertically in a speed high enough, we can easily make it hit the target without touching any of the obstacles, but giving a high initial speed is energy-consuming. Energy is extremely precious in space exploration, and the initial speed of the bullet should be minimized. Making the bullet bounce a number of times may make the bullet reach the target with lower initial speed. The bullet should bounce, however, no more than a given number of times. Although the body of the bullet is made strong enough, some of the sensors inside may not stand repetitive shocks. The allowed numbers of bounces vary on the type of the observation bullets. You are summoned engineering assistance to this project to author a smart program that tells the minimum required initial speed of the bullet to accomplish the mission. Figure D.1 gives a sketch of a situation, roughly corresponding to the situation of the Sample Input 4 given below. Figure D.1. A sample situation You can assume the following. The atmosphere of the planet is so thin that atmospheric resistance can be ignored. The planet is large enough so that its surface can be approximated to be a completely flat plane. The gravity acceleration can be approximated to be constant up to the highest points a bullet can reach. These mean that the bullets fly along a perfect parabolic trajectory. You can also assume the following. The surface of the planet and the bullets are made so hard that bounces can be approximated as elastic collisions. In other words, loss of kinetic energy on bounces can be ignored. As we can also ignore the atmospheric resistance, the velocity of a bullet immediately after a bounce is equal to the velocity immediately after its launch. The bullets are made compact enough to ignore their sizes. The launcher is also built compact enough to ignore its height. You, a programming genius, may not be an expert in physics. Let us review basics of rigid-body dynamics. We will describe here the velocity of the bullet $v$ with its horizontal and vertical components $v_x$ and $v_y$ (positive meaning upward). The initial velocity has the components $v_{ix}$ and $v_{iy}$, that is, immediately after the launch of the bullet, $v_x = v_ix$ and $v_y = v_iy$ hold. We denote the horizontal distance of the bullet from the launcher as $x$ and its altitude as $y$ at time $t$. The horizontal velocity component of the bullet is kept constant during its flight when atmospheric resistance is ignored. Thus the horizontal distance from the launcher is proportional to the time elapsed. x=v_{ix}t \tag{1} The vertical velocity component vy is gradually decelerated by the gravity. With the gravity acceleration of g, the following differential equation holds during the flight. \frac{d{v_y}}{dt}=-g \tag{2}Solving this with the initial conditions of vy = viy and y = 0 when t = 0, we obtain the following. \begin{eqnarray} y&=&-\frac{1}{2}gt^2+v_{iy}t \tag{3} \\ &=&-(\frac{1}{2}gt-v_{iy})t \tag{4} \end{eqnarray}The equation (4) tells that the bullet reaches the ground again when $t = \frac{2v_{iy}}{g}$. Thus, the distance of the point of the bounce from the launcher is $\frac{2v_{ix}v_{iy}}{g}$. In other words, to make the bullet fly the distance of l, the two components of the initial velocity should satisfy $2v_{ix}v_{iy}= lg$. Eliminating the parameter t from the simultaneous equations above, we obtain the following equation that escribes the parabolic trajectory of the bullet. y=-(\frac{g}{2v_{ix}^2})x^2+(\frac{v_{iy}}{v_{ix}})x \tag{5}For ease of computation, a special unit system is used in this project, according to which the gravity acceleration g of the planet is exactly 1.0. InputThe input consists of several tests case with the following format. d\ n\ b \\ p_1\ h_1 \\ p_2\ h_2 \\ \vdots \\ p_n\ h_n \\For each test, the first line contains three integers, $d$, $n$, and $b$. Here, $d$ is the distance from the launcher to the target spot $(1 ≤ d ≤ 10000)$, $n$ is the number of obstacles $(1 ≤ n ≤ 10)$, and $b$ is the maximum number of bounces allowed, not including the bounce at the target spot $(0 ≤ b ≤ 15)$. Each of the following $n$ lines has two integers. In the k-th line, $pk$ is the position of the k-th obstacle, its distance from the launcher, and hk is its height from the ground level. You can assume that 0 &lt; p1, pk &lt; pk + 1 for $k = 1,\cdots, n − 1$, and $pn &lt; d$. You can also assume that $1 ≤ hk ≤ 10000$ for $k = 1,\cdots, n$. OutputOutput the smallest possible initial speed vi that makes the bullet reach the target. The initial speed vi of the bullet is defined as follows. v_i=\sqrt{v_{ix}^2+v_{iy}^2}The output should not contain an error greater than 0.0001. Sample Input100 1 0 50 100 10 1 0 4 2 100 4 3 20 10 30 10 40 10 50 10 343 3 2 56 42 190 27 286 34 Sample Output14.57738 3.16228 7.78175 11.08710 HintSourceAsia Regional Contest, Tokyo, 2014 题目大意一道物理题，给定终点和起点的距离$d$，以及$n$个距离起点坐标不同的障碍物（板子）。一颗子弹从起点做抛物线运动，可以撞击地面再弹起$b$次（忽略能量损失），求可以越过障碍物恰好达到终点的初始速度值大小的最小值。 解题思路 模拟+贪心（不知道可不可以叫贪心） 转化一下，由于撞击地面弹起能量无损失。所以可以将撞击前后的两段转化为一段。对每个可能的距离更新最小值。 d_i=\frac{d}{i} (i=1,2,3 \cdots b-1) 对于每个$d_i$，先行判断45度（即$v_y=v_x$时）是否满足条件，若满足直接更新最小值。若不满足则根据轨迹方程不断更新直至能越过最高点。 解题代码123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657#include &lt;cstdio&gt;#include &lt;cmath&gt;#include &lt;cstring&gt;#include &lt;string&gt;#define INF 0x3f3f3f3f#define EPS 1e-8using namespace std;int n,b;double d,dis,vx,vy;//障碍物 struct obstacles&#123; double h,x; &#125;ob[20];double x[20]; void cal(double x,double h)&#123; vx=sqrt((dis*x/2.0-x*x/2.0)/h); vy=dis/2.0/vx;&#125;int judge()&#123; //判断是否可以跨过所有障碍物 for (int i = 0; i &lt; n; i++)&#123; double h = vy*x[i] / vx - 0.5*x[i]*x[i] / (vx*vx); if (ob[i].h-h &gt;= EPS) return 0; &#125; return 1;&#125;double solve(int cnt)&#123; dis = d/cnt; //划分段 for(int i=0;i&lt;n;i++) x[i]=fmod(ob[i].x,dis); //浮点数取模 vy=vx=sqrt(dis/2); //先检测vy=vx时候 if(judge()) return vx*sqrt(2.0); double ans=INF; for(int i=0;i&lt;n;i++)&#123; cal(x[i],ob[i].h); //根据x[i],ob[i]初的障碍物更新vx vy的值。 if(judge()) ans=min(ans,sqrt(vx*vx+vy*vy)); &#125; return ans; &#125;int main()&#123; while(~scanf("%lf %d %d", &amp;d, &amp;n, &amp;b)) &#123; memset(ob,0,sizeof(ob)); memset(x,0,sizeof(x)); for (int i = 0; i &lt; n; i++) scanf ("%lf %lf", &amp;ob[i].x, &amp;ob[i].h); double ans = INF; for (int i = 1; i &lt;= b+1; i++) ans = min(ans, solve(i)); printf ("%.8f\n", ans); &#125;&#125; 收获与反思 从简单开始考虑，无障碍物的时候45度最远 将多段跳跃等效为一段。 浮点数取模函数 fmod 函数计算 x 除以 y 的 f 浮点余数，这样 x = i*y + f，其中 i 是整数，f 和 x 有相同的符号，而且 f 的绝对值小于 y 的绝对值。 1234result=fmod(x,y);printf("10.0%%-3.0= %f/n",result); //1.0result=fmod(y,x);printf("-3.0%%10.0= %f/n",result); //-3.0]]></content>
      <categories>
        <category>编程</category>
        <category>ACM</category>
      </categories>
      <tags>
        <tag>算法</tag>
        <tag>ACM</tag>
        <tag>CSU</tag>
        <tag>Imitation</tag>
        <tag>2018暑假集训</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[【HDU-6301】解题报告（贪心，预处理）]]></title>
    <url>%2F2018%2F07%2F25%2F%E3%80%90HDU-6301%E3%80%91%E8%A7%A3%E9%A2%98%E6%8A%A5%E5%91%8A%EF%BC%88%E8%B4%AA%E5%BF%83%EF%BC%8C%E9%A2%84%E5%A4%84%E7%90%86%EF%BC%89%2F</url>
    <content type="text"><![CDATA[原始题目Distinct Values Time Limit: 4000/2000 MS (Java/Others) Memory Limit: 32768/32768 K (Java/Others) Total Submission(s): 3168 Accepted Submission(s): 1017 Problem DescriptionChiaki has an array of $n$ positive integers. You are told some facts about the array: for every two elements $a_i$ and $a_j$ in the subarray $a_{l \cdots r} (l≤i&lt;j≤r)$, $a_i≠a_j$ holds. Chiaki would like to find a lexicographically minimal array which meets the facts. InputThere are multiple test cases. The first line of input contains an integer $T$, indicating the number of test cases. For each test case: The first line contains two integers $n$ and $m (1≤n,m≤105)$ — the length of the array and the number of facts. Each of the next $m$ lines contains two integers $l_i$ and $r_i$ $(1≤li≤ri≤n)$. It is guaranteed that neither the sum of all $n$ nor the sum of all $m$ exceeds 106. OutputFor each test case, output $n$ integers denoting the lexicographically minimal array. Integers should be separated by a single space, and no extra spaces are allowed at the end of lines. Sample Input3 2 1 1 2 4 2 1 2 3 4 5 2 1 3 2 4 Sample Output1 2 1 2 1 2 1 2 3 1 1 Source2018 Multi-University Training Contest 1 Recommendliuyiding 题目大意对于一个数列，已知其m个子区间，每个子区间内数列的项两两不同，求复合条件的字典序最小的数列。 解题思路 要求字典序最小，算法就是从前贪心的让每一位都是当前可使用数的最小值（从1开始）。 那么如何处理出第i位可用数字的最小值？ 预处理出$pre[i]$（包含第i位线段的最小左端点，即与第i位不相同的最早位置） 用set维护当前可使用的数，$pt$指向当前可用最小数的位置， 求每一位的$ans[i]$时，先检查，当$pt&lt;pre[i]$时，说明$pt$到$pre[i]$位置间使用过的数可以再次使用，所以开始向set容器里补充$pt$位置的数，直至$pt=pre[i]$，再取set容器中的最小值付给$ans[i]$ 如何与处理出$pre[i]$（见下图） 解题代码123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657#include &lt;bits/stdc++.h&gt;using namespace std;#define rep(i,a,n) for (int i=a;i&lt;n;i++)#define per(i,a,n) for (int i=n-1;i&gt;=a;i--)#define pb push_back#define mp make_pair#define np next_permutation#define all(x) x.begin(),x.end()#define fi first#define se second#define SZ(x) ((int)(x).size()) typedef vector&lt;int&gt; vi;typedef long long ll;typedef pair&lt;int,int&gt; pii;const int mod=1e9+7;const int maxn=2e5+5;set &lt;int&gt; s;int pre[maxn],n,m,ans[maxn]; //预处理出不可相同的区间前端点。 int main()&#123; int t; scanf("%d",&amp;t); while(t--)&#123; s.clear(); scanf("%d%d",&amp;n,&amp;m); rep(i,1,n+1)&#123; pre[i]=i; //没有限制条件，前端点都是自身 s.insert(i); &#125; rep(i,1,m+1)&#123; int l,r; scanf("%d%d",&amp;l,&amp;r); pre[r]=min(l,pre[r]); //有可能多个区间右端点相同。 //易错写成 pre[r]=l;忘记更新 &#125; per(i,1,n) pre[i]=min(pre[i],pre[i+1]); //易错写成n+1 //处理完毕 //初始set均可用 int pt=1; //pt记录当前不可用线段开头 rep(i,1,n+1)&#123; //开头更替，则往set里补充可用最小值 // cout&lt;&lt;"pt="&lt;&lt;pt&lt;&lt;" pre[i]="&lt;&lt;pre[i]&lt;&lt;endl; while(pt&lt;pre[i])&#123; s.insert(ans[pt++]); &#125; ans[i]=*s.begin(); s.erase(*s.begin()); &#125; rep(i,1,n+1)&#123; if(i==1) printf("%d",ans[i]); else printf(" %d",ans[i]); &#125; printf("\n"); &#125;&#125; 收获与反思 预处理出线段的左端点。 贪心的考虑每一位的最小值。]]></content>
      <categories>
        <category>编程</category>
        <category>ACM</category>
      </categories>
      <tags>
        <tag>算法</tag>
        <tag>ACM</tag>
        <tag>2018暑假集训</tag>
        <tag>Greedy</tag>
        <tag>HDU</tag>
        <tag>2018HDU多校</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[【HDU-6300】解题报告（简单几何贪心）]]></title>
    <url>%2F2018%2F07%2F25%2F%E3%80%90HDU-6300%E3%80%91%E8%A7%A3%E9%A2%98%E6%8A%A5%E5%91%8A%EF%BC%88%E7%AE%80%E5%8D%95%E5%87%A0%E4%BD%95%E8%B4%AA%E5%BF%83%EF%BC%89%2F</url>
    <content type="text"><![CDATA[原始题目Triangle Partition Time Limit: 2000/1000 MS (Java/Others) Memory Limit: 132768/132768 K (Java/Others) Total Submission(s): 1054 Accepted Submission(s): 533 Special Judge Problem DescriptionChiaki has $3n$ points $p_1,p_2,…,p_{3n}$. It is guaranteed that no three points are collinear. Chiaki would like to construct $n$ disjoint triangles where each vertex comes from the $3n$ points. InputThere are multiple test cases. The first line of input contains an integer $T$, indicating the number of test cases. For each test case: The first line contains an integer $n (1≤n≤1000)$ — the number of triangle to construct. Each of the next 3n lines contains two integers $x_i$ and $y_i (−109≤x_i,y_i≤109)$. It is guaranteed that the sum of all $n$ does not exceed 10000. OutputFor each test case, output $n$ lines contain three integers $a_i,b_i,c_i (1≤a_i,b_i,c_i≤3n)$ each denoting the indices of points the i-th triangle use. If there are multiple solutions, you can output any of them. Sample Input1 1 1 2 2 3 3 5 Sample Output1 2 3 Source2018 Multi-University Training Contest 1 Recommendliuyiding 题目大意给出$3n$个点，且任意三点军部贡献，要求按顺序给出$n$个三角形的三个顶点坐标，要求$n$个三角形两两不相交（不共点）。 解题思路反向理解 若两条线相交（如下图） 假设我们连三角形时先连A线再连，B线，若出现A2&gt;B1，则有可能会出现两线相交。 考虑到题目给出任意三点不共线，即人以三点都可以构成一个三角形。我们只要找到一种方法逐个连接出不相交的三角形就行。 按x轴将所有点排序，从小到大每次找三个点即可。 解题代码12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152#include &lt;bits/stdc++.h&gt;using namespace std;#define rep(i,a,n) for (int i=a;i&lt;n;i++)#define per(i,a,n) for (int i=n-1;i&gt;=a;i--)#define pb push_back#define mp make_pair#define np next_permutation#define all(x) x.begin(),x.end()#define fi first#define se second#define SZ(x) ((int)(x).size()) typedef vector&lt;int&gt; vi;typedef long long ll;typedef pair&lt;int,int&gt; pii;const int mod=1e9+7;const int maxn=1e4+5;struct node&#123; int index; pii point;&#125;a[maxn];ll t,n,m;bool cmp(node a, node b)&#123; if(a.point.first==b.point.first) return a.point.second&lt;b.point.second; else return a.point.first&lt;b.point.first;&#125;int main()&#123; ios::sync_with_stdio(false); cin&gt;&gt;t; while(t--)&#123; cin&gt;&gt;n; rep(i,1,3*n+1)&#123; a[i].index=i; cin&gt;&gt;a[i].point.first&gt;&gt;a[i].point.second; &#125; sort(a+1,a+1+3*n,cmp);// rep(i,1,3*n+1)&#123;// cout&lt;&lt;a[i].point.fi&lt;&lt;" "&lt;&lt;a[i].point.se&lt;&lt;endl;// &#125; rep(i,1,3*n+1)&#123; if(i==1) cout&lt;&lt;a[i].index; else cout&lt;&lt;" "&lt;&lt;a[i].index; &#125; cout&lt;&lt;endl; &#125; &#125; 收获与反思 简单的几何贪心，考虑两线相交的条件拓展即可。]]></content>
      <categories>
        <category>编程</category>
        <category>ACM</category>
      </categories>
      <tags>
        <tag>算法</tag>
        <tag>ACM</tag>
        <tag>2018暑假集训</tag>
        <tag>Greedy</tag>
        <tag>HDU</tag>
        <tag>2018HDU多校</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[【HDU-6298】解题报告（数论，整除）]]></title>
    <url>%2F2018%2F07%2F25%2F%E3%80%90HDU-6298%E3%80%91%E8%A7%A3%E9%A2%98%E6%8A%A5%E5%91%8A%EF%BC%88%E6%95%B0%E8%AE%BA%EF%BC%8C%E6%95%B4%E9%99%A4%EF%BC%89%2F</url>
    <content type="text"><![CDATA[原始题目Maximum Multiple Time Limit: 4000/2000 MS (Java/Others) Memory Limit: 32768/32768 K (Java/Others) Total Submission(s): 1503 Accepted Submission(s): 653 Problem DescriptionGiven an integer $n$, Chiaki would like to find three positive integers $x$, $y$ and $z$ such that: $n=x+y+z$, $x∣n$, $y∣n$, $z∣n$ and $xyz$ is maximum. InputThere are multiple test cases. The first line of input contains an integer $T (1≤T≤106)$, indicating the number of test cases. For each test case:The first line contains an integer $n (1≤n≤106)$. OutputFor each test case, output an integer denoting the maximum xyz. If there no such integers, output −1 instead. Sample Input3 1 2 3 Sample Output-1 -1 1 Source 2018 Multi-University Training Contest 1 Recommend liuyiding 题目大意已知三个数的和为$n$，且三个数均能整除$n$，求三个数乘积的最大值。 解题思路数论问题 不妨设$a=\frac{n}{x},b=\frac{n}{y},c=\frac{n}{z}$。由题目条件可以得到 \frac{1}{a}+\frac{1}{b}+\frac{1}{c}=1由于$a,b,c$均为整数（正整数）。所以该方程共有三组解。分别为$a=3,b=3,c=3,xyz=\frac{n^3}{27}$或者$a=2,b=4,c=4,xyz=\frac{n^3}{32}$或者$a=2,b=3,c=6,xyz=\frac{n^3}{36}$ 故判断$n|3,n|4$整除即可。又因为若第三组解成立，则必有第三组解，而且第一组解对应的$xyz$值更大，故不考虑第三组。 解题代码1234567891011121314151617181920212223242526272829303132#include &lt;bits/stdc++.h&gt;using namespace std;#define rep(i,a,n) for (int i=a;i&lt;n;i++)#define per(i,a,n) for (int i=n-1;i&gt;=a;i--)#define pb push_back#define mp make_pair#define np next_permutation#define all(x) x.begin(),x.end()#define fi first#define se second#define SZ(x) ((int)(x).size()) typedef vector&lt;int&gt; vi;typedef long long ll;typedef pair&lt;int,int&gt; pii;const int mod=1e9+7;const int maxn=1e5+5;ll t,n,m;int main()&#123; ios::sync_with_stdio(false); cin&gt;&gt;t; while(t--)&#123; cin&gt;&gt;n; if(!(n%3)) cout&lt;&lt;1ll*n*n*n/27&lt;&lt;endl; else if(!(n%4)) cout&lt;&lt;1ll*n*n*n/32&lt;&lt;endl; else cout&lt;&lt;"-1"&lt;&lt;endl; &#125; &#125; 收获与反思 寻找条件的关系 数论学习]]></content>
      <categories>
        <category>编程</category>
        <category>ACM</category>
      </categories>
      <tags>
        <tag>算法</tag>
        <tag>ACM</tag>
        <tag>2018暑假集训</tag>
        <tag>数论</tag>
        <tag>HDU</tag>
        <tag>2018HDU多校</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[【HDU-6165】解题报告（BFS，搜索优化）]]></title>
    <url>%2F2018%2F07%2F25%2F%E3%80%90HDU-6165%E3%80%91%E8%A7%A3%E9%A2%98%E6%8A%A5%E5%91%8A%EF%BC%88BFS%EF%BC%8C%E6%90%9C%E7%B4%A2%E4%BC%98%E5%8C%96%EF%BC%89%2F</url>
    <content type="text"><![CDATA[原始题目FFF at Valentine Time Limit: 6000/3000 MS (Java/Others) Memory Limit: 65536/65536 K (Java/Others) Total Submission(s): 1703 Accepted Submission(s): 722 Problem Description At Valentine’s eve, Shylock and Lucar were enjoying their time as any other couples. Suddenly, LSH, Boss of FFF Group caught both of them, and locked them into two separate cells of the jail randomly. But as the saying goes: There is always a way out , the lovers made a bet with LSH: if either of them can reach the cell of the other one, then LSH has to let them go. The jail is formed of several cells and each cell has some special portals connect to a specific cell. One can be transported to the connected cell by the portal, but be transported back is impossible. There will not be a portal connecting a cell and itself, and since the cost of a portal is pretty expensive, LSH would not tolerate the fact that two portals connect exactly the same two cells. As an enthusiastic person of the FFF group, YOU are quit curious about whether the lovers can survive or not. So you get a map of the jail and decide to figure it out. Input Input starts with an integer $T (T≤120)$, denoting the number of test cases. For each case, First line is two number $n$ and $m$, the total number of cells and portals in the jail.$(2≤n≤1000,m≤6000)$ Then next $m$ lines each contains two integer $u$ and $v$, which indicates a portal from $u$ to $v$. OutputIf the couple can survive, print “I love you my love and our love save us!” Otherwise, print “Light my fire!” Sample Input3 5 5 1 2 2 3 2 4 3 5 4 5 3 3 1 2 2 3 3 1 5 5 1 2 2 3 3 1 3 4 4 5 Sample OutputLight my fire! I love you my love and our love save us! I love you my love and our love save us! Source2017 Multi-University Training Contest - Team 9 Recommendliuyiding 题目大意给定一个有向图，问任意两点之间是否连通 解题思路暂时没有其他（正常）想法，SHL写了一个暴力BFS+优化，拿来学习一下。 解题代码12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061#include&lt;bits/stdc++.h&gt;using namespace std;vector&lt;int&gt; v[1010];int Flag[1010][1010],vis[1010];int ans;void bfs(int st)&#123; queue&lt;int&gt; q; while(!q.empty()) q.pop(); q.push(st); memset(vis,0,sizeof vis); vis[st] = 1; while(!q.empty()) &#123; int u = q.front();q.pop(); for(int i = 0; i &lt; v[u].size(); i++) &#123; if(vis[v[u][i]] == 0) &#123; vis[v[u][i]] = 1; q.push(v[u][i]); if(Flag[st][v[u][i]] == 0) &#123; Flag[st][v[u][i]] = Flag[v[u][i]][st] = 1; ans++; &#125; &#125; &#125; &#125;&#125;void Init()&#123; for(int i=0;i&lt;1010;i++) v[i].clear(); memset(Flag,0,sizeof Flag); ans=0;&#125;int main()&#123; int T,n,m;cin&gt;&gt;T; while(T--) &#123; Init(); scanf("%d%d",&amp;n,&amp;m); while(m--) &#123; int x,y; scanf("%d%d",&amp;x,&amp;y); v[x].push_back(y); &#125; for(int i = 1; i &lt;= n; i++) bfs(i); if(ans == n*(n-1)/2) printf("I love you my love and our love save us!\n"); else printf("Light my fire!\n"); &#125; return 0;&#125; 收获与反思待补充]]></content>
      <categories>
        <category>编程</category>
        <category>ACM</category>
      </categories>
      <tags>
        <tag>算法</tag>
        <tag>ACM</tag>
        <tag>2018暑假集训</tag>
        <tag>BFS</tag>
        <tag>HDU</tag>
        <tag>2017HDU多校</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[【HDU-6168】解题报告（数学，规律，分组）]]></title>
    <url>%2F2018%2F07%2F24%2F%E3%80%90HDU-6168%E3%80%91%E8%A7%A3%E9%A2%98%E6%8A%A5%E5%91%8A%EF%BC%88%E6%95%B0%E5%AD%A6%EF%BC%8C%E8%A7%84%E5%BE%8B%EF%BC%8C%E5%88%86%E7%BB%84%EF%BC%89%2F</url>
    <content type="text"><![CDATA[原始题目Numbers Time Limit: 4000/2000 MS (Java/Others) Memory Limit: 131072/131072 K (Java/Others) Total Submission(s): 1466 Accepted Submission(s): 692 Problem Descriptionzk has n numbers a1,a2,…,an. For each (i,j) satisfying 1≤i&lt;j≤n, zk generates a new number (ai+aj). These new numbers could make up a new sequence b1，b2,…,bn(n−1)/2. LsF wants to make some trouble. While zk is sleeping, Lsf mixed up sequence a and b with random order so that zk can’t figure out which numbers were in a or b. “I’m angry!”, says zk. Can you help zk find out which n numbers were originally in a? Input Multiple test cases(not exceed 10). For each test case: ∙The first line is an integer m(0≤m≤125250), indicating the total length of a and b. It’s guaranteed m can be formed as n(n+1)/2. ∙The second line contains m numbers, indicating the mixed sequence of a and b. Each ai is in [1,10^9] Output For each test case, output two lines. The first line is an integer n, indicating the length of sequence a; The second line should contain n space-seprated integers a1,a2,…,an(a1≤a2≤…≤an). These are numbers in sequence a. It’s guaranteed that there is only one solution for each case. Sample Input6 2 2 2 4 4 4 21 1 2 3 3 4 4 5 5 5 6 6 6 7 7 7 8 8 9 9 10 11 Sample Output3 2 2 2 6 1 2 3 4 5 6 Source 2017 Multi-University Training Contest - Team 9 Recommend liuyiding 题目大意已知一个数列由a，b两个数列构成，b数列中的每一项都是a数列中某两项的和，求原数列a 解题思路首先可以确定的几点是 数列$a$有$n$项，则数列$b$有$\frac{n(n-1)}{2}$项，则给定的$c$数列有$\frac{n(n+1)}{2}$项， 由于$a$中任意一项均&gt;=1（即，$a$为正数数列），所以$c$中的最小项极为$a$中的最小项。 也可以推得，$c$中第二小项也为$a$中第二小项。 再往后推 $c$项中第三小的可能是$a$中第三小的项，也可能是b项中第一小的项（即${a_1}+{a_2}$)。 由于$c$由$a$和$b$全部项构成，所以${b_1}={a_1}+{a_2}$必然在$c$中。 由此我们想到筛数的方法。 $c$中去掉${a_1}+{a_2}$的一项后剩下的最小项必然为$a_3$。 再从$c$中去掉${a_1}+{a_3}$，${a_2}+{a_3}$，剩下的最小项必然为$a_4$。 解题代码123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657#include &lt;cstdio&gt;#include &lt;cstring&gt;#include &lt;string&gt;#include &lt;iostream&gt;#include &lt;set&gt;#include &lt;algorithm&gt;#include &lt;iomanip&gt;#include &lt;vector&gt;#include &lt;map&gt;#include &lt;queue&gt;using namespace std;const int maxn=1e5+5;int n,m;vector &lt;int&gt; a,b,c,ans;map &lt;int,int&gt; num;int main()&#123; while(~scanf("%d",&amp;n))&#123; a.clear(); b.clear(); c.clear(); ans.clear(); num.clear(); int temp; for(int i=0;i&lt;n;i++)&#123; scanf("%d",&amp;temp); a.push_back(temp); if(num[temp]==0) num[temp]=1; else num[temp]++; //记录次数 &#125; sort(a.begin(),a.end()); ans.push_back(a[0]); //初始装进一个最小a1 num[a[0]]--; for(int i=1;i&lt;n;i++)&#123; if(!num[a[i]]) continue; for(int j=0;j&lt;ans.size();j++)&#123; num[a[i]+ans[j]]--; &#125; ans.push_back(a[i]); num[a[i]]--; &#125; printf("%d\n",ans.size()); vector &lt;int&gt; ::iterator it; for(it=ans.begin();it!=ans.end();it++)&#123; if(it==ans.begin()) cout&lt;&lt;*it; else cout&lt;&lt;" "&lt;&lt;*it; &#125; cout&lt;&lt;endl; &#125;&#125; 收获与反思 有序数列的构成注意寻找规律。 分组后更新数列状态。]]></content>
      <categories>
        <category>编程</category>
        <category>ACM</category>
      </categories>
      <tags>
        <tag>算法</tag>
        <tag>ACM</tag>
        <tag>2018暑假集训</tag>
        <tag>HDU</tag>
        <tag>2017HDU多校</tag>
        <tag>规律</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[【HDU-6170】解题报告（字符串，正则匹配，dp）]]></title>
    <url>%2F2018%2F07%2F24%2F%E3%80%90HDU-6170%E3%80%91%E8%A7%A3%E9%A2%98%E6%8A%A5%E5%91%8A%EF%BC%88%E5%AD%97%E7%AC%A6%E4%B8%B2%EF%BC%8C%E6%AD%A3%E5%88%99%E5%8C%B9%E9%85%8D%EF%BC%8Cdp%EF%BC%89%2F</url>
    <content type="text"><![CDATA[原始题目Two strings Time Limit: 2000/1000 MS (Java/Others) Memory Limit: 65536/65536 K (Java/Others) Total Submission(s): 2511 Accepted Submission(s): 891 Problem DescriptionGiving two strings and you should judge if they are matched. The first string contains lowercase letters and uppercase letters. The second string contains lowercase letters, uppercase letters, and special symbols: “.” and “*”.. can match any letter, and * means the front character can appear any times. For example, “a.b” can match “acb” or “abb”, “a” can match “a”, “aa” and even empty string. ( “\” will not appear in the front of the string, and there will not be two consecutive “*”. InputThe first line contains an integer T implying the number of test cases. (T≤15)For each test case, there are two lines implying the two strings (The length of the two strings is less than 2500). OutputFor each test case, print “yes” if the two strings are matched, otherwise print “no”. Sample Input3 aa a* abb a.* abb aab Sample Outputyes yes no Source2017 Multi-University Training Contest - Team 9 Recommendliuyiding 题目大意给定 $a$，$b$ 两个字符串。$a$字符串只由字母构成，$b$字符串由字母和”.“，”*“两种符号组合成。有如下规则。 “符号可以匹配任意一个字母。 “*“符号可以匹配0个或多个上一字母，且不会出现在开头。判断$a$，$b$两字符串能否匹配。 解题思路改变了”*“规则的正则匹配。可以用C++正则匹配的库做，也可以使用dp做。 dp思路：bool型dp二维数组，$dp[i][j]$表示$a$字符串第i位和$b$字符串第j位能否匹配。 状态转移方程： 当$b_j$为”.“时，$dp[i][j]=dp[i-1][j-1]$。 当$b_j$为字母时，若$a_i=b_j$，则$dp[i][j]=dp[i-1][j-1]$。否则$dp[i][j]=0$。 当$b_j$为”*“时，根据”*“的规则。上一个字母出现次数为$n$。 当$n=0$时，匹配为上一个字母没有出现过，可从$dp[i][j-2]$转移过来。 当$n=1$时，匹配为上一个字母出现一次，可从$dp[i][j-1]$转移过来。 当$n=2$时，匹配为上一个字母出现两次，故若$a_i=a_{i-1}$时，可从$dp[i-1][j-1]$转移过来。否则$dp[i][j]=0$。 当$n&gt;2$时，匹配为上一个出现$n$次，若$a_i=a_{i-1}$时，$dp[i-1][j]$转移过来，可以不断回退直到到上一情况。 解题代码 正则匹配法 123456789101112131415161718192021222324252627282930313233343536373839#include &lt;iostream&gt;#include &lt;algorithm&gt;#include &lt;cstdio&gt;#include &lt;cmath&gt;#include &lt;cstring&gt;#include &lt;string&gt;#include &lt;string.h&gt;#include &lt;map&gt;#include &lt;set&gt;#include &lt;queue&gt;#include &lt;deque&gt;#include &lt;list&gt;#include &lt;bitset&gt;#include &lt;stack&gt;#include &lt;stdlib.h&gt;#include &lt;regex&gt;#define lowbit(x) (x&amp;-x)#define e exp(1.0)#define eps 1e-8//ios::sync_with_stdio(false);// auto start = clock();// cout &lt;&lt; (clock() - start) / (double)CLOCKS_PER_SEC;typedef long long ll;using namespace std; int main()&#123; ios::sync_with_stdio(false); int T; cin&gt;&gt;T; while(T--) &#123; string a,b; cin&gt;&gt;a&gt;&gt;b; b=regex_replace(b,regex("\\.\\*"),"(.)\\1*"); regex_match(a,regex(b))?cout&lt;&lt;"yes"&lt;&lt;endl:cout&lt;&lt;"no"&lt;&lt;endl; &#125; return 0;&#125; dp12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061#include &lt;bits/stdc++.h&gt;using namespace std;#define rep(i,a,n) for (int i=a;i&lt;n;i++)#define per(i,a,n) for (int i=n-1;i&gt;=a;i--)#define pb push_back#define mp make_pair#define np next_permutation#define all(x) x.begin(),x.end()#define fi first#define se second#define INF Ox3f3f3f3f#define SZ(x) ((int)(x).size()) //ios::sync_with_stdio(false);// auto start = clock();// cout &lt;&lt; (clock() - start) / (double)CLOCKS_PER_SEC;const int maxn=2510;char a[maxn],b[maxn];bool dp[maxn][maxn];int n,m;int main()&#123; int TT,T=0; scanf("%d",&amp;TT); while(TT--)&#123; scanf("%s",a+1); scanf("%s",b+1); n=strlen(a+1); m=strlen(b+1); memset(dp,0,sizeof(dp)); dp[0][0]=1; if (b[2]=='*') dp[0][2]=1; for(int i=1;i&lt;=n;i++)&#123; for(int j=1;j&lt;=m;j++)&#123; //字母情况 if(b[j]!='.'&amp;&amp;b[j]!='*')&#123; dp[i][j]=(a[i]==b[j]?dp[i-1][j-1]:0); &#125; else if(b[j]=='.')&#123; dp[i][j]=dp[i-1][j-1]; &#125; else if(b[j]=='*')&#123; dp[i][j]=dp[i][j-1]|dp[i][j-2]; if(a[i]==a[i-1]&amp;&amp;!dp[i][j]) dp[i][j]=dp[i-1][j-1]|dp[i-1][j]; //注意此处!dp[i][j] 否则会将状态由1更新为0，诸如 bb bba*就会出错 &#125; &#125; &#125; if(dp[n][m]) printf("yes\n"); else printf("no\n"); &#125; return 0;&#125;//1//bb//bba* 收获与反思 C++正则匹配regex库，涨姿势。 字符串dp，状态转移的思考需要学习一下。]]></content>
      <categories>
        <category>编程</category>
        <category>ACM</category>
      </categories>
      <tags>
        <tag>算法</tag>
        <tag>ACM</tag>
        <tag>2018暑假集训</tag>
        <tag>HDU</tag>
        <tag>2017HDU多校</tag>
        <tag>正则匹配</tag>
        <tag>dp</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[【CSU-1005】解题报告（数据结构，树入门，2018暑选入门B题）]]></title>
    <url>%2F2018%2F07%2F13%2F%E3%80%90CSU-1005%E3%80%91%E8%A7%A3%E9%A2%98%E6%8A%A5%E5%91%8A%EF%BC%88%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%EF%BC%8C%E4%BA%8C%E5%8F%89%E6%90%9C%E7%B4%A2%E6%A0%91%EF%BC%8C2018%E6%9A%91%E9%80%89%E5%85%A5%E9%97%A8B%E9%A2%98%EF%BC%89%2F</url>
    <content type="text"><![CDATA[原始题目1005: Binary Search Tree analogTime Limit: 1 SecMemory Limit: 128 MbSubmitted: 1630Solved: 473 DescriptionBinary Search Tree, abbreviated as BST, is a kind of binary tree maintains the following property: Each node has a Key value, which can be used to compare with each other. For every node in the tree, every Key value in its left subtree is smaller than its own Key value. For every node in the tree, every Key value in its right subtree is equal to or larger than its own Key value. Now we need to analog a BST, we only require one kind of operation: inserting. First, we have an empty BST. Input is a sequence of numbers. We need to insert them one by one flowing the rules below: If the inserted value is smaller than the root’s value, insert it to the left subtree. If the inserted value is larger than or equal to the value of the root’s value, insert it to the right subtree. After each input, we need to output the preorder, inorder, postorder traversal sequences. About tree traversal, the following is from Wikipedia: Depth-first TraversalTo traverse a non-empty binary tree in preorder, perform the following operations recursively at each node, starting with the root node: Visit the root. Traverse the left subtree. Traverse the right subtree. To traverse a non-empty binary tree in inorder (symmetric), perform the following operations recursively at each node: Traverse the left subtree. Visit the root. Traverse the right subtree. To traverse a non-empty binary tree in postorder, perform the following operations recursively at each node: Traverse the left subtree. Traverse the right subtree. Visit the root. Look at the folowing example: Intput is a sequence of 5 integers: 3 6 9 5 1 After each integer inserted the structure of the tree is illustrated in the flowing: 3 / \ 1 6 / \ 5 9 InputThe first integer of the input is T, the number of test cases. Each test case has two lines. The first line contain an integer N,(1≤N≤1000), the number of numbers need to be inserted into the BST. The second line contain N integers separated by space, each integer is in the range of [0,230]. OutputEach test case, output must contain three lines: the preorder, inorder and postorder traversal sequence. The numbers in each line should be separated by a single space and you should not output anything at the end of the line! Output a blank line after each case. Sample Input1 5 3 6 9 5 1 Sample Output3 1 6 5 9 1 3 5 6 9 1 5 9 6 3 HintSource中南大学第五届大学生程序设计竞赛-热身赛 题目大意构建二叉搜索树，然后将树按前序，中序，后序输出。 解题思路构建二叉树，写函数三种序输出即可。树入门题。 解题代码123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990#include &lt;cstdio&gt;#include &lt;cstring&gt;#include &lt;iostream&gt;#include &lt;set&gt;#include &lt;queue&gt;#include &lt;map&gt;#include &lt;algorithm&gt;using namespace std;typedef long long ll;const int maxn=1e5+5;struct node&#123; int x; struct node *left,*right;&#125;list[maxn];int t,i,n,x,flag1=1;struct node root,*p;void Insert(struct node *r,struct node *p)&#123; if(!r) return; if(r-&gt;x&gt;p-&gt;x) &#123; if(r-&gt;left) Insert(r-&gt;left,p); else r-&gt;left=p; &#125; else &#123; if(r-&gt;right) Insert(r-&gt;right,p); else r-&gt;right=p; &#125;&#125;void pretral(struct node *p)&#123; if(!p) return; if(flag1) printf("%d",p-&gt;x),flag1=0; else printf(" %d",p-&gt;x); pretral(p-&gt;left); pretral(p-&gt;right);&#125;void intral(struct node *p)&#123; if(!p) return; intral(p-&gt;left); if(flag1) printf("%d",p-&gt;x),flag1=0; else printf(" %d",p-&gt;x); intral(p-&gt;right);&#125;void postod(struct node *p)&#123; if(!p) return; postod(p-&gt;left); postod(p-&gt;right); if(flag1) printf("%d",p-&gt;x),flag1=0; else printf(" %d",p-&gt;x);&#125;int main()&#123; scanf("%d",&amp;t); while(t--) &#123; scanf("%d",&amp;n); scanf("%d",&amp;root.x); root.left=root.right=0; for(i=0;i&lt;n-1;i++) &#123; scanf("%d",&amp;x); p=&amp;list[i]; p-&gt;x=x; p-&gt;left=p-&gt;right=0; Insert(&amp;root,p); &#125; flag1=1; pretral(&amp;root); printf("\n"); flag1=1; intral(&amp;root); printf("\n"); flag1=1; postod(&amp;root); printf("\n"); printf("\n"); &#125;&#125; 收获与反思数据结构入门，二叉树熟悉，水题。]]></content>
      <categories>
        <category>编程</category>
        <category>ACM</category>
      </categories>
      <tags>
        <tag>算法</tag>
        <tag>ACM</tag>
        <tag>CSU</tag>
        <tag>数据结构</tag>
        <tag>2018暑期选拔</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[【CSU-1224】解题报告（BFS，水题，2018暑选入门A题）]]></title>
    <url>%2F2018%2F07%2F13%2F%E3%80%90CSU-1224%E3%80%91%E8%A7%A3%E9%A2%98%E6%8A%A5%E5%91%8A%EF%BC%88BFS%EF%BC%8C%E6%B0%B4%E9%A2%98%EF%BC%8C2018%E6%9A%91%E9%80%89%E5%85%A5%E9%97%A8A%E9%A2%98%EF%BC%89%2F</url>
    <content type="text"><![CDATA[原始题目1224: ACM小组的古怪象棋Time Limit: 1 SecMemory Limit: 128 MbSubmitted: 851Solved: 347 DescriptionACM小组的Samsara和Staginner对中国象棋特别感兴趣，尤其对马（可能是因为这个棋子的走法比较多吧）的使用进行深入研究。今天他们又在 构思一个古怪的棋局:假如Samsara只有一个马了，而Staginner又只剩下一个将，两个棋子都在棋盘的一边，马不能出这一半棋盘的范围，另外这 一半棋盘的大小很奇特(n行m列)。Samsara想知道他的马最少需要跳几次才能吃掉Staginner的将(我们假定其不会移动)。当然这个光荣的任 务就落在了会编程的你的身上了。 Input每组数据一行，分别为六个用空格分隔开的正整数$n,m,x1,y1,x2,y2$分别代表棋盘的大小$n,m$以及将的坐标和马的坐标。$(1 \le x1,x2 \le n \le 20 ,1 \le y1,y2 \le m \le 20)$ ，将和马的坐标不相同。 Output输出对应也有若干行，请输出最少的移动步数,如果不能吃掉将则输出“-1”(不包括引号)。 Sample Input8 8 5 1 4 5 Sample Output3 HintSourceCSU Monthly 2011 Dec. 题目大意如题 解题思路马的坐标为单入口BFS，如果搜索不到输出-1. 解题代码1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465666768697071727374757677787980#include &lt;queue&gt;#include &lt;cstdio&gt;#include &lt;cstring&gt;#include &lt;cstdlib&gt;#define maxn 35using namespace std; int n,m,x1,y1,x2,y2;bool vis[maxn][maxn];int dir[8][2]=&#123;&#123;-2,1&#125;,&#123;-2,-1&#125;,&#123;-1,2&#125;,&#123;-1,-2&#125;,&#123;1,2&#125;,&#123;1,-2&#125;,&#123;2,1&#125;,&#123;2,-1&#125;&#125;;struct State // BFS 队列中的状态数据结构&#123; int x,y; int Step_Counter; // 搜索步数统计器&#125;;//State a[maxn];int ans[maxn];bool CheckState(State next) // 约束条件检验&#123; if(next.x&gt;=1&amp;&amp;next.x&lt;=n&amp;&amp;next.y&gt;=1&amp;&amp;next.y&lt;=m&amp;&amp;!vis[next.x][next.y]) // 满足条件 &#123;// printf("next x=%d y=%d\n",next.x,next.y); return 1; &#125; else // 约束条件冲突 return 0;&#125;void bfs(State st)&#123; int flag=0; queue &lt;State&gt; q; // BFS 队列 State now,next; // 定义2个状态，当前和下一个 st.Step_Counter=0; // 计数器清零 q.push(st); // 入队 vis[st.x][st.y]=1; // 访问标记 while(!q.empty()) &#123; now=q.front(); // 取队首元素进行扩展// a[now.i].Step_Counter=++circle; if(now.x==x1&amp;&amp;now.y==y1) &#123; flag=1; printf("%d\n",now.Step_Counter); return ; &#125; for(int i=0;i&lt;8;i++) &#123; next.x=now.x+dir[i][0]; next.y=now.y+dir[i][1]; next.Step_Counter=now.Step_Counter+1; // 计数器加1 if(CheckState(next)) // 如果状态满足约束条件则入队 &#123; q.push(next);// printf("insert x=%d y=%d\n",next.x,next.y); vis[next.x][next.y]=1; //访问标记 &#125; &#125; q.pop(); // 队首元素出队 &#125; printf("-1\n"); return;&#125;int main()&#123; while(~scanf("%d%d%d%d%d%d",&amp;n,&amp;m,&amp;x1,&amp;y1,&amp;x2,&amp;y2)) &#123; memset(vis,0,sizeof(vis)); State start; start.x=x2; start.y=y2; bfs(start); &#125; return 0;&#125; 收获与反思bfs，可以考虑将模板改为bool型。]]></content>
      <categories>
        <category>编程</category>
        <category>ACM</category>
      </categories>
      <tags>
        <tag>算法</tag>
        <tag>ACM</tag>
        <tag>CSU</tag>
        <tag>2018暑期选拔</tag>
        <tag>BFS</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[《解忧杂货店》读书笔记]]></title>
    <url>%2F2018%2F07%2F13%2F%E3%80%8A%E8%A7%A3%E5%BF%A7%E6%9D%82%E8%B4%A7%E5%BA%97%E3%80%8B%E8%AF%BB%E4%B9%A6%E7%AC%94%E8%AE%B0%2F</url>
    <content type="text"><![CDATA[内容摘录第一章 回答在牛奶箱里 P49 “让深爱的人放弃梦想，这比死还让我痛苦。即使分隔两地，我们的心也会永远在一起。你不要有任何顾虑，我希望你无怨无悔地去追寻梦想。” 第三章 在思域车上等到天亮 P101 “不管是骚扰还是恶作剧，写这些信给浪失杂货店的人，和普通的咨询者再本质上是一样的。他们都是内心破了个洞，重要的东西正从那个破洞逐渐流失。” P106 “这么多年咨询信看下来，让我逐渐明白了一件事。很多时候，咨询的人心里已经有了答案，来咨询只是想确认自己的决定是对的。” P107 “或许雄治留恋的不是杂货店，二十烦恼咨询。他觉得一旦关了店离开这里，就不会有人来找他咨询了。” P175 “人与人之间情断义绝，并不需要什么具体的理由，就算表面上有，也很可能只是心已经离开的结果，事后才编造出的借口而已。因为倘若心没有离开，当将会导致关系破裂的事态发生时，理应有人努力去挽救。如果没有，说明其实关系早已破裂。所以那四个人谁也没有挽救披头士乐队，就像看客一般，眼睁睁看着船只沉没。” Last page “我衷心的祈祷你可以相信你自己，无悔地燃烧自己的人生。”]]></content>
      <categories>
        <category>阅读</category>
      </categories>
      <tags>
        <tag>阅读</tag>
        <tag>小说</tag>
        <tag>文学</tag>
        <tag>解忧杂货店</tag>
        <tag>东野圭吾</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[《如何阅读一本书》读书笔记]]></title>
    <url>%2F2018%2F07%2F13%2F%E3%80%8A%E5%A6%82%E4%BD%95%E9%98%85%E8%AF%BB%E4%B8%80%E6%9C%AC%E4%B9%A6%E3%80%8B%E8%AF%BB%E4%B9%A6%E7%AC%94%E8%AE%B0%2F</url>
    <content type="text"><![CDATA[内容摘录第一篇 阅读的层次第一章 阅读的活力与艺术 P9 “‘阅读的人’（readers），是指那些今天仍然习惯于从书写文字中汲取大量资讯，以增进对世界了解的人。” P10 “太多的咨询就如童太少的资讯一样，都是一种对理解力的阻碍。换句话说，现代的媒体正以压倒性的泛滥资讯阻碍了我们的理解力。” P11 “听众或读者的‘接收’，应该像是棒球赛中的捕手才对。……我们可以把这个类比的概念往前推。捕手的艺术就在能接住任何球的技巧——快速球、曲线球、变化球、慢速球等等。同样地，阅读的艺术也在尽可能掌握住每一种讯息的技巧。” P18 “蒙田说：‘初学者的无知在于未学’，而学者的无知在于学后。” P19 “倾听是从一位出现在你眼前的老师学习——一位活生生的老师——而阅读却是跟一位缺席的老师学习。如果你问一位活生生的老师一个问题，他可能会回答你。如果你还是不懂他的说的话，你可以再问他问题，省下自己思考的时间。然而如果你问一本书一个问题，你就必须自己回答这个问题。在这样的情况下，这本书就跟自然或世界一样。当你提出问题时，只有等你自己作了思考与分析之后，才会在书本上找到答案。” P22 “我们要懂得如何让书本来教导我们。事实上，这就是这本书最主要的目的。” 第二章 阅读的层次 阅读的四个层次，我们称之为基础阅读，检视阅读，分析阅读，主题阅读，这四个层次是渐进的。 P26 “如果说检视阅读是在涌现的时间内，最好也最完整的阅读，那么分析阅读就是在无限的时间里，最好也最完整的阅读。” P27 “弗兰西斯·培根曾今说过：‘有些书可以浅尝辄止，有些书是要生吞活剥，只有少数的书是要咀嚼与消化的。’分析阅读就是要咀嚼与消化一本书。” P27 “在做主题阅读时，阅读者会越读很多书，而不是一本书，并列举出这些书之间相关之处，提出一个所有的书都谈到的主题。但只是书本里字里行间的比较还不够。主题阅读涉及的远不止此。借助他所阅读的书籍，主题阅读这要能够架构出一个可能在哪一本书里都没提过的主题分析。” 第三章 阅读的第一个层次：基础阅读 P37 “我们的历史一直强调，无限制的受教育机会是一个社会能够提供给人民最有价值的服务——或说得正确一点，只有当一个人的自我期许，能力与需要受限制时，教育机会才会受到限制。我们还没有办法提供这种机会之前，不表示我们就有理由要放弃尝试。” 第四章 阅读的第二个层次：检视阅读 P39 “略读的i管应该用不着花太多时间，下面是要如何去做的一些建议：（1）先看书名页，然后如果有序就先看序。（2）研究目录页。（3）如果书中富有索引，也要检阅一下。（4）不妨读一下出版者的介绍。（5）开始挑几个看起来跟主题息息相关的篇章来看。（6）最后一步，把书打开翻看，有时候连续读几页，但不要太多。” P47 “拍摄下来的眼睛在活动时的影片，显示年轻或未受过训练的阅读者，在阅读一行字的时候会在五六个地方发生‘逗留’（fixate）现象。（眼睛在移动时看不见，只有停下来时才能看见。）因此，他们在读这一行字的时候，只能间隔着看到一个个单字或最多两三个字的组合。更糟的是，这些不熟练的阅读这在看过每两三行后，眼睛就自然地‘倒退’（regress）到原点——也就是说，他们又会倒退到先前读过的句子与那一行去了。所有这些习惯不但浪费而且显然降低了阅读的的速度。之所以说是浪费，因为我们的头脑跟眼睛不一样，并不需要一次只‘读’一个字或一个句子。我们的头脑是个惊人的工具，可以在‘一瞥’之间掌握住一个句子或段落——只要眼睛能提供足够资讯。” P50 “在阅读一本书的时候，慢不该慢到不值得，快不该快到有损于满足与理解。不论怎么说，阅读的速度，不论是快还是慢，只不过是阅读问题一个微笑的部分而已。” P51 “在第一次阅读一本很难得书时，不要企图了解每一个子句。这是最最重要的一个规则。这也是检视阅读的基本概念。不要害怕，或是但又自己似乎读得很肤浅。就算是最难读的书也快快地读一遍。当你再度第二次时，你就已经准备好要读这本书了。” 第五章 如何做一个自我要求的读者 P52 “在阅读的时候想要保持清醒，或昏昏入睡，主要看你的阅读目标是什么。如果你的月度目标是获得利益——不论是心灵或精神上的成长——你就得保持清醒。这也意味着在阅读时要尽可能地保持主动，同时还要做一番努力——而这番努力是会有回馈的。” P53 “关于一本书，你一定要提出四个主要的问题。（1）整体来说，这本书到底在谈些什么？（2）作者细部说了什么，怎么说的？（3）这本书说得有道理吗？是全部有道理。还是部分有道理（4）这本书跟你有什么关系？” P60 “所谓艺术或技巧，只属于哪个能养成习惯，而且能依照规则来运作的人。这也是艺术家或任何领域的工匠与众不同之处。” 第二篇 阅读的第三个层次：分析阅读第六章 一本书的分类 实用性vs.理论性作品，理论——是什么，实用——怎么做。 P74 “实用是与某种有效的做法有关，不管是立即或长程的功效。而理论所关注的却是去明白或了解某件事。” P74 “纯科学于应用科学的区别，或是像通常非常粗糙的那种说法，也就是科学与科技之间的区别。有些书或有些老师，只对他们要传达的知识本身感兴趣。这并不是说他们否定知识的实用性，或是他们坚持只该为知识而知识。他们知识将自己限制在某一种沟通或教学方式中，而让其他人去用别的方式。其他这些人的兴趣则在追求知识本身以外的事上，他们关切的是哪些知识能帮忙解决的人生问题。他们也传递知识，但永远带着一种强调知识的实际应用的观点。” P78 “质疑某件事的有效性是理论，而质疑任何事的目的，却是实用。” P75 “要让知识变成有用，就要有操作的规则。我们一定要超越‘知道这是怎么回事’，进而明白‘如果我想做些什么，应该怎么利用它’。”知与行的区别，而本书就是一本告诉我们该怎么做的实用的书。 P81 “如果一本理论的书所强调的内容，超乎你日常、理性、正常生活的经验，那就是科学的书。否则就是一本哲学的书。” 第七章 透视一本书 P85 “对于‘整体内容’这件事，光是一个模糊的认知是不够的，你必须要确切清楚地了解才行。只有一个方法能知道你是否成功了。你必须能用几句话，告诉你自己，或别人，这整本书在说的是什么。（如果你要说的话太多，表示你还没有将整体的内容看清楚，而只是看到了多样的内容。）” P106 “分析阅读的第一阶段，或，找出一本书在谈些什么的四个规则：（1）依照书本的种类与主题作分类。（2）用最简短的句子说出整本书在谈些什么。（3）按照顺序与关系，列出全书的重要部分。将全书的纲要拟出来之后，再将各个部分的纲要也一一列出。（4）找出作者在问的问题，或作者想要解决的问题。” 第八章 与作者找出共通的词义 P116 “就积极面来说，只要熟悉一下哪个领域，你就能找出这些专门的单字；就消极面来说，你只要看到不是平常惯见的单字，就会知道那些字一定是专门用语。” P116 “另外一个线索是，作者与其他作者争执的某个用语就是重要的字。” P119 “你一定要利用上下文自己已经了解的所有字句，来推敲出你所不了解的那个字的意义。” P132 “第五个规则：找出关键字，与作者达成共识。第六个规则可以说是：将一本书中最重要的句子圈起来，找出其中的主旨。第七个规则是：从相关文句的关联中，设法架构出一本书的基本论述。” P133 “从一个赌这的观点来看，对你重要的句子就是一些需要花一点努力来诠释的句子，因为你第一眼看到这些句子时并不能完全理解…….最重要的句子就是在整个论述中，阐述作者判断的部分。” 未完待续]]></content>
      <categories>
        <category>阅读</category>
      </categories>
      <tags>
        <tag>阅读</tag>
        <tag>社科</tag>
        <tag>如何阅读一本书</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[C++运算符重载与无名对象引用问题的一点思考]]></title>
    <url>%2F2018%2F06%2F16%2FC%2B%2B%E8%BF%90%E7%AE%97%E7%AC%A6%E9%87%8D%E8%BD%BD%E4%B8%8E%E6%97%A0%E5%90%8D%E5%AF%B9%E8%B1%A1%E5%BC%95%E7%94%A8%E9%97%AE%E9%A2%98%E7%9A%84%E4%B8%80%E7%82%B9%E6%80%9D%E8%80%83%2F</url>
    <content type="text"><![CDATA[问题的发现今天复习C++运算符重载时候的意外发现：关于类的临时对象以及引用的一些思考。来源于C++程序设计（小红书）上给出了“+”号运算符重载的样例。 基本知识回顾重载运算符的习惯 C++规定，赋值运算符=、下标运算符[]、函数调用运算符()、成员运算符-&gt;必须作为成员函数。 流插入运算符&lt;&lt; 和流提取运算符 &gt;&gt;、类型转换运算符不能定义为类的成员函数，只能作为友元函数。 一般将单目运算符和复合运算符重载为成员函数 一般将双目运算符重载为友元函数。NextSo 根据上述的习惯，我对着屏幕敲了书上的样例的类定义的代码。1234567891011121314151617181920212223242526272829303132333435363738394041424344class Complex&#123; public: Complex() &#123; real=0; imag=0; &#125; Complex(double d)&#123; real=d; imag=0; &#125; Complex(double r,double i)&#123; real =r; imag=i; &#125; friend Complex operator + (Complex &amp;a,Complex &amp;b); friend ostream&amp; operator &lt;&lt; (ostream &amp;,Complex &amp;); private: double real; double imag;&#125;;Complex operator +(Complex &amp;a,Complex &amp;b)&#123; Complex temp; temp.real=a.real+b.real; temp.imag=a.imag+b.imag; return temp;&#125;ostream&amp; operator &lt;&lt; (ostream&amp; output,Complex &amp;a )&#123; cout&lt;&lt;"("&lt;&lt;a.real&lt;&lt;","&lt;&lt;a.imag&lt;&lt;"i)"; return output;&#125;int main()&#123; Complex c1(3,4),c2(5,-10),c3; c3=c1+4.0; cout&lt;&lt;c3&lt;&lt;endl; c3=c3+c1; cout &lt;&lt;c3&lt;&lt;endl;&#125; 写完感觉看着是没什么问题对吧（我真觉的没什么问题）。然而运行了一下就报错了，那…报什么错了？ [Error] no match for &#39;operator+&#39; (operand types are &#39;Complex&#39; and &#39;double&#39;) [Note] candidates are: [Note] Complex operator+(Complex&amp;, Complex&amp;) [Note] no known conversion for argument 2 from &#39;Complex&#39; to &#39;Complex&amp;&#39; 哦哦看了下报错，原来是重载函数写的问题，我先去查了一下代码。 课本上给出的重载运算符声明和定义是： friend Complex operator + (Complex a,Complex b); ... 我自己看走眼敲成了： friend Complex operator + (Complex &amp;a,Complex &amp;b); ... 看出问题在哪了么？没错就是一个”&amp;”的差别，即形参是Complex类对象的引用还是Complex类对象。 问题展开与解决去掉”&amp;”后程序果然可以正常运行的。不过我考虑了一下程序的实现过程，不对啊，一个简单的相加，我传递一个类对象的引用不应该出现什么问题啊，”+”本身又不会对引用的对象进行什么操作，返回类型是一个Complex类的对象。问题出现在哪里了？ 一些奇葩（正经）的实验于是乎我把之前写的简单的”+”重载的程序，函数的形参都改为对象的引用，再运行。结果更奇怪了，除了上述程序，都没有报错。这个程序又独特在哪里了？ 问题点再返回去读一读程序，这个样例用到了转换构造函数。 c3=c1+4.0; 在保留注释掉以后程序果然可以正常运行了，问题确实出现在这里。既然是转换构造函数的问题，隐式调用（默认执行的）方式不可行，那我试一试显式的 c3=c1+Complex(4.0); 然而…报错依旧，只有微小的变化 [Error] no match for &#39;operator+&#39; (operand types are &#39;Complex&#39; and &#39;Complex&#39;) 对照之前的 [Error] no match for &#39;operator+&#39; (operand types are &#39;Complex&#39; and &#39;double&#39;) 原来最开始的程序并没有成功的调用转换构造函数。编译器没有检测到？看来是哪里出了什么之前没考虑过的问题。 思考（不摔桌！不摔桌！冷静！）如果通过引用进行参数传递，可以免去建立实参的拷贝，空间和时间上都可以得到优化，逻辑推理一下，那这种传参的方式应该被推行啊，相近的例子就是流提取和流插入运算符的重载，第二个参数都是自定义类的引用。 那…为何”+”的重载不采用这种方式呢？看来是有问题的，结合之前的实验，在不出现转换构造函数调用的情况下，形参为引用是行得通的。看来这个问题和转换构造函数也相关。 再回过头来看报错信息 [Error] no match for &#39;operator+&#39; (operand types are &#39;Complex&#39; and &#39;Complex&#39;) [Note] candidates are: [Note] Complex operator+(Complex&amp;, Complex&amp;) [Note] no known conversion for argument 2 from &#39;Complex&#39; to &#39;Complex&amp;&#39; 最后一句：Complex到Complex&amp;转换出了问题，这个比较稀奇。从类对象到类对象的引用不应该是顺理成章的事情么，别名而已。Emm问题就在这个别名身上 引用&lt;-&gt;别名转换构造函数出现的无名对象转换构造函数是构造函数的重载，在使用转换构造函数的过程中，我们可以建立一个有名对象，也可以建立一个无名对象。书上中的代码样例 Complex c1(3.5); //调用转换构造函数建立对象c1 Complex(3.6); //调用转换构造函数建立无名对象，合法，但无法使用。 就是这个无名对象的锅，我们回过头来看最开始发现的问题点： c3=c1+Complex(4.0); 由于Complex(4.0)建立的是一个无名对象，而采用我错误写出的以引用作为形参的 “+”运算符重载，会发生什么？没有名字，自然无法引用啊。这也就解释了报错信息为什么Complex到Complex&amp;转换出了问题。无名的对象无法建立引用（没名字你怎么给它找个别名）。 事后诸葛亮根据简单的实验其实能得到一些结论 涉及转换构造函数的运算符重载，形参都应该是类对象而不是类对象的引用。 C++自己实现的”=”应该也是用类对象作形参，因为 c1=Complex(3.6); 这一句是可以正常执行的。 算作对引用以及构造函数的一个探索吧:)]]></content>
      <categories>
        <category>编程</category>
      </categories>
      <tags>
        <tag>C++</tag>
        <tag>课程学习</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[【CSU-1895】解题报告（数学，矩阵快速幂）]]></title>
    <url>%2F2018%2F06%2F13%2F%E3%80%90CSU-1895%E3%80%91%E8%A7%A3%E9%A2%98%E6%8A%A5%E5%91%8A%EF%BC%88%E6%95%B0%E5%AD%A6%EF%BC%8C%E7%9F%A9%E9%98%B5%E5%BF%AB%E9%80%9F%E5%B9%82%EF%BC%89%2F</url>
    <content type="text"><![CDATA[原始题目1895: Apache is late again Time Limit: 1 Sec Memory Limit: 128 Mb Submitted: 141 Solved: 45 DescriptionApache is a student of CSU. There is a math class every Sunday morning, but he is a very hard man who learns late every night. Unfortunate, he was late for maths on Monday. Last week the math teacher gave a question to let him answer as a punishment, but he was easily resolved. So the math teacher prepared a problem for him to solve. Although Apache is very smart, but also was stumped. So he wants to ask you to solve the problem. Questions are as follows: You can find a m made (1 + sqrt (2)) ^ n can be decomposed into sqrt (m) + sqrt (m-1), if you can output $m% 100000007$ otherwise output No. InputThere are multiply cases. Each case is a line of $n (|n| \le 10 ^ {18})$ OutputLine, if there is no such m output No, otherwise output m% 100,000,007. Sample Input2 Sample Output9 HintSource中南大学第十一届大学生程序设计竞赛 题目大意给定n，若${1 + \sqrt {2}} ^ n$，能表示成$\sqrt {m} + \sqrt {m-1}$，则输出m，否则输出No 解题思路当$n&gt;0$时,试着写出前几项 $(1+\sqrt{2})^1=\sqrt{2}+\sqrt{1}=\sqrt{1^2+1}+\sqrt{1^2}$ $(1+\sqrt{2})^2=\sqrt{9}+\sqrt{8}=\sqrt{3^2}+\sqrt{3^2-1}$ $(1+\sqrt{2})^3=\sqrt{50}+\sqrt{49}=\sqrt{7^2+1}+\sqrt{7^2}$ $(1+\sqrt{2})^4=\sqrt{289}+\sqrt{288}=\sqrt{17^2}+\sqrt{17^2-1}$ 若只观察含有$\sqrt{2}$的项，我们能得到下面的数列 a_1=1,a_2=2,a_3=5,a_4=12,\cdots可以看作是一个二阶差分方程，其通项的矩阵表达 \begin{bmatrix} a_n \\ a_{n-1} \\ \end{bmatrix}=\begin{bmatrix} 2&1 \\1&0 \end{bmatrix}\begin{bmatrix} a_{n-1}\\ a_{n-2}\end{bmatrix}={\begin{bmatrix} 2&1\\ 1&0\end{bmatrix} }^{n-2}\begin{bmatrix}a_2\\ a_1 \end{bmatrix}给定$a_1=1$，$a_2=2$，通过矩阵快速幂计算$a_n$ 解题代码123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293#include &lt;cstdio&gt;#include &lt;cstring&gt;#include &lt;iostream&gt;#include &lt;set&gt;#include &lt;queue&gt;#define mod 100000007 //这里定义模 using namespace std;const int maxn=1e5+5;typedef long long ll;struct Matrix&#123; ll a[2][2]; Matrix() &#123; memset(a,0,sizeof(a)); &#125; Matrix operator * (const Matrix y) &#123; Matrix ans; for(int i = 0; i &lt; 2; i++) for(int j = 0; j &lt; 2; j++) for(int k = 0; k &lt; 2; k++) ans.a[i][j] += (a[i][k]*y.a[k][j])%mod; return ans; &#125; Matrix operator = (const Matrix y) &#123; for(int i=0;i&lt;2;i++) for(int j=0;j&lt;2;j++) a[i][j]=y.a[i][j]; &#125; Matrix operator *= (const Matrix y) &#123; Matrix ans; for(int i=0;i&lt;2;i++) for(int j=0;j&lt;2;j++) for(int k=0;k&lt;2;k++) ans.a[i][j] += (a[i][k]*y.a[k][j])%mod; for(int i=0;i&lt;2;i++) for(int j=0;j&lt;2;j++) a[i][j]=ans.a[i][j]; &#125;&#125;;Matrix qpow(ll x)&#123; Matrix ans; ans.a[0][0]=ans.a[1][1]=1; //单位矩阵 Matrix mul; mul.a[0][0]=2; mul.a[0][1]=mul.a[1][0]=1; while(x) &#123; if(x&amp;1) ans *= mul; mul *= mul; x&gt;&gt;=1; &#125; return ans;&#125;ll pow(ll a,ll b)&#123; ll ans=1; while(b) &#123; if(b&amp;1) ans=(ans*a%mod); a=a*a%mod; b&gt;&gt;=1; &#125; return ans; &#125;ll n;int main()&#123; while(~scanf("%lld",&amp;n)) &#123; if(n&lt;0) printf("No\n"); else if(n==0) printf("1\n"); else if(n==1) printf("2\n"); else if(n==2) printf("9\n"); else if(n==3) printf("50\n"); else &#123; Matrix m=qpow(n-2); ll ans=(m.a[0][0]*2%mod+m.a[0][1]%mod)%mod; if(n&amp;1) printf("%lld\n",ans*ans*2%mod); else printf("%lld\n",(ans*ans%mod*2+1)%mod); &#125; &#125;&#125; 收获与反思 矩阵快速幂练习 注意n&lt;0时候输出No，因为这个T了好几次。]]></content>
      <categories>
        <category>编程</category>
        <category>ACM</category>
      </categories>
      <tags>
        <tag>算法</tag>
        <tag>ACM</tag>
        <tag>2018春季训练</tag>
        <tag>CSU</tag>
        <tag>矩阵快速幂</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[【CSU-2138】解题报告（数学，矩阵快速幂）]]></title>
    <url>%2F2018%2F06%2F13%2F%E3%80%90CSU-2138%E3%80%91%E8%A7%A3%E9%A2%98%E6%8A%A5%E5%91%8A%EF%BC%88%E6%95%B0%E5%AD%A6%EF%BC%8C%E7%9F%A9%E9%98%B5%E5%BF%AB%E9%80%9F%E5%B9%82%EF%BC%89%2F</url>
    <content type="text"><![CDATA[原始题目2138: Rikka’s Set Time Limit: 1 Sec Memory Limit: 128 Mb Submitted: 44 Solved: 11 DescriptionRikka is poor at math. Now she asks you for help. A set is known as extraordinary set when the minimum integer of it is equal to its size.min{x : x ∈ S}=|S|For example, S = {3, 7, 8} is extraordinary. gn is the number of extraodinary subsets of {1, 2, …, n}. Rikka wants to know the value of gn. InputInput consists of one integer n(1 ≤ n ≤ 1018) OutputOutput a single integer gnmod1000000009 Sample Input16 Sample Output987 HintSourceAuthorxm 题目大意给定一个{1,2,3……n}的集合，问有多少个集合中元素个数等于集合中元素最小值的子集。 解题思路 对于给定的n， n=1，易知为1 n=2，易知为1 n&gt;=3，我们很容易根据题目想到答案的表达式Mathjax显示不出来好吧。。。就是 C(n-i,i-1) i从2到n的求和+1。 列出前几项，我们发现实际为斐波那契数列（等价证明还没想明白） 运用矩阵快速幂可得到答案。 解题代码12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364656667686970717273747576777879808182838485868788899091#include &lt;cstdio&gt;#include &lt;cstring&gt;#include &lt;iostream&gt;#include &lt;set&gt;#include &lt;queue&gt;#define mod 1000000009 //这里定义模 using namespace std;const int maxn=1e5+5;typedef long long ll;struct Matrix&#123; ll a[2][2]; Matrix() &#123; memset(a,0,sizeof(a)); &#125; Matrix operator * (const Matrix y) &#123; Matrix ans; for(int i = 0; i &lt; 2; i++) for(int j = 0; j &lt; 2; j++) for(int k = 0; k &lt; 2; k++) ans.a[i][j] += (a[i][k]*y.a[k][j])%mod; return ans; &#125; Matrix operator = (const Matrix y) &#123; for(int i=0;i&lt;2;i++) for(int j=0;j&lt;2;j++) a[i][j]=y.a[i][j]; &#125; Matrix operator *= (const Matrix y) &#123; Matrix ans; for(int i=0;i&lt;2;i++) for(int j=0;j&lt;2;j++) for(int k=0;k&lt;2;k++) ans.a[i][j] += (a[i][k]*y.a[k][j])%mod; for(int i=0;i&lt;2;i++) for(int j=0;j&lt;2;j++) a[i][j]=ans.a[i][j]; &#125;&#125;; Matrix qpow(ll x)&#123; Matrix ans; ans.a[0][0]=ans.a[1][1]=1; //单位矩阵 Matrix mul; mul.a[0][0]=mul.a[0][1]=mul.a[1][0]=1; while(x) &#123; if(x&amp;1) ans *= mul; mul*=mul; x&gt;&gt;=1; &#125; return ans;&#125;ll pow(ll a,ll b)&#123; ll ans=1; while(b) &#123; if(b&amp;1) ans=(ans*a%mod); a=a*a%mod; b&gt;&gt;=1; &#125; return ans; &#125;ll n;int main()&#123; while(~scanf("%lld",&amp;n)) &#123; if(n==1) printf("1\n"); else if(n==2) printf("1\n"); else if(n==3) printf("2\n"); else if(n==4) printf("3\n"); else if(n==5) printf("5\n"); else &#123; Matrix m=qpow(n-2); printf("%lld\n",(m.a[0][0]+m.a[0][1])%mod); &#125; &#125;&#125; 收获与反思 多尝试一下前几项，发现规律 矩阵快速幂练习]]></content>
      <categories>
        <category>编程</category>
        <category>ACM</category>
      </categories>
      <tags>
        <tag>算法</tag>
        <tag>ACM</tag>
        <tag>2018春季训练</tag>
        <tag>CSU</tag>
        <tag>矩阵快速幂</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[【AtCoder-4152】解题报告（数学，进制，贪心）]]></title>
    <url>%2F2018%2F06%2F11%2F%E3%80%90AtCoder-4152%E3%80%91%E8%A7%A3%E9%A2%98%E6%8A%A5%E5%91%8A%EF%BC%88%E6%95%B0%E5%AD%A6%EF%BC%8C%E8%BF%9B%E5%88%B6%EF%BC%8C%E8%B4%AA%E5%BF%83%EF%BC%89%2F</url>
    <content type="text"><![CDATA[原始题目C - Strange Bank Time limit : 2sec Memory limit : 256MB Score : 300 points Problem StatementTo make it difficult to withdraw money, a certain bank allows its customers to withdraw only one of the following amounts in one operation: 1 yen (the currency of Japan) 6 yen, 62(=36) yen, 63(=216) yen, … 9 yen, 92(=81) yen, 93(=729) yen, … At least how many operations are required to withdraw exactly N yen in total? It is not allowed to re-deposit the money you withdrew. Constraints1≤N≤100000N is an integer. InputInput is given from Standard Input in the following format: N OutputIf at least x operations are required to withdraw exactly N yen in total, print x. Sample Input 1127 Sample Output 14 By withdrawing 1 yen, 9 yen, 36(=62) yen and 81(=92) yen, we can withdraw 127 yen in four operations. Sample Input 23 Sample Output 23 By withdrawing 1 yen three times, we can withdraw 3 yen in three operations. Sample Input 344852 Sample Output 316 题目大意规定三种取钱的方法，一次可以取1元，6^k元或者9^k元 （k&gt;=1） ，问取n元最少的次数是多少。 解题思路将n拆成i和n-i。分别用6和9进制表示，维护系数和最小值即可。 解题代码123456789101112131415161718192021222324#include &lt;cstdio&gt;#include &lt;iostream&gt; using namespace std;int n;int main()&#123; while(~scanf("%d" ,&amp;n)) &#123; int res=n; //最大情况肯定为n次 全部每次取1元 for(int i=0;i&lt;=n;i++) &#123; int cc=0; int t=i; while(t) cc+=t%6,t/=6; //计算6进制的系数和 t=n-i; while(t) cc+=t%9,t/=9; //计算9进制的系数和 if(res&gt;cc) res=cc; &#125; printf("%d\n",res); &#125;&#125; 收获与反思 理解题意，三种方法算最小值其实就是求一个数用6/9进制混合表达的系数最小值。 把n拆成两部分，维护系数最小值。 while(t) cc+=t%k,t/=k; 该方法得到的cc为t用k进制表达的系数和。]]></content>
      <categories>
        <category>编程</category>
        <category>ACM</category>
      </categories>
      <tags>
        <tag>算法</tag>
        <tag>ACM</tag>
        <tag>AtCoder</tag>
        <tag>math</tag>
        <tag>2018春季训练</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[【CodeForces-978F】解题报告（二分，排序，数据结构）]]></title>
    <url>%2F2018%2F06%2F01%2F%E3%80%90CodeForces-978F%E3%80%91%E8%A7%A3%E9%A2%98%E6%8A%A5%E5%91%8A%EF%BC%88%E4%BA%8C%E5%88%86%EF%BC%8C%E6%8E%92%E5%BA%8F%EF%BC%8C%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%EF%BC%89%2F</url>
    <content type="text"><![CDATA[原始题目Mentors time limit per test3 seconds memory limit per test256 megabytes inputstandard input outputstandard output In BerSoft n programmers work, the programmer i is characterized by a skill ri. A programmer a can be a mentor of a programmer b if and only if the skill of the programmer a is strictly greater than the skill of the programmer b (ra&gt;rb) and programmers a and b are not in a quarrel. You are given the skills of each programmers and a list of k pairs of the programmers, which are in a quarrel (pairs are unordered). For each programmer i, find the number of programmers, for which the programmer i can be a mentor. InputThe first line contains two integers n and k (2≤n≤2⋅105, 0≤k≤min(2⋅105,n⋅(n−1)2)) — total number of programmers and number of pairs of programmers which are in a quarrel. The second line contains a sequence of integers r1,r2,…,rn (1≤ri≤109), where ri equals to the skill of the i-th programmer. Each of the following k lines contains two distinct integers x, y (1≤x,y≤n, x≠y) — pair of programmers in a quarrel. The pairs are unordered, it means that if x is in a quarrel with y then y is in a quarrel with x. Guaranteed, that for each pair (x,y) there are no other pairs (x,y) and (y,x) in the input. OutputPrint n integers, the i-th number should be equal to the number of programmers, for which the i-th programmer can be a mentor. Programmers are numbered in the same order that their skills are given in the input. ExamplesInput4 2 10 4 10 15 1 2 4 3 Output0 0 1 2 Input10 4 5 4 1 5 4 3 7 1 2 5 4 6 2 1 10 8 3 5 Output5 4 0 5 3 3 9 0 2 5 NoteIn the first example, the first programmer can not be mentor of any other (because only the second programmer has a skill, lower than first programmer skill, but they are in a quarrel). The second programmer can not be mentor of any other programmer, because his skill is minimal among others. The third programmer can be a mentor of the second programmer. The fourth programmer can be a mentor of the first and of the second programmers. He can not be a mentor of the third programmer, because they are in a quarrel. 题目大意给定n个人员skill值，并给出k个有矛盾的对，对于每个人，可以做skill值比自己小且没有矛盾人的导师。输出每一个人可做多少人的导师。 解题思路 排序后对每个人的skill值二分查找，存储到ans[]中。 对于每个矛盾对，skill值大的ans减1即可。 解题代码12345678910111213141516171819202122232425262728293031323334353637383940414243444546#include &lt;iostream&gt;#include &lt;cstdio&gt;#include &lt;iomanip&gt;#include &lt;cstring&gt;#include &lt;map&gt;#include &lt;set&gt;#include &lt;queue&gt;#include &lt;algorithm&gt;#define eps 1e-8#define INF 0x3f3f3f3fusing namespace std;typedef long long ll;const int maxn=2e5+5;ll a[maxn],b[maxn];int ans[maxn],n,t,k;int main()&#123; while(~scanf("%d%d",&amp;n,&amp;k)) &#123; for(int i=0;i&lt;n;i++) &#123; scanf("%I64d",&amp;a[i]); b[i]=a[i]; &#125; sort(b,b+n); for(int i=0;i&lt;n;i++) &#123; ans[i]=lower_bound(b,b+n,a[i])-b;// printf("--%d--\n",ans[i]); &#125; for(int i=0;i&lt;k;i++) &#123; int temp1,temp2; scanf("%d%d",&amp;temp1,&amp;temp2); if(a[temp1-1]&gt;a[temp2-1]) ans[temp1-1]--; else if(a[temp2-1]&gt;a[temp1-1]) ans[temp2-1]--; &#125; for(int i=0;i&lt;n;i++) &#123; if(i==0) printf("%d",ans[i]); else printf(" %d",ans[i]); &#125; printf("\n"); &#125;&#125; 收获与反思 二分查找 lower_bound的运用。 注意quarrel列的在线计算。]]></content>
      <categories>
        <category>编程</category>
        <category>ACM</category>
      </categories>
      <tags>
        <tag>算法</tag>
        <tag>ACM</tag>
        <tag>2018春季训练</tag>
        <tag>二分</tag>
        <tag>CodeForces</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[【CodeForces-978E】解题报告（暴力，数学）]]></title>
    <url>%2F2018%2F06%2F01%2F%E3%80%90CodeForces-978E%E3%80%91%E8%A7%A3%E9%A2%98%E6%8A%A5%E5%91%8A%EF%BC%88%E6%9A%B4%E5%8A%9B%EF%BC%8C%E6%95%B0%E5%AD%A6%EF%BC%89%2F</url>
    <content type="text"><![CDATA[原始题目Bus Video System time limit per test1 second memory limit per test256 megabytes inputstandard input outputstandard output The busses in Berland are equipped with a video surveillance system. The system records information about changes in the number of passengers in a bus after stops. If x is the number of passengers in a bus just before the current bus stop and y is the number of passengers in the bus just after current bus stop, the system records the number y−x. So the system records show how number of passengers changed. The test run was made for single bus and n bus stops. Thus, the system recorded the sequence of integers a1,a2,…,an (exactly one number for each bus stop), where ai is the record for the bus stop i. The bus stops are numbered from 1 to n in chronological order. Determine the number of possible ways how many people could be in the bus before the first bus stop, if the bus has a capacity equals to w (that is, at any time in the bus there should be from 0 to w passengers inclusive). InputThe first line contains two integers n and w (1≤n≤1000,1≤w≤109) — the number of bus stops and the capacity of the bus. The second line contains a sequence a1,a2,…,an (−106≤ai≤106), where ai equals to the number, which has been recorded by the video system after the i-th bus stop. OutputPrint the number of possible ways how many people could be in the bus before the first bus stop, if the bus has a capacity equals to w. If the situation is contradictory (i.e. for any initial number of passengers there will be a contradiction), print 0. ExamplesInput3 5 2 1 -3 Output3 Input2 4 -1 1 Output4 Input4 10 2 4 1 2 Output2 NoteIn the first example initially in the bus could be 0, 1 or 2 passengers. In the second example initially in the bus could be 1, 2, 3 or 4 passengers. In the third example initially in the bus could be 0 or 1 passenger. 题目大意给定公交车经历的站数和最大容载量，并给出在各个公交站上/下车的人数，求最初车上人数有几种可能。 解题思路初始sum为0，上下车人数，记录最大值和最小值，计算最大差值，ans=m-(mmax-mmin)+1。 解题代码12345678910111213141516171819202122232425262728293031323334#include &lt;cstdio&gt;#include &lt;cstring&gt;#include &lt;iostream&gt;#include &lt;set&gt;#include &lt;queue&gt;#include &lt;map&gt;#include &lt;vector&gt;#include &lt;algorithm&gt;#define eps 1e-8#define INF 0x3f3f3f3fusing namespace std;const int maxn=2e5+5;typedef long long ll;ll b[maxn],d[maxn],n,m,t,sum,ans;int main()&#123; while(~scanf("%I64d%I64d",&amp;n,&amp;m)) &#123; sum=0; ll mmax=0,mmin=0; for(int i=1;i&lt;=n;i++) &#123; scanf("%I64d",&amp;b[i]); sum+=b[i]; if(sum&gt;mmax) mmax=sum; if(sum&lt;mmin) mmin=sum; &#125;// printf("%I64d %I64d\n",mmin,mmax); ll ans=m-(mmax-mmin)+1; if(ans&lt;=0) printf("0\n"); else printf("%I64d\n",ans); &#125;&#125; 收获与反思 简单数学问题]]></content>
      <categories>
        <category>编程</category>
        <category>ACM</category>
      </categories>
      <tags>
        <tag>算法</tag>
        <tag>ACM</tag>
        <tag>math</tag>
        <tag>2018春季训练</tag>
        <tag>CodeForces</tag>
        <tag>暴力</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[【CodeForces-978D】解题报告（暴力，数学讨论）]]></title>
    <url>%2F2018%2F06%2F01%2F%E3%80%90CodeForces-978D%E3%80%91%E8%A7%A3%E9%A2%98%E6%8A%A5%E5%91%8A%EF%BC%88%E6%9A%B4%E5%8A%9B%EF%BC%8C%E6%95%B0%E5%AD%A6%E8%AE%A8%E8%AE%BA%EF%BC%89%2F</url>
    <content type="text"><![CDATA[原始题目Almost Arithmetic Progression time limit per test1 second memory limit per test256 megabytes inputstandard input outputstandard output Polycarp likes arithmetic progressions. A sequence [a1,a2,…,an] is called an arithmetic progression if for each i (1≤i&lt;n) the value ai+1−ai is the same. For example, the sequences [42], [5,5,5], [2,11,20,29] and [3,2,1,0] are arithmetic progressions, but [1,0,1], [1,3,9] and [2,3,1] are not. It follows from the definition that any sequence of length one or two is an arithmetic progression. Polycarp found some sequence of positive integers [b1,b2,…,bn]. He agrees to change each element by at most one. In the other words, for each element there are exactly three options: an element can be decreased by 1, an element can be increased by 1, an element can be left unchanged. Determine a minimum possible number of elements in b which can be changed (by exactly one), so that the sequence b becomes an arithmetic progression, or report that it is impossible. It is possible that the resulting sequence contains element equals 0. InputThe first line contains a single integer n (1≤n≤100000) — the number of elements in b. The second line contains a sequence b1,b2,…,bn (1≤bi≤109). OutputIf it is impossible to make an arithmetic progression with described operations, print -1. In the other case, print non-negative integer — the minimum number of elements to change to make the given sequence becomes an arithmetic progression. The only allowed operation is to add/to subtract one from an element (can’t use operation twice to the same position). ExamplesInput4 24 21 14 10 Output3 Input2 500 500 Output0 Input3 14 5 1 Output-1 Input5 1 3 6 9 12 Output1 NoteIn the first example Polycarp should increase the first number on 1, decrease the second number on 1, increase the third number on 1, and the fourth number should left unchanged. So, after Polycarp changed three elements by one, his sequence became equals to [25,20,15,10], which is an arithmetic progression. In the second example Polycarp should not change anything, because his sequence is an arithmetic progression. In the third example it is impossible to make an arithmetic progression. In the fourth example Polycarp should change only the first element, he should decrease it on one. After that his sequence will looks like [0,3,6,9,12], which is an arithmetic progression. 题目大意给定一组数，对每一个数可以不操作，或者+1，或者-1（加减记录改变次数），问这一组数是否可以通过操作变为等差数列 若可以，输出所需改变次数的最小值。 若不可以，输出-1. 解题思路对每种可能的gap遍历数据，更新需要更改的次数的最小值。gap由前两项a[0],a[1]确定，共有9种可能。确定gap后开始从a[2]开始遍历数组，一旦出现不符合则跳出，全部符合则更新最小操作数。 解题代码12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364656667686970717273747576777879808182838485868788#include &lt;cstdio&gt;#include &lt;cmath&gt;#include &lt;cstring&gt;#include &lt;iostream&gt;#include &lt;set&gt;#include &lt;string&gt;#include &lt;iomanip&gt;#include &lt;algorithm&gt;#include &lt;queue&gt;#include &lt;vector&gt;#include &lt;map&gt;#define INF 0x3f3f3f3f#define eps 1e-8using namespace std;const int maxn=1e5+5;typedef long long ll;ll a[maxn+10];int ans; int n,m,t;int main()&#123; while(~scanf("%d",&amp;n)) &#123; ans=INF; for(int i=0;i&lt;n;i++) scanf("%I64d",&amp;a[i]); if(n==1) &#123; printf("0\n"); continue; &#125; ll gap=a[1]-a[0]; ll origin0=a[0],origin1=a[1],ogap=a[1]-a[0]; //第一种情况 for(int i=0;i&lt;9;i++) &#123; int ccnt=0; if(i==0) a[0]=origin0-1,a[1]=origin1-1,ccnt=2; else if(i==1) a[0]=origin0,a[1]=origin1-1,ccnt=1; else if(i==2) a[0]=origin0+1,a[1]=origin1-1,ccnt=2; else if(i==3) a[0]=origin0-1,a[1]=origin1,ccnt=1; else if(i==4) a[0]=origin0,a[1]=origin1,ccnt=0; else if(i==5) a[0]=origin0+1,a[1]=origin1,ccnt=1; else if(i==6) a[0]=origin0-1,a[1]=origin1+1,ccnt=2; else if(i==7) a[0]=origin0,a[1]=origin1+1,ccnt=1; else if(i==8) a[0]=origin0+1,a[1]=origin1+1,ccnt=2; gap=a[1]-a[0]; //开始遍历剩余 int j=2; ll last=a[1]; for(;j&lt;n;j++) &#123;// printf("before a[j]-last=%d\n",a[j]-last); if(a[j]-last==gap) &#123; last=a[j]; continue; &#125; else if(a[j]-last==gap+1) &#123; last=a[j]-1; ccnt++; continue; &#125; else if(a[j]-last==gap-1) &#123; last=a[j]+1; ccnt++; continue; &#125; else break; &#125; if(j==n) ans=min(ans,ccnt); &#125; if(ans==INF) printf("-1\n"); else printf("%d\n",ans); &#125;&#125; 收获与反思 想到可能的等差gap值。 暴力遍历每种gap的可能。]]></content>
      <categories>
        <category>编程</category>
        <category>ACM</category>
      </categories>
      <tags>
        <tag>算法</tag>
        <tag>ACM</tag>
        <tag>math</tag>
        <tag>2018春季训练</tag>
        <tag>CodeForces</tag>
        <tag>暴力</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[【CodeForces-978C】解题报告（水题，前缀和）]]></title>
    <url>%2F2018%2F06%2F01%2F%E3%80%90CodeForces-978C%E3%80%91%E8%A7%A3%E9%A2%98%E6%8A%A5%E5%91%8A%EF%BC%88%E6%B0%B4%E9%A2%98%EF%BC%8C%E5%89%8D%E7%BC%80%E5%92%8C%EF%BC%89%2F</url>
    <content type="text"><![CDATA[原始题目Letters time limit per test4 seconds memory limit per test256 megabytes inputstandard input outputstandard output There are n dormitories in Berland State University, they are numbered with integers from 1 to n. Each dormitory consists of rooms, there are ai rooms in i-th dormitory. The rooms in i-th dormitory are numbered from 1 to ai. A postman delivers letters. Sometimes there is no specific dormitory and room number in it on an envelope. Instead of it only a room number among all rooms of all n dormitories is written on an envelope. In this case, assume that all the rooms are numbered from 1 to a1+a2+⋯+an and the rooms of the first dormitory go first, the rooms of the second dormitory go after them and so on. For example, in case n=2, a1=3 and a2=5 an envelope can have any integer from 1 to 8 written on it. If the number 7 is written on an envelope, it means that the letter should be delivered to the room number 4 of the second dormitory. For each of m letters by the room number among all n dormitories, determine the particular dormitory and the room number in a dormitory where this letter should be delivered. InputThe first line contains two integers n and m (1≤n,m≤2⋅105) — the number of dormitories and the number of letters. The second line contains a sequence a1,a2,…,an (1≤ai≤1010), where ai equals to the number of rooms in the i-th dormitory. The third line contains a sequence b1,b2,…,bm (1≤bj≤a1+a2+⋯+an), where bj equals to the room number (among all rooms of all dormitories) for the j-th letter. All bj are given in increasing order. OutputPrint m lines. For each letter print two integers f and k — the dormitory number f (1≤f≤n) and the room number k in this dormitory (1≤k≤af) to deliver the letter. ExamplesInput3 6 10 15 12 1 9 12 23 26 37 Output1 1 1 9 2 2 2 13 3 1 3 12 Input2 3 5 10000000000 5 6 9999999999 Output1 5 2 1 2 9999999994 NoteIn the first example letters should be delivered in the following order: the first letter in room 1 of the first dormitory the second letter in room 9 of the first dormitory the third letter in room 2 of the second dormitory the fourth letter in room 13 of the second dormitory the fifth letter in room 1 of the third dormitory the sixth letter in room 12 of the third dormitory 题目大意给出n个公寓的房间数，给出从第一个房间开始计数的房间号，要求输出按公寓分开后每个房间对应的公寓号码和在本公寓的房间号码 解题思路根据n个公寓的房间数处理出前缀和，顺序遍历前缀和数组，对每个查询求差值即可。 解题代码123456789101112131415161718192021222324252627282930313233343536373839404142434445464748#include &lt;cstdio&gt;#include &lt;cstring&gt;#include &lt;iostream&gt;#include &lt;set&gt;#include &lt;queue&gt;#include &lt;map&gt;#include &lt;vector&gt;#include &lt;algorithm&gt;#define eps 1e-8#define INF 0x3f3f3f3fusing namespace std;const int maxn=2e5+5;typedef long long ll;ll gcd(ll a,ll b)&#123; return a?gcd(b%a,a):b;&#125;ll lcm(ll a,ll b)&#123; return a/gcd(a,b)*b; &#125; ll n,m,vis[maxn],ans[maxn],cnt;ll a[maxn],sum[maxn];int main()&#123; while(~scanf("%lld%d",&amp;n,&amp;m)) &#123; sum[0]=0; for(ll i=1;i&lt;=n;i++) &#123; scanf("%lld",&amp;sum[i]); sum[i]+=sum[i-1]; //处理前缀和 &#125; ll temp; ll j=0; for(ll i=0;i&lt;m;i++) &#123; scanf("%I64d",&amp;temp); while(temp&gt;sum[j]) j++; printf("%I64d %I64d\n",j,temp-sum[j-1]); &#125; &#125;&#125; 收获与反思前缀和应用。注意如果查询不按顺序的话应该采用二分查找。]]></content>
      <categories>
        <category>编程</category>
        <category>ACM</category>
      </categories>
      <tags>
        <tag>算法</tag>
        <tag>ACM</tag>
        <tag>2018春季训练</tag>
        <tag>水题</tag>
        <tag>CodeForces</tag>
        <tag>前缀和</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[【CodeForces-978B】解题报告（水题，贪心，字符串）]]></title>
    <url>%2F2018%2F06%2F01%2F%E3%80%90CodeForces-978B%E3%80%91%E8%A7%A3%E9%A2%98%E6%8A%A5%E5%91%8A%EF%BC%88%E6%B0%B4%E9%A2%98%EF%BC%8C%E8%B4%AA%E5%BF%83%EF%BC%8C%E5%AD%97%E7%AC%A6%E4%B8%B2%EF%BC%89%2F</url>
    <content type="text"><![CDATA[原始题目File Name time limit per test1 second memory limit per test256 megabytes inputstandard input outputstandard output You can not just take the file and send it. When Polycarp trying to send a file in the social network “Codehorses”, he encountered an unexpected problem. If the name of the file contains three or more “x” (lowercase Latin letters “x”) in a row, the system considers that the file content does not correspond to the social network topic. In this case, the file is not sent and an error message is displayed. Determine the minimum number of characters to remove from the file name so after that the name does not contain “xxx” as a substring. Print 0 if the file name does not initially contain a forbidden substring “xxx”. You can delete characters in arbitrary positions (not necessarily consecutive). If you delete a character, then the length of a string is reduced by 1. For example, if you delete the character in the position 2 from the string “exxxii”, then the resulting string is “exxii”. InputThe first line contains integer n (3≤n≤100) — the length of the file name. The second line contains a string of length n consisting of lowercase Latin letters only — the file name. OutputPrint the minimum number of characters to remove from the file name so after that the name does not contain “xxx” as a substring. If initially the file name dost not contain a forbidden substring “xxx”, print 0. ExamplesInput6 xxxiii Output1 Input5 xxoxx Output0 Input10 xxxxxxxxxx Output8 NoteIn the first example Polycarp tried to send a file with name contains number 33, written in Roman numerals. But he can not just send the file, because it name contains three letters “x” in a row. To send the file he needs to remove any one of this letters. 题目大意文件名中超过n个（n&gt;=3）连续的x时需要修改n-2次。 解题思路每次贪心的取最大连续个x值，然后判断累加即可。 解题代码12345678910111213141516171819202122232425262728293031323334353637383940414243444546#include &lt;cstdio&gt;#include &lt;cstring&gt;#include &lt;iostream&gt;#include &lt;set&gt;#include &lt;queue&gt;#include &lt;map&gt;#include &lt;vector&gt;#include &lt;algorithm&gt;#define eps 1e-8#define INF 0x3f3f3f3fusing namespace std;const int maxn=1e5+5;typedef long long ll;ll gcd(ll a,ll b)&#123; return a?gcd(b%a,a):b;&#125;ll lcm(ll a,ll b)&#123; return a/gcd(a,b)*b; &#125; int n,m,vis[maxn],ans[maxn],cnt;char a[maxn];int main()&#123; while(~scanf("%d",&amp;n)) &#123; getchar(); cnt=0; int ccnt=0;char temp; gets(a); for(int i=0;i&lt;n;i++) &#123; if(a[i]=='x') ccnt++; else &#123; if(ccnt&gt;=3) cnt+=ccnt-2; ccnt=0; &#125; &#125; if(ccnt&gt;=3) cnt+=ccnt-2; printf("%d\n",cnt); &#125; &#125; 收获与反思字符串简单贪心]]></content>
      <categories>
        <category>编程</category>
        <category>ACM</category>
      </categories>
      <tags>
        <tag>算法</tag>
        <tag>ACM</tag>
        <tag>2018春季训练</tag>
        <tag>Greedy</tag>
        <tag>CodeForces</tag>
        <tag>字符串</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[【CodeForces-978A】解题报告（水题）]]></title>
    <url>%2F2018%2F06%2F01%2F%E3%80%90CodeForces-978A%E3%80%91%E8%A7%A3%E9%A2%98%E6%8A%A5%E5%91%8A%EF%BC%88%E6%B0%B4%E9%A2%98%EF%BC%89%2F</url>
    <content type="text"><![CDATA[原始题目Remove Duplicates time limit per test1 second memory limit per test256 megabytes inputstandard input outputstandard output Petya has an array a consisting of n integers. He wants to remove duplicate (equal) elements. Petya wants to leave only the rightmost entry (occurrence) for each element of the array. The relative order of the remaining unique elements should not be changed. InputThe first line contains a single integer n (1≤n≤50) — the number of elements in Petya’s array. The following line contains a sequence a1,a2,…,an (1≤ai≤1000) — the Petya’s array. OutputIn the first line print integer x — the number of elements which will be left in Petya’s array after he removed the duplicates. In the second line print x integers separated with a space — Petya’s array after he removed the duplicates. For each unique element only the rightmost entry should be left. ExamplesInput6 1 5 5 1 6 1 Output3 5 6 1 Input5 2 4 2 4 4 Output2 2 4 Input5 6 6 6 6 6 Output1 6 NoteIn the first example you should remove two integers 1, which are in the positions 1 and 4. Also you should remove the integer 5, which is in the position 2. In the second example you should remove integer 2, which is in the position 1, and two integers 4, which are in the positions 2 and 4. In the third example you should remove four integers 6, which are in the positions 1, 2, 3 and 4. 题目大意给一组数，输出不重复的数个数，按序输出。 解题思路水题 解题代码123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354#include &lt;cstdio&gt;#include &lt;cstring&gt;#include &lt;iostream&gt;#include &lt;set&gt;#include &lt;queue&gt;#include &lt;map&gt;#include &lt;vector&gt;#include &lt;algorithm&gt;#define eps 1e-8#define INF 0x3f3f3f3fusing namespace std;const int maxn=1e5+5;typedef long long ll;ll gcd(ll a,ll b)&#123; return a?gcd(b%a,a):b;&#125;ll lcm(ll a,ll b)&#123; return a/gcd(a,b)*b; &#125; int a[maxn],n,m,vis[maxn],ans[maxn],cnt;int main()&#123; while(~scanf("%d",&amp;n)) &#123; cnt=0; memset(vis,0,sizeof(vis)); for(int i=1;i&lt;=n;i++) &#123; scanf("%d",&amp;a[i]); &#125; for(int i=n;i&gt;=1;i--) &#123;// printf("%d",a[i]); if(!vis[a[i]]) &#123; ans[cnt++]=a[i]; vis[a[i]]=1; &#125; &#125; printf("%d\n",cnt); for(int i=cnt-1;i&gt;=0;i--) &#123; if(i==0) printf("%d",ans[i]); else printf("%d ",ans[i]); &#125; printf("\n"); &#125;&#125; 收获与反思无，注意细节一遍成功即可。]]></content>
      <categories>
        <category>编程</category>
        <category>ACM</category>
      </categories>
      <tags>
        <tag>算法</tag>
        <tag>ACM</tag>
        <tag>2018春季训练</tag>
        <tag>水题</tag>
        <tag>CodeForces</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[【CSU-1023】解题报告（二分）]]></title>
    <url>%2F2018%2F05%2F09%2F%E3%80%90CSU-1023%E3%80%91%E8%A7%A3%E9%A2%98%E6%8A%A5%E5%91%8A%EF%BC%88%E4%BA%8C%E5%88%86%EF%BC%89%2F</url>
    <content type="text"><![CDATA[原始题目1023: 修路 Time Limit: 1 Sec Memory Limit: 128 Mb Submitted: 632 Solved: 340Description前段时间，某省发生干旱，B山区的居民缺乏生活用水，现在需要从A城市修一条通往B山区的路。假设有A城市通往B山区的路由$m$条连续的路段组成，现在将这m条路段承包给$n$个工程队$(n ≤ m ≤ 300)$。为了修路的便利，每个工程队只能分配到连续的若干条路段（当然也可能只分配到一条路段或未分配到路段）。假设每个工程队修路的效率一样，即每修长度为$1$的路段所需的时间为$1$。现在给出路段的数量$m$，工程队的数量$n$，以及$m$条路段的长度（这$m$条路段的长度是按照从A城市往B山区的方向依次给出，每条路段的长度均小于$1000$），需要你计算出修完整条路所需的最短的时间（即耗时最长的工程队所用的时间）。 Input第一行是测试样例的个数T ，接下来是T个测试样例，每个测试样例占2行，第一行是路段的数量m和工程队的数量n，第二行是m条路段的长度。 Output对于每个测试样例，输出修完整条路所需的最短的时间。 Sample Input2 4 3 100 200 300 400 9 4 250 100 150 400 550 200 50 700 300 Sample Output400 900 HintSource中南大学第四届大学生程序设计竞赛 解题思路 每个队伍必须连续修路，每个队伍效率相同（每天都修单位长度） 可以得到修路的下限和上限，二分修路长度最终得到答案 解题代码123456789101112131415161718192021222324252627282930313233343536373839404142434445464748#include &lt;cstdio&gt;#include &lt;cstring&gt;#include &lt;iostream&gt;#include &lt;set&gt;#include &lt;queue&gt;#include &lt;algorithm&gt;#include &lt;queue&gt;using namespace std;const int maxn=1e5+5;int t,n,m;int road[maxn];int main()&#123; scanf("%d",&amp;t); while(t--) &#123; memset(road,0,sizeof(road)); scanf("%d%d",&amp;m,&amp;n); int high=0,low=0; for(int i=0;i&lt;m;i++) &#123; scanf("%d",&amp;road[i]); high+=road[i]; low=max(road[i],low); &#125; while(low&lt;high) //二分修路的长度 &#123; int mid=(high+low)&gt;&gt;1;// printf("now mid=%d\n",mid); int tot=n-1,sum=road[0]; //一共还有n-1个人可以用 for(int i=1;i&lt;m;i++) &#123; if(sum+road[i]&gt;mid) &#123; tot--; sum=road[i]; &#125; else sum+=road[i]; if(tot&lt;0) break; &#125; if(tot&lt;0) low=mid+1; else high=mid; &#125; printf("%d\n",low); &#125; &#125; 收获与反思 二分思维转换 已知上界下界后利用二分逼近答案]]></content>
      <categories>
        <category>编程</category>
        <category>ACM</category>
      </categories>
      <tags>
        <tag>算法</tag>
        <tag>ACM</tag>
        <tag>2018春季训练</tag>
        <tag>CSU</tag>
        <tag>二分</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[【HDU-1166】解题报告（线段树求和，点维护）]]></title>
    <url>%2F2018%2F04%2F26%2F%E3%80%90HDU-1166%E3%80%91%E8%A7%A3%E9%A2%98%E6%8A%A5%E5%91%8A%EF%BC%88%E7%BA%BF%E6%AE%B5%E6%A0%91%E6%B1%82%E5%92%8C%EF%BC%8C%E7%82%B9%E7%BB%B4%E6%8A%A4%EF%BC%89%2F</url>
    <content type="text"><![CDATA[原始题目敌兵布阵 Time Limit: 2000/1000 MS (Java/Others) Memory Limit: 65536/32768 K (Java/Others) Total Submission(s): 111269 Accepted Submission(s): 46637 Problem Description C国的死对头A国这段时间正在进行军事演习，所以C国间谍头子Derek和他手下Tidy又开始忙乎了。A国在海岸线沿直线布置了N个工兵营地,Derek和Tidy的任务就是要监视这些工兵营地的活动情况。由于采取了某种先进的监测手段，所以每个工兵营地的人数C国都掌握的一清二楚,每个工兵营地的人数都有可能发生变动，可能增加或减少若干人手,但这些都逃不过C国的监视。中央情报局要研究敌人究竟演习什么战术,所以Tidy要随时向Derek汇报某一段连续的工兵营地一共有多少人,例如Derek问:“Tidy,马上汇报第3个营地到第10个营地共有多少人!”Tidy就要马上开始计算这一段的总人数并汇报。但敌兵营地的人数经常变动，而Derek每次询问的段都不一样，所以Tidy不得不每次都一个一个营地的去数，很快就精疲力尽了，Derek对Tidy的计算速度越来越不满:”你个死肥仔，算得这么慢，我炒你鱿鱼!”Tidy想：“你自己来算算看，这可真是一项累人的工作!我恨不得你炒我鱿鱼呢!”无奈之下，Tidy只好打电话向计算机专家Windbreaker求救,Windbreaker说：“死肥仔，叫你平时做多点acm题和看多点算法书，现在尝到苦果了吧!”Tidy说：”我知错了。。。”但Windbreaker已经挂掉电话了。Tidy很苦恼，这么算他真的会崩溃的，聪明的读者，你能写个程序帮他完成这项工作吗？不过如果你的程序效率不够高的话，Tidy还是会受到Derek的责骂的. Input第一行一个整数$T$，表示有$T$组数据。每组数据第一行一个正整数$N(N \le 50000)$,表示敌人有$N$个工兵营地，接下来有$N$个正整数,第$i$个正整数$a_i$代表第$i$个工兵营地里开始时有$a_i$个人$(1 \le ai \le 50)$。接下来每行有一条命令，命令有4种形式：(1) Add i j,i和j为正整数,表示第i个营地增加j个人（j不超过30）(2)Sub i j ,i和j为正整数,表示第i个营地减少j个人（j不超过30）;(3)Query i j ,i和j为正整数,i&lt;=j，表示询问第i到第j个营地的总人数;(4)End 表示结束，这条命令在每组数据最后出现;每组数据最多有$40000$条命令 Output对第i组数据,首先输出“Case i:”和回车,对于每个Query询问，输出一个整数并回车,表示询问的段中的总人数,这个数保持在int以内。 Sample Input1 10 1 2 3 4 5 6 7 8 9 10 Query 1 3 Add 3 6 Query 2 7 Sub 10 2 Add 6 3 Query 3 10 End Sample OutputCase 1: 6 33 59 AuthorWindbreaker RecommendEddy 题目大意见中文 解题思路线段树入门题目，点修改（含正负情况），区间询问，注意 解题代码123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106#include &lt;cstdio&gt;#include &lt;cstring&gt;#include &lt;cmath&gt;#include &lt;iostream&gt;#include &lt;iomanip&gt;#include &lt;set&gt;#include &lt;queue&gt;#include &lt;map&gt;#include &lt;vector&gt;#include &lt;algorithm&gt;#include &lt;stack&gt;using namespace std;typedef long long ll;const int maxn=2e5+5;struct node&#123; ll l,r,sum;&#125;tree[maxn];ll a[maxn];void build(ll k, ll l,ll r)&#123; tree[k].l=l; tree[k].r=r; if(tree[k].l==tree[k].r) &#123; tree[k].sum=a[l]; return ; &#125; ll mid=(tree[k].l+tree[k].r)&gt;&gt;1; build(k&lt;&lt;1,l,mid); build(k&lt;&lt;1|1,mid+1,r); tree[k].sum=tree[k&lt;&lt;1].sum+tree[k&lt;&lt;1|1].sum;// printf("k==%lld k.sum==%lld\n",k,tree[k].sum);&#125;void change(ll k,ll d,ll x)&#123; if(tree[k].l==tree[k].r&amp;&amp;tree[k].r==d) &#123; tree[k].sum=tree[k].sum+x; return ; &#125; int mid=(tree[k].l+tree[k].r)&gt;&gt;1; if(d&gt;=tree[k].l&amp;&amp;d&lt;=mid) change(k&lt;&lt;1,d,x); else change(k&lt;&lt;1|1,d,x); tree[k].sum=tree[k&lt;&lt;1].sum+tree[k&lt;&lt;1|1].sum; &#125;ll query(ll k,ll l,ll r)&#123; if(tree[k].l==l&amp;&amp;tree[k].r==r) return tree[k].sum; ll mid=(tree[k].l+tree[k].r)&gt;&gt;1; if(r&lt;=mid) return query(k&lt;&lt;1,l,r); else if(l&gt;=mid+1) return query(k&lt;&lt;1|1,l,r); else return query(k&lt;&lt;1,l,mid)+query(k&lt;&lt;1|1,mid+1,r); &#125;char ch[10];ll t,n,d,x;int main() &#123;// freopen("in.txt","r",stdin);// freopen("out.txt","w",stdout); while(~scanf("%lld",&amp;t)) &#123; int cnt=0; while(t--) &#123; memset(tree,0,sizeof(tree)); memset(a,0,sizeof(a)); cnt++; printf("Case %d:\n",cnt); scanf("%lld",&amp;n); for(int i=1;i&lt;=n;i++) scanf("%lld",&amp;a[i]); build(1,1,n); while(scanf("%s",ch)&amp;&amp;ch[0]!='E') &#123; if(ch[0]=='Q') &#123; scanf("%lld%lld",&amp;d,&amp;x); printf("%lld\n",query(1,d,x)); &#125; else if(ch[0]=='A') &#123; scanf("%lld%lld",&amp;d,&amp;x); change(1,d,x); &#125; else if(ch[0]=='S') &#123; scanf("%lld%lld",&amp;d,&amp;x); change(1,d,-x); &#125; &#125; &#125; &#125; &#125; 收获与反思 Emmm，WA了两次是因为数组开的不够大，这个以为够用了，待分析原因。 进一步熟悉模板。 注意long long。]]></content>
      <categories>
        <category>编程</category>
        <category>ACM</category>
      </categories>
      <tags>
        <tag>算法</tag>
        <tag>ACM</tag>
        <tag>2018春季训练</tag>
        <tag>HDU</tag>
        <tag>线段树</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[【POJ-3468】解题报告（线段树求和，区间维护）]]></title>
    <url>%2F2018%2F04%2F26%2F%E3%80%90POJ-3468%E3%80%91%E8%A7%A3%E9%A2%98%E6%8A%A5%E5%91%8A%EF%BC%88%E7%BA%BF%E6%AE%B5%E6%A0%91%E6%B1%82%E5%92%8C%EF%BC%8C%E5%8C%BA%E9%97%B4%E7%BB%B4%E6%8A%A4%EF%BC%89%2F</url>
    <content type="text"><![CDATA[原始题目A Simple Problem with Integers Time Limit: 5000MS Memory Limit: 131072K Total Submissions: 129411 Accepted: 40139 Case Time Limit: 2000MS Description You have N integers, A1, A2, … , AN. You need to deal with two kinds of operations. One type of operation is to add some given number to each number in a given interval. The other is to ask for the sum of numbers in a given interval. InputThe first line contains two numbers N and Q. 1 ≤ N,Q ≤ 100000.The second line contains N numbers, the initial values of A1, A2, … , AN. -1000000000 ≤ Ai ≤ 1000000000.Each of the next Q lines represents an operation.“C a b c” means adding c to each of Aa, Aa+1, … , Ab. -10000 ≤ c ≤ 10000.“Q a b” means querying the sum of Aa, Aa+1, … , Ab. OutputYou need to answer all Q commands in order. One answer in a line. Sample Input10 5 1 2 3 4 5 6 7 8 9 10 Q 4 4 Q 1 10 Q 2 4 C 3 6 3 Q 2 4 Sample Output4 55 9 15 HintThe sums may exceed the range of 32-bit integers. SourcePOJ Monthly—2007.11.25, Yang Yi 题目大意对于一组序列A,有两种操作，询问：给出对应区间序列的和，增加：给出对应区间区间内所有点增加固定值。 解题思路线段树模板题，区间询问，区间修改，注意long long即可。 解题代码123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147148149150151152153154155156#include &lt;cstdio&gt;#include &lt;cstring&gt;#include &lt;cmath&gt;#include &lt;cmath&gt;#include &lt;iostream&gt;#include &lt;iomanip&gt;#include &lt;string&gt;#include &lt;set&gt;#include &lt;queue&gt;#include &lt;vector&gt;#include &lt;map&gt;using namespace std;const int maxn=2e5+5;typedef long long ll;ll n,m;ll d,x;ll b,e;ll a[maxn];struct node&#123; ll l; ll r; ll sum; ll tag; ll maxnum;&#125;tree[maxn&lt;&lt;2];char ch[2];void build(ll k,ll l,ll r) //k为线段树的角标 &#123; tree[k].l=l; tree[k].r=r; if(l==r) &#123; tree[k].sum=a[l]=a[r]; //叶子节点，单点的sum即是本身 return ; &#125; ll mid=(l+r)&gt;&gt;1; build(k&lt;&lt;1,l,mid); //递归构建左线段（左子树） build(k&lt;&lt;1|1,mid+1,r); //递归构建右线段（右子树） tree[k].sum=tree[k&lt;&lt;1].sum+tree[k&lt;&lt;1|1].sum; return ; &#125;void change1(ll k,ll d,ll x)&#123; if(tree[k].l==tree[k].r&amp;&amp;tree[k].r==d) //找到索引点 &#123; tree[k].maxnum=x; //修改最大值 return ; //修改后再开始回溯 &#125; ll mid=(tree[k].l+tree[k].r)&gt;&gt;1; if(d&gt;=tree[k].l&amp;&amp;d&lt;=mid) //查找点在左子树 change1(k&lt;&lt;1,d,x); //k&lt;&lt;1为左子树, else //查找点在右子树， change1(k&lt;&lt;1|1,d,x); //k&lt;&lt;1|1为右子树 tree[k].maxnum=max(tree[k&lt;&lt;1].maxnum,tree[k&lt;&lt;1|1].maxnum); //递归从新计算非叶结点的值 &#125;void change(ll k) //懒惰操作，有标记才操作一次，有记忆性 &#123; if(tree[k].l==tree[k].r) tree[k].sum+=tree[k].tag; else &#123; tree[k].sum+=(tree[k].r-tree[k].l+1)*tree[k].tag; tree[k&lt;&lt;1].tag+=tree[k].tag; tree[k&lt;&lt;1|1].tag+=tree[k].tag; &#125; tree[k].tag=0; //自身标记清零 &#125;void add(ll k,ll l,ll r,ll x)&#123; if(tree[k].tag) &#123;// printf("--"); change(k); &#125; if(tree[k].l==l&amp;&amp;tree[k].r==r) //在固定的区间打标记 &#123; tree[k].tag+=x; //向下打标记 // printf("k=%lld l=%lld r=%lld tag=%lld\n",k ,l,r,tree[k].tag); return ; &#125;// printf("1 %lld\n",tree[k].sum); tree[k].sum+=(r-l+1)*x;// printf("2 %lld\n",tree[k].sum); ll mid=(tree[k].r+tree[k].l)&gt;&gt;1; if(r&lt;=mid) add(k&lt;&lt;1,l,r,x); else if(l&gt;=mid+1) add(k&lt;&lt;1|1,l,r,x); else &#123; add(k&lt;&lt;1,l,mid,x); add(k&lt;&lt;1|1,mid+1,r,x); &#125;&#125;ll query(ll k,ll l,ll r)&#123;// printf("query %lld .tag=%lld\n",k,tree[k].tag); if(tree[k].tag) &#123;// printf("$"); change(k); &#125; ll mid=(tree[k].l+tree[k].r)&gt;&gt;1; if(tree[k].l==l&amp;&amp;tree[k].r==r) return tree[k].sum; if(r&lt;=mid) return query(k&lt;&lt;1,l,r); else if(l&gt;=mid+1) return query(k&lt;&lt;1|1,l,r); else return query(k&lt;&lt;1,l,mid)+query(k&lt;&lt;1|1,mid+1,r); //中线跨区间 &#125;int main()&#123; while(~scanf("%lld%lld",&amp;n,&amp;m)) &#123; memset(tree,0,sizeof(tree)); for(ll i=1;i&lt;=n;i++) &#123; scanf("%lld",&amp;a[i]); &#125; build(1,1,n); for(ll i=1;i&lt;=m;i++) &#123; scanf("%s",ch); if(ch[0]=='Q') &#123; scanf("%lld%lld",&amp;b,&amp;e);// printf("11"); printf("%lld\n",query(1,b,e)); &#125; else &#123; scanf("%lld%lld%lld",&amp;b,&amp;e,&amp;x); add(1,b,e,x); &#125; &#125; &#125;&#125; 收获与反思 注意数组不要越界，注意long long。 写模板注意sum的写法和取最大值的写法略有不同。 理解lazy（tag）标记，即访问到时才进行一次向下扩展，每次修改并不直接作用于叶子节点。]]></content>
      <categories>
        <category>编程</category>
        <category>ACM</category>
      </categories>
      <tags>
        <tag>算法</tag>
        <tag>ACM</tag>
        <tag>2018春季训练</tag>
        <tag>HDU</tag>
        <tag>线段树</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[【HDU-1754】解题报告（线段树最大值，点维护）]]></title>
    <url>%2F2018%2F04%2F26%2F%E3%80%90HDU-1754%E3%80%91%E8%A7%A3%E9%A2%98%E6%8A%A5%E5%91%8A%EF%BC%88%E7%BA%BF%E6%AE%B5%E6%A0%91%E6%9C%80%E5%A4%A7%E5%80%BC%EF%BC%8C%E7%82%B9%E7%BB%B4%E6%8A%A4%EF%BC%89%2F</url>
    <content type="text"><![CDATA[原始题目I Hate It Time Limit: 9000/3000 MS (Java/Others) Memory Limit: 32768/32768 K (Java/Others) Total Submission(s): 92291 Accepted Submission(s): 35036 Problem Description很多学校流行一种比较的习惯。老师们很喜欢询问，从某某到某某当中，分数最高的是多少。这让很多学生很反感。 不管你喜不喜欢，现在需要你做的是，就是按照老师的要求，写一个程序，模拟老师的询问。当然，老师有时候需要更新某位同学的成绩。 Input本题目包含多组测试，请处理到文件结束。在每个测试的第一行，有两个正整数 N 和 M ( 0&lt;N≤200000,0&lt;M&lt;5000 )，分别代表学生的数目和操作的数目。学生ID编号分别从1编到N。第二行包含N个整数，代表这N个学生的初始成绩，其中第i个数代表ID为i的学生的成绩。接下来有M行。每一行有一个字符 C (只取’Q’或’U’) ，和两个正整数A，B。当C为’Q’的时候，表示这是一条询问操作，它询问ID从A到B(包括A,B)的学生当中，成绩最高的是多少。当C为’U’的时候，表示这是一条更新操作，要求把ID为A的学生的成绩更改为B。 Output对于每一次询问操作，在一行里面输出最高成绩。 Sample Input5 6 1 2 3 4 5 Q 1 5 U 3 6 Q 3 4 Q 4 5 U 2 9 Q 1 5 Sample Output5 6 5 9 HintHuge input,the C function scanf() will work better than cin Authorlinle Source2007省赛集训队练习赛（6）_linle专场 Recommendlcy 题目大意如中文 解题思路线段树模板题，点修改，维护最大值 解题代码1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465666768697071727374757677787980818283848586878889909192939495969798#include &lt;cstdio&gt;#include &lt;cstring&gt;#include &lt;cmath&gt;#include &lt;cmath&gt;#include &lt;iostream&gt;#include &lt;iomanip&gt;#include &lt;string&gt;#include &lt;set&gt;#include &lt;queue&gt;#include &lt;vector&gt;#include &lt;map&gt;using namespace std;const int maxn=2e5+5;int n,m;int d,x;int a[maxn];struct node&#123; int l; int r; int maxnum;&#125;tree[maxn&lt;&lt;2];char ch[2];void build(int k,int l,int r) //k为线段树的角标 &#123; tree[k].l=l; tree[k].r=r; if(l==r) &#123; tree[k].maxnum=a[l]=a[r]; //叶子节点，单点的max值就是该点的值 return ; &#125; int mid=(l+r)&gt;&gt;1; build(k&lt;&lt;1,l,mid); //递归构建左线段（左子树） build(k&lt;&lt;1|1,mid+1,r); //递归构建右线段（右子树） tree[k].maxnum=max(tree[k&lt;&lt;1].maxnum,tree[k&lt;&lt;1|1].maxnum); //根节点的最大值是左右子树最大值的max return ; &#125;void change(int k,int d,int x)&#123; if(tree[k].l==tree[k].r&amp;&amp;tree[k].r==d) //找到索引点 &#123; tree[k].maxnum=x; //修改最大值 return ; //修改后再开始回溯 &#125; int mid=(tree[k].l+tree[k].r)&gt;&gt;1; if(d&gt;=tree[k].l&amp;&amp;d&lt;=mid) //查找点在左子树 change(k&lt;&lt;1,d,x); //k&lt;&lt;1为左子树, else //查找点在右子树， change(k&lt;&lt;1|1,d,x); //k&lt;&lt;1|1为右子树 tree[k].maxnum=max(tree[k&lt;&lt;1].maxnum,tree[k&lt;&lt;1|1].maxnum); //递归从新计算非叶结点的值 &#125;int query(int k,int l,int r)&#123; int maxnum; if(tree[k].l==l&amp;&amp;tree[k].r==r) return tree[k].maxnum; int mid=(tree[k].l+tree[k].r)&gt;&gt;1; if(r&lt;=mid) maxnum=query(k&lt;&lt;1,l,r); else if(l&gt;=mid+1) maxnum=query(k&lt;&lt;1|1,l,r); else maxnum=max(query(k&lt;&lt;1,l,mid),query(k&lt;&lt;1|1,mid+1,r)); //中线跨区间 return maxnum;&#125;int main()&#123; while(~scanf("%d%d",&amp;n,&amp;m)) &#123; memset(tree,0,sizeof(tree)); for(int i=1;i&lt;=n;i++) &#123; scanf("%d",&amp;a[i]); &#125; build(1,1,n); for(int i=1;i&lt;=m;i++) &#123; scanf("%s%d%d",ch,&amp;d,&amp;x); if(ch[0]=='Q') //查询输入 &#123; printf("%d\n",query(1,d,x)); &#125; else change(1,d,x); &#125; &#125;&#125; 收获与反思 对模板的理解都写在注释里了 本题是维护最大值，可以用int替换ll 切记memset数组]]></content>
      <categories>
        <category>编程</category>
        <category>ACM</category>
      </categories>
      <tags>
        <tag>算法</tag>
        <tag>ACM</tag>
        <tag>2018春季训练</tag>
        <tag>HDU</tag>
        <tag>线段树</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[【CSU-1977】解题报告（二进制，位运算，读题》]]></title>
    <url>%2F2018%2F04%2F23%2F%E3%80%90CSU-1977%E3%80%91%E8%A7%A3%E9%A2%98%E6%8A%A5%E5%91%8A%EF%BC%88%E4%BA%8C%E8%BF%9B%E5%88%B6%EF%BC%8C%E4%BD%8D%E8%BF%90%E7%AE%97%EF%BC%8C%E8%AF%BB%E9%A2%98%E3%80%8B%2F</url>
    <content type="text"><![CDATA[原始题目Bit-reversal Permutation Time Limit: 1 Sec Memory Limit: 128 Mb Submitted: 81 Solved: 27 DescriptionA fast Fourier transform (FFT) algorithm computes the discrete Fourier transform (DFT) of a sequence, or its inverse (IFFT). Fourier analysis converts a signal from its original domain (often time or space) to a representation in the frequency domain and vice versa. An FFT rapidly computes such transformations by factorizing the DFT matrix into a product of sparse (mostly zero) factors. As a result, it manages to reduce the complexity of computing the DFT from O(n2), which arises if one simply applies the definition of DFT, to O(nlogn), where n is the data size. ——From Wikipedia During this summer holiday, csuxushu feels so bored to learn FFT. Because FFT is a complicated algorithm, he need to apply a bit-reversal permutation to a sequence first before DFT which is a part of FFT. In applied mathematics, a bit-reversal permutation is a permutation of a sequence of n items, where n = 2^k is a power of two. It is defined by indexing the elements of the sequence by the numbers from 0 to n − 1 and then reversing the binary representations of each of these numbers (padded so that each of these binary numbers has length exactly k). Each item is then mapped to the new position given by this reversed value. Because all fellows in CSU(California State University ) can apply FFT, NTT or even FWT, it is a shame that he even doesn’t know how to take the first step. As one of the best computer programmer in CSU, can you help him? You may think this problem is too hard to solve. In fact, it is a piece of cake to you. Remember to see the hint :-) InputThe first line of the input gives the number of test cases T(T≤10); T test cases follow.Each test case contains a number sequence.In each case, the first line is a number N(1≤N≤10^5), the number of elements in the following sequence.The second line is the sequence.Its length may not be exactly a power of two, so you can append some zeros to make it the minimal power of two larger than or equal to N. OutputFor each test case, output the sequence from input in bit-reversal order. Sample Input1 6 21 58 96 12 45 65 Sample Output21 45 96 0 58 65 12 0 HintBit-reverse Order （图片待添加） 中文提示：可以看到，我们最终处理的系数从左至右的编号的二进制形式分别为000,100,010,110,001,101,011,111，若将其二进制反序，可得000,001,010,011,100,101,110,111，这些反序的二进制编码是从小到大排列的。也就是说，我们可以按照每个下标的二进制编码来确定处理系数的顺序。这种方法就称为位逆序置换(Bit-reversal permutation)。 Source2017年8月月赛 Author徐戍 题目大意将给定序列按位反转后的顺序输出 解题思路看中文提示和图示就能不明白，将序列顺序（从0开始）用二进制位表示后位反转，按反转后从小到大顺序输出。 解题代码123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051#include &lt;cstdio&gt;#include &lt;cstring&gt;#include &lt;set&gt;#include &lt;cmath&gt;#include &lt;map&gt;#include &lt;queue&gt;#include &lt;algorithm&gt;#include &lt;map&gt;using namespace std;const int maxn=2e5+5;int raw[maxn];int t;int m,n;int main()&#123; while(~scanf("%d",&amp;t)) &#123; while(t--) &#123; scanf("%d",&amp;m); &#123; n=0; memset(raw,0,sizeof(raw)); while(pow(2,n)&lt;m) n++; for(int i=0;i&lt;m;i++) &#123; scanf("%d",&amp;raw[i]); &#125; int len=pow(2,n); for(int i=0;i&lt;len;i++) &#123; int bit=0,b=i; for(int j=0;j&lt;n;j++) &#123; bit=bit|(b&amp;1); b&gt;&gt;=1; bit&lt;&lt;=1; &#125;// printf("bit=%d\n",bit); bit&gt;&gt;=1; if(i==0) printf("%d",raw[bit]); else printf(" %d",raw[bit]); &#125; printf("\n"); &#125; &#125; &#125;&#125; 收获与反思用二进制计算方法（按位与、按位或、左移右移），来替代pow(2,n)。否则超时比如将序号进行位反转后再十进制化的代码。 // b为原始序列号 bit为位反转再十进制化的序列号 int bit=0,b=i; for(int j=0;j&lt;n;j++) { bit=bit|(b&amp;1); b&gt;&gt;=1; bit&lt;&lt;=1; } 这一过程不要用 int bit=0,b=i; for(int j=0;j&lt;n;j++) { if(b&amp;1) bit+=pow(n-1-j); b/=2; } //乘方会慢很多很多]]></content>
      <categories>
        <category>编程</category>
        <category>ACM</category>
      </categories>
      <tags>
        <tag>算法</tag>
        <tag>ACM</tag>
        <tag>2018春季训练</tag>
        <tag>CSU</tag>
        <tag>位运算</tag>
        <tag>补图</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Hello Hexo]]></title>
    <url>%2F2018%2F04%2F21%2FHello-Hexo%2F</url>
    <content type="text"><![CDATA[今日博客搬家 bing 基于Hexo-Next-Gemini 还在搬运Evernote和CSDN上的东西 还有很多功能没有添加，欢迎各位提意见]]></content>
  </entry>
  <entry>
    <title><![CDATA[《1Q84》读书笔记]]></title>
    <url>%2F2018%2F04%2F08%2F%E3%80%8A1Q84%E3%80%8B%E8%AF%BB%E4%B9%A6%E7%AC%94%E8%AE%B0%2F</url>
    <content type="text"><![CDATA[内容摘录第一部 P371 “世界这个东西，青豆啊，就是一种记忆和相反的另一种记忆永无休止的斗争。” 第二部 P262 “人的生命虽然本质上是孤独的存在，却不是孤立的存在。” P270 “但店内除了天吾，只有一对像是大学生的青年男女并肩坐在吧台前，正在交头接耳，起劲地说着悄悄话。望着他们，天吾感到了许久不曾有过的深深地寂寞。在这个世界上，自己是孤独的，和谁都没有关联。” P274 “我当时看见了月亮。青豆也看见了同一个月亮。浮在下午三点半依然十分明亮的天上的灰色岩块。沉默而孤独的卫星。两人并肩而立，望着那个月亮。但是，那究竟意味着什么？难道月亮会领我去青豆所在的地方吗？” P276 “天吾专注着望着月光，心中从远古时代传承下来的记忆般的东西被唤醒了。远在人类获得火、工具和语言之前，月亮就始终不变地是人们的朋友。它作为天赐地灯火，不时照亮黑暗的世界，缓解了人们的恐惧。它地圆缺给了人们时间观念。对月亮这种无偿地感谢之情，纵然在黑暗已从绝大部分地域驱逐的现在，似乎依然牢牢烙印在人类的遗传因子里。作为一种温暖的集体记忆。” P311 “我隔着一条马路看到了她，还因为可能被他拥入怀中而颤抖。虽说只有几分钟，我毕竟也全身心地题为过那种激烈的喜悦和期待。她闭上眼睛，紧攥着滑梯的扶手，咬住嘴唇。” P312 “不过这将无所谓。我将为他而死。我不能为自己而活，这种可能性从一开始就被剥夺了。可是，我却能为他而死。这样就够了。我可以微笑着去死。 这不是谎言。” P338 “他像被遗弃在风暴逝去后的静谧中，无法在任何事物上集中精神。” P341 “父亲依旧纹丝不动，他的双眼被牢牢封闭在那黑暗地深坑底部，望去仿佛在静静地等待降雪，将深坑填成白色。” Emmm…我喜欢带鼓点的纯音乐，因为在不知哪个关键的时刻，想起的鼓点声总能巧妙地切合这个场景。 P350 “这二十年间，他心里时时刻刻装着这位少女的面容。 青豆，天吾叫出声来。 少女沉在深深的睡眠中。似乎是很深的自然的睡眠，连呼吸都极其微弱。她的心脏也只是轻微地鼓动着，虚幻得传不到人的耳朵里。甚至连抬起眼睑得力量都没有……青豆在遥远的地方听见了这呼唤。天吾君，她在心中念道，还清晰地呼出声来。但这句话却不会掀动躺在空气蛹中少女的嘴唇，也不会传入天吾的耳朵。”]]></content>
      <categories>
        <category>阅读</category>
      </categories>
      <tags>
        <tag>阅读</tag>
        <tag>小说</tag>
        <tag>村上春树</tag>
        <tag>1Q84</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[《黑豹》观后感]]></title>
    <url>%2F2018%2F03%2F17%2F%E3%80%8A%E9%BB%91%E8%B1%B9%E3%80%8B%E8%A7%82%E5%90%8E%E6%84%9F%2F</url>
    <content type="text"><![CDATA[总的来说，是近几年漫威出的质量比较高的一部电影了，没有过分卖腐，卖情怀。一点点人格之间的矛盾，一点点反思，剧情衔接也很不错，虽然有一点套路，但是在可接受的范围内。 表弟Killmonger让我想起了铁血孤儿团三日月一众人，还有麦基利斯。悲情么？悲情。可惜么？不可惜。他们的行为注定是孤独的悲情的，但欣慰的是他们的死亡是注入世界的一剂良药，让目睹他们死亡的人能感受到他们心中那一点点不同，然后做出改变（就像黑豹和艾里安议长）。或许人们不会记得他们，但历史会。 黑豹带表弟去看生命中第一次也是最后一次瓦坎达的日落，是为自己的父亲赎罪，也是对叔叔的缅怀。他将不在时电影开头的那个黑豹，从此，父亲与叔叔的两种感情将汇聚在他一人身上。月型草被一把火烧了个干干净净，或许他死后也不会再去自己父亲那里了吧。 但是表弟最后嘴里说出的那句“不自由，毋宁死”确实是把原文的意思曲解了。去Google了一下。原句是这样的 “Bury me in the ocean with my ancestors who jumped from ships, cause they knew death was better than bondage,” 我个人更倾向于表弟想表达的是：不愿意在此处与瓦坎达独享安宁（在他眼里是一种绑架，被历史、被先祖的传统绑架），的不自由（矛盾的焦点不在于他们是否拥有走出瓦坎达的边境的freedom，而在于是否应该向外输出自己的科技，武装世界其他角落受压迫的黑人对）。而且，“不自由，毋宁死.”这一句本是美国独立战争时期，Patrick Henry在弗吉尼亚议会演讲的最后一句“Give me liberty or give me death.”的翻译。 忙里偷闲独自看一场电影，还不错。]]></content>
  </entry>
  <entry>
    <title><![CDATA[《亲爱的安德烈》读书笔记]]></title>
    <url>%2F2018%2F03%2F16%2F%E3%80%8A%E4%BA%B2%E7%88%B1%E7%9A%84%E5%AE%89%E5%BE%B7%E7%83%88%E3%80%8B%E8%AF%BB%E4%B9%A6%E7%AC%94%E8%AE%B0%2F</url>
    <content type="text"><![CDATA[内容摘录认识一个十八岁的人 P4 “虽然心中有爱，但是爱，冻结在经年累月的沉默里，好像一个疼痛的伤口，没有纱布可绑。” P5 “我们是两代人，中间隔个三十年。我们也是两国人，中间隔个东西文化。我们原来也可能再他十八岁那年，就像水上浮萍一样各自荡开，从此天涯淡泊。 日后的人生旅程，当然还是要漂萍离散——人生哪有恒长的厮守？但是三年的海上旗语，茹月色满怀，我还奢求什么呢。” 第1封信 十八岁那一年 P13 “那‘愚昧无知’的渔村，确实没有给我知识，但是给了我一种能力，悲悯同情的能力。” P14 “你们这一代‘定锚’的价值是什么？终极的关怀是什么？你认为美丽的热带鱼游泳也要在P乎方向吗？或者，你要挑衅地说，这是一个无谓的问题，因为热带鱼只为自己而活？” 第3封信 逃避国家 P21 “觉得德国是个不错得国家这种感觉是没有人敢显露，大家都要藏起来的。” P25 “如果是五十个德国人在街上大喊‘德国第一；’德国万岁‘，会把人给吓死，第二天可以上《纽约时报》了，对吧？” 第5封信 对玫瑰花的反抗 P37 “玩，可以说是天地间学问的根本。” 第6封信 一切都是小小地 P41 “每个人都在走自己的路，每个人都在选择自己的品味， 搞自己的游戏，设定自己的对和错的标准，一切都是小小的、个人的，因为，我们的时代已经不在有’伟大‘的任何特征。” 第7封信 有没有时间革命？ P48 “这世上/没有真实世界这回事/只有谎言/迫使你设法穿越” 第8封信 我是个百分之百的混蛋 P56 “世界上那么多不公正的存在，怎么可能没有‘反叛’的需要？所差的只不过在于你是否愿意看见，是否愿意站起来，行动不行动而已” P56 “至少，我清楚看见自己的生存状态，而且至少，我并不以我的生存状态为荣。” 第9封信 两种道德 P63 “这些国家里的人民，准许，或说要求，他们的政府把大量的钱，花在离他们很遥远但是贫病交迫的人们身上。” 第11封信 阳光照进你的路 P79 “对美的迷恋可以打败任何智者自以为是的心得报告。我只能让你跌倒，看着你跌倒，只能希望你会在跌倒的地方爬起来，希望阳光照过来，照亮你藏着忧伤的心，照亮你眼前看不见尽头的路。” 第13封信 向左走，向右走 P93 “然而母亲想念成长的孩子，总是单向的；充满青春活力的孩子奔向他人生的愿景，眼睛热切望着前方，母亲只能在后头张望他越来越小的背影，揣摩，那地平线有多远，有多长，怎么一下子，就看不见了。” 第14封信 秘密的、私己的美学 P101 “流行文化经过时间的筛子，泥沙被淘汰，金块被留下，留下的就叫做经典或古典……” （文化，大浪淘沙） 第16封信 藏在心中的小镇 P112 “所以我坐在这阳台上，细细回想我们共有的美好时光，把回忆拥在心里，是得往前走，但是直到我从哪里来。” 第17封信 你是哪国人？ P116 “‘逃民’被时代的一把剑切断了她和土地、和传统、和宗族友群的连结韧带，她漂浮，她悬在半空中，因为，她也许对这个世界看得特别透彻，因为她不在友群里，视线不被挡住，但是她处在一种灵魂的孤独中。” P116 “她不要你和她一样，做一个灵魂的漂泊者——那也许是文学的美好境界，却是生活的苦楚。” P118 “可是不管国家这种单位发生了什么根本的变化，有了或没了，兴盛了或灭亡了，变大了或变小了，安德烈，小镇不会变。泥土和记忆不会变。 我很欢喜你心中有一个小镇，在你驶向大海远走高飞之前。” 第20封信 在一个没有咖啡馆的城市里 P134 “酒吧跟咖啡馆，在欧洲，其实就是社区文化。朋友跟街坊邻居习惯去那里聊天，跟老板及侍者也像老友。香港却显得很‘浅’——不知道这个词用得对不对。这里没有咖啡馆，只有蹩脚的连锁店星巴克和太平洋咖啡，要不然就是贵的要死其实根本不值得的大饭店。” P135 “人跟人之间愿意花时间交流，坐下来为了喝咖啡而喝咖啡，为了聊天而聊天，在欧洲是生活很大的一部分，是很重要得一种生活艺术。香港没有这样的生活艺术。” 第21封信 文化，因为逗留香港印象 P144 “那天很热，我背着很重的书，一条街一条街寻找，以为和台北一样，转个弯一定可以看到。可是没有。真的没有。去茶餐厅吧，可是那是一个油腻腻、甜滋滋得地方，匆忙拥挤而喧嚣，有人硬是站在你旁边瞅着你的位子。去星巴克或太平洋吧，可是你带着对跨国企业垄断得不满，疑惧他们对本土产业的消灭。不情愿在那里消费。” P145 “我们在谈的这个所谓‘咖啡馆’，当然不只是一个卖咖啡得的地方，它是一个‘个人’开的小馆，意思是，老板不是一个你看不见摸不着的抽象财团，因此小馆里处处洋溢着小店主人的气质和个性；它是社区的公共‘客厅’，是一个荒凉的大城市里最温暖的小据点。来喝咖啡的人彼此面熟，老板的绰号人人知道。如果因缘际会，来这里的人多半是创作者——作家、导演、学者、反对运动家……那么咖啡馆就是这个城市的文化舞台。” P146 “这个城市，连群众示威的大广场都没有。群众示威，和咖啡馆酒吧里的彻夜闲聊一样，是培养社区共识的行为，对加深文化认同多么关键。示威游行，绝对是极其重要的一种‘逗留文化’。但是，香港是个没有闲人，‘请勿逗留’的城市。” 第22封信 谁说香港没文化？ P156 （读者来信）“在你们的文章中，一再提到咖啡馆，并说明欧洲的咖啡馆出过多少名人。我想来想去，的确想不出，中国历史上这么多著名的文人学者，有谁是在咖啡馆完成大作的。但，他们就因为没有在咖啡馆沉思过，就不能获得你们的认同吗？今天和今后，东方的咖啡馆还是无法和西方咖啡馆相比，但东方的文化今天的成就与未来，就肯定将因此而逊色和不被看好吗？”（个人感触：龙应台先生和安德烈先生来往信件中提到的咖啡馆，代表这一类能给人以文化气息，静下来逗留的场所。既然台北和香港都属于东方地域中受西方文化影响最为深远的城市，作为西方许多文化甚至文明诞生发展的一大影响因素，分布在各个城市角落里的这些充满个人气息的“咖啡厅”，理应也被吸纳进两个城市的发展洪流中。然而事实是，并没有。不知道是怎样的一种过滤方式，这些文明根源的事物就这么被无情的抛掉了，不禁令人遗憾和惋惜。诸子百家以及之后几百年内的各个中国古代先贤，自然不是在咖啡厅里完成自己的大作的，可以是旷野的星空下，可以是周游马车上，但无疑，他们需要这样一个与他人，或者与自我，静下来，慢慢交流咀嚼的契机。西方的工业革命把生产力水平不知翻了多少倍，人们的生活节奏也自然被迫推着加速着，加速着。但是就是这么神奇，历史的车轮再快，也巧妙地避开了城市地一个个咖啡厅，保留了这一份每个人奢求地文化角落，这种保留是奢侈的，也是必要的。） 第26封信 孩子，你喝哪瓶奶？ P177 “你从坏的吃起，到明天，那好的也逐渐变坏了，结果你就一路在追赶那坏的，你永远在吃那不新鲜的苹果。你为什么不能就直接享受那最好的呢？” P179 “请问品味是什么？它不就是细致的分辨、性格的突出，以及独立个体的呈现吗？每一件，都正好是贫穷所吝啬给你的，也是威权政治所剥夺于你的。” P180 “如果太好的环境赋予了你美感和品味，那么它剥夺了你些什么？你的一切，是否其实有另一种的‘贫穷’？” 第28封信 给河马刷牙 P195 “对我最重要的，安德烈，不是你有否成就，而是你是否快乐。而在现代的生活架构里，什么样的工作比较可能给你快了？第一，它给你意义；第二，它给你时间。你的工作是你觉得有意义的，你的工作不绑架你使你成为工作的俘虏，容许你去充分体验生活，你就比较可能是快乐的。至于金钱和名声，哪里是快乐的核心元素呢？假定说，横在你眼前的选择，是到华尔街做银行经理或者到动物园做照顾狮子、河马的管理员，而你是一个喜欢动物研究的人，我就完全不认为银行经理比较有成就，或者狮子、河马的管理员‘平庸’。每天为钱的数字起伏而紧张而斗争，很可能不如每天给大象洗澡，给河马刷牙。” P195 “当你的工作在你心目中有意义，你就有成就感。当你的工作给你时间，不剥夺你的生活，你就有尊严。成就感和尊严，给你快乐。” P195 “我怕你变成画长颈鹿的提摩，不是因为他没钱没名，而是因为他找不到意义。我也要求你读书用功，不是因为我要你跟别人比成就，而是因为，我希望你将来会拥有选择的权利，选择有意义、有时间的工作，而不是被迫谋生。” P195 “如果我们不是在跟别人比名比利，而只是为自己找心灵安适之所在，那么连‘平庸’这个词都不太有意义了。‘平庸’是跟别人比，心灵的安适是跟自己比。我们最终极的负责对象，安德烈，千山万水走到最后，还是‘自己’二字。因此，你当然更没有理由去跟你的上一代比，或者为了符合上一代对你的想象而活。” 第29封信 第二颗眼泪 Kitsch让两颗眼泪快速出场。第一颗眼泪说：孩子在草地上跑，太感动了！第二颗眼泪说，孩子在草地上跑，被感动的感觉实在太棒了。跟全人类一起被感动，尤其棒！使Kitsch成为Kitsch的，使那第二颗眼泪。——《生命中不能承受之轻》 “还好昆德拉说，那第一颗眼泪不是，第二颗才是Kitsch。” 第31封信 两只老虎跑得慢、跑得快 “‘你以后一定不能忍受城乡差距、贫富不均所带来的不公平。’也就是说，‘失败启蒙’给我的教训，不是打入‘成功者’的行列，而是，你要去挑战，去质疑‘成功者’的定义。” 第33封信 人生诘问 “安德烈：我想知道，你怎么面对人家总是期待你有思想、有智慧这个现实？ 安德烈，一半的人在赞美我的同时，总有另外一半的人在批判我。我有充分机会学习如何‘宠辱不惊’。至于人们的‘期待’，那是一种你自己必须学会去‘抵御’的东西，因为那个东西是最容易把你绑死的圈套。不知道就不要说话，傻就不假装聪明。你现在明白为何我推掉几乎所有的演讲、座谈、上电视的邀请吧？我本来就没那么多知识和智能可以天天去讲。” 第35封信 独立宣言 不繁文缛节，却也不失礼貌，给人以必要的人格尊重，这就是你要做的。 在时光里 “‘马克·吐温说，’安德烈伸手拿起一粒绿色的橄榄，放在嘴里，似乎在品尝，然后慢条斯理地说，‘我评判一个人的品格，不看他如何对待比他地位高地人，我看他如何对待比他地位低地人。’”]]></content>
      <categories>
        <category>阅读</category>
      </categories>
      <tags>
        <tag>阅读</tag>
        <tag>书信</tag>
        <tag>龙应台</tag>
        <tag>安德烈</tag>
        <tag>亲爱的安德烈</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[《岛上书店》读书笔记]]></title>
    <url>%2F2018%2F03%2F16%2F%E3%80%8A%E5%B2%9B%E4%B8%8A%E4%B9%A6%E5%BA%97%E3%80%8B%E8%AF%BB%E4%B9%A6%E7%AC%94%E8%AE%B0%2F</url>
    <content type="text"><![CDATA[书中书目 P97《白鲸》 赫尔曼·麦尔维尔 P99《古拉格群岛》 索尔仁尼琴 P99《纳尼亚传奇》系列 C.S.刘易斯 P107 《洛城机密》詹姆斯·埃尔罗伊 犯罪小说 P119 《真爱如血》电视剧 P132 《好人难寻》弗兰纳里·奥康纳 P135 《卡拉维拉显驰名的跳蛙》 马克吐温 P135 《所罗门之歌》 托妮·莫里森 P135 《奥丽芙·基特里奇》 伊丽莎白·斯特鲁特 P183 《与父亲的对话》 格蕾斯·佩利 P197 《逮香蕉鱼的最佳日子》 J.D.塞林格（A.J.谈到对玛雅作品的建议，移情，为什么人们会做他们想做的事？ P209 《泄密的心》 埃德加·爱伦·坡 P213 《我们的小镇》 桑顿·怀尔德 P216 《德伯家的苔丝》《约翰尼上战场》《永别了，武器》《为欧文·米尼起到》《呼啸山庄》《织工马南》《他们眼望上苍》《我们的秘密城堡》 P223 《铁头》 艾梅·本德 P235 《追忆似水年华》 马塞尔·普鲁斯特 P246 《尘雾家园》 安德烈·迪比三世 P249 《当我们谈论爱情时我们再谈论什么》 雷蒙德·卡佛 P257 《书店老板》 罗尔德·达尔 P269 《美国众神》尼尔·盖曼 因为从心底害怕自己不值得被爱，我们独来独往，然而就是因为独来独往，才让我们以为自己不值得被爱。有一天，你不知道是什么时候，你会驱车上路。有一天，你不知道是什么时候，你会遇到他（她）。你会被爱，因为你今生第一次真正不再孤单。你会选择不在孤单下去。 内容摘录 P210 “一个地方如果没有一家书店，就算不上个地方了。” （AJ和妮可） P266 “没有书店的地方算不上是个地方。”（兰比亚斯和伊斯梅） P261 他会再试试，他永远不会放弃尝试。“玛雅，我们会成为我们所爱的那样。是爱成就了我们。” 玛雅在摇头。“爸爸，对不起，我听不明白。” “我们不是我们所收集的、得到的、所读的东西，只要我们还或者，我们就是爱，我们所爱的事物，我们所爱的人。所有这些，我认为真的会存活下去。” 她还在摇头。“我听不懂你的话，爸爸。我希望我能。你想让我找艾米吗？要么也许你可以打出来？” 他在冒汗。交谈不再是有趣的，以前曾经很容易。好吧，他想。如果必须用一个单词，那就必须用一个单词吧。 ”爱？”他问。他祈祷自己说得对。 她皱起眉头，努力去辨读他的表情。“手套？”她问，“是你的手冷吗，爸爸？” 她点点头。她把她的手放在她手里。他的手本来冷，这时暖和了，他想好了今天说的够接近了。也许明天，他就能知道该怎么说了。]]></content>
      <categories>
        <category>阅读</category>
      </categories>
      <tags>
        <tag>阅读</tag>
        <tag>文学，小说</tag>
        <tag>岛上书店</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[《1988：我想和这个世界谈谈》读书笔记]]></title>
    <url>%2F2018%2F03%2F03%2F%E3%80%8A1988%EF%BC%9A%E6%88%91%E6%83%B3%E5%92%8C%E8%BF%99%E4%B8%AA%E4%B8%96%E7%95%8C%E8%B0%88%E8%B0%88%E3%80%8B%E8%AF%BB%E4%B9%A6%E7%AC%94%E8%AE%B0%2F</url>
    <content type="text"><![CDATA[内容摘录 P45 “我说，丁丁哥哥，你去做什么啊？ 丁丁哥哥说，我去和他们谈谈。 我说，你和谁谈谈啊？ 丁丁哥哥唇边露出微笑，急切地说，这个世界。” P62 “这样的旅行在我年少时曾经幻想过无数次，夜晚的国道李，我等待着自己梦寐以求的女子，开着自己梦寐以求的车，去往未知旅程的终点。未知旅程怎么会有终点，旅途上没有疲劳和困意，我们聊着电影和音乐，穿越群山和丛林，最终停在一泓无人的湖水旁边，有一个没有任何经济头脑的人开的酒店，干净便宜。” P86 “混乱的地面道路是最好的地方。1988就像我周围的人，国道就像这个杂乱的世界，在越无序的地方，我越能寻觅到安全感。这安全感的代价就是你要时刻集中精神，否则你就会被庞大的交通工具碾过。” P87 “生活它不是深渊，它是你走过的平原和你想登上的高山，它就像我们睡过的每一张床，你从来不会陷下去，也许它不属于我们，但它一定属于你，你觉得它在往下，是因为引力，它绝不会把你拖下深渊，它指向让你伏在地上，听听它的声音，当你休息好了，听够了，你随时可以站起来，你懂吗？” P97 “小学的离别，那是最不能知道你身边的人未来将变成一个什么样的人的时刻。” 这句话是后面很多故事开展的一个引子。 P98 “在一个陌生的环境里，我可以重新塑造一遍我自己，没有什么事不会改变的，我上一个角色已经演完了，这是我接的新戏。” P124 “我说：‘……但难道就没有人正儿八经的做新闻么？’ 朋友说，都有，每一拨李都有那么几个。 我说，那那些在哪里？ 朋友说，辞退了。” P124 “我坚信邪恶不能压倒正义……嗯。但是他们可以定义正义和邪恶。” P126 “你相信么，在这样一个世界里，你用脑子想过的事情，你总是以为你已经做过了，” P127 “其实温水煮青蛙是一个错误的俗语，温水煮不了青蛙的……不要拿青蛙给现实改变自己找借口，温水是煮不了青蛙的，青蛙没有那么蠢，这就是现实。”不是显示改变了自己，你很强，你没有跳出来，只是你自己不想，事你自己屈服，自己变了。 P141 “我早就想通了，人们埋怨一成不变，但也埋怨居无定所，人其实都无所谓，只要是给日子找点岔子而已，似乎只有违背现在的生活，才真正懂得了生活，生活就是一个婊子、一个戏子。一个你能想到的一切，你所有的比喻就在里面扔吧，你总是对的。因为生活太强大了，最强者总是懒得跟你反驳，甚至任你修饰，然后悄悄地把锅盖盖住。” P163 “当我的生命力只能讲一个故事的时候，我愿将这个故事说出来，这个故事平淡无奇，平铺直叙，既没有曲折，也没有高潮，也就是寻找，相识，分开，就如同走在路上看见一盏红绿灯一样稀松平常，但若驻足，你会发现，它永远闪着黄灯。我就一直看着这盏信号灯，在灯下等了很久，始终不知道黄灯结束以后将要亮起的是红色还是绿色，一直等成了一个红绿色盲。” P164 “我不知道是否有一种很奇怪的感情，它深到你想去结束它，或者冰封它。只因为它出现在错误的时间里，于是你要去等待一个正确时间重启它，而不是让错误的时间去消耗它。少则一天，多则一生。” P177 “移动着的人永远比固定着的人更]]></content>
      <categories>
        <category>阅读</category>
      </categories>
      <tags>
        <tag>阅读</tag>
        <tag>小说</tag>
        <tag>韩寒</tag>
        <tag>1988：我想和这个世界谈谈</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[《水滴直播，让你我的隐私再也不滴水不漏》]]></title>
    <url>%2F2018%2F02%2F20%2F%E3%80%8A%E6%B0%B4%E6%BB%B4%E7%9B%B4%E6%92%AD%EF%BC%8C%E8%AE%A9%E4%BD%A0%E6%88%91%E7%9A%84%E9%9A%90%E7%A7%81%E5%86%8D%E4%B9%9F%E4%B8%8D%E6%BB%B4%E6%B0%B4%E4%B8%8D%E6%BC%8F%E3%80%8B%2F</url>
    <content type="text"><![CDATA[无意间从朋友圈里看到了一条说说，主体内容是一段搬运自微博：“嘻哈公社”的自媒体采访视频，很短，但简单，却很现实。不知道是不是因为上了大学，看新闻的时间少了，还是真的社会已经适应了这种“直播”的存在，而我成了另类？ 抛开直播圈的其他乱象不说（你们都懂，某平台的某些知名主播的蛇皮操作，各种公关闹剧简直是一出年末大戏），我一直以为直播和生活的界限还是分的很开的。直播归直播，那是镜头上的人物，是在表演，可以有感情的虚假，可以有套路，可以有剧本，起码和“生活”总隔着一个界限。这个界限，你说不出是个怎样的存在，但都能感觉到它在这里，真实的在这里。 我也依稀记得斗鱼之前有过一个户外板块（不知道现在是否还存在），专门供主播分享户外生活的点点滴滴，直播里自然会出现其他“路人”，不过“路人”们都清楚的明白，有一个手持的直播设备在对着自己，无论愿意还是不愿意，至少，他们都是知情者，清楚自己已经穿过那条“界限”，站在这个直播平台提供的“舞台”上，成为了万千观众眼中的表演者。 然而，我从未想到过，我会被剥夺这份知情权，被永远剥夺。 某天，你打开某上市公司的直播平台 你会惊奇的发现 镜头上表情呆滞的自己， 柜台前输入密码的自己， 和密友讨论私事的自己， 表演出丑后尴尬的自己， 买东西犹豫不决的自己， 和那个他/她亲热的自己， 失恋后酒吧买醉的自己， 而且，不仅有你自己，还有无数磕着瓜子吃着西瓜，以单身不知多少年的手速敲击键盘，享受着这种360度全方位无死角的窥屏狂魔们。你生活的一切横截面，无论你想或不向，都会成为这些人的娱乐自我的资源。 我从不认为有错的技术，只有错的人与错误的利用方式。 谢谢水滴直播，谢谢周总，让我明白《楚门的世界》有机会成为现实。 谢谢水滴直播，谢谢周总，让我知道天网监控对个人隐私的侵害是多么的彻底。 谢谢水滴直播，谢谢周总，让我知道删掉360不仅是对电脑的保护，更是对自我的保护。 谢谢水滴直播，谢谢周总，让我知道身边的一切private things是多么的宝贵。]]></content>
  </entry>
  <entry>
    <title><![CDATA[读《还好我不是新加坡人》有感 转自新浪微博]]></title>
    <url>%2F2018%2F02%2F20%2F%E8%AF%BB%E3%80%8A%E8%BF%98%E5%A5%BD%E6%88%91%E4%B8%8D%E6%98%AF%E6%96%B0%E5%8A%A0%E5%9D%A1%E4%BA%BA%E3%80%8B%E6%9C%89%E6%84%9F%20%E8%BD%AC%E8%87%AA%E6%96%B0%E6%B5%AA%E5%BE%AE%E5%8D%9A%2F</url>
    <content type="text"><![CDATA[转自新浪微博 原文地址 作者龙应台是台湾著名社会批评家，八十年代她在宝岛“放火”，一时间名声大噪，那本《野火集》让她从此广为人知。而上世纪九十年代，她又在新加坡“放火”,写下了这么一篇极具争议性的文章。 龙应台一向以文笔犀利老辣，说话微言大义而出名，这篇文章显然也有这一特点。细细读来，这篇杂文和她的大多数作品一样，都是着一时事或是小事出发，从而牵引出一个相当大的命题。在本文中她先是提出对新加坡外长在国际会议上以亚洲人代表自居，将狮城文化等同于亚洲文化的不满，在此基础上，她开始批判新加坡的某些法律条文和政府政策。其中最一针见血的要属那句：“给我再高的经济成长，再好的治安，再效率十足的政府，对不起，我也不愿意放弃我那一点个人自由与尊严。” 意料之中的，这篇短文遭到一片骂名。龙应台觉得委屈，另外发文称自己将主要火力放在了外长未经其它亚洲人考据和同意就把自己、乃至把新加坡当作亚洲代表这一点上，她不满外长以亚洲之名发出新加坡人的声音。然而，令那些愤怒的新加坡人真正不满的却是她在文章最后对于狮城的举例讽刺与挖苦。 在我想来，在这场唇舌交战中无论作者还是读者都有点小题大做的嫌疑。众所皆知，一篇好的批判性文章必须夺人眼球，因此，这篇文章的标题和结尾必须令人眼前一亮。龙应台不满自己的亚洲人身份“被代表”，这体现了她尊重人权、支持自由的一面，当然这与她的身份和多年留洋经历是分不开的。而想想新加坡文化与西亚文化、印度文化的巨大差别，让它来代表亚洲人说话的确有点名不正而言不顺。但实际上，我们也必须承认，在特定场合里，让新加坡代表亚洲人说法也未尝不可，本来这就是个多民族的国家，它的文化融合了中华文化、马来回教文化、印度文化，作为亚洲文化的大熔炉，在非正式场合把自己当代表那还是有点说服力的，我们不也常常理直气壮地说“我们亚洲如何如何”吗？但鉴于那是在国际官方会议上的讲话，加之明明知道事后会被西方媒体大肆渲染一番，这为代表实在不合适。 再看那最令狮城人民不满的部分，即龙应台对狮城政策的批判，说真的这部分占全文的比例并不大，又何以一石惊起千层浪呢并且几无附和龙文之音呢?对此龙应台的解释是：一是新加坡人确实比较满意于现状，乐于接受由权威政府领导的生活方式；或者，在权威的笼罩之中，不同基调的声音根本还不敢冒出来。”我觉得这两个原因都有可能。的确，新加坡这个蕞尔小国近几年的发展倍受瞩目，亚洲四小龙之一的实力实在不容小觑。有很多人都在羡慕“花园城市”的廉政与洁净。短短几十年就有了如此大的进步和成就，狮城人民很有可能是对政府十分满意甚至是充满感恩的。当然，这并不代表这个国家就没有问题，但是很明显这种政体、甚至是这份普遍的感激都极有可能成为“敢怒而不敢言者”沉默的原因。所以说，第二个假设也可以成立。 这么说来，是龙应台恶意赚取噱头，鸡蛋里挑骨头了？当然不是。我们必须承认她的出发点是善意的，甚至可以说是极具理想化的，事实上无论在哪一个国家，知识分子愿意为社会的鸡毛蒜皮小事而生气、而发出批判之声，这是一件很幸运的事情，何况和她当年批判台湾相比，这篇文章已经很客气。正因我们身处于这样不够完美的社会与时代，我们才应该对小事看不顺眼、对琐事斤斤计较—只要我们都是为了让这个社会变得更好。批评，让学者们慎思、明辨。也正因如此，当今不少学者都认为，将眼下大热的龙应台和周国平放在一起，两者固然没什么可比性，但是对青年人而言，读多一点龙应台也许会对这个国家更有益。如果硬要就新加坡到底好不好来说，或许只能是：子非鱼安知鱼之乐。 读罢这篇杂文，我想这其中还有很多东西值得我们深思：同是一个多民族国家，新加坡何以拥有这么强的核心凝聚力？再者，如果连这般清廉、法制完善的新加坡都被人这样批评，我们正在崛起的中国又该何去何从？换句话说，如果现在让龙应台来批判中国大陆，她又会有多少文章可作？ 一番深思熟虑后，我想我最欣赏的还要属新加坡《联合早报》，它居然胆敢在本国报纸上刊登这么一篇必将刺痛人民神经的文章。我也钦佩龙应台，她居然胆敢在自己的文集里放进这么多批评自己的文字。看似是拿自己的手打了自己的脸，但为何此时此刻，我有种回到百家争鸣时代的错觉呢?]]></content>
      <categories>
        <category>随笔</category>
      </categories>
      <tags>
        <tag>龙应台</tag>
        <tag>随笔</tag>
        <tag>读后感</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[《野火集》读书笔记]]></title>
    <url>%2F2018%2F02%2F20%2F%E3%80%8A%E9%87%8E%E7%81%AB%E9%9B%86%E3%80%8B%E8%AF%BB%E4%B9%A6%E7%AC%94%E8%AE%B0%2F</url>
    <content type="text"><![CDATA[内容摘录 P10 “说穿了，龙应台所传承、传递的野火，其实就是一种乌托邦的想象。教导我们在现代的荒原上培养价值的火种，批判的火种，或点灯或放火，在众多的小天地和大天地，边缘和中间之间，找到一种新的文化串联的策略……”《野火集》中野火的多层含义，一方面是指如同普罗米修斯为人类带来神火，龙应台给台湾带来思想与意识观念的”野火“，她这个”盗火的玉娇龙“，背负着维护古典价值的使命，在哪个时代挂起漫野的星星之火。 P11 “如福柯所说，我们一再发现自己处于开始的位置；因为这样，我们更应该一起思索未来，以新的火焰挑战者、文化挑战者为己任，化被动为主动，大力叩问个体生命的意义，将我们共同的困境，化成一场戏剧性的自我追寻，扩张梦想的蓝图和坐标，脚踢东西文明，甚至期待有一天，将龙应台的野火放回西方去。” P24 “……倒觉得八零年代就是太近的昨天，时间很长，路却走得不十分远。” P28 “八零年代，我从台北走到北京，在从莫斯科走到东伯里的大街上，秋色萧萧，已是年代末了。我看见作家在对群众演说，群众在对天空呐喊，天空，默然下起了冷雨，雨水冲洗着人们脸上悲愤激情的泪水。 那是一个最坏也最好的时代，最黑暗也最光明的时代。因为黑暗，所以人们充满了追求光明的力气和反抗黑暗的激情，而且黑白分明，奋斗的目标多么明确。力气、激情、目标明确——八零年代是理想主义风起云涌的时代。只有在得到”光明“之后，在”光明“中面对个人自我的黑暗，发现那黑暗更深不可测，我们才进入了疑惑不安的九零年代，世纪之末。” P31 “个人要从民意的强大束缚中解放出来，要向民意的平庸统治争取不同流俗的权利。极权瓦解之后，压迫着个人的是无数个个人所结成的集体，’民意’.” P31 “梁启超在七十年前说过的话，更令我惊诧其早熟：‘……岂独裁军阀财阀的专横可憎可恨，就是工团的同盟抵抗乃至社会革命还不是同一种强权作用！只不过从前强权，在那一班少数人手里，往后的强权，移在这一班多数人手里罢了。’” P33 “个人，当他是反对者的时候，她不被捕杀就是圣洁的英雄。当他不再是反对者，严酷的测验就来了：他是否能抵挡权力腐化，他是否能承担责任，他是否能容忍异己。许多事实表明：那打破了专制的英雄们竟是无数个专制的个人。个人，才是黑暗的真正来源。” P62 “我爱惜我的学生；像努力迎取阳光的黄色向日葵，他们聪慧、纯洁、奋发，对老师尤其一片真情。但是，他们也是典型的中国学生：缺乏独立自主的个性，盲目服从权威，更严重的，他们没有——完全没有——独立思考的能力。 错在学生吗？ 当然不是。学生是一抔混沌的黏土，在教育者的手中揉搓成形。从小学到大专联考这个漫长过程中的种种问题，暂且不谈，让我们看看这些‘不敢’、‘泪眼汪汪’、‘没有意见’的大学生正在接受什么样的高等教育…….我一直以为大学校长是高瞻远瞩，指导学术与教育大方向的决策人，而不是管馒头稀饭的保姆，但这也暂且不提。这一类型的教育者的用心，毋庸置疑，当然是善意的，问题是，我们论‘事’的时候，用心如何根本不重要，重要的是实际的后果，而教育的后果和其严重！这种喂哺式、育婴式的大学教育刚好吻合心理学家Levy早在一九四三年给所谓‘过度保护’（Overprotection）所作的诠释：第一，给予过多的接触——‘有任何问题，随时来找我’；第二，禁止他独立自主——‘你不许……’；第三，将他‘婴儿化’——‘乖，早睡早起。’；第四，把自己的价值取向加诸其身——‘你听我的……’在这种过度呵护的幼稚教育下成长的大学生，遇事时，除了‘泪眼汪汪’之外又能做什么呢？” 1984，奥威尔的台湾 P117 “要出书时，书稿要送印刷厂了，出版人和我面对面发愁，这一篇，收不收进书里？收进去，可能使整个书被查禁销毁，前功尽弃；不收进去，唉，龙应台实在，实在不甘心！ 夜很深了，我抬起头，说：‘收。’” P120 “那么我们要不要言论自由？这个问题本身大概就是一个忌讳——我们对外号称‘自由’，当然本来就有言论自由，而且是宪法保障的，问‘要不要’简直是自打耳光。可是自打耳光总比等着让别人来打要好得多。” P121 “一方面鼓励学生去努力追求真理，真相。一方面有用各种手段防止学生得到某种知识——学生难道是智能不足。我们希冀他不会发现这两种态度间的严重冲突？这种掩藏式的做法不仅暴露出执政者及教育者的虚伪。而且更可笑的，他根本行不通！思考是追求真理的工具，学生一旦获得这个工具，我们就不可能对他说：你去治学问，但不要碰政治。譬如说一个有能力深思经济问题，文学问题的人，他一定也有能力分析政治问题。反过来说，如果我们执意不让学生在政治问题上刨根问底，唯一的办法就是根本不教他追求真理的原则与方法，不给他‘思考’那个刨根问底的工具——但是这样一来，我们还谈什么教育？” 麦尔教授的老鼠实验——“以不变应万变”的古板愚蠢，甚至还在一代代的加重，“遗传”给后人。 P126 “一个国家，又何尝不是个精神可能崩溃的老鼠？！……如何能不受制于旧习惯、旧观念、就方法，如何不搞‘拧’了去老撞一闪没有乳酪的门而撞得鼻青脸肿，需要的是弹性与智慧。 智慧布政使人之所以为人，鼠之所以为鼠的差别吗？” P131 “在台湾革新很难，一方面固然是由于许多制度的僵化……另外还有保守的执政单位对社会自觉运动的移惧。一个更大的障碍，确实民众本身的缺乏动力。” P142 “‘野火’只有一个简单的要求：撕掉蒙眼布。对‘野火’狂热的反响或许也就传达了那么一个简单但迫切、坚决的讯息：我们不要蒙眼布！让子女，学生，人民都用自己的眼睛去看。自己的头脑去想。” P166 “脱法行为频繁，公权力低落，有一个更根本的原因：执法者与执政者同体……执法者虽然有心执法，但是因为与执政者通体，执法起来就难免背上‘迫害’的大帽子。为了避嫌，只好让法律放个假。” 我的台湾意识 P169 “战前的日本，跟目前的中国台湾一样，所有的教科书都由政府统一编制……把教育作为一种政治手段，就是家永一类的学者所惧怕的，他们害怕历史的大悲剧重演。战后的日本和多数欧美国家一样，教科书由民间自行编制，政府只能审核品质，但是不能操纵它的内容。这种做法的目的，当然在避免一个政府有计划、有系统地制造易于统治的顺民。” 寒食节 P205 “唐朝时，中国的文化到达空前的高峰，是当时世界上最强盛的国家。我们对唐文化的了解有限，尤其是唐朝的节日。 唐人很重视的节日是寒食，设定在冬至后的一百零五日，大约在清明节前的一日。这天全长安城的炉灶内都不能有火，人们吃冷粥及冷饼，等到第二天一早，由大明宫内传出薪火，到家家户户的灶内。 这是一个充满了象征意义的节日，而且非常严厉地执行，寒食日仍起火者，要处以死刑的。”]]></content>
      <categories>
        <category>阅读</category>
      </categories>
      <tags>
        <tag>阅读</tag>
        <tag>龙应台</tag>
        <tag>杂文集</tag>
        <tag>野火集</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[《天幕红尘》读后感]]></title>
    <url>%2F2018%2F02%2F19%2F%E3%80%8A%E5%A4%A9%E5%B9%95%E7%BA%A2%E5%B0%98%E3%80%8B%E8%AF%BB%E5%90%8E%E6%84%9F%2F</url>
    <content type="text"><![CDATA[转自豆瓣 原文地址 数年前，看电视剧《天道》的时候，面对剧尾的那一场诉讼，我佩服得五体投地，于是，给某人出了一道题：如果一个农村家庭作坊被人谴责为滥用童工，怎么辩护？彼时，还算是民商法才子的某人给了一个答案。但是，我依然觉得是电视剧中的辩护词更赞。 电视剧中，中年的农民大叔说，农村的孩子，谁不是从小就帮着家里干活的呢？难道这也是用童工？其实，当时我转述问题的时候也有所遗漏。但是，不管怎么样，《天道》惊艳了我，豆豆也惊艳了我。只是，豆豆创作的小说数量并不多。而我，又属于那种心理洁癖者，很少在看完电视剧以后再看原著小说或者在看完原著小说后又去看电视剧的。所以，我并没有读过《天道》的原著小说《遥远的救世主》，我读了《背叛》。豆豆的小说有着明显的style，就像是大树的年轮，早已融于自身，无法消除。 豆豆的男主，都是有着绝顶的智慧的，就像是罗贯中笔下羽扇纶巾的诸葛亮，对方的一举一动、事态的发展，皆在自己的预料之中。无论是宋一坤，还是丁元英，抑或是叶子农，都是那种其貌不扬，扔在人堆里就找不到的主儿，但是，却具有翻手为云覆手为雨的能力。而他们的这种操纵乾坤的智慧和能力，在小说里，则体现为游走于法律的边缘。这句话，用通俗的说法叫做“打法律的擦边球”。无论是丁元英设计的“劫富济贫”，还是叶子农策划的“劳务输出”，较了真，其实都是违法行为。 但是，叶子农则认为自己的这种行为并非钻法律的空子，因为他的所思所想所作所为，均在法律认可的范围以内，既然法律没有明确禁止，那就是合法的。呵，这个人，倒是懂得将私法上的“法无禁止即自由”的思想应用于实践。“情深不寿，慧极必伤。”善于谋划，并且算无遗策的人，是一种“只可远观”的神话；从某种程度上来讲，他们的存在对于他人来说也是一种“危害”。这样的人，要么屹立于社会之巅，操纵着芸芸众生；要么，注定无法容于世。所以，天神一般的神机妙算的诸葛亮只是罗贯中在正统思想下塑造出来的“演义”。 所以，宋一坤用鲜血来洗刷自己的罪孽；所以，丁元英孤独终老；所以，叶子农倒在了异国他乡。 作品中，人物身上的种种智慧，事实上，都是作者自身智慧的投影。]]></content>
      <categories>
        <category>阅读</category>
      </categories>
      <tags>
        <tag>阅读</tag>
        <tag>小说</tag>
        <tag>豆豆</tag>
        <tag>天幕红尘</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[2018.2.3-2018.2.5武汉游记]]></title>
    <url>%2F2018%2F02%2F19%2F2018.2.3-2018.2.5%E6%AD%A6%E6%B1%89%E6%B8%B8%E8%AE%B0%2F</url>
    <content type="text"><![CDATA[第一天 2.3号。原本打算集训完直接回家的，临走前两天打开携程，下一站并不是石家庄，而是武汉。脑子里突然想起了那个“一时冲动”。哈，虽然不像自己的风格，但是既然买了票，那就一去吧 2.2集训完，晚上收拾寝室+整理行李就鼓捣到了2点多，拜托馨馨没睡的话6点钟把我叫起来，不过好在重要的事情自己心里也都有个谱，虽然睡眠时间不多，第二天一早还是自然醒了。把计划好的事情一件件做完，还了宁哥的电车钥匙，把没吃完的枇杷送给宿管阿姨，拎着强行塞下的行李箱和电脑包，地铁来到了长沙南站，本想着高铁一路还能看看南方这边郊外的风景，不过也许是前一天晚上收拾得有些晚了，上了高铁倒头就睡，一觉醒来已经是“列车即将到达武汉站“。精神迷糊得导致我下车时候应该把我仅带得一本小说《月亮与六便士》落在了座位上，可能是真的不打算让我读完它了哈哈哈（这可是我仅带的一本小说啊）。下了高铁在武汉站里吃了热干面，听了一个好心大姐的建议，在吃饭的地方换了些零钱然后买了一张城市交通一卡通（后来事实证明它发挥了无比巨大的作用）。午饭过后，乘地铁到了户部巷附近，入住如家，由于是内宾，光线不是很好，得，困意再次袭来，我一个午睡足足睡到了7点钟。还因此错过了我妈的电话，搞得她老人家着急了一番（生怕我这个一米八几的人在武汉被拐了）。 好好的休息了一番后，我便开始了晚上的自由行程，先是户部巷吃了些小吃（热干面，鸭架，哦对那个糊米酒不错，少数我能吃得惯的酒酿产品。。），有意思的是，户部巷里排队最长的竟然是长沙的臭豆腐和大香肠，哇，我这半个长沙人心里也莫名有了几分自豪。顺着巷子走，尽头是一个不起眼的藏酸奶，再一拐面前就是沿江大道了，时间已经过了八点，人并不是很多，江风阵阵，江堤边有不同用处的码头，还有供行人夜赏江景的平台。自小在北方长大的我一直很向往这种有水伴城的感觉，与家乡的人工水系最大的不同，这里是”水养人“，而非”人养水“，面朝江河，或是风平浪静、波澜不惊，亦或是怒浪卷云、波涛汹涌，自然的表现从不因你的喜恶而改变，或者更严谨的说，其内蕴之博大更难凭你一人的感情去左右。如此，无论自己有什么烦恼，跑到江边，去听，去感受，你总会静下来，与人不一样，它无需承诺，无论你在或不在，它总在那里，不怨，不悔，不念，不恼，它的存在，对我自己而言，已是一种终不可达的傲然姿态，对它的这种敬佩，是心底里的。 步行了一段时间，我搭上了来往过武汉长江大桥的公交，回来的时候应该恰好是末班吧。下了车能望到夜里灯光装饰的黄鹤楼，照旧，不喜自拍，但不想错过景致，拍了几张照，走回了旅店，这一小段路也顺便摸清了明早跑步的路线，晚上和三五好友聊了些天，睡觉时候好像也不早了（似乎自己上了大学后一直没有早睡过）。 第二天 2.4号。前一天睡得不早，不过今天早晨还是兴致勃勃的7点钟起来了，既然拿了跑步的衣服，又有如此兴致（PS重点是我竟然起来了），当然要粗发啦，还能留个纪念。 半个小时4.5km跑了武汉长江大桥一个来回，新成就get哈哈，回来的时候看到了纪念碑，上面有毛主席所写的”一桥飞架南北，天堑变通途“。当然，希望自己今后和村上春树先生一样，能坚定的做自己爱干的事业，同时还能坚定的做一个跑者。上午抓紧时间把武昌有文化存留的这一个区域都逛了一遍，黄鹤楼景区无论是火爆的还是冷门的景点都看了一遍，不曾想除了语文书中所提到的崔颢创作《黄鹤楼》，以及李白搁笔的故事，这座”天下江山第一楼“还与诸多历史名人有着千丝万缕的联系。过费祎亭，知晓了传说费祎死后登仙，每乘黄鹤于此憩驾。学了些历史知识，南朝刘宋就三国孙权所建夏口城扩建而成郢州城，地理位置就位于武汉市武昌蛇山，也就是黄鹤楼所在的这一片区域，而此处在宋朝时就是岳飞抗金作战的前线，而岳飞在郢州驻军时间最久，黄鹤楼景区内也有岳飞这一历史名将的雕塑，供后人瞻仰。哦对还有一点，黄鹤楼多次被毁重修，如今的黄鹤楼实际上是建国后重新修建的，清光绪十年（1884年）大火，留下来的只有黄鹤楼东侧的古铜顶。 游完黄鹤楼景区，旁边的首义公园是旧武汉省图书馆所在，但是现在已是危房，修缮中并没有对外开放。我便乘公交，过武昌路隧道，向北，到了沿江边的红色景点区，包括毛泽东旧居，中共五大会议旧址，革命时代的记忆，因为没有相似的经历，所以看革命先辈抛头颅，洒热血，更多的是敬佩，为信仰而奋斗，无需其他理由。之后又回户部巷，到老字号蔡林记吃的武汉正宗热干面。嗯对顺便尝了下恩施小土豆。看了看日期，今天是星期日，想起来多数博物馆都是周一闭馆，作为一个博物馆狂人，赶紧下午麻溜的跑到湖北省博物馆，先把最出名的看了再说，剩下的。。总之以后还会到武汉来的嘛。 博物馆的镇馆之宝应该就是曾侯乙编钟和越王勾践剑了，听了app上的讲解（竟然不是免费的，还很难用，差评），这两件文物以及相关历史和考古知识讲解的都比较仔细，剩下的，知识的系统性和文物的丰富性并比不上陕西历史博物馆等。但凡是参观博物馆，多看看，有收获就是好的。出了博物馆，这时旁边的湖北省美术馆已经关门了，好吧虽然有些可惜，不过还算留下了再来武汉游玩的决心。回去的路上经过现在的武汉省图书馆，不得不说比家乡的河北省图书馆要大好多啊。。外部造型和内部构造以及环境氛围都很让人有静下心来读书的赶脚，进馆的每个人也都很自觉地压低了自己的声音，总之氛围很好。 回到如家拿上行李，准备开拔到民宿的小姐姐家，公交到了楚河汉街附近，也是她强烈安利的，em或许不是因为这个，我也不会选择这边的民宿吧，哈。楚河汉街处于武汉中央文化区，地理位置相当于武汉市的几何中心，官方说明为”万达集团投资500亿元人民币，倾力打造的以文化为核心，兼具旅游、商业、商务、居住功能的世界级文化旅游项目“。晚上一个人走了个来回，哈确实不同的人总会找到不同的吸引点，购物达人-&gt;时装品牌，美食博主-&gt;小吃街，文艺青年-&gt;文创书店，都有适合你的那一个。我吃了点小吃然后就在文华书城看了会儿书，重点是，里！面！有!3D-JP！拼图店！突然回忆起了那段和拼图斗智斗勇，哦不，只有斗智的时光。 第三天 2.5号。emm早晨睡了个懒觉，今天是公交车上的一天哈哈。上车坐公交坐错方向了，不过正好公交线路正好是沿着东湖走一圈，干脆一不做二不休，坐到了终点站再坐回来（不愧是时间多），音乐与东湖美景相伴，这一趟值了。经过武汉长江二桥，我来到了汉阳，听了天骄的安利想着去看一下江汉关博物馆，不过么，确实博物馆周一都不开，江汉关也不例外。不过呐，以江汉关博物馆作为东头，恰巧是汉口地区最出名的文化购物一条街（一条街上足足有三四个阿迪达斯的专卖店。。），建筑都是民国风的，当然，这里不同于汉街，有不少是“真民国”，比如上海银行汉口分行旧址（现在在这里是工商银行的地界了），三段式立面，中段采用爱奥尼双柱巨柱式，还有四明银行旧址（现在是OCE的专卖店），以及不知道是不是真民国遗存的中国银行（看得挺像得），闲逛一小圈后，我又搭乘地铁来到了琴台附近，先去东边得汉阳造文化创意产业园游览了一番，这里的工作氛围并不像大型公司那样紧凑忙碌充满商业气息，相反，一股“文新”感觉扑面而来，作为比较小众的景点，步行游览的人也有，但并不多，三三两两，时而有看着像因公来此处的轿车出入，靠近入口的知音书店或许是和我的生活相交最多了吧，在门口张望了一阵子，书店里的灯透过帘子隐约感觉韩式亮的，但是并没有看到里面有人在的迹象，我还是被好奇心驱使着推开门进了这家书店，少往里一拐，一个年纪比我稍长几岁的姐姐还在吧台读着书，确实没有其他客人，不过看到我来还是很热情的走来欢迎。环顾书店，并不大，中间整齐的放置着六张木制桌椅，很复古，再往里还有一个“国学讲坛”，整体风格相较于现代的书咖更传统些，书籍也是很规则的摆放在两边靠墙的书架上。一杯海盐咖啡，一本1Q84陪着我度过了一个下午，在这里工作的姐姐并没有怎么打扰我，难以言说的“温暖孤独”。 傍晚时分来到了西边的古琴台，这里规划成了一个集成剧院和音乐厅的休闲公园，地图上标记为“月湖风景区”，一个北方人，看到水和湖，又是一脸羡慕的表情，景色还是蛮不错的，公园还很贴心的规划了步行推荐路线，我也确实见到几个在附近居住的武汉市民在这里步行健身。 晚上在光谷逛了一番，emm规划的很大，不过整体的感觉有点杂乱，看看时间已经十年了，再一想，十年！十年前武汉这么靠东的地方就有这样规格的购物广场了，确实发展步伐要快很多啊。比较有意思的小插曲就是晚上部门培训，哇花着全国流量举着手机看了一路（怕是被路人误当成追剧少年了哈哈哈）。 归途，返程。]]></content>
      <categories>
        <category>旅行</category>
      </categories>
      <tags>
        <tag>旅行</tag>
        <tag>游记，武汉</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[【POJ-1458】解题报告（DP，最长相同子序列）]]></title>
    <url>%2F2018%2F01%2F30%2F%E3%80%90POJ-1458%E3%80%91%E8%A7%A3%E9%A2%98%E6%8A%A5%E5%91%8A%EF%BC%88DP%EF%BC%8C%E6%9C%80%E9%95%BF%E7%9B%B8%E5%90%8C%E5%AD%90%E5%BA%8F%E5%88%97%EF%BC%89%2F</url>
    <content type="text"><![CDATA[原始题目Common Subsequence Time Limit: 1000MS Memory Limit: 10000K Total Submissions: 56895 Accepted: 23740 Problem Description A subsequence of a given sequence is the given sequence with some elements (possible none) left out. Given a sequence X = &lt; x1, x2, …, xm &gt; another sequence Z = &lt; z1, z2, …, zk &gt; is a subsequence of X if there exists a strictly increasing sequence &lt; i1, i2, …, ik &gt; of indices of X such that for all j = 1,2,…,k, xij = zj. For example, Z = &lt; a, b, f, c &gt; is a subsequence of X = &lt; a, b, c, f, b, c &gt; with index sequence &lt; 1, 2, 4, 6 &gt;. Given two sequences X and Y the problem is to find the length of the maximum-length common subsequence of X and Y. InputThe program input is from the std input. Each data set in the input contains two strings representing the given sequences. The sequences are separated by any number of white spaces. The input data are correct. OutputFor each set of data the program prints on the standard output the length of the maximum-length common subsequence from the beginning of a separate line. Sample Inputabcfbc abfcab programming contest abcd mnp Sample Output4 2 0 SourceSoutheastern Europe 2003 题目大意给定两个字符串，求最长相同子序列的长度。 解题思路入门dp，状态转移方程为：dp[i][j]={dp[i-1][j-1]+1(a[i]=a[j]), max(dp[i-1][j],dp[i][j-1])(a[i]!=a[j]} 解题代码12345678910111213141516171819202122232425262728293031#include &lt;cstring&gt;#include &lt;cstdio&gt;#include &lt;algorithm&gt;using namespace std;const int maxn=1005;int len1,len2;char s1[maxn],s2[maxn];int dp[maxn][maxn];void solve()&#123; for(int i=0;i&lt;len1;i++) &#123; for(int j=0;j&lt;len2;j++) &#123; if(s1[i]==s2[j]) dp[i][j]=dp[i-1][j-1]+1; else dp[i][j]=max(dp[i-1][j],dp[i][j-1]); &#125; &#125;&#125;int main()&#123; while(~scanf("%s%s",s1,s2)) &#123; memset(dp,0,sizeof(dp)); len1=strlen(s1),len2=strlen(s2); solve(); printf("%d\n",dp[len1-1][len2-1]); &#125; return 0;&#125; 收获与反思熟悉格式。]]></content>
      <categories>
        <category>编程</category>
        <category>ACM</category>
      </categories>
      <tags>
        <tag>算法</tag>
        <tag>ACM</tag>
        <tag>DP</tag>
        <tag>2018寒假集训</tag>
        <tag>POJ</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[【HDU-1518】解题报告（DFS，极易TLE，剪枝）]]></title>
    <url>%2F2018%2F01%2F29%2F%E3%80%90HDU-1518%E3%80%91%E8%A7%A3%E9%A2%98%E6%8A%A5%E5%91%8A%EF%BC%88DFS%EF%BC%8C%E6%9E%81%E6%98%93TLE%EF%BC%8C%E5%89%AA%E6%9E%9D%EF%BC%89%2F</url>
    <content type="text"><![CDATA[原始题目Square Time Limit: 10000/5000 MS (Java/Others) Memory Limit: 65536/32768 K (Java/Others) Total Submission(s): 17274 Accepted Submission(s): 5409 Problem DescriptionGiven a set of sticks of various lengths, is it possible to join them end-to-end to form a square? InputThe first line of input contains N, the number of test cases. Each test case begins with an integer 4 ≤ M ≤ 20, the number of sticks. M integers follow; each gives the length of a stick - an integer between 1 and 10,000. OutputFor each case, output a line containing “yes” if is is possible to form a square; otherwise output “no”. Sample Input3 4 1 1 1 1 5 10 20 30 40 50 8 1 7 2 6 4 4 3 5 Sample Outputyes no yes SourceUniversity of Waterloo Local Contest 2002.09.21 RecommendLL 题目大意给定M个小木棍的长度，问能否组成一个正方形。 解题思路题目很简单啊，思路也很简单啊，但是写出来就TLE了啊。。。如此可见dfs剪枝是多么的重要。 解题代码12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364656667686970717273747576777879808182#include &lt;queue&gt;#include &lt;cstdio&gt;#include &lt;cstring&gt;#include &lt;cmath&gt;#include &lt;cstdlib&gt;#include &lt;algorithm&gt;using namespace std;//dfsconst int maxn=25;int stick[maxn]; bool vis[maxn];int M,T,sum,len,flag,mmax,mmin; bool cmp(int a, int b)&#123; return a&gt;b?1:0;&#125;void dfs(int count,int now,int index)&#123; if(flag) return; if(count==4) &#123; flag=1; return; &#125; if(now==0) &#123; dfs(count+1,len,M-1); if(flag) return; &#125; else if(now&lt;mmin) return; for(int i=index;i&gt;=0;i--) //剪枝1：从index开始遍历 &#123; if(!vis[i]&amp;&amp;now&gt;=stick[i]) &#123; vis[i]=1; dfs(count,now-stick[i],i-1); //i已经使用过 if(flag) return; vis[i]=0; if(index==M-1)&lt;span class="space" style="white-space:pre;display:inline-block;text-indent:2em;line-height:inherit;"&gt;//剪枝2（重要剪枝）：由于每一边长度都相等，一边不能利用最长木棍的话，那么肯定这组数据肯定过不了，不需要检测了。&lt;/span&gt; &#123; return; &#125; //相同的忽略 while(stick[i]==stick[i-1])&lt;span class="space" style="white-space:pre;display:inline-block;text-indent:2em;line-height:inherit;"&gt; //剪枝3：同样长度的都过不了，无需再走一遍&lt;/span&gt; &#123;// printf("!1"); i--; &#125; &#125; &#125; return ;&#125;int main()&#123;// freopen("in.txt","r",stdin); scanf("%d",&amp;T); while(T--) &#123; memset(vis,0,sizeof(vis)); scanf("%d",&amp;M); flag=sum=0; for(int i=0;i&lt;M;i++) &#123; scanf("%d",&amp;stick[i]); sum+=stick[i]; &#125; sort(stick,stick+M); mmax=stick[M-1],mmin=stick[0]; len=sum/4; if(sum%4||mmax&gt;len) printf("no\n"); else &#123; dfs(0,len,M-1); if(flag) printf("yes\n"); else printf("no\n"); &#125; &#125; return 0; &#125; 收获与反思跟TLE斗智斗勇了一下午，慢慢嚼代码，想剪枝，确定剪枝的效果。（等待补图）]]></content>
      <categories>
        <category>编程</category>
        <category>ACM</category>
      </categories>
      <tags>
        <tag>算法</tag>
        <tag>ACM</tag>
        <tag>2018寒假集训</tag>
        <tag>补图</tag>
        <tag>HDU</tag>
        <tag>DFS</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[【CodeForces-455A】解题报告（DP，long long）]]></title>
    <url>%2F2018%2F01%2F29%2F%E3%80%90CodeForces-455A%E3%80%91%E8%A7%A3%E9%A2%98%E6%8A%A5%E5%91%8A%EF%BC%88dp%EF%BC%8Clong%20long%EF%BC%89%2F</url>
    <content type="text"><![CDATA[原始题目A. Boredom time limit per test 1 second memory limit per test 256 megabytes input standard input output standard output Alex doesn’t like boredom. That’s why whenever he gets bored, he comes up with games. One long winter evening he came up with a game and decided to play it. Given a sequence a consisting of n integers. The player can make several steps. In a single step he can choose an element of the sequence (let’s denote it ak) and delete it, at that all elements equal to ak + 1 and ak - 1 also must be deleted from the sequence. That step brings ak points to the player. Alex is a perfectionist, so he decided to get as many points as possible. Help him. InputThe first line contains integer n (1 ≤ n ≤ 105) that shows how many numbers are in Alex’s sequence. The second line contains n integers a1, a2, …, an (1 ≤ ai ≤ 105). OutputPrint a single integer — the maximum number of points that Alex can earn. Examplesinput2 1 2 output2 input3 1 2 3 output4 input9 1 2 1 3 2 2 2 2 3 output10 NoteConsider the third test example. At first step we need to choose any element equal to 2. After that step our sequence looks like this [2, 2, 2, 2]. Then we do 4 steps, on each step we choose any element equals to 2. In total we earn 10 points. 题目大意给出一个数列a1,a2,a3…ai…an。每次选定一个数ai，并且所有与ai-1，ai+1相等的数全部消去，这样消去一次得分为ai。最终把数列全部消去完，问最终最高得分是多少。 解题思路dp，数组A[ai]表示ai出现的次数，并且记录最大值mmax，从0到mmax走一遍dp。 状态转移方程为dp[i]=max(dp[i-1],dp[i-2]+A[i]*i)，即从小到大消去到ai=i时的最高得分为：消去到i-1的最高得分（因为消去i-1时所有i=i-1+1全部被消去）与消去到i-2的最高得分加上消去A[i]个i的得分（即跳过i-1不消去）。 由于涉及求和，ai乘上出现次数会超int范围，故使用long long。 解题代码1234567891011121314151617181920212223242526272829303132333435363738394041#include &lt;queue&gt;#include &lt;cstdio&gt;#include &lt;cstring&gt;#include &lt;cmath&gt;#include &lt;cstdlib&gt;#include &lt;algorithm&gt;//dp[i]=max(dp[i-1],dp[i-2]+a[i]*i)using namespace std;const int maxn=100100;long long dp[maxn],a[maxn];long long n,t,mmax;void solve()&#123; //0不出现，初始化 1 dp[1]=a[1]; for(long long i=2;i&lt;=mmax;i++) &#123; dp[i]=max(dp[i-1],dp[i-2]+a[i]*i); &#125; printf("%lld\n",dp[mmax]);&#125;int main()&#123; while(~scanf("%lld",&amp;n)) &#123; memset(dp,0,sizeof(dp)); memset(a,0,sizeof(a)); long long maxx=0; for(long long i=1;i&lt;=n;i++) &#123; scanf("%lld",&amp;t); if(t&gt;mmax) mmax=t; a[t]++; &#125;// for(long long i=1;i&lt;=n;i++)// printf("a[%d]=%d\n",i,a[i]); solve(); &#125; return 0;&#125; 收获与反思建立好状态转移方程就好，注意long long。]]></content>
      <categories>
        <category>编程</category>
        <category>ACM</category>
      </categories>
      <tags>
        <tag>算法</tag>
        <tag>ACM</tag>
        <tag>DP</tag>
        <tag>2018寒假集训</tag>
        <tag>CodeForces</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[【AtCoder-3881】解题报告（简单DP）]]></title>
    <url>%2F2018%2F01%2F29%2F%E3%80%90AtCoder-3881%E3%80%91%E8%A7%A3%E9%A2%98%E6%8A%A5%E5%91%8A%EF%BC%88%E7%AE%80%E5%8D%95DP%EF%BC%89%2F</url>
    <content type="text"><![CDATA[原始题目C - Candies Time limit : 2sec Memory limit : 256MB Score : 300 points Problem Statement We have a 2×N grid. We will denote the square at the i-th row and j-th column (1≤i≤2, 1≤j≤N) as (i,j). You are initially in the top-left square, (1,1). You will travel to the bottom-right square, (2,N), by repeatedly moving right or down. The square (i,j) contains Ai,j candies. You will collect all the candies you visit during the travel. The top-left and bottom-right squares also contain candies, and you will also collect them. At most how many candies can you collect when you choose the best way to travel? Constraints 1≤N≤100 1≤Ai,j≤100 (1≤i≤2, 1≤j≤N) InputInput is given from Standard Input in the following format: N A1,1 A1,2 … A1,N A2,1 A2,2 … A2,N OutputPrint the maximum number of candies that can be collected. Sample Input 1 5 3 2 2 4 1 1 2 2 2 1 Sample Output 1 14The number of collected candies will be maximized when you: move right three times, then move down once, then move right once. Sample Input 2 4 1 1 1 1 1 1 1 1 Sample Output 2 5 You will always collect the same number of candies, regardless of how you travel. Sample Input 3 7 3 3 4 5 4 5 3 5 3 4 4 2 3 2 Sample Output 3 29 Sample Input 4 1 2 3 Sample Output 4 5 题目大意2*N个格子，每个格子里均含有不同数量的蜡烛。每一次只能向右或者向下走，问从（1，1）走到（2，N）最多能收集多少根蜡烛（包括首尾）。 解题思路入门DP，简化成2*N了，状态转移方程：dp[i][j]=max(dp[i-1][j],dp[i][j-1])+a[i][j] 解题代码 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556#include &lt;cstdio&gt;#include &lt;cstring&gt;#include &lt;cmath&gt;#include &lt;iostream&gt;#include &lt;iomanip&gt;#include &lt;set&gt;#include &lt;queue&gt;#include &lt;stack&gt;#include &lt;vector&gt;#include &lt;string&gt;#include &lt;sstream&gt;#include &lt;bits/stdc++.h&gt;#define rep(i,a,n) for(int i=a;i&lt;n;++i)#define per(i,a,n) for(int i=n-1;i&gt;=a;--i);#define ms(x,a) memset((x),a,sizeof((x))) #define INF 0x3f3f3f3f#define eps 1e-8#define fi first#define se second#define mp make_pair#define pb push_back#define np next_permutation#define gapline cout&lt;&lt;"##======================##"&lt;&lt;endlusing namespace std;const int maxn=300;const int maxl=26;const int maxm=1e5+5;typedef long long ll;typedef unsigned long long ull;typedef vector&lt;int&gt; vi;typedef pair&lt;int,int&gt; pii;int n,m;int dp[maxn][maxn],a[maxn][maxn];void solve()&#123; rep(i,1,n+1)&#123; rep(j,1,m+1)&#123; dp[i][j]=max(dp[i-1][j],dp[i][j-1])+a[i][j]; &#125; &#125;&#125; int main()&#123; ios::sync_with_stdio(false); while(cin&gt;&gt;m)&#123; ms(dp,0); n=2; rep(i,1,n+1)&#123; rep(j,1,m+1) cin&gt;&gt;a[i][j]; &#125; solve(); cout&lt;&lt;dp[2][m]&lt;&lt;endl; &#125;&#125; 收获与反思 第一次小比赛实战应用dp，看了看大神们也都是dp秒出说明思路是正确的。能写好状态转移方程就行。 2018.8.23更新 代码优化，利用dp外围空白。]]></content>
      <categories>
        <category>编程</category>
        <category>ACM</category>
      </categories>
      <tags>
        <tag>算法</tag>
        <tag>ACM</tag>
        <tag>AtCoder</tag>
        <tag>DP</tag>
        <tag>2018寒假集训</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[【SCU-1114】解题报告（DP，路径，DFS）]]></title>
    <url>%2F2018%2F01%2F28%2F%E3%80%90SCU-1114%E3%80%91%E8%A7%A3%E9%A2%98%E6%8A%A5%E5%91%8A%EF%BC%88DP%EF%BC%8C%E8%B7%AF%E5%BE%84%EF%BC%8CDFS%EF%BC%89%2F</url>
    <content type="text"><![CDATA[原始题目下图是个数字三角，请编写一个程序计算从顶部至底部某处一条路径，使得该路径所经过的数字总和最大。 7 3 8 8 1 0 2 7 4 4 每一步可沿左斜线向下或右斜线向下走； 1≤三角形行数≤100 三角形中的数字为整数 0，1，……，99。 如果有多种情况结果都最大，任意输出一种即可。 输入：第一行一个整数N，代表三角形的行数。 接下来N行，描述了一个数字三角。 输出：第一行一个整数，代表路径所经过底数字总和。 第二行N个数，代表所经过的数字。 样例：输入：4 7 3 8 8 1 0 2 7 4 4 输出：25 7 3 8 7 解题思路入门dp，状态转移方程为dp[i][j]=max(dp[i+1][j],dp[i+1][j+1])+a[i][j]; dp[i][j]表示i行j列（即第i行j个数字到底部的最大和）。根据该状态转移方程递归实现即可。 本题不仅需要记录最终的和，还需要记录路径，这时候就需要根据dp的表再用dfs走一遍。 解题代码123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778#include &lt;cstdio&gt;#include &lt;cstring&gt;#include &lt;cstdlib&gt;#include &lt;cmath&gt;using namespace std;const int maxn=1e2+10; int n,m;//n行，m列 int a[maxn][maxn];int f[maxn][maxn];int ans[maxn];int flag;//f[i,j]=max(f[i+1,j],f[i+1,j+1])+a[i,j]int max(int a,int b)&#123; return a&gt;b?a:b;&#125;int dp(int i,int j)//递归实现 &#123; int t; if(i==n)//到底部 &#123; t=a[i][j]; return f[i][j]=t; &#125; else &#123; t=max(dp(i+1,j),dp(i+1,j+1))+a[i][j]; return f[i][j]=t; &#125; &#125;void dfs(int i,int j,int tot,int n) &#123; //cout&lt;&lt;i&lt;&lt;" "&lt;&lt;j&lt;&lt;endl; if(flag) return; if(i==n) &#123; for(int i=1;i&lt;n;i++) printf("%d ",ans[i]); printf("%d\n",ans[n]); flag=1; &#125; int tmp=tot-a[i][j]; if(tmp==f[i+1][j]) &#123; ans[i+1]=a[i+1][j]; dfs(i+1,j,tmp,n); &#125; else if(tmp==f[i+1][j+1]) &#123; ans[i+1]=a[i+1][j+1]; dfs(i+1,j+1,tmp,n); &#125; &#125; int main()&#123; while(~scanf("%d",&amp;n)) &#123; memset(a,0,sizeof(a)); memset(f,0,sizeof(f)); for(int i=1;i&lt;=n;i++) &#123; for(int j=1;j&lt;=i;j++) &#123; scanf("%d",&amp;a[i][j]); &#125; &#125; dp(1,1); printf("%d\n",f[1][1]); flag=0; dfs(0,0,f[1][1],n); &#125; return 0;&#125; 收获与反思开始在怎么寻找路径这里卡住了，学到的东西得反复看啊。。不然真的不会用。]]></content>
      <categories>
        <category>编程</category>
        <category>ACM</category>
      </categories>
      <tags>
        <tag>算法</tag>
        <tag>ACM</tag>
        <tag>DP</tag>
        <tag>2018寒假集训</tag>
        <tag>DFS</tag>
        <tag>SCU</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[【HDU-2717】解题报告（BFS）]]></title>
    <url>%2F2018%2F01%2F27%2F%E3%80%90HDU-2717%E3%80%91%E8%A7%A3%E9%A2%98%E6%8A%A5%E5%91%8A%EF%BC%88BFS%EF%BC%89%2F</url>
    <content type="text"><![CDATA[原始题目Catch That Cow Time Limit: 5000/2000 MS (Java/Others) Memory Limit: 32768/32768 K (Java/Others) Total Submission(s): 17820 Accepted Submission(s): 5260 Problem Description Farmer John has been informed of the location of a fugitive cow and wants to catch her immediately. He starts at a point N (0 ≤ N ≤ 100,000) on a number line and the cow is at a point K (0 ≤ K ≤ 100,000) on the same number line. Farmer John has two modes of transportation: walking and teleporting. Walking: FJ can move from any point X to the points X - 1 or X + 1 in a single minute Teleporting: FJ can move from any point X to the point 2 × X in a single minute. If the cow, unaware of its pursuit, does not move at all, how long does it take for Farmer John to retrieve it? InputLine 1: Two space-separated integers: N and K OutputLine 1: The least amount of time, in minutes, it takes for Farmer John to catch the fugitive cow. Sample Input5 17 Sample Output4 HintThe fastest way for Farmer John to reach the fugitive cow is to move along the following path: 5-10-9-18-17, which takes 4 minutes. SourceUSACO 2007 Open Silver Recommendteddy 题目大意一个人想用最短的时间去抓住一头牛，牛不会动，人的移动规则是：下一次移动可以移动到X+1位置，X-1位置，或者2*X位置（X为当前位置坐标），现在给定人和牛的坐标，求人抓到牛所需要的最短时间（次数） 解题思路很直接的广搜，搜索规则可以理解成三个direction，+1，-1，*2；最后可以加上一点处理（不知道算不算剪枝）因为坐标横大于0，那么若牛的初始坐标值小于人，那么无需广搜可以得到最短次数即坐标值之差（每次左移一个单位），另由于广搜深度增加，每次搜索的量会很大，可以加入判断搜索到结果时立即跳脱循环。 解题代码123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384#include &lt;queue&gt;#include &lt;cstdio&gt;#include &lt;cstring&gt;#include &lt;cmath&gt;#include &lt;cstdlib&gt;#include&lt;algorithm&gt;using namespace std;const int maxn=100001; int n,m; bool vis[maxn]; // 访问标记int dir[3]; //struct State // BFS 队列中的状态数据结构//&#123;// int x;// int Step_Counter; // 搜索步数统计器//&#125;;queue &lt;int&gt; q;int step[maxn];bool CheckState(int X) // 约束条件检验&#123;// int X=now.x; if(X&gt;=0&amp;&amp;X&lt;=100000&amp;&amp;!vis[X]) // 满足条件 &#123;// printf("next X=%d, step=%d\n",X,now.Step_Counter+1); return 1; &#125; else // 约束条件冲突 return 0;&#125;void bfs(int st)&#123; int now,next; // 定义2个状态，当前和下一个 q.push(st); step[st]=0; vis[st]=true; // 访问标记 while(!q.empty()) &#123; now=q.front(); // 取队首元素进行扩展 if(now==m) // 出现目标态，此时为Step_Counter 的最小值，可以退出即可 &#123; printf("%d\n",step[now]); return; &#125; //按照规则搜索下一组数 //两种形式，一种左右，一种倍乘。 dir[0]=-1;dir[1]=1;dir[2]=now; int flag=0; for(int i=0;i&lt;3;i++) &#123; next=now+dir[i];// printf("check X=%d, step=%d\n",next,step[now]+1); if(next==m)//剪枝，立即跳出循环 &#123; while(!q.empty()) q.pop(); step[next]=step[now]+1; q.push(now); q.push(next); break; &#125; if(CheckState(next)) &#123; step[next]=step[now]+1; vis[next]=true; //不要忘了标记已访问 q.push(next); &#125; &#125; q.pop(); // 队首元素出队 &#125; return;&#125;int main()&#123;// freopen("in.txt","r",stdin); while(~scanf("%d%d",&amp;n,&amp;m)) &#123; while(!q.empty()) q.pop(); memset(vis,0,sizeof(vis)); memset(step,0,sizeof(step)); if(n&gt;=m) printf("%d\n",n-m); else bfs(n); &#125;&#125; 收获与反思使用模板里的结构时出现了两次MLE，不知道是什么个情况，有待检查。]]></content>
      <categories>
        <category>编程</category>
        <category>ACM</category>
      </categories>
      <tags>
        <tag>算法</tag>
        <tag>ACM</tag>
        <tag>2018寒假集训</tag>
        <tag>BFS</tag>
        <tag>HDU</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[【POJ-3126】解题报告（BFS，换门牌号，素数筛）]]></title>
    <url>%2F2018%2F01%2F27%2F%E3%80%90POJ-3126%E3%80%91%E8%A7%A3%E9%A2%98%E6%8A%A5%E5%91%8A%EF%BC%88BFS%EF%BC%8C%E6%8D%A2%E9%97%A8%E7%89%8C%E5%8F%B7%EF%BC%8C%E7%B4%A0%E6%95%B0%E7%AD%9B%EF%BC%89%2F</url>
    <content type="text"><![CDATA[原始题目Prime Path Time Limit: 1000MS Memory Limit: 65536K Total Submissions: 24280 Accepted: 13417 Problem Description The ministers of the cabinet were quite upset by the message from the Chief of Security stating that they would all have to change the four-digit room numbers on their offices. — It is a matter of security to change such things every now and then, to keep the enemy in the dark. — But look, I have chosen my number 1033 for good reasons. I am the Prime minister, you know! — I know, so therefore your new number 8179 is also a prime. You will just have to paste four new digits over the four old ones on your office door. — No, it’s not that simple. Suppose that I change the first digit to an 8, then the number will read 8033 which is not a prime! — I see, being the prime minister you cannot stand having a non-prime number on your door even for a few seconds. — Correct! So I must invent a scheme for going from 1033 to 8179 by a path of prime numbers where only one digit is changed from one prime to the next prime. Now, the minister of finance, who had been eavesdropping, intervened. — No unnecessary expenditure, please! I happen to know that the price of a digit is one pound. — Hmm, in that case I need a computer program to minimize the cost. You don’t know some very cheap software gurus, do you? — In fact, I do. You see, there is this programming contest going on… Help the prime minister to find the cheapest prime path between any two given four-digit primes! The first digit must be nonzero, of course. Here is a solution in the case above. 1033 1733 3733 3739 3779 8779 8179 The cost of this solution is 6 pounds. Note that the digit 1 which got pasted over in step 2 can not be reused in the last step – a new 1 must be purchased. InputOne line with a positive number: the number of test cases (at most 100). Then for each test case, one line with two numbers separated by a blank. Both numbers are four-digit primes (without leading zeros). OutputOne line for each case, either with a number stating the minimal cost or containing the word Impossible. Sample Input3 1033 8179 1373 8017 1033 1033 Sample Output6 7 0 SourceNorthwestern Europe 2006 题目大意换门牌号，要求每次只能更换一位，且更换完之后的新数字要是素数，问更换到指定号码的最少步数是多少。 解题思路按个十百千位广搜，&lt;40入口，搜索的规则是，该数没有被搜索过，且该数为素数。由于是BFS，所以第一次搜索到最终更改的门牌号时一定是最少步数，输出该值即可。如果广搜入口全部遍历一编还是未能搜索到最终更改的门牌号，即为不可能，输出Impossible。 要点： 由于要求是素数，所以个位只需要搜索奇数即可，以及千位避开0； 涉及素数，可以用最基础的素数判断（即从2开始逐个除，若有因子则返回false），或者使用素数筛先建立素数表然后直接查表（待补充） 解题代码 素数传统判断 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130#include &lt;queue&gt;#include &lt;cstdio&gt;#include &lt;cstring&gt;#include &lt;cmath&gt;#include &lt;cstdlib&gt;#include&lt;algorithm&gt;#define maxn 10100using namespace std;int n,m; bool vis[maxn]; // 访问标记//int dir[4][2]=&#123;0,1,0,-1,1,0,-1,0&#125;; // 方向向量//int dir[8][2]=&#123;&#123;1,1&#125;,&#123;1,0&#125;,&#123;1,-1&#125;,&#123;0,1&#125;,&#123;0,-1&#125;,&#123;-1,1&#125;,&#123;-1,0&#125;,&#123;-1,-1&#125;&#125; ;struct State // BFS 队列中的状态数据结构&#123; int x; int Step_Counter; // 搜索步数统计器&#125;;bool isPrime(int x)&#123; if(x==0||x==1) return false; else if(x==2||x==3) return true; else &#123; for(int i=2;i&lt;=(int)sqrt(x);i++) &#123; if(x%i==0) return false; &#125; return true; &#125;&#125; State a[maxn];bool CheckState(int s,State now) // 约束条件检验&#123; if(s!=now.x&amp;&amp;!vis[s]&amp;&amp;isPrime(s)) // 满足条件 &#123;// printf("next s=%d, step=%d\n",s,now.Step_Counter+1); return 1; &#125; else // 约束条件冲突 return 0;&#125;void bfs(State st)&#123; queue &lt;State&gt; q; State now,next; // 定义2个状态，当前和下一个 st.Step_Counter=0; // 计数器清零 q.push(st); // 入队 vis[st.x]=1; // 访问标记 while(!q.empty()) &#123; now=q.front(); // 取队首元素进行扩展 if(now.x==m) // 出现目标态，此时为Step_Counter 的最小值，可以退出即可 &#123; printf("%d\n",now.Step_Counter); return; &#125; //按照规则搜索下一组数 for(int i=1;i&lt;=9;i+=2) &#123; int s=now.x/10*10+i; if(CheckState(s,now)) &#123; vis[s]=1; next.x=s; next.Step_Counter=now.Step_Counter+1; q.push(next); &#125; &#125; for(int i=0;i&lt;=9;i++) &#123; int s = now.x / 100 * 100 + i * 10 + now.x % 10; if(CheckState(s,now)) &#123; vis[s]=1; next.x=s; next.Step_Counter=now.Step_Counter+1; q.push(next); &#125; &#125; for(int i=0;i&lt;=9;i++) &#123; int s=now.x/1000*1000+i*100+now.x%100; if(CheckState(s,now)) &#123; vis[s]=1; next.x=s; next.Step_Counter=now.Step_Counter+1; q.push(next); &#125; &#125; for(int i=1;i&lt;=9;i++) &#123; int s=i*1000+now.x%1000; if(CheckState(s,now)) &#123; vis[s]=1; next.x=s; next.Step_Counter=now.Step_Counter+1; q.push(next); &#125; &#125; q.pop(); // 队首元素出队 &#125; printf("Impossible\n"); return;&#125;int main()&#123; int t; scanf("%d",&amp;t); for(int i=0;i&lt;t;i++) &#123;// printf("%d %d\n",t,n);// while(!q.empty()) q.pop(); memset(vis,0,sizeof(vis)); scanf("%d%d",&amp;n,&amp;m); struct State tmp; tmp.x=n; tmp.Step_Counter=0; bfs(tmp); &#125; return 0;&#125; 非线性埃式素数筛 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132#include &lt;queue&gt;#include &lt;cstdio&gt;#include &lt;cstring&gt;#include &lt;cmath&gt;#include &lt;cstdlib&gt;#include&lt;algorithm&gt;#define maxn 10100using namespace std;int n,m; bool vis[maxn]; // 访问标记//int dir[4][2]=&#123;0,1,0,-1,1,0,-1,0&#125;; // 方向向量//int dir[8][2]=&#123;&#123;1,1&#125;,&#123;1,0&#125;,&#123;1,-1&#125;,&#123;0,1&#125;,&#123;0,-1&#125;,&#123;-1,1&#125;,&#123;-1,0&#125;,&#123;-1,-1&#125;&#125; ;struct State // BFS 队列中的状态数据结构&#123; int x; int Step_Counter; // 搜索步数统计器&#125;;bool isPrime[maxn]; void solvePrime() //埃式素数筛 &#123; memset(isPrime,1,sizeof(isPrime)); isPrime[0]=isPrime[1]=false; for(int i=2;i&lt;=maxn;i++) &#123; if(isPrime[i]) &#123; for(int j=i*i;j&lt;=maxn;j+=i) &#123; isPrime[j]=false; &#125; &#125; &#125;&#125;State a[maxn];bool CheckState(int s,State now) // 约束条件检验&#123; if(s!=now.x&amp;&amp;!vis[s]&amp;&amp;isPrime[s]) // 满足条件 &#123;// printf("next s=%d, step=%d\n",s,now.Step_Counter+1); return 1; &#125; else // 约束条件冲突 return 0;&#125;void bfs(State st)&#123; queue &lt;State&gt; q; State now,next; // 定义2个状态，当前和下一个 st.Step_Counter=0; // 计数器清零 q.push(st); // 入队 vis[st.x]=1; // 访问标记 while(!q.empty()) &#123; now=q.front(); // 取队首元素进行扩展 if(now.x==m) // 出现目标态，此时为Step_Counter 的最小值，可以退出即可 &#123; printf("%d\n",now.Step_Counter); return; &#125; //按照规则搜索下一组数 for(int i=1;i&lt;=9;i+=2) &#123; int s=now.x/10*10+i; if(CheckState(s,now)) &#123; vis[s]=1; next.x=s; next.Step_Counter=now.Step_Counter+1; q.push(next); &#125; &#125; for(int i=0;i&lt;=9;i++) &#123; int s = now.x / 100 * 100 + i * 10 + now.x % 10; if(CheckState(s,now)) &#123; vis[s]=1; next.x=s; next.Step_Counter=now.Step_Counter+1; q.push(next); &#125; &#125; for(int i=0;i&lt;=9;i++) &#123; int s=now.x/1000*1000+i*100+now.x%100; if(CheckState(s,now)) &#123; vis[s]=1; next.x=s; next.Step_Counter=now.Step_Counter+1; q.push(next); &#125; &#125; for(int i=1;i&lt;=9;i++) &#123; int s=i*1000+now.x%1000; if(CheckState(s,now)) &#123; vis[s]=1; next.x=s; next.Step_Counter=now.Step_Counter+1; q.push(next); &#125; &#125; q.pop(); // 队首元素出队 &#125; printf("Impossible\n"); return;&#125;int main()&#123; solvePrime(); int t; scanf("%d",&amp;t); for(int i=0;i&lt;t;i++) &#123;// printf("%d %d\n",t,n);// while(!q.empty()) q.pop(); memset(vis,0,sizeof(vis)); scanf("%d%d",&amp;n,&amp;m); struct State tmp; tmp.x=n; tmp.Step_Counter=0; bfs(tmp); &#125; return 0;&#125; 收获与反思题目本身没什么问题，两次TLE都是因为输入输出格式的问题最后一直等待输入，需要再细心一点。 对于素数筛知识的补充。 传统方法：根据是否有大于1小于本身的因子来判断，复杂度为O(nlognlogn) （虽然还不会证明）。 素数筛方法 埃式筛法，即埃拉托斯特尼筛法，本题采用。原理就是排除0，1，从2开始当前未筛去的数最小的数即为素数 改进前后两次的时间对比（图待补充） 另外还有欧拉筛法（线性）有待学习。]]></content>
      <categories>
        <category>编程</category>
        <category>ACM</category>
      </categories>
      <tags>
        <tag>算法</tag>
        <tag>ACM</tag>
        <tag>2018寒假集训</tag>
        <tag>BFS</tag>
        <tag>补图</tag>
        <tag>素数筛</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[【CodeForces-689B】解题报告（BFS）]]></title>
    <url>%2F2018%2F01%2F27%2F%E3%80%90CodeForces-689B%E3%80%91%E8%A7%A3%E9%A2%98%E6%8A%A5%E5%91%8A%EF%BC%88BFS%EF%BC%89%2F</url>
    <content type="text"><![CDATA[原始题目B. Mike and Shortcuts time limit per test 3 seconds memory limit per test 256 megabytes input standard input output standard output Recently, Mike was very busy with studying for exams and contests. Now he is going to chill a bit by doing some sight seeing in the city. City consists of n intersections numbered from 1 to n. Mike starts walking from his house located at the intersection number 1 and goes along some sequence of intersections. Walking from intersection number i to intersection j requires |i - j| units of energy. The total energyspent by Mike to visit a sequence of intersections p1 = 1, p2, …, pk is equal to units of energy. Of course, walking would be boring if there were no shortcuts. A shortcut is a special path that allows Mike walking from one intersection to another requiring only 1 unit of energy. There are exactly n shortcuts in Mike’s city, the ith of them allows walking from intersection i to intersection ai (i ≤ ai ≤ ai + 1) (but not in the opposite direction), thus there is exactly one shortcut starting at each intersection. Formally, if Mike chooses a sequence p1 = 1, p2, …, pk then for each 1 ≤ i &lt; k satisfying pi + 1 = api and api ≠ pi Mike will spend only 1 unit of energy instead of |pi - pi + 1| walking from the intersection pi to intersection pi + 1. For example, if Mike chooses a sequence p1 = 1, p2 = ap1, p3 = ap2, …, pk = apk - 1, he spends exactly k - 1 units of total energy walking around them. Before going on his adventure, Mike asks you to find the minimum amount of energy required to reach each of the intersections from his home. Formally, for each 1 ≤ i ≤ n Mike is interested in finding minimum possible total energy of some sequence p1 = 1, p2, …, pk = i. InputThe first line contains an integer n (1 ≤ n ≤ 200 000) — the number of Mike’s city intersection. The second line contains n integers a1, a2, …, an (i ≤ ai ≤ n , , describing shortcuts of Mike’s city, allowing to walk from intersection i to intersection ai using only 1 unit of energy. Please note that the shortcuts don’t allow walking in opposite directions (from ai to i). OutputIn the only line print n integers m1, m2, …, mn, where mi denotes the least amount of total energy required to walk from intersection 1 to intersection i. Examplesinput3 2 2 3 output0 1 2 input5 1 2 3 4 5 output0 1 2 3 4 input7 4 4 4 4 7 7 7 output0 1 2 1 2 3 3 NoteIn the first sample case desired sequences are: 1: 1; m1 = 0; 2: 1, 2; m2 = 1; 3: 1, 3; m3 = |3 - 1| = 2. In the second sample case the sequence for any intersection 1 &lt; i is always 1, i and mi = |1 - i|. In the third sample case — consider the following intersection sequences: 1: 1; m1 = 0; 2: 1, 2; m2 = |2 - 1| = 1; 3: 1, 4, 3; m3 = 1 + |4 - 3| = 2; 4: 1, 4; m4 = 1; 5: 1, 4, 5; m5 = 1 + |4 - 5| = 2; 6: 1, 4, 6; m6 = 1 + |4 - 6| = 3; 7: 1, 4, 5, 7; m7 = 1 + |4 - 5| + 1 = 3. 题目大意给出n个点，如果直接从a1点到an点，耗费|xn-x1|的能量，不过每个点都存在一个到另一个点的“快速路径”，消耗能量为1，现在求从第一个点开始到每一个点消耗能量的最小值。 解题思路广搜，下一次搜索的规则是，左右相邻的点和该点快速路径到达的点（即消耗能量均为1的点），三个方向，这样一层一层往下搜索，第一次到达ai点时消耗的能量（计数器)即为从第一个点到该点消耗的最小能量。 解题代码123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102#include &lt;queue&gt;#include &lt;cstdio&gt;#include &lt;cstring&gt;#include &lt;cmath&gt;#include &lt;cstdlib&gt;#define maxn 200010using namespace std;int n;//个数 bool vis[maxn]; // 访问标记//int dir[4][2]=&#123;0,1,0,-1,1,0,-1,0&#125;; // 方向向量//int dir[8][2]=&#123;&#123;1,1&#125;,&#123;1,0&#125;,&#123;1,-1&#125;,&#123;0,1&#125;,&#123;0,-1&#125;,&#123;-1,1&#125;,&#123;-1,0&#125;,&#123;-1,-1&#125;&#125; ;int dir[3];struct State // BFS 队列中的状态数据结构&#123; int i; int ai; int Step_Counter; // 搜索步数统计器 bool first; int min;&#125;;State a[maxn];int ans[maxn];bool CheckState(State next) // 约束条件检验&#123; if(next.i&gt;0&amp;&amp;next.i&lt;=n&amp;&amp;!vis[next.i]) // 满足条件 &#123;// printf("next %d %d\n",next.i,next.ai); return 1; &#125; else // 约束条件冲突 return 0;&#125;void bfs(State st)&#123; queue &lt;State&gt; q; // BFS 队列 State now,next; // 定义2个状态，当前和下一个 st.Step_Counter=0; // 计数器清零 q.push(st); // 入队 vis[st.i]=1; // 访问标记 int circle=0; while(!q.empty()) &#123; now=q.front(); // 取队首元素进行扩展// a[now.i].Step_Counter=++circle; if(a[now.i].first) // 出现目标态，此时为Step_Counter 的最小值，可以退出即可 &#123; // 做相关处理// printf("first visit i=%d, min=%d\n",now.i,now.Step_Counter); a[now.i].min=now.Step_Counter; a[now.i].first=false;// return; &#125; else if(a[now.i].min&lt;now.Step_Counter) a[now.i].min=now.Step_Counter; dir[0]=now.i-1;dir[1]=now.i+1;dir[2]=now.ai; //生成下一组方向 for(int i=0;i&lt;3;i++) &#123; next.i=dir[i];// 按照规则生成 下一个状态 next.ai=a[dir[i]].ai; next.Step_Counter=now.Step_Counter+1; // 计数器加1 if(CheckState(next)) // 如果状态满足约束条件则入队 &#123; q.push(next);// printf("insert i=%d ai=%d\n",next.i,next.ai); vis[next.i]=1; //访问标记 &#125; &#125; q.pop(); // 队首元素出队 &#125; return;&#125;int main()&#123; while(~scanf("%d",&amp;n)) &#123; memset(vis,0,sizeof(vis)); for(int j=1;j&lt;=n;j++) &#123; a[j].i=j; a[j].first=true; scanf("%d",&amp;a[j].ai); &#125; bfs(a[1]); int flag=1; for(int j=1;j&lt;=n;j++) &#123; if(flag) &#123; printf("%d",a[j].min); flag=0; &#125; else printf(" %d",a[j].min); &#125; printf("\n"); &#125; return 0;&#125; 收获与反思思路清楚的话还是比较好写的，这里没有绝对的目标状态，所以全部遍历一遍每一个都打上Step值，然后输出就行。]]></content>
      <categories>
        <category>编程</category>
        <category>ACM</category>
      </categories>
      <tags>
        <tag>算法</tag>
        <tag>ACM</tag>
        <tag>2018寒假集训</tag>
        <tag>BFS</tag>
        <tag>CodeForces</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[【ZOJ-1709】解题报告（BFS）]]></title>
    <url>%2F2018%2F01%2F27%2F%E3%80%90ZOJ-1709%E3%80%91%E8%A7%A3%E9%A2%98%E6%8A%A5%E5%91%8A%EF%BC%88BFS%EF%BC%89%2F</url>
    <content type="text"><![CDATA[原始题目Oil Deposits Time Limit: 2 Seconds Memory Limit: 65536 KB The GeoSurvComp geologic survey company is responsible for detecting underground oil deposits. GeoSurvComp works with one large rectangular region of land at a time, and creates a grid that divides the land into numerous square plots. It then analyzes each plot separately, using sensing equipment to determine whether or not the plot contains oil. A plot containing oil is called a pocket. If two pockets are adjacent, then they are part of the same oil deposit. Oil deposits can be quite large and may contain numerous pockets. Your job is to determine how many different oil deposits are contained in a grid. InputThe input file contains one or more grids. Each grid begins with a line containing m and n, the number of rows and columns in the grid, separated by a single space. If m = 0 it signals the end of the input; otherwise 1 ≤ m ≤ 100 and 1 ≤ n ≤ 100. Following this are m lines of n characters each (not counting the end-of-line characters). Each character corresponds to one plot, and is either *&#39;, representing the absence of oil, or@’, representing an oil pocket. OutputFor each grid, output the number of distinct oil deposits. Two different pockets are part of the same oil deposit if they are adjacent horizontally, vertically, or diagonally. An oil deposit will not contain more than 100 pockets. Sample Input1 1 * 3 5 *@*@* **@** *@*@* 1 8 @@****@* 5 5 ****@ *@@*@ *@**@ @@@*@ @@**@ 0 0 Sample Output0 1 2 2 SourceMid-Central USA 1997 题目大意给定一个用*和@标记的油田，找出不连续的油田总数。 解题思路每一个点入口BFS，搜索过的标记，最后记录广搜的总次数就行。 解题代码12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364656667686970717273747576777879808182838485868788899091929394959697#include &lt;queue&gt;#include &lt;cstdio&gt;#include &lt;cstring&gt;#include &lt;cstdlib&gt;#define maxn 105using namespace std;char map[maxn][maxn];//图 int n,m;//n为行数，m为列数 bool vis[maxn][maxn]; // 访问标记//int dir[4][2]=&#123;0,1,0,-1,1,0,-1,0&#125;; // 方向向量int dir[8][2]=&#123;&#123;1,1&#125;,&#123;1,0&#125;,&#123;1,-1&#125;,&#123;0,1&#125;,&#123;0,-1&#125;,&#123;-1,1&#125;,&#123;-1,0&#125;,&#123;-1,-1&#125;&#125; ;struct State // BFS 队列中的状态数据结构&#123; int x,y; // 坐标位置 int Step_Counter; // 搜索步数统计器&#125;;State a[maxn];bool CheckState(State s) // 约束条件检验&#123; if(s.x&gt;=0&amp;&amp;s.x&lt;m&amp;&amp;s.y&gt;=0&amp;&amp;s.y&lt;n&amp;&amp;map[s.x][s.y]&amp;&amp;!vis[s.x][s.y]) // 满足条件 &#123;// printf("next %d %d\n",s.x,s.y); return 1; &#125; else // 约束条件冲突 return 0;&#125;void bfs(State st)&#123; queue &lt;State&gt; q; // BFS 队列 State now,next; // 定义2个状态，当前和下一个 st.Step_Counter=0; // 计数器清零 q.push(st); // 入队 vis[st.x][st.y]=1; // 访问标记 while(!q.empty()) &#123; now=q.front(); // 取队首元素进行扩展// if(now==G) // 出现目标态，此时为Step_Counter 的最小值，可以退出即可// &#123;// ...... // 做相关处理// return;// &#125; for(int i=0;i&lt;8;i++) &#123; next.x=now.x+dir[i][0]; // 按照规则生成 下一个状态 next.y=now.y+dir[i][1];// printf("insert %d %d\n",next.x,next.y); next.Step_Counter=now.Step_Counter+1; // 计数器加1 if(CheckState(next)) // 如果状态满足约束条件则入队 &#123; q.push(next);// printf("insert %d %d\n",next.x,next.y); vis[next.x][next.y]=1; //访问标记 &#125; &#125; q.pop(); // 队首元素出队 &#125; return;&#125;int main()&#123; while(~scanf("%d%d",&amp;m,&amp;n)&amp;&amp;m+n) &#123; memset(vis,0,sizeof(vis)); for(int i=0;i&lt;m;i++) &#123; scanf("%s",map[i]); for(int j=0;j&lt;n;j++) &#123; if(map[i][j]=='*') map[i][j]=0; else if(map[i][j]=='@') map[i][j]=1; &#125; &#125; int count=0; for(int i=0;i&lt;m;i++) &#123; for(int j=0;j&lt;n;j++) &#123; if(map[i][j]&amp;&amp;!vis[i][j]) //此区域有油&amp;&amp;没有被访问过 &#123; count++; State curst; curst.x=i;curst.y=j;// printf("search %d %d\n",i,j); bfs(curst);//BFS搜索 &#125; &#125; &#125; printf("%d\n",count); &#125; return 0;&#125; 收获与反思第一次使用模板，对于这种图表示的还比较顺手，如何按照规则查找出下一个状态是广搜的关键。 PS：注意一些细节，比如1和i的区别，一点打错了要debug半天真的伤不起啊。]]></content>
      <categories>
        <category>编程</category>
        <category>ACM</category>
      </categories>
      <tags>
        <tag>算法</tag>
        <tag>ACM</tag>
        <tag>2018寒假集训</tag>
        <tag>BFS</tag>
        <tag>ZOJ</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[【CodeForces-600C】解题报告（贪心，字符串）]]></title>
    <url>%2F2018%2F01%2F22%2F%E3%80%90CodeForces-600C%E3%80%91%E8%A7%A3%E9%A2%98%E6%8A%A5%E5%91%8A%EF%BC%88%E8%B4%AA%E5%BF%83%EF%BC%8C%E5%AD%97%E7%AC%A6%E4%B8%B2%EF%BC%89%2F</url>
    <content type="text"><![CDATA[原始题目C. Make Palindrome time limit per test 2 seconds memory limit per test 256 megabytes input standard input output standard output Problem Description A string is called palindrome if it reads the same from left to right and from right to left. For example “kazak”, “oo”, “r” and “mikhailrubinchikkihcniburliahkim” are palindroms, but strings “abb” and “ij” are not. You are given string s consisting of lowercase Latin letters. At once you can choose any position in the string and change letter in that position to any other lowercase letter. So after each changing the length of the string doesn’t change. At first you can change some letters in s. Then you can permute the order of letters as you want. Permutation doesn’t count as changes. You should obtain palindrome with the minimal number of changes. If there are several ways to do that you should get the lexicographically (alphabetically) smallest palindrome. So firstly you should minimize the number of changes and then minimize the palindrome lexicographically. InputThe only line contains string s (1 ≤ |s| ≤ 2·105) consisting of only lowercase Latin letters. OutputPrint the lexicographically smallest palindrome that can be obtained with the minimal number of changes. Examplesinputaabc outputabba inputaabcd outputabcba 题目大意任意输入一串字符，要求输出改动次数最少（移动交换位置不算做改动）且字典序最小的回文串。 解题思路贪心的想法比较直观。由于移动交换位置不算改动。贪心的从两端对称输出典序最小的字母，如果该字母出现次数位奇数，则从字典序最大的字母开始搜索，直至找到第一个出现个数也为奇数的字母（当然也是最大的），大字母的个数-1，小字母个数+1（即用小替换大），偶数个数会调整全部字母出现次数为偶数然后结束，奇数个数的话则需要额外判断，如果搜索到的字母和原字母相同，则说明该字母是中间字母（不一定该字母都在中间！）易错点：把中间字母单独提出来然后相邻的放到中间。 比如aabbhhwwhwwhhbbaa输入本应该原样输出，但是却输出了aabbwwhhhhhwwbbaa，这样会使字典序增大，需要对中间字母特殊处理（正常左右两端输出，只不过最后留一个在中间打印就行。） 解题代码123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147148149150151152153154155156157158159160161162163164165166167168#include &lt;cstdio&gt;#include &lt;iostream&gt;#include &lt;cstring&gt;#include &lt;cmath&gt;#include &lt;algorithm&gt;#define maxn 200100using namespace std;char s[maxn];char outs[maxn];//int alpha[26];bool mark[26];struct node&#123; char letter; int times;&#125;alpha[26];bool cmp(struct node n1,struct node n2)&#123; return n1.letter&gt;n2.letter;&#125;bool cmp1(struct node n1,struct node n2)&#123; return n1.letter&lt;n2.letter;&#125;void odd(int len)&#123;// printf("in odd\n"); for(int i=0;i&lt;len;i++) &#123; alpha[s[i]-97].times++; &#125; sort(alpha,alpha+26,cmp);// for(int i=0;i&lt;26;i++)// &#123;// printf("%d %c %d\n",i,alpha[i].letter,alpha[i].times);// &#125; int point=0,target=0; for(int i=0;i&lt;26;i++) &#123; if(!(alpha[i].times%2)) continue; else &#123; target=i; int j; for(j=target,point=0;j&lt;26;j++) &#123; if(!(alpha[j].times%2)) continue; else point=j; &#125; if(point==0) break; else &#123; alpha[point].times++; alpha[target].times--; &#125; &#125; &#125;// for(int i=0;i&lt;26;i++)// &#123;// printf("%d %c %d\n",i,alpha[i].letter,alpha[i].times);// &#125; char c=alpha[target].letter; char t=alpha[target].times;// printf("target=%c\n",c);// target 中间单值 int count=0; int leftlen=len-alpha[target].times; sort(alpha,alpha+26,cmp1);// printf("now len=%d\n",leftlen); for(int i=0;count&lt;(len-1)/2;i++) &#123; if(alpha[i].letter==c) for(int j=0;j&lt;(alpha[i].times-1)/2;j++) outs[count++]=alpha[i].letter; else for(int j=0;j&lt;alpha[i].times/2;j++) outs[count++]=alpha[i].letter; &#125; int i; for(i=0;i&lt;count;i++) &#123; printf("%c",outs[i]); &#125; printf("%c",c); for(i=count-1;i&gt;=0;i--) &#123; printf("%c",outs[i]); &#125; printf("\n");&#125;void even(int len)&#123;// printf("in even\n"); for(int i=0;i&lt;len;i++) &#123; alpha[s[i]-97].times++; &#125; sort(alpha,alpha+26,cmp);// for(int i=0;i&lt;26;i++)// &#123;// printf("%d %c %d\n",i,alpha[i].letter,alpha[i].times);// &#125; int point=0,target=0; for(int i=0;i&lt;26;i++) &#123;// if(i==25 ) printf("YOO\n"); if(!(alpha[i].times%2)) continue; else &#123; target=i; int j; for(j=target,point=0;j&lt;26;j++) &#123; if(!(alpha[j].times%2)) continue; else point=j; &#125; if(point==0) break; else &#123; alpha[point].times++; alpha[target].times--; &#125; &#125; &#125;// char c=alpha[target].letter;// char t=alpha[target].times;// printf("target=%c\n",c);// //target 中间单值 int count=0;// int leftlen=len-alpha[target].times; sort(alpha,alpha+26,cmp1);// printf("now len=%d\n",leftlen); for(int i=0;count&lt;len/2;i++) &#123; for(int j=0;j&lt;alpha[i].times/2;j++) outs[count++]=alpha[i].letter; &#125; int i; for(i=0;i&lt;count;i++) &#123; printf("%c",outs[i]); &#125; for(i=count-1;i&gt;=0;i--) &#123; printf("%c",outs[i]); &#125; printf("\n");&#125;int main()&#123;// freopen("in.txt", "r", stdin);//其实in.txt是可以修改成其他名字的 比如“输入.txt”，都是可以的，这里只是为了方便起见，下同； // freopen("outmy.txt", "w", stdout); while(~scanf("%s",s)) &#123; memset(alpha,0,sizeof(alpha)); for(int i=0;i&lt;26;i++) &#123; alpha[i].letter='a'+i; alpha[i].times=0; &#125; int len=strlen(s); if(len%2)//Odd odd(len); else even(len); &#125; return 0;&#125; 收获与反思（第一次写贪心，由于开始理解有偏差，改了很多次，代码也很丑陋= =而且太冗长= =，好在最后AC了，需要后面再优化下。）]]></content>
      <categories>
        <category>编程</category>
        <category>ACM</category>
      </categories>
      <tags>
        <tag>算法</tag>
        <tag>ACM</tag>
        <tag>2018寒假集训</tag>
        <tag>Greedy</tag>
        <tag>CodeForces</tag>
        <tag>字符串</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[【HDU-1716】解题报告（排列STL）]]></title>
    <url>%2F2018%2F01%2F22%2F%E3%80%90HDU-1716%E3%80%91%E8%A7%A3%E9%A2%98%E6%8A%A5%E5%91%8A%EF%BC%88%E6%8E%92%E5%88%97STL%EF%BC%89%2F</url>
    <content type="text"><![CDATA[原始题目排列2 Time Limit: 1000/1000 MS (Java/Others) Memory Limit: 32768/32768 K (Java/Others) Total Submission(s): 9524 Accepted Submission(s): 3467 Problem DescriptionRay又对数字的列产生了兴趣：现有四张卡片，用这四张卡片能排列出很多不同的4位数，要求按从小到大的顺序输出这些4位数。 Input每组数据占一行，代表四张卡片上的数字（0≤数字≤9），如果四张卡片都是0，则输入结束。 Output对每组卡片按从小到大的顺序输出所有能由这四张卡片组成的4位数，千位数字相同的在同一行，同一行中每个四位数间用空格分隔。每组输出数据间空一行，最后一组数据后面没有空行。 Sample Input1 2 3 4 1 1 2 3 0 1 2 3 0 0 0 0 Sample Output1234 1243 1324 1342 1423 1432 2134 2143 2314 2341 2413 2431 3124 3142 3214 3241 3412 3421 4123 4132 4213 4231 4312 4321 1123 1132 1213 1231 1312 1321 2113 2131 2311 3112 3121 3211 1023 1032 1203 1230 1302 1320 2013 2031 2103 2130 2301 2310 3012 3021 3102 3120 3201 3210 解题思路先利用sort排序，然后利用C++STL中的next_permutation()函数将符合要求的排列逐个输出，本题需要注意输出格式有以下几点要求： 需要检测千位发生变化时换行（同一个数的排列每一行打印的四位数个数不一定相等） 含0的序列0不做首位（但是却经历这些排列，注意换行和空格的问题） 老样子，每一行最后一个四位数后没有空格，没有空格，没有空格（输出格式经常出的问题）。 除最后一行之外均有空行。 解题代码123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566#include &lt;cstdio&gt;#include &lt;cstring&gt;#include &lt;cmath&gt;#include &lt;algorithm&gt;using namespace std;int a[4];bool cmp(int a,int b)&#123; return a&lt;b;&#125;int main()&#123;// freopen("in.txt", "r", stdin);// freopen("out.txt", "w", stdout); int i,count=0,num=0; for(i=0;i&lt;4;i++) &#123; int c; scanf("%d",&amp;c); a[count++]=c;// printf("i=%d a[i]=%d\n",i,a[i]); &#125; sort(a,a+count,cmp); while(a[0]||a[1]||a[2]||a[3]) &#123; int circle=0; int qian=a[0]; if(qian&amp;&amp;num) printf("\n"); int sum=0; do &#123; int j; if(a[0]==0) continue; //跳过0开头的排列 if(a[0]!=qian) //换行判定 &#123; qian=a[0]; printf("\n%d",a[0]); &#125; else if(sum) printf(" %d",a[0]); //sum标记第一个数，sum非零四位数前均打印一个空格 else printf("%d",a[0]); for(j=1;j&lt;count-1;j++) &#123; printf("%d",a[j]); &#125; printf("%d",a[j]); sum++; &#125;while(next_permutation(a,a+count)); //使用do while 先打印一次再变为下个排列 printf("\n"); num++; count=0,i=0; for(i=0;i&lt;4;i++) &#123; int c; scanf("%d",&amp;c);// if(c)// &#123; a[count++]=c;// &#125;// printf("i=%d a[i]=%d\n",i,a[i]); &#125; sort(a,a+count,cmp); &#125; return 0; &#125; 收获与反思再次运用next_permutation函数，加深印象，以及对于输出格式的严格控制。]]></content>
      <categories>
        <category>编程</category>
        <category>ACM</category>
      </categories>
      <tags>
        <tag>算法</tag>
        <tag>ACM</tag>
        <tag>2018寒假集训</tag>
        <tag>HDU</tag>
        <tag>STL</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[【POJ-2260】解题报告（模拟，图论引申）]]></title>
    <url>%2F2018%2F01%2F21%2F%E3%80%90POJ-2260%E3%80%91%E8%A7%A3%E9%A2%98%E6%8A%A5%E5%91%8A%EF%BC%88%E6%A8%A1%E6%8B%9F%EF%BC%8C%E5%9B%BE%E8%AE%BA%E5%BC%95%E7%94%B3%EF%BC%89%2F</url>
    <content type="text"><![CDATA[原始题目Error Correction Time Limit: 1000MS Memory Limit: 65536K Total Submissions: 6820 Accepted: 4286 Problem Description A boolean matrix has the parity property when each row and each column has an even sum, i.e. contains an even number of bits which are set. Here’s a 4 x 4 matrix which has the parity property: 1 0 1 0 0 0 0 0 1 1 1 1 0 1 0 1 The sums of the rows are 2, 0, 4 and 2. The sums of the columns are 2, 2, 2 and 2.Your job is to write a program that reads in a matrix and checks if it has the parity property. If not, your program should check if the parity property can be established by changing only one bit. If this is not possible either, the matrix should be classified as corrupt. InputThe input will contain one or more test cases. The first line of each test case contains one integer n (n&lt;100), representing the size of the matrix. On the next n lines, there will be n integers per line. No other integers than 0 and 1 will occur in the matrix. Input will be terminated by a value of 0 for n. OutputFor each matrix in the input file, print one line. If the matrix already has the parity property, print “OK”. If the parity property can be established by changing one bit, print “Change bit (i,j)” where i is the row and j the column of the bit to be changed. Otherwise, print “Corrupt”. Sample Input4 1 0 1 0 0 0 0 0 1 1 1 1 0 1 0 1 4 1 0 1 0 0 0 1 0 1 1 1 1 0 1 0 1 4 1 0 1 0 0 1 1 0 1 1 1 1 0 1 0 1 0 Sample OutputOK Change bit (2,3) Corrupt SourceUlm Local 1998 题目大意给定一个n*n的由0/1构成的boolean矩阵，判断是否各行各列和均为偶数。 若是输出OK，若不是，可否更改其中一点的位置使行列均为偶数。输出这个点，若不可以，输出Corrupt 解题思路改一个点即可的充要条件为行和列之中存在且仅有一行与一列的各自的和为奇数。 或者利用邻接矩阵的知识转化为有向图+深度优先搜索？？学姐讲的图论知识，还没有深入学习。]]></content>
      <categories>
        <category>编程</category>
        <category>ACM</category>
      </categories>
      <tags>
        <tag>算法</tag>
        <tag>ACM</tag>
        <tag>2018寒假集训</tag>
        <tag>Imitation</tag>
        <tag>Graph</tag>
        <tag>POJ</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[【POJ-1328】解题报告（二维转一维，贪心）]]></title>
    <url>%2F2018%2F01%2F21%2F%E3%80%90POJ-1328%E3%80%91%E8%A7%A3%E9%A2%98%E6%8A%A5%E5%91%8A%EF%BC%88%E4%BA%8C%E7%BB%B4%E8%BD%AC%E4%B8%80%E7%BB%B4%EF%BC%8C%E8%B4%AA%E5%BF%83%EF%BC%89%2F</url>
    <content type="text"><![CDATA[原始题目Radar Installation Time Limit: 1000MS Memory Limit: 10000K Total Submissions: 96097 Accepted: 21364 Problem Description Assume the coasting is an infinite straight line. Land is in one side of coasting, sea in the other. Each small island is a point locating in the sea side. And any radar installation, locating on the coasting, can only cover d distance, so an island in the sea can be covered by a radius installation, if the distance between them is at most d. We use Cartesian coordinate system, defining the coasting is the x-axis. The sea side is above x-axis, and the land side below. Given the position of each island in the sea, and given the distance of the coverage of the radar installation, your task is to write a program to find the minimal number of radar installations to cover all the islands. Note that the position of an island is represented by its x-y coordinates. Figure A Sample Input of Radar Installations InputThe input consists of several test cases. The first line of each case contains two integers $n (1 \le n \le 1000)$ and d, where n is the number of islands in the sea and d is the distance of coverage of the radar installation. This is followed by n lines each containing two integers representing the coordinate of the position of each island. Then a blank line follows to separate the cases. The input is terminated by a line containing pair of zeros OutputFor each test case output one line consisting of the test case number followed by the minimal number of radar installations needed. “-1” installation means no solution for that case. Sample Input3 2 1 2 -3 1 2 1 1 2 0 2 0 0 Sample OutputCase 1: 2 Case 2: 1 SourceBeijing 2002 题目大意给定二维平面N个点的坐标作为小岛坐标，给定雷达辐射半径，求坐标轴上放置雷达的最少个数。 解题思路将小岛在二维平面钟的坐标转化为一维坐标轴上的线段也即数轴上的闭区间。两个闭区间的交集表示可以同时辐射到这两个小岛的雷达可放置的区域。 由此，要使放置雷达的个数最少。将线段按左端点递增排序，采用贪心策略，对于下一个小岛能利用之前的雷达就利用，条件为，下一条线段的左端点小于公用范围（线段）右边界。否则雷达+1，并以该线段作为新雷达的公用范围。 注意：1.共用范围（线段）是不断减小的，后一条线段的有端点大于共用范围右端，则无影响，若小于右端，则新右边界变为该线段的右端点。 解题代码1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465666768697071727374#include &lt;cstdio&gt;#include &lt;cstring&gt;#include &lt;cmath&gt;#include &lt;algorithm&gt;#include &lt;queue&gt;#define maxn 10010using namespace std;struct line&#123; double left; double right;&#125;island[10002];bool cmp(struct line s1,struct line s2)&#123; return s1.left&lt;s2.left;&#125;int main()&#123;// freopen("in.txt", "r", stdin);// freopen("out.txt", "w", stdout); int ni,nd; scanf("%d%d",&amp;ni,&amp;nd); int count=0; while(ni||nd) &#123; bool flag=false; for(int i=0;i&lt;ni;i++) &#123; double x,y; scanf("%lf%lf",&amp;x,&amp;y); if(y&gt;nd) flag=true;// printf("x=%lf y=%lf\n",x,y); island[i].left=x-sqrt(nd*nd-y*y); island[i].right=x+sqrt(nd*nd-y*y); &#125; if(flag) &#123; printf("Case %d: -1\n",++count); scanf("%d%d",&amp;ni,&amp;nd); &#125; else &#123; sort(island,island+ni,cmp);// for(int i=0;i&lt;ni;i++)// printf("island[%d] left=%lf right=%lf\n",i,island[i].left,island[i].right); int num=1; double minright=island[0].right; for(int i=0;i+1&lt;ni;i++) &#123; if(island[i+1].left&lt;=minright) &#123; if(island[i+1].right&lt;minright) &#123; minright=island[i+1].right; &#125; &#125; else &#123; num++;// printf("num++\n"); minright=island[i+1].right; &#125; &#125; printf("Case %d: %d\n",++count,num); scanf("%d%d",&amp;ni,&amp;nd); &#125; &#125;// fclose(stdin);//关闭文件 // fclose(stdout);//关闭文件 return 0;&#125; 收获与反思二维问题转一维，学习一下。]]></content>
      <categories>
        <category>编程</category>
        <category>ACM</category>
      </categories>
      <tags>
        <tag>算法</tag>
        <tag>ACM</tag>
        <tag>2018寒假集训</tag>
        <tag>Greedy</tag>
        <tag>POJ</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[【CodeForces-825B】解题报告（模拟，五子棋）]]></title>
    <url>%2F2018%2F01%2F21%2F%E3%80%90CodeForces-825B%E3%80%91%E8%A7%A3%E9%A2%98%E6%8A%A5%E5%91%8A%EF%BC%88%E6%A8%A1%E6%8B%9F%EF%BC%8C%E4%BA%94%E5%AD%90%E6%A3%8B%EF%BC%89%2F</url>
    <content type="text"><![CDATA[原始题目B. Five-In-a-Row time limit per test 1 second memory limit per test 256 megabytes input standard input output standard output Alice and Bob play 5-in-a-row game. They have a playing field of size 10 × 10. In turns they put either crosses or noughts, one at a time. Alice puts crosses and Bob puts noughts. In current match they have made some turns and now it’s Alice’s turn. She wonders if she can put cross in such empty cell that she wins immediately. Alice wins if some crosses in the field form line of length not smaller than 5. This line can be horizontal, vertical and diagonal. InputYou are given matrix 10 × 10 (10 lines of 10 characters each) with capital Latin letters ‘X’ being a cross, letters ‘O’ being a nought and ‘.’ being an empty cell. The number of ‘X’ cells is equal to the number of ‘O’ cells and there is at least one of each type. There is at least one empty cell. It is guaranteed that in the current arrangement nobody has still won. OutputPrint ‘YES’ if it’s possible for Alice to win in one turn by putting cross in some empty cell. Otherwise print ‘NO’. ExamplesinputXX.XX..... .....OOOO. .......... .......... .......... .......... .......... .......... .......... .......... outputYES inputXXOXX..... OO.O...... .......... .......... .......... .......... .......... .......... .......... .......... outputNO 题目大意给定一个五子棋棋盘，判断X棋一步之后能否胜利。 解题思路没什么，自己写模拟。遍历每个可下的点判断横竖和斜方向上能否实现大于等于五子相连。 注意边界问题，可以采用左右上下各拓展4行4列。 解题代码123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114#include &lt;cstdio&gt;#include &lt;cstring&gt;#include &lt;cmath&gt;#include &lt;algorithm&gt;#include &lt;queue&gt;#define maxn 10010using namespace std;char map[20][20];bool check(int a,int b)&#123; map[a][b]=1;// printf("begin check %d %d\n",a,b); int conti,i,j; for(conti=0,i=a-4;i&lt;=a+4;i++) //横向判断 &#123; if(map[i][b]==1) &#123; conti++; if(conti&gt;4) return true; &#125; else &#123; conti=0; continue; &#125; &#125; for(conti=0,j=b-4;j&lt;=b+4;j++) //纵向判断 &#123; if(map[a][j]==1) &#123; conti++; if(conti&gt;4) return true; &#125; else &#123; conti=0; continue; &#125; &#125; for(conti=0,i=a-4,j=b-4;i&lt;=a+4;i++,j++) //斜向判断1 &#123; if(map[i][j]==1) &#123; conti++; if(conti&gt;4) return true; &#125; else &#123; conti=0; continue; &#125; &#125; for(conti=0,i=a-4,j=b+4;i&lt;=a+4;i++,j--) //斜向判断1 &#123; if(map[i][j]==1) &#123; conti++; if(conti&gt;4) return true; &#125; else &#123; conti=0; continue; &#125; &#125; map[a][b]=0; return false; &#125;int main()&#123;// freopen("in.txt", "r", stdin);//其实in.txt是可以修改成其他名字的 比如“输入.txt”，都是可以的，这里只是为了方便起见，下同； for(int i=0+4;i&lt;10+4;i++) &#123; scanf("%s",map[i]+4); &#125; for(int i=0+4;i&lt;10+4;i++) &#123; for(int j=0+4;j&lt;10+4;j++) &#123; switch(map[i][j]) &#123; case 'X': map[i][j]=1;break; case 'O': map[i][j]=2;break; case '.': map[i][j]=0;break; &#125;// printf("%d ",map[i][j]); &#125;// printf("\n"); &#125; int flag=0; for(int i=0+4;i&lt;10+4;i++) &#123; for(int j=0+4;j&lt;10+4;j++) &#123; if(map[i][j]||!map[i-1][j]&amp;&amp;!map[i+1][j]&amp;&amp;!map[i][j-1]&amp;&amp;!map[i][j+1]&amp;&amp;!map[i-1][j-1]&amp;&amp;!map[i+1][j+1]&amp;&amp;!map[i-1][j+1]&amp;&amp;!map[i+1][j-1]) continue; else flag=check(i,j); if(flag) &#123;// printf("%d %d \n",i-4,j-4); break; &#125; &#125; if(flag) break; &#125; if(flag) printf("YES\n"); else printf("NO\n");// fclose(stdin);// fclose(stdout); return 0;&#125; 总结与反思模拟的时候要注意细节，尽量不要返工。 能简化的简化（后面会学到剪纸），比如判定周围一圈没有棋子可以直接continue跳过该循环。]]></content>
      <categories>
        <category>编程</category>
        <category>ACM</category>
      </categories>
      <tags>
        <tag>算法</tag>
        <tag>ACM</tag>
        <tag>2018寒假集训</tag>
        <tag>Imitation</tag>
        <tag>CodeForces</tag>
        <tag>Graph</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[【HDU-1027】解题报告（排列STL）]]></title>
    <url>%2F2018%2F01%2F20%2F%E3%80%90HDU-1027%E3%80%91%E8%A7%A3%E9%A2%98%E6%8A%A5%E5%91%8A%EF%BC%88%E6%8E%92%E5%88%97STL%EF%BC%89%2F</url>
    <content type="text"><![CDATA[原始题目Ignatius and the Princess II Time Limit: 2000/1000 MS (Java/Others) Memory Limit: 65536/32768 K (Java/Others) Total Submission(s): 9305 Accepted Submission(s): 5446 Problem Description Now our hero finds the door to the BEelzebub feng5166. He opens the door and finds feng5166 is about to kill our pretty Princess. But now the BEelzebub has to beat our hero first. feng5166 says, “I have three question for you, if you can work them out, I will release the Princess, or you will be my dinner, too.” Ignatius says confidently, “OK, at last, I will save the Princess.” “Now I will show you the first problem.” feng5166 says, “Given a sequence of number 1 to N, we define that 1,2,3…N-1,N is the smallest sequence among all the sequence which can be composed with number 1 to N(each number can be and should be use only once in this problem). So it’s easy to see the second smallest sequence is 1,2,3…N,N-1. Now I will give you two numbers, N and M. You should tell me the Mth smallest sequence which is composed with number 1 to N. It’s easy, isn’t is? Hahahahaha……”Can you help Ignatius to solve this problem? InputThe input contains several test cases. Each test case consists of two numbers, $N$ and $M$ (1 \le N \le 1000, 1 \le M \le 10000). You may assume that there is always a sequence satisfied the BEelzebub’s demand. The input is terminated by the end of file. OutputFor each test case, you only have to output the sequence satisfied the BEelzebub’s demand. When output a sequence, you should print a space between two numbers, but do not output any spaces after the last number. Sample Input6 4 11 8 Sample Output1 2 3 5 6 4 1 2 3 4 5 6 7 9 8 11 10 AuthorIgnatius.L 题目大意定义排列逆序，输出对应编号的排列 解题思路利用C++STL中的next_permutation()函数实现对数组排列，调用m-1次该函数然后按格式输出即可。 解题代码12345678910111213141516171819202122232425262728293031323334#include &lt;iostream&gt; #include &lt;algorithm&gt;#include &lt;string&gt;#include &lt;stack&gt;#include &lt;vector&gt;#define maxn 100010using namespace std;int a[maxn];int main()&#123; int n,m; while(cin&gt;&gt;n&gt;&gt;m)// cin&gt;&gt;n&gt;&gt;m;&#123; for(int i=0;i&lt;n;i++) &#123; a[i]=i+1; &#125;// vector&lt;int&gt; v1(a,a+n); 没有利用上vector 待补充 // vector&lt;int&gt;::iterator p=v1.begin(); int count=m-1; //设置计数器 do //注意使用dowhile &#123;// for(int j=0;j&lt;n;j++)// cout&lt;&lt;a[j]&lt;&lt;" ";// cout&lt;&lt;endl; count--; &#125;while(next_permutation(a,a+n)&amp;&amp;count); for(int j=0;j&lt;n-1;j++) cout&lt;&lt;a[j]&lt;&lt;" "; cout&lt;&lt;a[n-1]&lt;&lt;endl; //输出格式最后一个数后面没有空格 &#125; return 0;&#125; 收获与反思图片待添加]]></content>
      <categories>
        <category>编程</category>
        <category>ACM</category>
      </categories>
      <tags>
        <tag>算法</tag>
        <tag>ACM</tag>
        <tag>2018寒假集训</tag>
        <tag>补图</tag>
        <tag>HDU</tag>
        <tag>STL</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[《乌合之众——群体心理研究》读后感]]></title>
    <url>%2F2018%2F01%2F08%2F%E3%80%8A%E4%B9%8C%E5%90%88%E4%B9%8B%E4%BC%97%E2%80%94%E2%80%94%E7%BE%A4%E4%BD%93%E5%BF%83%E7%90%86%E7%A0%94%E7%A9%B6%E3%80%8B%E8%AF%BB%E5%90%8E%E6%84%9F%2F</url>
    <content type="text"><![CDATA[内容摘录 P51 影响大众想象力的不是是事实本身，而是他所扩展和传播的方式。 P56 群体的所有信仰都采取宗教形式，对群体来说，必须有个神，否则什么都谈不上。 P92 理性从来就不曾指导过群体，这值得后悔吗？我们不敢这么说。理性把人类带向了文明之路，但缺乏幻觉所激起的那种热情和勇敢。这些幻觉也许是必要的，它们是支配我们的无意识造成的。 P100 第二种领导，意志持久……他们聪明过人，还是智慧有限，这不重要。世界将永远属于他们。他们所拥有的持久意志是一种十分罕见而强大的能力，能战胜一切。 P160 （议会制）它反映了一种心理上错误但被普遍认同的观点，即对某个问题，许多人聚在一起比一小部分人更能做出明智而独立的决定。 P177 随着古老理想的彻底丧失，种族将最终完全失去自己的灵魂，成了一群独处的个人，回到了起点：群体，表现出一切短时间的特征，步调不一，没有前途。文明失去了稳定性，只能随风飘散。民众掌握了至高无上的大权，社会变得越来越野蛮。文明似乎还能辉煌一段时间，因为它扔拥有漫长历史所建的外墙，但那其实是一座已经被虫蛀空的大厦，支撑不了多久，暴风雨一来就会倒塌。从野蛮到文明，一路追逐着梦想，而当这种梦想失去了力量，便开始衰落，走向死亡，这就是一个民族的生命周期。]]></content>
      <categories>
        <category>阅读</category>
      </categories>
      <tags>
        <tag>阅读</tag>
        <tag>社科</tag>
        <tag>古斯塔夫・勒庞</tag>
        <tag>乌合之众</tag>
      </tags>
  </entry>
</search>
