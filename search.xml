<?xml version="1.0" encoding="utf-8"?>
<search>
  <entry>
    <title><![CDATA[算法与数据结构学习——分块莫队]]></title>
    <url>%2Fpost%2Fd632e628.html</url>
    <content type="text"><![CDATA[区间最大值RMQ问题 ST表 线段树 分块做法，多一个根号。 n/t+t 不等式的话一般取根n合适 静态区间和 f[i][j] = i ~ i+2^j-1 区间加法支持 区间剑法就要用线段树sf’””””””fdSd]]></content>
      <categories>
        <category>编程</category>
      </categories>
      <tags>
        <tag>编程</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[操作系统学习——集群技术初识]]></title>
    <url>%2Fpost%2F2024a703.html</url>
    <content type="text"><![CDATA[（可以关注一下 Future Generation Computer Systems） 集群技术初识——以Linux负载均衡集群学习为例 写在前面本文主要参考：章文嵩博士所写的Linux服务器集群系统介绍，集群技术（原理篇），高俊峰所著《高性能Linux服务器构建实战》，魔软运维社所著《大规模Linux集群架构最佳实践》。 由于查阅资料的时候不懂得地方太多，所以多数只能从概念上简单理解，如想自己深入理解其中的奥妙，还需要完成本门课程，将基础打好，同时熟悉Linux系统的一些基本情况后再做深入且仔细的学习。 第一部分 什么是集群背景我们在计算机网络中已经学习了吞吐量的概念，即单位时间内成功地传送数据的数量（以比特、字节、分组等测量），我们这里着重考量接收端的吞吐能力（以带宽衡量）。 Internet的飞速发展给网络带宽和服务器带来巨大的挑战。从网络技术的发展来看，网络带宽的增长远高于处理器速度和内存访问速度的增长，这是什么意思。数据出了小区门（计算机）在路途中已经可以上高速公路了，但是在小区内的行驶速度却成了难题，越来越多的瓶颈会出现在服务器端。互联网的海洋中对性能的不断提高，高可伸缩性、高可用性、可管理性、价格有效性的网络服务技术将成为网络服务技术的主导。各种平台下的技术方案应运而生。 对称多处理系统 对称多处理（Symmetric Multi-Processor，简称SMP）是由多个对称的处理器、和通过总线共享的内存和I/O部件所组成的计算机系统。SMP是一种低并行度的结构，是我们通常所说的”紧耦合多处理系统”， SMP的可扩展能力有限，但也有相应的优点： 单一系统映像（Single System Image） 有共享的内存和I/O， 易编程。 由于SMP的可扩展能力有限，SMP服务器显然不能满足高可伸缩、高可用网络服务中的负载处理能力不断增长需求。随着负载不断增长，会导致服务器不断地升 级。这种服务器升级有下列不足： 升级过程繁琐，机器切换会使服务暂时中断，并造成原有计算资源的浪费 越往高端的服务器，所花费的代价越大； 三是 SMP服务器是单一故障点（Single Point of Failure），一旦该服务器或应用软件失效，会导致整个服务的中断。 集群的起源集群并不是一个全新的概念，其实早在七十年代计算机厂商和研究机构就开始了对集群系统的研究和开发。由于主要用于科学工程计算，所以这些系统并不为大家所熟知。直到Linux集群的出现，集群的概念才得以广为传播。对集群的研究起源于集群系统的良好的性能可扩展性(scalability)。提高CPU主频和总线带宽是最初提供计算机性能的主要手段。但是这一手段对系统性能的提供是有限的。接着人们通过增加CPU个数和内存容量来提高性能，于是出现了向量机，对称多处理机(SMP)等。但是当CPU的个数超过某一阈值，象SMP这些多处理机系统的可扩展性就变的极差。主要瓶颈在于CPU访问内存的带宽并不能随着CPU个数的增加而有效增长。与SMP相反，集群系统的性能随着CPU个数的增加几乎是线性变化的 集群恰恰是通过高性能网络或局域网互联的服务器集群正成为实现高可伸缩的、高可用网络服务的有效结构（而非基于单机CPU数量的增长）。这种松耦合结构的服务器集群系统有下列优点： 性能 网络服务的工作负载通常是大量相互独立的任务，通过一组服务器分而治之，可以获得很高的整体性能。 性能/价格比 组成集群系统的PC服务器或RISC服务器和标准网络设备因为大规模生产降低成本，价格低，具有最高的性能/价格比。若整体性能随着结点数的增长而接近线性增加，该系统的性能/价格比接近于PC服务器。所以，这种松耦合结构比紧耦合的多处理器系统具有更好的性能/价格比。 可伸缩性 集群系统中的结点数目可以增长到几千个，乃至上万个，其伸缩性远超过单台超级计算机。 高可用性在硬件和软件上都有冗余，通过检测软硬件的故障，将故障屏蔽，由存活结点提供服务，可实现高可用性。 当然，用服务器集群系统实现可伸缩网络服务也存在很多挑战性的工作： 透明性（Transparency）对用户透明，如何高效地使得由多个独立计算机组成的松藕合的集群系统构成一个虚拟服务器；客户端应用程序与集群系统交互时，就像与一台高性能、高可用的服务器交互一样，客户端无须作任何修改。部分服务器的切入和切出不会中断服务，这对用户也是透明的。 性能（Performance） 性能要接近线性加速，这需要设计很好的软硬件的体系结构，消除系统可能存在的瓶颈。将负载较均衡地调度到各台服务器上。 高可用性（Availability） 需要设计和实现很好的系统资源和故障的监测和处理系统。当发现一个模块失败时，要这模块上提供的服务迁移到其他模块上。在理想状况下，这种迁移是即时的、自动的。 可管理性（Manageability） 要使集群系统变得易管理，就像管理一个单一映像系统一样。在理想状况下，软硬件模块的插入能做到即插即用（Plug &amp; Play）。 可编程性（Programmability） 在集群系统上，容易开发应用程序。 集群类型通常我们根据需求将集群分为三类：负载均衡集群（Load Balancing LB）,高可用性集群（High Availability HA）,高性能也叫科学集群（High Performance HP。 下面做一下详细的介绍（来源自博客），笔者本人学习中只听闻过负载均衡集群。 负载均衡集群（Load Balancing LB） 负载均衡集群为企业需求提供了更实用的系统。如名称所暗示的，该系统使负载可以在计算机集群中尽可能平均地分摊处理。该负载可能是需要均衡的应用程序处理负载或网络流量负载。这样的系统非常适合于运行同一组应用程序的大量用户。每个节点都可以处理一部分负载，并且可以在节点之间动态分配负载，以实现平衡。对于网络流量也是如此。通常，网络服务器应用程序接受了太多入网流量，以致无法迅速处理，这就需要将流量发送给在其它节点上运行的网络服务器应用。还可以根据每个节点上不同的可用资源或网络的特殊环境来进行优化。 高可用性集群（High Availability HA） 高可用性集群的出现是为了使集群的整体服务尽可能可用，以便考虑计算硬件和软件的易错性。如果高可用性集群中的主节点发生了故障，那么这段时间内将由次节点代替它。次节点通常是主节点的镜像，所以当它代替主节点时，它可以完全接管其身份，并且因此使系统环境对于用户是一致的。 高性能也叫科学集群（High Performance HP） 为集群开发并行编程应用程序，以解决复杂的科学问题。这是并行计算的基础，尽管它不使用专门的并行超级计算机，这种超级计算机内部由十至上万个独立处理器组成。但它却使用商业系统，如通过高速连接来链接的一组单处理器或双处理器 PC，并且在公共消息传递层上进行通信以运行并行应用程序。因此，您会常常听说又有一种便宜的 Linux 超级计算机问世了。但它实际是一个计算机集群，其处理能力与真的超级计算机相等，通常一套象样的集群配置开销要超过 $100,000。这对一般人来说似乎是太贵了，但与价值上百万美元的专用超级计算机相比还算是便宜的。 集群的实现根据网络资料，已知的负载均衡集群可以通过硬件和软件两种方式实现，其他两种集群的实现方式不太清楚。 硬件方式：即通过专用的硬件（处理机）进行内容的分发调度，一般而言，硬件负载均衡在功能、性能上优于软件方式，不过成本昂贵。而且最重要的是该专用硬件是单点配置，即具有发生单点故障导致整个集群瘫痪的风险。 软件方式：软件负载均衡解决方案是指在一台或多台服务器相应的操作系统上安装一个或多个附加软件来实现负载均衡，它的优点是基于特定环境，配置简单，使用灵活，成本低廉，可以满足一般的负载均衡需求。 后面着重以LVS（著名的开源项目）为例来说明LVS集群系统的实现。 第二部分 LVS集群系统项目诞生 针对高可伸缩、高可用网络服务的需求，我们给出了基于IP层和基于内容请求分发的负载平衡调度解决方法，并在Linux内核中实现了这些方法，将一组服务器构成一个实现可伸缩的、高可用网络服务的虚拟服务器。 虚拟服务器的体系结构如图2所示，一组服务器通过高速的局域网或者地理分布的广域网相互连接，在它们的前端有一个负载调度器（Load Balancer）。负载调度器能无缝地将网络请求调度到真实服务器上，从而使得服务器集群的结构对客户是透明的，客户访问集群系统提供的网络服务就像访 问一台高性能、高可用的服务器一样。客户程序不受服务器集群的影响不需作任何修改。系统的伸缩性通过在服务机群中透明地加入和删除一个节点来达到，通过检 测节点或服务进程故障和正确地重置系统达到高可用性。由于我们的负载调度技术是在Linux内核中实现的，我们称之为Linux虚拟服务器（Linux Virtual Server）。 LVS集群的组成与特点Linux虚拟服务器（Linux Virtual Server，LVS）是一个由章文嵩开发的一款自由软件，利用LVS可以实现高可用的、可伸缩的Web、Mail、Cache和Media等网络服务。并在此基础上开发支持庞大用户数的、可伸缩的、高可用的电子商务应用。LVS自1998年发展到现在，已经变得比较成熟，目前广泛应用在各种网络服务和电子商务应用中。 LVS具有很好的可伸缩性、可靠性和可管理性，通过LVS要实现的最终目标是：利用Linux操作系统和LVS集群软件实现一个高可用、高性能、低成本的服务器应用集群。 LVS 集群的组成利用LVS架设的服务器集群由3个部分组成：最前端的是负载均衡层（用Load Balancer表示），中间是服务器群组层（用Server Array表示），底端是数据共享存储层（用Shared Storage表示，这里应该还涉及一些分布式存储？的知识）。在用户看来，整个LVS集群系统的所有内部应用结构都是透明的，最终用户只是在使用一个虚拟服务器提供的高性能服务。 下面对LVS三个组成部分进行详细的介绍： 负载均衡层：位于整个集群系统的最前端，由一台或多台负载均衡调度器（Director Server），只有一台调度器的时候我们也将其成为Load Balancer，LVS核心模块IPVS就安装在Director Server上，而Director的主要作用类似于一个路由器，它含有为完成LVS功能所设定的路由表，通过这些路由表把用户的请求分发给服务器群组层的应用服务器（Real Server），整个过程对访问集群的用户是透明的。同时，在Director Server上还要安装对Real Server的监控模块Ldirectord，此模块用于监测各个Real Server服务的健康状况。在Real Server不可用时将其从LVS路由表中剔除，在恢复时重新加入（伸缩性的体现）。 服务器群组层：由一组实际运行应用服务的机器组成，Real Server可以是Web服务器、Mail服务器、FTP服务器、DNS服务器、视频服务器中的一个或多个，每个Real Server之间通过高速的LAN或分布在各地的WAN相连接。在实际的应用中，Director Server也可以同时兼任Real Server的角色。 共享存储层：是为所有Real Server提供共享存储空间和内容一致性的存储区域，一般由磁盘阵列设备组成。为了提供内容的一致性，一般可以通过NFS网络文件系统共享数据，但是NFS在繁忙的业务系统中，性能并不是很好，此时可以采用集群文件系统，例如Red Hat的GFS文件系统，Oracle提供的OCFS2文件系统等。 从整个LVS结构可以看出，Dirctor Server是整个LVS的核心。目前，用于Director Server的操作系统只有Linux和FreeBSD，Linux 2.6内核完全内置了LVS的各个模块，不用任何设置就可以支持LVS功能。 LVS集群的特点 IP负载均衡与负载调度算法 IP负载均衡技术 负载均衡技术有很多实现方案，有基于DNS域名轮流解析的方法，有基于客户端调度访问的方法，有基于应用层系统负载的调度方法，还有基于IP地址的调度方法。在这些负载调度算法中，执行效率最高的是IP负载均衡技术。 LVS的IP负载均衡技术是通过IPVS模块来实现的。IPVS是LVS集群系统的核心软件，它的主要作用是：安装在Director Server上，同时在Director Server上虚拟出一个IP地址，用户必须通过这个虚拟的IP地址访问服务器。这个虚拟IP一般称为LVS的VIP，即Virtual IP。访问的请求首先经过VIP到达负载调度器，然后由负载调度器从Real Server列表中选择一个服务器节点相应用户的请求。 在用户的请求到达负载调度器后，调度器如何请求发送到提供服务的Real Server节点，而Real Server节点如何返回数据给用户，是IPVS实现的重点技术。IPVS实现负载均衡地方式有3种，分别是NAT、TUN和DR。（原书后面有详细介绍，这里就不多写了，有兴趣之后再了解）。 负载均衡调度算法 动态选择的实现，就是负载调度算法。IPVS实现了8种负载调度算法。分别是，轮叫调度（Round Robin）、加权轮叫调度（Weighted Round Robin）、最少连接调度（Least Connections）、加权最少连接调度（Weighted Least Connections）、基于局部性的最少连接（Locality-Based Least Connections）、带复制的基于局部性最少连接（Locality-Based Least Connections with Replication）、目标地址散列（Destination Hashing）和源地址散列（Source Hashing）。 如果想要进一步了解，请登录LVS中文站点，查阅更详细的信息。 高可用性 LVS是一个基于内核级别的应用软件，因此具有很高的处理性能。由LVS构建的负载均衡集群系统具有优秀的处理能力，每个服务节点的故障不会影响整个系统的正常使用，又能够实现负载的合理均衡，使应用具有超高负荷的服务能力，可支持上百万个并发连接请求。 高可靠性 LVS负载均衡集群软件已经在企业和学校中得到了很好的普及，国内外很多大型的、关键性的Web站点也都采用了LVS集群软件，所以它的可靠性在实践中得到了很好印证。有很多由LVS构成的负载均衡系统，运行很长时间，从未进行过重新启动。这些都说明了LVS的高稳定性和高可靠性。 使用环境 目前仅支持Linux和FreeBSD系统作为前端Director Server，但是支持大多数的TCP和UDP协议。支持TCP协议的应用有：HTTP、HTTPS、FTP、SMTP、POP3、IMAP4等等；支持UDP协议的应用有：DNS、NTP、ICP、视频和音频流播放协议等。 LVS对Real Server的操作系统没有任何限制，Real Server可运行在任何支持TCP/IP的操作系统上，包括Linux，各种UNIX（如FreeBSD、Sun Solaris、HP Unix等），Mac OS和Windows等。 开源软件 LVS集群软件是按GPL（GNU Public License许可证发行的自由软件，因此，使用者可以得到软件的源代码，并且可以根据自己的需要进行各种修改，但是修改必须以GPL方式发行。 第三部分 集群系统的配套应用Heartbeat如果负载均衡层（Load Balancer）仅由一台Director Server来实现VIP与集群资源的调度，就会面临单点故障后整个集群系统瘫痪的危险。为了实现LVS负载均衡系统下的高可用性，我们可以使用一些常用的HA软件，实现“双机互备”。 heartbeat使Linux-HA项目中的一个组件，也是目前开源HA项目中最成功的一个例子，它提供了所有HA软件需要的基本功能，检测集群中的系统服务，在集群的节点间转移共享IP地址的所有者等。自1999年开始到现在，heartbeat在行业内得到了广泛应用，也发行了很多版本，最核心的包括两个部分，其最核心包括心跳监测部分和资源接管部分，心跳监测可以通过网络链路和串口进行，而且支持冗余链路，它们之间相互发送报文来告诉对方自己当前的状态，如果在指定的时间内未受到对方发送的报文，那么就认为对方失效，这时需启动资源接管模块来接管运 行在对方主机上的资源或者服务。 IP网络存储iSCSI主要介绍基于IP SAN的网络存储iSCSI。iSCSI技术以其低廉的构建成本和优秀的存储性能，博得了很多CIO和存储管理员的喜爱，目前陆续进入企业应用领域，推动了企业的存储环境向集中式转变。虽然，目前对于iSCSI应该在什么样的环境中使用还存在着诸多争议，但是iSCSI的前途使光明的，在未来的存储世界中，iSCSI一定会占据重要的席位。 存储概念的术语在存储的世界里，有各种各样的名词和术语，常见的有SCSI、FC、DAS、NAS、SAN等。本节重点介绍与存储相关的术语和知识。 SCSI介绍 SCSI是小型计算机系统接口（Small Computer System Interface）的简称，SCSI作为输入/输出接口，主要用于硬盘、光盘、磁带机、扫描仪、打印机等设备。 FC介绍 FC是光纤通道（Fiber Channel）的简称，是一种适合于千兆数据传输的、成熟而安全的解决方案，与传统的SCSI技术相比，FC提供更高的数据传输速率，更远的传输距离，更多的设备连接支持，更稳定的性能，更简易的安装。 DAS介绍 DAS是直联式存储（Directed-Attached Storage）的简称，是指将存储设备通过SCSI接口或光纤通道直接连接到一台计算机上，当服务器在地理上比较分散，很暗通过远程进行互连时，DAS是比较好的解决方案。但是这种存储方式只能通过与之连接的主机进行访问，不能实现数据与其他主机的共享，同时，DAS会占用服务器操作系统资源，例如CPU资源、IO资源等，并且数据量越大，占用操作系统资源就越严重。 NAS介绍 网络接入存储（Network-Attached Storage）简称NAS，它通过网络交换机连接存储系统和服务器，建立专门用于数据存储的私有网络，用户通过TCP/IP协议访问数据，采用业界标准文件共享协议如NFS、HTTP、CIFS来实现基于文件级的数据共享。NAS存储使文件共享访问变得更方便和快捷，并且能很容易地增加存储容量。通过企业化的文件服务器和存储技术相结合，NAS为那些需要共享大量文件数据的企业提供了一个高效的、可靠的、高性价比的解决方案。但是NAS也有一定的局限性，它会受到网络带宽和网络拥堵的影响，在一定程度上限制了NAS的网络传输能力。 SAN介绍 存储区域网络（Storage Area Network）简称SAN，它是一种通过光纤交换机、光线路由器、光纤集线器等设备将磁盘阵列、磁带等存储设备与相关服务器连接起来的高速专用子网。 SAN由三个部分组成，分别是连接设备（如路由器、光纤交换机和Hub）、接口（如SCSI、FC）、通信协议（如IP和SCSI）。这三部分再加上存储设备和服务器就构成了一个SAN系统。SAN提供了一个灵活的、高性能的和高扩展性的存储网络环境，它可以更加有效地传输海量地数据块。由于采用了光纤接口，因此SAN还具有更高的带宽，同时，SAN也使统一管理和集中控制实现简化。现在SAN已经广泛应用于ISP和银行等，随着用户业务量增大，SAN的应用前景将越来越光明。 iSCSI的概念iSCSI，即internet SCSI，是IETF制定的一项标准，用于将SCSI数据块映射为以太网数据包。从根本上说，它是一种基于IP Storage理论的新型存储技术，该技术将存储行业广泛应用的SCSI接口技术IP网络技术相结合，可以在IP网络上构建SAN。简单地说，iSCSI就是在IP网络上运行SCSI协议的一种网络存储技术。iSCSI最初由Cisco和IBM两家开发，并且得到了广大IP存储技术爱好者的大力支持，这几年迅速的发展壮大。 FC SAN与IP SAN在iSCSI技术出现后，通过IP技术搭建的存储网络也应运而生，SAN技术也就出现了两种不同的实现方式，即FC SAN与IP SAN。简单来说，以光纤搭建的存储网络就是FC SAN，以SCSI技术搭建的存储网络叫做IP SAN。 作为SAN的两种实现方式，他们各有优劣，下面从几个方面分别阐述。 在数据传输方式上，FC SAN与IP SAN都采用块协议方式来完成，这是他们的相同点。 在传输速度上，就目前传输速率而言，FC SAN（2Gbit/s）最快，iSCSI（1Gbit/s）次之。 在传输距离上，FC SAN理论上可以达到100公里，而事实上，传输50公里过后，会出现瓶颈。而通过IP网络的iSCSI技术在理论上没有距离的限制，即iSCSI可以进行没有距离限制的数据传输。 在管理及维护成本上，架设FC SAN网络需要投入很多硬件成本吗，并且需要特定的工具软件进行操作管理，而IP SAN构建成本低廉，由于iSCSI是通过IP网络来传输数据和分配存储资源的，因此只要在现有的网络上进行管理和使用即可，这样就可以省下大笔的管理费用及培训成本。 当然，iSCSI的推广还存在着安全性、软硬件适配问题等，但是相信在未来的网络存储世界里，IP SAN绝对会拥有一席之地。 iSCSI的组成一个简单的iSCSI系统大致有以下部分组成： iSCSI Initiator或者iSCSI HBA iSCSI Target 以太网交换机 一台或者多台服务器 详细的软硬件设备介绍（Initiator和Target）以及iSCSI工作原理有兴趣再做进一步研究，在此不再叙述。]]></content>
      <categories>
        <category>操作系统,集群</category>
      </categories>
      <tags>
        <tag>编程</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[PHP学习——Laravel框架入门]]></title>
    <url>%2Fpost%2Fd7435d20.html</url>
    <content type="text"><![CDATA[环境搭建此处省略，后面补充 Laravel教程微博实例构建页面样式美化12yarn install --no-bin-linksyarn add cross-env 使用Boostrap组件进行前端样式美化 Bootstrap再入门上面代码将引入public/css/app.css样式文件。 header, nav 是 HTML5 提供的一种语义化标签，其实际作用与 div 一致，语义化的标签能帮助机器更方便理解代码，使代码更简洁，有助于网站的 SEO 优化。我们在上面代码使用到一些如 navbar, container 等类名在 Bootstrap 中都拥有特殊含义。 Laravel 前端工作流介绍Sass,NPM,Yarn,Laravel Mix来构成一套完整的前端工作流。 SASS语法基础 样式文件导入 Sass使用@import 来导入其它的样式文件从而实现样式嵌套。 变量 Sass允许加入自己的变量，所有的变量以$开头 1234$navbar-color: #3c3e42;.navbar-inverse &#123; background-color: $navbar-color;&#125; 在编译成功后，变量会被替代为对应的值 嵌套 Sass允许选择器中相互嵌套以减少代码量 引用父选择器 在Sass嵌套中使用&amp;对父选择器进行引用： 123456a &#123; color: white; &amp;:hover &#123; color: blue; &#125;&#125; NPMNPM 是Node.js 的包管理和任务管理工具，其强大的功能也是Node.js能够如此成功的因素之一。在使用NPM安装第三方模块（也可理解为扩展包）时，你需要在 package.json 中队需要安装的模块指定好名称和版本号。然后运行下面的命令进行安装： 1$ npm install 在学习教程中，出于安装速度考虑，我们使用更加现代化的 Yarn 来替代 NPM 的包管理功能。然而我们仍然会使用到 NPM 的任务管理功能，如命令 npm run watch-poll。 YarnYarn 是 Facebook 在 2016 年 10 月开源的一个新的包管理器，用于替代现有的 NPM 客户端或者其他兼容 NPM 仓库的包管理工具。Yarn 在保留 NPM 原有工作流特性的基础上，使之变得更快、更安全、更可靠。在后面的项目开发中，我们统一使用 Yarn 来代替 NPM 进行安装包的管理。 我们可通过下面命令来安装当前项目的所有包： 1$ yarn install Laravel MixLaravel Mix 一款前端任务自动化管理工具，使用了工作流的模式对制定好的任务依次执行。Mix 提供了简洁流畅的 API，让你能够为你的 Laravel 应用定义 Webpack 编译任务。Mix 支持许多常见的 CSS 与 JavaScript 预处理器，通过简单的调用，你可以轻松地管理前端资源。我们可以在 webpack.mix.js 文件中制定一些如资源文件的编译、压缩等任务。Laravel 已默认为我们生成了 webpack.mix.js 文件，并集成了 laravel-mix 模块。 浏览器缓存问题问题描述 现代化的浏览器，会对静态文件进行缓存，静态文件在本课程的范畴内，指的是 .css 、.js 后缀的文件。这是一个浏览器的优化功能，极大地加快了网页的加载速度，但是在我们日常开发和维护中，有时候会造成混淆。 开发时，你明明修改了样式，但是刷新浏览器却看不见变化，然后你就来回不断地修改你的样式文件，做各种测试，浏览器页面仍然一成不变。直到你重新刷新好多次，或者修改样式文件名称时，才恍然大悟，原来是浏览器缓存了。 解决方法Laravel Mix，增加哈希值，只要修改，哈希值改变，则客户端浏览器就需要重新加载文件。 对 webpack.mix.js 稍作修改 1234const mix = require('laravel-mix');mix.js('resources/js/app.js', 'public/js') .sass('resources/sass/app.scss', 'public/css').version(); 局部视图随着代码量增加，都存在默认视图中会变得太过臃肿，难以维护，所以最好将部分视图分离出来，成为单独得局部视图。 头部和底部视图首先，我们需要新建一个头部视图文件。 resources/views/layouts/_header.blade.php 123456789&lt;nav class="navbar navbar-expand-lg navbar-dark bg-dark"&gt; &lt;div class="container "&gt; &lt;a class="navbar-brand" href="/"&gt;Weibo App&lt;/a&gt; &lt;ul class="navbar-nav justify-content-end"&gt; &lt;li class="nav-item"&gt;&lt;a class="nav-link" href="/help"&gt;帮助&lt;/a&gt;&lt;/li&gt; &lt;li class="nav-item" &gt;&lt;a class="nav-link" href="#"&gt;登录&lt;/a&gt;&lt;/li&gt; &lt;/ul&gt; &lt;/div&gt;&lt;/nav&gt; 可以看到，我们在头部视图的文件名前面加了下划线 _，这样做是为了指定该视图文件为局部视图，为局部视图增加前缀下划线是『约定俗成』的做法，方便了其它人快速地理解该文件的实际作用。从这里开始，我们都会为局部文件添加下划线前缀。 现在让我们再来为应用创建一个底部视图，用于置放网站的一些基础信息。 resources/views/layouts/_footer.blade.php 12345678910&lt;footer class="footer"&gt; &lt;img class="brand-icon" src="https://iocaffcdn.phphub.org/uploads/sites/KDiyAbV0hj1ytHpRTOlVpucbLebonxeX.png"&gt; &lt;a href="https://learnku.com/laravel/courses" target=_blank&gt; 刻意练习，每日精进 &lt;/a&gt; &lt;div class="float-right"&gt; &lt;a href="/about" &gt;关于&lt;/a&gt; &lt;/div&gt;&lt;/footer&gt; 布局中的链接Laravel中链接地址的写法较为常见的链接地址的写法 1&lt;li&gt;&lt;a href="/help"&gt;帮助&lt;/a&gt;&lt;/li&gt; 在Laravel中，我们可以这么写 1&lt;li&gt;&lt;a href=" route('help') "&gt;帮助&lt;/a&gt;&lt;/li&gt; 大括号括起来的部分是在HTML中内嵌PHP的Blade语法标识符，表示包含在该区块内的代码都将用PHP来编译运行。route()方法由Laravel提供，传递一个具体的路由名称来生成完整的URL。 在 Laravel 中，我们可以通过在路由后面链式调用 name 方法来为路由指定名称： 1Route::get('/help', 'StaticPagesController@help')-&gt;name('help'); 可以看到 route(&#39;help&#39;)为我们生成了完整的 URL 地址，这样当我们需要对生成的 URL 进行更改时，我们只需要改动路由文件即可，由此可见在实际开发中养成对路由的命名是一个好习惯，可以帮助我们节省很多工作量，另外也是 Laravel 项目开发的最佳实践。 均改为href=&quot;route()&quot;的形式 静态页面在我们后面的教程中，将会为应用添加注册登录的功能，本节让我们先来完成用户注册功能的第一步：为用户注册功能创建基本的静态页面。 注册路由当用户访问注册url时，进入我们的注册页面 修改（添加）路由 12345Route::get('/', 'StaticPagesController@home')-&gt;name('home');Route::get('/help', 'StaticPagesController@help')-&gt;name('help');Route::get('/about', 'StaticPagesController@about')-&gt;name('about');Route::get('signup', 'UsersController@create')-&gt;name('signup'); 注册路由时，URI signup 和 /signup 从使用上来看，并无区别，Laravel 框架兼容这两种写法。 注意这里不在注册到StaticPagesController控制器上，因为不单是静态页面，会涉及和数据库的交互，所以围绕用户使用用户控制器来处理此逻辑。 用户模型MVC框架的MM-Model（模型），构建一个基本的用户模型来实现用户数据的存储，并了解Laravel如何对模型对象进行增删查改等操作。后面我们还会在此用户模型上添加用户注册和登录的功能，并对用户进行权限认证，管理员具备用户的删除操作。再构建一套用户账号激活和密码找回系统。 用户认证系统Laravel集成了一整套用户登录注册功能，并提供了一些方便的API，但是出于学习目的，我们会借助一些简单的API来独自开发一个完整的用户认证系统。 如果定制性不高，还是建议使用Laravel的默认提供的用户认证系统。 Eloquent ORM在接下来几章要实现的用户注册功能需要用到数据库来进行数据存储，用于放置用户的基本信息。在这期间，还需要用到数据模型- Model，利用 Laravel 提供的 Eloquent ORM 跟数据库进行交互，实现用户数据的增删改查操作。Eloquent 提供了简洁优雅的 ActiveRecord 实现来跟数据库进行交互。Active Record 是一种领域模型模式，该模式由 Martin Fowler 在 2003 年出版的《企业应用架构模式》一书中进行了详细叙述并命名。其特点是一个模型类对应关系型数据库中的一个表，模型类的一个实例对应表中的一行记录。Active Record 最大优点是允许我们简单, 直观地操作数据层。 数据库迁移Laravel中通过数据库迁移来管理数据库表结构，迁移就像数据库中的版本控制。 好处 多人并行开发 代码版本管理 数据库版本控制：如：回滚重置更新 兼容多种数据库系统 部署方便 默认迁移文件所有迁移文件统一放置在 database/migrations 文件夹里 我们看到Laravel已经默认创建好了两个迁移文件。 database/migrations/2014_10_12_000000_create_users_table.php database/migrations/2014_10_12_100000_create_password_resets_table.php 加入时间戳避免多人开发时候的命名冲突。 创建数据库表up方法里，通过调用 Schema 类的create方法来创建users表： 123Schema::create('users', function (Blueprint $table) &#123; ...&#125;); 两个参数 参数1：表名称 参数2：Blueprint实例的必报（函数依赖关系必报） 定义数据表字段CreateUsersTable 类中通过 Blueprint 的实例 $table 为 users 表创建所需的数据库字段。接下来让我们来详细讲解 Blueprint 实例 $table 的基本用法： 1$table-&gt;increments('id'); 由 increments 方法创建了一个 integer 类型的自增长 id。 1$table-&gt;string('name'); 由 string 方法创建了一个 name 字段，用于保存用户名称。 1$table-&gt;string('email')-&gt;unique(); 由 string 方法创建了一个 email 字段，且在最后指定该字段的值为唯一值，用于保存用户邮箱。 1$table-&gt;timestamp('email_verified_at')-&gt;nullable(); Email 验证时间，空的话意味着用户还未验证邮箱。nullable()方法表示字段可空。 1$table-&gt;string('password', 60); 由 string 方法创建了一个 password 字段，且在 string 方法中指定保存的值最大长度为 60，用于保存用户密码。 1$table-&gt;rememberToken(); 由 rememberToken 方法为用户创建一个 remember_token 字段，用于保存『记住我』的相关信息。 1$table-&gt;timestamps(); 由 timestamps 方法创建了一个 created_at 和一个 updated_at 字段，分别用于保存用户的创建时间和更新时间。注意和前面email的timestap字段区分开。 回滚迁移down 方法会在回滚命令发起时被调用，是 up 方法的逆向操作。在上面的代码中，up 创建了 users 表，那么这里将会通过调用 Schema 的 drop 方法来删除 users 表。 1Schema::dropIfExists('users'); 用户注册本章节为注册页添加一个注册表单 隐式绑定由于我们使用了 view(&#39;users.show&#39;, compact(&#39;user&#39;)) 将用户数据与视图进行绑定，因此在视图中可以直接使用 $user 来访问用户实例。 会话管理由于 HTTP 协议是无状态的，所以 Laravel 提供了一种用于临时保存用户数据的方法 - 会话（Session），并附带支持多种会话后端驱动，可通过统一的 API 进行使用。 我们可以使用 session() 方法来访问会话实例。而当我们想存入一条缓存的数据，让它只在下一次的请求内有效时，则可以使用 flash 方法。flash 方法接收两个参数，第一个为会话的键，第二个为会话的值，我们可以通过下面这行代码的为会话赋值。 接下来的消息提示我们会用会话进行闪存，并分别为其设定好指定的键。danger, warning, success, info 这四个键名在 Bootstrap 分别具有不同样式展现效果，因此后面我们将使用这几个键名作为消息提示的专有设定。 用户CRUD新增的 edit 动作主要做了以下几个操作： 利用了 Laravel 的『隐性路由模型绑定』功能，直接读取对应 ID 的用户实例 $user，未找到则报错；将查找到的用户实例 $user 与编辑视图进行绑定；在将用户数据与视图进行绑定之后，便可以在视图上通过 $user 来访问用户对象。接下来让我们接着完成用户编辑页面的构建。 编辑成功现在的用户编辑功能还有两个地方需要优化： 在每次更改个人资料的时候都输入完整的密码，才能更新其它信息，对于不想对密码进行更新的用户，这个过程会比较繁琐； 更新成功之后在页面上没有进行任何提示，而是直接跳转到用户的个人页面，用户体验非常不好；]]></content>
      <categories>
        <category>编程,PHP</category>
      </categories>
      <tags>
        <tag>编程,PHP</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[数据挖掘学习——数据驱动比赛笔记]]></title>
    <url>%2Fpost%2F53729461.html</url>
    <content type="text"><![CDATA[数据挖掘比赛简介主要任务对中国青少年科技创新比赛做统计分析 分析目标 各省历年一、二等奖获奖情况比较 东、中、西部地区获奖情况比较 各省获奖最多的学校（集中度） 各省获奖最多的学校获学科类别比较 历年选题相似度比较 工程学项目选题变化趋势 获奖项目水平与学生知识匹配度 2009-2012（有保送）、2013-2014（高考加分）、2015-2018（自主招生（选题和获奖情况比较 三等奖与一等奖在选题上的差别 初步想法编程使用语言：python 使用外部库： jieba用于中文分词 numpy,matplotlib用于科学计算与绘图 wordcloud用于制作词云 利用python相关外部库，通过jieba中文分词对限定范围内的中文文本进行分词，然后统计词频， 统计词频以后绘制词云图]]></content>
      <categories>
        <category>编程</category>
      </categories>
      <tags>
        <tag>编程,数据挖掘</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[数据挖掘学习——TF-IDF算法原理学习]]></title>
    <url>%2Fpost%2F2ee4d523.html</url>
    <content type="text"></content>
      <tags>
        <tag>编程</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[《数据挖掘学习——数据驱动比赛笔记]]></title>
    <url>%2Fpost%2Ffa83cee.html</url>
    <content type="text"></content>
      <tags>
        <tag>编程</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[编译原理学习——《编译原理》龙书读书笔记（一）]]></title>
    <url>%2Fpost%2Ff8e4bc7f.html</url>
    <content type="text"><![CDATA[第1章 引论目标语言翻译成一种能被计算机执行的形式，完成这一过程的软件系统称为编译器（compiler）。 本书介绍的是设计和实现编译器的方法。 本章内容 介绍语言翻译器的不同形式 在高层次（概念层次）概述一个典型编译器的结构 讨论程序设计语言和硬件体系结构的发展趋势 编译器理论和计算机科学理论的关系的一些事实 给出一些在编译器设计领域以外的应用 语言处理器编译器，和解释器（Interpreter）是常见的两种形式。 主要区别：解释器并不同编译器一样将源程序编译成目标程序，而是对源语句（结合用户的输入）逐条解释执行。 预处理器，除了编译器之外，创建一个可执行的目标程序还需要一些其他程序，比如将程序员写程序时划分的多个模块聚合在一起的任务，以及将称为宏（micro）展开成源语言格式的任务，有时就由预处理器完成。 一个编译器的结构通过编译器，源程序映射到目标语言程序（语义上等价），映射过程大致分为分析和综合两部分。 分析（analysis） 把源程序分解为多个组成要素，加上语法结构，创建中间表示。 检测是否符合源程序语言语义并给出用户相应提示，同时收集源程序的一些信息，存放在一个称为符号表（symbol table）的数据结构中，然后一并传送给综合部分。 综合（synthesis） 根据分析得到的中间表示和符号表中的信息来构造用户期待的目标程序。 常称分析部分为编译器的前端（front end），而综合部份为编译器的后端（back end）。 编译过程可以拆成一组过程（phase） 词法分析词法分析（lexical analysis）或称为扫描（scanning）。读入源程序字符流，拆成词素序列，词法单元和一个符号表。 语法分析语法分析（syntax analysis）或称为解析（parsing）根据词法单元的第一个分量创造一个树形的中间表示，一种常用的表示方法时语法树（syntax tree）。 语义分析语义分析器（sermantic analyzer）使用语法树和符号表中的信息来检查源程序是否和语言定义的语义一致。同时收集类型信息，在随后的中间代码生成过程中使用。 一个重要部分时类型检查（type checking），同时实现（如果允许的话）自动类型转换。 中间代码生成]]></content>
      <categories>
        <category>编程</category>
        <category>编译原理</category>
      </categories>
      <tags>
        <tag>编程,编译原理</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[编译原理学习——基本概念梳理]]></title>
    <url>%2Fpost%2Fe8bc7157.html</url>
    <content type="text"><![CDATA[正式上课前注意点梳理关于编译原理学习编译本身是一个超级算法，其中分成两大部分：理论和技术。 编译原理的学习不同于离散数学，离散数学的各个部分是相对而言分离的，各部分没有直接的前后因果关系，但是编译原理作为一个“算法”，是一个整体，前后贯通和呼应，因此，在学习编译原理的过程中，必须把前面的基础学懂了才能应对后面的内容。 根据教材，《编译原理》第一章到第五章侧重于理论，第六章和第七章是理论与技术结合，再后面的章节主要是计数方法介绍。 《编译原理》学习的要点在形式语言和自动机，所有的一切最终都是归结到自动机的理论和应用。 巩固好前驱课程，如数据结构、高级语言程序设计、汇编语言等专业课程有助于编译原理课程的学习。 关于数学的客观来源与表现形式编译原理学习中提到的形式语言与自动机。 形式语言和自动机，是从两个角度、使用两种建模方式对相同客观对象描述的两个“等价”的数学模型，各有其在不同的环境下的用途。 数学的形式是主观的，但来源是客观的，都是对客观世界的抽象。主观性表现在抽象的形态是“随心所欲”的，同一个对象可被抽象为不同的数学表示方式和运算方式，但其根本性是客观的，离开了物化的或具体化意义的数学是不存在的，如果存在，也是毫无价值的。 初识“自动机”话放在前面，不是严格意义上的自动机，而是为了方便初学者理解的“简化版自动机” 为了方便理解，先行介绍“简化”的自动机，我们当下可以认为自动机是由$n$个状态组成的状态集合，$S= { s_1,s_2, \cdots ,s_n }$和$m$个字符组成的输入字符集合，$\Sigma = { a_1,a_2, \cdots , a_m }$构成的二元组，即$自动机 = $ 但是真正的自动机不是二元组，而是五元组。作为初学者，可以先从理解这个二元组形式的来入门，更容易从本质上理解什么是自动机。 核查正确性，很容易联想到构造一个“字典”一样的存在，但是不可能用一个标准的字典来穷尽所有正确的单词（单词可能是无穷的）。那么自动机就起到了这个包含了无穷个单词的字典的作用（核查）。 要完整地弄懂自动机概念，需要四个方面的基础知识：集合，笛卡尔乘积，关系，函数。 当然，掌握了自动机理论，离使用这套理论构造程序语言的编译程序还有一段距离，即理论到应用的距离。应用辨识能力，需要慢慢学习。 所谓“语言”科学和数学的定义，一是要普世、二是要精确。 回顾“关系”，关系的数学定义是：A集合到B集合的笛卡尔乘积的子集。 那么，语言的数学定义是什么？ 语言的数学定义：语言就是字符串的集合。 广义的“语言”，科学和数学方式定义的语言意义重大。最大直接好处是：这些概念所表的东西可以被以数学方式进行处理，比如，列出方程并求解方程，列出逻辑公式并推理，等等。 既然语言是字符串的集合，我们可以进一步用一个公式产生某些字符串的集合，遗憾的是，有些字符串的集合是找不到公式来产生的。言下之意，有些肯定是可以用公式产生的。我们编译原理关心的是这些可以由数学公式产生的字符串的集合（即语言） 形式语言的数学定义：可以由数学公式产生的语言就叫做形式语言。 人类的自然语言是不可以用数学公式表达出来的，否则，自然语言识别就是100%准确并且100%听懂人类语言的机器人也能被制造出来。 尽管人类语言无法用数学公式统一表达，但是程学设计语言是可以的。实际上，是先数学公式做好，再产生出对应的程序设计语言。 这个“数学公式”叫做文法或语法。 例：G文法形式是：$S \rightarrow aS|b$ ,其中$S$叫做非终止符，在这里也做开始符号，整个公式叫做产生式集合。 其推出的语言 $L = { ab,aab,aaab, \cdots }$。 用数学公式（文法）表示的语言可以很方便的被处理，因为这个语言的特征都通过文法集中体现了，我们只要针对文法进行处理，就等价于对整个语言进行了处理。通过掌控有线而驾驭了无限。 《编译原理》可以告诉你如何分析程序设计语言的文法来驾驭这个语言。 人类语言的变化多端和本身造句的模糊性以及其本身不断地发展变化（包括规则本身的变化），使不可能被一个或一组数学公式（形式语法）完全表达。 程序设计语言不是实践的结果，而是先规定了数学公式，然后再要求用数学公式的法则来写程序。 语言是字符串的集合，所以语言就会有子集的概念，其实，我们也可以将人类语言中的一些子集用形式语法表达出来，从而实现自动化。比如语音售票机等等。 经典名句：“买一张济南到长沙的火车票”，和“我要独自一人乘着钢铁巨龙回到梦开始的地方、湘江之滨的湖南省会”，人类能理解意思相同，不过呢，售票机恐怕就不行了。 再谈“形式语言的文法”和“自动机”的关系任何一个语言的文法都有一个等价的自动机，反之亦然。也就是说：文法和自动机本质上就是同一个东西，或者说是同一个东西的不同数学形式（在前面已经提到过对同一客观存在的不同刻画）。 而刻画的事物，实际上就是形式语言。 形式语言和自动机本质上是一个东西的不同数学表示，因此，再很多需要区别的情况下，无论是使用“文法”、“语法”、还是“自动机”，都没有区别，其混合使用的时候我们更应理解它们指的是同一事物（形式语言）。 文法分类问题文法的分类是个需要专门花大量时间来讲述的事情，《计算理论》中由四分之一到三分之一的内容实际上实在讲述文法的分类，可见，这不是一个几句话就能说清楚的问题（文法分类的专业深度很深）。 词法是关于单词的构成方法，单词是程序语言中最简单的字符串，比如，用户取得变量名称，但是要将一个个单词连成更长的字符串，法则就会难度大很多，显然不单单是检查单词那么简单，这个时候得文法就叫做“句法”（在我们学习的课程中，习惯句法叫做语法） 教材的编写也符合从易到难的原则，第三章是词法，第四第五章是句法。 词法，难度低 句法，难度高 它们都是文法 但是，需要提醒的是：从形式语言的角度看，单词和句子本质上是一个东西，毫无区别（都是字符串），只是相对长短不同而已。 专门针对单词的自动机（文法）肯定是文法中最简单的一种，或者说是一个完整语言中的一部分，我们把这部分专门描述单词组成规则的部分叫做“词法”。 For example，C语言的单词拼写是否正确就是靠C语言的词法（自动机）来判定的，把源程序输入自动机，自动机将逐一检查单词，如果有错误就会报警，指出错误。如果全部正确，那就输入这些单词，以备后面使用。 当然，只检查单词拼写规范是远远不够的，所以C语言词法（自动机）仅仅是其中的一部分，还得有检测句法的（人为分类）如if else 这样的结构是否合法。 再说语言再次强调核心概念：语言是字符串的集合。 关于问题及其求解的思考，其实也跟“语言”有密切关系。 （下面基本上原封不动搬运徐老师的讲解） 首先给你一个论断：凡是能用字符串表达出来的问题就都是一个语言。很吃惊是吧？按照这个说法，世界上的问题就没有不是语言了（因为你总要用字符串的集合，即语言，把问题表述出来）。 确实是这样，有了“语言是字符串的集合”这个定义后，世界上的任何问题都是一种语言，对于任何问题的解决，本质上就是看这个问题（即语言）是否能够用数学公式（文法）表达出来，更专业的说法是，世界上所有的问题都是语言，问题是否可解等价于该语言是否可计算，“可计算”的基础就是这个问题（即语言）是否可以用形式文法表示出来，如果能用形式语法表示出来，也就等价于存在一个自动机，它可以接受这个问题，即解决这个问题。 比如，我要你计算一个题目，题目是这样出的：“请计算2+3=”，这个问题不就是个字符串吗，答案就是自动机（假设存在）输入问题字符串后的最终状态。 总结：世界上所有的问题都是语言 那么，把世界上所有的问题都归结为语言，这有什么意义呢？ 意义很大，要理解这个问题一定要系统学习《计算理论》才能知道。 举一个语言被广义化后的意义，这是我们计算机学科特别关心的意义。计算机学科的基本问题之一：什么问题是计算机可以解决的，大致等价的问题是：什么问题是计算机不能解决的 答案是：凡是能够用形式语法（自动机）表达的问题都是可以用计算机解决的，否则就是不可解的。 计算机不是万能的，有些问题（即语言）已经被证明是不能用形式文法表达的，对这些语言（即问题 ），你就不要试图用计算机去解决它们了。 如果理论上不可解，那就彻底不可解。理论上可解，现实中也不一定可解。用逻辑术语来表达，理论上可解是现实可解的必要条件，但不是充分条件。 语义分析和中间代码生成为什么需要语义分析诸如类型匹配等检查仅通过词法和语法是难以实现的，类型不匹配这种语义分析要扫描前后文字，这就是“语义分析”也叫作“上下文相关分析”的原因。 按照分治的思想，设计出中间代码，介于源代码和目标代码（汇编语言代码或者机器码）的一种代码方式。 中间代码形式举例逆波兰式 逆波兰表达式也叫做后缀表达式 要是中缀表达式复杂了，可能就不容易凭经验和概念很快写成等价的后缀式，中缀表达式转换为逆波兰式是可以用程序来完成的，这样，无论多么复杂的中缀表达式，机器都能迅速地转换为后缀式。具体的算法微信上很难写，你们先记住有这么个算法，上课时就有准备了。 三地址码形式 三地址码形式的主要特点是：一个等式中只能出现三个地址（变量）。 三地址码的具体写法又可以有三元式、四元式等等，这些形式中，一个表达式中只会出现三个地址。]]></content>
      <categories>
        <category>编程</category>
        <category>编译原理</category>
      </categories>
      <tags>
        <tag>编程</tag>
        <tag>编译原理</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[数学建模—美赛2019E题]]></title>
    <url>%2Fpost%2F4c60a529.html</url>
    <content type="text"><![CDATA[第一天上午定题目E题，环境相关 关键词：环境退化，环境成本，生态经济，适应性模型 下午开始着手搜集相关论文资料，包括但不限于，生态服务功能价值评估模型，水源森林生态资源衡量标准 建模思路，层次分析法，搜集大量数据获可能影响生态成本指标体系的层次结构 预想的指标： 评估指标 1 8 24 60 112层次分析法AHP 113 第二天整理下思路，层次分析法（照着ppt又回顾了下） 搜集数据？不需要细致工程的数据，但是要能衡量大中小型项目的污染标准。]]></content>
      <categories>
        <category>数学建模</category>
      </categories>
      <tags>
        <tag>编程</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[《無印良品的改革》读书笔记]]></title>
    <url>%2Fpost%2F4ab96b49.html</url>
    <content type="text"><![CDATA[序言 新“無印神话”的开端無印良品在日本的三大直营店：有乐盯店、京都的Platz店与打扮的难波店，其中有乐盯店是一家主要负责向社会大众宣传無印良品的店铺，几乎汇聚了全部经营的商品。 笔者采访一位职场女性，问是否经常来，得到的答复是这样的。 P005 “是的。这些日杂物品只是看看就令人心情愉快，平时换季的时候我也会来这里买衣服。实际上我也买优衣库的衣服，但是由于细节设计上没有特点，所以只是作为内搭穿在里面。与此相比，無印的没一件服装都很有风格，所以我很喜欢。在我还上高中的时候就经常来购物了，但不知从何时起，無印的商品和店铺失去了特色，觉得失望之后有段时间就没有来过了。但是，从三四年前無印又变的非常吸引人，因此我很高兴又来购物” 诞生既是荣耀，不知为何跌落，却又重回巅峰。这本书大概讲述的，就是讲这样一个世界品牌的故事。 理念、感性与科学的有机结合。在生活理念中看到科学量化的务实，却绝不会倒向向性价比等纯粹科学量化的指标，而是站立在理念这感性的一方。 第1章 無印良品的诞生及其迅速发展西友创立無印良品，本就是走在“品牌热的对立面”，一句“因为合理，所以便宜”广告，打破了人们购物的思维定势，从而引导人们重新审视品牌、价格、品质三者之间的关系。好称无品牌（No Brand）的無印良品，恰恰是宣传的这样一种不愿拘泥于民族品牌而诞生的New Brand。 广告海报上写着如下内容 P010 “不依赖品牌和包装来选择商品。这不仅与热情的生活方式相结合，也是一种重要的态度。” 無印良品品牌诞生的原动力：做质量不低于民族品牌但不为品牌做无用功（无谓支出）的优质产品。 無印良品的商品开发及生产的基本理念：选择优质原材料、不断改良生产工序、商品采用简约包装。 生活习气与生活美学的艰难选择二者实现的途径都要求回归生活本质，但是内涵却大不相同。 P027 “但是，要正确划分‘生活习气’和‘生活美学’之间的界线是极其苦难的。所以，商品上架前的最后检查都交给了富于感性的设计师团队。正是装也判断商品合适与否的顾问团队，在無印良品的发展过程中发挥了巨大的作用。” 無印良品从西友集团的独立木内任负责人时期，对無印良品不能掌握自己商品的众多核心信息（诸如完整的销售记录，开发成本等）而对品牌深感忧虑，在他的眼里，無印良品错过了成为子公司的最佳时节，现在却成为了西友的门面工程，这与品牌的初衷越走越远。 P013 “也就是说，‘西武集团式特色’一直将品牌形象摆在前面，这样一来，無印良品的经营就变成了‘看不见的经营’，这正是木内先生深感危机的原因。” 第2章 从一帆风顺到遭遇挫折从無印从西武集团独立出来，便掀起了一股“無印热”，开店邀请纷至沓来。1993年，無印良品首次开设了拥有大型卖场的直营店——無印良品LaLaPort（位于千叶县船桥市），1995年，無印良品在店铺正式公开售股，在获得充足资金后，無印良品又快马加鞭地开设了更多店铺，从100坪，300坪，500坪最后到1000坪。 然而新开店铺收益不及预期，往往是开设与关闭同时进行，而且随着店铺体量的扩张，为了填满店铺的货架商品种类数，不得不加快新产品的企划。这种“赶工”式的做法为后来的品牌危机埋下了伏笔。 扩大战略背后暗藏的“失控”以及顾客是否也远离了無印良品，两朵阴霾让这个品牌的发展道路的头上。 第3章 致使無印良品走向凋零的八大原因高层人事调整，由松井忠三接任有贺馨担任良品计划的社长。 一家家店铺的走访，一点点打开店长们的心结让他们敢于张口说话，在不懈的努力下，新社长总算对品牌危机的原因有了一个更清晰的认识。 P059 “对于良品计划业绩突然下滑的原因，一共可以总结出八条。当然，这些原因之间都是相互关联、相互影响的，正因为各个要素相互重叠，才给無印良品的业绩带来了严重的问题。” 原因1 成功带来的自满情绪 P059 “全体职工在经历無印良品的成功之后，在不知不觉中变得自满起来。” 前期发展一帆风顺，在泡沫经济中逆势增长，售股募集资金，上市过程也是顺风顺水，加之不断增开的大型直营店，无论怎样说都取得了一定的瞩目成果。上述的种种，居安思危精神的懈怠，笔者这么描述的。 P059 “此时，無印良品的员工认为不需要向其他公司学习，只要维持现状即可，由此，大家便失去了谦逊的态度和用心做事的优秀品质。与此相对，在这期间，埋头研究和学习的竞争对手，在不久之后便开始崭露头角。” 原因2 大企业通病的腐蚀内部结构过于僵化，纵向延申过长，不够扁平化带来的最直接的影响就是运行速度的相对迟缓，对市场的讯息反应不够快。 过去很多优秀的传统变成了“例行公事”，在無印良品里，最典型的就是对于开店事宜的讨论和决议。 P060 “在决定开设门店之时，公司应该重视对该场地条件最为熟知的开发部长的意见，随后才是经营的最高责任人社长做判断。但此时無印良品的实际情况是，几乎每个项目都采取董事会举手表决制，根据少数服从多数的原则决定是否开店。回忆当时的光景，松井说道：‘那时的状态就好比众愚政治一样。’” 原因3 忘记根本，只顾眼前采取的诸多应急措施，有违品牌设立之初的形象，为了应急而应急，却忽视了长远利益的考量。丢失了原则。比如服饰方面一改商品原本只有黑白和自然色的基调，加入其他颜色，这些无视“原则”的商品也被摆上了無印良品的货架。 原因4 品牌自身的弱化没有专攻品牌的建设，初期品牌优势很大，但随着市场竞争的增强，不再进行品牌理念的打磨最终结果将是被竞争对手淘汰。 P062 “但是时代在进步，消费者的信息收集能力也在飞速提高。同时，其他竞争对手的商品生产也提高到了可以与無印良品相抗衡的水准。在这种情况下，自己十多年前便再未打造锤炼的品牌也必然无法应对市场的巨大变化。” 品牌理念过于强烈对于继续锤炼品牌价值也提高了难度，负责打造品牌的组织结构变得很弱，無印良品内部根本就不存在这样的部门，同时拥有的个人理念都停留在大脑中，不能实现理念的广泛传播，或者作为企业资产实现共享。 P063 “总而言之，个人所拥有的知识和技术无法作为部门及企业的资产共享 ，更无法累积。因此，打造品牌的部门缺失为以后业绩下滑埋下了重大的祸根。” 原因5 店铺开发战略的失败店铺规模逐步增长最终过于庞大，而且太过急于开店。在扩充商品生产和完善供给体制之前，無印良品优先做的是扩大店铺面积。 这种模式在中小型规模（低于300坪）的店铺还未见问题，但是到达500坪、1000坪，涉及到产品的企划开发，就显得很吃力了。 开店规模不合适，新产品的企划开发难以跟随开店速度，新店开设“众愚政治”状态导致的开店不够谨慎，都划归为店铺开发战略的失败。 原因6 社长新旧更替良品计划的“创始人”，或者为这家公司注入灵魂的关键人物木内政雄社长回到西友总部工作，也时無印良品走下坡路不得不考虑的一个因素。 P066 “因为在创业阶段，由社长决定应该采取何种战略来经营公司是最为重要的。但是，过了创业期转入下一发展阶段时，领导者身上所必须具备的是能切实地实行经营战略地调动能力及使公司内部抱成一团地能力” 领导者需要有不同于常人地能力，无论公司出于什么时期。 P066 “从创始人手里接过管理权地领导行事必须谨慎，并且一定要有组织能力。为了使企业能够不断发展，建立完备的组织体系和创造相应的公司氛围是非常重要的。而無印良品在以上条件都未具备的时候，公司就脱离了创始人的指导和运作。” 原因7 对专于创造的初衷产生了摇摆“优秀的平均化”策略本是無印良品立足的根本，但是店面扩增，销售压力的增大，“卖掉就好了”思维也逐渐侵蚀了产品本身。而且，时代在变，年轻一代对著名设计者如数家珍的时候，無印良品的商品开始走向腐朽。 原因8 优衣库及大创等劲敌的出现外部原因——竞争对手的强势崛起。百元店对小物品市场的攻占，优衣库连续三个季度畅销夸张一点说是将所有同行企业（服装部门）推进了水深火热中，以及似鸟公司（NITORI）以家具为中心与無印良品相抗衡。 第4章 改革从服饰开始先是一扫堆积如山的存货，改变过量生产模式，提升整体企划更新的速度，维持上架货品的新鲜度以及正价销售率，同时海外店铺也进行存货清扫、“止血”。 “可视化、计算、行动”生产过程的信息不够公开透明，基本上仅存在少数人脑海中（营销总监）。 P085 “于是，在2002年，以三零商社的三位负责人为中心，無印良品开始实施经营改革工程。首先公司推行的是改善业务流程，以求能够让公司员工清晰地看到商品生产的过程。其次，召集良品计划女士服装、男士服装等各个领域地经理和营销总监以及总代理，为这些人创造探讨如何改善业务地机会。到了现在，这种习惯也被延续了下来，服饰杂货部每周都召开项目会议。” 单品的原价销售率、折扣销售以及剩余货品的相关数据都被一一记录下来，以这些数据为基础，無印良品提高了计划生产的精确度，从而进行了业务改善。 在销售情况可视化基础上，掌握商品畅销和滞销情况（無印良品SABC等级分析），结合订单业务，降低错失机会以及库存损失的风险。 改良后的商品周期，分类如图 名称 销售时间 备注 YF（全年使用款） 全年 在20世纪90年代占全部商品的一半 SB（季度基本款） 26周 每半年更新一次 ST（季节流行款） 10周左右 目前女装占80%以上 由过去無印良品认为的“一直摆放在卖场里就能获得安心”，颇为重视YF款到现在结合顾客对“卖场变得无趣”等建议做出的种种改变，质朴与安心中也要透露出改变、心意与诚意。 P092 “生活用品还可以因为顾客的喜好保持不变，但服装与此不同，如果一成不变就难免让人感到厌倦。另外，即使不改变基本款的服装，也应该在服装的方向感上做出一些变化以适应潮流。于是無印良品决定先设计出基本款服装，然后组织一个能够把握方向感的团队。” 与山本耀司公司合作，山本耀司公司发挥其创造力，把握产品方向感，而無印良品则将其理念注入其中，并负责其全程的销售。 P98 “以‘文化’和‘感性’为主题发展起来的良品计划，转而以数据及标准值，即‘数值’为基础构筑起最合适的生产、销售组织。” 第5章 商品生产方式的进步观察法的革新，从造方消费者的住宅来捕捉新的需求。全球·無印，与世界顶级设计师联合，匿名设计，将个人设计的概念融入企业的理念。从世界各地获取新的灵感，创造新产品。 重建总部与店铺的信赖关系，关注过去忽略的企划速率，以及开发效率的问题，整体提升店铺商品的质量。 第6章 实施新的开店暂略从岛村那里学来的，整理出规范化的“开店标准手册”。这样，经验的可视化、标准化，让新手也能按照“無印”式要求去勘察一块商圈是否适合开店。 开店空间的计算 P122 “统计出每个商圈的零售业销售额后，乘以無印良品的市场占有率，如此便可以算出無印良品在各都市商圈能够确保的市场占有额。然后用上述结果减去现有店铺的销售额。然后，用上述结果减去店铺现有销售额，就饿能够推算出来尚未确保的占有率，即开店空间。” 销售额空间 = \sum_i 店铺i销售额 \times 市场占有率 - 现有店铺销售额通过SABCD准则对开店水平进行评估，评估参数包括：市场、商业设施、店铺环境三大方面以及和周围竞争环境的综合考量。每一个大方面又细分成几个细致的指标，甚至人口的收入差距，标准楼梯高低都考虑在内。 無印良品从过去的实际成绩中，渐渐积累了这些选择开店地点的智慧。 开店讨论会与日后的主要战略以及对于新店开设的讨论会，听取了岛村集团时任社长的建议，不是喋喋不休的说明，而是针对开店手册（规范标准）进行必要的说明，然后销售总部部长和开发部长负责提出更加具体和更具实质性的问题。 公司进行了整体调整后，德江先生列举了三个今后开店的重点策略： 扩大店铺的面积。 但不是无限扩张，将200坪定义为标准型店铺，为了强化生活用品部，逐步发展250到300坪的卖场。 推进500坪店铺的开发 目的是增加家电、自行车等生活用品的摆放空间，用来和似鸟等品牌竞争。 挑战地方的小商业圈市场 建立起能够在小商业圈内运营的成本构造，定位可行的开店环境。 海外情况欧洲市场则是通过雇佣当地设计师重新设计符合当地需求的服装样式，几番更改后，海外服装设计步入正轨，扭曲为盈。通过加盟许可（Licenced Store）的方式扩大市场占有率。 中国市场，在与冒牌無印店的官司中获胜（MUJI当时出书时还未），已经说明了其在东亚这个广大市场的热度。 美国市场 P143 “2004年10月，無印良品在纽约现代艺术博物馆（The Museum of Mordern Art 简称 MOMA）的零售业部门——“设计门店”的53街开设了店铺。由于顾客的反映良好，無印良品的卖场面积也比当初开业时变得更宽敞了。” 第7章 大幅度压缩成本的“30%委员会” P147 “为了进一步提高竞争力，松井忠三社长确定下一步的改革重点就是削减销售管理费（销售费用和一般管理费用）2005年2月，松井在公司内设置了直属社长的‘30%委员会’（升级后的‘30%项目’）。” 30%委员会设定了多个改善项目，包含： 店铺内作业 物流 总部业务 直接贸易 店铺租金 保安与菜场管理 人工费 监察室对于不必要的重复流程进行简化，同时对同一监察人执行的监察项目进行复用，并重新审视检查项目的覆盖范围。 P150 “还有，顾客的预付款、返还款以及遗失的财务等，無印良品都会对此进行一一登记后存放在保险箱里。但是，把这些现金的进出归入检查项目、本身既不自然，也成了一种浪费。如果有顾客把财务遗失在店里，只需要立即送到附近的警察局就可以了。” 此外，还有重新合理规划店铺内店员的工作流程，减少不必要的行动浪费，减少标签等等措施。 無印良品的经费结构目标 P155 “各综合超市的销售管理费比例一般在27%左右（2006年度），连锁超市也有不少企业在24%左右。被良品计划视为加盟店运营榜样的岛村集团只有21.5%（2007年2月决算期期末实际数据），与之相比，良品计划的31.5%与其相差了10个百分点。” 这些百分比都是销售额的百分比，嗯这个是常识。 第8章 改变卖场员工的工作一份“店铺工作指南”只有16页，浓缩了开店中种种问题，给店长合理分配员工工作提供了可靠依据。 P172 “如此制定出来的‘店铺工作指南’，其内容网罗了员工从开始上班到关闭店铺、离开店铺为止的所有业务项目。为了便于临时工理解，指南内海使用了彩色图解，为了使员工更容易把握住要点，标题一般都使用简介、易于理解的表达方式，如某一章节的标题为‘什么是实现商品上架的高效化？’” 考虑到了临时工，而且都是通过简介、直观的方式展现出来，可以说整个店铺工作指南也是無印良品理念一脉相承的产出，即避免一切不必要的浪费。 比如，指南中规定收银台的工作主要由两类员工负责：一是主要负责收银的员工，二是辅助收银的员工。这两类员工分别为‘100%收银负责人’和‘50%收银负责人’。另外，指南中还配有插图解释员工如何根据顾客流动数量来应对收银工作。 根据SABCD等级划分的商品，也在指南中给~出了不同的整理拜访策略：S级和A级商品一天上架三次，整理两次，而C级和D级商品则各一次。 地方诞生的“畅销商品搜索队”精确到检查店长们是不是精确了解自己家店面的情况，销售量排名前五的商品，以及对畅销商品摆放位置的检查，摆放方式是否恰当等细节。这就是精确到每一个销售单位的最细致的监督。 P177 “另外，对于业绩特别低迷的店铺，田中等三人则每天早晚一次进行训练，并且训练时间长达半年之久。早上三人对店长作出指示后，当天晚上则再次来到此店确认其执行情况。由于三人每天都去视察，因此不仅对店长，而且对员工的工作状况都能细致地把握，最后还是看到了店铺的小小进步。每当发现进步的时候，田中等人就会表达出来，以此激发员工的工作积极性。” 也正是因为这种“简单粗暴”方式的有效（其有效性很大程度和日本地区人们的工作态度有关），所以总部发现这一方法后将其推向全国。 “一品入魂”、“天下一品”、“幸运单品”都属于营销手段，设定某一目标商品，然后设定能力上可以达到但是之前都为达到的，根据其覆盖范围可以分为店铺型、区域型的。 带着自信去推销，并依照成绩对其嘉奖，这种方法很有效果。 P184 “系统和人心之间有很多相反的地方，但如果将这些词置换成‘数值’和‘感性’的话，就能与良品计划所开创的平衡经营息息相关。只要公司具备完善的组织结构继续支持销售员工的积极性，那么相信卖场的意识改革就会不断顺利向前推进。” 尾章 良品计划的未来与今后的课题無印便利店的可能性根据市场分析，通过大型卖场销售無印的产品早晚会达到开店以及销售额的天花板，所以良品计划将目标瞄准了日客流量更大，分布小但覆盖更为全面的便利店。 P188 “而通过与便利店合作，無印良品便多了一个向消费者传达商品信息的据点。便利店和专卖店的顾客之间还是有很大区别的，特别是无印良品的顾客有‘执着’的一面，商品能够进入更多消费者的视野中是具有重大意义的。” 重启食品部门無印良品创业之初，食品部门曾作为基础部门之一，但是随后的发展却不及其他部门，一大原因是顾客构成的固化。 P195 “可能是由于过度锤炼商品的品质和感性，反而导致粉丝层受到限制。” 所以放低顾客的受众面，从而增大無印理念影响的消费者的范围，是进后無印良品的主要计划之一。 P196 “無印良品所应该追求的是商品所具有的吸引力，维持品牌形象，或者更高的目标。” 利用电视广告从过去基本不采用外媒的态度转化为每年举行一次企业主题的发布会，無印良品的转变是明显的，同时也是必须的（扩大顾客层）。 03年的“無印良品的未来”，04年的“無印良品之家”，05年的主题则是“茶室和無印良品”，具有强烈主题感的发布会也是迈入新发展时期后，無印良品不停向外界传递的信息：無印良品已经不只是简洁朴素。 收购家居公司IDEE作为無印良品分支业务的拓展，仍然贯彻“坚实的外表，可变化的内部，并且能够根据生活方式自由地改变房间地布置”的理念，但与之前無印良品自己的家具产品不同的是，IDEE风格更加现代一些， 无印良品官方也是这样定义的： IDÉE：为空间增光添彩、赋予趣味。 无印良品：以极度简约为魅力。 IDÉE+无印良品：二者相得益彰，为生活的各个场景提供令人喜悦的组合。]]></content>
      <categories>
        <category>阅读</category>
      </categories>
      <tags>
        <tag>阅读</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[请你振作下去]]></title>
    <url>%2Fpost%2F703409c5.html</url>
    <content type="text"><![CDATA[不要再这样下去了 请你自己振作起来]]></content>
      <categories>
        <category>随笔</category>
      </categories>
      <tags>
        <tag>随笔</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[算法与数据结构学习——数论专题]]></title>
    <url>%2Fpost%2F22b5b237.html</url>
    <content type="text"><![CDATA[数论专题复习前一部分来源于网络Wannafly Winter Camp冬令营 Day1 数论专题 Tangjz 整除理论约数（因数）和倍数的定义。 以及：整除关系的传递性，约数的倍数的线性组合仍为倍数，整除关系为偏序关系反对称推出相等。 模意义下容易忽略0的问题。 质数和合数的定义：对于$\forall n \in Z$，如果$\exists_{k \in Z, k \neq1, k \neq n} k \mid n$ 则$n$ 为合数，否则为质数 一些性质 若 $n \in Z^{+}$，则$min_{k \mid n} k \le \sqrt{n}$ 对于$\forall n \in Z^{+}$，存在唯一的指数分解$n = \prod_{i=1}^{n}p_i^{e_i}$，这里$p_i$互不相同 令$\pi(n)$表示不超过$n$的质数个数，有$\pi(n)=\Theta(\frac{n}{\ln{n}})$ 给出n可以知道比n小质数个数的渐近界 例：2017CCPC合肥网络赛人从S,S+1,S+2,S+3…S+n-作为1,2,3,4,5,6….n 贪心结论：n&gt;S的部分 都会按j=i座（这时候最优）。然后根据质数密度判断是否有两个质数，然后暴力匹配?? 继续整除理论 公约数对于 $x1 , x_2 , \cdots , x_n \in Z$ ，且 $\forall{i=1,2,\cdots,n} d\mid X_i$，则称 $d$ 为它们的公约数 当$x_1,x_2,\cdots,x_n$不全为零，存在最大的公约数，称为$\gcd(x_1,x_2,\cdots,x_n)$ 当$\gcd(x_1,x_2,\cdots,x_n) = 1$，称$x_1,x_2,\cdots,x_n$互质（互素），注意这里说是整体互质而不是说两两互质。是个大坑。 $\gcd(a,b) = \gcd(a,b-a) = \gcd(a,b \mod a)$ 欧几里得算法：辗转相除 时间复杂度分析：$O(\log a+ \log b)$ 公倍数同余理论不定方程之前有课件 有理逼近数论是整数方面的研究，有些地方将无理数用无穷级数+有理数表示。 数论函数使用迪利克雷卷积（暑假课程）进行推导]]></content>
      <categories>
        <category>编程</category>
        <category>数据结构与算法</category>
      </categories>
      <tags>
        <tag>编程</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[算法与数据结构学习——深入学习基础篇]]></title>
    <url>%2Fpost%2F7169c4ed.html</url>
    <content type="text"><![CDATA[关于数据的一些易混淆概念 数据：信息的载体，能够被计算机识别、存储、加工，包括整数、实数、字符串、图像、声音等 数据元素：数据的基本单位，也称结点、元素、顶点、记录。一个数据元素可由若干个数据项组成 数据项：是具有独立寒意的最小标识单元，也称字段、域、属性等 数据结构：指数据之间的相互关系，即组织形式，有逻辑结构（一般程序中出现的形式）和物理结构之分（内存中的连续存储形式）；逻辑结构又有线性（非空，仅由一个开始结点和一个终端结点，除首尾结点之外，所有节点均只有一个直接前区和一个直接后继，如一维数组、栈、队列、链表、串等）和非线性之分（一个结点可以有多个直接前区和多个直接后继，如多维数组、广义表、树、图等）]]></content>
      <categories>
        <category>编程</category>
        <category>数据结构与算法</category>
      </categories>
      <tags>
        <tag>编程</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[校园导航系统CampusNavigation（C++实现）]]></title>
    <url>%2Fpost%2Ff7b33ddd.html</url>
    <content type="text"><![CDATA[课程设计选题及要求选题6：校园导航系统设计一个校园导航系统，为学校来访者提供各种信息查询服务，方便查找学校主要单位、校园景点之间最短距离，并能及时对该图进行更新，地点信息包括名称、代号、相关介绍等，及两个地点之间有直接路径的距离 基本功能与技术要求 数据文件管理功能：创建新文件、打开文件、保存文件。 计算与统计功能，完成记录中相关数据的统计； 能够打开已存在的数据表文件，计算任意两个地点之间的最短路径的长度及途经地点。 提供来访者从出发地到目的地的路线统计，以图示界面输出。 记录管理功能：记录的管理采用链表、数组等实现。 输入／添加/插入记录，并保存到数据文件中。 查询、显示记录，根据用户要求按所给地点查询单位或景点信息，以及到地点的问路情况等。 修改记录：能够打开已存在的数据表文件，并对确定的任意记录进行修改，在修改过程中，应显示记录信息，给出确认提示，并对更新的记录信息进行文件保存。 删除记录：能够打开已存在的数据表文件，可以删除数据表中的任一记录，要求具备逻辑删除（具有恢复功能）和物理删除功能，并对新的数据表信息进行文件保存。 设计思路 整体模式以及主要涉及的模块 整体设计采用MVC模式，及数据的储存处理与表现分离。使用QT框架提供基础的图形界面操作，整体分为三个模块，CNView前端部分负责数据的显示，CNModel数据的储存预处理。 模块功能的划分以及类的初步设计 CNView 前端部分 主要结合QT框架，界面展示，地点展示，路径展示，以及提供对应的GUI工具实现文本的录入 CNModel 后端部分 功能设计和模块划分本次课程设计额 C++父类指针操作子类新函数的方式父类指针无法直接调用子类的新函数，需要转换为子类的指针后方可调用。 C++编译器在编译的时候是做静态类型分析。也就是说，你的父类指针是否真的指向一个子类类型，编译器并不会做这个假设。所以你用父类指针去调用子类的函数是无法被识别的。这里提供一种不安全和一种安全的转换方式可以实现该功能： 假设我们有父类和子类的定义如下： 12345678910111213141516171819202122class Base&#123;public: void virtual Func() &#123; cout &lt;&lt; "Base\n"; &#125;&#125;; class Derived : public Base&#123;public: void Func() &#123; cout &lt;&lt; "Derived\n"; &#125; void NewFunc() &#123; cout &lt;&lt; "New func\n"; &#125;&#125;; 强制转换（不安全） 12345Base* b = new Derived();b-&gt;Func();// 不安全的转换Derived* d = (Derived*)b;d-&gt;NewFunc(); 这里之所以说不安全是因为转换的时候无法得知是否转换成功。编译器强制把d当成Derived类型去使用。比如说b本来是真的指向Base而不是Derived类型那么强制转换后调用Derived的NewFunc可能会导致程序崩溃。 2.动态转换，dynamic_cast（安全） 12345678Base* b = new Derived();b-&gt;Func(); // 安全转换 Derived* d = dynamic_cast&lt;Derived*&gt;(b); if (d != NULL)&#123; d-&gt;NewFunc();&#125; dynamic_cast是在运行时去做转换而非编译时，所以它可以给出是否转换成功的信息。如果转换不成功则返回NULL。所以可以判断转换结果是否为NULL来决定是否能使用该指针不会导致程序崩溃 第一天进度记录 完成后端1/2（除去文件读写） string index放着先不实现，所有都先按照鼠标事件和xy坐标来写 明早补充边的增加和删减 注意边增添的时候算直线距离 普通点的增加和删减 第X天进度记录就是说如果槽的命名是这样的话： 1void on_&lt;widget name&gt;_&lt;signal name&gt;(&lt;signal parameters&gt;); 就会自动将widget name中的信号signal name和这个槽void on_&lt;widget name&gt;_&lt;signal name&gt;(&lt;signal parameters&gt;)链接起来。 这是QT不需要connect语句就可以自动链接信号和槽的机制！ 绘图相关当发生一下情况时会产生绘制事件并调用paintEvent()函数: 在窗口部件第一次显示时，系统会自动产生一个绘图事件，从而强制绘制这个窗口部件。 当重新调整窗口部件的大小时，系统也会产生一个绘制事件。 当窗口部件被其他窗口部件遮挡，然后又再次显示出来的时候，就会对那些隐藏的区域产生一个绘制事件。 同时可以调用QWidget::update()或者QWidget::repaint()来强制产生一个绘制事件。二者的区别是: repaint()函数会强制产生一个即时的重绘事件,而update()函数只是在Qt下一次处理事件时才调用一次绘制事件。 如果多次调用update(),Qt会把连续多次的绘制事件压缩成一个单一的绘制事件，这样可避免闪烁现象。 使用repaint()]]></content>
      <categories>
        <category>编程</category>
      </categories>
      <tags>
        <tag>编程,C++,课程设计</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Git学习——《精通Git》笔记（一）]]></title>
    <url>%2Fpost%2Fb8ca3dfa.html</url>
    <content type="text"><![CDATA[关于Git关于版本控制理解版本控制：我们需要他的原因就是我们希望能够记录对一系列文档操作的历史，便于查看修改记录，历史版本，甚至是在出错或者其他情况回滚到过去版本。 P1 “使用版本控制系统，你可以将文件或者整个项目恢复到先前的状态，还可以比对掌握文件随时间的吧ing呢个，查看什么人最后做出的更改。” 大型项目需要多人共同完成时，版本控制又提供了很可靠的多人协作的方式，每个人对项目的操作都可以作为一个版本记录其中，而且不同版本的提交留下的历史也为日后出现问题的时候找到对应负责人提供了可信途径（笑）。 本地版本控制系统上古时代的VCS(Version Control System 学点英文)，开始计算机通信还没像现在互联网这种程度时候，本低版本控制也是一个必备需求。RCS，一个常用VCS工具，Mac OS X操作系统中，rcs命令会使RCS在磁盘上以一种特殊的格式保存补丁集（patch set ， 即记录文件之间的差异）通过叠加补丁来恢复到某个状态。 集中式版本控制系统当多人开发协作流行起来，本低版本控制不能满足需求，集中式版本控制系统（Centralized Version Control System, CVCS）应运而生 特点：依赖网络、依赖中心仓库、集中管理、单点故障难以处理 分布式版本控制系统为了解决集中式的依赖在线和中心仓库交互、单点故障等问题，分布式版本控制系统（Distributed Version Control System, DVCS）被开发出来。 特点：无严格意义上的中心仓库，完整镜像（完整备份）， Git简史Git产生于Linux内核这个超大规模开源软件项目的维护过程中，开始Linux内核开发者社区使用的是BitKeeper专有分布式版本控制系统，后来关系破裂B收回软件的使用权，所以Linux开发社区（尤其是Linux之父林纳斯）汲取了原软件的经验和不足，开发出了自己的控制系统，最初目标是实现： 速度快 设计简洁 对于非线性开发有力支持（大数量分支） 完全的分布式设计 能够有效处理像Linux内核这种超大型项目（速度及数据量） Git特性介绍介绍Git对比其他版本控制系统的差异，以及一些Git独特的地方。 快照而非差异Git最大不同在于对待数据的方式，很多版本控制系统（CVS、Subversion、Perforce）记录的是一些文件和在文件上随时间做的改动（记录变化量）。Git记录的是快照，抓取快照后存储一个指向该快照的引用，变动的记录变动后的文件信息，不变动不记录，留下原先的链接，整体宏观上是非线性的，数据变动在快照到快照这个快照流中体现。 几乎所有操作都在本地执行在本地有本地仓库，自己对文件修改并记录版本时，一般无需从网络和其他计算机获取信息，无需考虑网络延时的开销。只有需要通过Web交互信息（比如上传至代码托管平台，对比与远程仓库差异）或者和他人写作的时候，在修改完成后再进行网络传输（这时本地已经完成了文件的修改，本地仓已经为最新版本） Git的完整性关于完整性，Git存储前会进行校验和计算，校验使用SHA-1散列（嗯密码学相关），改一点散列值都会产生很大变化~。 P6 “因为用途及广，你在Git中到处都会看到这种散列值。实际上，Git并不是通过文件名在数据库中存储信息，而是通过信息的散列值。”]]></content>
      <categories>
        <category>编程</category>
        <category>Git</category>
      </categories>
      <tags>
        <tag>Git</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[VSCode——Git配置及终端替换]]></title>
    <url>%2Fpost%2Feae0b80e.html</url>
    <content type="text"><![CDATA[Git安装如果本机还没有安装过Git，那么首先从官网上下载合适的版本（Mac OS/Windows/Linux） 官方地址为：https://git-scm.com/download/win 下载完以后双击进行安装，勾选使用Git Bash以及使用VSCode作为默认编辑器（这个看个人喜好）。 安装成功界面 检查Git命令行输入 git --version 得到结果 git version 2.20.1.windows.1 证明Git安装正常，若出现异常，无对应函数，确定一下环境变量是否配置正常 VSCode中Git配置 Git 路径 Ctrl+,打开Setting界面，搜索Git.path，编辑到User Setting中（本机都使用所以可以不必每次都添加到Workspace Setting处设计），值为本机安装的Git文件目录里git.exe的路径。（注意Windows修改’\‘为’\\‘） Git Bash替换原有终端 鉴于不少人习惯通过Git Bash命令行进行操作，我们利用VSCode提供的内置终端功能，将终端替换为Git Bash，再也不用担心一堆Git窗口来回切了，还可以配合Ctrl+\等快捷键充分发挥终端小窗口并行工作的潜力。 Ctrl+,打开Setting界面，搜索git.integrated.shell.window,编辑对应框，路径改为对应的Bash.exe路径（我的机器中是D:\Program Files\Git\bin\bash.exe） Thanks to微软爸爸，现在我们就可以在VSCode里优雅的使用Git啦。 关于Git的教程，后续读完《精通Git》会补一篇。链接在这里。]]></content>
      <categories>
        <category>编程</category>
        <category>生产力工具</category>
      </categories>
      <tags>
        <tag>VSCode,Git,生产力工具,,</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[VSCode——通用插件推荐与介绍]]></title>
    <url>%2Fpost%2Facf6b02e.html</url>
    <content type="text"><![CDATA[VSCode常用插件一览这篇文章写了一些目前我已经下载并且使用体验良好的插件，欢迎大家联系我推荐其他插件吼。 插件主要从通用工具与编写支持、界面/美化、语言支持及相关工具三个类别来进行介绍。 通用工具与编写支持 Chinese (Simplified) Language Pack for Visual Studio Code 功能：此中文（简体）语言包为 VS Code 提供本地化界面。 使用方法：安装后，在 locale.json 中添加 “locale”: “zh-cn”，即可载入中文（简体）语言包。要修改 locale.json，你可以同时按下 Ctrl+Shift+P 打开命令面板，之后输入 “config” 筛选可用命令列表，最后选择配置语言命令。请参阅文档并获取更多信息。 vscode-faker 功能：提供编造数据 使用方法：安装后，Ctrl+Shift+P然后输入Faker选择对应的数据进行构造 VS Live Share 功能：与他人实时同步编辑代码 使用方法：安装后根据说明文档来吧，博主目前还用不到，自己稍微尝试了一下，很有趣。 Docker 功能：语法高亮，命令以及拼写检查 使用方法：参见说明文档，博主目前还未接触Docker，只听闻这个东西 界面/图标美化 vscode-icons 功能：提供多彩图标 使用方法：安装后，Ctrl+Shift+P然后输入Icons选择对应的命令。（博主觉得太花哨，还是选择Seti的VScode图标） Studio Icons 功能：提供Visual Studio风格图标 使用方法：安装后，在左下角小齿轮选择Icon Theme找到Visual Studio Code风格的两个Icon配色方案。 Markdown相关 markdownlint 功能：提供Markdown规范以及风格的检查 使用方法：安装后，在md文件编写的时候会生效产生markdownlint的warning信息，可以在Setting里面选择错误信息的显示的设置。 Markdown All in One 功能：提供Markdown书写习惯的快捷键。 使用方法：安装后，md文件编写的时候生效，比如Ctrl+B加粗，以及自动对标号顺延。 语言支持及相关工具 C++相关 功能：提供了C++编译测试的支持，以及C++书写检查，代码高亮，和联想输入。 使用方法：安装后参照说明文档。 Java相关 功能：提供了Java编译测试的支持，以及Java书写规范检查，代码高亮，联想输入 使用方法：安装后参照说明文档。 Maven 功能：提供了Maven Projects的管理，编译支持。 使用方法：安装后关联Maven，Ctrl+Shift+P 然后输入Maven可以使用相关指令。 Python 功能：提供了Python编译测试的支持 使用方法：参考说明文档]]></content>
      <categories>
        <category>编程</category>
        <category>生产力工具</category>
      </categories>
      <tags>
        <tag>VScode</tag>
        <tag>test</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[VSCode——基础配置]]></title>
    <url>%2Fpost%2F9305c5f5.html</url>
    <content type="text"><![CDATA[微软良心之作，高颜值加可拓展性。目前学生党一枚，一边学习着算法一遍又要写写前端以及blog的md，所以就入了VSCode的坑。 对于我本人，最舒服的莫过于继承了Terminal，以后再也不用跑到编辑器或者IDE外面鼠标右键或者Win+R开终端了。嗯看好微软（买Surface的动力++），另外可以配置好Python，Java和C++环境可以完成一个编辑器上写代码+调试+写博客总结的一系列操作，日后有望成为主要生产力工具。 后面会着手写一系列关于VSCode基本配置操作以及在各种语言环境，以及插件所实现的VSCode+操作。 VSCode下载与安装首先从官网下载 安装就不断下一步就行 VSCode界面顺利安装完成，打开VScode以后会出现下图类似的界面（左边side bar上有一些图标是插件提供的，插件功能一会儿会提及）。大体上应该是这个Welcome界面 VSCode用户设置 进入Setting界面进行设置 Ctrl+, 打开Setting界面出现如下 用户设置界面可以根据自己的需要搜索祥光的配置项并修改。后续很多插件的DIY配置都需要在这里搜索到匹配的项然后进行Edit in setting.json后编辑。 需要说明的是，左边是默认的用户设置，从左边选择条目加入右边。右边有两个Setting，分别为用户的使用Setting（公用），和当前工作环境的Setting。当编辑当前工作环境Setting的时候VSCode会自动在工作区文件夹建立一个名为.vscode的文件夹内部包含setting.json。 改变编辑器外观（Color Theme） Ctrl+K,Ctrl+T 组合按键，或者Ctrl+Shift+P 后输入Color Theme进入选择菜单，VS还很贴心的分出了浅色Theme和深色Theme。博主自己比较喜欢深色就选择了一款深色主题，大家用自己习惯的就好咯。 VSCode操作命令博主常用的快捷键下面列了一些（我）常用的快捷键，应付基本需求基本上是没问题了 Ctrl+N 新建一个文件（上面会显示Untitle.txt） Ctrl+Shift+N 新建一个VSCode编辑器窗口 Ctrl+\ 右侧切出一个新的VScode编辑器 Ctrl+Tab 切换打开的文件 Ctrl+P 快速打开 Quick Open Ctrl+Shift+P 显示命令面板 Ctrl+Shift+Y 显示Debug结果 Ctrl+(ESC下面那个) 显示终端Terminal Ctrl+Shift+(ESC下面那个) 新增一个Terminal Terminal+Ctrl+\ 右侧切出一个Terminal终端 Ctrl+, 打开Setting界面 Ctrl+Shift+M 打开PROBLEMS出错信息界面（调试或者格式化的时候常用） Alt+Shif+F 很多插件提供的全页面按对应语言格式化 快捷键中英文对照表思否上有前辈贴出了基本上全部的VSCode快捷键中英文对照表 原文链接 常用 General 按 Press 功能 Function Ctrl + Shift + P，F1 显示命令面板 Show Command Palette Ctrl + P 快速打开 Quick Open Ctrl + Shift + N 新窗口/实例 New window/instance Ctrl + Shift + W 关闭窗口/实例 Close window/instance 基础编辑 Basic editing 按 Press 功能 Function Ctrl+X 剪切行（空选定） Cut line (empty selection) Ctrl+C 复制行（空选定）Copy line (empty selection) Alt+ ↑ / ↓ 向上/向下移动行 Move line up/down Shift+Alt + ↓ / ↑ 向上/向下复制行 Copy line up/down Ctrl+Shift+K 删除行 Delete line Ctrl+Enter 在下面插入行 Insert line below Ctrl+Shift+Enter 在上面插入行 Insert line above Ctrl+Shift+\ 跳到匹配的括号 Jump to matching bracket Ctrl+] / [ 缩进/缩进行 Indent/outdent line Home 转到行首 Go to beginning of line End 转到行尾 Go to end of line Ctrl+Home 转到文件开头 Go to beginning of file Ctrl+End 转到文件末尾 Go to end of file Ctrl+↑ / ↓ 向上/向下滚动行 Scroll line up/down Alt+PgUp / PgDown 向上/向下滚动页面 Scroll page up/down Ctrl+Shift+[ 折叠（折叠）区域 Fold (collapse) region Ctrl+Shift+] 展开（未折叠）区域 Unfold (uncollapse) region Ctrl+K Ctrl+[ 折叠（未折叠）所有子区域 Fold (collapse) all subregions Ctrl+K Ctrl+] 展开（未折叠）所有子区域 Unfold (uncollapse) all subregions Ctrl+K Ctrl+0 折叠（折叠）所有区域 Fold (collapse) all regions Ctrl+K Ctrl+J 展开（未折叠）所有区域 Unfold (uncollapse) all regions Ctrl+K Ctrl+C 添加行注释 Add line comment Ctrl+K Ctrl+U 删除行注释 Remove line comment Ctrl+/ 切换行注释 Toggle line comment Shift+Alt+A 切换块注释 Toggle block comment Alt+Z 切换换行 Toggle word wrap 导航 Navigation 按 Press 功能 Function Ctrl + T 显示所有符号 Show all Symbols Ctrl + G 转到行… Go to Line… Ctrl + P 转到文件… Go to File… Ctrl + Shift + O 转到符号… Go to Symbol… Ctrl + Shift + M 显示问题面板 Show Problems panel F8 转到下一个错误或警告 Go to next error or warning Shift + F8 转到上一个错误或警告 Go to previous error or warning Ctrl + Shift + Tab 导航编辑器组历史记录 Navigate editor group history Alt + ←/→ 返回/前进 Go back / forward Ctrl + M 切换选项卡移动焦点 Toggle Tab moves focus 搜索和替换 Search and replace 按 Press 功能 Function Ctrl + F 查找 Find Ctrl + H 替换 Replace F3 / Shift + F3 查找下一个/上一个 Find next/previous Alt + Enter 选择查找匹配的所有出现 Select all occurences of Find match Ctrl + D 将选择添加到下一个查找匹配 Add selection to next Find match Ctrl + K Ctrl + D 将最后一个选择移至下一个查找匹配项 Move last selection to next Find match Alt + C / R / W 切换区分大小写/正则表达式/整个词 Toggle case-sensitive / regex / whole word 多光标和选择 Multi-cursor and selection 按 Press 功能 Function Alt +单击 插入光标 Insert cursor Ctrl + Alt +↑/↓ 在上/下插入光标 Insert cursor above / below Ctrl + U 撤消上一个光标操作 Undo last cursor operation Shift + Alt + I 在选定的每一行的末尾插入光标 Insert cursor at end of each line selected Ctrl + I 选择当前行 Select current line Ctrl + Shift + L 选择当前选择的所有出现 Select all occurrences of current selection Ctrl + F2 选择当前字的所有出现 Select all occurrences of current word Shift + Alt + → 展开选择 Expand selection Shift + Alt + ← 缩小选择 Shrink selection Shift + Alt + （拖动鼠标） 列（框）选择 Column (box) selection Ctrl + Shift + Alt +（箭头键） 列（框）选择 Column (box) selection Ctrl + Shift + Alt + PgUp / PgDown 列（框）选择页上/下 Column (box) selection page up/down 丰富的语言编辑 Rich languages editing 按 Press 功能 Function Ctrl + 空格 触发建议 Trigger suggestion Ctrl + Shift + Space 触发器参数提示 Trigger parameter hints Tab Emmet 展开缩写 Emmet expand abbreviation Shift + Alt + F 格式化文档 Format document Ctrl + K Ctrl + F 格式选定区域 Format selection F12 转到定义 Go to Definition Alt + F12 Peek定义 Peek Definition Ctrl + K F12 打开定义到边 Open Definition to the side Ctrl + . 快速解决 Quick Fix Shift + F12 显示引用 Show References F2 重命名符号 Rename Symbol Ctrl + K Ctrl + X 修剪尾随空格 Trim trailing whitespace Ctrl + K M 更改文件语言 Change file language 编辑器管理 Editor management 按 Press 功能 Function Ctrl+F4, Ctrl+W 关闭编辑器 Close editor Ctrl+K F 关闭文件夹 Close folder Ctrl+\ 拆分编辑器 Split editor Ctrl+ 1 / 2 / 3 聚焦到第1，第2或第3编辑器组 Focus into 1st, 2nd or 3rd editor group Ctrl+K Ctrl+ ←/→ 聚焦到上一个/下一个编辑器组 Focus into previous/next editor group Ctrl+Shift+PgUp / PgDown 向左/向右移动编辑器 Move editor left/right Ctrl+K ← / → 移动活动编辑器组 Move active editor group 文件管理 File management 按 Press 功能 Function Ctrl+N 新文件 New File Ctrl+O 打开文件… Open File… Ctrl+S 保存 Save Ctrl+Shift+S 另存为… Save As… Ctrl+K S 全部保存 Save All Ctrl+F4 关闭 Close Ctrl+K Ctrl+W 关闭所有 Close All Ctrl+Shift+T 重新打开关闭的编辑器 Reopen closed editor Ctrl+K 输入保持打开 Enter Keep Open Ctrl+Tab 打开下一个 Open next Ctrl+Shift+Tab 打开上一个 Open previous Ctrl+K P 复制活动文件的路径 Copy path of active file Ctrl+K R 显示资源管理器中的活动文件 Reveal active file in Explorer Ctrl+K O 显示新窗口/实例中的活动文件 Show active file in new window/instance 显示 Display 按 Press 功能 Function F11 切换全屏 Toggle full screen Shift+Alt+1 切换编辑器布局 Toggle editor layout Ctrl+ = / - 放大/缩小 Zoom in/out Ctrl+B 切换侧栏可见性 Toggle Sidebar visibility Ctrl+Shift+E 显示浏览器/切换焦点 Show Explorer / Toggle focus Ctrl+Shift+F 显示搜索 Show Search Ctrl+Shift+G 显示Git Show Git Ctrl+Shift+D 显示调试 Show Debug Ctrl+Shift+X 显示扩展 Show Extensions Ctrl+Shift+H 替换文件 Replace in files Ctrl+Shift+J 切换搜索详细信息 Toggle Search details Ctrl+Shift+C 打开新命令提示符/终端 Open new command prompt/terminal Ctrl+Shift+U 显示输出面板 Show Output panel Ctrl+Shift+V 切换Markdown预览 Toggle Markdown preview Ctrl+K V 从旁边打开Markdown预览 Open Markdown preview to the side 调试 Debug 按 Press 功能 Function F9 切换断点 Toggle breakpoint F5 开始/继续 Start/Continue Shift+F5 停止 Stop F11 / Shift+F11 下一步/上一步 Step into/out F10 跳过 Step over Ctrl+K Ctrl+I 显示悬停 Show hover 集成终端 Integrated terminal 按 Press 功能 Function Ctrl+` 显示集成终端 Show integrated terminal Ctrl+Shift+` 创建新终端 Create new terminal Ctrl+Shift+C 复制选定 Copy selection Ctrl+Shift+V 粘贴到活动端子 Paste into active terminal Ctrl+↑ / ↓ 向上/向下滚动 Scroll up/down Shift+PgUp / PgDown 向上/向下滚动页面 Scroll page up/down Ctrl+Home / End 滚动到顶部/底部 Scroll to top/bottom]]></content>
      <categories>
        <category>编程</category>
        <category>生产力工具</category>
      </categories>
      <tags>
        <tag>VScode</tag>
        <tag>test</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[金融学辅修——金融学笔记（十）]]></title>
    <url>%2Fpost%2F380486cb.html</url>
    <content type="text"><![CDATA[老师提供的习题册，15-16版本。 考试时间，19周周末，问一下课代表确定时间 债券种类国内债券 国际债券氛围外国债券和欧洲债券 欧洲债券分为公墓债券和私募债券 债券发行与交易 三种方式：溢价发行、平价发行、折价发行 直接债券和无息债券 几种特殊债券： 武士债券、扬基债券、熊猫债券 政府债券、金融债券、企业债券 可转换公司债券 是一种可以在特定时间，按特定条件转换为普通股股票的特殊公司债券，它兼有债券和股票的特征。 具有以下条件 债券性，有规定的利率和期限。 股权性，可转换债券为股票后，债权人变为公司的股东， 可转换性， 可转换性， 可氛围进内和境外可抓换债券。 债券的发行与流通 债券发行市场 发行合同书说明shn 证券投资基金的基本特征基本特征基金作为一种现代投资工具，三个特征 集合投资，基金是这样一种投资方式；零散基金汇集， 谋取资产的增值。 分散风险。科学的投资组合降低风险，一定的资金实力，基金帮助中小投资者解决了资金实力不足的问题。 专业理财，基金实行专家管理制度，运用先进的技术手段分析，尽可能地避免投资决策的失误，提高投资的正确率。 证券投资基金的类型按组织形式分：公司型投资基金（股份制投资公司），契约型投资基金（信托型投资基金） 主要区别 按基金可否赎回分：不可赎回（封闭式基金），可赎回（开放式基金） 按投资对象分为]]></content>
      <categories>
        <category>金融</category>
        <category>金融学</category>
      </categories>
      <tags>
        <tag>课堂笔记</tag>
        <tag>辅修</tag>
        <tag>金融学</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[金融学辅修——微观经济学笔记（六）]]></title>
    <url>%2Fpost%2F62cb42be.html</url>
    <content type="text"><![CDATA[第八章 垄断竞争市场垄断竞争市场的特点完全竞争和完全垄断的市场模式是两个极端的市场类型，它们在现实经济活动中都极其罕见。 垄断竞争的性质和特这个 市场上买卖双方人数较多； 一个生产集团企业数量非常多，每个厂商都认为自己的行为不会引起竞争队首的注意和反应，因而也不会受到 竞争对手的任何影响。 各厂商生产的产品有差别 这些产品都是非常接近的替代品，较强替代性但不可完全替代。 差别越大，垄断越 厂商进出比较容易； 厂商是市场价格的影响者 垄断竞争厂商的需求曲线 基本假设 生产集团内所有厂商都具有i昂同的成本曲线和需求曲线，可以以代表性厂商进行分析。 特征：需求曲线向右下方倾斜并且比较平坦（弹性比较大） 特征：两种需求曲线d和D 关于需求曲线d 在垄断竞争生产集团某个厂商改变产品价格，而其他厂商的产品价格都保持不变时。 该厂商的产品价格和销售量之间的关系 厂商主观摄像的需求曲线——自需求曲线 关于需求曲线D 在垄断竞争生产集团某个厂商改变产品价格，而其他厂商的产品价格发生相同变化时。 该厂商的产品价格和销售量之间的关系 符合客观规律的市场上需求曲线——比例需求曲线 d和D的关系 垄断竞争厂商的短期均衡 顺势均衡 垄断竞争厂商利润最大化行为 垄断竞争厂商面临向右下倾斜但比较完全垄断厂商平坦的需求曲线。 按MR=MC确定产量（比例需求曲线D） 垄断竞争厂商短期可能获得超额利润，无超额利润或亏损 但在长期无嫦娥利润（超额利润引入新厂商，总供给增加，右下方移动），且产量水平在AC最低点左边。 P 不同市场的比较 斯威齐模型 两个基本假设： 一个寡头价格提升的时候，生于寡头不变化，提价寡头销售量减少 一个寡头价格降低的时候，其他寡头为了防止自己的市场份额缩水，所以跟着降低价格。 贝特朗模型 概述 由法国数学家、经济学家贝特朗1883年提出，又称价格竞争的古诺模型 价格竞争：厂商之间竞争围绕价格展开，以价格为决策变化量 假设: 厂商定价时候， 推理： 每个厂商都有动力降价直至边际成本（为了防止自己的销售量下降） 价格等于边际成本时，每个厂商都零利润 会不会所有厂商都将价格设定为高于边际成本？不会，不稳定，不符合最优决策。 均衡含义： 价格战必定使每家企业按p=边际成本的原则来经营，长期看低成本挤走高成本 同质产品竞争必然导致价格降低至边际成本。 价格领导模型 概述： 行业中一个或极少数几个大厂商变动价格，其他厂商随之跟进。 晴雨表型：价格领导者反映整个行业成本和需求的变化 支配型： 支配型领导模型：主导厂商考虑其他厂商的产量怎样取决于它定的价格，次要厂商像完全竞争市场那样行为，价格当作给定的，根据此安排生产。 价格接收者优先考虑，供给曲线和成本曲线的关系。 卡特尔卡特尔的一般表达式： 卡特尔的主要任务 规定统一价格: 运用MR=MC的原则确定整个卡特尔组织的产量 比较：等边际原理 卡特尔的不稳定性： 卡特尔成员有违背协议或背离默契的动机 监督上的困难与惩罚手段的缺乏 卡特尔成员违约是因为其需求曲线 博弈论的概念和不同类型的博弈推理过程 博弈论：又称对策论，是描述、分析多人对策行为的理论。经济学中应用广泛主要用来解释寡头之间的。 支付矩阵与占优策略均衡 占优策略 无论其他参与者采取什么策略，某参与者都存在唯一的最优策略选择，这一最优策略就是他的占优策略。 纳什均衡 相对不变占优策略一定是纳什均衡，但纳什均衡不一定是占优策略 囚徒困境 算是一种纳什均衡，也是占优策略。 囚徒困境说明了维持合作的困难。 重复博弈 重复博弈——动态博弈的一种特殊情况 动态博弈是一种反复进行的博弈 在重复博弈中，同一个博弈被重复多次 不同市场经济效率的比较（容易出论述题） 经济效率是指利用经济资源的有效性 高的经济效率表示对资源的充分利用 不同市场的价格和产量 表格 长期和短期超额利润的问题，切线 不同市场的经济效率判断标准 判断标准：P=MC 边际社会价值=边际社会成本 垄断市场与技术进步两种观点 阻碍技术进步：利润的长期性导致缺乏动力 促进技术进部：有足够的资金进行大规模的技术研发，技术研发有利于继续保持垄断地位。]]></content>
      <categories>
        <category>金融</category>
        <category>微观经济学</category>
      </categories>
      <tags>
        <tag>课堂笔记</tag>
        <tag>辅修</tag>
        <tag>微观经济学</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[金融学辅修——微观经济学笔记（五）]]></title>
    <url>%2Fpost%2F7c50967.html</url>
    <content type="text"><![CDATA[价格歧视不是所有的价格差别？都是价格歧视 价格歧视行之有效的条件 必须在完全垄断的市场条件下，才能实现价格歧视，卖者可以控制价格 不同的消费群体或不同的销售市场是互相隔离的 这样就避免了中间商 价格歧视的类型 一级价格歧视 一级价格歧视也叫完全价格歧视，是指厂商对每一单位产品都按消费者愿意支付的最高价格出售，每一单位产品的销售价格都不一样，不同消费者所获得的价格是不同的。 结论：价格歧视源于对消费者剩余的掠夺 问题：为什么难以实行 回答： 消费者很多 难以估计不同消费者的保留价格或者最高原支付价格。 二级价格歧视 二级价格歧视指不同单元的产品以不同的价格出售，而购买同一数量的不同消费者都付统一价格。消费优惠，对于 相同消费的消费者其购买数量相同。 三级价格歧视 三级价格歧视同一产品和服务在不同购买对象或不同时间不同市场上收取不同加个。 三级价格歧视是价格歧视最常见的形式 eg：富人区和穷人区，国内市场和国外市场，给学生和老年人的折扣。 实现市场分割的条件： 垄断者能够把不同市场或市场的各个部分有效分割 均衡条件：利润函数对Q1，Q2求偏导数，一阶导数等于0，可得边际成本MC=MR1=MR2 三级价格歧视与需求弹性：需求弹性较大的定较低价格，需求弹性较小的定高价格。弹性相同，收取的加个就是一致的。 针对不同市场应该如何定价。 其他形式的加个策略 二部定价 垄断厂商要求消费者先付费以获得商品的购买权，然后再要求为每一单位该商品支付额外的费用。 捆绑销售 捆绑销售：捆绑销售是指厂商要求客户购买某种商品的同时也不许购买他的另一种产品。 ？捆绑系数 自然垄断和政府管制 由来： FC大但是VC小的行业，一个厂商的生产能力即可满足全部市场的需求，若有多个企业经营，造成资源浪费 特点： 存在规模报酬递增，所以AC曲线呈现下降状态 高价格Pm，高利润、低产出Qm、低效率 低效率的解决：政府管制 管制定价： 垄断厂商的产量决定和效率评价]]></content>
      <categories>
        <category>金融</category>
        <category>微观经济学</category>
      </categories>
      <tags>
        <tag>课堂笔记</tag>
        <tag>辅修</tag>
        <tag>微观经济学</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[金融学辅修——金融学笔记（九）]]></title>
    <url>%2Fpost%2Fbd36a30f.html</url>
    <content type="text"><![CDATA[第七章 金融市场体系第一节 金融市场概述概念引出：生产单位、消费单位、产品市场、要素四场四元组。支付的流动、收入的流动，所有的货币资金的流动金融资产的交换都在金融市场中进行 金融市场的定义 定义：指经济主体之间为实现一定的目的，通过一定的交易方式进行各种金融叫资产交易的场所、机制 和行为的综合。 最直接的理解——“进行金融资产或金融工具交易的市场” “金融资产”——能够为持有者带来预期收益且具有特定权利归属关系的金融工具 “市场”——有形和无形之分 市场的真正含义——不在于场所，而在于机制 交易方式+场所+机制：既包括有组织的有形场所也包括分散在不同地点、主要采用现代通讯手段进行的、没有 统一组织、依据共同约定的惯例和规则、以协议方式进行的金融交易。 各种金融资产交易： 狭义的金融市场 定义： 指货币资金借贷和金融工具交易的场所、机制与行为的总和。 最狭义的理解主要是进行有价证券交易的场所、机制与行为的综合。更一般的情况下特指证券市场（股票 市场和债券市场）。 金融市场交易主体 指为实现一定的目的而进行金融交易的经济主体，包括参与交易的家庭、非金融企业、政府和各类金融 机构 分为专门 金融市场的 金融市场的交易媒体 金融市场媒体：是指在金融市场上充当交易媒介、从事交易或促使交易完成的组织、机构或个人。金融市场媒体 同金融市场主体一样，都是金融市场的参与者。 佣金支付，促进交易 金融市场的交易价格 金融市场的交易方式 主要类型： 交易所方式：固定场所、有组织、有制度，集中进行公开竞价的交易方式，主要表现为“多对多”。 柜台交易方式：在各金融机构柜台上买卖双方进行面议、分散交易的方式。表现为“一对一”。 场外交易方式：既没有固定的交易场所，也不直接接触，而主要是借助电讯手段来完成交易的方式。表现为“一对多”。 金融市场的监管主体 金融监管体制：指金融监管当局对金融机构和金融市场施加影响的机制]]></content>
      <categories>
        <category>金融</category>
        <category>金融学</category>
      </categories>
      <tags>
        <tag>课堂笔记</tag>
        <tag>辅修</tag>
        <tag>金融学</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[【HDU-1829】解题报告（带权并查集）]]></title>
    <url>%2Fpost%2F792e36ed.html</url>
    <content type="text"><![CDATA[原始题目A Bug’s Life Time Limit: 15000/5000 MS (Java/Others) Memory Limit: 32768/32768 K (Java/Others) Total Submission(s): 20239 Accepted Submission(s): 6472 Problem Description Background Professor Hopper is researching the sexual behavior of a rare species of bugs. He assumes that they feature two different genders and that they only interact with bugs of the opposite gender. In his experiment, individual bugs and their interactions were easy to identify, because numbers were printed on their backs. Problem Given a list of bug interactions, decide whether the experiment supports his assumption of two genders with no homosexual bugs or if it contains some bug interactions that falsify it. InputThe first line of the input contains the number of scenarios. Each scenario starts with one line giving the number of bugs (at least one, and up to 2000) and the number of interactions (up to 1000000) separated by a single space. In the following lines, each interaction is given in the form of two distinct bug numbers separated by a single space. Bugs are numbered consecutively starting from one. OutputThe output for every scenario is a line containing “Scenario #i:”, where i is the number of the scenario starting at 1, followed by one line saying either “No suspicious bugs found!” if the experiment is consistent with his assumption about the bugs’ sexual behavior, or “Suspicious bugs found!” if Professor Hopper’s assumption is definitely wrong. Sample Input2 3 3 1 2 2 3 1 3 4 2 1 2 3 4 Sample OutputScenario #1: Suspicious bugs found! Scenario #2: No suspicious bugs found! HintHuge input,scanf is recommended. SourceTUD Programming Contest 2005, Darmstadt, Germany Recommendlinle 题目大意一种虫子具有两种性别，如果假定虫子只跟异性交配，给出交配的虫子号码，判断是否符合假设（即是否存在同性交配的虫子）。 解题思路 二元关系的带权并查集（或者称之为二元种类并查集） 解题代码12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364656667686970717273747576777879808182838485868788#include&lt;cstdio&gt;#include&lt;cstring&gt;#include&lt;cmath&gt;#include&lt;iostream&gt;#include&lt;iomanip&gt;#include&lt;set&gt;#include&lt;queue&gt;#include&lt;unordered_map&gt;#include&lt;string&gt;#include&lt;sstream&gt;using namespace std;const int maxn=1e5+5;const int maxm=1e5+5;const int maxl=26;typedef long long ll;typedef unsigned long long ull;typedef vector&lt;int&gt; vi;typedef pair&lt;int, int&gt; pii;typedef pair&lt;string,string&gt; pss;#define rep(i,a,n) for(int i=a;i&lt;n;++i)#define per(i,a,n) for(int i=n-1;i&gt;=a;--i)#define fi first#define se second#define pb push_back#define np next_permutation#define pb push_back#define INF 0x3f3f3f3f#define EPS 1e-8int fa[maxn],cnt[maxn],relate[maxn];int n,t,m;void init()&#123; rep(i,0,maxn)&#123; fa[i]=i; cnt[i]=1; relate[i]=0; &#125;&#125;int find(int x)&#123; if(x==fa[x]) return x; else&#123; int temp=fa[x]; fa[x]=find(fa[x]); relate[x]=(relate[x]+relate[temp])%2; return fa[x]; &#125;&#125;int flag;bool merge(int x,int y)&#123; int fx=find(x); int fy=find(y); if(fx==fy)&#123; //已有关系 return relate[x]==relate[y]; &#125; else&#123; fa[fx]=fy; int temp=(1+relate[y])%2; relate[fx]=(temp+2-relate[x])%2; return false; &#125;&#125;int main()&#123; scanf("%d",&amp;t); rep(j,1,t+1)&#123; init(); scanf("%d%d",&amp;n,&amp;m); flag=false; int a,b; rep(i,0,m)&#123; scanf("%d%d",&amp;a,&amp;b); if(flag) continue; flag = merge(a,b); &#125; printf("Scenario #%d:\n",j); if(flag) printf("Suspicious bugs found!\n"); else printf("No suspicious bugs found!\n"); printf("\n"); &#125;&#125; 收获与反思 手敲并查集和带权并查集，注意输出格式，PE了两次。]]></content>
      <categories>
        <category>编程</category>
        <category>ACM</category>
      </categories>
      <tags>
        <tag>算法</tag>
        <tag>ACM</tag>
        <tag>2018秋季训练</tag>
        <tag>HDU</tag>
        <tag>并查集</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[【POJ-1182】解题报告（带权并查集）]]></title>
    <url>%2Fpost%2Fcd41dfb7.html</url>
    <content type="text"><![CDATA[原始题目食物链 Time Limit: 1000MS Memory Limit: 10000K Total Submissions: 95522 Accepted: 28832 Description动物王国中有三类动物A,B,C，这三类动物的食物链构成了有趣的环形。A吃B， B吃C，C吃A。现有N个动物，以1－N编号。每个动物都是A,B,C中的一种，但是我们并不知道它到底是哪一种。有人用两种说法对这N个动物所构成的食物链关系进行描述：第一种说法是”1 X Y”，表示X和Y是同类。第二种说法是”2 X Y”，表示X吃Y。此人对N个动物，用上述两种说法，一句接一句地说出K句话，这K句话有的是真的，有的是假的。当一句话满足下列三条之一时，这句话就是假话，否则就是真话。 当前的话与前面的某些真的话冲突，就是假话； 当前的话中X或Y比N大，就是假话； 当前的话表示X吃X，就是假话。 你的任务是根据给定的N（1 &lt;= N &lt;= 50,000）和K句话（0 &lt;= K &lt;= 100,000），输出假话的总数。 Input第一行是两个整数N和K，以一个空格分隔。 以下K行每行是三个正整数 D，X，Y，两数之间用一个空格隔开，其中D表示说法的种类。 若D=1，则表示X和Y是同类。 若D=2，则表示X吃Y。 Output只有一个整数，表示假话的数目。 Sample Input100 7 1 101 1 2 1 2 2 2 3 2 3 3 1 1 3 2 3 1 1 5 5 Sample Output3 SourceNoi 01 题目大意如题 解题思路 不仅要储存集合的关系，且要表示集合间相互元素的关系，关系可合并（推导），考虑带权并查集 维护一个relate数组，$relate[i]$表示i对根结点的关系。 0：与根同类 1：吃根 2：被根吃 推导规则（由于循环食物链，考虑模数关系）： A对B的关系为x，B对C的关系为y，则A对C的关系为$(x+y)%3$ A对B的关系为x，A对C的关系为y，则B对C的关系为$(y-x+3)%3$ 解题代码12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364656667686970717273747576777879808182838485868788899091929394#include &lt;cstdio&gt;#include &lt;cstring&gt;#include &lt;iostream&gt;#include &lt;iomanip&gt;#include &lt;string&gt;#include &lt;stack&gt;#include &lt;queue&gt;#include &lt;vector&gt;#include &lt;set&gt;#include &lt;cmath&gt;#include &lt;list&gt;using namespace std;const int maxn=1e5+5;const int maxm=1e5+5;typedef long long ll;typedef unsigned long long ull;typedef vector&lt;int&gt; vi;typedef pair&lt;int,int&gt; pii;typedef pair&lt;string,string&gt; pss;#define rep(i,a,n) for(int i=a;i&lt;n;++i)#define per(i,a,n) for(int i=n-1;i&gt;=a;--i)#define fi first#define se second#define mp make_pair#define np next_permutation#define pb push_back#define INF 0x3f3f3f3f#define EPS 1e-8#define cl(x,a) memset(x,a,sizeof(x))#define all(x) x.bein(),x.end()const int maxl=26;int n,k,d,x,y;int fa[maxn],relate[maxn];void init()&#123; rep(i,0,maxn)&#123; fa[i]=i; relate[i]=0; &#125;&#125;int find(int x)&#123; if(fa[x]==x)&#123; return x; &#125; else &#123; int temp=fa[x]; fa[x]=find(fa[x]); relate[x]=(relate[x]+relate[temp])%3; return fa[x]; &#125;&#125;bool merge(int r, int x, int y)&#123; int fx= find(x); int fy=find(y); if(fx==fy)&#123; if((relate[x]-relate[y]+3)%3==d) return true; else return false; &#125; else&#123; fa[fx]=fy; relate[fx]=(r+relate[y]-relate[x]+3)%3; return true; &#125;&#125;int main()&#123; scanf("%d%d",&amp;n,&amp;k); init(); int a,b,c,ccnt=0; rep(i,0,k)&#123; scanf("%d%d%d",&amp;d,&amp;x,&amp;y); d--; if(x&gt;n || y&gt;n )&#123; ccnt++; continue; &#125; if(d &amp;&amp; x==y)&#123; ccnt++; continue; &#125; if(merge(d,x,y)==false) ccnt++; &#125; printf("%d\n",ccnt);&#125; 收获与反思 并查集知识待补充。]]></content>
      <categories>
        <category>编程</category>
        <category>ACM</category>
      </categories>
      <tags>
        <tag>算法</tag>
        <tag>ACM</tag>
        <tag>2018秋季训练</tag>
        <tag>并查集</tag>
        <tag>待补充</tag>
        <tag>POJ</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[【HDU-1272】解题报告（并查集，集合数量）]]></title>
    <url>%2Fpost%2F4dc7502.html</url>
    <content type="text"><![CDATA[原始题目小希的迷宫 Time Limit: 2000/1000 MS (Java/Others) Memory Limit: 65536/32768 K (Java/Others) Total Submission(s): 67235 Accepted Submission(s): 21092 Problem Description上次Gardon的迷宫城堡小希玩了很久（见Problem B），现在她也想设计一个迷宫让Gardon来走。但是她设计迷宫的思路不一样，首先她认为所有的通道都应该是双向连通的，就是说如果有一个通道连通了房间A和B，那么既可以通过它从房间A走到房间B，也可以通过它从房间B走到房间A，为了提高难度，小希希望任意两个房间有且仅有一条路径可以相通（除非走了回头路）。小希现在把她的设计图给你，让你帮忙判断她的设计图是否符合她的设计思路。比如下面的例子，前两个是符合条件的，但是最后一个却有两种方法从5到达8。 Input输入包含多组数据，每组数据是一个以0 0结尾的整数对列表，表示了一条通道连接的两个房间的编号。房间的编号至少为1，且不超过100000。每两组数据之间有一个空行。整个文件以两个-1结尾。 Output对于输入的每一组数据，输出仅包括一行。如果该迷宫符合小希的思路，那么输出”Yes”，否则输出”No”。 Sample Input6 8 5 3 5 2 6 4 5 6 0 0 8 1 7 3 6 2 8 9 7 5 7 4 7 8 7 6 0 0 3 8 6 8 6 4 5 3 5 6 5 2 0 0 -1 -1 Sample OutputYes Yes No AuthorGardon SourceHDU 2006-4 Programming Contest Recommendlxj 题目大意如题 解题思路判定条件： 是否为一棵树，即两点之间是否只有一条途径。 是否包含全部点（即并查集森林大小为1） 条件1判断：用标准并查集对于每次合并检查是否已在一个集合中，若在，说明已有路径，则不满足题意。 条件2判断：set储存出现的点，$fa[x]==x$来判断是否为根节点。 解题代码123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899#include &lt;cstdio&gt;#include &lt;cstring&gt;#include &lt;iostream&gt;#include &lt;set&gt;#include &lt;queue&gt;#include &lt;vector&gt;#include &lt;stack&gt;#include &lt;vector&gt;#include &lt;algorithm&gt;#include &lt;string&gt;#include &lt;iostream&gt;#include &lt;iomanip&gt;#include &lt;map&gt;#include &lt;unordered_map&gt;using namespace std;const int maxn=1e5+5;const int maxm=1e5+5;typedef long long ll;typedef unsigned long long ull;typedef vector&lt;int&gt; vi;typedef pair&lt;int,int&gt; pii;typedef pair&lt;string,string&gt; pss;#define rep(i,a,n) for(int i=a;i&lt;n;++i)#define per(i,a,n) for(int i=n-1;i&gt;=a;--i)#define cl(x,a) memset(x,a,sizeof(x))#define pb push_back#define np next_permutation#define mp make_pair#define INF 0x3f3f3f3f#define EPS 1e-8int fa[maxn],cnt[maxn];set &lt;int&gt; s;int n,m,k,t;void init()&#123; rep(i,0,maxn)&#123; fa[i]=i; cnt[i]=1; &#125; s.clear();&#125;int find(int x)&#123; if(fa[x]==x) return x; else &#123; fa[x]=find(fa[x]); return fa[x]; &#125;&#125;bool merge(int x,int y)&#123; int fx=find(x),fy=find(y); if(fx==fy) return false; else &#123; fa[fy]=fx; cnt[fx]+=cnt[fy]; return true; &#125;&#125;int check(int x)&#123; return cnt[find(x)];&#125;int u,v;int main()&#123; ios::sync_with_stdio(false); init(); bool flag= true; while(cin&gt;&gt;u&gt;&gt;v &amp;&amp; u!=-1 &amp;&amp; v!=-1)&#123; if(!u &amp;&amp; !v)&#123; if(flag)&#123; if(s.empty()) cout&lt;&lt;"Yes"&lt;&lt;endl; else&#123; //检查 set &lt;int&gt;::iterator it; int ccnt=0; for(it=s.begin();it!=s.end();it++)&#123; if(fa[*it]==*it) ccnt++; &#125; if(ccnt==1) cout&lt;&lt;"Yes"&lt;&lt;endl; else cout&lt;&lt;"No"&lt;&lt;endl; &#125; &#125; else cout&lt;&lt;"No"&lt;&lt;endl; init(); flag = true; &#125; else &#123; s.insert(u);s.insert(v); if(merge(u,v)==false) flag=false; &#125; &#125;&#125; 收获与反思 记录森林大小]]></content>
      <categories>
        <category>编程</category>
        <category>ACM</category>
      </categories>
      <tags>
        <tag>算法</tag>
        <tag>ACM</tag>
        <tag>2018秋季训练</tag>
        <tag>HDU</tag>
        <tag>并查集</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[【HDU-3172】解题报告（并查集）]]></title>
    <url>%2Fpost%2Fe78ad34c.html</url>
    <content type="text"><![CDATA[原始题目Virtual Friends Time Limit: 4000/2000 MS (Java/Others) Memory Limit: 32768/32768 K (Java/Others) Total Submission(s): 11465 Accepted Submission(s): 3345 Problem DescriptionThese days, you can do all sorts of things online. For example, you can use various websites to make virtual friends. For some people, growing their social network (their friends, their friends’ friends, their friends’ friends’ friends, and so on), has become an addictive hobby. Just as some people collect stamps, other people collect virtual friends. Your task is to observe the interactions on such a website and keep track of the size of each person’s network. Assume that every friendship is mutual. If Fred is Barney’s friend, then Barney is also Fred’s friend. InputInput file contains multiple test cases. The first line of each case indicates the number of test friendship nest. Each friendship nest begins with a line containing an integer F, the number of friendships formed in this frindship nest, which is no more than 100 000. Each of the following F lines contains the names of two people who have just become friends, separated by a space. A name is a string of 1 to 20 letters (uppercase or lowercase). OutputWhenever a friendship is formed, print a line containing one integer, the number of people in the social network of the two people who have just become friends. Sample Input1 3 Fred Barney Barney Betty Betty Wilma Sample Output2 3 4 SourceUniversity of Waterloo Local Contest 2008.09 Recommendchenrui 题目大意朋友圈，给出$n$组朋友，每次输入两个人名，表示两个人成为朋友，同时输出当下两个人朋友圈的总大小。 解题思路 利用map(unordered_map)存储string-&gt;int的映射。 标准并查集，维护集合的大小。 每次merge两人所代表的集合，输出大小即可。 解题代码123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990#include &lt;cstdio&gt;#include &lt;cstring&gt;#include &lt;iostream&gt;#include &lt;set&gt;#include &lt;queue&gt;#include &lt;vector&gt;#include &lt;stack&gt;#include &lt;vector&gt;#include &lt;algorithm&gt;#include &lt;string&gt;#include &lt;iostream&gt;#include &lt;iomanip&gt;#include &lt;map&gt;#include &lt;unordered_map&gt;using namespace std;const int maxn=1e5+5;const int maxm=1e5+5;typedef long long ll;typedef unsigned long long ull;typedef vector&lt;int&gt; vi;typedef pair&lt;int,int&gt; pii;typedef pair&lt;string,string&gt; pss;#define rep(i,a,n) for(int i=a;i&lt;n;++i)#define per(i,a,n) for(int i=n-1;i&gt;=a;--i)#define cl(x,a) memset(x,a,sizeof(x))#define pb push_back#define np next_permutation#define mp make_pair#define INF 0x3f3f3f3f#define EPS 1e-8unordered_map &lt;string,int&gt; mmp;int fa[maxn],cnt[maxn];int n,m,k,t;void init()&#123; rep(i,0,maxn)&#123; fa[i]=i; cnt[i]=1; &#125; mmp.clear();&#125;int find(int x)&#123; if(fa[x]==x) return x; else &#123; fa[x]=find(fa[x]); return fa[x]; &#125;&#125;bool merge(int x,int y)&#123; int fx=find(x),fy=find(y); if(fx==fy) return false; else &#123; fa[fy]=fx;// cout&lt;&lt;"fx="&lt;&lt;fx&lt;&lt;" fy="&lt;&lt;fy&lt;&lt;endl; cnt[fx]+=cnt[fy]; return true; &#125;&#125;int check(int x)&#123;// cout&lt;&lt;"fa="&lt;&lt;find(x)&lt;&lt;endl; return cnt[find(x)];&#125;int main()&#123; ios::sync_with_stdio(false); while(cin&gt;&gt;t) while(t--)&#123; cin&gt;&gt;n; init(); string a,b; int ccnt=0; rep(i,0,n)&#123; cin&gt;&gt;a&gt;&gt;b; if(!mmp.count(a)) mmp.insert(mp(a,++ccnt)); if(!mmp.count(b)) mmp.insert(mp(b,++ccnt)); merge(mmp[a],mmp[b]); cout&lt;&lt;check(mmp[b])&lt;&lt;endl; &#125; &#125;&#125; 收获与反思 可利用unordered_map加速 并查集知识🔗待补充。]]></content>
      <categories>
        <category>编程</category>
        <category>ACM</category>
      </categories>
      <tags>
        <tag>算法</tag>
        <tag>ACM</tag>
        <tag>HDU</tag>
        <tag>并查集</tag>
        <tag>待补充</tag>
        <tag>2018球季训练</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[【POJ-1611】解题报告（并查集）]]></title>
    <url>%2Fpost%2F3d71c64b.html</url>
    <content type="text"><![CDATA[原始题目The Suspects Time Limit: 1000MS Memory Limit: 20000K Total Submissions: 51885 Accepted: 24803 DescriptionSevere acute respiratory syndrome (SARS), an atypical pneumonia of unknown aetiology, was recognized as a global threat in mid-March 2003. To minimize transmission to others, the best strategy is to separate the suspects from others.In the Not-Spreading-Your-Sickness University (NSYSU), there are many student groups. Students in the same group intercommunicate with each other frequently, and a student may join several groups. To prevent the possible transmissions of SARS, the NSYSU collects the member lists of all student groups, and makes the following rule in their standard operation procedure (SOP).Once a member in a group is a suspect, all members in the group are suspects.However, they find that it is not easy to identify all the suspects when a student is recognized as a suspect. Your job is to write a program which finds all the suspects. InputThe input file contains several cases. Each test case begins with two integers n and m in a line, where n is the number of students, and m is the number of groups. You may assume that 0 &lt; n &lt;= 30000 and 0 &lt;= m &lt;= 500. Every student is numbered by a unique integer between 0 and n−1, and initially student 0 is recognized as a suspect in all the cases. This line is followed by m member lists of the groups, one line per group. Each line begins with an integer k by itself representing the number of members in the group. Following the number of members, there are k integers representing the students in this group. All the integers in a line are separated by at least one space.A case with n = 0 and m = 0 indicates the end of the input, and need not be processed. OutputFor each case, output the number of suspects in one line. Sample Input100 4 2 1 2 5 10 13 11 12 14 2 0 1 2 99 2 200 2 1 5 5 1 2 3 4 5 1 0 0 0 Sample Output4 1 1 SourceAsia Kaohsiung 2003 题目大意为了减少SARS传播，最好的方法是将这些疑似患者区分开。现在给定一个学校里有$n$个人，$m$个学生团体，同一学生团体中只要有一个疑似患者，即都被认定为疑似患者。现在统计所有的疑似患者的数量。 解题思路标准并查集，维护一个数组cnt记录集合的大小，根节点的cnt值为集合大小。 初始化 fa[i]=i; cnt[i]=1; find函数路径压缩 fa[x]=find(fa[x]); //加速下一次询问 merge函数增加维护cnt cnt[fx] += cnt[fy] 解题代码12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364656667686970717273747576777879808182838485#include &lt;cstdio&gt;#include &lt;cstring&gt;#include &lt;iostream&gt;#include &lt;set&gt;#include &lt;queue&gt;#include &lt;vector&gt;#include &lt;stack&gt;#include &lt;vector&gt;#include &lt;algorithm&gt;#include &lt;string&gt;#include &lt;iostream&gt;#include &lt;iomanip&gt;using namespace std;const int maxn=1e5+5;const int maxm=1e5+5;typedef long long ll;typedef unsigned long long ull;typedef vector&lt;int&gt; vi;typedef pair&lt;int,int&gt; pii;typedef pair&lt;string,string&gt; pss;#define rep(i,a,n) for(int i=a;i&lt;n;++i)#define per(i,a,n) for(int i=n-1;i&gt;=a;--i)#define cl(x,a) memset(x,a,sizeof(x))#define pb push_back#define np next_permutation#define mp make_pair#define INF 0x3f3f3f3f#define EPS 1e-8 int fa[maxn],cnt[maxn];int n,m,k;void init(int n)&#123; rep(i,0,n)&#123; fa[i]=i; cnt[i]=1; &#125;&#125;int find(int x)&#123; if(fa[x]==x) return x; else &#123; fa[x]=find(fa[x]); return fa[x]; &#125;&#125;bool merge(int x,int y)&#123; int fx=find(x),fy=find(y); if(fx==fy) return false; else &#123; fa[fy]=fx; cnt[fx]+=cnt[fy]; return true; &#125;&#125;int check(int x)&#123; return cnt[find(x)];&#125;int main()&#123; ios::sync_with_stdio(false); while(cin&gt;&gt;n&gt;&gt;m &amp;&amp; n+m)&#123; init(n); rep(i,0,m)&#123; cin&gt;&gt;k; int first,temp; cin&gt;&gt;first; rep(t,1,k)&#123; cin&gt;&gt;temp; merge(first,temp); &#125; &#125;// cout&lt;&lt;"#"; cout&lt;&lt;check(0)&lt;&lt;endl; &#125; &#125; 收获与反思待补充]]></content>
      <categories>
        <category>编程</category>
        <category>ACM</category>
      </categories>
      <tags>
        <tag>算法</tag>
        <tag>ACM</tag>
        <tag>2018秋季训练</tag>
        <tag>并查集</tag>
        <tag>待补充</tag>
        <tag>POJ</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[2018-12-01武汉游记]]></title>
    <url>%2Fpost%2Fa8759852.html</url>
    <content type="text"></content>
      <categories>
        <category>编程</category>
        <category>ACM</category>
      </categories>
  </entry>
  <entry>
    <title><![CDATA[【CSU-2187】解题报告（维护顺序极差）]]></title>
    <url>%2Fpost%2F7410a832.html</url>
    <content type="text"><![CDATA[原始题目2187: 翻转游戏加强版 Time Limit: 1 Sec Memory Limit: 128 Mb Submitted: 101 Solved: 23 Description给当一个01串，最多可以对一段区间里的01取反一次，求最多能取得的1的个数 Input多组数据，第一行为数组组数$T(T≤10)$ 每组数据第一行一个整数$N(1≤N≤{10}^{6})$ 第二行一个长度为$N$的01字符串 Output每组数据输出一行代表答案 Sample Input2 4 1001 4 1111 Sample Output4 4 HintSource题目大意如题 解题思路 小规模数据采取枚举分界点的方法，时间复杂度$O(n^{2})$ 仔细想一下，我们要找的是一个区间，里面0的数量与1的数量差最大。如果直接寻找区间有点难理解的话，我们可以换一个角度，记录出现0和出现1的差值，求差值在翻转以后的最小值。 如图 那么如何求翻转以后的最小值？如果对每个区间下限进行计数，遇1减减，遇0加加，我们的答案就是不同起点的所有cnt值得最大值。 实际上我们就是找图中一个极小值（包括头点）与一个极大值（包括末尾）极差得最大值，而且需要注意得是我们求的是1的翻转次数最大，所以要求是一个极小值在左，极大值在右，左低右高。 再如图 线性从头扫一遍，维护最小值，同时重新计数cnt，最后求cnt的最大值。 解题代码12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364#include &lt;cstdio&gt;#include &lt;cstring&gt;#include &lt;queue&gt;#include &lt;stack&gt;#include &lt;cstring&gt;#include &lt;algorithm&gt;#include &lt;vector&gt;#include &lt;string&gt;#include &lt;bits/stdc++.h&gt;using namespace std;const int maxn=1e6+5;const int maxm=1e6+5;#define INF 0x3f3f3f3f#define EPS 1e-8#define rep(i,a,n) for(int i=a;i&lt;n;++i)#define per(i,a,n) for(int i=n-1;i&gt;=a;--i)#define fi first#define se second#define pb push_back#define np next_permutation#define mp make_pairtypedef long long ll;typedef unsigned long long ull;typedef vector &lt;int&gt; vi;typedef pair&lt;string,string&gt; pss;typedef pair&lt;int, int&gt; pii;int main()&#123; ios::sync_with_stdio(false);// freopen("in.txt","r",stdin); int t; cin&gt;&gt;t; while(t--)&#123; int n; cin&gt;&gt;n; string s; cin&gt;&gt;s; int ans=0,cnt=0,ccnt=0; int mmin=0; rep(i,0,n)&#123; if(s[i]=='0') ans++,cnt++; else ans--,cnt--; if(i==n-1 &amp;&amp; s[i]=='0') ccnt=max(ccnt,cnt); if(i!=n-1)&#123; if(s[i]=='1' &amp;&amp; s[i+1]=='0' &amp;&amp; ans&lt;mmin) mmin=ans,cnt=0; if(s[i]=='0' &amp;&amp; s[i+1]=='1') ccnt=max(ccnt,cnt); &#125; &#125; if(ccnt==0) cout&lt;&lt;n&lt;&lt;endl; else&#123;// cout&lt;&lt;"min="&lt;&lt;mmin&lt;&lt;" max="&lt;&lt;mmax&lt;&lt;endl; ans= ans-2*(ccnt); cout&lt;&lt;(n-ans)/2&lt;&lt;endl; &#125; &#125;&#125; 收获与反思考虑单调性，维护记录值，最大/最小值。]]></content>
      <categories>
        <category>编程</category>
        <category>ACM</category>
      </categories>
      <tags>
        <tag>算法</tag>
        <tag>ACM</tag>
        <tag>CSU</tag>
        <tag>2018秋季训练</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[【CSU-2179】解题报告（水题）]]></title>
    <url>%2Fpost%2F6db0d89d.html</url>
    <content type="text"><![CDATA[原始题目2179: 找众数 Time Limit: 1 Sec Memory Limit: 128 Mb Submitted: 86 Solved: 32 Description由文件给出$N$个$1$到$30000$间无序数正整数，其中$1≤N≤10000$，同一个正整数可能会出现多次，出现次数最多的整数称为众数。求出它的众数及它出现的次数。 Input输入文件第一行是正整数的个数$N$，第二行开始为$N$个正整数。 Output输出文件有若干行，每行两个数，第一个是众数，第二个是众数出现的次数。 Sample Input12 2 4 2 3 2 5 3 7 2 3 4 3 Sample Output2 4 3 4 HintSource题目大意如题 解题思路记录出现次数，加入动态数组中按次数大小快速排序，最后输出（众数多个注意排序的时候按字典序）。 解题代码1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859#include &lt;cstdio&gt;#include&lt;cstring&gt;#include&lt;iostream&gt;#include&lt;set&gt;#include &lt;queue&gt;#include&lt;vector&gt;#include &lt;bits/stdc++.h&gt;using namespace std;const int maxn=1e5+5;const int maxm=1e5+5;typedef long long ll;typedef unsigned long long ull;typedef vector&lt;int&gt; vi;typedef pair&lt;int,int &gt; pii;typedef pair&lt;string,string&gt; pss;#define rep(i,a,n) for(int i=a;i&lt;n;++i)#define per(i,a,n) for(int i=n-1;i&gt;=a;--i)#define fi first#define se second#define pb push_back#define np next_permutation#define mp make_pair#define all(x) x.begin(),x.end()int n;int a[maxn];int ans1=0,ans2=0;vi ans;bool cmp(int c,int d)&#123; if(a[c]==a[d]) return c&lt;d; else return a[c]&gt;a[d];&#125;int main()&#123; ios::sync_with_stdio(false); while(cin&gt;&gt;n)&#123; memset(a,0,sizeof(a)); ans.clear(); rep(i,0,n)&#123; int temp; cin&gt;&gt;temp; if(!a[temp]) ans.pb(temp); a[temp]++; &#125; sort(all(ans),cmp); int len=ans.size(); cout&lt;&lt;ans[0]&lt;&lt;" "&lt;&lt;a[ans[0]]&lt;&lt;endl; for(int i=1;i&lt;len;i++)&#123; if(a[ans[i]]&lt;a[ans[0]]) break; cout&lt;&lt;ans[i]&lt;&lt;" "&lt;&lt;a[ans[0]]&lt;&lt;endl; &#125; &#125;&#125; 收获与反思出题者没说清楚，应该加个特判的，所以注意排序以字典序为第二关键字。]]></content>
      <categories>
        <category>编程</category>
        <category>ACM</category>
      </categories>
      <tags>
        <tag>算法</tag>
        <tag>ACM</tag>
        <tag>CSU</tag>
        <tag>2018秋季训练</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[【CSU-2185】解题报告（水题）]]></title>
    <url>%2Fpost%2F3a72081e.html</url>
    <content type="text"><![CDATA[原始题目2185: a simple problem Time Limit: 1 Sec Memory Limit: 128 Mb Submitted: 78 Solved: 46 DescriptionMy girlfriend loves 7 very much, she thinks it is lucky! If an integer contains one or more 7, she will think it is lucky too! InputThere are multiple test files and each contains one case.The number of cases is at most 100. For each test case, there is only one line with an integer $X ( 1 ≤ X ≤ {10}^{9} )$. OutputFor each test case, if $X$ contains one or more 7, output “Lucky”(without quotation marks),otherwise output “Unlucky”(without quotation marks). Sample Input17171 Sample OutputLucky HintSource题目大意输入一串字符，字符中有7则输出“Lucky”，否则输出“Unlucky” 解题思路逐位判断 解题代码12345678910111213141516171819202122232425262728293031323334353637383940414243444546#include &lt;cstdio&gt;#include&lt;cstring&gt;#include&lt;cmath&gt;#include&lt;iostream&gt;#include&lt;set&gt;#include&lt;queue&gt;#include&lt;map&gt;#include &lt;algorithm&gt;#include &lt;stack&gt;#include &lt;bits/stdc++.h&gt;#define INF 0x3f3f3f3f#define EPS 1e-8#define fi first#define se second#define mp make_pair#define pb push_back#define np next_permutation#define cl(x,a) memeset(x,a,sizeof(x))#define rep(i,a,n) for(int i=a;i&lt;n;++i)#define per(i,a,n) for(int i=n-1;i&gt;=a;--i)using namespace std;const int maxn=1e5+5;const int maxm=1e5+5;typedef long long ll;typedef unsigned long long ull;typedef vector&lt;int&gt; vi;typedef pair&lt;int,int&gt; pii;typedef pair&lt;string,string&gt; pss;int n,t;int main()&#123; while(~scanf("%d",&amp;n))&#123; int flag=0; while(n)&#123; if(n%10==7)&#123; flag=1; break; &#125; n/=10; &#125; if(flag) printf("Lucky\n"); else printf("Unlucky\n"); &#125;&#125; 收获与反思无]]></content>
      <categories>
        <category>编程</category>
        <category>ACM</category>
      </categories>
      <tags>
        <tag>算法</tag>
        <tag>ACM</tag>
        <tag>CSU</tag>
        <tag>2018秋季训练</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[【CSU-2163】解题报告（水题）]]></title>
    <url>%2Fpost%2F73136b.html</url>
    <content type="text"><![CDATA[原始题目2163: 字符画 Time Limit: 1 Sec Memory Limit: 128 Mb Submitted: 221 Solved: 139 Description读入 $w$，请输出 2018 的字符画，两个数字之间有 $w$ 个空格。具体格式请参考样例输出。$(1 ≤ w ≤ 2018)$ Input输入文件只包含 1 个整数 $w$. Output输出 5 行，每行 $12 + 3w$ 个字符（只包含 o 和 . 两种，字符画的部分用 o，空格的部分用 .），以换行符结尾。 Sample Input2 Sample Outputooo..ooo..ooo..ooo ..o..o.o...o...o.o ooo..o.o...o...ooo o....o.o...o...o.o ooo..ooo..ooo..ooo HintSource2018湖南省第14届大学生计算机程序设计竞赛 Authorftiasch 题目大意如题 解题思路打输出 解题代码1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465666768697071727374757677787980#include &lt;iostream&gt;#include &lt;cstdio&gt;#include &lt;cstring&gt;#include &lt;sstream&gt;#include &lt;set&gt;#include &lt;queue&gt;#include &lt;cmath&gt;#include &lt;stack&gt;#include &lt;map&gt;#include &lt;set&gt;#include &lt;algorithm&gt;using namespace std;const int maxn=1e5+5;const int maxm=1e5+5;#define rep(i,a,n) for(int i=a;i&lt;n;++i)#define per(i,a,n) for(int i=n-1;i&gt;=a;--i)#define fi first#define se second#define pb push_back#define np next_permutation#define mp make_pair#define INF 0x3f3f3f3f#define EPS 1e-8int n;int main()&#123; ios::sync_with_stdio(false); while(cin&gt;&gt;n)&#123; &#123; cout&lt;&lt;"ooo"; rep(i,0,n) cout&lt;&lt;"."; cout&lt;&lt;"ooo"; rep(i,0,n) cout&lt;&lt;"."; cout&lt;&lt;"ooo"; rep(i,0,n) cout&lt;&lt;"."; cout&lt;&lt;"ooo"&lt;&lt;endl; &#125; &#123; cout&lt;&lt;"..o"; rep(i,0,n) cout&lt;&lt;"."; cout&lt;&lt;"o.o"; rep(i,0,n) cout&lt;&lt;"."; cout&lt;&lt;".o."; rep(i,0,n) cout&lt;&lt;"."; cout&lt;&lt;"o.o"&lt;&lt;endl; &#125; &#123; cout&lt;&lt;"ooo"; rep(i,0,n) cout&lt;&lt;"."; cout&lt;&lt;"o.o"; rep(i,0,n) cout&lt;&lt;"."; cout&lt;&lt;".o."; rep(i,0,n) cout&lt;&lt;"."; cout&lt;&lt;"ooo"&lt;&lt;endl; &#125; &#123; cout&lt;&lt;"o.."; rep(i,0,n) cout&lt;&lt;"."; cout&lt;&lt;"o.o"; rep(i,0,n) cout&lt;&lt;"."; cout&lt;&lt;".o."; rep(i,0,n) cout&lt;&lt;"."; cout&lt;&lt;"o.o"&lt;&lt;endl; &#125; &#123; cout&lt;&lt;"ooo"; rep(i,0,n) cout&lt;&lt;"."; cout&lt;&lt;"ooo"; rep(i,0,n) cout&lt;&lt;"."; cout&lt;&lt;"ooo"; rep(i,0,n) cout&lt;&lt;"."; cout&lt;&lt;"ooo"&lt;&lt;endl; &#125; &#125;&#125; 收获与反思无]]></content>
      <categories>
        <category>编程</category>
        <category>ACM</category>
      </categories>
      <tags>
        <tag>算法</tag>
        <tag>ACM</tag>
        <tag>CSU</tag>
        <tag>2018秋季训练</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[【CSU-2184】解题报告（水题）]]></title>
    <url>%2Fpost%2F3bc7f503.html</url>
    <content type="text"><![CDATA[原始题目2184: 解密简单版 Time Limit: 1 Sec Memory Limit: 128 Mb Submitted: 101 Solved: 39 Description小F居住在铁道校区，他想和湘雅校区的同学小L聊天，为了保证沟通安全，他发明了一种加密方式，这种加密方式是这样的：对于一个01串，小F会将其从左到右每8位分成一组，最后一组可能不足8位，对每组进行逆序操作，即如果原来是$ b{L}b{L+1}b{L+2}b{R-1}b{R} $,逆序之后变成 $ b{R}b{R-1}b{R-2}b{L-1}b{L} $。现在小F已经加密好了一个串，并且将其发给了小L，你能帮助小L得到这串密文对应的原始信息吗？ Input单组数据。 一行一个 01 串，代表加密后的字符串，串长度大于0,小于等于 100。 Output一行字符串，代表加密后的字符串所对应的原始信息。 Sample Input100010110011101 Sample Output110100011011100 HintSource题目大意如题 解题思路模8反转输出 解题代码1234567891011121314151617181920212223242526272829303132333435#include &lt;iostream&gt;#include &lt;string&gt;#include &lt;sstream&gt;#include &lt;bits/stdc++.h&gt;using namespace std;const int maxn=1e5+5;const int maxm=1e5+5;#define rep(i,a,n) for(int i=a;i&lt;n;++i)#define per(i,a,n) for(int i=n-1;i&gt;=a;--i)typedef long long ll;typedef unsigned long long ull;typedef vector&lt;int&gt; vi;typedef pair&lt;string,string&gt; pss;int main()&#123; ios::sync_with_stdio(false); string ss; while(cin&gt;&gt;ss)&#123; int len= ss.length(); int t=len/8; rep(i,0,t)&#123; per(j,0,8)&#123; cout&lt;&lt;ss[i*8+j]; &#125; &#125; for(int i=len-1;i&gt;=t*8;i--) cout&lt;&lt;ss[i]; cout&lt;&lt;endl; &#125;&#125; 收获与反思暂无]]></content>
      <categories>
        <category>编程</category>
        <category>ACM</category>
      </categories>
      <tags>
        <tag>算法</tag>
        <tag>ACM</tag>
        <tag>CSU</tag>
        <tag>2018秋季训练</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[【CSU-2183】解题报告（水题）]]></title>
    <url>%2Fpost%2F3fce0650.html</url>
    <content type="text"><![CDATA[原始题目2183: 击鼓传花简单版 Time Limit: 1 Sec Memory Limit: 128 Mb Submitted: 165 Solved: 41 Description岳麓山下旌旗卷，CSU运动会隆重开幕了，小Q所在的班级参加了“击鼓传花”趣味比赛。 比赛规则如下，$n$个队员(不包括小Q)围成一个圈，每个人手里拿着一些花束(数量也可能为0)，小Q站在圆圈的中间，队员需要传递花束给小Q，每个鼓点只允许一个人传送一束花，最终要求圆圈上所有人的花束都传递给小Q。请问需要花多少鼓点呢？ Input多组数据。 第一行$n$，代表队员数量。 第2行到第$n+1$行，每行一个整数$a_i$，代表每个队员最开始拿的花束数量。$(0 ≤ a_i ≤ {10}^{6})$所有组的n之和不超过 $ {10}^{3} $ Output一个整数，代表需要的鼓点数。 Sample Input4 1 2 5 4 Sample Output12 HintSource题目大意如题 解题思路求和，注意long long。 解题代码123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051#include &lt;cstdio&gt;#include &lt;cstring&gt;#include &lt;iostream&gt;#include &lt;set&gt;#include &lt;queue&gt;#include &lt;stack&gt;#include &lt;vector&gt;#include &lt;bits/stdc++.h&gt;using namespace std;const int maxn=1e5+5;const int maxm=1e5+5;#define rep(i,a,n) for(int i=a;i&lt;n;++i)#define per(i,a,n) for(int i=n-1;i&gt;=a;--i)#define fi first#define se second#define pb push_back#define np next_permutation#define mp make_pair#define INF 0x3f3f3f3f#define EPS 1e-8typedef long long ll;typedef unsigned long long ull;typedef vector&lt;int&gt; vi;typedef pair&lt;int, int&gt; pii;typedef pair&lt;string,string&gt; pss;int main()&#123; ios::sync_with_stdio(false); ll sum=0; int n; while(cin&gt;&gt;n)&#123; int temp; sum=0; rep(i,0,n)&#123; cin&gt;&gt;temp; sum+=temp; &#125; cout&lt;&lt; sum&lt;&lt;endl; &#125;&#125; 收获与反思注意long long。]]></content>
      <categories>
        <category>编程</category>
        <category>ACM</category>
      </categories>
      <tags>
        <tag>算法</tag>
        <tag>ACM</tag>
        <tag>CSU</tag>
        <tag>2018秋季训练</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[【CSU-2181】解题报告（枚举分界点）]]></title>
    <url>%2Fpost%2Fc938bbd1.html</url>
    <content type="text"><![CDATA[强化题目和线性做法在这里【CSU-2187】解题报告（维护顺序极差） 原始题目2181: 翻转游戏 Time Limit: 1 Sec Memory Limit: 128 Mb Submitted: 115 Solved: 34 Description给当一个01串，最多可以对一段区间里的01取反一次，求最多能取得的1的个数 Input多组数据，第一行为数组组数$T(T ≤ 10)$ 每组数据第一行一个整数 $N(1 ≤ N ≤ 100)$ 第二行一个长度为$N$的01字符串 Output每组数据输出一行代表答案 Sample Input2 4 1001 4 1111 Sample Output4 4 HintSourceAuthorWells 题目大意如题 解题思路枚举分界点，暴力更新最大值 解题代码12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364656667686970717273747576777879808182#include &lt;cstdio&gt;#include &lt;cstring&gt;#include &lt;iostream&gt;#include &lt;string&gt;#include &lt;set&gt;#include &lt;queue&gt;#include &lt;vector&gt;#include &lt;bits/stdc++.h&gt;using namespace std;const int maxn=1e5+5;const int maxm=1e5+5;#define rep(i,a,n) for(int i=a;i&lt;n;++i)#define per(i,a,n) for(int i=n-1;i&gt;=a;--i)#define fi first#define se second#define INF 0x3f3f3f3f#define EPS 1e-8#define mp make_pair#define np next_permutation#define pb push_backtypedef long long ll;typedef unsigned long long ull;typedef vector&lt;int&gt; vi;typedef pair&lt;int,int&gt; pii;typedef pair&lt;string,string&gt; pss;int t,n;vi le,ri;int a[maxn];int b[maxn];int main()&#123; ios::sync_with_stdio(false); cin&gt;&gt;t; while(t--)&#123; cin&gt;&gt;n; string s; cin&gt;&gt;s; int len=s.length(); le.clear(); ri.clear(); memset(a,0,sizeof(a)); memset(b,0,sizeof(b)); rep(i,0,n)&#123; if(s[i]=='1')&#123; a[i+1]=a[i]+1; b[i+1]=b[i]; &#125; else &#123; a[i+1]=a[i]; b[i+1]=b[i]+1; &#125; if(s[i]=='0' &amp;&amp; i==0 || s[i]=='0' &amp;&amp; s[i-1]=='1') le.push_back(i+1); if(s[i]=='0' &amp;&amp; i==n-1 || s[i]=='0' &amp;&amp; s[i+1]=='1') ri.push_back(i+1); &#125;// rep(i,1,n+1)&#123; cout&lt;&lt;"#"&lt;&lt;a[i]&lt;&lt;" "&lt;&lt;b[i]&lt;&lt;endl;&#125; if(le.empty() &amp;&amp; ri.empty())&#123; cout&lt;&lt;n&lt;&lt;endl; continue; &#125; int all=a[n]; int ans=-INF; for(int i=0;i&lt;le.size();i++)&#123; for(int j=0;j&lt;ri.size();j++)&#123; if(le[i]&gt;ri[j]) continue;// cout&lt;&lt;"left="&lt;&lt;le[i]&lt;&lt;" right="&lt;&lt;ri[j]&lt;&lt;endl; int temp1=a[ri[j]]-a[le[i]-1]; int temp0=b[ri[j]]-b[le[i]-1];// cout&lt;&lt;temp1&lt;&lt;" "&lt;&lt;temp0&lt;&lt;endl; ans=max(all-temp1+temp0,ans);// cout&lt;&lt;"tempans="&lt;&lt;ans&lt;&lt;endl; &#125; &#125; cout&lt;&lt;ans&lt;&lt;endl; &#125;&#125; 收获与反思合理枚举]]></content>
      <categories>
        <category>编程</category>
        <category>ACM</category>
      </categories>
      <tags>
        <tag>算法</tag>
        <tag>ACM</tag>
        <tag>CSU</tag>
        <tag>2018秋季训练</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[金融学辅修——金融学笔记（八）]]></title>
    <url>%2Fpost%2Fc7fb8250.html</url>
    <content type="text"><![CDATA[汇率汇率制度的类型 固定汇率类型（金本位和纸本位） 共通点： 各国对本国货币都规定有金平价，中心汇率是按两国货币各自的金平价之比来确定的。 外汇市场上的汇率水平相对稳定，围绕中心汇率在很小的限度内浮动。不同点： 金本位制下的固定汇率制时自发形成的，纸币流通条件下，固定汇率时国际协议（布雷顿森林体系）认为建立起来的。 金本位制度下，各国货币的金平价不会变动，而在纸币流通条件下，各国货币的金平价则是可以调整的。 浮动汇率制度 自由浮动： 情节浮动 管理浮动： 肮脏浮动 联合浮动：（原欧洲货币体系各成员国之间保持固定汇率，对体系外，即非成员国货币则采取共同浮动做法，洞中小蛇）（相关，1992年GBP危机） 单独浮动：（本国货币不与外国任何货币发生固定联系，根据外汇市场的供求状况单独浮动） 1999年IMF新的汇率制度分类 无独立法定货币的汇率安排 货币局制度（新加坡，香港） 其他传统固定汇率制 水平（上下1%）调整的钉住制 爬行钉住 爬行带内浮动（目标区） 不事先公布干预方式的管理浮动 单独浮动 专栏6-1 我国的金融机构体系——政策性金融机构 政策性金融机构，政策性金融机构由 商业金融机构 我国典当行业概况 典当实际上是一种融资渠道，典当业作为现代金融业的鼻祖，国外称之为“第二银行”。 第四节 金融机构的脆弱性 金融机构的内在脆弱性 功能有效发挥的两个前提条件 投资者不能同时提现 银行能够效率原则，选择效益最好的项目 然而这两个前提条件并不是 挤兑的案例：海南发展银行案例。塞浦路斯银行破产危机案例。 第五节 对金融机构体系的管理国外对金融体系的管理（以美国为例） 证券交易委员会：交易所和金融市场 商品期货交易委员会：期货市场 通货监理官办公室：联邦注册的商业银行 全国信用社管理局：联邦注册的信用社 联邦存款保险公司（罗斯福时期建立）：商业银行、互助储蓄银行、储蓄贷款协会为10万美元以下的存款账户提供保险 联邦储备体系：所有存款机构 管理不慎案例：巴黎银行误操作导致破产。]]></content>
      <categories>
        <category>金融</category>
        <category>金融学</category>
      </categories>
      <tags>
        <tag>课堂笔记</tag>
        <tag>辅修</tag>
        <tag>金融学</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[金融学辅修——微观经济学笔记（四）]]></title>
    <url>%2Fpost%2F685bcc20.html</url>
    <content type="text"><![CDATA[长期成本曲线LTC，LMC，LMC 分别表示长期总成本，长期平均成本和长期边际成本。 曲线间的推导 成本理论的应用-1 产量分配 等边际效应解释，等边际成本时总生产成本最少。（导数证明） 成本理论的应用-2 污染控制]]></content>
      <categories>
        <category>金融</category>
        <category>微观经济学</category>
      </categories>
      <tags>
        <tag>课堂笔记</tag>
        <tag>辅修</tag>
        <tag>微观经济学</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[《不得贪胜》读书笔记]]></title>
    <url>%2Fpost%2Fab720150.html</url>
    <content type="text"><![CDATA[引言 人生如棋，不得贪胜《围棋十绝》 不得贪胜：越是对胜利存有贪念，越得不到胜利。 入界宜缓：穿越警戒线时要缓慢。 功彼顾我：向外攻击对方的时候要回首自身形势。 弃子争先：即使丢掉部分棋子也要抢到先手。 舍小取大：放弃小的利益追求大的收获。 逢危需弃：遇到危及情况要弃子。 慎勿轻速：不要轻率快速行棋。 动须相应：每步行棋需相互配合。 彼强自保：如果对方势力强大则需先谋求自身安全。 势孤取和：形势危孤则首选平和。 《围棋九品》 九品守拙：方式笨拙愚蠢，但是懂得这种守卫的方法。 八品若愚：笨拙但是懂得下围棋的方法。 七品斗力：拥有可以争战的力量，围棋下得有力。 六品小巧：懂得用小的技巧。 五品用智：下围棋时略表现出智慧。 四品通幽：下围棋时仿佛已经进入深奥的围棋世界。 三品具体：博采众长，了解围棋得远近。 二品坐照：坐着能够洞察整个围棋世界。 一品入神：下围棋到达神的境界。 “您认为围棋是什么？”当时我是这样回答的：“我认为围棋就是不断向远方前进。”现在我仍然是这么认为的。 第一章 成长 P010 “所以，直到现在，我还是个左撇子。我也记不清是从什么时候开始，我在下围棋的时候刻意用右手了，因为我得知用右手是‘对对方的尊重’，所以，没有经过痛苦的改正和纠结，我很自然地成为了两只手使用起来都很灵活的人。”P011 “能够这样快快乐乐、无忧无虑度过一个阳光的童年，真是我的幸运。因为在这样的环境下，我养成了看待整个世界和人生的积极态度，学会了用肯定的眼光审视周围的一切，乐观地看到事情充满可能的一面，并且从头到脚饱含着走向完美人生的力量。” 怎样的童年才是适合自己的？肆意增长？还是修剪枝叶？我个人认为李昌镐生来有着一份稚童不改的心，又很幸运的得到了适合他这种心境的教育。 P016 “进入了围棋这个成年人的世界，幼小的我内心充满着惶惑。在我眼里，围棋就是魔法的世界，围棋就是宇宙的中心。世界的所有秘密都被呈现在围棋中，而只要稍微开拓一下视野，那无穷无尽的变化就会滚滚涌现。在那如同迷宫般交错的横线和竖线上思索，然后每次解决困局找到新的棋路的欣喜，就如同发现天下至宝。” P038 “但是在第二次来全州与我对局时，老师改变了对我的看法。在第二次对局的时候，让子数和第一次一样，老师让我三子，但是内容却跟上次很不一样。在短短不过一个月的时间里，我好像从上次的对局中悟出了什么。我的这种样子让周围的人们感觉到了一种‘深入骨髓的力量’。老师也被那种不知道是什么东西的力量所吸引，最终接收我为弟子。” 虽然昌镐拜师后，总显得下棋迟钝、笨拙，复盘也不会。但是曹薰铉老师从未试图改变他的下棋方式，即便不甚满意，这就是大师识人、做事的不同吧。 P043 “你的围棋是由你自己的气质构成的。” 第二章 拼搏减少失误即为成功 P060 “这期间，我通过研究和老师的对局不断反推对局，推出了这样的结论：‘围棋竞技的胜利属于失误少的一方’。这便是我尽量回避对杀的本质原因。回避对杀并不是因为害怕对杀，而是害怕对杀过程中的诸多变化会导致不能预见的失误。” 温故而知新——复盘的力量 P070 “围棋有‘复盘’这样一位‘好老师’，如果你获胜了，那么复盘可以让你养成‘胜利的习惯’；如果你失败了，那么复盘可以让你做好‘胜利的准备’。” P070 “我虽然没有天才般的才能，但是我有持久力。我不断将失败的对弈重新复盘，找出失败的原因，类似于这样的努力我自认为比任何人付出得都多。持久力和努力是任何人都可以做到的。只要能不懈地努力，就再也没有必要害怕那些天生具有某些才能的人了。” 强迫观念，是李昌镐的特点，而对他在棋局上的发挥而言，则是一把双刃剑。 P073 “如果细究起来，从入段时开始，那支配我的心理，让我不知不觉开始‘认生’，开始寡言的根源，就是‘强迫观念’。在由成年人围成的藩篱中，我需要不停地辗转在心里给自己定下种种规矩，我就这样不知不觉变成一个‘老人般的孩子’。” P073 “强迫观念可以说是一把双刃剑。这里说的强迫观念并不同于医学上的那种精神疾病‘强迫症’，因为强迫观念并不是单纯地类似于疾病的坏东西。它包含着两个层面：一方面是不能控制强迫的症状而转变为精神疾病的危险；另一方面则是通过正确的方式和坚强的意志塑造出道德观念和责任感。” 并非单纯的授棋之师，更接近一种为人之师。石佛对老师的态度后来也体现在，婚礼上并没有邀请除老师和师母以外其他围棋界的同僚，其实老师出席本身就已经体现，他对于李昌镐，早已经不单单是围棋上的老师了。 P078 “在我的老师的思想中，老师的精神世界和一般人的层次应是不同的。它应该更接近于道人的世界。在我成为职业棋手之前，他就不断教导我要先学做人。而成为职业棋手继续围棋事业的过程中，他也不断向我强调做人的重要性。通过他的这些教诲，我隐隐感受到了他的为师之道。而他老人家也十分明白地向我展示了什么才是一个老师应有的作为。他曾说过：‘老师就是给弟子打开前行的道路。’回到韩国，收李昌镐为徒后，我便暗下决心：‘一定要按照老师的教会，践行他的为师之道’” 站在巨人的肩膀上，也应给予巨人足够的尊重，因为他原意将肩膀借给你，作为你腾飞的奠基。 P092 “这个世界上充斥着那些没有得到社会承认的天才。这就是世事的原则。而我这个无比犯上不敬的弟子，如果不是拥有了从老师那里借来的巨人的肩膀，飞向更高、飞向更远的这种动力又从何而来呢？” 第三章 腾飞不断地反复咀嚼过去，围棋是零和博弈，失败一方本什么都得不到，唯一的慰藉和不幸中的万幸就是可以在失败中探索，去研究，去向自己索取。 P099 “不断地回想自己的胜利是件开心地事情，但是将失败翻来覆去地研究，是给人巨大精神压力地工作。” “围棋不过如此，但我也只有围棋” P104 “围棋是全部。能够把并不轻松人生意义通过‘围棋不过如此，但我也只有围棋’这种轻松的言语表达出来，其中的哲学高度并不是每个人都能达到的。” P141 “自信真是一种奇妙的东西，有的时候它会带来足以压倒对方的气势，而有的时候，它便回越过应有的位置，成为向对方暴露要害的漫不经心。而在为其中，当必要的精密轰然倒塌时，自己的棋便无法再由自己掌控了。” 日本的经营学者中郁次郎在《战略的本质》一书中对战略这样分析：战略并不单纯指的是桌面上的作战计划，而是与对手的一种相互作用。 P144 “围棋是以战争为模型，双方较量战略的游戏。施行战略的最高指挥官必须对和战争相关的所有因素以及敌人所可能采取的行动进行细致精密的分析，全面分析过后才能确定最终行动方针。这个过程在围棋中便以布局、定式、中盘、终盘、封盘的过程一一展现。” 红皇后效应是指一个人在发生变化的同时，周围环境和竞争对手同样在变化，甚至变化的更快，自身的相对位置不升甚至有可能反而下降。 红皇后这样呼喊道：“就算是想保持原位不动也要拼命地奔跑才行！” P155 “变化是必然的。没有进步，保持原位不动就是退步。就算是苟然无目的地向前以动，也有可能出现发展的道路。拜托停滞不前的那第一部路，说不定就会成为前进的道路。” 第四章 危机 P184 “明知道有危险也要不顾一切冲上去并不能算是有勇气。能够克制住自己的冲动，拒绝外界的诱惑，默默地走自己的道路，这种选择才是勇气的表现。这时决胜点在于丧失忍耐力。” P184 “危机二字如同其字面的意思，危险和机遇是相伴相生的。” 让一个人安静独处，有时候是最好的关怀方式。 第五章 不得贪胜 P210 “赵治勋九段不顾人们含着泪的阻止，强行参加棋圣战的迫切意志，原来并不是源自于‘英雄的斗魂’，而是由于急于确认迷茫未来的这种人之常情。” 英雄往往是被媒体塑造的，但是英雄精神的内核往往就是被我们忽略的每个平常人都具有的特质，李敏镐眼里的赵九段，只是用最人性的方法来确认不安中摇摆的自己的存在，外人看来疯狂而决绝，其实这是事中人必然的做法。 5岁到日本学棋，并且就像前文提到的一样，对于赵九段，围棋就意味着全部，他只有围棋，如果被突然告知不能再下围棋了，无异于天降死刑，所以他不甘。 P211 “赵九段的这个故事，生动而又深刻地向我展示了一个事实，那就是迫切感也会成为一个人再面临胜负时的强大力量。” 迫切感可以化做力量，的确如此。]]></content>
      <categories>
        <category>阅读</category>
      </categories>
      <tags>
        <tag>阅读</tag>
        <tag>自传</tag>
        <tag>不得贪胜</tag>
        <tag>李昌镐</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[金融学辅修——金融学笔记（七）]]></title>
    <url>%2Fpost%2F3090aa13.html</url>
    <content type="text"><![CDATA[第四章 金融市场的利率继续之前课堂的内容 第三节 我国利率的市场化改革利率市场化进程 1996.6年放开银行间同业拆借市场利率 1997.6 利率机制：央行利率——银行利率——市场利率 阶段目标：“存款利率管上限，贷款利率管下限” 二元化的利率调控模式： 调整存贷款基准利率（上下限）影响金融机构存贷款利率水平 通过公开市场操作及各类中央银行利率引导市场利率 问题： 利率市场化步骤（利率市场化，交易品种丰富化；存贷款利率市场化；法律明确） 中国特点：政府推进型；渐进型；可控型；谨慎型 今后突破：贷款下限，存款上限。 古典学派的储蓄投资理论 利率是由储蓄函数和投资函数共同决定的，取决于]]></content>
      <categories>
        <category>金融</category>
        <category>金融学</category>
      </categories>
      <tags>
        <tag>课堂笔记</tag>
        <tag>辅修</tag>
        <tag>金融学</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[算法与数据结构学习——最小生成树]]></title>
    <url>%2Fpost%2F9d402b32.html</url>
    <content type="text"><![CDATA[引入在之前的学习中，我们已经介绍了图的储存方式等相关内容。 （这里待补坑） 数据结构课本上引入： “假设要在n个城市之间建立通信联络网，则连通n个城市只需要n-1条线路。这时，自然会考虑这样一个问题，如何在最节省经费的前提下建立这个通信网” 在含有n个结点的连通网中挑选n-1条边构造一颗边权和最小（耗费最小），这个问题就是最小代价生成树（Minimum Cost Spanning Tree）（简称最小生成树）构造问题。 定义补充关于图的几个概念定义： 连通图：在无向图中，若任意两个顶点vivi与vjvj都有路径相通，则称该无向图为连通图。 强连通图：在有向图中，若任意两个顶点vivi与vjvj都有路径相通，则称该有向图为强连通图。 连通网：在连通图中，若图的边具有一定的意义，每一条边都对应着一个数，称为权；权代表着连接连个顶点的代价，称这种连通图叫做连通网。 生成树：一个连通图的生成树是指一个连通子图，它含有图中全部n个顶点，但只有足以构成一棵树的n-1条边。一颗有n个顶点的生成树有且仅有n-1条边，如果生成树中再添加一条边，则必定成环。 最小生成树：在连通网的所有生成树中，所有边的代价和最小的生成树，称为最小生成树。 算法构造最小生成树有很多算法，但是他们都是利用了最小生成树的同一种性质： MST性质：假设N=(V,{E})是一个连通网，U是顶点集V的一个非空子集，如果（u，v）是一条具有最小权值的边，其中u属于U，v属于V-U，则必定存在一颗包含边（u，v）的最小生成树 性质证明： 反证法：假设网N的任何一棵最小生成树都不包含（u，v）。设T是连通网上的一棵最小生成树，当将边（u，v）加入到T中时，由生成树的定义，T中必存在一条包含（u，v)的回路。另一方面，由于T是生成树，则在T上必存在另一条边（u’，v’），其中u’∈U，v’∈V - U，且u和u’之间，v和v’之间均有路径相通。删去边（u’，v’），便可消除上述回路，同时得到另一棵生成树T’。因为（u，v）的代价不高于（u’，v’），则T’的代价亦不高于T，T’是包含（u，v）的一棵最小生成树，和假设矛盾。 下面就介绍两种使用MST性质生成最小生成树的算法：普里姆算法（Prim）和克鲁斯卡尔（Kruskal）算法。 2、普里姆算法—Prim算法 首先就是从图中的一个起点a开始，把a加入U集合，然后，寻找从与a有关联的边中，权重最小的那条边并且该边的终点b在顶点集合：（V-U）中，我们也把b加入到集合U中，并且输出边（a，b）的信息，这样我们的集合U就有：{a,b}，然后，我们寻找与a关联和b关联的边中，权重最小的那条边并且该边的终点在集合：（V-U）中，我们把c加入到集合U中，并且输出对应的那条边的信息，这样我们的集合U就有：{a,b,c}这三个元素了，一次类推，直到所有顶点都加入到了集合U。]]></content>
      <categories>
        <category>编程</category>
        <category>数据结构与算法</category>
      </categories>
      <tags>
        <tag>最小生成树</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[算法与数据结构学习——线索二叉树]]></title>
    <url>%2Fpost%2F4db7e28a.html</url>
    <content type="text"><![CDATA[引入在之前的学习中，我们能够感觉到，二叉树的非递归遍历需要用到栈结构的原因是需要之前遍历的信息。 以二叉链表作为存储结构时，只能找到结点的左、右孩子信息，而不能直接得到结点在任一序列中的前驱和后继信息，这种信息只能在动态过程中才能得到。 我们想保存这个信息，该怎么办？ 通过考察各种二叉链表，不管形态如何，空链域的个数总是多过非空链域的个数。准确的说，n个结点的二叉链表共有2n个链域，非空链域为n-1个，其中的空链域必定有n+1个。如下图所示。 实际上，我们可以利用好这些空链域来存放结点的前驱和后继信息。 线索二叉树1234567891011// 二叉树的二叉线索存储表示typedef enum PointerTag&#123; Link, Thread&#125;; //0 为孩子指针 1为线索指针typedef struct BiThrNode&#123; TElemType data; struct BiThrNode *lchild, *rchild; //左右孩子/线索指针 PointerTag LTag, RTag; //左右标识 线索化的实质就是将二叉链表中的空指针改为指向前驱或后继的线索。由于前驱和后继信息只有在遍历该二叉树时才能得到，所以，线索化的过程就是在遍历的过程中修改空指针的过程。遍历即线索化过程。 1234567891011121314151617181920BiThrTree pre; //表示遍历的上一点void InThreading(BiThrTree p)&#123; if (p) &#123; InThreading(p-&gt;lchild); //遍历左子树 if (!p-&gt;lchild) //当前点没有左孩子 &#123; p-&gt;LTag = Thread; //前驱线索标记 p-&gt;lchild = pre; //左孩子指针指向前驱 &#125; if (!pre-&gt;rchild) //前驱点没有右孩子 &#123; pre-&gt;RTag = Thread; //后继线索标记 pre-&gt;rchild = p; //右孩子指针指向后继 &#125; pre = p; InThreading(p-&gt;rchild); //遍历右子树 &#125;&#125; 中间代码做的事情： 对中间结点的左孩子判断（是否存在直接前驱），如果不存在的话左孩子的指针并不是空，而是指向保存的前驱结点。同时对前驱结点的右孩子判断（是否存在直接后继），如果不存在的话指向当前的结点。 如图： 完成前驱和后继以后，线索二叉树的遍历，实际上等于操作一个双向链表结构。 如图： 参考博客https://www.cnblogs.com/guweiwei/p/7090050.html http://blog.csdn.net/u014492609/article/details/40477795]]></content>
      <categories>
        <category>编程</category>
        <category>数据结构与算法</category>
      </categories>
      <tags>
        <tag>线索二叉树</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[金融学辅修——金融学笔记（六）]]></title>
    <url>%2Fpost%2Fe290dd8c.html</url>
    <content type="text"><![CDATA[课前小组分享资本市场和衍生品市场我国资本市场的发展历程探索阶段——成长阶段——协调发展阶段——深化改革依法治市阶段 股票市场股票发行和流通的场所，可以分为一级和二级：一级发行，二级流通。 职能：积聚 转让 转化 基本性质：不可偿还行 参与性 收益性（可以参与流通） 流通性（可以二次流通） 波动性和风险性 股票的分类： 股东权利分类：普通股，优先股，后配股 上市地区分类：A股，B股，H股（香港），N股（纽约），S股 按业绩分类：绩优股，垃圾股，蓝筹股 债券市场政府、企业、银行，到期还本付息的？？ 基本性质：偿还性，流通性，安全性， 企业破产时，债权人索取资产优先于股东 债券融资的优点和缺点： 优点：资本成本低，具有财务杠杆作用，所筹集资金属于长期资金，债券投资范围广 缺点：限制条件多， 衍生品市场远期、期货、互换、期权 是一种金融合约。XXX 远期合约 远期利率协议、远期外汇合约、远期股票合约。 相关风险：时间跨度大，不确定因素多，规模和持仓量都不如现期。 期货 期货交易分类：商品期货和金融期货。 最大的区别就是双向交易，可以买多也可以卖空。价格上涨时可以低买高卖。 互换 互换交易 非现金支付非现金支付分类票据，银行卡（信用卡，借记卡），网上支付。 非现金支付的前世今生 银联诞生，信用卡开启五现金支付第一步 交易场景变革。改革开放，难以满足线下大额交易。 支付产业变革 02年银联建立 创立了银联卡，提供线下清算服务。 电商时代来临，第三方支付问世 交易场景变革。互联网发展带动线上交易场景出现，电子商务时代来临。 支付产业变革。第三方支付，“支付宝”提出担保支付模式，虚拟账户概念，推动清算。 移动时代来临，再次变革进行中 移动端入口加入。 扫码支付迈向渗透线下场景的第一步 微信红包13年除夕开始发力，推动微信支付打破支付宝一方独霸的场面。 支付产业变革总结非现金支付的衍生价值 消费金融：推动消费金融向长尾客户的渗透。 财富管理：基于互联网的财富管理新模式，具有无限商机。 政府监管：互联网信息监管，可以减少洗钱等问题。 废县及支付的发展现状 我国： 1362.14亿笔，金额规模4024.56万亿元。70%支付比例。 国外 欧洲地区： 美国：信用卡支付比较发达，但是移动支付发展比较缓慢。 亚洲地区：新加坡提出“无现金”支付，日本看齐美国。印度发展过8%。 非洲地区：非洲肯尼亚，M-pesa。 中外非现金支付现状差异 具体方式不同：中国以移动支付为主，美国等以信用卡消费。 原因，中国没有信用卡消费的习惯和粘性。 现金 or 非现金 如果拒收现金，损害了人民币的法定地位。 垄断问题，政府参与系统问题。 P2P小额信贷 人人贷P2P平台，有钱需要理财和缺钱需要贷款，联络双方的一个平台。 投标，散标。 平台概况：8年，700多亿。 三倍于常规借贷，但是审核，到款快。 三条红线：资金池模式，非法集资，庞氏骗局模式。 第四章 金融市场的利率继续之前课堂内容 关于中国的Shibor（2007年1月4日对外公布） Shibor的定义 中国货币市场基准利率，是根据信用等级较高的银行报出的人民币同业拆除利率计算确定的算术平均利率。 由上海同业拆借中心进行计算和发布，因而命名为“上海银行间同业拆放利率”（Shanghai Interbank Offered Rate） Shibor报价行名单 中工农建交，Shibor报价行的职责：Shibor的报价每日提供基于市场情况的拆入、拆出的双边报价，并且 在当日货币市场的交易中，以其报价利率为基准。报价行的报价行为应是独立的，当日的报价不得在银行间相互参照。 如何得到Shibor 相关网站链接 http://www.shibor.org http://www.chinamoney.com.cn 利率掉期 第二节 利率的计算 单利和复利 单利：存贷期的各期只以本金乘以利率计算的利息 S=P+r*n 复利：指数 终值和终值洗漱 终值是用复利计算的一笔投资在某个时间获得的本利和。 S=P {(1+r)} ^ }n 与厨师本金P相乘的系数成为终值系数。 关于计息次数 常以年度百分率和一定的计息次数（如按月按天计息）表示，在哦同样的时间内。通常使用实际年率l 现值与贴现 现值（present value）与终值是相对应的概念。现值就是未来收益按照一定的贴现率贴现后的当前价值。 银行贴现：$PV=P-P \dot r \dot n$ 现金 = 本金（期满应还）-本金 × 利率 × 时间 扣除利息 = 本金 × 利率 × 时间]]></content>
      <categories>
        <category>金融</category>
        <category>金融学</category>
      </categories>
      <tags>
        <tag>课堂笔记</tag>
        <tag>辅修</tag>
        <tag>金融学</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[亚马逊AWS云计算讲座笔记]]></title>
    <url>%2Fpost%2F1dc46f40.html</url>
    <content type="text"><![CDATA[亚马逊历史1994年发展起来，除大中华区，电商巨头 云计算 AWS， Amazon Web Service 2006年成立 Gartner IT行业咨询公司 市场占有率：AWS 44.1%，2016数据， 正式演讲云计算的由来工业革命：两次对动力系统的革新 动力轴对比电网供电：稳定性，可调节性，初始投资，动力成本，可拓展性。 ？？So how about 云计算 第三次工业革命 企业IT系统：办公系统/CRM/ERP/生产销售管理招标建设运维模式：需求-&gt;招标-&gt;厂家选择-&gt;工程建设-&gt;系统运行维护-&gt;再需求 互联网产业带来新需求 新需求 超大规模 敏捷（Agile） Emmm该补功课了（新需求到新产品的滞后期） 互联网企业先有流量，再有变现。 变现途径：广告，增值服务，游戏，出租服务。 先有： 新需求-&gt;新技术-&gt;新思想-&gt;新组织模式 以变现作为驱动力： 技术扩散-&gt;云计算 案例分析云计算价值前例：AWS+JPL NASA卫星图像的分析，2小时 案例1：降低创新门槛 产品创新一套测试环境：6服务器+1交换机 传统模式需要2到6周时间 AWS云环境？（虚拟服务器配置） 案例2：弹性扩展 某电信行业软件巨头新功能交付：2~3月 需求分析与系统设计：4周 代码编写与单元测试：2~3周 系统回归测试：4周 测试结果是否和预期一致 确保软件稳定性：数十万测试用例 缩短交付周期：自动化测试；集中所有可用硬件设备并行测试 瓶颈：可用硬件设备有限，继续扩充利用率和成本有问题。 云计算的六个优势 Trade capital expense for variable expensive Benefit from massive economies of scale Stop guessing about capacity Increase speed and agility Stop spending money running and maintaining data centers Go global in minutes AWS的大数据和AI平台Amazon 平台可用的开源工具 数据价值递减曲线 《《待补充 最近的数据 非常有价值 如果你及时采取行动 旧的数据+新的数据 更有价值 如果你能找到联系他们的方法 Amazon 机器学习平台堆栈：应用服务API基础设施框架，平台服务，应用服务。 平台：Amazon SageMaker大规模构架，直接调优模型，调优算法 AWS Academy ProgramAWS Academy计划学期课程为一个一个学期，AWS Cloud Practitioner AWS Educate教育优惠 AWS 认证路径job market不错 开发者，系统管理员，架构师。 Dockers 容器 AWS Training andQ&amp;A 对于Amazon的认证 课程本身应该不是免费的。 Amazon本身需求在AWS的占比 可见比例，但是具体并不知道，另外还有Netflix在里面占有比较大的比例（全托管) 服务器征用，有可见选项 折扣比较低 对于中国云市场的整体看法 Amazon对于云计算在以后的拓展方向 最开始只有S3，对象存储。 云平台，信息安全问题 观念问题落后于实际问题]]></content>
      <categories>
        <category>讲座</category>
      </categories>
      <tags>
        <tag>讲座笔记</tag>
        <tag>AWS</tag>
        <tag>亚马逊</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Python学习——《FlaskWeb开发》笔记（一）]]></title>
    <url>%2Fpost%2F6cb7680e.html</url>
    <content type="text"><![CDATA[第一部分 Flask简介第1章 安装Flask有3个主要依赖： 路由、调试和Web服务器网关接口子系统由Werkzeug提供； 模板系统由Jinja2提供； 命令行集成由Click提供。 这些依赖都是Flask的开发者Armin Ronacher开发的。 原生不支持数据库访问、Web表单验证和用户身份验证，但是可通过拓展形式实现。 虚拟环境安装 pip install virtualenv Windows 注意修改PATH环境变量 第2章 应用的基本架构 初始化应用实例 所有来自客户端的请求都交由应用实例（Flask类对象）处理。 路由和视图函数 客户端（Web）浏览器把请求发送给Web服务器，Web服务器再把请求发送给Flask应用实例。 应用实例保存URL请求到Python函数的映射关系，处理URL和函数之间关系的程序称之为路由。 最简单的方法（app.route）装饰器： 123@app.route('/')def index() return '&lt;h1&gt;Hello World!&lt;/h1&gt;' index()这样处理入站请求的函数称之为视图函数，函数的返回值称之为响应，是客户端接收到的内容。 路由URL中放在尖括号里面的内容是动态部分，任何能匹配到静态部分的URL会映射到这个路由上，调用视图函数时， Flask会将动态部分作为参数传入函数 123@app.route('/user/&lt;name&gt;') # 任何匹配静态部分的URL都走这个路由def user(name): # 尖括号里的name作为参数传递进视图函数 return '&lt;h1&gt;Hello, &#123;&#125;!&lt;/h1&gt;'.format(name) 请求-相应循环 应用和请求上下文 请求对象封装了客户端发送的HTTP请求。方便使用，会通过上下文变为全局可访问。 上下文全局变量：current_app, g, request, session 请求分派 URL映射，路由。Flask为每个路由都制定了请求方法，这样即使不同的请求方法发送到相同URL上，也会 使用不同的视图函数来处理 请求对象 上下文变量request对外开放请求对象，包含全部信息。 请求钩子 请求钩子通过装饰器实现，四种钩子：before_request, before_first_request, after_request, teardown_request 响应 多数情况下，视图函数返回值作为响应内容。字符串，状态。response对象。URL重定向。 Flask扩展 第3章 模板模板是包含响应文本的文件，其中包含用占位变量表示的动态部分，其具体值只在请求的上下文中才能知道。使用真实值替换变量，再返回最终得到的响应字符串，这一过程称为渲染。Jinja2 变量 大括号两层括起来的部分就是变量，可以识别复杂类型，加过滤器（渲染时事变变换），如|capitalize, |lower ,|upper, |title, |trim, |striptags:. {{ name }} 表示name是等待视图函数传递的变量 eg &lt;p&gt; A value from a dictionary : {{ mydict['key'] }}, &lt;/p&gt; &lt;p&gt; A value from a list : {{ mylist[-1] }}, &lt;/p&gt; &lt;p&gt; A value from a dictionary with 过滤器: {{ mydict['key']|striptags: }}, &lt;/p&gt; 控制结构 条件判断 {% if user %} Hello, {{ user }} {% else %} Hello. Stranger {% endif %} 初步尝试 123456789101112131415161718192021222324252627282930313233343536&#123;% extends "bootstrap/base.html" %&#125;&#123;% block title %&#125;Flasky&#123;% endblock %&#125;&#123;% block navbar %&#125;&lt;div class="navbar navbar-inverse" role="navigation"&gt; &lt;div class="container"&gt; &lt;div class="navbar-header"&gt; &lt;button type="button" class="navbar-toggle" data-toggle="collapse" data-target=".navbar-collapse"&gt; &lt;span class="sr-only"&gt;Toggle navigation&lt;/span&gt; &lt;span class="icon-bar"&gt;&lt;/span&gt; &lt;span class="icon-bar"&gt;&lt;/span&gt; &lt;span class="icon-bar"&gt;&lt;/span&gt; &lt;/button&gt; &lt;a class="navbar-brand" href="/"&gt;Flasky&lt;/a&gt; &lt;/div&gt; &lt;div class="navbar-collapse collapse"&gt; &lt;ul class="nav navbar-nav"&gt; &lt;li&gt;&lt;a href="/"&gt;Home&lt;/a&gt;&lt;/li&gt; &lt;/ul&gt; &lt;/div&gt; &lt;/div&gt;&lt;/div&gt;&#123;% endblock %&#125;&#123;% block content %&#125;&lt;div class="container"&gt; &lt;div class="page-header"&gt; &#123;% if name == "ryx" %&#125; &#123;# 注意==符号还有 双引号 #&#125; &lt;h1&gt;Hello, 大哥 &#123;&#123; name|striptags: &#125;&#125;!&lt;/h1&gt; &#123;% else %&#125; &lt;h1&gt;Hello, 小老弟 &#123;&#123; name|striptags:&#125;&#125;! &lt;/h1&gt; &#123;% endif %&#125; &lt;/div&gt;&lt;/div&gt;&#123;% endblock %&#125;]]></content>
      <categories>
        <category>编程</category>
        <category>Python</category>
      </categories>
      <tags>
        <tag>Python</tag>
        <tag>Flask框架</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[金融学辅修——金融学笔记（五）]]></title>
    <url>%2Fpost%2F879e9655.html</url>
    <content type="text"><![CDATA[课前同学分享银监会和保监会 混业经营，灰色地带。 2018年3月人大表决通过，设立中国银行保险监督管理委员会，即银监会和保监会合并。4月正式挂牌。 小微企业的重要性 企业规模小，生命周期不长，缺乏质押品，信用记录不够完善。 阶段性成就： 银保监会措施: 更好的借贷：降低对小微企业的贷款抵押以来，缩短周期，满足小微企业的资金需求。 更好的考核：疏通货币政策的传导机制 银保监会的建议： 偏离主业，过度融资，高杠杆 去也自身的问题。 课堂知识信用与中小微企业融资普惠金融（额外内容）普惠金融的背景、意义、界定、现状等等 章前引言：十九大报告之——建设现代化经济体系 六大任务 深化供给侧结构性改革 加快建设创新型国家 实施乡村振兴战略 实施区域协调发展战略 加快完善社会主义市场经济体制 推动形成全面开放格局 根据乡村振兴战略的目标发展而来 章前引例实施乡村振兴战略的四大经济手段： 发展多种习惯是适度规模经营 培育新型农业经营主体 促进农产品一二三产业融合发展 支持和鼓励农民就业创业 三农市场潜在金融产品和服务需求： 农业季节性生产特征。（农忙时节） 发展的困难，供给不足的障碍： 缺乏盈利记录和交易信息，难以纳入评估体系 缺乏可靠的抵押物品，难以得到传统信贷业务覆盖。 征信问题 地理分散，增大负担 小微、三农 联合国定义： 能有效、全方位为社会所有阶层和群体，提供服务的金融体系。 第四章 金融市场的利率金融市场的利率 利率与利率的含义/利率的计算/利率市场化/利率理论/利率期限结构 第一节 利率与利率的含义基准利率——金融市场体系中的中枢神经 美国联邦准备金率——同业拆借利率 基准利率必须是市场化体制下产生的利率： 原则：相关性、可测性、可控性、灵敏性。 伦敦同业拆借利率（Libor） 利率-利息率 指借贷期间所形成的利息率额与本金的比率。反映利息水平的高低，一种重要的经济杠杆。 利率体系：（利率的种类） 市场利率与基准利率。名义利率与实际利率 r=i+p r=(1+i)(1+p)-1 固定利率与浮动利率（浮动利率提前签好，3%；LIBOR+-0.3%） 市场利率与官定利率 一般利率与优惠利率 平均利率、基准利率和到期收益率 Shibor ？？？？？？ 利率掉期 利率掉期示意图 兴业银行和花旗银行 最明显的问题 327国债期货]]></content>
      <categories>
        <category>金融</category>
        <category>金融学</category>
      </categories>
      <tags>
        <tag>课堂笔记</tag>
        <tag>辅修</tag>
        <tag>金融学</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[金融学辅修——微观经济学笔记（三）]]></title>
    <url>%2Fpost%2Fdf76d545.html</url>
    <content type="text"><![CDATA[承接上一篇 第二章 需求、价格与供求关系第六节 需求弹性和供给弹性待补充 影响需求的价格弹性的因素 eg：禁毒增加还是减少了与毒品相关的犯罪 需求弹性小，供给弹性大。 禁毒是控制供给。 控制需求更为重要，反毒品教育是控制需求。 互补、替代 需求量：互补商品反向变化，替代商品同向变化。 需求的收入弹性 Em&gt;1，Em=1，Em&lt;1，Em=0，Em&lt;0（劣质物品，吉芬品） 恩格尔系数的弹性概念解释 第七节 运用供求曲线的事例 价格政策 Price controls 价格调节有其不完善性，需要价格政策来支持。短期性和无序性 支持价格【最低限价】（Price Floor） ：政府为了保护或者扶持某个行业而出台的产品最低价格。 支持农产品的作用：稳定农产品，调整农业结构。 （属于宏观调控，防止市场调节的滞后性） 最高限价总是高于市场的均衡价格。目的往往是抑制某些产品的价格上涨，尤其是为了应对通货膨胀。 最低限价总是低于市场的均衡价格。目的往往是扶持某些行业的发展。 价格上限的弊端 价格水平低不利于刺激生产。 限制价格的弊端 一般在战争或者自然灾害时期使用。 政府税收对均衡价格的影响 从量税与从价税：从量税根据商品销售数量征税；从价税根据商品销售收入征税。 对消费者征税，需求曲线左移。对生产者征税，供给曲线左移。]]></content>
      <categories>
        <category>金融</category>
        <category>微观经济学</category>
      </categories>
      <tags>
        <tag>课堂笔记</tag>
        <tag>辅修</tag>
        <tag>微观经济学</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Python学习——《笨方法学Python3》笔记（一）]]></title>
    <url>%2Fpost%2F6e80eb1e.html</url>
    <content type="text"><![CDATA[习题1~习题22学了什么 格式化字符串: 12w = f"What I want is &#123;you&#125;."# 此处you为变量名，格式化字符串会用变量替换对应的位置 字符串填充： 1234w = "What I want is &#123;&#125;."w.format("R") # 或者其他变量# 通过字符串的format方法填充对应位置# '+'可以用来拼接 print() 1# 缺省最后一个参数 end='\n' ，默认是换行 引入模块（库） 1234from sys import argvscript, file_name = argv# 解包# argv[0]为程序运行的名称，后面变量在命令行中输入，个数需要匹配，否则报错 文件操作 1234567891011# oepn()第一个参数为字符串，是文件名，第二个参数操作方式，缺省为"r"只读# open()的返回值为一个文件对象file_name = "eddy.txt"target = open(file_name, "r")in_data = target.read() # 读取内容target.close() # 最后要关闭file_name = "eddy.txt"in_data = open(file_name, "w").write("Well, Allright")# 'w'写入# 这种操作写入完成后会自动关闭文件，无需再写close（而且也不知道咋写，没名字） 习题23~习题39循环、列表与字典循环 123456# 少用while多用for，尤其是已知循环次数的时候for i in range(3,5)# range 左闭右开for i in change# change为列表，后面会介绍# for虚幻的时候i就被定义了，每次碰到则赋值为当前循环的元素值 列表，有的地方叫做数组，这里按照python的习惯说法称之为列表。列表支持按照角标随机访问。 12345678_count = [1,2,3,4,5]fruits = ['apples','oranges','pears','apricots']change = [1,'pennies',2,'dimes',3,'quarters']# 列表添加末尾（类似push_back）new_word = 'new'change.append(new_word)# 列表中的列表，二维列表[[1,2,3],[4,5,6]] 字典（类比C++STL里的map）实际上就是映射，不过这里不用在乎类型。 123456789# 注意大括号states = &#123; 'Oregon': 'OR', 'Florida': 'FL', 'New York': 'NY'&#125;# 对于字典的循环for i,j in list(states.items()): print(i,j) 字典的get方法（尤其注意第二个参数的缺省值） 123456789101112# 描述# Python 字典 get() 函数返回指定键的值，如果值不在字典中返回默认值。# 语法# get()方法语法：dict.get(key, default=None)# 参数# key -- 字典中要查找的键。# default -- 如果指定键的值不存在时，返回该默认值值city = cities.get('TX', 'Does Not Exist')# 所以书目中cities字典中虽然没有键值为'TX'的映射，但是设置了未查到的返回值。 此时city的值为'Does Not Exist' 关于切片 多说点如此，我们会得到从starting_index对应元素开始，到ending_index对应元素结束，但是不包括ending_index对应元素，所组成的子序列的内容。起止索引都是可选的选项，如果没有提供或者为None，那么开始索引默认为0，结束索引默认为序列最末尾的索引。切片的访问模式，有第三个值，类似于步长，其访问类似下面代码 12345&gt;&gt;&gt; ('a','b','c','d')[0:3:2]('a', 'c')food='appale pie'print(food[-3:7]) 后面，-3其实是6的位置 12345678910111213141516171819202122232425262728293031323334353637383940414243import numpy as npa = np.array([[-1,2],[2,3]])b = np.array([[3,4],[4,5]])print '\n a:\n',aprint '\n b:\n',b##转置print '\n a transpose:\n',a.T##共扼矩阵#print '\n a H:\n',a.I##逆矩阵print '\n a inv:\n',np.linalg.inv(a) # 求逆##转置print '\n a transpose:\n',a.T# a + b，矩阵相加print "\n a+b: \n",a+b# a - b，矩阵相减print "\n a-b: \n",a-b#2x2 矩阵，矩阵相乘print "\n a mul b:\n",a.dot(b.T)#2x3矩阵，矩阵点乘print "\n a dot b: \n",a*b#2x3矩阵，矩阵点除print "\n a/b \n:",a/np.linalg.inv(b)#求迹print "\n a trace",np.trace(a) #特征，特征向量eigval,eigvec = np.linalg.eig(a) #eigval = np.linalg.eigvals(a) #直接求解特征值print "\n a eig value:\n",eigval,print'\n a eig vector:\n',eigvec]]></content>
      <categories>
        <category>编程</category>
        <category>Python</category>
      </categories>
      <tags>
        <tag>Python</tag>
        <tag>笨方法学Python3</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[《金融的本质：伯南克四讲美联储》读书笔记]]></title>
    <url>%2Fpost%2Fbea42f1e.html</url>
    <content type="text"><![CDATA[第一讲 美联储的起源与使命本讲先说说中央银行的定一、职能、以及他是符合在美国出现的，我还会介绍美联储如何应对其第一次重大挑战，即20世纪30年代的经济大萧条。 第二讲中，回顾二战后美联储的发展状况、80年代如何战胜通胀，格林斯潘任期内的“大缓和”时期，以及1945年后发生的其它一些变化。危机如何形成，以及导致08~009年经济危机的部分原因。 第三讲中，近期发生的事件，此轮金融危机最严重的阶段，危机发生的原因和后果，还有美联储褐其他政策制定者对危机的应对等。 第四讲中，危机的后果，危机后的经济衰退和美联储的应对措施（包括货币政策），以及金融监管方面的变革。此外，还会对金融危机如何改变央行的运作方式，以及美联储未来会如何运作，进行一些前瞻性的讨论。 央行是什么中央银行的职能，第一个是维持宏观经济稳定，即追求经济稳定增长，避免大幅度波动（如衰退等），并维持低通胀，经济稳定只能。另一个职能，也是这一系列讲座重点探讨的一个功能，就是金融稳定职能，中央银行要尽可能保证金融系统的正常运作，尤其要尽可能防止金融恐慌，避免发生金融危机。 稳定经济方面的工具主要是货币政策：公开市场买卖证券来降低或提高短期利率，调整隔夜拆借利率。 应对金融恐慌的工具主要是流动性供给：短期信贷平息市场情绪，维持金融机构稳定性，“最后贷款人”工具。 第三个工具是金融监管：评估，非中央银行独有。系列讲座不予以详谈。 什么是金融恐慌 P007 “总体来说，金融恐慌是由大家对金融机构失去信心而引起的。” P009 “如果金融机构持有期限较长的非流动性资产——非流动性意味着出售这些资产（如贷款）需要花费相当多的时间和精力，而支持这些资产的资金（如发放贷款的资金）却主要来自资产负债表另一侧的短期负债（如储蓄），那么金融恐慌随时都有可能发生。” 关于央行职能和相应政策，白芝浩。 P010 “在恐慌时期，中央银行应大量放款，只要找上门来的人有抵押物，就可以放宽给他，中央银行需要持有安全的抵押物，以确保能收回贷款，因此这些抵押必须是优质安全的，否则贷款时就必须带着计算。当然中央银行还应征收惩罚税率，这样人们才不会利用这种恐慌局势来占便宜。人们愿意支付较高水平的利率，这表明他们确实急需现金。” 金本位的利与弊南北战争结束到20世纪30年代，美国实行的一直是金本位制。 P013 “真正的金本位制会创造出一个自我管理的货币体系，而这样的货币体系至少能部分替代央行的职能。” P013 “不幸的是，金本位制还远非完善的货币体系。比如，金本位制造成了极大的资源浪费，从一处地下（开采处）转移到另一处地下（美联储），除此以外，实际表明金本位制还会导致许多更严重的金融及经济问题。” 金本位带来的还有：央行货币政策工具受到限制，国家间固定汇率体系，投机冲击。 美联储的起源 P017 “1913年，在所有研究全部完成以后，国会终于通过了《联邦储备法案》，奠定了美联储成立的基础，威尔逊总统把签署《联邦储备法案》看作自己执政期间最重要的国内政治成就。” 之前有过两次尝试，但是由于以商业街为代表的普通民众和以华尔街为代表的资本家之间存在重大分歧，即美联储是否能代表整个国家的利益，前两次尝试均以失败告终。 威尔逊总统通过在各城市分散建立12个联邦储备银行，而非在华盛顿建立一家中央银行，解决了两大群体的主要纠纷。12个联邦储备区，其中每一个区都有一家联邦储备银行。华盛顿的联邦储备委员会监管着整个系统。 P019 “当美联储制定货币政策时，它会考虑整个国家所有联邦储备银行的意见，再在国家层面上制定相关政策。” 美联储的第一次大挑战面对“大萧条”，美联储在这个时期做了什么呢？不幸的是，当首次面临此类重大挑战时，美联储无论是在货币政策还是在金融稳定方面都表现得不尽如人意。原因有很多，防止股市投机，信奉清算主义，维护金本位。 最后贷款人方面，也对银行业挤兑现象反映不足，致使大量银行破产，这种反应迟钝很大程度上还是因为对清算注意的认同。 P027 “尽管罗斯福采取的许多措施并没有奏效，但在我看来，他有两项工作确实有效解决了那些由美联储造成的问题。第一项就是于1934年建立了联邦存款保险公司。从那以后，即便银行倒闭，普通储户仍然可以拿回自己的钱，这样他们就没有动机再去银行挤兑了……罗斯福做的另一件事就是废除了金本位制。废除金本位制后，他允许放松货币政策，扩张货币供给，这就结束了通货紧缩，使经济在1933到1934年间经历了一个短期的有力反弹。” 罗斯福的上述两件措施，根本上解决美联储未尽责而造成或者加重的问题。 应对首次挑战时两大职能未尽其力，当后来的危机以及2008到2009年的金融危机到来时，我们应该牢牢记住这些曾经的教训。 对话 紧缩货币政策防止股票投机的探讨，如何正确应对泡沫？ P028 “我们当然知道资产价格泡沫十分危险，也想尽可能地化解这些泡沫。但若要通过金融监管途径来解决， 那就应该采用更具针对性的解决办法，而不仅仅是提高利率水平这种带有普遍杀伤力的方法。调整保证金要求的方法 就好得多，因为至少还可以根据业务的不同制定不同的标准。” 回归金本位制有可能吗？ 金本位制从长期看可以保持价格稳定，解决通胀问题，但是短期的金矿开采等各种事情都会导致波动，逐年看就不正确了。 P029 “我认为无论从实践还是政策角度来看，金本位制都不可行。在实践方面，一个很简单的事实就是，黄金总量不足以 支持整个国际金本位体系……如今，经济史学家们认为，工人运动在‘一战’后更加强大，使得政府 对失业开始有了更多的担忧，19世纪之前，人们甚至都不会去衡量失业率，但是‘一战’后，人们开始 更多地关注失业和经济周期。” 承诺金本位制就等于承诺无论失业情况多糟糕，央行都不会采取货币政策干预。不现实也是不可能的，而且民众会因 怀疑而拿现金换黄金，从而引起冲击。 关于“大萧条”期间的二次衰退，和我们该注意的问题？ 未被普遍认可的说法，“大萧条期间”有过两次经济衰退：分别是1929至1933年和1937年至1938年。第二次衰退是由于 政策转向过早，收紧财政和货币政策导致的，当然同期还有其他事情的影响。 “大萧条”期间为什么没有更多的全球性合作？ “一战”留下的不良情绪，德国正面临不得不支付战争赔款的处境，英法在战争债务上一直有政治，国际政治环境糟糕， 并没有理想的合作空间。 P034 “同时，对于实施固定汇率的国家来说，国家间的央行合作更为重要，20世纪20年代，各国因为金本位制形成了 固定汇率体系，这就意味着一国货币政策将影响到其他国家。这是个关于央行非常有必要进行国际合作的很好的例子，但 这种合作并没有出现。” 当然在今天的灵活汇率制度下，作者认为这种合作是非常必要的。 第二讲 “二战”后的美联储货币政策与通货膨胀 P038 “‘二战期间’，美联储与财政部‘合作’，利用自身管利率的职能，使利率保持在低位，从而帮助美国政府以较低成本为“二战”筹资。这就是美联储在二战中扮演的决策。” 如果一国利率长期维持在低水平，尤其是经济增长和复苏时仍是如此，就可能造成经济过热和通货膨胀。 1951年美国财政部与美联储签署《美联储——财政部协议》，这一协议的重大意义在于使美国政府第一次承认央行（美联储）的独立运行。 P039 “特别是，一个独立运行的央行可以不去理会短期的政治压力，例如为了选举而被迫刺激经济。这样一来，独立的央行就可以采取一些立足长远的举措并且能取得更好的效果。这方面的证据是相当充分的。所以，独立运行是世界各主要央行的典型特征，这意味着它们所做的决定不会受短期政治压力影响。” 20世纪60年代后期和70年代初期，美国财政政策总体上过于宽松。越南战争和其他政府计划增加了政府支出和赤字，使得美国经济雪上加霜。 P042 “我要讲的另一个问题是工资——物价管制政策。在20世纪70年代初期，当通货膨胀率上升到约5%时，理查德·尼克松总统引入了工资——物价管制政策，通过颁布一系列法律，禁止企业提高它们的产品价格。” 实际上即是通过行政手段，破坏了需求对价格的影响（微观），人为限制。 价格是经济的温控器，是经济赖以运行的机制。所以，管制物资和物价意味着整个经济体系存在短缺及其他各种问题。 P043 “除此之外，正如弗里德曼所说，这项政策就像通过破坏温控器来调节一个过热的炉子。事实上，最根本的问题是需求总量太大推高了价格，简单地通过一项法律来禁止涨价并没有解决货币政策过度宽松和需求过大的根本问题。” 沃尔克的铁腕政策虽然带来了短期（80年代初期）的副作用，即高失业率，但是把通货膨胀水平大幅度压低，经济增长恢复到正常水平，经济形势稳定，国民对政府更加信任，奠定了格林斯潘上任后“大缓和”时代的基础。 金融危机的前奏信贷门槛降低，抵押贷款质量降低，房价大幅上涨，住房抵押贷款清偿率上升。 房地产泡沫的破灭 P056 “房价崩盘造成了一系列严重的后果。其中之一就是，很多人因为他们的房子价格上涨、手上有很多股票而觉得自己非常富有，但突然发现房价和股票都缩水了，这意味着他们抵押贷款欠的钱已经大大超过房屋的价值。情况颠倒过来了，借款人的房产实际上已经是负责产。07年开始房屋抵押贷款的数字呈现负资产的状况变得越来越明显。” 导致房价暴涨暴跌并演变成严重的经济危机德原因，既存在于私人部门，也存在与公共部门。 私人部门： 借债过多，杠杆过度，人们过于自信，风险保护措施不够。 短期融资方式受到偏爱，但这些负债容易遭受挤兑。 投入到风险管理的信息技术和资源不足以帮助人们意识到风险存在和严重程度。 公共部门： 监管未能与时俱进，具体以美联储为关注点来说，一是在监管银行和银行持股公司时，对风险的计量做得不够。二是消费者保护上做得不够好，没有向住房抵押贷款人提供必要的保护。 缺少对整个系统的监管，多数只是关注经济系统的某个部分。 争议性话题——货币政策的作用： 通过低利率刺激房地产需求？说法的合理性待定，几个驳斥的理由： 其他国家/地区的房价降低与飙升和利率的高低并没有太大关系，对于拥有相同中央银行的德国和西班牙，德国危机期间，房价维持的很好，西班牙房价的激增却远超美国。 泡沫大小，并没有表现出与利率变化有较大的关系。 泡沫的时机，一些经济学家的研究认为，泡沫开始于利率调低之前，而且房价激增的一部分原因还来自于国外对于安全美元资产的需求。 对话 上一讲中提到“大萧条”时期政策收紧的太早，那么如何判恰当时机？是只有一个恰当的时机还是时机一直在变？ 预测时机很难，这也是美联储要拥有如此之多的经济学家和模型的原因。预测并不是非常准确，尤其是20世纪70年代，预期 不受任何限制，归功于沃尔克和格林斯潘，在通胀率保持较低水平的情况下，美联储有更大余地，即使一段时间内政策宽松， 也不会陷入工资和物价交替上涨的恶性循环，预期会变得明朗一些。 如果01年时您是美联储主席，您会让利率保持在那样低的水平上吗？您认为当时那样做是正确的吗？ P069 “总之，适当的运用货币政策是能实现宏观经济整体稳定的，但也不能忽视金融失衡。 我认为美联储本可以在监管上表现得更为激进，以确保发起的贷款具有更高的质量。” 低利率会导致私人投资者和银行面临更大的风险，您认为这会不会触发危机？ P071 “这个问题很好。我认为低利率对投资风险加大有一定的影响，但是这有涉及经济平衡的问题，在经济衰退阶段，总的来说， 大多数投资者变得非常谨慎，过去一段时间当然也是如此。人们想要让风险大小合理，不多不少，这需要金融监管 发挥作用，尤其是对大型机构（例如银行）直接监管以确保其风险管理得当。这又回到了‘用合适的政策工具来达成目的 ’上来。” 21世纪初，您在关注经济走势时认为在房价泡沫积累之后会发生什么？您是否认为这将最终导致一次经济衰退。 曾在白宫任经济顾问委员会主席时，分析了房价下跌的后果，当时的结论：虽然会导致衰退，但没有预料到 会对金融体系的稳定性产生如此深远的影响。 主要原因还是在于房价下跌于01年股票市场下跌表现得并不一致，房价下跌影响抵押贷款彻底暴露出金融体系 的一些漏洞，以影响住房抵押贷款的方式破坏了金融体系的稳健性，造成恐慌，而恐慌情绪又会加剧金融体系的不稳定性。 所以整个事件链条至关重要，并不仅仅时房价下跌，而是整个链条。 体系的崩塌，而非单一泡沫的破裂。 第三讲 美联储应对金融危机的政策应对金融体系的漏洞 政府支持型企业——房利美和房地美的漏洞。自身资本充足率不够，持有缺乏担保或者不受保护的住房抵押贷款。 金融衍生品的泛滥一些奇特的住房抵押贷款，通常是为哪些信用水平较差的人提供的，共同特征就是建立在房价保持上升态势之上。例如： 只付利息的浮动利率住房抵押贷款； 含权浮动利率住房抵押贷款（允许借款人改变其每期的还款额）； 超长期的住房抵押贷款（贷款期限超30年） 负摊销浮动利率住房抵押贷款（首付甚至可以低于当期利息）； 无信用证明的住房抵押贷款。 应对危机的举措08年经济危机后，七国集团例行峰会在华盛顿举行，这次会议没有按照以往的惯例来进行，与会人员一直在讨论该如何应对金融危机。 这次会议拟定了一份原则声明，根据这些原则，各国将会共同采取措施来避免那些具有系统重要性的金融机构破产。 P095 “根据‘白芝浩原则’，缓解2金融恐慌的最佳方式就是为那些缺乏资金的机构提供流动性。但是，美联储发放的所有贷款都是需要抵押担保的，不能拿纳税人的钱当儿戏。最后，资金不仅流向了银行部门，而且更为广泛地流向了整个金融体系。这些政策和措施的目的是增加金融体系的稳定性，使信用再次流动起来。需要强调的是，中央银行作为最后贷款人的这一职能已存在了数百年，只是与传统的银行环境相比，它现在面临的体制环境发生了变化。” 金融危机期间，从最后贷款人理论的视角来看，尽管金融产品公司令美国国际集团严重亏损，但作为世界上最大的保险集团，后者还拥有大量的优质资产。因此，它可以通过将其优质资产抵押给美联储而获得贷款，以补充流动性，维持日常运营。 以优质资产作为抵押，美联储发挥最后贷款人的功能，为其提供了850亿美元的贷款。 一些企业大以致于不能倒。 对话 奇异住房抵押贷款等衍生品数量持续增长，为什么会给信用状况很差的人放贷？如果预见了房价下跌，还会发放吗？ 对房价上涨的背景下，这种抵押贷款算不上劣质品，人们对于“房价会持续上涨”太过乐观。这是原因之一。 另一个原因是，对资产证券化产品的需求在此期间大幅增长。国际客户大量需求，“精明”的金融机构把 资产捆绑装饰打包后，创设AAA评级证券，出售。 P110 “金融市场上出现的种种倾向：金融机构对自身风险管理能力过度自信，人们坚信房价会迟旭上涨， 银行认为抵押贷款可以轻易转售出去，国际客户对‘安全性’资产存在大量需求。出于上述这些原因，如果 房价确实能持续上涨，那么提供次级住房抵押贷款就是一项利润可观的金融业务。只有当房价下跌时，这项 业务才可能会出现亏损。” “大而不倒”，那么对银行施以援助或任其倒闭的界线在哪里？美联储的这种决策是随机的，还是有一套明晰的行事规则？ P115 “这些机构是在全球金融危机背景下才呈现出‘大而不倒’特性的。我们做出‘大而不倒’的判断 是基于这些机构的规模、复杂性和相互关联性等因素。我们从来不认为这是件好事。金融改革的主要目标之一 就是破除‘大而不倒’的怪圈，因为它的存在对整个金融体系不利，对这些机构本身也不利。从许多方面来讲 ‘大而不倒’现象都是不公平的。但在当时的情形下，我们不得不做出如此选择，因为在众多可选方案中， 这是危害性最小的一个方案。” 对一些系统重要性金融机构逐步要求具备额外资本，以及对于影响金融体系稳定性，可能会产生一家系统重要性 银行的并购，也很可能不会被批准。 第四讲 危机的后遗症扑灭金融危机之火关于“大规模资产购买计划”，即所谓的“量化宽松”。 P128 “为什么美联储要购买这些资产呢？戍边插一句，这是米尔顿·弗里德曼和其他货币学派学者所提到的，他们的基本观点是，当你购买国债或者政府支持型企业证券并把它们写进资产负债表时，市场中可供应的同类证券就减少了。如果投资者想要持有这些证券，就必须接受较低的收益率。换句话说，如果市场中可供应的同类证券减少了，投资者就会原意为这些证券支付更高的价格，这与收益率是相反的。” P129 “因而，通过购买国债、写入资产负债表、减少这些国债的有效供给，我们有效地降低了长期国债和政府支持型企业证券的利率。而且，当投资者的投资组合中不再有国债和政府支持型企业证券时，他们就不得不转向其他类型的证券，比如公司债券，而这将提高其他证券的价格，降低其收益率。所以，这些行为的净效应是降低大范围内证券的收益率。通常，较低的利率对经济增长具有有益的刺激效应。” 实际上可以看作另一种货币政策：我们聚焦在长期利率，而不是短期利率上。但是，这里的基本逻辑是一致的，都是降低利率，刺激经济增长。 政策的指引者大规模资产计划并非真正意义上的花钱，算不上政府开支。资产，在未来的某个时间点会出售给市场，所以这些花销会赚回来（在资产负债表上存在一段时间）。事实上，不花钱，不增加赤字，这个项目还可以从持有的证券上获取利息，这些利润直接减少了财政赤字。 财政政策：联邦政府支出和税收的工具。 货币政策：美联储对利率的管控相关。 美联储已经开始为投资者和公众提供指引，告诉市场认为的利率走向，期望市场更好的理解美联储的计划，从而减少景荣市场的不确定性。 缓慢复苏现在看来，保持金融稳定与保持货币政策和经济稳定显得同等重要。诚然，美联储回到了最初的起点。要知道，美联储的创建就是为了试着减少金融恐慌的影响范围；金融稳定是建立美联储的初衷。因此，现在我们兜了一圈又回到了原地。 对话 对金融稳定的重要性理解不深的美国人来说，花钱救助银行的行为非常不受欢迎，您是否看到了美国公众和华尔街在对问题的认识上也无法达成一致？ 美联储正在通过更多的推官活动，比如新闻发布会以及其他途径，试图解释其所作所为。让外界能更好的 理解美联储的政策用意，这个任务是必要而且艰巨的。 对于逐步退出大规模则产购买计划，如何确保投资者未来原意重新买入这些资产？ 还没有理解，待后续填坑。 您在讲座中提到了在“大萧条”以及日本通货紧缩的危害，以及将目标通货膨胀率设定在零以上的论据之一就是给通货紧缩的可能性提供缓冲。您认为2%是防止通货紧缩的一个足够缓冲吗？您是否考虑过更高的通胀目标 P154 “这个问题太棒了！对此已有很多学术研究，似乎国际共识是2%。几乎所有设定了通胀目标的 中央银行不是将之设定为2%，就是1%~3%或类似水平。而且这里有个权衡的问题。原因是，一方面正如你所言， 是为了避免或者减少通货紧缩的风险而将之设定为大于零。然而另一方面，如果通货膨胀率太高，市场 就会出问题，经济体的效率会下降。总之，权衡之处在于合适的通货膨胀水平既给了你对抗通货紧缩的合理 缓冲，又不至于太高而导致市场运转不灵。因此如前所述，国际共识是2%左右，这也是长期以来美联储的 非正式目标。这就是我们所公布的目标，在可见的未来我们也计划保持现状。但显然研究者们仍然会 探究这个议题，试图准确定位最优的平衡点。”]]></content>
      <categories>
        <category>阅读</category>
      </categories>
      <tags>
        <tag>阅读</tag>
        <tag>演讲</tag>
        <tag>本·伯南克</tag>
        <tag>金融的本质</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[金融学辅修——微观经济学笔记（二）]]></title>
    <url>%2Fpost%2F92687617.html</url>
    <content type="text"><![CDATA[第二章 需求、价格与供求关系需求曲线 需求 Demand：在一定时期内，各种可能的价格水平，人们愿意并且能够购买的商品量。 需求表，函数关系，来表示价格与需求量的关系 需求曲线 绘制：横轴需求量，纵轴价格 一条向右下方的曲线。 需求分类 个人需求曲线与市场需求曲线：市场需求曲线由个人叠加，个人的较为陡直，市场的较平坦（对价格变化更加敏感） 需求定理 需求需求的因素 商品本身的价格 相关商品的价格 消费者的收入及社会分配的公平程度 消费者爱好（嗜好） 消费者对未来的预期 需求定理的特例 吉芬物品 Giffen’s Goods：需求量于价格成同向变动的特殊商品。 饥荒时期的土豆 炫耀性物品 Consipicuous Goods： 特例总结 曲线上端回归：稀有物品（古书，名画），预期紧俏的商品。 曲线下端回归：吉芬物品，吃紧时，随价格上升需求量增加。 S曲线：原本不值钱物品值钱了，原本不值钱的值钱了。 横线，价格一定，需求无限大： 竖线，需求一定，价格无限：军需物品。 供给曲线 供给 ：在一定时间内各种可能的价格原意而且能够提供出售的该种商品的数量。 需求曲线 绘制：横轴供给量，纵轴价格。 一条向右上方的曲线 单个厂商的供给曲线对比市场供给曲线：市场供给曲线更加平滑（纵轴价格不变，横轴供给量叠加）供给定理 影响供给的因素 厂商的目标 厂商对未来的预期 商品本身的价格 相关商品的价格（替代品，互补品？） 生产要素的价格（商品本身价格不变，成本上升会使利润减小，供给量下降） 生产技术的变动（一般情况下，生产技术水平的提高可以提高劳动生产率，从而降低成本，增大产量） 需求函数与供给函数数学表达 D=f(a1,b1,c1,d1...n1) a1,b1,c1,d1...n1代表影响需求的因素 理想情况 Qd=f(P) 关于价格的一元函数 S=f(a2,b2,c2,d2...n2) a2,b2,c2,d2...n2代表影响供给的因素 理想情况 Qs=f(P) 关于价格的一元函数 价格的变化体现在沿曲线的滑动，除商品自身价格以外的这些其他因素变化所导致的市场需求（供给）数量的变化通常称为需求（供给）的变动。几何图形中，表示为曲线的平移 消费者剩余和生产者剩余？？ 均衡价格供给曲线和需求曲线的交点，此时达到市场出清的状态。 供求定理：在其他条件不变的情况下，需求变动分别引起均衡价格和均衡数量的同方向的变动，供给变动引起均衡价格的反方向的变动，引起均衡数量的同方向的变动。]]></content>
      <categories>
        <category>金融</category>
        <category>微观经济学</category>
      </categories>
      <tags>
        <tag>课堂笔记</tag>
        <tag>辅修</tag>
        <tag>微观经济学</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[《枪炮、病菌与钢铁》读书笔记]]></title>
    <url>%2Fpost%2F74a4286c.html</url>
    <content type="text"><![CDATA[内容摘录与笔记前言 耶利的问题 P2“耶利的问题：‘为什么你们白人制造了那么多的货物并将它们运到新几内亚来，而我们黑人却几乎没有属于我们自己的货物呢？’” P3 “在普通新几内亚人的生活方式和普通欧洲人或普通美国人的生活方式之间仍然存在着巨大的差异。类似的差异同样把世界上其他民族的生活方式区别了开来。这些巨大的差异必定具有人们可能认为显而易见的重要原因。” P3 “关于这个问题的解决办法，专业的历史学家们仍然意见不一：大多数人甚至不再问这样的问题了。” P3 “在25年后撰写的本书就是试图对耶利的问题作出回答。” P10 “在传统的新几内亚社会中，聪明人比不那么聪明的人更有可能逃脱导致高死亡率的死因。然而，在传统的欧洲社会中，流行性疾病造成的死亡率的差异与智力几乎没有任何关系，而是与取决于人体化学细节的遗传抵抗力有关。例如，血型为B或O的人比血型为A的人对天花有更强的抵抗力。就是说，促进智力基因的自然选择，在新几内亚比在人口稠密、政治上复杂的社会可能要无情得多，因为在这样的社会里，对人体化学组成得自然选择反而更有效力。” 如果说之前读到得历史著作对历史进程必然性的分析是基于分布在各大陆的民族在政治、军事、文化等等方面的差异而来的，那么本书想要探究的则是这些差异的来源和产生模式。相较于讨论为什么欧洲人能够屠杀或者正如其他民族的直接原因，这本书着眼于分析，为什么是欧洲人而不是非洲人、亚洲人能够屠杀或者征服其他民族，这种差异是如何从零慢慢演变出来的。是对历史进程终极原因的探索。 P15 “新闻记者总使要求作者用一句话把篇幅很长的书加以概括。对本书来说，这样的一句话就是：‘不同民族的历史遵循不同的道路前进，其原因是民族环境的差异，而不是民族自身在生物学上的差异。’” 我更倾向于理解成，更主要的原因是…而不是…（阅读前） P19 “造成粮食生产传播速度差异的一个重大因素原来竟是大陆的轴线方向：欧亚大陆主要是东西向，而美洲和非洲则主要是南北向（第十章）。” P19 “第三部分（《从粮食到枪炮、病菌与钢铁》，第十一章到第十四章）从密籍人口所特有的病菌的演化开始，对从终极原因到近似原因的联系进行了考察（第十一章）。欧亚大陆的病菌杀死的印第安人和其他非欧亚大陆民族，比欧亚大陆的枪炮或钢铁武器所杀死的要多得多。相反，在新大陆，很少有或根本没有任何危险的病菌在等待未来的欧洲征服者。为什么病菌的交流这样不相等？在这里，近来分子生物学的研究成果在把病菌和粮食生产的出现相联系方面是富于启发性的，而这两者的联系在欧亚大陆要远远超过美洲。” P22 “然而，我希望我已经使读者相信，历史并不‘就是一个又一个讨厌的事实’，就像一个愤世嫉俗者说的那样。的确存在着始用于历史的广泛模式，而寻找这些模式的解释不但令人陶醉，也是大有裨益的。” 第一部分 从伊甸园到卡哈马卡第一章 走上起跑线——公元前11000年前各个大陆发生了些什么 P3 “用以比较不同大陆的历史发展的合适起点是公元前11000年左右。这个年代大致相当于世界上一些地区村社生活的开始。这时，美洲毫无疑问已经出现了首批定居者，更新世和上一次冰期已经结束，地质学家所说的全新世已经开始。在那个年代的几千年内，动植物的训话至少在世界上的一个地方开始了。从那时起，某些大陆上的族群是否已经比其他大陆上的族群领先一步或处于明显优势呢？” 本章想要探索的问题，快速浏览人类的初期历史，是否在很早期就在不同大陆上的人类演化产生了优劣之分，从而影响之后的历史进程。 P8 “我曾在《第三种黑猩猩》一书中主张，是喉的完善为现代语言提供了解剖学的基础，而发挥人的创造力是要大大依靠语言的。而另外一些人则提出，在当时脑容量不变的情况下脑组织发生的变化，使现代语言成为可能。” 大约10万年至5万年前，人类种族祖先能力发生巨大变化原因的两种解释。 在之后，4万年前，克罗马努人用他们现代人的体格，先进的文化，语言技能和智慧，或者变相利用他们身上的细菌，取代了欧洲的尼安德特人，没有证据证明两个早期人类种族的混合，更多的证据指向克罗马努人让尼安德特人不复存在。 这种种族本身的跃进和人类生存区域的重大扩张在时间上不谋而合。由非洲、亚欧大陆拓展到澳大利亚/新几内亚，以及在大陆板块快速扩散。 P9 “那时候，要从亚洲大陆到达澳大利亚/新几内亚，仍然需要渡过8个海峡，其中最宽的一个海峡至少有50英里宽。被大多数这样的海峡分隔开的岛屿彼此隔海相望，但从澳大利亚看不见印度尼西亚……因此，对澳大利亚/新几内亚的占有使一个重大事件，因为那需要有水运工具，因此这一点显然提供了关于历史上使用水运工具的最早证据” 还有人类的早期祖先们在各个大陆拓张过程中可能对一些大型哺乳动物带来的影响。 P11 “如此众多的大型动物几乎同时消失这一点引出了一个显而易见的问题：是什么造成了这种情况？一个显而易见的可能答案是：它们被首批到达的人类杀光或间接消灭了。” 由于这种大型哺乳动物灭绝不单单出现在澳大利亚/新几内亚地区，其他大陆包括后来的美洲，也同样出现了这样的灭绝现象，时间也与人类的首次到达和拓殖相差不多，更增添了这一假说的可能性。 也有一些人持气候变化印象，不过作者认为历经历史上的多次气候变化都没灭绝的一众物种都在人类足迹到达之后灭亡，难说是巧合。 P11 “我们知道，加拉帕戈斯群岛喝南极的鸟类喝哺乳动物同样也是在没有人类的情况下演化的，并且直到现代才看见了人，所以今天仍温顺得不可救药。如果不是环境保护主义者采取了保护性措施，它们可能已经很快灭绝了。在其他一些最近才发现的岛上，由于保护措施没有很快实施，消灭动物的事的确发生了：一个这样的受害者就是毛里求斯岛的渡渡鸟，渡渡鸟实际上已成了一种绝种的象征。” 很难不让人思考过去新西兰的恐鸟、马达加斯加的大狐猴喝夏威夷的巨型野鹅是不是也是由于相同原因在更早的时间灭绝。 P13 “从解剖学看，确实掌握了这种技术的现代民族（缝制衣服等抵御寒冷的技术），在大约2万年前进入西伯利亚（对此通常都有一些认为时间还要早得多的说法）。这一扩张可能就是欧亚大陆长毛象和长毛犀绝种的原因。” P19 “随着人类在美洲的定居，各个大陆和陆边岛屿以及从印度尼西亚到新几内亚东面的洋中岛，凡是可居住的大多数地区都有人类在生活。在世界上其余岛屿的定居直到现代才完成：地中海诸岛如克里特岛、塞浦路斯岛、科西嘉岛和撒丁岛约在公元前8500年到4000年之间；加勒比海诸岛从公元前4000年左右开始；波里尼西亚群岛和密克罗尼西亚群岛在公元前1200年到公元1000年之间；马达加斯加岛在公元300年到800年之间；冰岛在公元9世纪。美洲印第安人可能是现代伊努伊特人的祖先，他们大约在公元前2000年遍布北极附近地区。这样，在过去的700年中，唯一的无人居住、等待欧洲探险者光顾的地区就只剩下大西洋和印度洋中那些最偏远的岛屿（如亚速尔群岛和塞舌尔群岛）和南极大陆了。” P22 “因此，一个被送回到公元前11000年的观察者可能不会预测到哪个大陆上的人类社会会发展最快，但他可以提出充分的理由说明任何一个大陆都有这样的机会……欧亚大陆社会发展较快的真实原因根本不是我们所虚构的公元前11000年时的考古学家所猜测的那种直截了当的原因。本书以下篇幅所要研究的就是去发现那些真正的原因。” 去探索导致不同大陆发展差异，历史特殊性的真正原因。 第二章 历史的自然实验——地理因素是怎样塑造波利尼西亚群岛的社会的如果说达尔文在加拉帕戈斯群岛所观察到的“自然实验”是物种起源假说的有力证据，那本书作者对于人类社会在波利尼西亚群岛演化的“自然实验”则是为解决人类发展历史为何如此，是什么造成了历史，给出了可以分析的模式。 莫里奥里人与毛利人的冲突，虽是由相同祖先分化而来，环境的不同使两个地区的人类走上不同的演化道路，莫里奥里人回归狩猎采集的生活，坚持和平避免冲突的政策，而毛利人则走上集约农业的道路，信奉征服与掠夺。 P24 “这种相反的演化道路注定了他们最后冲突的结果。如果我们能够了解这两个岛屿社会向截然不同的方向发展的原因，我们也许就有了一个模式，用以了解各个大陆不同发展的更广泛的问题。” 这两个人类社会间的冲突又是波利尼西亚群岛这个中等规模“自然实验”下一个更微观的实验。 P28 “在波利尼西亚群岛之间，至少有6种环境可变因素促成了波利尼西亚社会之间的这些差异：岛屿气候、地址类型、海洋资源、面积、地形的破碎和隔离程度……” 第三章 卡哈马卡的冲突——为什么印加帝国皇帝阿塔瓦尔帕没有俘虏西班牙国王查理一世 P54 “因此，皮萨罗俘虏阿塔瓦尔帕这件事，表明了导致欧洲人向新大陆移民而不是美洲土著向欧洲移民的那组近似的因素。皮萨罗成功的直接原因包括：以枪炮、钢铁武器和马匹为基础的军事技术；欧亚大陆的传染性流行病；欧洲的航海技术；欧洲国家集中统一的行政组织和文字。本书的书名是这些近似因素的简略的表达，这些因素也使现代欧洲人能够去征服其他大陆的民族。” 划重点，本书的书名是这些近似因素的简略的表达。 第二部分 粮食生产的出现和传播第四章 农民的力量——枪炮、病菌与钢铁的根源 P58 “粮食生产是枪炮、病菌和钢铁发展的一个先决条件。因此，在不同大陆的族群是否或何时变成农民和牧人方面的地理差异，在很大程度上说明了他们以后截然不同的命运。” P64 “总之，动植物的驯化意味着人类的粮食越来越多，因而也就意味着人口越来越稠密。因此而带来的粮食和（在某些地区）利用畜力运输剩余量是，成了定居的、行政上集中统一的、社会等级分明额、经济上复杂的、技术上富有革新精神的社会的发展的先决条件。因此，能否利用驯化的动植物，最终说明了为什么帝国、知书写字和钢铁武器在欧亚大陆最早发展起来，而在其他大陆则发展较晚，或根本没有发展起来。” 第五章 历史上的穷与富——粮食生产开始时的地理差异 P67 “为什么粮食生产首先在看似相当贫瘠的土地上形成，只是到后来才在今天最肥沃的农田和牧场发展起来？” 确定古代遗存和年代以后，人们怎样确定这个动物或者植物是在附近驯化的，而不是在别处驯化，后来才传到这个遗址来的？ P70 “一个方法是研究这个作物或动物的野生祖先的地理分布图，并推断出驯化势必发生在野生祖先出现的地方。” P87 “确定某个作物或动物的驯化地点的第二个方法，是在地图上标出每个地区驯化物种首次出现的年代。出现年代最早的地点也许就是驯化最早的地点——而如果野生物种的祖先也在那里出现，且如果它们在其他地点首先出现的年代随着与推定的最早驯化地点距离的增加而渐次推后，从而表明驯化物种在向其他那些地点传播，情况就尤为如此。” P87 “一个极端情况是：有些地区的粮食生产完全是独立出现的……目前能够举出详细又令人信服的证据的这样的地区只有5个：西南亚，亦称近东或新月沃地；中国；中美洲（该词用来指墨西哥的中部和南部以及中美洲的毗连地区）；那美洲的安第斯山脉地区，可能还有亚马孙河流域的毗连地区；以及美国东部。在这些粮食生产中心中，有些中心或所有中心可能实际上包含了附近的几个或多或少独立出现的粮食生产的中心，如中国北方的黄河流域和中国南部的长江流域。” P92 “另一个极端情况是：有些地区的粮食生产毫无疑问不但是从外来作物和动物的引进开始的，而且也是从外来人的突然到来开始的。” 第六章 种田还是不种田——粮食生产传播的原因一个常见的错误观念：从到处流浪流浪的狩猎采集族群与定居的粮食生产者之间必定是界限分明。 P97 “粮食生产制度的渐次形成乃是许多关于时间和劳力分配的不同决定积累的结果。” P98 “觅食的人和觅食的动物一样，都在不断地按优先顺序来做出分配劳力的决定，哪怕是无意识地也是一样。他们首先集中注意力于最喜欢的食物，或者能够产生最高报偿的食物……在做出这些决定时要考虑许多问题。人们寻找食物是为了充饥果腹。他们也渴望得到一些特别的食物。如果所有其他情况相同，人们就用一种以最少的时间、最小的努力和最大的回报的方法去寻找食物。” P100 “我们必须把粮食生产同狩猎采集看作是相互竞争的供选择的方法。” 第七章 怎样识别杏仁——古代作物的无意识的发展 P110 “迄今为止，我们对野生植物演化为作物的描述的种种变化，与早期农民实际上可能已注意到的一些特征直接有关——如果实的大小、苦味、多肉、含油和纤维的长度。通过收获这些具有特别可取的品质的野生植物，古代人在无意识中传播了这些植物，使他们走上了驯化的道路。” 部分奇怪的突变本不利于植物在无人的环境下竞争，不过恰巧是这些突变利于人类对其驯化而保留了下来。 P111 “一个明显的例子就是豌豆。豌豆的种子（我们吃的豌豆）封闭在豆荚里。野豌豆要发芽生长，就必须破荚而出。为了做到这一点，豌豆就演化出一种基因，能使豆荚突然破裂，把豌豆弹射到地上。偶然产生突变的豌豆的豆荚不会爆裂。在野外，这种产生突变的豌豆一直到死都是包裹在亲株上的豆荚里面，而只有这种能爆裂的豆荚才能把它们的基因传递给后代。但与此相反的是，人类能够收获到的唯一豆荚可能就是留在植株上那些不爆裂的豆荚。因此，一旦人类开始把野豌豆带回家去吃，立刻就产生了对这种单基因突变的选择。对同样不爆裂突变进行选择的例子还有兵豆、亚麻和罂粟。” 与之相似的还有后文介绍的大麦和小麦，野生型麦秆可以自动脱落使得种子落到能够发芽生长的地面上，而突变型却保留在麦秆顶端，给人类的采集带来了方便，其后代同样保持了这样的性状，对这种突变品种的无意识选择，显然是人类对植物的第一个重大的“改良”，标志着新月沃地农业的开始。 第八章 问题在苹果还是印第安人——为什么有些地区的族群未能驯化植物 P127 “人类历史的主要事实之一，是西南亚的那个叫做新月沃地的地区在人类发展早期的重要性。那个地区似乎是包括城市、文字、帝国以及我们所说的文明（不论是福是祸）在内的一连串新情况发生的地方。而所有这些情况之所以发生，都是由于有了稠密的人口，有了剩余粮食的贮存，以及可以养活不从事农业的专门人材，凡此种种之所以可能又都是由于出现了以作物栽培和牲口饲养为形式的粮食生产。” 气候的原因——也影响了早期粮食生产基地的“选址” P146 “对美国东部驯化植物最了解的农民，就是这个地区的印第安人自己。他们在墨西哥三位一体的作物体系引进后宣判了当地驯化植物的命运：或者把它们完全抛弃，或者把它们的重要性降低。这个结果也表明了印第安人没有受到文化保守主义的束缚，而是在看到一种优良的植物时完全能够认识到它的价值。因此，同在新几内亚一样，美国东部土生土长的粮食生产所受到的限制，不是由于印第安人本身，而是完全决定于美洲的生物区系和环境。” 那么总结性的讲，限制粮食生产或者粮食生产发展水平的主要原因可以归结为下面一段话。 P147 “所有这些不存在本地粮食生产或只有有限的本地粮食生产的地区，都缺少可驯化的牲畜和谷物的野生祖先。” 关于第八章章节首部提出的问题的答案 P150 “因此，在欧洲人到达时，印第安人仍未能驯化北美的苹果，其原因不是印第安人，也不在苹果……印第安人未能驯化苹果的原因却是在于印第安人所能得到的整个野生动植物组合。这个组合的微弱的驯化潜力，就是北美粮食生产很晚才开始的主要原因。 第九章 斑马、不行的婚姻和安娜·卡列尼娜原则——为什么大多数大型野生哺乳动物没有得到驯化 P151 “可驯化的动物都是可以驯化的；不可驯化的动物各有各的不可驯化之处。” 即可以驯化的大型哺乳动物是要求符合多种条件的，这些条件都是“被驯化”这一结果的必要条件，而缺少其中任一（甚至被干扰）都会影响到大型哺乳动物的驯化。 P170 “人类同大多数动物缔结了一种不幸的婚姻，这是由于许多可能的原因中的一个或多个原因造成的：动物的日常食物、生长速度、交配习惯、性情、容易受惊的倾向以及群居组织的几个不同的特点。只有很少一部分野生哺乳动物由于在上述所有这些方面都能协调一致而最终得以和人类结成美满的婚姻” 第十章 辽阔的天空与偏斜的轴线——为什么在不同的大陆粮食生产传播的速度不同 P173 “轴线走向影响了作物和牲口的传播速度，可能还影响文字、车轮和其他发明的传播速度。这种基本的地理特征在过去500年中队印第安人、非洲人和欧亚大陆人十分不同的经验的形成起了巨大的促进作用。” 关于“抢先驯化现象”：可以反应作物在大陆上的传播速度可以利用“抢先驯化现象”，即如果某一未驯化可利用作物的地方，当面临该作物的野生祖先和传播而来的变种（驯化）作物，可以推断出当地人类会选择后者，因而不会再进行一次其野生祖先的驯化。 因而，通过遗传分析，可以得到的结果是：欧亚大陆驯化的古代作物多数显示出只有一个不同的野生变种或不同的转化突变体，即反应出一次可利用的驯化。但新大陆的驯化作物则常常出现至少两个，即在不同场合独立的出现了驯化现象。这说明，新大陆对比欧亚大陆，前期驯化成果并没有迅速传播开来，侧面反映了粮食传播的速度差异。 进一步的 P176 “某种作物的迅速传播可能不但抢先阻止了同一植物的野生祖先在其他地方的驯化，而且也阻止了有亲缘关系的野生植物的驯化。” P180 “为什么作物从新月沃地向外传播的速度如此之快？回答部分地取决于我在本章开始时谈到的欧亚大陆的东西向周线。位于同一纬度地东西两地，白天的长度和季节的变化完全相同。在较小程度上，它们也往往具有类似的疾病、温度和雨量情势以及动植物生境或生物群落区（植被类型）。” 第三部分 从粮食到枪炮、病菌与钢铁第十一章 牲畜的致命礼物——病菌的演化 P203 “因此，当人口的数量和集中达到一定程度时，我们也就达到了这样的一个历史阶段，在这个阶段我们至少能够形成并保持只有我们人类才会有的人群病。但这个结论也有其矛盾之处：在那时以前这些病是不可能存在的！相反，它们必须演化成新的疾病。那么，这些新的疾病又是从哪里来的呢？” P203 “最近，由于对致病病菌所进行的分子研究，证据正在不断出现。就引起我们独有的疾病的许多病菌来说，分子生物学家现在能够确定一些亲缘关系最为接近的病菌。这些病菌同样证明是人群传染病的媒介——不过只在我们的各种家畜和宠物中流行罢了！” 人类疾病携带亲缘关系最为接近的抗原体的动物 麻疹牛（牛瘟） 肺结核牛 天花牛（牛痘）或携带亲缘痘病毒的其他牲畜 流行性感冒猪和鸭 百日咳猪、狗 恶性疟疾禽鸟（鸡和鸭？） 动物原病转化为人类疾病一般可以分为四个阶段。 回到开头耶利的问题。 P212 “如果没有欧洲送给其他大陆的不详礼物——从欧亚大陆人与家畜的长期密切关系中演化出来的病菌，这一切也许是不会发生的。” 第十二章 蓝图和借用字母文字的力量显而易见，能够指导重大行动下达指令，能够记录前人经验（包括但不限于航海）从而给后人以经验和指导。 几个问题： 为什么只有某些民族产生了文字？ 文字在人类历史上分别产生过几次？ 为什么有些民族发明文字早得多？ 为什么有些民族发明文字但之后却利用的很少？ 苏美尔人表示抽象名词的神奇创新： P218 “也许整个文字史上最重要的一步是苏美尔人采用了语音符号，开始时是借助代表发音相同而又可以画出来的名词的符号来书写抽象名词。例如，要为弓画出一个可以识别的图形是容易的，但要为生命画出一个可以识别的图形就困难了，但这两者的发音在苏美尔语里都是ti，因此一张弓的图形的意思或者是弓，或者是生命。解决由此而产生的歧义是加上一个叫做义符的无声符号，以表示拟议中的对象所属的名词类别。语言学家把这种决定性的创新称之为画迷原则，也是今天构成双关语的基础。” 传播形式的两端：“蓝图复制”和“思想传播”。 P225 “罗马字母本身就是长长的一系列蓝图复制的终端产品。在人类历史上，字母只产生过一次：是在公元前第二个千年中从现代叙利亚到西奈半岛这个地区内说闪语的人当中产生的。历史上的和现行的几百种字母，追本溯源全都来自闪语字母这个老祖宗，有些（如爱尔兰的欧甘字母）是思想传播的结果，但大多数则是通过字母形式的实际复制和修改而产生的。 ” 第十三章 需要之母 P243 “我们最终将要涉及本书的一个中心问题：为什么在不同的大陆上技术以不同的速度演进的问题” P247 “我的两个主要结论是：技术的发展是插个旗积累的，而不是靠孤立的英雄行为；技术在发明出来后大部分都得到了使用，而不是发明出来去满足某种预见到的需要。” 一种技术产生后传播受到多种因素的影响。 P263 “中世纪欧洲从3000年的字母发展中继承的字母文字适合于用活字印刷，因为只需浇铸几十个字母就行了，不像中国文字那样需用几千个语言符号。” P265 “现在，让我们来总结一下，粮食生产开始的时间、技术传播的障碍和人口的多寡这三大因素的变化，是怎样直接导致我们所看到的各大陆之间在技术发展方面的差异的。欧亚大陆（实际上也包括北非在内）是世界上最大的陆块，包含有数量最多的互相竞争的社会。它也是最早开始拥有粮食生产的两个中心的陆块，这两个中心就是新月沃迪和中国。它的东西向的主轴线，使欧亚大陆一个地区采用的许多发明得以较快地传播到欧亚大陆具有想同纬度和气候的其他地区的社会。它的沿次轴线（南北轴线）的宽度，同美洲巴拿马地峡的狭窄形成了对照。它没有把美洲和非洲的主轴线切断的那种严峻的生态障碍。因此，对技术传播的地理和生态障碍，在欧亚大陆没有在其他大陆那样严峻。由于所有这些因素，后更新世技术的加速发展，在欧亚大陆没有在其他大陆那样严峻。由于所有这些因素，后更新世技术的加速发展，在欧亚大陆开始得最早，从而导致了本地最大的技术积累。” 第十四章 从平等主义到盗贼统治 P281 “盗贼统治者和英明政治家得区别，强盗贵族和公益赞助人的区别，只是程度不同而已：这只是一个从生产者那里榨取来的财物有多少被上层人物留下来的问题。” 获取群众的支持，从古至今的盗贼统治者混合使用了4种办法： 接触平民的武装，同时武装上层掌权人物。 用通行的办法把得到的财务的很大一部分再分配给群众来博取欢心。 利用对武力的绝对控制来维持公共秩序和制止暴力以促进社会幸福。 制造一种为盗贼统治辩护的意识形态或宗教。 早期国家相较于酋长管辖地，直观的差别是规模更大，亲属关系更平淡，最高世袭领袖对信息、决策和权力实行更大的垄断。 P285 “许多早期国家，也是大多数早期国家，都层经历过奴隶制，其规模比酋长管辖地大得多。这不是因为酋长管辖地在处理被打败的敌人时更加宽大为怀，而是因为国家经济专门化的发展，更多的大规模胜场和更多的公共工程需要使用更多的奴隶劳动。此外，更大规模的国家战争能够得到更多的俘虏。” 当然，相较于酋长管辖地，还有一些潜在优势，比如国家对意识形态的统一更能激发一些个人的奉献精神，心甘情愿为国捐躯，现代国家中这已经成为一条基本思想通过我们从小受到的教育灌输进我们的大脑，使我们忘记了它标志着同以往人类历史的彻底决裂。 不再顾及自己感情和生命，取而代之的，“为了国王和国家”，“为了上帝和西班牙”，“战死沙场最光荣，给我们以生命的神最看重这种光荣的死：我远远看见了它，我的内心充满了对它的渴望！” 第五部分 在五章中环游世界第十五章 耶利的族人——澳大利亚和新几内亚的历史 P321 “‘他们是世界上最悲惨的人，是和没有理性的野兽差不多的人。’” 第十六章 中国是怎样成为中国人的中国的——东亚的历史第十七章 驶向波利尼西亚的快艇——南岛人扩张的历史第十八章 两个半球的碰撞——欧亚大陆与美洲历史的比较第十九章 非洲是怎样成为黑人的非洲的——非洲的历史]]></content>
      <categories>
        <category>阅读</category>
      </categories>
      <tags>
        <tag>阅读</tag>
        <tag>历史</tag>
        <tag>贾雷德·戴蒙德</tag>
        <tag>枪炮、病菌与钢铁</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[【UVA-679】解题报告（二叉树）]]></title>
    <url>%2Fpost%2Fe6364ca4.html</url>
    <content type="text"><![CDATA[原始题目 题目大意一颗完全二叉树（FBT）初始所有结点标记为false，根结点标号1，对于一个小球从根结点释放，遇到false标记向左下，true标记向右下，直至到达叶子结点。每次经过标记后标记翻转。 给出完全二叉树（FBT）的深度$D$，和小球的次序$I$，求其最终下落的叶子节点标号。 解题思路 考虑根节点，发现奇数次序小球向左下，偶数小球向右。 同理，若为$I$奇数，则其是到达左子树的第$ \frac {I+1}{2}$个小球，序号为$ 2 \times index $。 若位偶数，则其是到达右子树的第$ \frac {I}{2} $个小球，序号为 $ 2 \times index + 1 $。 递推n-1次解题代码12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849#include &lt;cstdio&gt;#include &lt;iostream&gt;#include &lt;iomanip&gt;#include &lt;vector&gt;#include &lt;string&gt;#include &lt;cstring&gt;#define rep(i,a,n) for(int i=a;i&lt;n;++i)#define per(i,a,n) for(int i=n-1;i&gt;=a;--i)#define clint(x,a) memset(x,a,sizeof(int)*n)#define clll(x,a) memset(x,a,sizeof(ll)*n)#define pb push_back#define np next_permutation#define mp make_pair#define fi first#define se second#define INF 0x3f3f3f3f#define EPS 1e-8#define PI acos(-1.0)using namespace std;const int maxn=1e5+5;const int maxm=1e5+5;const int maxl=26;typedef long long ll;typedef unsigned long long ull;typedef vector&lt;int&gt; vi;typedef pair&lt;int,int&gt; pii;typedef pair&lt;string,string&gt; pss;ll t,d,ii;int main()&#123; ios::sync_with_stdio(false); cin&gt;&gt;t; rep(tt,1,t+1)&#123; cin&gt;&gt;d&gt;&gt;ii; ll ans=1; for(int i=1;i&lt;d;i++)&#123; if(ii&amp;1)&#123; ans*=2; ii=(ii+1)/2; &#125; else&#123; ans=ans*2+1; ii=ii/2; &#125; &#125; cout&lt;&lt;ans&lt;&lt;endl; &#125; cin&gt;&gt;t;&#125; 收获与反思 注意奇偶性规律]]></content>
      <categories>
        <category>编程</category>
        <category>ACM</category>
      </categories>
      <tags>
        <tag>算法</tag>
        <tag>ACM</tag>
        <tag>数据结构</tag>
        <tag>2018秋季训练</tag>
        <tag>UVA</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[【UVA-12657】解题报告（双端链表）]]></title>
    <url>%2Fpost%2F6c71e418.html</url>
    <content type="text"><![CDATA[原始题目 题目大意有$n$个箱子，初始标号从左到右由$1$到$n$，有以下四种操作 把X移动到Y左边 把X移动到Y右边 交换X和Y的位置 全体翻转颠倒 其中1，2若已经符合状态则不操作 给出$n$和所有的操作，输出从左到右奇数位的和。 解题思路 数组形式双端链表 $left[i],right[i]$，模拟实现 简化实现：3不受4影响，4的翻转可以记录状态，且翻转状态下2-&gt;1，1-&gt;2。 交换需要分类，相邻时特判 解题代码123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113#include &lt;cstdio&gt;#include &lt;iostream&gt;#include &lt;iomanip&gt;#include &lt;vector&gt;#include &lt;string&gt;#include &lt;cstring&gt;#define rep(i,a,n) for(int i=a;i&lt;n;++i)#define per(i,a,n) for(int i=n-1;i&gt;=a;--i)#define clint(x,a) memset(x,a,sizeof(int)*n)#define clll(x,a) memset(x,a,sizeof(ll)*n)#define pb push_back#define np next_permutation#define mp make_pair#define fi first#define se second#define INF 0x3f3f3f3f#define EPS 1e-8#define PI acos(-1.0)using namespace std;const int maxn=1e5+5;const int maxm=1e5+5;const int maxl=26;typedef long long ll;typedef unsigned long long ull;typedef vector&lt;int&gt; vi;typedef pair&lt;int,int&gt; pii;typedef pair&lt;string,string&gt; pss;int a[maxn],lleft[maxn],rright[maxn];int n,m;void init()&#123; rep(i,1,n+1)&#123; lleft[i]=i-1; rright[i]=(i+1); &#125; rright[0]=1; lleft[n+1]=n;&#125;void link(int l,int r)&#123; rright[l]=r;lleft[r]=l;&#125;int main()&#123; ios::sync_with_stdio(false); int kase=0; while(cin&gt;&gt;n&gt;&gt;m)&#123; init(); int op,aa,bb,status=0; rep(i,0,m)&#123; cin&gt;&gt;op; if(op==4)&#123; status=!status; &#125; else&#123; cin&gt;&gt;aa&gt;&gt;bb; if(status &amp;&amp; op!=3) op=3-op; //改变操作 if(op==3 &amp;&amp; rright[bb]==aa) swap(aa,bb); int laa=lleft[aa],raa=rright[aa],lbb=lleft[bb],rbb=rright[bb]; if(op==1)&#123; if(aa==lbb) continue; else &#123; link(laa,raa); link(lbb,aa); link(aa,bb); &#125; &#125; else if(op==2)&#123; if(aa==rbb) continue; else &#123; link(laa,raa); link(bb,aa); link(aa,rbb); &#125; &#125; else if(op==3)&#123; if(raa==bb)&#123; link(laa,bb); link(bb,aa); link(aa,rbb); &#125; else&#123; link(laa,bb); link(bb,raa); link(lbb,aa); link(aa,rbb); &#125; &#125; &#125; &#125; ll sum=0; int b; if(status) b=n+1; else b=0; for(int i=1;i&lt;=n;++i)&#123; if(status)&#123; b=lleft[b]; &#125; else b=rright[b]; if(i&amp;1) sum+=b; &#125; cout&lt;&lt;"Case "&lt;&lt;++kase&lt;&lt;": "&lt;&lt;sum&lt;&lt;endl;// int c=0;// for(int i=1;i&lt;=n;++i)&#123;// c=rright[c];// cout&lt;&lt;c&lt;&lt;" ";// &#125;// cout&lt;&lt;endl; &#125;&#125; 收获与反思 数组形式双端链表$left[i],right[i]$，分别表示前驱结点和后继结点的指针。 //link操作，将两结点连接在一起。 void link(int l,int r){ rright[l]=r;lleft[r]=l; } 对于1，2操作，需要考虑连接顺序，记录原始的lx，ly，rx，ry，然后从左到右一一link就好。 注意记录原始的lx，ly，rx，ry，后面会改变]]></content>
      <categories>
        <category>编程</category>
        <category>ACM</category>
      </categories>
      <tags>
        <tag>算法</tag>
        <tag>ACM</tag>
        <tag>Imitation</tag>
        <tag>2018秋季训练</tag>
        <tag>UVA</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[【UVA-11988】解题报告（链表）]]></title>
    <url>%2Fpost%2F75f986a1.html</url>
    <content type="text"><![CDATA[原始题目 题目大意给出一段输入，‘[’表示“Home”键，即输入跳转到开头，‘]’表示“End”键，即输入跳至结尾。输出最终实际文字。 解题思路数组形式链表模拟。加空开头和尾。 解题代码12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849#include &lt;cstdio&gt;#include &lt;bits/stdc++.h&gt;#define rep(i,a,n) for(int i=a;i&lt;n;++i)#define per(i,a,n) for(int i=n-1;i&gt;=a;--i)#define clint(x,a) memset(x,a,sizeof(int)*n)#define clll(x,a) memset(x,a,sizeof(ll)*n)#define pb push_back#define np next_permutation#define mp make_pair#define fi first#define se second#define INF 0x3f3f3f3f#define EPS 1e-8#define PI acos(-1.0)using namespace std;const int maxn=1e5+5;const int maxm=1e5+5;const int maxl=26;char ss[maxn];int nextt[maxn];int main()&#123; ios::sync_with_stdio(false); while(cin&gt;&gt;ss+1)&#123; int last=0,cur=0; memset(nextt,0,sizeof(nextt)); int len=strlen(ss+1); rep(i,1,len+1)&#123; if(ss[i]=='[')&#123; cur=0; &#125; else if(ss[i]==']') &#123; cur=last; &#125; else &#123; nextt[i]=nextt[cur]; nextt[cur]=i; if(cur==last) last=i; cur=i; &#125; &#125; for(int i=nextt[0];i!=0;i=nextt[i])&#123; cout&lt;&lt;ss[i]; &#125; cout&lt;&lt;endl; &#125;&#125; 收获与反思 数组形式链表，数组标号0作为空头结点，next[0]作为头节点的指针。 添加结点的操作为 next[i]=next[cur] //加入结点的指针与前一结点的指针相同 next[cur]=i; //前一结点指针指向新结点 //由于本题还需要记录尾结点的序号所以有 //if(cur==last) last=i; cur=i; //指针移向当前结点]]></content>
      <categories>
        <category>编程</category>
        <category>ACM</category>
      </categories>
      <tags>
        <tag>算法</tag>
        <tag>ACM</tag>
        <tag>Imitation</tag>
        <tag>2018秋季训练</tag>
        <tag>UVA</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[【UVA-442】解题报告（STL，栈）]]></title>
    <url>%2Fpost%2Fca14c5df.html</url>
    <content type="text"><![CDATA[原始题目 题目大意给出$n$个矩阵的行数和列数（矩阵名为A到Z），再给出一些表达式，根据表达式的运算规则计算是否合法，若合法计算出乘法次数。 解题思路简单的表达式解析可以通过栈实现，输入右括号时计算，输入字母时压入栈。 解题代码12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364656667686970717273#include &lt;cstdio&gt;#include &lt;bits/stdc++.h&gt;#define rep(i,a,n) for(int i=a;i&lt;n;++i)#define per(i,a,n) for(int i=n-1;i&gt;=a;--i)#define clint(x,a) memset(x,a,sizeof(int)*n)#define clll(x,a) memset(x,a,sizeof(ll)*n)#define pb push_back#define np next_permutation#define mp make_pair#define fi first#define se second#define INF 0x3f3f3f3f#define EPS 1e-8#define PI acos(-1.0)using namespace std;const int maxn=1e5+5;const int maxm=1e5+5;const int maxl=26;typedef long long ll;typedef unsigned long long ull;typedef vector&lt;int&gt; vi;typedef pair&lt;int,int&gt; pii;typedef pair&lt;string,string&gt; pss;int t,n;struct Matrix&#123; int a,b; Matrix(int a=0,int b=0):a(a),b(b)&#123;&#125;&#125;m[26];int main()&#123; ios::sync_with_stdio(false); cin&gt;&gt;n; rep(i,0,n)&#123; char c; cin&gt;&gt;c; cin&gt;&gt;m[c-'A'].a&gt;&gt;m[c-'A'].b; &#125; string str; while(cin&gt;&gt;str)&#123; stack &lt;Matrix&gt; s; bool flag=0; int ans=0; int len=str.length(); rep(i,0,len)&#123; if(isalpha(str[i]))&#123; if(flag) break; s.push(m[str[i]-'A']); &#125; else if(str[i]==')')&#123; Matrix m1,m2; if(flag) break; m1=s.top();s.pop(); m2=s.top();s.pop(); if(m1.a!=m2.b)&#123; flag=1; break; &#125; else&#123; ans+=m2.a*m1.b*m1.a; s.push(Matrix(m2.a,m1.b)); &#125; &#125; &#125; if(flag) cout&lt;&lt;"error"&lt;&lt;endl; else cout&lt;&lt;ans&lt;&lt;endl; &#125;&#125; 收获与反思注意读题，表达式的范式。]]></content>
      <categories>
        <category>编程</category>
        <category>ACM</category>
      </categories>
      <tags>
        <tag>算法</tag>
        <tag>ACM</tag>
        <tag>2018秋季训练</tag>
        <tag>STL</tag>
        <tag>UVA</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[【UVA-10474】解题报告（STL，排序，二分）]]></title>
    <url>%2Fpost%2Fbcb02c2b.html</url>
    <content type="text"><![CDATA[原始题目 题目大意有许多$N$个标有不同数字的大理石，每次按1，2，3这样从小到大的次序数。有$Q$个询问，对于每个询问，是否能数到指定数，若能输出数的次数，若不能输出not found. 解题思路排序以后利用二分查找，输出位置+1即可。 解题代码12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455#include &lt;bits/stdc++.h&gt;#define rep(i,a,n) for(int i=a;i&lt;n;++i)#define per(i,a,n) for(int i=n-1;i&gt;=a;--i)#define fi first#define se second#define mp make_pair#define pb push_back#define np next_permutation#define cl(x,a,n) memset(x,a,sizeof(int)*n)using namespace std;typedef long long ll;typedef unsigned long long ull;typedef long double ld;typedef vector&lt;int&gt; vi;typedef pair&lt;int,int&gt; pii;typedef pair&lt;string,string&gt; pss;const int maxn=1e5+5;int n,q;int cnt,a[maxn];vector&lt; pii &gt; v;bool cmp( pii a, pii b)&#123; if(a.se!=b.se) return a.se&lt;b.se; else return a.fi&lt;b.fi;&#125;int main()&#123; ios::sync_with_stdio(false); while(cin&gt;&gt;n&gt;&gt;q &amp;&amp; n+q)&#123; rep(i,0,n)&#123; cin&gt;&gt;a[i]; &#125; cout&lt;&lt;"CASE# "&lt;&lt;++cnt&lt;&lt;":"&lt;&lt;endl; sort(a,a+n); rep(i,0,q)&#123; int x; cin&gt;&gt;x; int index=lower_bound(a,a+n,x)-a; if(a[index]==x) cout&lt;&lt;x&lt;&lt;" found at "&lt;&lt;index+1&lt;&lt;endl; else cout&lt;&lt;x&lt;&lt;" not found"&lt;&lt;endl; &#125; &#125;&#125; 收获与反思排序，二分]]></content>
      <categories>
        <category>编程</category>
        <category>ACM</category>
      </categories>
      <tags>
        <tag>算法</tag>
        <tag>ACM</tag>
        <tag>2018秋季训练</tag>
        <tag>STL</tag>
        <tag>UVA</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[金融学辅修——金融学笔记（四）]]></title>
    <url>%2Fpost%2Fe8005312.html</url>
    <content type="text"><![CDATA[课前同学分享 金融衍生品 期权 八大特点 零和博弈：金融衍生品交易净损益之和等于零跨期性：未来交易联动性高风险性高杠杆性交易的保值性 金融衍生品在我国的发展情况 过去——1992年——国债期货 1994年——1998年——金融衍生品市场 发展现况市场经济的推进 对外开放和国际经济接轨 金融衍生品的功能1.风险转移2.价格发现：可以预测未来现货价格的变化3.增强流动4. 存在的问题]]></content>
      <categories>
        <category>金融</category>
        <category>金融学</category>
      </categories>
      <tags>
        <tag>课堂笔记</tag>
        <tag>辅修</tag>
        <tag>金融学</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[金融学辅修——微观经济学笔记（一）]]></title>
    <url>%2Fpost%2Fa27e9acf.html</url>
    <content type="text"><![CDATA[第一章 导论第一节 什么是西方经济学第四节 西方经济学的主要分析方法任何一门学科都有一定的研究和分析方法。 边际分析法边际分析法的特点 其一，边际分析是一种数量分析，尤其是变量分析，运用这一方法研究数量的变动和相互关系。 边际分析法研究微增量的变化及变量之间的关系，可使经济理论精细化（差分，微分）。 边际分析法的意义 经济学研究重心发生改变，由社会性、历史性的政治学经济学转为纯粹研究如何抉择稀缺资源分配给无限而又有竞争性的用途上，以有效利用。 开创了经济学“数量化”的时代。 导致了微观经济学的形成，“个量分析”的微观经济学的诞生。 奠定了最优化理论的基础。 使实证经济学得到发展。 经济模型与抽象分析经济模型： 实证分析和规范分析 规范经济学 Normative economics 以一定的主观价值判断为基础，提出某些标准作为分析处理经济问题的根据，作为建立经济理论的前提和制定经济政策的依据，并研究如何才能符合这些标准。回答“应该是什么”的问题。（标准，应有的样子） 实证经济学 Positive economics 对经济现象进行客观描述，企图超脱或排斥一切主观价值判断。回答“是什么”的问题。 均衡分析均衡即平衡，本是物理学的一个概念 博弈论：纳什均衡 经济学中的均衡状态：各个经济决策者（消费者、生产者等等）所做出的决策正好相容，并且在外界条件不变的情况下，每个人都不愿意再调整自己的决策，从而不再改变其经济行为。（环境不改变，博弈均衡） 均衡分析就是假定经济变量达到均衡状态时所出现的情况以及实现均衡的条件。局部/一般均衡分析。 局部均衡分析：假定其他条件不变，只考虑本身的各相关变量的作用（部分忽略，考虑局部），研究该种变量如何实现均衡。局限在一个局部范围。 一般均衡分析：考虑在各种因素和变量的作用下，如何实现均衡。 静态分析、比较静态分析与动态分析 静态分析：分析均衡状态和所需要的条件，不考虑实现的过程。 比较静态分析：分析在已知条件发生后，均衡状态如何变化。（方向） 动态分析：论述均衡调整变化的实际过程，通常把经济运动过程划分为连续的分析期间，考察有关经济变量在连续时间段的变化。（加时间变量的分析） 外生变量与内生变量 内生变量（Endogenous Variables）经济模型内部结构决定的变量 外生变量（Exogenous Variable）经济模型外部的因素决定的变量 存量（Stock）一定时间存在的量 流量（Flow）一定时间内变化的量 第五节 为关于宏观经济学的基本框架微观经济学微观经济学（Micro-Economics）：研究市场经济中单个经济主体——居民与企业的经济行为以及相应的经济变量的决定。 应有内容：个量分析/单个经济单位/目标最大化/资源配置/价格理论为核心 微观经济学的假设：理性经济人假设/充分就业假设/市场出清假设/完全信息假设 微观经济学的基本内容： 价格的决定：需求和供给决定价格 需求分析：消费者行为理论 攻击分析： 生产与成本理论 市场理论：市场类型对价格和产量决定的影响 要素价格的决定：分配理论 信息经济学 一般均衡与福利经济学 市场失灵与政府失灵 理性人假设基本动力：利益最大化。基本准则：既定目标的最优化。（非理性因素：目标队员，限制性，习惯，社会政治道德等方面呢约束） 第六节 学习经济学容易犯的错误基本研究方法：给定假设，简化关系，放松假设，逼近现实 容易犯的错误：经验主义，合成谬误]]></content>
      <categories>
        <category>金融</category>
        <category>微观经济学</category>
      </categories>
      <tags>
        <tag>课堂笔记</tag>
        <tag>辅修</tag>
        <tag>微观经济学</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[【HDU-6222】解题报告（大数，打表）]]></title>
    <url>%2Fpost%2Fd120bd8e.html</url>
    <content type="text"><![CDATA[原始题目Heron and His Triangle Time Limit: 2000/1000 MS (Java/Others) Memory Limit: 262144/262144 K (Java/Others) Total Submission(s): 2123 Accepted Submission(s): 892 Problem DescriptionA triangle is a Heron’s triangle if it satisfies that the side lengths of it are consecutive integers $ t-1, t, t+1 $ and that its area is an integer. Now, for given n you need to find a Heron’s triangle associated with the smallest $t$ biggerthan or equal to $n$. InputThe input contains multiple test cases. The first line of a multiple input is an integer $T (1 ≤ T ≤ 30000)$ followedby T lines. Each line contains an integer $N (1 ≤ N ≤ {10}^{30}) $. OutputFor each test case, output the smallest $t$ in a line. If the Heron’s triangle required does not exist, output $-1$. Sample Input4 1 2 3 4 Sample Output4 4 4 4 Source2017ACM/ICPC亚洲区沈阳站-重现赛（感谢东北大学） Recommendjiangzijing2015 题目大意输入$n$，求大于等于$n$的最小$t$满足由$t-1,t,t+1$构成的三角形面积为整数。 解题思路打表发现$t$构成数列 t[i]=4 \times t[i-1] -t[i-2]大数板子打表输出。 标程证明还没有想，待补充。 解题代码123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147148149150151152153154155156157158159160161162163164165166167168169170171172173174175176177178179180181182183184185186187188189190191192193194195196197198199200201202203204205206207208209210211212213214215216217218219220221222223224225226227228229230231232233234235236237238239240241242243244245246247248249250251252253254255256257258259260261262263264265266267268269270271272273274275276277278279280281282283284285286287288289290291292293294295296297298299300301302303304305306307308309310311312313314315316317318319320321322323324325326327328329330331332333334335336337338339340341342343344345346347348349350351352353354355356357358359360361362363364365366367368369370371372373374375376377378379380381382383384385386387388389390391392393394395396397398399400401402403404405406407408409410411412413414415416417418419420421422423424425426427428429430431432433434435436437438439440441442443444445446447448449450451452453454455456457458459460461462463464465466467468469470471472473474475476477478#include &lt;bits/stdc++.h&gt;#define rep(i,a,n) for(int i=a;i&lt;n;++i)#define per(i,a,n) for(int i=n-1;i&gt;=a;--i)#define fi first#define se secondusing namespace std;// base and base_digits must be consistentconstexpr int base = 1000000000;constexpr int base_digits = 9;struct bigint&#123; vector&lt;int&gt; z; int sign; bigint() : sign(1) &#123;&#125; bigint(long long v) &#123; *this = v; &#125; bigint&amp; operator=(long long v) &#123; sign = v &lt; 0 ? -1 : 1; v*=sign; z.clear(); for(; v &gt; 0; v = v / base) z.push_back((int)(v % base)); return *this; &#125; bigint(const string&amp; s) &#123; read(s); &#125; bigint&amp; operator+=(const bigint&amp; other) &#123; if (sign == other.sign) &#123; for (int i = 0, carry = 0; i &lt; other.z.size() || carry; ++i) &#123; if(i==z.size()) z.push_back(0); z[i] += carry + (i &lt; other.z.size() ? other.z[i] : 0); carry = z[i] &gt;= base; if(carry) z[i] -= base; &#125; &#125; else if (other != 0 /* prevent infinite loop */) &#123; *this -= -other; &#125; return *this; &#125; friend bigint operator+(bigint a, const bigint&amp; b) &#123; return a += b; &#125; bigint&amp; operator-=(const bigint&amp; other) &#123; if (sign == other.sign) &#123; if (sign == 1 &amp;&amp; *this &gt;= other || sign == -1 &amp;&amp; *this &lt;= other) &#123; for (int i = 0, carry = 0; i &lt; other.z.size() || carry; ++i) &#123; z[i] -= carry + (i &lt; other.z.size() ? other.z[i] : 0); carry = z[i] &lt; 0; if(carry) z[i] += base; &#125; trim(); &#125; else &#123; *this = other - *this; this-&gt;sign = -this-&gt;sign; &#125; &#125; else *this += -other; return *this; &#125; friend bigint operator - (bigint a,const bigint&amp; b) &#123; return a -= b; &#125; bigint&amp; operator*=(int v) &#123; if(v&lt;0) sign=-sign,v=-v; for(int i=0,carry=0;i&lt;z.size() || carry;++i) &#123; if(i==z.size()) z.push_back(0); long long cur = (long long)z[i] * v + carry; carry = (int)(cur / base); z[i] = (int)(cur % base); &#125; trim(); return *this; &#125; bigint operator*(int v) const &#123; return bigint(*this) *= v; &#125; friend pair&lt;bigint, bigint&gt; divmod(const bigint&amp; a1, const bigint&amp; b1) &#123; int norm = base / (b1.z.back() + 1); bigint a = a1.abs() * norm; bigint b = b1.abs() * norm; bigint q, r; q.z.resize(a.z.size()); for (int i = (int)a.z.size() - 1; i &gt;= 0; i--) &#123; r*=base; r+=a.z[i]; int s1 = b.z.size() &lt; r.z.size() ? r.z[b.z.size()] : 0; int s2 = b.z.size() - 1 &lt; r.z.size() ? r.z[b.z.size() - 1] : 0; int d = (int)(((long long)s1 * base + s2) / b.z.back()); r -= b * d; while(r &lt; 0) r+=b,--d; q.z[i] = d; &#125; q.sign = a1.sign * b1.sign; r.sign = a1.sign; q.trim(); r.trim(); return &#123;q, r / norm&#125;; &#125; friend bigint sqrt(const bigint&amp; a1) &#123; bigint a=a1; while(a.z.empty()||a.z.size()%2==1) a.z.push_back(0); int n = a.z.size(); int firstDigit = (int)::sqrt((double)a.z[n - 1] * base + a.z[n - 2]); int norm = base / (firstDigit + 1); a *= norm; a *= norm; while(a.z.empty()||a.z.size()%2==1) a.z.push_back(0); bigint r = (long long)a.z[n - 1] * base + a.z[n - 2]; firstDigit = (int)::sqrt((double)a.z[n - 1] * base + a.z[n - 2]); int q = firstDigit; bigint res; for (int j = n / 2 - 1; j &gt;= 0; j--) &#123; for(;;--q) &#123; bigint r1=(r-(res*2*base+q)*q)*base*base+(j&gt;0?(long long)a.z[2*j-1]*base+a.z[2*j-2]:0); if(r1&gt;=0) &#123; r=r1; break; &#125; &#125; res*=base;res+=q; if(j&gt;0) &#123; int d1 = res.z.size() + 2 &lt; r.z.size() ? r.z[res.z.size() + 2] : 0; int d2 = res.z.size() + 1 &lt; r.z.size() ? r.z[res.z.size() + 1] : 0; int d3 = res.z.size() &lt; r.z.size() ? r.z[res.z.size()]:0; q = (int)(((long long)d1*base*base+(long long)d2*base+d3)/(firstDigit*2)); &#125; &#125; res.trim(); return res / norm; &#125; bigint operator/(const bigint&amp; v) const &#123; return divmod(*this, v).first; &#125; bigint operator%(const bigint&amp; v) const &#123; return divmod(*this, v).second; &#125; bigint&amp; operator/=(int v) &#123; if(v&lt;0) sign=-sign,v=-v; for (int i = (int)z.size() - 1, rem = 0; i &gt;= 0; --i) &#123; long long cur = z[i] + rem * (long long)base; z[i] = (int)(cur / v); rem = (int)(cur % v); &#125; trim(); return *this; &#125; bigint operator/(int v) const &#123; return bigint(*this) /= v; &#125; int operator%(int v) const &#123; if(v&lt;0) v=-v; int m=0; for(int i=(int)z.size()-1;i&gt;=0;--i) m=(int)((z[i]+m*(long long)base)%v); return m * sign; &#125; bigint&amp; operator*=(const bigint&amp; v) &#123; *this = *this * v; return *this; &#125; bigint&amp; operator/=(const bigint&amp; v) &#123; *this = *this / v; return *this; &#125; bool operator&lt;(const bigint&amp; v) const &#123; if(sign!=v.sign) return sign &lt; v.sign; if(z.size()!=v.z.size()) return z.size()*sign&lt;v.z.size()*v.sign; for(int i = (int)z.size() - 1; i &gt;= 0; i--) if(z[i] != v.z[i]) return z[i] * sign &lt; v.z[i] * sign; return false; &#125; bool operator&gt;(const bigint&amp; v) const &#123; return v &lt; *this; &#125; bool operator&lt;=(const bigint&amp; v) const &#123; return !(v &lt; *this); &#125; bool operator&gt;=(const bigint&amp; v) const &#123; return !(*this &lt; v); &#125; bool operator==(const bigint&amp; v) const &#123; return !(*this &lt; v) &amp;&amp; !(v &lt; *this); &#125; bool operator!=(const bigint&amp; v) const &#123; return *this &lt; v || v &lt; *this; &#125; void trim() &#123; while(!z.empty() &amp;&amp; z.back() == 0) z.pop_back(); if(z.empty()) sign = 1; &#125; bool isZero() const &#123; return z.empty(); &#125; friend bigint operator-(bigint v) &#123; if(!v.z.empty()) v.sign = -v.sign; return v; &#125; bigint abs() const &#123; return sign == 1 ? *this : -*this; &#125; long long longValue() const &#123; long long res = 0; for(int i = (int)z.size() - 1; i &gt;= 0; i--) res = res * base + z[i]; return res * sign; &#125; friend bigint gcd(const bigint&amp; a, const bigint&amp; b) &#123; return b.isZero() ? a : gcd(b, a % b); &#125; friend bigint lcm(const bigint&amp; a, const bigint&amp; b) &#123; return a / gcd(a, b) * b; &#125; void read(const string&amp; s) &#123; sign = 1; z.clear(); int pos = 0; while(pos &lt; s.size() &amp;&amp; (s[pos] == '-' || s[pos] == '+')) &#123; if(s[pos] == '-') sign = -sign; ++pos; &#125; for(int i=(int)s.size()-1;i&gt;=pos;i-=base_digits) &#123; int x=0; for(int j=max(pos,i-base_digits+1);j&lt;=i;j++) x=x*10+s[j]-'0'; z.push_back(x); &#125; trim(); &#125; friend istream&amp; operator&gt;&gt;(istream&amp; stream, bigint&amp; v) &#123; string s; stream &gt;&gt; s; v.read(s); return stream; &#125; friend ostream&amp; operator&lt;&lt;(ostream&amp; stream, const bigint&amp; v) &#123; if(v.sign == -1) stream &lt;&lt; '-'; stream &lt;&lt; (v.z.empty() ? 0 : v.z.back()); for(int i = (int)v.z.size() - 2; i &gt;= 0; --i) stream &lt;&lt; setw(base_digits) &lt;&lt; setfill('0') &lt;&lt; v.z[i]; return stream; &#125; static vector&lt;int&gt; convert_base(const vector&lt;int&gt;&amp; a, int old_digits, int new_digits) &#123; vector&lt;long long&gt; p(max(old_digits, new_digits) + 1); p[0] = 1; for(int i=1;i&lt;p.size();i++) p[i]=p[i-1]*10; vector&lt;int&gt; res; long long cur = 0; int cur_digits = 0; for(int v : a) &#123; cur += v * p[cur_digits]; cur_digits += old_digits; while (cur_digits &gt;= new_digits) &#123; res.push_back(int(cur % p[new_digits])); cur /= p[new_digits]; cur_digits -= new_digits; &#125; &#125; res.push_back((int)cur); while(!res.empty() &amp;&amp; res.back()==0) res.pop_back(); return res; &#125; typedef vector&lt;long long&gt; vll; static vll karatsubaMultiply(const vll&amp; a, const vll&amp; b) &#123; int n=a.size(); vll res(n + n); if(n &lt;= 32) &#123; for (int i = 0; i &lt; n; i++) for (int j = 0; j &lt; n; j++) res[i + j] += a[i] * b[j]; return res; &#125; int k = n &gt;&gt; 1; vll a1(a.begin(), a.begin() + k); vll a2(a.begin() + k, a.end()); vll b1(b.begin(), b.begin() + k); vll b2(b.begin() + k, b.end()); vll a1b1 = karatsubaMultiply(a1, b1); vll a2b2 = karatsubaMultiply(a2, b2); for(int i=0;i&lt;k;i++) a2[i]+=a1[i]; for(int i=0;i&lt;k;i++) b2[i]+=b1[i]; vll r = karatsubaMultiply(a2, b2); for(int i=0;i&lt;a1b1.size();i++) r[i]-=a1b1[i]; for(int i=0;i&lt;a2b2.size();i++) r[i]-=a2b2[i]; for(int i=0;i&lt;r.size();i++) res[i+k]+=r[i]; for(int i=0;i&lt;a1b1.size();i++) res[i]+=a1b1[i]; for(int i = 0;i&lt;a2b2.size();i++) res[i+n]+=a2b2[i]; return res; &#125; bigint operator*(const bigint&amp; v) const &#123; vector&lt;int&gt; a6=convert_base(this-&gt;z,base_digits,6); vector&lt;int&gt; b6=convert_base(v.z,base_digits,6); vll a(a6.begin(),a6.end()); vll b(b6.begin(),b6.end()); while(a.size()&lt;b.size()) a.push_back(0); while(b.size()&lt;a.size()) b.push_back(0); while(a.size()&amp;(a.size()-1)) a.push_back(0),b.push_back(0); vll c=karatsubaMultiply(a, b); bigint res; res.sign = sign * v.sign; for (int i = 0, carry = 0; i &lt; c.size(); i++) &#123; long long cur = c[i] + carry; res.z.push_back((int)(cur % 1000000)); carry = (int)(cur / 1000000); &#125; res.z = convert_base(res.z, 6, base_digits); res.trim(); return res; &#125;&#125;;bigint qpow(bigint a,bigint b)&#123; bigint ans=1; while(b!=0)&#123; if(b%2)&#123; ans= ans*a; &#125; b/=2; a= a*a; &#125; return ans;&#125;struct Matrix&#123; bigint a[2][2]; Matrix() &#123; rep(i,0,2)&#123; rep(j,0,2)&#123; a[i][j]=0; &#125; &#125; &#125; Matrix operator * (const Matrix y) &#123; Matrix ans; for(int i = 0; i &lt; 2; i++) for(int j = 0; j &lt; 2; j++) for(int k = 0; k &lt; 2; k++) ans.a[i][j] = ans.a[i][j] + (a[i][k]*y.a[k][j]); return ans; &#125; Matrix operator = (const Matrix y) &#123; for(int i=0;i&lt;2;i++) for(int j=0;j&lt;2;j++) a[i][j]=y.a[i][j]; &#125; Matrix operator *= (const Matrix y) &#123; Matrix ans; for(int i=0;i&lt;2;i++) for(int j=0;j&lt;2;j++) for(int k=0;k&lt;2;k++) ans.a[i][j] = ans.a[i][j] + (a[i][k]*y.a[k][j]); for(int i=0;i&lt;2;i++) for(int j=0;j&lt;2;j++) a[i][j]=ans.a[i][j]; &#125;&#125;;Matrix qpow(bigint x)&#123; Matrix ans; ans.a[0][0]=ans.a[1][1]=1; //单位矩阵 Matrix mul; mul.a[0][0]=4; mul.a[0][1]=-1; mul.a[1][0]=1; mul.a[1][1]=0; while(x!=0) &#123; if(x%2!=0) ans = ans*mul; mul = mul* mul; x/=2; &#125; return ans;&#125;bigint ans[1005];void solve()&#123; ans[0]=(bigint)4; ans[1]=(bigint)14; ans[2]=(bigint)52; rep(i,2,200)&#123; ans[i]=(bigint)4*ans[i-1]-ans[i-2];// cout&lt;&lt;ans[i]&lt;&lt;endl; &#125;&#125;int main()&#123; solve(); int t;cin&gt;&gt;t; while(t--)&#123; bigint n; cin&gt;&gt;n; rep(i,0,200)&#123; if(ans[i]&gt;=n)&#123; cout&lt;&lt;ans[i]&lt;&lt;endl; break; &#125; &#125; &#125;&#125; 收获与反思证明待补充]]></content>
      <categories>
        <category>编程</category>
        <category>ACM</category>
      </categories>
      <tags>
        <tag>算法</tag>
        <tag>ACM</tag>
        <tag>2018秋季训练</tag>
        <tag>HDU</tag>
        <tag>大数</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[金融学辅修——金融学笔记（三）]]></title>
    <url>%2Fpost%2F5f2d4a77.html</url>
    <content type="text"><![CDATA[课前同学分享 庞氏骗局 新用户的资金补贴旧用户，没有新用户加入进来的时候，资金链断裂 江小白发展困境与银行的最后贷款人功能 白芝浩 资管行业三十年蝶变 资产管理：管理资产和风险 基金崛起：公募基金2000年以前以封闭式基金为主，01年-07年黄金发展期，迅速发展，08年-13年股票型和股票型发展势头迅猛。 信托行业转向主动管理。07年至今规范化。 定位与发展 基金：银行理财：信托： 第三章 信用与信用工具什么是信用，信用形式，信用工具，信用与经济（普惠金融）。 第一节 什么是信用信用的含义 Credit，就是相信，信托和声誉。 日常生活中的信用是诚实、守信。 经济学含义是借贷活动的总称，就是债。 指不同所有者之间以偿还本金和支付利息为条件的借贷行为。是市场经济运行规则、市场经济交易方式、一种经济关系。 “信用经济”： 信用与借贷信用与债权债务时同时发生的，时借贷活动的两个方面：在借贷活动中，当事人一方为债权人，他将商品或货币贷出，称为授信；另一方面为债务人，他接受债权人的商品或货币，称为受信；债务人遵守承诺按期偿还商品或货币并支付利息，称为守信。任何时期的债务总额等于信用总量。 社会信用体系：政府信用，企业信用，个人信用。 信用的特点 以所有权与使用权相分离的资金为信用的标的 以还本付息为条件 以相互信任为基础 以收益最大化为目标 借贷双方利益最大化 信用的构成要素 信用的主体：债权人（creditor）与债务人（debtor） 信用标的物：货币资金与实物资金 信用条件：期限与利息 信用工具：（金融工具：记载信用标的，保护债权人权利，具备法律效力的书面凭证） 以口头承诺，账面信用为依据。（没有工具化） 以正式的书面凭证为依据，如借贷契约。（没有流动化） 可在流通市场上转让的信用，如债券（流动化） 信用的基本功能与基本形式 基本功能 资金配置 信用创造 信息传播 宏观调控 信用形式 以期限为标准——长期信用与短期信用 以低于为标准——国内信用与国际信用 以信用主体为标准——商业信用/银行信用/消费信用/国家信用/合作信用/高利贷信用/国际信用等调控 关于高利贷信用，并非政治经济学里面贬义的意思。 官方界定上有正规、非正规、非法。高利贷信用处于非正规和非法的灰色地带。评价注意客观性。 一个企业可能取得的融资方式 企业通过签发商业票据赊账——商业信用 企业以土地等抵押给银行取得商业性贷款，或者政府取得政策性贷款——银行信用 捆包优质资产上市，以固定资产为抵押，企业债券——证券信用 股东同意，减少红利获得更多公积金——内源融资 其他国家发行外国，国际市场发行欧洲债券，背对背协议——国际融资 第二节 信用的形式商业信用 含义 工商企业之间相互提供的，与商品交易直接向联系的信用形式。 方式 赊销，赊购，分期付款。 银行信用 含义 银行信用是指各种金融机构，特别是银行，以存、放款等多种业务形式向工商企业和个人提供的货币形态 的信用，它是在商业信用基础上发展起来的一种更高层次的信用。 地位 克服了资金力量、资信程度、提供方向方面的局限性，能通过对商业票据贴现为商业信用的进一步发展提供了条件， 从而能使它成为整个经济社会信用体系中占据核心地位，成为一国信用关系中的主体。 主要作用 国家信用 国家信用 是国家（包括各级政府）作为债务人，以发行政府债券或借款的方式向国内外企事业单位、团体、居民个人等筹集资金的借贷行为。 基本方式 发行债券（国内债务和国际债务）借款 国债的主要作用 筹措战争费用（战争时期） 平衡财政赤字，缓解货币流通，保持物价稳定（赤字国债） 筹措国家建设资金，举借内债影响经济增长（建设国债） 偿还到期国债（借换国债） 财政支出=财政收入+]]></content>
      <categories>
        <category>金融</category>
        <category>金融学</category>
      </categories>
      <tags>
        <tag>课堂笔记</tag>
        <tag>辅修</tag>
        <tag>金融学</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[金融学辅修——金融学笔记（二）]]></title>
    <url>%2Fpost%2F1233e925.html</url>
    <content type="text"><![CDATA[课前同学分享 离岸人民币市场离岸市场：目标货币发行国境外的货币交易中心 课后补充，美元本位？马歇尔计划？欧洲美元市场。伦敦拆借市场-&gt;欧洲货币市场。 租房贷房东，中介，用户，传统三元模式随着互联网的发展，中介的传统职能被互联网有所替代。不过新的房东，用户二元模式，又存在一些问题。 新三元模式中介面临资金链紧张的问题，故金融机构逐渐引入。租房贷的实质：中介公司 解决方式： 加强监管：透明化和规范化 风险主要分为信用风险和流动风险，信用风险一方面涉及 第四节 货币制度我国的货币制度 我国的法定货币是人民币。 人民币是我国唯一合法流通货币。 人民币的发行实行高度集中统一于中国人民银行。 人民币的发行保证是国家拥有的商品物资，黄金外汇储备主要是作为国际支付的准备金。 纸币发行准备制度的方式： 以黄金或外汇储备准备的发行 无准备发行 第二钟以港币发行为例。香港地方三家银行汇丰， 央行可以通过行政命令，直接宣布汇率变化，来影响 金属本位金银复本位 平行本位：即金银币平等，同事都是本位币，都可以自由铸造和融化自由地输出入国境，金银币的交易比率由市场决定，国家没有法律规定。 问题：由于任一商品都拥有两个价格，比例随金银比价波动，造成价格混乱，给交易带来了很多麻烦。 双本位：格雷欣法则，劣币驱逐良币 劣币驱逐良币律Gresham’s Law：金银复本位制下，两种实际价值不同而含义相同的金属铸币流通时，实际价值高的会通过熔化， 储藏或者到国外而退出流通。 跛行本位 金币可以自由铸造，但是银币不能自由铸造，只可以无限偿还。 金本位制的三种形式 金币本位：纯粹的金币本为： 自由铸造，自由兑换，自由输出入国境 金块本位：金币不再流通，黄金纸币不可自由兑换，一定限额。 两次世界大战期间英法实行，黄金储备不够不足以支持自由兑换（富人本位）。 金汇兑本位：不铸造金币，市场上不流通，本币不可兑换黄金，但本币可以以固定汇率兑换成某一实行金币或金块本位的国家的货币，并在该国兑换黄金。（无法兑换，提供其他两种本位的一个固定汇率关系） 纸币与黄金的关系进一步弱化。 第五节 国际货币体系“黄金——美元”本位制的布雷顿森立体系，美元本位制牙买加体系。 国际货币制度的研边国际金本位制度（1880-1913） =&gt; 浮动汇率制度（1914-1944） =&gt; 布雷顿森林体系（1945-1973） =&gt; 牙买加体系（1978） 国际金本位制特点： 原因 黄金产量不足，长期通货紧缩 黄金产品分布不均 第一次世界大战爆发的刺激 布雷顿森林体系的建立“双挂钩一固定” 美元同黄金挂钩，其他货币与美元挂钩。美元与黄金兑换固定（35美元1盎司）。]]></content>
      <categories>
        <category>金融</category>
        <category>金融学</category>
      </categories>
      <tags>
        <tag>课堂笔记</tag>
        <tag>辅修</tag>
        <tag>金融学</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[【UVALive-7734】解题报告（水题）]]></title>
    <url>%2Fpost%2F47b391f2.html</url>
    <content type="text"><![CDATA[原始题目 题目大意给出$n$种物品每种的个数和价值，求价值总和。 解题思路求和 解题代码1234567891011121314151617181920212223242526272829303132333435363738394041#include&lt;bits/stdc++.h&gt;#include&lt;algorithm&gt;#define rep(i,a,n) for(int i=a;i&lt;n;++i)#define per(i,a,n) for(int i=n-a;i&gt;=a;--i)#define fi first#define se second#define cl(x,a) memset(x,a,sizeof(x))#define all(x) x.begin(),x.end()#define INF 0x3f3f3f3f#define EPS 1e-9#define mod 1000000007using namespace std;const int maxn=1e5+5;const int maxm=1e5+5;typedef long long ll;typedef unsigned long long ull;typedef vector&lt;int&gt; vi;typedef pair&lt;int,int&gt; pii;int t,n,m;int main()&#123; ios::sync_with_stdio(false); cin&gt;&gt;t; while(t--)&#123; cin&gt;&gt;n; ll ans=0; rep(i,0,n)&#123; int a,b; cin&gt;&gt;a&gt;&gt;b; ans+=a*b; &#125; cout&lt;&lt;ans&lt;&lt;endl; &#125;&#125; 收获与反思暂无]]></content>
      <categories>
        <category>编程</category>
        <category>ACM</category>
      </categories>
      <tags>
        <tag>算法</tag>
        <tag>ACM</tag>
        <tag>2018秋季训练</tag>
        <tag>UVALive</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[【UVALive-7737】解题报告（概率，时间独立性，暴力）]]></title>
    <url>%2Fpost%2F273ced06.html</url>
    <content type="text"><![CDATA[原始题目 题目大意Bob想从$n$种硬币中选出一种幸运硬币。选择策略如下： 如果当前没有剩下的硬币或者只剩下一种硬币，则该硬币为幸运硬币。 否则，将现有硬币抛出后，保留所有正面朝上的硬币。 给出每种硬币抛出后正面朝上的概率，计算各种硬币成为幸运硬币的概率。 解题思路由于题目中更说明：每种硬币抛出后正面朝上的概率在0.4和0.6之间 易分析知抛得次数可能是无限的，但连续一百次正面朝上的概率已经很小（精度要求内可忽略不计），想到打表。 $alive[i][j]$ 表示第i种硬币能存留到第j次抛出之前。 $dead[i][j]$ 表示第i种硬币不能存留到第j次抛出之前。 则最终答案为 $ans[i]= \sum (alive[i][j]-alive[i][j+1])*( \sum dead[k][j]) $ 解题代码123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384#include&lt;bits/stdc++.h&gt;#include&lt;algorithm&gt;#define rep(i,a,n) for(int i=a;i&lt;n;++i)#define per(i,a,n) for(int i=n-a;i&gt;=a;--i)#define fi first#define se second#define cl(x,a) memset(x,a,sizeof(x))#define all(x) x.begin(),x.end()#define INF 0x3f3f3f3f#define EPS 1e-9#define mod 1000000007#define FF 150using namespace std;const int maxn=1e3+5;const int maxm=1e5+5;typedef long long ll;typedef unsigned long long ull;typedef vector&lt;int&gt; vi;typedef pair&lt;int,int&gt; pii;int t,n,m;int num[maxn];double p[maxn];double dead[maxn][FF];double alive[maxn][FF];double ans[maxn];double qpow(double a,int x)&#123; double ans=1.0; while(x)&#123; if(x&amp;1) ans *=a; a*=a; x&gt;&gt;=1; &#125; return ans;&#125;void solve()&#123; rep(i,1,n+1)&#123; rep(j,1,FF)&#123; double temp=qpow(p[i],j); dead[i][j]=qpow((1.0-temp),num[i]); alive[i][j]=1.0-dead[i][j]; &#125; &#125;&#125;int main()&#123; ios::sync_with_stdio(false); cin&gt;&gt;t; while(t--)&#123; cin&gt;&gt;n; rep(i,1,n+1)&#123; cin&gt;&gt;num[i]&gt;&gt;p[i]; &#125; if(n==1)&#123; cout&lt;&lt;fixed&lt;&lt;setprecision(6)&lt;&lt;1.0&lt;&lt;endl; continue; &#125; memset(alive,0,sizeof(alive)); memset(dead,0,sizeof(dead)); solve(); rep(i,1,n+1)&#123; ans[i]=0; rep(j,1,FF)&#123; double temp=1.0; rep(k,1,n+1)&#123; if(i==k) continue; else&#123; temp*=dead[k][j]; &#125; &#125; ans[i]+=temp*(alive[i][j]-alive[i][j+1]); &#125; &#125; cout&lt;&lt;fixed&lt;&lt;setprecision(6)&lt;&lt;ans[1]; rep(i,2,n+1)&#123; cout&lt;&lt;" "&lt;&lt;fixed&lt;&lt;setprecision(6)&lt;&lt;ans[i]; &#125; cout&lt;&lt;endl; &#125;&#125; 收获与反思注意分析概率的公式。]]></content>
      <categories>
        <category>编程</category>
        <category>ACM</category>
      </categories>
      <tags>
        <tag>算法</tag>
        <tag>ACM</tag>
        <tag>2018秋季训练</tag>
        <tag>UVALive</tag>
        <tag>概率</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[【CSU-1112】解题报告（模拟，水题）]]></title>
    <url>%2Fpost%2F1c52564f.html</url>
    <content type="text"><![CDATA[原始题目1112: 机器人的指令 Time Limit: 1 Sec Memory Limit: 128 Mb Submitted: 3392 Solved: 1245 Description数轴原点有一个机器人。该机器人将执行一系列指令，你的任务是预测所有指令执行完毕之后它的位置。 LEFT：往左移动一个单位 RIGHT: 往右移动一个单位 SAME AS i: 和第i 条执行相同的动作。输入保证i 是一个正整数，且不超过之前执行指令数 Input输入第一行为数据组数$T (T≤100)$。每组数据第一行为整数 $n (1≤n≤100) $，即指令条数。以下每行一条指令。指令按照输入顺序编号为$1 \cdots n$。 Output对于每组数据，输出机器人的最终位置。每处理完一组数据，机器人应复位到数轴原点。 Sample Input2 3 LEFT RIGHT SAME AS 2 5 LEFT SAME AS 1 SAME AS 2 SAME AS 1 SAME AS 4 Sample Output1 -5 HintSource湖南省第八届大学生计算机程序设计竞赛 题目大意如题 解题思路储存每一操作，线性扫。 解题代码12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455#include &lt;cstdio&gt;#include&lt;cstring&gt;#include &lt;set&gt;#include &lt;string&gt;#include &lt;iostream&gt;#include &lt;iomanip&gt;#include &lt;queue&gt;#include &lt;vector&gt;#include &lt;map&gt;#include &lt;algorithm&gt;#define rep(i,a,n) for(int i=a;i&lt;n;++i)#define per(i,a,n) for(int i=n-1;i&gt;=a;--i)#define cl(x,a) memset(x,a,sizeof(x))#define all(x) x.begin(),x.end()#define INF 0x3f3f3f3f#define EPS 1e-9#define mod 1000000007#define fi first#define se secondusing namespace std;const int maxn=1e5+5;typedef long long ll;typedef unsigned long long ull;typedef vector&lt;int&gt; vi;typedef pair&lt;int,int&gt; pii;int t,n,m,a;int num[maxn];string ctl;int main()&#123; ios::sync_with_stdio(false); cin&gt;&gt;t; while(t--)&#123; int temp=0; cin&gt;&gt;n; rep(i,1,n+1)&#123; cin&gt;&gt;ctl; if(ctl[0]=='S')&#123; cin&gt;&gt;ctl&gt;&gt;a; num[i]=num[a]; &#125; else if(ctl[0]=='L')&#123; num[i]=-1; &#125; else num[i]=1; &#125; rep(i,1,n+1)&#123; temp+=num[i]; &#125; cout&lt;&lt;temp&lt;&lt;endl; &#125;&#125; 收获与反思暂无]]></content>
      <categories>
        <category>编程</category>
        <category>ACM</category>
      </categories>
      <tags>
        <tag>算法</tag>
        <tag>ACM</tag>
        <tag>CSU</tag>
        <tag>Imitation</tag>
        <tag>2018秋季训练</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[【CSU-1104】解题报告（博弈游戏，找规律）]]></title>
    <url>%2Fpost%2Ffeaebfb5.html</url>
    <content type="text"><![CDATA[原始题目]]></content>
      <categories>
        <category>编程</category>
        <category>ACM</category>
      </categories>
      <tags>
        <tag>算法</tag>
        <tag>ACM</tag>
        <tag>CSU</tag>
        <tag>博弈</tag>
        <tag>2018秋季培训</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[金融学辅修——金融学笔记（一）]]></title>
    <url>%2Fpost%2F222505fd.html</url>
    <content type="text"><![CDATA[第一节 什么是货币金融学的起点，也是金融学的终点。所有金融现象、金融行为都是某种程度的或大或小的货币事件。 货币就是金钱，信用就是金钱，金钱可生金钱。货币决定未来世界格局。 IMF，国际货币基金组织，成员国，运行“份子”根据本国对外贸易占世界贸易中的比重，以及GDP水平等来衡量。投票权重与“份子”相关，百分之十五决议通过，而目前美元比重占比17%，所以几乎等于断言。IMF也是随着布雷顿森林体系的建立而崛起的。 货币的产生中国古代货币起源说（解决民间秒换困难，沟通产品交换的手段）。 西方货币起源说（创造发明说，便于交换说，保存财富说）。 马克思货币起源说（货币是商品生产和商品交换发展的必然产物，是商品经济内在矛盾发展的必然结果）。 进一步解释马克思的解释： 简单的物物交换=&gt;复杂的物物交换=&gt;（规模逐渐发展，信用，复杂程度等多方面影响）=&gt;货币的产生 货币的本质货币金属说，货币名目说，劳动价值说。 货币的定义经济学中成为货币的东西，就是人们日常生活中的钱的东西。由于时代背景，观察角度、观察深度不同以及侧重于理论剖析与侧重于解决实际问题需要不同，定义表述不同。 本质定义：从商品交换中分离出来固定地充当一般等价物的特殊商品。 经济学定义：在商品或劳务支付中或债务偿还中被普遍接受的任何东西。 法定货币（法律定义）：通过立法授予某种物品具有清偿债务的合法权利。 层次定义（计量定义）： M0=流通中现金（通货） M1=M0+企业活期存款+农业存款+]]></content>
      <categories>
        <category>金融</category>
        <category>金融学</category>
      </categories>
      <tags>
        <tag>课堂笔记</tag>
        <tag>辅修</tag>
        <tag>金融学</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[【CSU-1111】解题报告（水题）]]></title>
    <url>%2Fpost%2Fe256d99f.html</url>
    <content type="text"><![CDATA[原始题目1111: 三家人 Time Limit: 1 Sec Memory Limit: 128 Mb Submitted: 4053 Solved: 1606 Description有三户人家共拥有一座花园，每户人家的太太均需帮忙整理花园。A 太太工作了5 天，B 太太则工作了4 天，才将花园整理完毕。C 太太因为正身怀六甲无法加入她们的行列，便出了90元。请问这笔钱如何分给A、B 二位太太较为恰当？A 应得多少元？$ 5 \times \frac {90} {5+4}= 50 $？如果这么想你就上当了！正确答案是60 元。如果没想通的话再想想吧。 下面回答一个一般性的问题：假定A 太太工作了x 天，B 太太工作了y 天，C 太太出了90元，则A 太太应得多少元？输入保证二位太太均应得到非负整数元钱。三个太太工作效率相同。 友情提示：本题有个小小的陷阱哦。如果答案错的话，认真检查一下代码吧。 Input输入第一行为数据组数$T (T ≤ 20) $。每组数据仅一行，包含三个整数 $x, y, z (1 ≤ x, y ≤10,1 ≤ z ≤1000) $。 Output对于每组数据，输出一个整数，即A 太太应得的金额（单位：元）。 Sample Input2 5 4 90 8 4 123 Sample Output60 123 Hint如果使用浮点数，请小心误差，输出时尽量用四舍五入。 Source湖南省第八届大学生计算机程序设计竞赛 题目大意如题 解题思路考虑每个人都应该完成$ \frac {1}{3} $ 的工作量。再按多余完成量分配钱，注意考虑工作量不够自己应该完成的情况。 解题代码123456789101112131415161718192021222324252627282930313233#include &lt;cstdio&gt;#include &lt;cstring&gt;#include &lt;iostream&gt;#include &lt;iomanip&gt;#include &lt;cstdlib&gt;#include &lt;set&gt;#include &lt;string&gt;#include &lt;cstring&gt;#include &lt;stack&gt;#define rep(i,a,n) for(int i=a;i&lt;n;++i)#define per(i,a,n) for(int i=n-1;i&gt;=a;--i)using namespace std;const int maxn=1e5+5;const int maxl=26;int t,n;double x,y,z; int main()&#123; ios::sync_with_stdio(false); cin&gt;&gt;t; while(t--)&#123; cin&gt;&gt;x&gt;&gt;y&gt;&gt;z; double ans=(x+y)/3.0; if(ans&gt;(double)x) cout&lt;&lt;0&lt;&lt;endl; else if(ans&gt;(double)y) cout&lt;&lt;fixed&lt;&lt;setprecision(0)&lt;&lt;z&lt;&lt;endl; else &#123; x-=ans; y-=ans; cout&lt;&lt;fixed&lt;&lt;setprecision(0)&lt;&lt;z*x/(x+y)&lt;&lt;endl; &#125; &#125;&#125; 收获与反思水题]]></content>
      <categories>
        <category>编程</category>
        <category>ACM</category>
      </categories>
      <tags>
        <tag>算法</tag>
        <tag>ACM</tag>
        <tag>CSU</tag>
        <tag>2018暑假集训</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[【CSU-1115】解题报告（字典树）]]></title>
    <url>%2Fpost%2Fe5d75450.html</url>
    <content type="text"><![CDATA[原始题目1115: 最短的名字 Time Limit: 5 Sec Memory Limit: 64 Mb Submitted: 2057 Solved: 801 Description在一个奇怪的村子中，很多人的名字都很长，比如aaaaa, bbb and abababab。 名字这么长，叫全名显然起来很不方便。所以村民之间一般只叫名字的前缀。比如叫’aaaaa’的时候可以只叫’aaa’，因为没有第二个人名字的前三个字母是’aaa’。不过你不能叫’a’，因为有两个人的名字都以’a’开头。村里的人都很聪明，他们总是用最短的称呼叫人。输入保证村里不会有一个人的名字是另外一个人名字的前缀（作为推论，任意两个人的名字都不会相同）。 如果村里的某个人要叫所有人的名字（包括他自己），他一共会说多少个字母？ Input输入第一行为数据组数$T (T≤10)$。每组数据第一行为一个整数n$(1≤n≤1000)$ ，即村里的人数。以下$n$行每行为一个人的名字（仅有小写字母组成）。输入保证一个村里所有人名字的长度之和不超过 $10^{6}$。 Output对于每组数据，输出所有人名字的字母总数。 Sample Input1 3 aaaaa bbb abababab Sample Output5 HintSource湖南省第八届大学生计算机程序设计竞赛 题目大意如题 解题思路建立字典树，每个结点的value值储存单词字母的出现次数。 对于每个单词，统计第一个出现value值为1的位置（表示到这里后面没有相同单词前缀） 求和，完成任务 解题代码123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109#include &lt;cstdio&gt;#include &lt;cstring&gt;#include &lt;iostream&gt;#include &lt;cstdlib&gt;#include &lt;set&gt;#include &lt;string&gt;#include &lt;cstring&gt;#include &lt;stack&gt;#define rep(i,a,n) for(int i=a;i&lt;n;++i)#define per(i,a,n) for(int i=n-1;i&gt;=a;--i)using namespace std;const int maxn=1e5+5;const int maxl=26;typedef long long ll;typedef struct Trie&#123; int v; Trie* next[maxl];&#125;Trie; Trie *root;void iniTrie()&#123; root=(Trie*)malloc(sizeof(Trie)); for(int i=0;i&lt;maxl;i++) root-&gt;next[i]=NULL; root-&gt;v=-1;&#125;bool creTrie(string a)&#123; int l=a.length(); Trie *p=root,*q; for(int i=0;i&lt;l;i++) &#123; int id=a[i]-&apos;a&apos;; //并非前缀不能有相同，而是不能在相同的分支上。 // if(i==l-1)&#123;// if(p-&gt;next[id]!=NULL) return 0;// &#125; if(p-&gt;next[id]==NULL)&#123; q=(Trie*) malloc(sizeof(Trie)); q-&gt;v=1; for(int j=0;j&lt;maxl;j++) q-&gt;next[j]=NULL; // //结点连接到树上 p-&gt;next[id]=q; p=p-&gt;next[id]; &#125; else&#123; p=p-&gt;next[id]; p-&gt;v++; &#125; &#125; return 1;&#125;int cntTrie(string ss)&#123; int l=ss.length(); Trie *p=root,*q; for(int i=0;i&lt;l;i++) &#123; int id=ss[i]-&apos;a&apos;; p=p-&gt;next[id]; if(p-&gt;v==1) return i+1; &#125;&#125;void delTrie(Trie *p) &#123; int i; for(i=0;i&lt;maxl;i++) &#123; if(p-&gt;next[i] != NULL) delTrie(p-&gt;next[i]); &#125; free(p);// printf(&quot;1&quot;); p==NULL; return ;&#125; string s[maxn];int t,ccount,n;int main()&#123; ios::sync_with_stdio(false); cin&gt;&gt;t; while(t--)&#123; iniTrie(); cin&gt;&gt;n; rep(i,0,n)&#123; cin&gt;&gt;s[i]; creTrie(s[i]); &#125; int aans=0; rep(i,0,n)&#123; aans+=cntTrie(s[i]); &#125; cout&lt;&lt;aans&lt;&lt;endl; delTrie(root); &#125;&#125; 收获与反思灵活运用字典树的染色和统计功能]]></content>
      <categories>
        <category>编程</category>
        <category>ACM</category>
      </categories>
      <tags>
        <tag>算法</tag>
        <tag>ACM</tag>
        <tag>CSU</tag>
        <tag>2018暑假集训</tag>
        <tag>字典树</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[【CSU-1101】解题报告（水题，模拟）]]></title>
    <url>%2Fpost%2Fd6a5bd15.html</url>
    <content type="text"><![CDATA[原始题目1101: 报数游戏 Time Limit: 1 Sec Memory Limit: 128 Mb Submitted: 1400 Solved: 474 Descriptionn个人站成一行玩一个报数游戏。所有人从左到右编号为1到n。游戏开始时，最左边的人报1，他右边的人报2，编号为3的人报3，等等。当编号为n的人（即最右边的人）报完n之后，轮到他左边的人（即编号为n-1的人）报n+1，然后编号为n-2的人报n+2，以此类推。当最左边的人再次报数之后，报数方向又变成从左到右，依次类推。为了防止游戏太无聊，报数时有一个特例：如果应该报的数包含数字7或者是7的倍数，他应当用拍手代替报数。下表是n=4的报数情况（X表示拍手）。当编号为3的人第4次拍手的时候，他实际上数到了35。 给定$n,m,k$，你的任务是计算当编号为 $m$ 的人第 $k$ 次拍手时，他实际上数到了几。 Input输入包含不超过10组数据。每组数据占一行，包含三个整数 $n,m$ 和 $k$ $( 2 ≤ n ≤ 100, 1 ≤ m ≤n, 1 ≤ k ≤ 100)$。输入结束标志为 $n=m=k=0$。 Output对于每组数据，输出一行，即编号为 $m$ 的人第 $k$ 次拍手时，他实际上数到的那个整数。 Sample Input4 3 1 4 3 2 4 3 3 4 3 4 0 0 0 Sample Output17 21 27 35 HintSource湖南省第七届大学生计算机程序设计竞赛 题目大意如题 解题思路直接模拟 解题代码12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364656667686970#include &lt;cstdio&gt;#include &lt;cstring&gt;#include &lt;cstdlib&gt;#include &lt;string&gt;#include &lt;iostream&gt;#include &lt;iomanip&gt;#include &lt;queue&gt;#include &lt;stack&gt;#include &lt;vector&gt;#include &lt;set&gt;#include &lt;map&gt;#include &lt;algorithm&gt;#include &lt;bits/stdc++.h&gt;#define fi first#define se second#define rep(i,a,n) for(int i=a;i&lt;n;++i)#define per(i,a,n) for(int i=n-1;i&gt;=a;--i)#define cl(x,a) memset(x,a,sizeof(x)) #define all(x) x.begin,x.end()#define INF 0x3f3f3f3f#define eps 1e-8using namespace std;typedef long long ll;typedef unsigned long long ull;typedef vector&lt;int&gt; vi;typedef pair&lt;int,int&gt; pii;typedef pair&lt;string,string&gt; pss;const int maxn=1e5+5;const int maxm=1e5+5;const int maxl=26;int vis[maxn];bool check(ll num)&#123; while(num)&#123; int temp=num%10; if(temp==7) return 1; num/=10; &#125; return 0;&#125;int main()&#123; ll n,m,k,cnt=0; int flag=0; while(~scanf("%lld%lld%lld",&amp;n,&amp;m,&amp;k) &amp;&amp; n+m+k)&#123; memset(vis,0,sizeof(vis)); flag=0,cnt=0; while(vis[m]&lt;k)&#123; rep(i,1,n)&#123; if((++cnt )%7==0 || check(cnt)) &#123;// cout&lt;&lt;"i="&lt;&lt;i&lt;&lt;" cnt="&lt;&lt;cnt&lt;&lt;endl; vis[i]++; &#125; if(vis[m]==k) break; &#125; if(vis[m]==k) break; per(i,2,n+1)&#123; if((++cnt)%7==0 || check(cnt)) &#123;// cout&lt;&lt;"i="&lt;&lt;i&lt;&lt;" cnt="&lt;&lt;cnt&lt;&lt;endl; vis[i]++; &#125; if(vis[m]==k) break; &#125; &#125; cout&lt;&lt;cnt&lt;&lt;endl; &#125; &#125; 收获与反思直接模拟即可]]></content>
      <categories>
        <category>编程</category>
        <category>ACM</category>
      </categories>
      <tags>
        <tag>算法</tag>
        <tag>ACM</tag>
        <tag>CSU</tag>
        <tag>Imitation</tag>
        <tag>2018暑假集训</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[【CSU-1315】解题报告（排序，前缀和）]]></title>
    <url>%2Fpost%2Fe7058b47.html</url>
    <content type="text"><![CDATA[原始题目1315: 全场最水题之陈兴老师与比赛 Time Limit: 1 Sec Memory Limit: 128 Mb Submitted: 841 Solved: 280 Description大家都知道ACM比赛罚时很重要。比如说你做A题要10分钟，B题要15分钟，如果先做A题再做B题，那么在ranking上的时间就是10 + （10）+ 15 = 35。如果先做B题再做A题总罚时就是15+(15)+10=40.现在陈兴老师要做一场比赛，比赛有$n$道题， 总时间是$300$分钟。我们的陈兴老师仅仅看题目就可以知道他做每道题需要的时间，所以他想在比赛刚开始时就计算出自己的最大总做题数，以及对应的总罚时和做题顺序（当然，做题数相等时当然希望总罚时最少咯）。比如一般的比赛，陈兴老师做第一题需要1分钟，第二题2分钟，依此类推，陈兴老师只需要66分钟就可以AK一场11道题的比赛。PS: 陈兴老师做题都是1Y，膜拜陈兴老师Orz！ Input第一行是一个数字 $n (0&lt;n ≤25)$ 。 第二行是$n$个数字，第$i$个数字代表陈兴老师出编号为$i$的题所需要的时间 $t_i( 0 &lt; t_i ≤ 80)$。 Output第一行输出陈兴老师的出题数和Penalty（总时间） 以下按照顺序输出陈兴老师出题的顺序,每行一个编号。（详见输出样例）PS：时间一样的按编号升序输出。 Sample Input3 1 2 3 4 1 2 3 4 6 60 60 60 60 60 60 Sample Output3 10 1 2 3 4 20 1 2 3 4 5 900 1 2 3 4 5 HintSource题目大意原题说的不大清楚，实际上对于每到AC题目罚时累加上从开始到完成该题目的时间，比赛一共300分钟，求解题数，罚时，并输出接替顺序。（感觉整理CSU题面的时候应该再完善一下题目意思） 解题思路排序以后求前缀和，当前缀和超过300时输出 解题代码12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364656667686970717273747576#include &lt;cstdio&gt;#include &lt;cstring&gt;#include &lt;iostream&gt;#include &lt;iomanip&gt;#include &lt;set&gt;#include &lt;queue&gt;#include &lt;map&gt;#include &lt;sstream&gt;#include &lt;algorithm&gt;#include &lt;vector&gt;#include &lt;stack&gt;#include &lt;cmath&gt;#define rep(i,a,n) for(int i=a;i&lt;n;++i)#define per(i,a,n) for(int i=n-1;i&gt;=a;--i)#define fi first#define se second#define mp make_pair#define pb push_back#define np next_permutation#define all(x) x.begin(),x.end()#define insert(x) x,x.begin()#define cl(x,a) memset(x,a,sizeof(x))using namespace std;const int maxn=1e5+5;const int maxm=1e5+5;const int maxl=26;typedef long long ll;typedef unsigned long long ull;typedef vector&lt;int&gt; vi;typedef pair&lt;int,int&gt; pii;typedef pair&lt;string,string&gt; pss;bool cmp(pii a,pii b)&#123; if(a.second!=b.second) return a.second&lt;b.second; else return a.first&lt;b.first;&#125;int n,t,a[maxn];int main()&#123;// ios::sync_with_stdio(false); while(~scanf("%d",&amp;n))&#123; vector&lt;pii&gt; v; rep(i,1,n+1)&#123; int temp; scanf("%d",&amp;temp); v.pb(mp(i,temp)); &#125; sort(all(v),cmp); a[0]=v[0].second; rep(i,1,n) &#123; a[i]=a[i-1]+v[i].second;// cout&lt;&lt;"a["&lt;&lt;i&lt;&lt;"] = "&lt;&lt;a[i]&lt;&lt;endl; &#125; int panality=0,i=0,caltime=0; for(;i&lt;n&amp;&amp;caltime&lt;=300;i++)&#123; panality+=a[i]; caltime+=v[i].second; &#125; if(caltime&lt;=300) &#123;// cout&lt;&lt;n&lt;&lt;" "&lt;&lt;panality&lt;&lt;endl; printf("%d %d\n",n,panality);// rep(i,0,n) cout&lt;&lt;v[i].fi&lt;&lt;endl; rep(i,0,n) printf("%d\n",v[i].fi); &#125; else &#123; panality-=a[--i];// cout&lt;&lt;i&lt;&lt;" "&lt;&lt;panality&lt;&lt;endl; printf("%d %d\n",i,panality);// rep(i,0,n) cout&lt;&lt;v[i].fi&lt;&lt;endl; rep(j,0,i) printf("%d\n",v[j].fi); &#125; &#125;&#125; 收获与反思排序一下]]></content>
      <categories>
        <category>编程</category>
        <category>ACM</category>
      </categories>
      <tags>
        <tag>算法</tag>
        <tag>ACM</tag>
        <tag>CSU</tag>
        <tag>2018暑假集训</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[【CSU-1321】解题报告（最短路，dij）]]></title>
    <url>%2Fpost%2F4773b69c.html</url>
    <content type="text"><![CDATA[原始题目1321: CX and girls Time Limit: 1 Sec Memory Limit: 128 Mb Submitted: 597 Solved: 181 DescriptionCX是要赶去上课，为了不迟到必须要以最短的路径到达教室，同时CX希望经过的路上能看到的学妹越多越好。现在把地图抽象成一个无向图，CX从$1$点出发，教室在$N$号点，告诉每个点上学妹的数量，每条边的长度。 请你求出CX以最短路径赶到教室最多能看到多少学妹。 Input多组输入数据(最多20组)，输入到文件结束。 每组数据第一行两个正整数$N,M$其中$N$代表点的个数$( 2 ≤ N ≤ 1000)$，$M$代表边的个数$(1 ≤ M ≤ 10000)$。 接下来一行$N$个数，代表着$1 \cdots N$每个点上学妹的个数，$(0 ≤ N_i \le 50)$。 接下来$M$行，每行三个数$A,B,C (1 \le A , B \le N , 0 &lt; C \le 100 )$ 代表$A,B$两点间有边，长度为$C$。(可能存在重边) Output输出CX以最短距离从$1$到$n$的情况下能看到的最多学妹数量，若从点$1$无法到达点$N$输出$-1$。 Sample Input4 4 1 2 3 4 1 2 1 1 3 1 2 4 2 3 4 2 Sample Output8 AuthorCSU_ZZY SourceCSU Monthly 2013 Oct. 题目大意如题 解题思路最短路加上对结点值的判断 解题代码123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103#include &lt;cstdio&gt;#include &lt;cstring&gt;#include &lt;string&gt;#include &lt;algorithm&gt;#include &lt;iostream&gt;#include &lt;stack&gt;#include &lt;set&gt;#include &lt;vector&gt;#include &lt;queue&gt;#include &lt;cmath&gt;#include &lt;cstdlib&gt;#include &lt;bits/stdc++.h&gt; using namespace std;#define eps 1e-8#define INF 0x3f3f3f3f#define rep(i,a,n) for(int i=a;i&lt;n;i++)#define per(i,a,n) for(int i=n-1;i&gt;=a;i--)#define all(x) x.begin(),x.end()#define pb push_back#define np next_permutation#define ms(x,a) memset((x),(a),sizeof(x))//优先队列迪杰斯特拉 const int maxn=1e5+5;struct Edge&#123; int u,v,w; Edge(int _u,int _v,int _w):u(_u),v(_v),w(_w)&#123; &#125;;&#125;;vector &lt;Edge&gt; edges[maxn];int dis[maxn],meizi[maxn],mei[maxn];bool vis[maxn];int n,m,uu,vv,ww;void init(int n)&#123; //n个结点的边集都清空 rep(i,0,maxn)&#123; edges[i].clear(); &#125;&#125;void addEdge(int u,int v,int w)&#123; edges[u].pb(Edge(u,v,w));&#125;struct Node&#123; int Id,W; Node(int _Id,int _W):Id(_Id),W(_W)&#123; &#125;; bool operator &lt; (const Node &amp;b) const &#123; return W&gt;b.W;// else return Id&lt;b.Id; &#125;&#125;;void Dijkstra(int s)&#123; ms(vis,0); ms(meizi,0); ms(dis,INF); priority_queue &lt;Node&gt; q; q.push(Node(s,0)) ; dis[s]=0;meizi[s]=mei[s]; while(!q.empty())&#123; Node now=q.top(); q.pop(); int index=now.Id; if(vis[index]) continue;// if(index==end) return; vis[index]=1; rep(i,0,edges[index].size())&#123; Edge temp=edges[index][i]; if(dis[temp.v]&gt;dis[index]+temp.w)&#123; dis[temp.v]=dis[index]+temp.w; meizi[temp.v]=meizi[index]+mei[temp.v]; q.push(Node(temp.v,dis[temp.v])); &#125; else if(dis[temp.v]==dis[index]+temp.w)&#123; if(meizi[temp.v]&lt;meizi[index]+mei[temp.v])&#123; meizi[temp.v]=meizi[index]+mei[temp.v]; q.push(Node(temp.v,dis[temp.v])); &#125; &#125; &#125; &#125;&#125;int main()&#123; ios::sync_with_stdio(false); while(cin&gt;&gt;n&gt;&gt;m)&#123; init(n); rep(i,1,n+1)&#123; cin&gt;&gt;mei[i]; &#125; rep(i,1,m+1)&#123; cin&gt;&gt;uu&gt;&gt;vv&gt;&gt;ww; addEdge(uu,vv,ww); addEdge(vv,uu,ww); &#125; Dijkstra(1); if(dis[n]&gt;100000000) cout&lt;&lt;"-1"&lt;&lt;endl; else cout&lt;&lt;meizi[n]&lt;&lt;endl; &#125; &#125; 收获与反思 模板开始错了，少了return，WA了一晚上。]]></content>
      <categories>
        <category>编程</category>
        <category>ACM</category>
      </categories>
      <tags>
        <tag>算法</tag>
        <tag>ACM</tag>
        <tag>CSU</tag>
        <tag>2018暑假集训</tag>
        <tag>Dijkstra</tag>
        <tag>最短路</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[【CSU-1323】解题报告（字典树）]]></title>
    <url>%2Fpost%2F677d0fef.html</url>
    <content type="text"><![CDATA[原始题目1323: ZZY and his little friends Time Limit: 5 Sec Memory Limit: 256 Mb Submitted: 708 Solved: 258 Descriptionzzy养了一只小怪兽和N只凹凸曼，单挑的话每只凹凸曼都不是小怪兽的对手，所以必须由两只凹凸曼合作来和小怪兽战斗。凹凸曼A和凹凸曼B合作的战斗力为他们战斗力的异或值。现在由zzy从N只凹凸曼中选出两只来和小怪兽战斗。 请问zzy能否选出两只凹凸曼使他们能够战胜小怪兽(他们的战斗力比小怪兽大)。 Input输入有多个例子，直到文件结束。 每个例子的第一行含两个数N和M，表示有 $ N ( 2 \le N \le 10^5 )$只凹凸曼，小怪兽的战斗力为$ M (0 &lt; M \le 10^9 )$。接着有一行N个数，每个数 $ A_i ( 0 &lt; A_i &lt; M )$表示每只凹凸曼的战斗力。 Output对于每个例子输出一行，如果能选出两只凹凸曼使他们战胜小怪兽输出”YES”, 否则输出”NO”(不含引号) Sample Input2 5 1 1 2 6 5 2 Sample OutputNO YES Author CSU_CX SourceCSU Monthly 2013 Oct. 题目大意如题 解题思路01字典树，将数字转换为32位的01数字串（高位在前）储存到树中。然后扫一遍求异最大值，与题目给定的$M$比较。 接替代码123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131#include &lt;cstdio&gt;#include &lt;cstring&gt;#include &lt;cmath&gt;#include &lt;set&gt;#include &lt;queue&gt;#include &lt;map&gt;#include &lt;set&gt;#include &lt;string&gt;#include &lt;iostream&gt;#include &lt;iomanip&gt;#include &lt;stack&gt;#define rep(i,a,n) for(int i=a ; i&lt;n;++i)#define per(i,a,n) for(int i=n-1;i&gt;=a;--i)#define fi first#define se second#define cl(x,a) memset(x,a,sizeof(x)) #define all(x) x.begin(),x.end()#define insert(x) x,x.begin()#define debug printf("======================\n");#define mp make_pair#define np next_permutation#define pb push_back#define INF 0x3f3f3f3f#define eps 1e-8using namespace std;const int maxn=1e5+5;const int maxm=1e5+5;const int maxl=2;const int K=32;typedef long long ll;typedef struct Trie&#123; int v; Trie* next[maxl];&#125;Trie;Trie *root;void iniTrie()&#123; root=(Trie*) malloc(sizeof(Trie)); rep(i,0,maxl) root-&gt;next[i]=NULL; root-&gt;v=-1; &#125;bool creTrie(int a)&#123; //预处理整数为01数组 int temp[35]; int id=K-1; while(a)&#123; temp[id--]=(a&amp;1); a&gt;&gt;=1; &#125; rep(i,0,id+1) temp[i]=0; int l=K; Trie *p=root,*q; rep(i,0,l)&#123; int id=temp[i]; if(p-&gt;next[id]!=NULL)&#123; p=p-&gt;next[id]; &#125; else &#123; q=(Trie*) malloc(sizeof(Trie)); q-&gt;v=1; //新建节点染色 for(int j=0;j&lt;maxl;j++) q-&gt;next[j]=NULL; p-&gt;next[id]=q; p=p-&gt;next[id]; &#125; &#125; &#125;int findTrie(int a)&#123; int aa=a; int temp[35]; int id=K-1; while(a)&#123; temp[id--]=(a&amp;1); a&gt;&gt;=1; &#125; rep(i,0,id+1) temp[i]=0; //前面位置补0 int aans=0; Trie *p=root; int l=K; for(int i=0;i&lt;l;i++)&#123; int index= !temp[i]; if(p-&gt;next[index] !=NULL )&#123; aans=(aans&lt;&lt;1)+index; p=p-&gt;next[index]; &#125; else &#123; aans=(aans&lt;&lt;1)+temp[i]; p=p-&gt;next[temp[i]]; &#125; &#125; return aans^aa; &#125;void delTrie(Trie *p)&#123; int i; for(int i=0;i&lt;maxl;i++)&#123; if(p-&gt;next[i]!= NULL) delTrie(p-&gt;next[i]); &#125; free(p); p=NULL; return ;&#125;int a[maxn],n,m;int main()&#123; ios::sync_with_stdio(false); while(cin&gt;&gt;n&gt;&gt;m)&#123; iniTrie(); rep(i,0,n)&#123; cin&gt;&gt;a[i]; creTrie(a[i]); &#125; int fans=0; rep(i,0,n)&#123; fans=max(fans,findTrie(a[i])); &#125; if(fans&gt;m) cout&lt;&lt;"YES"&lt;&lt;endl; else cout&lt;&lt;"NO"&lt;&lt;endl; &#125; &#125; 收获与反思熟悉求异或最大值01字典树的操作。]]></content>
      <categories>
        <category>编程</category>
        <category>ACM</category>
      </categories>
      <tags>
        <tag>算法</tag>
        <tag>ACM</tag>
        <tag>CSU</tag>
        <tag>2018暑假集训</tag>
        <tag>字典树</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[【CSU-1330】解题报告（水题，字符串）]]></title>
    <url>%2Fpost%2Fbba462fb.html</url>
    <content type="text"><![CDATA[原始题目1330: 字符识别？ Time Limit: 1 Sec Memory Limit: 128 Mb Submitted: 885 Solved: 595 Description你的任务是写一个程序进行字符识别。别担心，你只需要识别1, 2, 3，如下： .*. *** *** .*. ..* ..* .*. *** *** .*. *.. ..* .*. *** *** Input输入仅包含一组数据，由$6$行组成。第一行为字符的个数 $n ( 1 \le n \le 10)$。以下$5$行每行包含$4n$个字符。每个字符恰好占$5$行$3$列，然后是一个空列（用”.”填充）。 Output输出应包含一行，即识别出的各个字符。 Sample Input3 .*..***.***. .*....*...*. .*..***.***. .*..*.....*. .*..***.***. Sample Output123 HintSource湖南省第九届大学生计算机程序设计竞赛 题目大意将一个五行宽的字符串替换成所代表的1，2，3。 解题思路水题，字符串判断一下特征字符区间即可。 解题代码1234567891011121314151617181920212223242526272829303132333435363738394041424344#include &lt;cstdio&gt;#include &lt;cstring&gt;#include &lt;cmath&gt;#include &lt;set&gt;#include &lt;queue&gt;#include &lt;map&gt;#include &lt;set&gt;#include &lt;string&gt;#include &lt;iostream&gt;#include &lt;iomanip&gt;#include &lt;stack&gt;#define rep(i,a,n) for(int i=a ; i&lt;n;++i)#define per(i,a,n) for(int i=n-1;i&gt;=a;--i)#define fi first#define se second#define cl(x,a) memset(x,a,sizeof(x)) #define all(x) x.begin(),x.end()#define insert(x) x,x.begin()#define debug printf("======================\n");#define mp make_pair#define np next_permutation#define pb push_back#define INF 0x3f3f3f3f#define eps 1e-8using namespace std;const int maxn=1e5+5;const int maxm=1e5+5;const int maxl=2;const int K=32;string word[5]; int main()&#123; ios::sync_with_stdio(false); int n; while(cin&gt;&gt;n)&#123; rep(i,0,5) cin&gt;&gt;word[i]; rep(i,0,n)&#123; int ii=i*4; if(word[2][ii]=='.' &amp;&amp; word[2][ii+1]=='*' &amp;&amp; word[2][ii+2]=='.') cout&lt;&lt;1; else if(word[3][ii]=='*' &amp;&amp; word[3][ii+1]=='.' &amp;&amp; word[3][ii+2]=='.') cout&lt;&lt;2; else if(word[3][ii]=='.' &amp;&amp; word[3][ii+1]=='.' &amp;&amp; word[3][ii+2]=='*') cout&lt;&lt;3; &#125; cout&lt;&lt;endl; &#125;&#125; 收获与反思无]]></content>
      <categories>
        <category>编程</category>
        <category>ACM</category>
      </categories>
      <tags>
        <tag>算法</tag>
        <tag>ACM</tag>
        <tag>CSU</tag>
        <tag>2018暑假集训</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[【CSU-1340】结题报告（水题）]]></title>
    <url>%2Fpost%2F6ca1eed5.html</url>
    <content type="text"><![CDATA[原始题目1340: A Sample Problem Time Limit: 1 Sec Memory Limit: 128 Mb Submitted: 706 Solved: 322 DescriptionMy girlfriend loves 7 very much, she thinks it is lucky! If an integer contains one or more 7, she will think it is lucky too! InputThe first line has one integer $T (1 \le T \le 100)$, means there are T test cases. For each test case, there is only one line with an integer $X (1 \le X \le 10^{9} )$. OutputFor each test case, if X contains one or more 7, output “Lucky” (without quotation marks), otherwise output “Unlucky” (without quotation marks). Sample Input4 7 11 568 17171 Sample OutputLucky Unlucky Unlucky Lucky Hint我们主要通过这个题目来感受一下一个完整的ACM竞赛的题目应当是什么样的。 ACM竞赛题目本身的“格式” 很明显： 第一部分是对题目的描述，会交待题目的背景，以及你需要编程完成哪些任务等等。 第二部分是对输入的约定，会告诉你题目是否有多组测试数据，每组测试数据的格式，每个参数的类型（整数，浮点数，字符串等）以及取值范围等等。 第三部分是对输出的约定，也就是你的程序应当输出哪些内容以及具体的格式是什么。 第四部分是一些样例，这些例子只是向你展示一部分测试数据以及对应的答案，目的是更好地帮助你理解题意，以及了解对输出格式的要求等。 大家也许会和我当初刚接触ACM时一样心中充满了疑问，在这里我就为大家列举几个常见的问题： 如果题目有多组数据，我们是不是也要像样例那样把所有的结果先都计算出来，然后再一起输出？ 这个是没必要的，你完全可以每处理完一组数据之后就立刻将这组数据对应的结果输出出来。 但如果你是手动去敲这些样例的话，你会发现在屏幕上输入和输出是混在一起的，并不像样例那样输入和输出是分离的，这样会不会不符合要求呢？那么请看，相信你的疑问就会被解答了。 OJ (Online Judge)怎么知道我的程序是不是写对了？ OJ并不会去智能化地分析你的代码正确与否，而是用另一种巧妙的思路来判断你的程序是否符合要求：“喂”给你的程序一些输入数据（就像你在键盘上敲一些东西后敲回车一样），之后再将你的程序“产出”的东西（就像你在屏幕上看到的你的程序输出的东西一样）和标准的答案进行对比，如果你的程序得到的答案和标准的答案一模一样，那么就算你通过了这个题目。 因此，即使你手动输入样例时屏幕上的输入和输出是混在一起也没关系，只要你的程序“产出”的东西和标准答案一模一样就可以了。 也正是这种评判机制的关系，你不应当让程序打印一些提示语句，如“Please input two integers”等等，因为凡是你的程序输出的内容都会被拿来和标准答案进行对比，一旦输出了类似这样的题目没有要求输出的语句，就会和标准答案大相径庭了，自然就会认为你的程序是不正确的了。 值得一提的是，尽管这样的评判机制似乎并不能完美地知道你的程序究竟是不是对的（想想看为什么？），不过如果测试数据足够强大的话，“你的程序是对的”的概率就会很高很高了。 为什么我的程序通过了所有的样例，但是最后还是过不了这个题目？ 题目的样例只是一小部分测试数据，目的是为了更好地帮助你理解题意，以及了解对输出格式的要求等，因此通过了样例并不能够代表能通过所有的测试数据。只有通过了所有的测试数据才能得到“Accept”，也就是通过了这个题目。 每组测试数据的答案输出完之后，是否都要换行？ 是的，即使题目里面没有明确说明，我们也应该在每组测试数据的答案输出完之后再输出一个“换行”（也就是“\n”），就像样例示意的那样。 接下来我们谈谈这个题目的思路吧，相信大家应该都想到算法了：只要依次判断读入的整数的每一位是否是7就可以了。如果觉得代码写起来会有困难的话，可以参考一下我在下面给出的示例代码，不过最后一定要按自己的思路写一个完整的代码（编写自己的代码时就不要再参考示例代码了，要一气呵成~）并获得“Accept”哟！O(∩_∩)O~ SourceACM入门示例（第一季） 题目大意如题 解题思路水题 解题代码12345678910111213141516171819202122232425262728293031#include &lt;cstdio&gt;#include &lt;cstring&gt;#include &lt;iostream&gt;#include &lt;set&gt;#include &lt;queue&gt;#include &lt;algorithm&gt;#define INF 0x3f3f3f3f#define rep(i,a,n) for(int i=a;i&lt;n;++i)#define per(i,a,n) for(int i=n-1;i&gt;=a;--i)using namespace std;const int maxn=1e5+5;typedef long long ll;ll t,n,m;int main()&#123; scanf("%lld",&amp;t); while(t--)&#123; scanf("%lld",&amp;n); int flag=0; while(n)&#123; if(n%10==7)&#123;// printf("now=%d\n",n); flag=1; break; &#125; n/=10; &#125; if(flag) printf("Lucky\n"); else printf("Unlucky\n"); &#125;&#125; 收获与反思无]]></content>
      <categories>
        <category>编程</category>
        <category>ACM</category>
      </categories>
      <tags>
        <tag>算法</tag>
        <tag>ACM</tag>
        <tag>CSU</tag>
        <tag>2018暑假集训</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[【CSU-2158】解题报告（水题）]]></title>
    <url>%2Fpost%2Faa0a97c8.html</url>
    <content type="text"><![CDATA[原始题目2158: 长门的运动会 Time Limit: 1 Sec Memory Limit: 128 Mb Submitted: 2 Solved: 2 SpecialJudge Description运动会，好开心~ CSU (California State University) 正在举行一场特殊的接力跑比赛，比赛在环形跑道上进行，同一支队伍的所有人从同一个位置向相同的方向出发，当需要接力的两个人再次相遇时，他们就要交接棒。最后总成绩是以队伍跑的总路程计算的 现在接力的第一棒在Nagato手中，需要把它交给Kyon。在长度为C的环形跑道上，他们出发了！Nagato以速度A匀速跑动，Kyon以速度B匀速跑动。他们在经过多长时间后可以再次相遇？ Input多组数据，第一行为一个整数T (1 ≤ T ≤ 106)，表示数据组数。 之后每行是一组数据，有三个整数C, A, B (1 ≤ C, A, B ≤ 109, A ≠ B)，分别表示环形跑道的长度，Nagato的速度和Kyon的速度。 Output每行输出一个数，表示再次相遇所需的时间。绝对误差或相对误差小于10−5则认为是正确的。 Sample Input2 3 1 2 5 10 7 Sample Output3.00000000 1.66666667 HintSourceAuthorYuki Nagato 题目大意如题 解题思路水题，追击运动一圈 解题代码1234567891011121314151617181920212223242526272829303132333435363738394041#include &lt;cstdio&gt;#include &lt;cstring&gt;#include &lt;iostream&gt;#include &lt;iomanip&gt;#include &lt;cmath&gt;#include &lt;sstream&gt;#include &lt;set&gt;#include &lt;vector&gt;#include &lt;stack&gt;#include &lt;queue&gt;#include &lt;map&gt;#include &lt;algorithm&gt;#define rep(i,a,n) for(int i=a;i&lt;n;++i) #define per(i,a,n) for(int i=n-1;i&gt;=a;--i)#define ms(x,a) memset((x),a,sizeof(x))#define pb push_back#define np next_permutation#define mp make_pair#define INF 0x3f3f3f3f#define eps 1e-8#define all(x) x.begin(),x.end()#define ins(x) inserter(x,x.begin())#define mod 1000000005#define K 20using namespace std;const int maxn=1e2+5;const int maxl=26;const int maxm=1e5+5;typedef long long ll;ll t,n,a;int c[K];int main()&#123; scanf("%lld",&amp;t); while(t--)&#123; int a,b,c; scanf("%d%d%d",&amp;a,&amp;b,&amp;c); if(b&lt;c) swap(b,c); double ans=double(a)/(b-c); printf("%f\n",ans); &#125;&#125; 收获与反思水题]]></content>
      <categories>
        <category>编程</category>
        <category>ACM</category>
      </categories>
      <tags>
        <tag>算法</tag>
        <tag>ACM</tag>
        <tag>CSU</tag>
        <tag>2018暑假集训</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[【UVA-12100】解题报告（STL，queue）]]></title>
    <url>%2Fpost%2Fc1864474.html</url>
    <content type="text"><![CDATA[原始题目 题目大意学生会里的打印机打印量巨大。现在给打印任务分配一个1到9的优先级，优先级越高表示任务越着急。 打印机的工作方式如下：首先从打印队列里取出一个任务J，如果队列里有比J更急的任务，则直接把J放到打印队列尾部，否则打印任务J（此时不会把它放到打印队列） 输入打印队列中各个任务的优先级，给定你的任务的序号，假定只有打印每个任务的时候耗时1分钟，问完成你的任务时总耗时是多少。 解题思路 利用set模拟，维护一下当前最大优先级和各优先级的任务数即可。 解题代码1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859#include &lt;cstdio&gt;#include &lt;cstring&gt;#include &lt;cmath&gt;#include &lt;iostream&gt;#include &lt;iomanip&gt;#include &lt;set&gt;#include &lt;queue&gt;#include &lt;map&gt;#include &lt;algorithm&gt;#include &lt;vector&gt;#define rep(i,a,n) for(int i=a;i&lt;n;++i)#define per(i,a,n) for(int i=n-1;i&gt;=a;--i)#define cl(x,a) memset(x,a,sizeof(x))#define all(x) x.begin(),x.end()#define pb push_back#define np next_permutation#define mp make_pair#define fi first#define se second#define INF 0x3f3f3f3f#define eps 1e-8using namespace std;const int maxn=1e5+5;const int maxl=26;const int maxm=1e5+5;typedef long long ll;typedef vector&lt;int&gt; vi;typedef pair&lt;int,int&gt; pii;int num[100];int main()&#123; ios::sync_with_stdio(false); int t,n,m,l,mmax=0; cin&gt;&gt;t; while(t--)&#123; cin&gt;&gt;n&gt;&gt;m;//自己得任务是m号 queue&lt;pii&gt; q; cl(num,0); rep(i,0,n)&#123; cin&gt;&gt;l; mmax=max(mmax,l); q.push(mp(i,l)); num[l]++; &#125; int ans=0; while(!q.empty())&#123; pii temp=q.front();q.pop(); if(temp.second&lt;mmax)&#123; q.push(temp); &#125; else&#123; ans++; if(!(--num[mmax])) while(!(num[mmax]) &amp;&amp; mmax)&#123;mmax--;&#125; if(temp.first==m) &#123;cout&lt;&lt;ans&lt;&lt;endl;break;&#125; &#125; &#125; &#125; &#125; 收获与反思 加快码速，秒之s]]></content>
      <categories>
        <category>编程</category>
        <category>ACM</category>
      </categories>
      <tags>
        <tag>算法</tag>
        <tag>ACM</tag>
        <tag>2018暑假集训</tag>
        <tag>STL</tag>
        <tag>UVA</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[【UVA-1595】解题报告（STL,Vector）]]></title>
    <url>%2Fpost%2Fa7528411.html</url>
    <content type="text"><![CDATA[原始题目 题目大意给出平面上N个点，问是否可以找到一条竖线，使得所有点左右对称。 解题思路纵坐标离散化后求每行得平均数，判断一下 解题代码1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465666768697071727374757677787980#include &lt;cstdio&gt;#include &lt;cstring&gt;#include &lt;cmath&gt;#include &lt;iostream&gt;#include &lt;iomanip&gt;#include &lt;set&gt;#include &lt;queue&gt;#include &lt;map&gt;#include &lt;algorithm&gt;#include &lt;vector&gt;#define rep(i,a,n) for(int i=a;i&lt;n;++i)#define per(i,a,n) for(int i=n-1;i&gt;=a;--i)#define cl(x,a) memset(x,a,sizeof(x))#define all(x) x.begin(),x.end()#define pb push_back#define np next_permutation#define mp make_pair#define fi first#define se second#define INF 0x3f3f3f3f#define eps 1e-8using namespace std;const int maxn=1e5+5;const int maxl=26;typedef long long ll;typedef vector&lt;int&gt; vi;typedef pair&lt;int,int&gt; pii;vector&lt;pii&gt; v0;vi v[1005];double ans[1005];bool cmp(pii a,pii b)&#123; if(a.first!=b.first) return a.first&lt;b.first; else return a.second&lt;b.second;&#125;int t,n,a,b;int main()&#123; ios::sync_with_stdio(false); cin&gt;&gt;t; while(t--)&#123; rep(i,0,1005) v[i].clear(); v0.clear(); cin&gt;&gt;n; rep(i,0,n) &#123;cin&gt;&gt;b&gt;&gt;a; v0.pb(mp(a,b));&#125; sort(all(v0),cmp);// rep(i,0,n) // &#123;// cout&lt;&lt;v0[i].fi&lt;&lt;" "&lt;&lt;v0[i].se&lt;&lt;endl;// &#125; int temp=INF,cnt=-1,sum=0; rep(i,0,n)&#123; if(temp!=v0[i].first)&#123; if(cnt!=-1)&#123; ans[cnt]=(double)sum/v[cnt].size();// cout&lt;&lt;"ave["&lt;&lt;cnt&lt;&lt;"]="&lt;&lt;ans[cnt]&lt;&lt;endl; &#125; temp=v0[i].first; cnt++; v[cnt].pb(v0[i].second); sum=v0[i].second; &#125; else &#123;v[cnt].pb(v0[i].second);sum+=v0[i].second;&#125; &#125; ans[cnt]=(double)sum/v[cnt].size(); cnt++; int flag=1; rep(i,1,cnt)&#123;// cout&lt;&lt;"ave["&lt;&lt;i&lt;&lt;"]="&lt;&lt;ans[i]&lt;&lt;endl; if(abs(ans[i]-ans[i-1])&gt;eps)&#123; flag=0; cout&lt;&lt;"NO"&lt;&lt;endl; break; &#125; &#125; if(flag) cout&lt;&lt;"YES"&lt;&lt;endl; &#125;&#125; 收获与反思 加快码速，秒之]]></content>
      <categories>
        <category>编程</category>
        <category>ACM</category>
      </categories>
      <tags>
        <tag>算法</tag>
        <tag>ACM</tag>
        <tag>2018暑假集训</tag>
        <tag>STL</tag>
        <tag>UVA</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[【UVA-10391】解题报告（STL）]]></title>
    <url>%2Fpost%2F4d6a6b27.html</url>
    <content type="text"><![CDATA[原始题目 题目大意给出一个字典，找出所有的复合单词，即恰好有两个单词连接而成的单词。输入已按照字典序从小到大排序，且不超过120000个单词，输出所有复合词，按照字典序从小到大排序。 解题思路substring秒过 解题代码1234567891011121314151617181920212223242526272829303132333435363738#include &lt;cstdio&gt;#include &lt;cstring&gt;#include &lt;string&gt;#include &lt;iostream&gt;#include &lt;set&gt;#include &lt;queue&gt;#include &lt;algorithm&gt;#include &lt;map&gt;#include &lt;vector&gt;#include &lt;iomanip&gt;#include &lt;cmath&gt;using namespace std;const int maxn=2e5+5;set &lt;string&gt; s;vector &lt;string&gt; all;string a;int n; int main()&#123; while(cin&gt;&gt;a)&#123; s.insert(a); &#125; set &lt;string&gt; ::iterator it; for(it=s.begin();it!=s.end();it++)&#123; int len=(*it).size(); for(int i=1;i&lt;len;i++)&#123; //遍历每个单词从头到尾 string pre=(*it).substr(0,i); string sub=(*it).substr(i,len-i); if(s.count(pre) &amp;&amp; s.count(sub))&#123; cout&lt;&lt;*it&lt;&lt;endl; break; &#125; &#125; &#125; &#125; 收获与反思 熟悉函数 string::substr() 第一个参数为起始位置，第二个参数为长度。]]></content>
      <categories>
        <category>编程</category>
        <category>ACM</category>
      </categories>
      <tags>
        <tag>算法</tag>
        <tag>ACM</tag>
        <tag>2018暑假集训</tag>
        <tag>STL</tag>
        <tag>UVA</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[【UVA-10763】解题报告（STL）]]></title>
    <url>%2Fpost%2F31a770a5.html</url>
    <content type="text"><![CDATA[原始题目 题目大意有n个学生想交换到其他学校学习。为了简单起见，规定每个象从A学校换到B学校的学生必须找一个想从B学校换到A的“搭档”。如果每个人都能找到搭档（一个人不能找多个搭档），学校就会同意他们交换。每个学生用两个整数A、B表示，你的任务是判断交换是否可以进行。 解题思路 利用multimap（多重映射）对于一组键、值对，查找有没有对应值为键，键为值得的映射，有则删除，没有的话把当前的键、值对加入multimap。最后检查是否为空 网上还有一种虽然简单优雅但是有漏洞的解法，初始赋值$ans[i]=i$输入一组$a,b$，$swap(ans[a],ans[b])$，最后检查是否复合原状态（一一匹配的话两次反转复原），不过这个解法没有考虑到三方交换的情况（即$swap(a,b),swap(b,c),swap(c,a)$）其实这是不满足题意的，但也会判YES。所以说有漏洞。 解题代码 multimap 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354#include &lt;cstdio&gt;#include &lt;cstring&gt;#include &lt;iostream&gt;#include &lt;iomanip&gt;#include &lt;cmath&gt; #include &lt;set&gt;#include &lt;vector&gt;#include &lt;string&gt;#include &lt;algorithm&gt;#include &lt;map&gt;#include &lt;sstream&gt;#include &lt;bits/stdc++.h&gt;#define rep(i,a,n) for(int i=a;i&lt;n;++i)#define per(i,a,n) for(int i=n-a;i&gt;=a;--i)#define cl(x,a) memset(x,a,sizeof(x))#define all(x) x.begin(),x.end()#define pb push_back#define np next_permutation#define mp make_pair#define INF 0x3f3f3f3f#define eps 1e-8#define K 1001#define fi first#define se secondusing namespace std;const int maxn=1e5+5;typedef vector&lt;int&gt; vi;typedef multimap &lt;int,int&gt;::const_iterator cit;int main()&#123; ios::sync_with_stdio(false); int n,a,b; while(cin&gt;&gt;n &amp;&amp; n)&#123; multimap &lt;int,int&gt; mmp; rep(i,0,n)&#123; cin&gt;&gt;a&gt;&gt;b; typedef pair&lt;cit,cit&gt; Range; Range range=mmp.equal_range(b); int flag=0; cit j=range.first; for(;j!=range.second;++j)&#123; if(j-&gt;second==a)&#123; flag=1; break; &#125; &#125; if(flag) mmp.erase(j); else mmp.insert(mp(a,b)); &#125; if(mmp.size()==0) cout&lt;&lt;"YES"&lt;&lt;endl; else cout&lt;&lt;"NO"&lt;&lt;endl; &#125;&#125; 朴素法（有漏洞） 123456789101112131415161718192021222324252627282930313233343536373839#include &lt;cstdio&gt;#include &lt;cstring&gt;#include &lt;iostream&gt;#include &lt;iomanip&gt;#include &lt;cmath&gt; #include &lt;set&gt;#include &lt;vector&gt;#include &lt;string&gt;#include &lt;algorithm&gt;#include &lt;map&gt;#include &lt;sstream&gt;#include &lt;bits/stdc++.h&gt;#define rep(i,a,n) for(int i=a;i&lt;n;++i)#define per(i,a,n) for(int i=n-a;i&gt;=a;--i)#define cl(x,a) memset(x,a,sizeof(x))#define all(x) x.begin(),x.end()#define pb push_back#define np next_permutation#define mp make_pair#define INF 0x3f3f3f3f#define eps 1e-8#define K 1001#define fi first#define se secondusing namespace std;const int maxn=5e5+5;int ans[maxn];int main()&#123; ios::sync_with_stdio(false); int n; while(cin&gt;&gt;n &amp;&amp; n)&#123; int flag=0; rep(i,1,n+1) ans[i]=i; rep(i,1,n+1) &#123;int a,b; cin&gt;&gt;a&gt;&gt;b; swap(ans[a],ans[b]);&#125; rep(i,1,n+1) &#123;if(ans[i]!=i) &#123;flag=1;break;&#125;&#125; if(flag) cout&lt;&lt;"NO"&lt;&lt;endl; else cout&lt;&lt;"YES"&lt;&lt;endl; &#125;&#125; 收获与反思 交换复原思想值得学习]]></content>
      <categories>
        <category>编程</category>
        <category>ACM</category>
      </categories>
      <tags>
        <tag>算法</tag>
        <tag>ACM</tag>
        <tag>2018暑假集训</tag>
        <tag>STL</tag>
        <tag>UVA</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[【UVA-10935】解题报告（STL，模拟）]]></title>
    <url>%2Fpost%2F26fa4dfc.html</url>
    <content type="text"><![CDATA[原始题目 题目大意桌上有n(n≤50) 张牌，从顶面开始，从上往下编号1到n。当至少剩下两张牌时进行以下操作： 把第一张牌扔掉，然后把新的第一张牌放到整叠牌的最后。 输入每行一个n，输出每次扔掉的牌以及最后剩下的牌。 解题思路 利用queue模拟操作，注意只有1张牌的时候特判。 解题代码1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950#include &lt;cstdio&gt;#include &lt;cstring&gt;#include &lt;iostream&gt;#include &lt;iomanip&gt;#include &lt;cmath&gt; #include &lt;set&gt;#include &lt;vector&gt;#include &lt;string&gt;#include &lt;algorithm&gt;#include &lt;map&gt;#include &lt;sstream&gt;#include &lt;bits/stdc++.h&gt;#define rep(i,a,n) for(int i=a;i&lt;n;++i)#define per(i,a,n) for(int i=n-a;i&gt;=a;--i)#define cl(x,a) memset(x,a,sizeof(x))#define all(x) x.begin(),x.end()#define pb push_back#define np next_permutation#define mp make_pair#define INF 0x3f3f3f3f#define eps 1e-8#define K 1001#define fi first#define se secondusing namespace std;const int maxn=1e5+5;int n;int main()&#123; ios::sync_with_stdio(false); while(cin&gt;&gt;n &amp;&amp;n)&#123; if(n==1)&#123; //1的时候特判 cout&lt;&lt;"Discarded cards:"&lt;&lt;endl; cout&lt;&lt;"Remaining card: 1"&lt;&lt;endl; continue; &#125; cout&lt;&lt;"Discarded cards: "; queue &lt;int&gt; q; rep(i,1,n+1) q.push(i); while(q.size()&gt;2)&#123; int top=q.front(); q.pop(); cout&lt;&lt;top&lt;&lt;", "; top=q.front();q.pop(); q.push(top); &#125; int top=q.front();q.pop(); cout&lt;&lt;top&lt;&lt;endl&lt;&lt;"Remaining card: "&lt;&lt;q.front()&lt;&lt;endl; &#125;&#125;]]></content>
      <categories>
        <category>编程</category>
        <category>ACM</category>
      </categories>
      <tags>
        <tag>算法</tag>
        <tag>ACM</tag>
        <tag>Imitation</tag>
        <tag>STL</tag>
        <tag>UVA</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[【UVA-11401】解题报告（数学，求和公式）]]></title>
    <url>%2Fpost%2F23f72a93.html</url>
    <content type="text"><![CDATA[原始题目 题目大意有长度分别为$1,2,3,4 \cdots n$ 的木杆各一根，问共可以组成多少个三角形。 解题思路 设$f[x]$ 表示以$x$为最长边的三角形的个数。 设另两条边为$y,z$，易知$y+z&gt;x$，所以$x-z]]></content>
      <categories>
        <category>编程</category>
        <category>ACM</category>
      </categories>
      <tags>
        <tag>算法</tag>
        <tag>ACM</tag>
        <tag>2018暑假集训</tag>
        <tag>补图</tag>
        <tag>UVA</tag>
        <tag>数学</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[【UVA-11538】解题报告（数学，组合数）]]></title>
    <url>%2Fpost%2F89873dd3.html</url>
    <content type="text"><![CDATA[原始题目 题目大意在$n \times m$的棋盘上放置$2$个皇后（一黑一白），问相互攻击的情况共有多少种。 解题思路 根据加法原理，总情况由下面三种子情况构成（覆盖全部切不重复）（n&lt;m) 两个皇后在同一行，情况数为$nm(m-1)$ 两个皇后在同一列，情况数为$mn(n-1)$ 两个皇后在同一斜行，情况数为$2 \times (2 \sum_{i=1}^{n-1}{i(i-1)} + (m+1-n)n(n-1)) = 2 \times( (2 \frac {n(n-1)(2n-4)}{6} )+(m-n+1)n(n-1))$ 相加即可 解题代码123456789101112131415161718192021222324252627282930313233343536373839#include &lt;cstdio&gt;#include &lt;cstring&gt;#include &lt;cmath&gt;#include &lt;iostream&gt;#include &lt;iomanip&gt;#include &lt;set&gt;#include &lt;queue&gt;#include &lt;map&gt;#include &lt;stack&gt;#include &lt;algorithm&gt;#include &lt;vector&gt;#include &lt;string&gt;#include &lt;sstream&gt;#define rep(i,a,n) for(int i=a;i&lt;n;++i)#define per(i,a,n) for(int i=n-a;i&gt;=a;--i)#define se second#define fi first#define eps 1e-8#define INF 0x3f3f3f3fusing namespace std;const int maxn=1e5+5;const int maxl=26;const int maxm=1e5+5;typedef long long ll;typedef unsigned long long ull;typedef vector&lt;int&gt; vi;typedef pair&lt;int,int&gt; pii;ll n,m;int main()&#123; ios::sync_with_stdio(false); while(cin&gt;&gt;n&gt;&gt;m&amp;&amp;n+m)&#123; if(n&gt;m) swap(n,m); ll ans=(n*m*(m-1) ); ans+=(m*n*(n-1)); ans+=(2*(n*(n-1)*(2*n-4)/6)+(m-n+1)*n*(n-1))*2; cout&lt;&lt;ans&lt;&lt;endl; &#125;&#125; 收获与反思 熟悉排列组合的加法原理与乘法原理 两个求和公式以及简单叠加 \sum {i=1}^n i = \frac {n(n+1)}{2}\sum {i=1}^n {i^2} = \frac {n(n+1)(2n+1)}{6}推导出 \sum {i=1}^n {i(i-1)} = \frac {n(n+1)(n-1)}{3}]]></content>
      <categories>
        <category>编程</category>
        <category>ACM</category>
      </categories>
      <tags>
        <tag>算法</tag>
        <tag>ACM</tag>
        <tag>2018暑假集训</tag>
        <tag>补图</tag>
        <tag>UVA</tag>
        <tag>数学</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[【HDU-1808】解题报告（数论，鸽巢定理）]]></title>
    <url>%2Fpost%2Fe583ed8d.html</url>
    <content type="text"><![CDATA[原始题目Halloween treats Time Limit: 1000/1000 MS (Java/Others) Memory Limit: 32768/32768 K (Java/Others) Total Submission(s): 1366 Accepted Submission(s): 560 Special Judge Problem DescriptionEvery year there is the same problem at Halloween: Each neighbour is only willing to give a certain total number of sweets on that day, no matter how many children call on him, so it may happen that a child will get nothing if it is too late. To avoid conflicts, the children have decided they will put all sweets together and then divide them evenly among themselves. From last year’s experience of Halloween they know how many sweets they get from each neighbour. Since they care more about justice than about the number of sweets they get, they want to select a subset of the neighbours to visit, so that in sharing every child receives the same number of sweets. They will not be satisfied if they have any sweets left which cannot be divided. Your job is to help the children and present a solution. InputThe input contains several test cases. The first line of each test case contains two integers c and n (1 ≤ c ≤ n ≤ 100000), the number of children and the number of neighbours, respectively. The next line contains n space separated integers a1 , … , an (1 ≤ ai ≤ 100000 ), where ai represents the number of sweets the children get if they visit neighbour i. The last test case is followed by two zeros. OutputFor each test case output one line with the indices of the neighbours the children should select (here, index i corresponds to neighbour i who gives a total number of ai sweets). If there is no solution where each child gets at least one sweet, print “no sweets” instead. Note that if there are several solutions where each child gets at least one sweet, you may print any of them. Sample Input4 5 1 2 3 7 5 3 6 7 11 2 5 13 17 0 0 Sample Output3 5 2 3 4 SourceHDOJ 2007 Summer Exercise（1） Recommendlinle 题目大意题目大意，万圣节孩子们去要糖果。给定孩子数$c$，和邻居数$n$，且$n&gt;c$。每个邻居家里有糖果$a_i$，孩子们希望能找到一些家庭他们的糖果数恰好时能被$c$整除，问是否存在，不存在输出“no sweets”，存在的话输出邻居的编号。 解题思路由于$n&gt;c$，求前缀和数组sum，对于严格单调增的n个前缀和，由于鸽巢原理，必然存在至少两个模c同余。 解题代码]]></content>
      <categories>
        <category>编程</category>
        <category>ACM</category>
      </categories>
      <tags>
        <tag>算法</tag>
        <tag>ACM</tag>
        <tag>2018暑假集训</tag>
        <tag>数论</tag>
        <tag>HDU</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[【UVA-12096】解题报告（STL，stack，模拟）]]></title>
    <url>%2Fpost%2Fa1cef007.html</url>
    <content type="text"><![CDATA[原始题目 题目大意有一个储存集合的栈，有五种操作。 压入空集合 将栈顶集合复制再加入栈 出栈栈顶两个集合，取交集后入栈 出栈栈顶两个集合，取并集后入栈 出栈栈顶两个集合，将最顶端的集合加入到次顶的集合中 给出操作，最后输出栈顶集合的元素个数。 解题思路利用set的数据结构+模拟 集合储存内部集合的编号，空集合就没有编号。 利用map把集合映射成ID，对于每个ADD操作后的新集合查找映射，没有就赋值。 模拟操作最后输出栈顶的size即可。 解题代码12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364656667686970717273747576777879808182#include &lt;cstdio&gt;#include &lt;cstring&gt;#include &lt;cmath&gt;#include &lt;iostream&gt;#include &lt;iomanip&gt;#include &lt;set&gt;#include &lt;queue&gt;#include &lt;stack&gt;#include &lt;vector&gt;#include &lt;map&gt;#include &lt;string&gt;#include &lt;sstream&gt;#include &lt;bits/stdc++.h&gt;#define rep(i,a,n) for(int i=a;i&lt;n;++i)#define per(i,a,n) for(int i=n-1;i&gt;=a;--i);#define ms(x,a) memset((x),a,sizeof((x))) #define all(x) x.begin(),x.end()#define ins(x) inserter(x,x.begin()) #define INF 0x3f3f3f3f#define eps 1e-8#define fi first#define e 2.718281828459045235360287471352662497757247093699959574966967627724076630353 #define se second#define mp make_pair#define pb push_back#define np next_permutation#define gapline cout&lt;&lt;"##======================##"&lt;&lt;endlusing namespace std;const int maxn=1e5+5;const int maxl=26;const int maxm=1e5+5;typedef long long ll;typedef unsigned long long ull;typedef set&lt;int&gt; si;map &lt;si,int&gt; IDcache; //把集合映射成IDvector &lt;si&gt; sicache; int t,n;// 查找给定集合x的ID。如果找不到，分配一个新的IDint ID(si x)&#123; if(IDcache.count(x)) return IDcache[x]; sicache.pb(x); //添加新的集合// cout&lt;&lt;"new="&lt;&lt;sicache.size()-1&lt;&lt;endl; return IDcache[x]=sicache.size()-1; //返回新的id // id 都是从 0 开始的 &#125; stack &lt;int&gt; s;//建立栈s， 里面储存不同集合的idint main()&#123; ios::sync_with_stdio(false); cin&gt;&gt;t; while(t--)&#123; while(!s.empty()) s.pop(); sicache.clear(); IDcache.clear(); cin&gt;&gt;n; string op; rep(i,0,n)&#123; cin&gt;&gt;op; if(op[0]=='P') s.push(ID(si())); //调用默认构造函数构造空集合，作为参数传给ID，判断有没有该集合，然后返回id else if(op[0]=='D') s.push(s.top()); //复制一个添加到栈顶 else&#123; si x1=sicache[s.top()];s.pop(); si x2=sicache[s.top()];s.pop(); si x;// cout&lt;&lt;"x1="&lt;&lt;ID(x1)&lt;&lt;" x2="&lt;&lt;ID(x2)&lt;&lt;endl; if(op[0]=='U') set_union(all(x1),all(x2),ins(x)); if(op[0]=='I') set_intersection(all(x1),all(x2),ins(x)); if(op[0]=='A') &#123; x=x2; x.insert(ID(x1)); &#125; s.push(ID(x)); &#125; cout&lt;&lt;sicache[s.top()].size()&lt;&lt;endl; &#125; cout&lt;&lt;"***"&lt;&lt;endl; &#125; &#125; 收获与反思 紫书说思想很重要]]></content>
      <categories>
        <category>编程</category>
        <category>ACM</category>
      </categories>
      <tags>
        <tag>算法</tag>
        <tag>ACM</tag>
        <tag>Imitation</tag>
        <tag>2018暑假集训</tag>
        <tag>补图</tag>
        <tag>STL</tag>
        <tag>UVA</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[【UVA-540】解题报告（STL，queue，模拟）]]></title>
    <url>%2Fpost%2F686dc27c.html</url>
    <content type="text"><![CDATA[原始题目 题目大意团队队列，给定n个团队每个团队的人员，对于一个整体队列，有入队出队两种操作。 入队：如果长队列中有将要入队成员的同团队成员，则该成员插入到同团队成员的最后方，如果没有，则插入整个队伍最后方。 出队：整体队列的队首人员出列。 解题思路 先map到自己的团队号。 建立不同团队的人员队列和团队队列（储存团队号），入队操作时检查本团队的人员队列是否为空，如果为空。那么就在团队队列插入该成员的团队号，然后本队队列入队该成员。不为空的话只在本队队列入队即可。出队操作检查出队成员所在本队队列是否为空，为空就在团队队列中也出队队伍号。 解题代码1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465666768697071727374#include &lt;cstdio&gt;#include &lt;cstring&gt;#include &lt;cmath&gt;#include &lt;iostream&gt;#include &lt;iomanip&gt;#include &lt;set&gt;#include &lt;queue&gt;#include &lt;stack&gt;#include &lt;vector&gt;#include &lt;map&gt;#include &lt;string&gt;#include &lt;sstream&gt;#include &lt;bits/stdc++.h&gt;#define rep(i,a,n) for(int i=a;i&lt;n;++i)#define per(i,a,n) for(int i=n-1;i&gt;=a;--i);#define ms(x,a) memset((x),a,sizeof((x))) #define all(x) x.begin(),x.end()#define ins(x) inserter(x,x.begin()) #define INF 0x3f3f3f3f#define eps 1e-8#define fi first#define e 2.718281828459045235360287471352662497757247093699959574966967627724076630353 #define se second#define mp make_pair#define pb push_back#define np next_permutation#define gapline cout&lt;&lt;"##======================##"&lt;&lt;endlusing namespace std;const int maxn=1e3+5;const int maxl=26;const int maxm=1e5+5;typedef long long ll;typedef unsigned long long ull;//团体队列 一个q储存团体序号， q2[i]表示i团体内的队列 // 出队时 q2[q[front]] 为空时 q.pop();// 入队时 q2[mp[number]]非空时直接插队尾， 空时 插队尾同时q.push(mp[number]) int t,n,kase;map&lt;int,int&gt; mmp;int main()&#123; ios::sync_with_stdio(false); while(cin&gt;&gt;t&amp;&amp;t)&#123; cout&lt;&lt;"Scenario #"&lt;&lt;++kase&lt;&lt;endl; mmp.clear(); int x; rep(i,0,t)&#123; cin&gt;&gt;n; rep(j,0,n)&#123; cin&gt;&gt;x; mmp[x]=i; &#125; &#125; queue&lt;int&gt; q,q2[maxn]; //q为团队队列 q2[i] 为i团队队内队列 string c; while(cin&gt;&gt;c &amp;&amp; c[0]!='S')&#123; if(c[0]=='E')&#123; cin&gt;&gt;x; int id=mmp[x]; if(q2[id].empty())&#123; q.push(id); &#125; q2[id].push(x); &#125; else&#123; int num=q2[q.front()].front(); cout&lt;&lt;num&lt;&lt;endl; q2[q.front()].pop(); if(q2[q.front()].empty()) q.pop(); &#125; &#125; cout&lt;&lt;endl; &#125;&#125; 收获与反思合理利用已有的数据结构]]></content>
      <categories>
        <category>编程</category>
        <category>ACM</category>
      </categories>
      <tags>
        <tag>算法</tag>
        <tag>ACM</tag>
        <tag>2018暑假集训</tag>
        <tag>补图</tag>
        <tag>STL</tag>
        <tag>UVA</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[【UVA-136】解题报告（STL，set，优先队列）]]></title>
    <url>%2Fpost%2F1b7db6f0.html</url>
    <content type="text"><![CDATA[原始题目 题目大意因子只包含2，3，5的称为丑数，打印第1500个丑数。 解题思路 优先队列维护，每次拓展2，3，5添加到优先队列中。 解题代码123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051#include &lt;cstdio&gt;#include &lt;cstring&gt;#include &lt;cmath&gt;#include &lt;iostream&gt;#include &lt;iomanip&gt;#include &lt;set&gt;#include &lt;queue&gt;#include &lt;stack&gt;#include &lt;vector&gt;#include &lt;map&gt;#include &lt;string&gt;#include &lt;sstream&gt;#include &lt;bits/stdc++.h&gt;#define rep(i,a,n) for(int i=a;i&lt;n;++i)#define per(i,a,n) for(int i=n-1;i&gt;=a;--i);#define ms(x,a) memset((x),a,sizeof((x))) #define all(x) x.begin(),x.end()#define ins(x) inserter(x,x.begin()) #define INF 0x3f3f3f3f#define eps 1e-8#define fi first#define e 2.718281828459045235360287471352662497757247093699959574966967627724076630353 #define se second#define mp make_pair#define pb push_back#define np next_permutation#define gapline cout&lt;&lt;"##======================##"&lt;&lt;endlusing namespace std;const int maxn=1e5+5;typedef long long ll;const int coeff[3]=&#123;2,3,5&#125;;int main()&#123; priority_queue&lt;ll,vector&lt;ll&gt;, greater&lt;ll&gt; &gt; pq; set&lt;ll&gt;s; pq.push(1); s.insert(1); for(int i=1;;i++)&#123; ll x=pq.top();pq.pop(); if(i==1500)&#123; cout&lt;&lt;"The 1500'th ugly number is "&lt;&lt;x&lt;&lt;".\n"; break; &#125; rep(j,0,3)&#123; ll x2=coeff[j]*x; if(!s.count(x2)) &#123;pq.push(x2);s.insert(x2);&#125; &#125; &#125;&#125; 收获与反思 水题]]></content>
      <categories>
        <category>编程</category>
        <category>ACM</category>
      </categories>
      <tags>
        <tag>算法</tag>
        <tag>ACM</tag>
        <tag>2018暑假集训</tag>
        <tag>补图</tag>
        <tag>STL</tag>
        <tag>UVA</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[【UVA-156】解题报告（STL，map）]]></title>
    <url>%2Fpost%2Feb9ab36.html</url>
    <content type="text"><![CDATA[原始题目 题目大意输入一些单词，找出所有满足下列条件的单词：不区分大小写后不能通过重排得到文本中另一个单词。，按字典序输出复合条件的原单词。 解题思路 利用set储存每个输入单词（自动按字典序排序），将每个单词标准化后其映射值+1。 遍历set输出标准化后映射值为1（只出现过一次）的单词。 解题代码12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455#include &lt;cstdio&gt;#include &lt;cstring&gt;#include &lt;cmath&gt;#include &lt;iostream&gt;#include &lt;iomanip&gt;#include &lt;set&gt;#include &lt;queue&gt;#include &lt;stack&gt;#include &lt;vector&gt;#include &lt;string&gt;#include &lt;sstream&gt;#include &lt;bits/stdc++.h&gt;#define rep(i,a,n) for(int i=a;i&lt;n;++i)#define per(i,a,n) for(int i=n-1;i&gt;=a;--i);#define ms(x,a) memset((x),a,sizeof((x))) #define INF 0x3f3f3f3f#define eps 1e-8#define fi first#define e 2.718281828459045235360287471352662497757247093699959574966967627724076630353 #define se second#define mp make_pair#define pb push_back#define np next_permutation#define gapline cout&lt;&lt;"##======================##"&lt;&lt;endlusing namespace std;const int maxn=1e5+5;const int maxl=26;const int maxm=1e5+5;string s;set&lt;string&gt; ans;map&lt;string,int&gt; mmp;int main()&#123; ios::sync_with_stdio(false); while(cin&gt;&gt;s&amp;&amp;s[0]!='#')&#123; ans.insert(s); string temp=s; rep(i,0,temp.length())&#123; if(isupper(temp[i])) temp[i]=temp[i]-'A'+'a'; &#125; sort(temp.begin(),temp.end()); mmp[temp]++; &#125; set&lt;string&gt;::iterator it; for(it=ans.begin();it!=ans.end();it++)&#123; string temp=*it; rep(i,0,temp.length())&#123; if(isupper(temp[i])) temp[i]=temp[i]-'A'+'a'; &#125; sort(temp.begin(),temp.end()); if(mmp[temp]==1) cout&lt;&lt;*it&lt;&lt;endl; &#125; &#125; 收获与反思 寒假入门的时候做过，现在回来再快速秒之]]></content>
      <categories>
        <category>编程</category>
        <category>ACM</category>
      </categories>
      <tags>
        <tag>算法</tag>
        <tag>ACM</tag>
        <tag>2018暑假集训</tag>
        <tag>补图</tag>
        <tag>STL</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[【HDU-2048】解题报告（递推，DP，数论，错排）]]></title>
    <url>%2Fpost%2F184fc5c7.html</url>
    <content type="text"><![CDATA[原始题目神、上帝以及老天爷 Time Limit: 2000/1000 MS (Java/Others) Memory Limit: 65536/32768 K (Java/Others) Total Submission(s): 50425 Accepted Submission(s): 20379 Problem DescriptionHDU 2006’10 ACM contest的颁奖晚会隆重开始了！为了活跃气氛，组织者举行了一个别开生面、奖品丰厚的抽奖活动，这个活动的具体要求是这样的： 首先，所有参加晚会的人员都将一张写有自己名字的字条放入抽奖箱中；然后，待所有字条加入完毕，每人从箱中取一个字条；最后，如果取得的字条上写的就是自己的名字，那么“恭喜你，中奖了！”大家可以想象一下当时的气氛之热烈，毕竟中奖者的奖品是大家梦寐以求的Twins签名照呀！不过，正如所有试图设计的喜剧往往以悲剧结尾，这次抽奖活动最后竟然没有一个人中奖！ 我的神、上帝以及老天爷呀，怎么会这样呢？ 不过，先不要激动，现在问题来了，你能计算一下发生这种情况的概率吗？ 不会算？难道你也想以悲剧结尾？！ Input输入数据的第一行是一个整数C,表示测试实例的个数，然后是C 行数据，每行包含一个整数$n(1&lt;n≤20)$,表示参加抽奖的人数。 Output对于每个测试实例，请输出发生这种情况的百分比，每个实例的输出占一行, 结果保留两位小数(四舍五入)，具体格式请参照sample output。 Sample Input1 2 Sample Output50.00% Authorlcy Source递推求解专题练习（For Beginner） Recommendlcy 题目大意如题 解题思路 DP 手动写一下如何安排参加人员都不中奖就可以发现规律。$D[i]$表示i个人符合要求的方案数目 比如计算dp[4]时，将1的纸条分给2或3或4，这三种情况下，可以变为解决子问题，比如将1的纸条分给2，之后将2、3、4的纸条分给1、3、4，与dp[3]接近，但是1位置不受限制，即1位置可以放2的纸条，这样又变为dp[2]。 故得到状态转移方程。 D[n]=(n-1)(D[n-1]+D[n-2]) 最后除以总情况数（排列），计算百分数即可。 错排公式 其实本题是一个错排公式题目，我们上面推导出来的$ D[i]=(i-1)(D[i-1]+D[i-2]) $，实际上就是错排公式的一个递推关系。 又因为$D[1]=0,D[2]=1$ 继续推导 \begin{align} D[n] & =(n-1)(D[n-1]+D[n-2]) \\ D[n] - n D[n-1] & = (-1) (D[n-1] - (n-1) D[n-2])\\ D[n] - n D[n-1] & = (-1)^{n-2} (D[2] - 2 D[1]) \\ D[n] & = n D[n-1] + (-1)^{n} \end{align} 如此我们得到了递推关系式，那么求通项公式可以用下面几种方法： 可以用母函数方法求出通项公式（还不会，待学了母函数填坑） 可以用容斥原理 最后得到错排公式为 D[n] = n!( \frac{1}{0!} - \frac{1}{1!} + \frac{1}{2!} - \cdots (-1)^{n} \frac{1}{n!} ) 再补充 简化公式 D(n) = [ \frac{n!}{e} + 0.5 ] 证明相见百度，e是自然对数的底，[x]为x的整数部分。 解题代码 DP 12345678910111213141516171819202122232425262728293031323334353637383940414243#include &lt;cstdio&gt;#include &lt;cstring&gt;#include &lt;iostream&gt;#include &lt;set&gt;#include &lt;algorithm&gt;#include &lt;queue&gt;#include &lt;map&gt;#include &lt;string&gt;#define eps 1e-8#define INF 0x3f3f3f3f#define rep(i,a,n) for(int i=a;i&lt;n;i++)#define per(i,a,n) for(int i=n-1;i&gt;=a;i--)using namespace std;const int maxn=1e5+5;typedef long long ll;ll dp[maxn],A[maxn];void solve()&#123; memset(dp,0,sizeof(dp)); dp[1]=0; dp[2]=1; A[1]=1; A[2]=2; for(ll i=3;i&lt;=20;i++)&#123; dp[i]=(i-1)*(dp[i-1]+dp[i-2]); A[i]=A[i-1]*i; // cout&lt;&lt;dp[i]&lt;&lt;" "&lt;&lt;A[i]&lt;&lt;endl; &#125;&#125;using namespace std;int main()&#123; int t; solve(); while(cin&gt;&gt;t)&#123; rep(i,0,t)&#123; ll a; cin&gt;&gt;a; double ans=(double)dp[a]/(double)A[a];// cout&lt;&lt;"dp[i]"&lt;&lt;dp[a]&lt;&lt;" "&lt;&lt;"A[i]"&lt;&lt;A[a]&lt;&lt;endl; printf("%.2lf%%\n",ans*100); &#125; &#125;&#125; 错排简化公式 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152#include &lt;cstdio&gt;#include &lt;cstring&gt;#include &lt;cmath&gt;#include &lt;iostream&gt;#include &lt;iomanip&gt;#include &lt;set&gt;#include &lt;queue&gt;#include &lt;stack&gt;#include &lt;vector&gt;#include &lt;string&gt;#include &lt;sstream&gt;#include &lt;bits/stdc++.h&gt;#define rep(i,a,n) for(int i=a;i&lt;n;++i)#define per(i,a,n) for(int i=n-1;i&gt;=a;--i);#define ms(x,a) memset((x),a,sizeof((x))) #define INF 0x3f3f3f3f#define eps 1e-8#define fi first#define e 2.718281828459045235360287471352662497757247093699959574966967627724076630353 #define se second#define mp make_pair#define pb push_back#define np next_permutation#define gapline cout&lt;&lt;"##======================##"&lt;&lt;endlusing namespace std;const int maxn=1e5+5;const int maxl=26;const int maxm=1e5+5;typedef long long ll;typedef unsigned long long ull;typedef vector&lt;int&gt; vi;typedef pair&lt;int,int&gt; pii;ll A[maxl];void solve()&#123; A[0]=1; A[1]=1; rep(i,2,maxl) A[i]=A[i-1]*i;&#125;int n; int main()&#123; ios::sync_with_stdio(false); solve(); ll t; cin&gt;&gt;t; while(t--)&#123; cin&gt;&gt;n; double ans=floor((double)A[n]/e+0.5); cout&lt;&lt;fixed&lt;&lt;setprecision(2)&lt;&lt;ans*100/A[n]&lt;&lt;"%"&lt;&lt;endl; &#125; &#125; 收获与反思 注意分析递推公式。手写前几项找规律也可以。 错排公式推导学习 挖坑母函数]]></content>
      <categories>
        <category>编程</category>
        <category>ACM</category>
      </categories>
      <tags>
        <tag>算法</tag>
        <tag>ACM</tag>
        <tag>DP</tag>
        <tag>2018暑假集训</tag>
        <tag>递推</tag>
        <tag>HDU</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[【CSU-1828】解题报告（数论，康托展开逆展开）]]></title>
    <url>%2Fpost%2F3e6878ac.html</url>
    <content type="text"><![CDATA[原始题目1828: Dictionary Time Limit: 2 Sec Memory Limit: 128 Mb Submitted: 202 Solved: 146 DescriptionThe isolated people of MacGuffin Island have a unique culture, and one of the most interesting things about them is their language. Their alphabet consists of the first 9 letters of the Roman alphabet (a, b, c, d, e, f, g, h, i). All of their words are exactly 9 letters long and use each of these 9 letters exactly once. They have a word for every possible permutation of these letters. In the library of their most sacred temple is a dictionary, and each word in their language has its own page. By coincidence they order their words exactly as they would be in ordered in English, so the word ‘abcdefghi’ is on the first page, and the word ‘ihgfedcba’ is on the last. The question is, given a list of random words from the MacGuffin language, can you say on which page of the MacGuffin dictionary each appears? InputThe first line of the input file is a positive integer. This integer tells you how many words will follow. The upper limit for this number is 6000. Every subsequent line contains a single word from the MacGuffin language, so if the first number is 1000 there will be 1000 lines after it, each containing a single word. OutputEach line of output will contain an integer. This integer should be the page number for the corresponding word. Sample Input4 abcdefgih abcdefghi abcdefgih ihgfedcba Sample Output2 1 2 362880 HintSourceACM-ICPC Asia Thailand National On-Site Programming Contest 2015 题目大意输入一个由(a, b, c, d, e, f, g, h, i)各出现一次构成的八位字符串，求其在按字典序排列中的序号。 解题思路看作1-8的排列，利用康托展开输出序号，模板题。 解题代码1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465666768697071727374757677787980818283848586#include &lt;cstdio&gt;#include &lt;cstring&gt;#include &lt;cmath&gt;#include &lt;string&gt;#include &lt;iostream&gt;#include &lt;iomanip&gt;#include &lt;sstream&gt;#include &lt;set&gt;#include &lt;map&gt;#include &lt;queue&gt;#include &lt;vector&gt;#include &lt;bits/stdc++.h&gt;#define INF 0x3f3f3f3f#define eps 1e-8#define mp make_pair#define np next_permutation#define pb push_back#define all(x) x.begin(),x.end()#define rep(i,a,n) for(int i=a;i&lt;n;++i)#define per(i,a,n) for(int i=n-1;i&gt;=a;--i)#define ms(x,a) memset((x),a,sizeof((x))) #define mod 998244353 using namespace std;typedef long long ll;typedef unsigned long long ull;typedef vector&lt;int&gt; vi;typedef pair&lt;int,int&gt; pii;const int maxl=10;const int maxn=1e5+5;int A[maxl];//阶乘； int ans_cantor[maxl];//康托展开数组 bool vis_cantor[maxl];//康托标记数组 string ss;void init()&#123; A[0]=A[1]=1; A[2]=2; rep(i,3,maxl+1) A[i]=A[i-1]*i;&#125;//contar展开，逆展开，数组标号都是从0开始 void cantor(int contar_s[], ll num, int contar_k)&#123;//康托展开，把一个数字num展开成一个数组contar_s，contar_k是数组长度 int t; memset(vis_cantor, 0, sizeof(vis_cantor)); for(int i = 0; i &lt; contar_k; i ++)&#123; t = num / A[contar_k-i-1]; num%=A[contar_k-i-1]; int cnt_cantor=0; rep(j,0,contar_k)&#123; //计算每位的逆序数 cout&lt;&lt;"cnt="&lt;&lt;cnt_cantor&lt;&lt;"t="&lt;&lt;t&lt;&lt;"vis="&lt;&lt;vis_cantor[j]&lt;&lt;endl; if(vis_cantor[j]) continue; if(cnt_cantor==t)&#123; contar_s[i]=j+1,vis_cantor[j]=1;break; &#125; ++cnt_cantor; &#125; &#125; rep(i,0,contar_k) cout&lt;&lt;contar_s[i]&lt;&lt;endl; //输出康拖展开的结果 &#125;ll inv_cantor(int contar_s[], int contar_k)&#123;//康托逆展开，把一个数组contar_s换算成一个数字num int cnt;ll num=0; num = 0; for(int i = 0; i &lt; contar_k; i ++)&#123; cnt = 0; for(int j = i + 1; j &lt; contar_k; j ++)&#123; if(contar_s[i] &gt; contar_s[j]) cnt ++;//判断几个数小于它,即求逆序数。 &#125; num += A[contar_k-i-1] * cnt; &#125; return num;&#125; int main()&#123; ios::sync_with_stdio(false); int t; cin&gt;&gt;t; init(); while(t--)&#123; cin&gt;&gt;ss; rep(i,0,ss.length())&#123; ans_cantor[i]=ss[i]-'a'+1; //这里加不加1都行 &#125; ll num=inv_cantor(ans_cantor,ss.length()); cout&lt;&lt;num+1&lt;&lt;endl; &#125; &#125; 收获与反思 感受模板的力量= =]]></content>
      <categories>
        <category>编程</category>
        <category>ACM</category>
      </categories>
      <tags>
        <tag>算法</tag>
        <tag>ACM</tag>
        <tag>CSU</tag>
        <tag>2018暑假集训</tag>
        <tag>数论</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[【UVA-815】解题报告（贪心，二分）]]></title>
    <url>%2Fpost%2F9eb065c8.html</url>
    <content type="text"><![CDATA[原始题目 题目大意给出$n \times m$个$10 \times 10$底面积柱子的海拔，以及洪水的总体积，计算洪水覆盖后的海拔高度以及覆盖柱子的百分比。 解题思路 首先$n*m$个柱子可以排序后看作一排。 思路一（自己的）：二分猜答案 先判断洪水是否会淹没所有柱子，如果不是的话那么二分下界为最低海拔，上界为最高海拔。二分答案判断 当前海拔下淹没体积是否达到总洪水体积（计算当前淹没体积的时候也需要二分查找，比较繁琐），这个思路 并没有很好的利用海拔随覆盖柱子数增多而增大的性质。 思路二（网络大神）：简化后贪心 先预处理成$1 \times 1$（或者说直接考虑高度），对柱子高度排序后，我们考虑洪水一定是从低到高填充，那么贪心的 让洪水只填充到当前的柱子，直至平均高度不高于下个柱子，这时候就是最终答案。（tql） 解题代码 二分： 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465666768697071727374757677787980818283848586878889#include &lt;cstdio&gt;#include &lt;cstring&gt;#include &lt;cmath&gt;#include &lt;algorithm&gt;#include &lt;set&gt;#include &lt;queue&gt;#include &lt;map&gt;#include &lt;vector&gt;#include &lt;stack&gt;#include &lt;iostream&gt;#include &lt;iomanip&gt;#include &lt;bits/stdc++.h&gt;#define rep(i,a,n) for(int i=a;i&lt;n;++i)#define per(i,a,n) for(int i=n-a;i&gt;=a;--i)#define se second#define fi first#define pb push_back#define mp make_pair#define np next_permutation#define ms(x,a) memset((x),a,sizeof((x)))#define all(x) x.begin(),x.end()#define eps 1e-9#define INF 0x3f3f3f3fusing namespace std;const int maxn=1e5+5;const int maxl=26;typedef long long ll;typedef unsigned long long ull;typedef vector&lt;int&gt; vi;typedef pair&lt;int,int&gt; pii;double a[maxn];double sum[maxn]; double allflood,maxa;int n,m;double check(double nowl, double allcubic)&#123; int index=lower_bound(a,a+m*n,nowl)-a;// cout&lt;&lt;"index="&lt;&lt;index&lt;&lt;" "; if(index==0) return allcubic; double temp=index*nowl-sum[index-1];// cout&lt;&lt;"temp="&lt;&lt;temp&lt;&lt;endl; return allcubic-(10.0*10.0*temp);&#125;int main()&#123; ios::sync_with_stdio(false); int kase=1; while(cin&gt;&gt;m&gt;&gt;n&amp;&amp;m+n)&#123; maxa=-100000; rep(i,0,m)&#123; rep(j,0,n)&#123; cin&gt;&gt;a[i*n+j]; &#125; &#125; sort(a,a+m*n); sum[0]=a[0]; rep(i,1,n*m) sum[i]=sum[i-1]+a[i]; cin&gt;&gt;allflood;// cout&lt;&lt;"mmin="&lt;&lt;a[0]&lt;&lt;" mmax="&lt;&lt;a[n*m-1]&lt;&lt;endl; //一共n*m个区域； cout&lt;&lt;"Region "&lt;&lt;kase++&lt;&lt;endl; //先判断填满是不是够 double temp=10.0*10.0*(n*m*a[n*m-1]-sum[n*m-1]); if(temp&lt;allflood)&#123; double ans=(allflood-temp)/(100.0*n*m)+a[n*m-1]; cout&lt;&lt;"Water level is "&lt;&lt;fixed&lt;&lt;setprecision(2)&lt;&lt;ans&lt;&lt;" meters."&lt;&lt;endl; cout&lt;&lt;"100.00 percent of the region is under water."&lt;&lt;endl; cout&lt;&lt;endl; continue; &#125; //不够 double l=a[0],r=a[n*m-1],mid=(l+r)/2.0; double ans=check(mid,allflood); while(abs(ans)&gt;eps)&#123; if(ans&gt;0) l=mid; else r=mid; mid=(r+l)/2.0;// cout&lt;&lt;"mid="&lt;&lt;mid&lt;&lt;" "; ans=check(mid,allflood); &#125; int index=lower_bound(a,a+m*n,mid)-a; cout&lt;&lt;"Water level is "&lt;&lt;fixed&lt;&lt;setprecision(2)&lt;&lt;mid&lt;&lt;" meters."&lt;&lt;endl; cout&lt;&lt;fixed&lt;&lt;setprecision(2)&lt;&lt;(double)index*100/(n*m)&lt;&lt;" percent of the region is under water."&lt;&lt;endl; cout&lt;&lt;endl; &#125;&#125; 贪心： 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859#include &lt;cstdio&gt;#include &lt;cstring&gt;#include &lt;cmath&gt;#include &lt;algorithm&gt;#include &lt;set&gt;#include &lt;queue&gt;#include &lt;map&gt;#include &lt;vector&gt;#include &lt;stack&gt;#include &lt;iostream&gt;#include &lt;iomanip&gt;#include &lt;bits/stdc++.h&gt;#define rep(i,a,n) for(int i=a;i&lt;n;++i)#define per(i,a,n) for(int i=n-a;i&gt;=a;--i)#define se second#define fi first#define pb push_back#define mp make_pair#define np next_permutation#define ms(x,a) memset((x),a,sizeof((x)))#define all(x) x.begin(),x.end()#define eps 1e-9#define INF 0x3f3f3f3fusing namespace std;const int maxn=1e5+5;const int maxl=26;typedef long long ll;typedef unsigned long long ull;typedef vector&lt;int&gt; vi;typedef pair&lt;int,int&gt; pii;int n,m;int a[maxn];int main()&#123; ios::sync_with_stdio(false); int kase=0; while(cin&gt;&gt;n&gt;&gt;m&amp;&amp;n+m)&#123; n*=m; rep(i,0,n) cin&gt;&gt;a[i]; sort(a,a+n); double ans; cin&gt;&gt;ans; ans/=100; a[n]=INF; int index=0; rep(i,0,n)&#123; ans+=a[i]; if(ans/(i+1)&lt;=a[i+1])&#123; ans=ans/(i+1); index=i+1; break; &#125; &#125; cout&lt;&lt;"Region "&lt;&lt;++kase&lt;&lt;endl; cout&lt;&lt;"Water level is "&lt;&lt;fixed&lt;&lt;setprecision(2)&lt;&lt;ans&lt;&lt;" meters."&lt;&lt;endl; cout&lt;&lt;fixed&lt;&lt;setprecision(2)&lt;&lt;(double)(index*100)/n&lt;&lt;" percent of the region is under water."&lt;&lt;endl; cout&lt;&lt;endl; &#125;&#125; 收获与反思 代码长度和速度高下立判啊。合理尝试贪心、二分，选择合适方法]]></content>
      <categories>
        <category>编程</category>
        <category>ACM</category>
      </categories>
      <tags>
        <tag>算法</tag>
        <tag>ACM</tag>
        <tag>二分</tag>
        <tag>Greedy</tag>
        <tag>UVA</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[【UVA-101】解题报告（模拟）]]></title>
    <url>%2Fpost%2Fd50b784.html</url>
    <content type="text"><![CDATA[原始题目 题目大意有$n$个积木，初始放在$0,1,2 \cdots n-1$位置上，有四种搭积木操作 move a onto b where a and b are block numbers, puts block a onto block b after returning any blocks that arestacked on top of blocks a and b to their initial positions. 把a和b上的积木放回原来位置，再将a放置到b上。 move a over b where a and b are block numbers, puts block a onto the top of the stack containing block b, afterreturning any blocks that are stacked on top of block a to their initial positions. 把a上的积木放回原来位置，再将a放置在b所在的积木堆上。 pile a onto b where a and b are block numbers, moves the pile of blocks consisting of block a, and any blocksthat are stacked above block a, onto block b. All blocks on top of block b are moved to theirinitial positions prior to the pile taking place. The blocks stacked above block a retain their orderwhen moved. 把b上的积木放回原来位置，再将a和a之上的积木块一起放在b上（保持相对顺序）。 pile a over b where a and b are block numbers, puts the pile of blocks consisting of block a, and any blocksthat are stacked above block a, onto the top of the stack containing block b. The blocks stackedabove block a retain their original order when moved. 把a和a之上的积木块一起放在b所在的积木堆上（保持相对顺序）。 直至遇到quit停止操作，输出最后每个位置上的积木状态。 解题思路 由于不涉及积木块放置在指定位置的操作，还原必定到原有位置且原有位置为空（易证），不用考虑木块放回的特殊情况。 注意判断是否在同一堆上，违法命令不进行任何实际操作 模拟四种操作即可 解题代码 数组模拟四种操作 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147148149150151152153154155156157#include &lt;cstdio&gt;#include &lt;cstring&gt;#include &lt;cmath&gt;#include &lt;algorithm&gt;#include &lt;set&gt;#include &lt;queue&gt;#include &lt;map&gt;#include &lt;vector&gt;#include &lt;stack&gt;#include &lt;iostream&gt;#include &lt;iomanip&gt;#include &lt;bits/stdc++.h&gt;#define rep(i,a,n) for(int i=a;i&lt;n;++i)#define per(i,a,n) for(int i=n-a;i&gt;=a;--i)#define se second#define fi first#define pb push_back#define mp make_pair#define np next_permutation#define ms(x,a) memset((x),a,sizeof((x)))#define all(x) x.begin(),x.end()#define eps 1e-9#define INF 0x3f3f3f3fusing namespace std;const int maxn=1e5+5;const int maxl=26;typedef long long ll;typedef unsigned long long ull;typedef vector&lt;int&gt; vi;typedef pair&lt;int,int&gt; pii;int n,m,a,b;string s1,s2;int top[maxn],bottom[maxn],place[maxn],mmp[maxn];void initial()&#123; rep(i,0,n) top[i]=bottom[i]=place[i]=i; rep(i,0,n) mmp[i]=-1;&#125;void solve(int aa,int bb,int index)&#123; switch(index)&#123; case 1: &#123; while(mmp[aa]!=-1)&#123; int next=mmp[aa]; mmp[aa]=mmp[next]; mmp[next]=-1; top[next]=bottom[next]=place[next]=next; &#125; while(mmp[bb]!=-1)&#123; int next=mmp[bb]; mmp[bb]=mmp[next]; mmp[next]=-1; top[next]=bottom[next]=place[next]=next; &#125; mmp[bb]=aa; int start=top[place[aa]]; if(start==aa) top[aa]=-1; else&#123; while(mmp[start]!=aa) start=mmp[start]; mmp[start]=-1; &#125; place[aa]=place[bb]; &#125; break; case 2: &#123; while(mmp[aa]!=-1)&#123; int next=mmp[aa]; mmp[aa]=mmp[next]; mmp[next]=-1; top[next]=bottom[next]=place[next]=next; &#125; while(mmp[bb]!=-1) bb=mmp[bb]; mmp[bb]=aa; int start=top[place[aa]]; if(start==aa) top[aa]=-1; else&#123; while(mmp[start]!=aa) start=mmp[start]; mmp[start]=-1; &#125; place[aa]=place[bb]; &#125; break; case 3: &#123; while(mmp[bb]!=-1)&#123; int next=mmp[bb]; mmp[bb]=mmp[next]; mmp[next]=-1; top[next]=bottom[next]=place[next]=next; &#125; mmp[bb]=aa; int start=top[place[aa]]; if(start==aa) top[aa]=-1; else&#123; while(mmp[start]!=aa) start=mmp[start]; mmp[start]=-1; &#125; while(mmp[bb]!=-1)&#123; place[mmp[bb]]=place[bb]; bb=mmp[bb]; &#125; &#125; break; case 4: &#123; while(mmp[bb]!=-1) bb=mmp[bb]; mmp[bb]=aa; int start=top[place[aa]]; if(start==aa) top[aa]=-1; else&#123; while(mmp[start]!=aa) start=mmp[start]; mmp[start]=-1; &#125; while(mmp[bb]!=-1)&#123; place[mmp[bb]]=place[bb]; bb=mmp[bb]; &#125; &#125; break; &#125;&#125;int main()&#123; while(cin&gt;&gt;n)&#123; initial(); while(cin&gt;&gt;s1&amp;&amp; s1[0]!='q')&#123; cin&gt;&gt;a&gt;&gt;s2&gt;&gt;b; if(place[a]==place[b]) continue; if(s1[0]=='m' &amp;&amp; s2[1]=='n') solve(a,b,1); if(s1[0]=='m' &amp;&amp; s2[1]=='v') solve(a,b,2); if(s1[0]=='p' &amp;&amp; s2[1]=='n') solve(a,b,3); if(s1[0]=='p' &amp;&amp; s2[1]=='v') solve(a,b,4); &#125; rep(i,0,n)&#123; cout&lt;&lt;i&lt;&lt;":"; if(top[i]==-1) cout&lt;&lt;endl; else &#123; int start=top[i]; cout&lt;&lt;" "&lt;&lt;start; while(mmp[start]!=-1)&#123; start=mmp[start]; cout&lt;&lt;" "&lt;&lt;start; &#125; cout&lt;&lt;endl; &#125; &#125;// cout&lt;&lt;endl; &#125;&#125; vector模拟两种操作 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778#include &lt;bits/stdc++.h&gt;#define rep(i,a,n) for(int i=a;i&lt;n;++i)#define per(i,a,n) for(int i=n-1;i&gt;=a;--i)#define fi first#define se second#define mp make_pair#define pb push_back#define np next_permutation#define cl(x,a,n) memset(x,a,sizeof(int)*n)using namespace std;typedef long long ll;typedef unsigned long long ull;typedef long double ld;typedef vector&lt;int&gt; vi;typedef pair&lt;int,int&gt; pii;typedef pair&lt;string,string&gt; pss;const int maxn=30;int n;vector&lt;int&gt; pile[maxn];void find_block(int a,int &amp;p, int &amp; h) &#123;// 引用形式返回ouke和高度 for( p=0;p&lt;n;p++)&#123; for(h=0;h&lt;pile[p].size();h++)&#123; if(pile[p][h]==a ) return; &#125; &#125;&#125;void clear_above(int p,int h)&#123; for(int i=h+1;i&lt;pile[p].size();i++)&#123; int b=pile[p][i]; pile[b].pb(b); &#125; pile[p].resize(h+1);&#125;void pile_onto(int p,int h,int p2)&#123; for(int i=h; i&lt;pile[p].size();i++)&#123; pile[p2].pb(pile[p][i]); &#125; pile[p].resize(h);&#125;void print()&#123; for(int i=0;i&lt;n;++i)&#123; printf("%d:",i); for(int j=0;j&lt;pile[i].size();j++) printf(" %d",pile[i][j]); printf("\n"); &#125;&#125;int main()&#123; int a,b; cin&gt;&gt;n; string s1,s2; rep(i,0,n) pile[i].pb(i); while(cin&gt;&gt;s1&gt;&gt;a&gt;&gt;s2&gt;&gt;b)&#123; int pa,pb,ha,hb; find_block(a,pa,ha); find_block(b,pb,hb); if(pa==pb) continue; //feifa if(s2=="onto") clear_above(pb,hb); if(s1=="move") clear_above(pa,ha); pile_onto(pa,ha,pb); &#125; print(); return 0;&#125; 收获与反思 大模拟，输出注意PE。]]></content>
      <categories>
        <category>编程</category>
        <category>ACM</category>
      </categories>
      <tags>
        <tag>算法</tag>
        <tag>ACM</tag>
        <tag>Imitation</tag>
        <tag>2018暑假集训</tag>
        <tag>UVA</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[【UVA-10815】解题报告（STL，set）]]></title>
    <url>%2Fpost%2F9282aeca.html</url>
    <content type="text"><![CDATA[原始题目 题目大意给定一段含标点的文章，将其中的单词全部按小写的字典序输出。 解题思路 去年做过这个题，当时入门 现在利用strig类和stringstream类可以轻松完成任务 解题代码12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849//set ssteam #include &lt;cstdio&gt;#include &lt;cstring&gt;#include &lt;cmath&gt;#include &lt;algorithm&gt;#include &lt;set&gt;#include &lt;queue&gt;#include &lt;map&gt;#include &lt;vector&gt;#include &lt;stack&gt;#include &lt;iostream&gt;#include &lt;iomanip&gt;#include &lt;sstream&gt;#include &lt;bits/stdc++.h&gt;#define rep(i,a,n) for(int i=a;i&lt;n;++i)#define per(i,a,n) for(int i=n-a;i&gt;=a;--i)#define se second#define fi first#define pb push_back#define mp make_pair#define np next_permutation#define ms(x,a) memset((x),a,sizeof((x)))#define all(x) x.begin(),x.end()#define eps 1e-9#define INF 0x3f3f3f3fusing namespace std;string s,ans;int main()&#123; ios::sync_with_stdio(false);// freopen("in.txt","r",stdin); set &lt;string&gt; sset; while(cin&gt;&gt;s)&#123; //处理一下 rep(i,0,s.length())&#123; if(!isalpha(s[i])) s[i]=' '; else s[i]=tolower(s[i]); &#125;// cout&lt;&lt;s&lt;&lt;endl; stringstream ss(s); while(ss&gt;&gt;ans)&#123; sset.insert(ans); &#125; &#125; for(set&lt;string&gt;::iterator it=sset.begin();it!=sset.end();it++)&#123; cout&lt;&lt;*it&lt;&lt;endl; &#125;&#125; 收获与反思 再多熟练运用一下stringstream]]></content>
      <categories>
        <category>编程</category>
        <category>ACM</category>
      </categories>
      <tags>
        <tag>算法</tag>
        <tag>ACM</tag>
        <tag>2018暑假集训</tag>
        <tag>STL</tag>
        <tag>UVA</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[《我辈孤雏》读书笔记]]></title>
    <url>%2Fpost%2F66258384.html</url>
    <content type="text"><![CDATA[内容摘录与笔记第一部 P29 “我一时之间竟说不上话，后来总算把话吐出来：‘您真是太仁慈了，先生，您的协助，我感激不尽，而且我也不希望您以为我不懂事。不过有一点请您谅解，我觉得我不该在这个时候返回英国。’上校一时之间并没有反应……” 第二部 P68 “接下来是针针见血的猛烈抨击，她对督察所用的这一招，我早已熟悉，而日后也还要听她陈述其中概要好多次；她先泛泛地批评英国政府，再把火力集中到私人企业，特别是摩根洋行身上，说他们不该从印度，输入这么庞大数量地鸦片到中国，然后冷眼旁观这整个民族陷入悲惨与堕落，说的时候，母亲地声音常常高张欲裂，不过都尖而未破，她双眼始终不曾放松……” P139 “这么多年来，她让我敬畏有加，可现在我明白这一切全是装腔作势：她丝毫无法控制这个逐渐将我们吞没的混乱世界，她只是个可悲的小女人，全靠伪装在我眼中建立她的形象，当巨大势力相互冲突斗争之际，她根本贱于蝼蚁。我站在走廊上瞪着她，眼神鄙夷至极。” 第三部 再次出现系住百叶窗叶片地细绳。 P153 “因为像您这样的人才，警探先生，这样的人才实在难得。像我们这样的人，我们的职责就是打击坏人，我们……该怎么说好呢？我们就像系住百叶窗叶片的细绳。一旦我们系得不牢靠，一切都会分崩离析。您背负得责任可是相当重大啊，警探先生。” 第四部 P179 “‘不，不，先生’——格雷森先生紧张地笑了笑——‘我指地是另一个欢迎仪式。我的意思是，欢迎令尊令堂历劫多年归来地那个。’” 第五部 P183 “从我抵达地那一刻起，真正教我心里暗暗吃惊的是，这里每一个人都拒绝承认他们都罪有应得。待在这里约两周地时间里，在我所接触的所有这些英国人当中，无论地位高低，我都还没遇到——一次也没有——有谁真心感到愧疚。换言之，在这里，在这个可能吞噬整个闻名世界地大漩涡的涡眼里，大家在心照不宣中无耻可悲地集体否认现实，否认自身的责任，而这种行为转为自我封闭，变本加厉，以冠冕堂皇地自我保护表现于外，这是我经常碰到地情况。而现在眼前地这一群所谓上海的精英，如此不屑一顾地凝望他们地中国邻居在运河对岸受苦受难。” 第六部 P327 “桌上的阅读灯下有一圈温暖的光线，可是房中其他部分都一片幽暗。正当我站在那里观察周遭的情况，有个身影从书桌边站了起来，小心地绕过书桌，回头指着桌后他空出来的座位。‘怎么不过去坐那儿，小海雀？’菲利普叔叔对我说，‘你还记得吧？你以前最喜欢坐我书桌后面的位子了。’” P332 “‘那么我母亲呢？她发生了什么事？’ 菲利普叔叔向前探身，双肘撑着桌子，头部微微往后仰。‘你对于她的事，现在知道的有多少？’他问。他先前在声音里所表现的轻松已经完全消失。他现在看起来有如心事重重的老人，饱受自我悔恨的折磨。尽管他把头往后仰，却还是仔细盯着我看，桌灯的黄光照拂下，看得他白色的鼻毛突出鼻孔。我听到楼下某处，正播放着中国军歌。” P336 “我探身向他，进入桌灯炫目的光亮之中，我有种奇怪的感觉，身后的黑暗愈变愈大，此时在那里摊成了一大片幽暗无光的空间。菲利普叔叔用掌心拭去前额的汗珠。不过他现在专注地看着我，继续说：‘那天后来我去新城饭店见王顾。我尽我所能化解可能面临的灾难。不过为时已晚。他那天下午对我说的话，一点都没有生气的样子。他发现你母亲的精神——他就是这么说的，她的‘精神’——非常迷人。他已经为之倾倒，因此打算娶她为妾，带她回湖南。他说要‘驯服’她，如同对待一匹野生的母马一样。这个你得理解，小海雀，你得理解那时候在上海、在中国是什么样的局势，像王顾这样的人，若是决定要做这类的事，谁也阻止不了他。这点你必须理解。向警方或任何人要求保护你母亲，根本不会有结果。也许能暂时缓一缓，不过终究是无用。没有任何人能保护她，不让这种人得逞。不过你明白吗，我真正担心的是你，小海雀。我不确定他打算怎么处置你，这才是我求他的事。结果我们达成协议。我想办法让她落单，无人守护，而同时我又把你带离现场。我只求他这件事。我不希望他连你也带走。你母亲，只能说是在劫难逃。至于你，还有商量的余地，我就是做了这样的事。’” P338 “‘菲利普叔叔，什么财务安排？’ 他低头看着手背，端详了半晌。‘要不是为了你，她对你的爱，小海雀，我相信你母亲会毫不迟疑结束自己的生命，不会让那个恶棍碰她一下。她总会有办法，也一定会做到。可是她还得担心你。因此，到了最后，她看情势比人强，便做了安排。你将会得到财务上的供应，以换取……换取她的顺从。我亲自监督了大半的程序，经由公司来安排。公司里有个对这件事全无概念的人，还以为这是在为鸦片的安全运送做安排呢！哈！哈！真是个傻子，那个人！’菲利普叔叔摇摇头，面露笑容。接着他的表情又阴沉起来，仿佛他要回到我们原先要谈的主题。 ‘我的生活费，’我平静地说，‘我继承的财产……’‘你在英国的姑妈，她从来就没富有过。真正资助你的人，这么多年来，一直是王顾。’” 在黑夜中摸索，希望能寻得父母那一辈所遗失的真相，奈何在现实的冷酷与成熟面前，我们终究不过孤雏而已，想象不到黑暗中那股势力的强大，压垮了我们本以为还算成熟的臂膀。比起那个时代，我们算得上什么？太过渺小而已。 第七部 P363 “不过，对于我们这种人而言，我们的命运是以孤儿的眼光看待世界，长年追逐着父母消逝的暗影。我们只有尽全力把使命完成，别无解脱之途，在此之前，心中无法得到片刻的宁静。”]]></content>
      <categories>
        <category>阅读</category>
      </categories>
      <tags>
        <tag>阅读</tag>
        <tag>小说</tag>
        <tag>文学</tag>
        <tag>石黑一雄</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[【POJ-3660】解题报告（Floyd传递闭包）]]></title>
    <url>%2Fpost%2F6fc3409b.html</url>
    <content type="text"><![CDATA[原始题目Cow Contest Time Limit: 1000MS Memory Limit: 65536K Total Submissions: 15815 Accepted: 8813 DescriptionN (1 ≤ N ≤ 100) cows, conveniently numbered 1..N, are participating in a programming contest. As we all know, some cows code better than others. Each cow has a certain constant skill rating that is unique among the competitors. The contest is conducted in several head-to-head rounds, each between two cows. If cow A has a greater skill level than cow B (1 ≤ A ≤ N; 1 ≤ B ≤ N; A ≠ B), then cow A will always beat cow B. Farmer John is trying to rank the cows by skill level. Given a list the results of M (1 ≤ M ≤ 4,500) two-cow rounds, determine the number of cows whose ranks can be precisely determined from the results. It is guaranteed that the results of the rounds will not be contradictory. Input Line 1: Two space-separated integers: N and M Lines 2..M+1: Each line contains two space-separated integers that describe the competitors and results (the first integer, A, is the winner) of a single round of competition: A and B Output Line 1: A single integer representing the number of cows whose ranks can be determined Sample Input5 5 4 3 4 2 3 2 1 2 2 5 Sample Output2 SourceUSACO 2008 January Silver 题目大意一共有N头牛，现在知道M条信息，每条信息描述两头牛谁更强一些，问可以确定最多多少头牛的排名。 解题思路 还在学习中，使用Floyd算法求闭包，（A胜B，B胜C，则传递A胜C） 然后对于每头牛扫一遍是否与其他n-1头牛都有确定的胜负关系，如果有的话答案++。 还需要深入学习Floyd算法 解题代码123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960#include &lt;cstdio&gt;#include &lt;cstring&gt;#include &lt;cmath&gt;#include &lt;iostream&gt;#include &lt;iomanip&gt;#include &lt;algorithm&gt;#include &lt;set&gt;#include &lt;map&gt;#include &lt;vector&gt;#include &lt;stack&gt;#include &lt;queue&gt;#define mp make_pair#define pb push_back#define np next_permutation#define rep(i,a,n) for(int i=a;i&lt;n;++i)#define per(i,a,n) for(int i=n-1;i&gt;=a;--i)#define first fi#define second se#define eps 1e-9#define INF 0x3f3f3f3f#define ms(x,a) memset((x),a,sizeof((x)))#define all(x) x.begin(),x.end()#define gapline cout&lt;&lt;"##================##"&lt;&lt;endlusing namespace std;const int maxn=1e3+5;const int mal=26;typedef long long ll;typedef unsigned long long ull;typedef vector&lt;int&gt; vi;typedef pair&lt;int,int&gt; pii;bool ans[maxn][maxn]; int n,m;void Floyd()&#123; rep(k,1,n+1) rep(i,1,n+1) rep(j,1,n+1) ans[i][j]=ans[i][j]|(ans[i][k]&amp;ans[k][j]); &#125;int main()&#123; ios::sync_with_stdio(false); while(cin&gt;&gt;n)&#123; cin&gt;&gt;m; ms(ans,0); rep(i,0,m)&#123; int a,b; cin&gt;&gt;a&gt;&gt;b; ans[a][b]=1; &#125; Floyd(); int aans=0; rep(i,1,n+1)&#123; int ccnt=0; rep(j,1,n+1)&#123; if(ans[i][j]||ans[j][i]) ccnt++; &#125; if(ccnt==n-1) aans++; &#125; cout&lt;&lt;aans&lt;&lt;endl; &#125; &#125; 收获与反思 挖坑，加强理解Floyd最短路算法。]]></content>
      <categories>
        <category>编程</category>
        <category>ACM</category>
      </categories>
      <tags>
        <tag>算法</tag>
        <tag>ACM</tag>
        <tag>2018暑假集训</tag>
        <tag>POJ</tag>
        <tag>Floyd</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[【HDU-1548】解题报告（BFS）]]></title>
    <url>%2Fpost%2Fac92be99.html</url>
    <content type="text"><![CDATA[原始题目A strange lift Time Limit: 2000/1000 MS (Java/Others) Memory Limit: 65536/32768 K (Java/Others) Total Submission(s): 32759 Accepted Submission(s): 11752 Problem DescriptionThere is a strange lift.The lift can stop can at every floor as you want, and there is a number $K_i (0 \le K_i \le N) $ on every floor.The lift have just two buttons: up and down.When you at floor i,if you press the button “UP” , you will go up $K_i$ floor,i.e,you will go to the i+Ki th floor,as the same, if you press the button “DOWN” , you will go down $K_i$ floor,i.e,you will go to the i-Ki th floor.Of course, the lift can’t go up high than N,and can’t go down lower than 1. For example, there is a buliding with 5 floors, and $k_1 = 3, k_2 = 3 , k_3 = 1 , k_4 = 2 , k_5 = 5 . $ Begining from the 1 st floor,you can press the button “UP”, and you’ll go up to the 4 th floor,and if you press the button “DOWN”, the lift can’t do it, because it can’t go down to the -2 th floor,as you know ,the -2 th floor isn’t exist. Here comes the problem: when you are on floor A,and you want to go to floor B,how many times at least he has to press the button “UP” or “DOWN”? InputThe input consists of several test cases.,Each test case contains two lines. The first line contains three integers $N,A,B( 1 \le N,A,B \le 200)$ which describe above,The second line consist $N$ integers $k_1,k_2 \cdots k_n$ . A single 0 indicate the end of the input. OutputFor each case of the input output a interger, the least times you have to press the button when you on floor A,and you want to go to floor B.If you can’t reach floor B,printf “-1”. Sample Input5 1 5 3 3 1 2 5 0 Sample Output3 Recommend8600 题目大意有一个电梯，对于每一层$i$，只能上升或者下降$a_i$（不能低于$1$层或高于$n$层），现在给定初态层数和末态层数，问最少需要操作几次才可以达到末态层数。到达不了输出-1。 解题思路 两方向BFS，注意打标记和输出-1的情况即可。 解题代码123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566#include &lt;cstdio&gt;#include &lt;cstring&gt;#include &lt;iostream&gt;#include &lt;iomanip&gt;#include &lt;map&gt;#include &lt;set&gt;#include &lt;algorithm&gt;#include &lt;queue&gt;#include &lt;vector&gt;#include &lt;stack&gt;//#include &lt;bits/stdc++.h&gt;//#define mp make_pair#define np next_permutation#define pb push_back#define fi first#define se second#define eps 1e-8#define INF 0x3f3f3f3f#define rep(i,a,n) for(int i=a;i&lt;n;++i)#define per(i,a,n) for(int i=n-1;i&gt;=a;--i)using namespace std;typedef long long ll;typedef unsigned long long ull;typedef vector&lt;int&gt; vi;typedef pair&lt;int,int&gt; pii;const int maxn=1e4+5;int vis[maxn];int mp[maxn],n,a,b;void bfs()&#123; int ans=0; int flag=0; queue&lt;pii&gt;q; q.push(make_pair(a,0)); memset(vis,0,sizeof(vis)); vis[a]=1; while(!q.empty())&#123; pii now=q.front(); q.pop(); if(now.fi==b)&#123; cout&lt;&lt;now.second&lt;&lt;endl; flag=1; break; &#125; int down=now.fi-mp[now.fi]; int up=now.fi+mp[now.fi];// cout&lt;&lt;"up="&lt;&lt;up&lt;&lt;" down="&lt;&lt;down&lt;&lt;endl; if(down&gt;=1 &amp;&amp; !vis[down])&#123; vis[down]=1; q.push(make_pair(down,now.second+1)); &#125; if(up&lt;=n &amp;&amp; !vis[up])&#123; vis[up]=1; q.push(make_pair(up,now.second+1)); &#125; &#125; if(!flag) cout&lt;&lt;-1&lt;&lt;endl;&#125;int main()&#123; ios::sync_with_stdio(false); while(cin&gt;&gt;n&amp;&amp;n)&#123; cin&gt;&gt;a&gt;&gt;b; rep(i,1,n+1) cin&gt;&gt;mp[i]; bfs(); &#125; &#125; 收获与反思 简单bfs，注意打对标记即可。]]></content>
      <categories>
        <category>编程</category>
        <category>ACM</category>
      </categories>
      <tags>
        <tag>算法</tag>
        <tag>ACM</tag>
        <tag>2018暑假集训</tag>
        <tag>BFS</tag>
        <tag>HDU</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[【CodeForces-579A】解题报告（二进制）]]></title>
    <url>%2Fpost%2Fc37095b9.html</url>
    <content type="text"><![CDATA[原始题目A. Raising Bacteria time limit per test1 second memory limit per test256 megabytes inputstandard input outputstandard output You are a lover of bacteria. You want to raise some bacteria in a box. Initially, the box is empty. Each morning, you can put any number of bacteria into the box. And each night, every bacterium in the box will split into two bacteria. You hope to see exactly x bacteria in the box at some moment. What is the minimum number of bacteria you need to put into the box across those days? InputThe only line containing one integer x (1 ≤ x ≤ $10^9$). OutputThe only line containing one integer: the answer. Examplesinput5 output2 input8 output1 NoteFor the first sample, we can add one bacterium in the box in the first day morning and at the third morning there will be 4 bacteria in the box. Now we put one more resulting 5 in the box. We added 2 bacteria in the process so the answer is 2. For the second sample, we can put one in the first morning and in the 4-th morning there will be 8 in the box. So the answer is 1. 题目大意初始盒子是空的，每天早晨你可以放任意个细菌到盒子盒子中去，每个细菌在盒子中每天分裂成两个。现在给出x，问最少需要放多少个细菌可以使一定天数后盒子中细菌数量恰好为x。 解题思路 在不限制天数的情况下，恰巧达到x就让每个放入的细菌尽可能繁殖 将x用二进制表示，有多少个1即为答案。 解题代码123456789101112131415161718192021222324252627282930313233343536373839#include &lt;cstdio&gt;#include &lt;cstring&gt;#include &lt;iostream&gt;#include &lt;iomanip&gt;#include &lt;map&gt;#include &lt;set&gt;#include &lt;algorithm&gt;#include &lt;queue&gt;#include &lt;vector&gt;#include &lt;stack&gt;#include &lt;bits/stdc++.h&gt;#define mp make_pair#define np next_permutation#define pb push_back#define fi first#define se second#define eps 1e-8#define INF 0x3f3f3f3fusing namespace std;typedef long long ll;typedef unsigned long long ull;typedef vector&lt;int&gt; vi;typedef pair&lt;int,int&gt; pii;const int maxn=1e5+5;const int maxl=26;ll n;int main()&#123; ios::sync_with_stdio(false); while(cin&gt;&gt;n)&#123; ll ans=0; while(n)&#123; if(n&amp;1) ans++; n&gt;&gt;=1; &#125; cout&lt;&lt;ans&lt;&lt;endl; &#125; &#125; 收获与反思 思维]]></content>
      <categories>
        <category>编程</category>
        <category>ACM</category>
      </categories>
      <tags>
        <tag>算法</tag>
        <tag>ACM</tag>
        <tag>2018暑假集训</tag>
        <tag>CodeForces</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[【HDU-1430】解题报告（数论，康拓展开逆展开，简单哈希，BFS）]]></title>
    <url>%2Fpost%2F6f3b3edd.html</url>
    <content type="text"><![CDATA[原始题目魔板 Time Limit: 10000/5000 MS (Java/Others) Memory Limit: 65536/32768 K (Java/Others) Total Submission(s): 4318 Accepted Submission(s): 1033 Problem Description在魔方风靡全球之后不久，Rubik先生发明了它的简化版——魔板。魔板由8个同样大小的方块组成，每个方块颜色均不相同，可用数字1-8分别表示。任一时刻魔板的状态可用方块的颜色序列表示：从魔板的左上角开始，按顺时针方向依次写下各方块的颜色代号，所得到的数字序列即可表示此时魔板的状态。例如，序列(1,2,3,4,5,6,7,8)表示魔板状态为： 1 2 3 48 7 6 5 对于魔板，可施加三种不同的操作，具体操作方法如下： A: 上下两行互换,如上图可变换为状态87654321 B: 每行同时循环右移一格,如上图可变换为41236785 C: 中间4个方块顺时针旋转一格,如上图可变换为17245368 给你魔板的初始状态与目标状态，请给出由初态到目态变换数最少的变换步骤，若有多种变换方案则取字典序最小的那种。 Input每组测试数据包括两行，分别代表魔板的初态与目态。 Output对每组测试数据输出满足题意的变换步骤。 Sample Input12345678 17245368 12345678 82754631 Sample OutputC AC AuthorLL SourceACM暑期集训队练习赛（三） Recommendlinle 题目大意如题 解题思路 先考虑暴力，对于每个初态，按A，B，C的顺序BFS，到末态，输出。 不过，似乎有些问题。 问题1：如何表示状态？ 问题2：多组数据每次都BFS的话，会T，咋办？ 对于问题1，我们不难发现，不同状态其实对应了1-8的一个排列，很明显根据常识我们知道排列是有顺序的（逆序数逐渐增大）那么我们可否根据排列的数组得到他对应全排列里的序号？其实这和康托展开就搭上关系了。 康拓展开：康托展开是一个全排列到一个自然数的双射，常用于构建哈希表时的空间压缩。 康托展开的实质是计算当前排列在所有由小到大全排列中的顺序，因此是可逆的。 稍微详细点的介绍放在收获与反思里。 这样我们就解决了表示状态的问题。 那么对于问题2呢。我们会发现，魔板从初态到末态，重要的是每个板子相对位置的变化，而不是板子的数。换言之，我们可以做一个初态到’12345678’的映射，重新给板子标号，再将末态各板子按映射关系对应新的标号，即末态按照映射对应一个新标号的末态。 初态 末态 75621483 -&gt; 13846572 ↓ 映射 12345678 -&gt; 58763214 代码为 rep(i,0,len1){ hhash[raw1[i]-&#39;0&#39;]=i+1; } rep(i,0,len1){ b[i]=hhash[raw2[i]-&#39;0&#39;]; } 保留板子相对移动的位置不变化即可，这样我们只要预处理一下’12345678’到各个排列的末态，然后对每组输入，做映射到’12345678’，输出新末态的结果即可。 解题代码123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135#include &lt;cstdio&gt;#include &lt;cstring&gt;#include &lt;cmath&gt;#include &lt;string&gt;#include &lt;iostream&gt;#include &lt;iomanip&gt;#include &lt;sstream&gt;#include &lt;set&gt;#include &lt;map&gt;#include &lt;queue&gt;#include &lt;vector&gt;#include &lt;bits/stdc++.h&gt;#define INF 0x3f3f3f3f#define eps 1e-8#define mp make_pair#define np next_permutation#define pb push_back#define all(x) x.begin(),x.end()#define rep(i,a,n) for(int i=a;i&lt;n;++i)#define per(i,a,n) for(int i=n-1;i&gt;=a;--i)#define ms(x,a) memset((x),a,sizeof((x))) #define mod 998244353 #define gapline cout&lt;&lt;"##---------------##"&lt;&lt;endlusing namespace std;typedef long long ll;typedef unsigned long long ull;typedef vector&lt;int&gt; vi;typedef pair&lt;int,int&gt; pii;const int maxl=8;const int maxn=1e5+5;int A[maxl];//阶乘； int ans_cantor[maxl];//康托展开数组 int next_cantor[maxl];bool vis_cantor[maxl];//康托标记数组 bool vis[maxn];int hhash[20],b[20];string ans[maxn];string raw1,raw2;queue &lt;ll&gt; q;void prechange()&#123; int len1=raw1.length(); rep(i,0,len1)&#123; hhash[raw1[i]-'0']=i+1; &#125; rep(i,0,len1)&#123; b[i]=hhash[raw2[i]-'0']; &#125;&#125;//contar展开，逆展开，数组标号都是从0开始 void cantor(int contar_s[], ll num, int contar_k)&#123;//康托展开，把一个数字num展开成一个数组contar_s，contar_k是数组长度 int t; memset(vis_cantor, 0, sizeof(vis_cantor)); for(int i = 0; i &lt; contar_k; i ++)&#123; t = num / A[contar_k-i-1]; num%=A[contar_k-i-1]; int cnt_cantor=0; rep(j,0,contar_k)&#123; //计算每位的逆序数 if(vis_cantor[j]) continue; if(cnt_cantor==t)&#123; contar_s[i]=j+1,vis_cantor[j]=1;break; &#125; ++cnt_cantor; &#125; &#125;// rep(i,0,contar_k) cout&lt;&lt;contar_s[i]&lt;&lt;' '; //输出康拖展开的结果 // cout&lt;&lt;endl;// gapline;&#125;ll inv_cantor(int contar_s[], int contar_k)&#123;//康托逆展开，把一个数组contar_s换算成一个数字num int cnt;ll num=0; num = 0; for(int i = 0; i &lt; contar_k; i ++)&#123; cnt = 0; for(int j = i + 1; j &lt; contar_k; j ++)&#123; if(contar_s[i] &gt; contar_s[j]) cnt ++;//判断几个数小于它,即求逆序数。 &#125; num += A[contar_k-i-1] * cnt; &#125; return num;&#125;void change(int i)&#123; switch(i)&#123; case 0: //操作A rep(j,0,4) swap(next_cantor[j],next_cantor[maxl-1-j]); break; case 1: //操作B per(j,1,4) swap(next_cantor[(j+1)%4],next_cantor[j]); swap(next_cantor[4],next_cantor[7]); swap(next_cantor[5],next_cantor[4]); swap(next_cantor[6],next_cantor[5]); break; case 2: //操作C swap(next_cantor[1],next_cantor[2]); swap(next_cantor[1],next_cantor[6]); swap(next_cantor[6],next_cantor[5]); break; &#125;&#125;void bfs()&#123; A[0]=A[1]=1; A[2]=2; rep(i,3,maxl+1) A[i]=A[i-1]*i; while(!q.empty()) q.pop(); q.push(0); vis[0]=1; while(!q.empty())&#123; ll temp1=q.front();q.pop(); cantor(ans_cantor,temp1,maxl); rep(i,0,3)&#123; rep(j,0,maxl) next_cantor[j]=ans_cantor[j]; change(i); ll temp2=inv_cantor(next_cantor,maxl); if(!vis[temp2])&#123; q.push(temp2); vis[temp2]=1; ans[temp2]=ans[temp1]+(char)('A'+i); &#125; &#125; &#125;&#125; int main()&#123; ios::sync_with_stdio(false); bfs(); while(cin&gt;&gt;raw1&gt;&gt;raw2)&#123; prechange(); //b[]为最终目标态 ll cnt=inv_cantor(b,maxl); cout&lt;&lt;ans[cnt]&lt;&lt;endl; &#125; &#125; 收获与反思 本题综合应用了数论里的康托展开（用于找到状态数和排列之间的联系），hash到相同情况讨论，以及BFS，值得深入考虑 关于康托展开 https://www.cnblogs.com/linyujun/p/5205760.html 大部分是通过这篇博客以及其他资料学习的，感谢原作者！ 公式为 X = a_n \times (n-1)! + a_{n-1} \times (n-2)! + \cdots + a_2 \times 1! + a_1 \times 0! 其中$a_n$表示第i个元素在未出现的元素中排列第几（从0开始） ，也可以理解成$a_n$表示该位的逆序数。 康托展开得到的X，就是该排列在全排列中的顺序（从0开始）。 逆展开就是循环除以(n-1)!，商为第n位在未出现元素排列第几（从0开始）。模为下一位的被除数。 在详细的等开个数论专题（挖坑）。]]></content>
      <categories>
        <category>编程</category>
        <category>ACM</category>
      </categories>
      <tags>
        <tag>算法</tag>
        <tag>ACM</tag>
        <tag>2018暑假集训</tag>
        <tag>BFS</tag>
        <tag>数论</tag>
        <tag>待补充</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[【AtCoder-4247】解题报告（水题）]]></title>
    <url>%2Fpost%2Ff0b23c5b.html</url>
    <content type="text"><![CDATA[原始题目B - 105 Time limit : 2sec / Memory limit : 1000MB Score: 200 points Problem StatementThe number 105 is quite special - it is odd but still it has eight divisors. Now, your task is this: how many odd numbers with exactly eight positive divisors are there between 1 and N (inclusive)? Constraints N is an integer between 1 and 200 (inclusive). InputInput is given from Standard Input in the following format: N OutputPrint the count. Sample Input 1105 Sample Output 11 Among the numbers between 1 and 105, the only number that is odd and has exactly eight divisors is 105. Sample Input 27 Sample Output 20 1 has one divisor. 3, 5 and 7 are all prime and have two divisors. Thus, there is no number that satisfies the condition. 题目大意给定n，求1到n恰好又8个因数的数字有多少个 集体思路 水题，预处理一下因子个数，再求一下前缀和就行。 解题代码123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960#include &lt;cstdio&gt;#include &lt;cstring&gt;#include &lt;cmath&gt;#include &lt;string&gt;#include &lt;iostream&gt;#include &lt;iomanip&gt;#include &lt;sstream&gt;#include &lt;set&gt;#include &lt;map&gt;#include &lt;queue&gt;#include &lt;vector&gt;#include &lt;bits/stdc++.h&gt;#define INF 0x3f3f3f3f#define eps 1e-8#define mp make_pair#define np next_permutation#define pb push_back#define all(x) (x.begin(),x.end())#define rep(i,a,n) for(int i=a;i&lt;n;++i)#define per(i,a,n) for(int i=n-1;i&gt;=a;--i) #define fi first#define se second using namespace std;const int maxn=1e4+5;const int maxl=26;typedef long long ll;typedef unsigned long long ull;typedef vector&lt;int&gt; vi;typedef pair&lt;int,int&gt; pii; int cnt[maxn],ans[maxn];void solve()&#123; rep(i,1,300) cnt[i]++; rep(i,2,300)&#123; for(int j=1;j*i&lt;=300;j++)&#123; cnt[i*j]++; &#125; &#125; int ccnt=0;ans[0]=0; rep(i,1,300) &#123; if(cnt[i]==8 and (i&amp;1))&#123; ans[i]=++ccnt; &#125; else ans[i]=ccnt; &#125; rep(i,1,300) &#123;// cout&lt;&lt;"ans["&lt;&lt;i&lt;&lt;"]="&lt;&lt;ans[i]&lt;&lt;endl; &#125;&#125; int a,b;int main()&#123; ios::sync_with_stdio(false); solve(); int n; while(cin&gt;&gt;n) cout&lt;&lt;ans[n]&lt;&lt;endl;&#125; 收获与反思无]]></content>
      <categories>
        <category>编程</category>
        <category>ACM</category>
      </categories>
      <tags>
        <tag>算法</tag>
        <tag>ACM</tag>
        <tag>AtCoder</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[【AtCoder-4242】解题报告（思维，水题）]]></title>
    <url>%2Fpost%2Fe769f01f.html</url>
    <content type="text"><![CDATA[原始题目C - To Infinity Time limit : 2sec / Memory limit : 1000MB Score: 300 points Problem StatementMr. Infinity has a string S consisting of digits from 1 to 9. Each time the date changes, this string changes as follows: Each occurrence of 2 in S is replaced with 22. Similarly, each 3 becomes 333, 4 becomes 4444, 5 becomes 55555, 6 becomes 666666, 7 becomes 7777777, 8 becomes 88888888 and 9 becomes 999999999. 1 remains as 1. For example, if S is 1324, it becomes 1333224444 the next day, and it becomes 133333333322224444444444444444 the day after next. You are interested in what the string looks like after $5 \times 10^{15}$ days. What is the K-th character from the left in the string after $5 \times 10^{15}$ days? Constraints S is a string of length between 1 and 100 (inclusive). K is an integer between 1 and $10^{18}$ (inclusive). The length of the string after $5 \times 10^{15}$ days is at least K. InputInput is given from Standard Input in the following format: S K OutputPrint the K-th character from the left in Mr. Infinity’s string after 5×1015 days. Sample Input 11214 4 Sample Output 12 The string S changes as follows: Now: 1214 After one day: 12214444 After two days: 1222214444444444444444 After three days: 12222222214444444444444444444444444444444444444444444444444444444444444444 The first five characters in the string after 5×1015 days is 12222. As K=4, we should print the fourth character, 2. Sample Input 23 157 Sample Output 23 The initial string is 3. The string after 5×1015 days consists only of 3. Sample Input 3299792458 9460730472580800 Sample Output 32 题目大意给定初始的一串数字，之后每一天每个数字会复制该数字次，比如’12223’，下一天变为’1222222333’，如此类推，问经过$5 \times 10^{15}$天后第k位数字是多少。 解题思路由于天数是固定的，而且很大，即便一位2经过5×1015，位数会变为$2^{5 \times 10^{15}}$ ，远超过 $10^{18}$所以只要判断第几位非1即可。 解题代码1234567891011121314151617181920212223242526272829303132333435363738394041424344454647#include &lt;cstdio&gt;#include &lt;cstring&gt;#include &lt;cmath&gt;#include &lt;string&gt;#include &lt;iostream&gt;#include &lt;iomanip&gt;#include &lt;sstream&gt;#include &lt;set&gt;#include &lt;map&gt;#include &lt;queue&gt;#include &lt;vector&gt;#include &lt;bits/stdc++.h&gt;#define INF 0x3f3f3f3f#define eps 1e-8#define mp make_pair#define np next_permutation#define pb push_back#define all(x) (x.begin(),x.end())#define rep(i,a,n) for(int i=a;i&lt;n;++i)#define per(i,a,n) for(int i=n-1;i&gt;=a;--i) #define fi first#define se second using namespace std;const int maxn=1e4+5;const int maxl=26;typedef long long ll;typedef unsigned long long ull;typedef vector&lt;int&gt; vi;typedef pair&lt;int,int&gt; pii;int main()&#123; ios::sync_with_stdio(false); string s; ull k; while(cin&gt;&gt;s&gt;&gt;k)&#123; int index=0; for(int i=0;i&lt;s.length();i++)&#123; if(s[i]!='1')&#123; index=i; break; &#125; &#125; if(k-1&lt;index) cout&lt;&lt;1&lt;&lt;endl; else cout&lt;&lt;s[index]&lt;&lt;endl; &#125;&#125; 收获与反思 思考一下即可，不过拓展应该是天数可变的时候，有机会找一下相关题再补吧。]]></content>
      <categories>
        <category>编程</category>
        <category>ACM</category>
      </categories>
      <tags>
        <tag>算法</tag>
        <tag>ACM</tag>
        <tag>AtCoder</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[【AtCoder-4244】解题报告（暴力，DP）]]></title>
    <url>%2Fpost%2F1448d9c8.html</url>
    <content type="text"><![CDATA[原始题目D - AtCoder Express 2 Time limit : 3sec / Memory limit : 1000MB Score: 400 points Problem StatementIn Takahashi Kingdom, there is a east-west railroad and N cities along it, numbered 1, 2, 3, …, N from west to east. A company called AtCoder Express possesses M trains, and the train i runs from City Li to City Ri (it is possible that Li=Ri). Takahashi the king is interested in the following Q matters: The number of the trains that runs strictly within the section from City pi to City qi, that is, the number of trains j such that pi≤Lj and Rj≤qi. Although he is genius, this is too much data to process by himself. Find the answer for each of these Q queries to help him. Constraints N is an integer between 1 and 500 (inclusive). M is an integer between 1 and 200 000 (inclusive). Q is an integer between 1 and 100 000 (inclusive). 1≤Li≤Ri≤N (1≤i≤M) 1≤pi≤qi≤N (1≤i≤Q) InputInput is given from Standard Input in the following format: N M Q L1 R1 L2 R2 : LM RM p1 q1 p2 q2 : pQ qQ OutputPrint Q lines. The i-th line should contain the number of the trains that runs strictly within the section from City pi to City qi. Sample Input 12 3 1 1 1 1 2 2 2 1 2 Sample Output 13 As all the trains runs within the section from City 1 to City 2, the answer to the only query is 3. Sample Input 210 3 2 1 5 2 8 7 10 1 7 3 10 Sample Output 21 1 The first query is on the section from City 1 to 7. There is only one train that runs strictly within that section: Train 1. The second query is on the section from City 3 to 10. There is only one train that runs strictly within that section: Train 3. Sample Input 310 10 10 1 6 2 9 4 5 4 7 4 7 5 8 6 6 6 7 7 9 10 10 1 8 1 9 1 10 2 8 2 9 2 10 3 8 3 9 3 10 1 10 Sample Output 37 9 10 6 8 9 6 7 8 10 题目大意在一条东西向的铁路上有 $1,2,3 \cdots N$ 个城市，列车公司有$M$列火车，每列火车从$L_i$行驶到 $R_i( L_i \le R_i)$，现在有$Q$个询问每次询问$p_i,q_i$ 两个城市间有多少躺列车的行驶路程恰好再在两城市之间（包括端点）。 解题思路 暴力：由于只需要计数，那么以每个城市为集合，统计该城市出发的列车的行使距离，对于每次询问，遍历pi到qi城市的集合判断距离是否小于终点到遍历点的距离即可。 DP： 把列车行驶看作线段，很明显大的线段包含小的线段。由此联想可以由内向外扩展，考虑DP 以终点作为集合，元素为起始点，预处理后对每个集合排序（代码实际应用vector而非set，因为set不支持迭代器随机访问而且可能会有重复线路） $dp[i][j]$表示从i城市到j城市包含的火车线路。 则状态转移方程为$dp[i][j]=dp[i][j-1]+num[i][j]$ ，$num[i][j]$表示到达j城市且起点不在i城市之前的列车线路数。 求$num[i][j]$，用二分查找lower_bound找到j城市集合中第一个大于等于i的位置，$num[i][j]$即为size减去前缀。 预处理后直接可以输出答案 解题代码 暴力 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364656667686970#include &lt;cstdio&gt;#include &lt;cstring&gt;#include &lt;cmath&gt;#include &lt;string&gt;#include &lt;iostream&gt;#include &lt;iomanip&gt;#include &lt;sstream&gt;#include &lt;set&gt;#include &lt;map&gt;#include &lt;queue&gt;#include &lt;vector&gt;#include &lt;bits/stdc++.h&gt;#define INF 0x3f3f3f3f#define eps 1e-8#define mp make_pair#define np next_permutation#define pb push_back#define all(x) (x.begin(),x.end())#define rep(i,a,n) for(int i=a;i&lt;n;++i)#define per(i,a,n) for(int i=n-1;i&gt;=a;--i)using namespace std; const int maxn=500+5;vector &lt;int&gt; v[maxn]; bool vis[maxn]; void init()&#123; rep(i,0,maxn) v[i].clear(); memset(vis,0,sizeof(vis));&#125; void addedge(int l,int r)&#123; int len=r-l; v[l].pb(len);&#125; int checkedge(int l,int len)&#123;// if(v[l].begin()!=v[l].end()) // cout&lt;&lt;*v[l].begin()&lt;&lt;endl; int ans=upper_bound(v[l].begin(),v[l].end(),len)-v[l].begin();// cout&lt;&lt;"ans="&lt;&lt;ans&lt;&lt;endl; return ans;&#125;int n,m,q,li,ri,pi,qi; int main()&#123; ios::sync_with_stdio(false); while(cin&gt;&gt;n&gt;&gt;m&gt;&gt;q)&#123; init(); rep(i,0,m)&#123; cin&gt;&gt;li&gt;&gt;ri; addedge(li,ri); vis[li]=1; &#125; rep(i,0,maxn)&#123; if(vis[i]) sort(v[i].begin(),v[i].end()); &#125; rep(i,0,q)&#123; cin&gt;&gt;pi&gt;&gt;qi; int cnt=0; for(int i=pi;i&lt;=qi;i++)&#123; int plen=qi-i;// cout&lt;&lt;"plen="&lt;&lt;plen&lt;&lt;endl; cnt+=checkedge(i,plen); &#125; cout&lt;&lt;cnt&lt;&lt;endl; &#125; &#125; &#125; DP 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354#include &lt;cstdio&gt;#include &lt;cstring&gt;#include &lt;cmath&gt;#include &lt;string&gt;#include &lt;iostream&gt;#include &lt;iomanip&gt;#include &lt;sstream&gt;#include &lt;set&gt;#include &lt;map&gt;#include &lt;queue&gt;#include &lt;vector&gt;#include &lt;bits/stdc++.h&gt;#define INF 0x3f3f3f3f#define eps 1e-8#define mp make_pair#define np next_permutation#define pb push_back#define all(x) x.begin(),x.end()#define rep(i,a,n) for(int i=a;i&lt;n;++i)#define per(i,a,n) for(int i=n-1;i&gt;=a;--i)using namespace std; const int maxn=500+5;typedef long long ll;typedef vector&lt;int&gt; vi;typedef pair&lt;int,int&gt; pii; vi v[maxn];int dp[maxn][maxn];int n,m,q,li,ri,pi,qi;void solve()&#123; rep(i,1,n+1) sort(v[i].begin(),v[i].end()); memset(dp,0,sizeof(dp)); rep(l,1,n+1)&#123; for(int r=l;r&lt;=n;r++)&#123; dp[l][r]=dp[l][r-1];// if(r-1&lt;l) continue; dp[l][r]+=(v[r].size()-(lower_bound(v[r].begin(),v[r].end(),l)-v[r].begin())); &#125; &#125;&#125;int main()&#123; ios::sync_with_stdio(false); while(cin&gt;&gt;n&gt;&gt;m&gt;&gt;q)&#123; rep(i,0,m)&#123; cin&gt;&gt;li&gt;&gt;ri; v[ri].pb(li); &#125; solve(); rep(i,0,q)&#123; cin&gt;&gt;pi&gt;&gt;qi; cout&lt;&lt;dp[pi][qi]&lt;&lt;endl; &#125; &#125;&#125; 收获与反思 脑子里别老想着暴力，有重复计算又没有修改为什么不考虑记忆化搜索？不考虑DP？思维训练还不够 很明显的时间差异。]]></content>
      <categories>
        <category>编程</category>
        <category>ACM</category>
      </categories>
      <tags>
        <tag>算法</tag>
        <tag>ACM</tag>
        <tag>AtCoder</tag>
        <tag>DP</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[【AtCoder-4245】解题报告（水题）]]></title>
    <url>%2Fpost%2Ff3d9c661.html</url>
    <content type="text"><![CDATA[原始题目A - Garden Time limit : 2sec / Memory limit : 1000MB Score: 100 points Problem StatementThere is a farm whose length and width are A yard and B yard, respectively. A farmer, John, made a vertical road and a horizontal road inside the farm from one border to another, as shown below: (The gray part represents the roads.)What is the area of this yard excluding the roads? Find it. NoteIt can be proved that the positions of the roads do not affect the area. Constraints A is an integer between 2 and 100 (inclusive). B is an integer between 2 and 100 (inclusive). InputInput is given from Standard Input in the following format: A B OutputPrint the area of this yard excluding the roads (in square yards). Sample Input 12 2 Sample Output 11 In this case, the area is 1 square yard. Sample Input 25 7 Sample Output 224 In this case, the area is 24 square yards. 题目大意一个矩形哇横纵两条宽度为1的道路，问剩下的面积 解题思路小学计算题，秒之 解题代码12345678910111213141516171819202122232425262728293031323334353637#include &lt;cstdio&gt;#include &lt;cstring&gt;#include &lt;cmath&gt;#include &lt;string&gt;#include &lt;iostream&gt;#include &lt;iomanip&gt;#include &lt;sstream&gt;#include &lt;set&gt;#include &lt;map&gt;#include &lt;queue&gt;#include &lt;vector&gt;#include &lt;bits/stdc++.h&gt;#define INF 0x3f3f3f3f#define eps 1e-8#define mp make_pair#define np next_permutation#define pb push_back#define all(x) (x.begin(),x.end())#define rep(i,a,n) for(int i=a;i&lt;n;++i)#define per(i,a,n) for(int i=n-1;i&gt;=a;--i)#define ms(x,a) memset((x),a,sizeof(x))#define fi first#define se secondusing namespace std;const int maxn=1e5+5;const int maxl=26;typedef long long ll;typedef unsigned long long ull;typedef vector&lt;int&gt; vi;typedef pair&lt;int,int&gt; pii;int a,b;int main()&#123; while(cin&gt;&gt;a&gt;&gt;b) cout&lt;&lt;a*b-a-b+1&lt;&lt;endl;&#125; 收获与反思无]]></content>
      <categories>
        <category>编程</category>
        <category>ACM</category>
      </categories>
      <tags>
        <tag>算法</tag>
        <tag>ACM</tag>
        <tag>AtCoder</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[密码技术学习——《图解密码技术》笔记（一）]]></title>
    <url>%2Fpost%2F4b15f9e3.html</url>
    <content type="text"><![CDATA[第3章 对称密码（共享密钥密码）——用相同的密钥进行加密和解密一次性密码本——绝对不会被破译的密码原理： 将明文与一串随机的比特序列进行XOR运算。 完全随机，密钥空间是所有可能的01组合，所以就算破译成功了，我们也无法判断它是正确的明文。比如正确明文是code，但破译会出现从aaaa到zzzz，其中不乏有意义的book，cook等“疑似明文”，由于是完全随机带来的密钥空间有全部可能，我们无法判断真正的明文是什么。 理论上无法破译 不过这样密钥的传送也成了问题，假设我们能够安全的传送密钥，那本身这个方法可以用来安全传递我们的消息了，所以现实中除了特工配送密钥完成元首热线通话以外，一次性密码本没有很高的应用价值。 DESFeistel网络的一轮，右侧直接向下变为输出，右侧与轮密钥XOR生成左侧。 多轮操作，每轮反转左右。 解密就是重复过程（两次XOR抵消从而得到这一轮前的输入）。 三重DES如名，不过是DES加密-&gt;DES解密-&gt;DES加密（由IBM公司提出，用来兼容普通DES，比如三层都是同样的DES密钥，就是普通DES了） 解密过程为DES解密-&gt;DES加密-&gt;DES解密 目前在银行等机构还在使用，但处理速度不高，除了特别重视向下兼容性的情况以外，很少被用于新的用途。 AES取代DES在2000成为新的标准，选定的算法名为Rijndael RijndaelRijndael算法也是由多个轮构成的，其中每一轮分为SubBytes（逐字节替换）、ShiftRows（平移行）、MixColumns（混合列）、AddRoundKey（与轮密钥进行XOR）共四个不中。DES使用Feistel网络作为基本结构，而Rijndael使用SPN结构。 加密：SubBytes -&gt; ShiftRows -&gt; MixColumns -&gt; AddRoundKey 解密：AddRoundKey -&gt; InvMixColumns -&gt; InvShiftRows -&gt; InvSubBytes 破译：由于其过程可以由数学公式来表达，那么理论上可以通过数学运算来求解，意味着Rigndael能够通过数学方法进行破译。不过现在为止还没有出现针对Rigndael的有效攻击。 第4章 分组密码的模式——分组密码是如何迭代的 模式总结表格 模式名称优点缺点备注 ECB模式Electronic CodeBook 电子密码本模式简单快速支持并行计算（加密、解密）明文中的重复排列会反映在密文中通过删除、替换密文分组可以对明文进行操作对包含某些比特错误的密文进行解密时，对应的分组会出错不能抵御重放攻击 不应使用 CBC模式Cipher Block Chaining 密文分组链接模式明文的重复排列不会反映在密文中支持并行计算（仅解密）能够解密任意密文分组对包含某些错误比特的密文进行解密时，第一个分组的全部比特以及后一个分组的相应比特会出错加密不支持并行计算CRYPTREC推荐《实用密码学》推荐 CFB模式Cipher-FeedBack 密文反馈模式不需要填充（padding）支持并行计算（仅解密）能够解密任意密文分组对包含某些错误比特的密文进行解密时，第一个分组的相应比特以及后一个分组的全部比特会出错加密不支持并行计算不能抵御重放攻击CRYPTREC推荐 OFB模式Output-FeedBack 输出反馈模式不需要填充（padding）可事先进行加密、解密的准备加密、解密使用相同结构对包含某些错误比特的密文进行解密时，只有明文中相应的比特会出错不支持并行计算主动攻击者反转密文分组中的某些比特时，明文分组中相对应的比特也会被反转CRYPTREC推荐 CTR模式CounTeR 计数器模式不需要填充（padding）可实现进行加密、解密的准备加密、解密使用相同的结构对包含某些错误比特的密文进行解密时，只有明文中相对应的比特会出错支持并行计算（加密、解密）主动攻击者反转密文分组中的某些比特时，明文分组中相对应的比特也会被反转CRYPTREC推荐《实用密码学》推荐 第5章 公钥密码——用公钥加密，用私钥解密密钥配送问题 通过事先共享密钥来解决（部分场景不现实） 通过密钥分配中心来解决（中心负担大，被破坏代价大风险高） 通过Diffie-Hellman密钥交换来解决（第11章） 通过公钥密码来解决（本章后续） 公钥密码一些特征 发送者只需要加密密钥 接收者只需要解密密钥 解密密钥不可以被窃听者获取 加密密钥被窃听者获取也没问题 无法解决的问题 解决了密钥配送问题，但是无门需要判断所得到的公钥是否正确合法，这个问题被称为公钥认证问题（后面章节）。 速度是对称密的几百分之一，解决方法后面会讲到。 时钟运算补充一些数论知识 除法：在模12的条件下两个数相乘为1，“类倒数”。可以发现规律，和12的最大公约数为1的数（5，7，11），即于12互质的数，存在倒数。 乘方：可以先模再乘，应用同余的性质。 对数：时钟运算中对数成为离散对数。能快速求出离散对数的算法到现在还没有被发现，Diffie-Hellman密钥交换协议以及ElGamal公钥算法中就运用了离散对数。 RSA]]></content>
      <categories>
        <category>编程</category>
        <category>密码技术</category>
      </categories>
      <tags>
        <tag>密码技术</tag>
        <tag>图解密码技术</tag>
        <tag>结城浩</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[《银河帝国8：我，机器人》读书笔记]]></title>
    <url>%2Fpost%2F7ef8a98f.html</url>
    <content type="text"><![CDATA[内容摘录机器人学三大法则 机器人不得伤害人类，或因不作为而使人类受到伤害。 除非违背第一法则，机器人必须服从人类的命令。 在不违背第一及第二法则的情况下，机器人必须保护自己。 第五篇 骗子！ P115 “‘你们的教科书里什么也没有；你们的科学知识一堆搜集来的数据，靠临时的理论粘在一起——而且全都简单到不可思议，简直真不值得我浪费时间。让我感兴趣的是你们的小说。你们会研究人类的动机以及情感的互动关系……’” P132 “厄比身子抵住了墙壁，双腿跪了下来。‘停止！’他尖叫道，‘关上你的心灵！它充满了痛苦、挫折和恨意！我不是故意的，我不骗你！我试图帮助你们，我把你们想听的话告诉你们。我不得不这样做！’” 第六篇 消失无踪 P143 “‘凯文博士，我们要么就是必须舍弃机器人，要么就是对第一法则做些修改——结果我们选择了后者。’……‘并没有取消它，只是作些修改。’寇纳尔解释道，‘这样制成的正子脑，仅含有第一法则的积极部分，也就是：机器人不得伤害人类，到此为止。不再有强迫性的要求，要他们防止外在因素伤害人类，比方说伽马射线。我这样说正确吧，玻格特博士?’” P152 “机器人心理学家说：‘假如修订型机器人从某人上方抛下一个重物，只要他在这样做的时候，明白自己具有足够的力量和反应速度，能在重物砸到那人之前将它抓走，他就不会违反第一法则。然而一旦重物离手，他就不再是主动的媒介，起作用的只剩下盲目的重力。然后那机器人久能改变心意，只要他不作为，就能让重物砸下去。修订后的第一法则允许这个行动。’” 第七篇 逃避！ P200 “接下来就很明显，那项资料进入它的计算机制后，产生了控制恒星际跃迁最短时段的方程式——这意味着人的死亡。统一公司的机器会完全崩溃，正是由于这个原因。但我已将死亡的严重性贬低——并非整个取消，因为第一法则永远无法违反——刚好足以让金头脑能对这个方程式多看一眼；足以给它时间去了解，这段时期过后，那些人会起死回生——正如太空船中的物质和能量会重新出现。换句话说，这个所谓的‘死亡’绝对只是暂时现象。你们懂了吗？”]]></content>
      <categories>
        <category>阅读</category>
      </categories>
      <tags>
        <tag>阅读</tag>
        <tag>小说</tag>
        <tag>艾萨克·阿西莫夫</tag>
        <tag>银河帝国</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[【HDU-2222】解题报告（AC自动机）]]></title>
    <url>%2Fpost%2Fd899bd9.html</url>
    <content type="text"></content>
      <categories>
        <category>编程</category>
        <category>ACM</category>
      </categories>
  </entry>
  <entry>
    <title><![CDATA[【CSU-2056】解题报告（思维，KMP，去0）]]></title>
    <url>%2Fpost%2F448da703.html</url>
    <content type="text"><![CDATA[原始题目2056: a simple game Time Limit: 1 Sec Memory Limit: 128 Mb Submitted: 412 Solved: 73 Description这一天，小A和小B在玩一个游戏，他俩每人都有一个整数，然后两人轮流对他们的整数进行操作，每次在下列两个操作任选一个： （1）对整数进行翻转，如1234翻转成4321 ，1200翻转成21 （2）将整数除以10，如1234/10=123，1/10=0 当操作过程中出现a==b时，则小A就赢了，而操作一直进行下去或不能使a==b则算小B赢。 现在小A求助于你，想让你帮他在知道两人的整数时小A能不能赢，假设每次都是小A先手，并且两人都是采取最优策略 Input首先输入$ T (T \le 100)$，表示有T组数据，然后接下来有$T$行，每行有两个整数$a,b ( 0 \le a,b &lt; 10100000)$。 Output有$T$行，当小A赢了则输出”Yes”,否则输出”No” Sample Input4 1234 123 123 321 1234 12345 123 123 Sample OutputYes Yes No Yes HintSourceAuthorwsf 题目大意如题 解题思路 如果将A，B的整数看作字符串，那两种操作就是反转，去尾。 两人都采取最优策略，考虑小A什么时候输，即B可以无限翻转而A永远不能将自己的串通过两种操作达到B字符串的状态。 那么当B的串或B反转后的串是A的子串时，A就是必赢的 考虑一些特殊情况。 由于末尾0的存在会在反转中自动去掉，所以要提前预处理一下，把末尾0去掉 正方各一次KMP即可。 解题代码123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293//#include &lt;bits/stdc++.h&gt;#include &lt;cstdio&gt; #include &lt;cstring&gt;#include &lt;cstdlib&gt;#include &lt;iostream&gt;#include &lt;iomanip&gt;#include &lt;string&gt;#include &lt;map&gt;#include &lt;set&gt;#include &lt;algorithm&gt;#include &lt;queue&gt;#include &lt;vector&gt;#define pb push_back#define mp make_pairusing namespace std;typedef long long LL;typedef pair&lt;int,int&gt; PII;#define PI acos((double)-1)#define E exp(double(1))#define K 1000000+9#define rep(i,a,n) for(int i=a;i&lt;n;i++)#define per(i,a,n) for(int i=n-1;i&gt;=a;i--)#define ms(x,a) memset((x),(a),sizeof(a))const int maxn=1e6+5;int nt[maxn],nt2[maxn] ;char a[maxn],b[maxn],b2[maxn];int n,m;//参数为模板串和next数组//字符串均从下标0开始void kmpGetNext(char *s,int *Next)&#123; Next[0]=0; int len=strlen(s); for(int i=1,j=0;i&lt;len;i++) &#123; while(j&amp;&amp;s[i]!=s[j]) j=Next[j]; if(s[i]==s[j]) j++; Next[i+1]=j; &#125;// Next[len]=0;&#125;int kmp(char *ss,char *s,int *Next)&#123; kmpGetNext(s,Next);// 调试输出Next数组// int len=strlen(s);// for(int i=0;i&lt;=len;i++)// cout&lt;&lt;Next[i]&lt;&lt;" ";// cout&lt;&lt;endl; int ans=0; int len1=strlen(ss); int len2=strlen(s); for(int i=0,j=0;i&lt;len1;i++) &#123; while(j&amp;&amp;ss[i]!=s[j])j=Next[j]; if(ss[i]==s[j]) j++; if(j==len2)&#123; return 1; &#125; &#125; return 0;// return ans;&#125;int main(void)&#123;// ios::sync_with_stdio(false); int t; scanf("%d",&amp;t); while(t--) &#123; memset(nt,0,sizeof(nt)); memset(nt2,0,sizeof(nt2)); scanf("%s",a); scanf("%s",b); int len1=strlen(a); int len2=strlen(b); while (a[len1-1] == '0'&amp;&amp;len1 &gt; 1) a[--len1] = '\0'; while (b[len2-1] == '0'&amp;&amp;len2 &gt; 1) b[--len2] = '\0'; rep(i,0,len2) b2[i]=b[len2-1-i]; b2[len2]='\0'; // printf("b1= %s\nb2= %s\n",b,b2); if(kmp(a,b,nt)||kmp(a,b2,nt2)) printf("Yes\n"); else printf("No\n"); &#125; return 0;&#125; 收获与反思 思维+KMP]]></content>
      <categories>
        <category>编程</category>
        <category>ACM</category>
      </categories>
      <tags>
        <tag>算法</tag>
        <tag>ACM</tag>
        <tag>CSU</tag>
        <tag>2018暑假集训</tag>
        <tag>KMP</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[【HDU-3746】解题报告（KMP，循环节）]]></title>
    <url>%2Fpost%2Fbb7f8e97.html</url>
    <content type="text"><![CDATA[原始题目Cyclic Nacklace Time Limit: 2000/1000 MS (Java/Others) Memory Limit: 32768/32768 K (Java/Others) Total Submission(s): 14437 Accepted Submission(s): 6022 Problem DescriptionCC always becomes very depressed at the end of this month, he has checked his credit card yesterday, without any surprise, there are only 99.9 yuan left. he is too distressed and thinking about how to tide over the last days. Being inspired by the entrepreneurial spirit of “HDU CakeMan”, he wants to sell some little things to make money. Of course, this is not an easy task. As Christmas is around the corner, Boys are busy in choosing christmas presents to send to their girlfriends. It is believed that chain bracelet is a good choice. However, Things are not always so simple, as is known to everyone, girl’s fond of the colorful decoration to make bracelet appears vivid and lively, meanwhile they want to display their mature side as college students. after CC understands the girls demands, he intends to sell the chain bracelet called CharmBracelet. The CharmBracelet is made up with colorful pearls to show girls’ lively, and the most important thing is that it must be connected by a cyclic chain which means the color of pearls are cyclic connected from the left to right. And the cyclic count must be more than one. If you connect the leftmost pearl and the rightmost pearl of such chain, you can make a CharmBracelet. Just like the pictrue below, this CharmBracelet’s cycle is 9 and its cyclic count is 2: Now CC has brought in some ordinary bracelet chains, he wants to buy minimum number of pearls to make CharmBracelets so that he can save more money. but when remaking the bracelet, he can only add color pearls to the left end and right end of the chain, that is to say, adding to the middle is forbidden. CC is satisfied with his ideas and ask you for help. InputThe first line of the input is a single integer $T ( 0 &lt; T \le 100 )$ which means the number of test cases. Each test case contains only one line describe the original ordinary chain to be remade. Each character in the string stands for one pearl and there are 26 kinds of pearls being described by ‘a’ ~’z’ characters. The length of the string $Len$: $( 3 \le Len \le 100000 )$. OutputFor each case, you are required to output the minimum count of pearls added to make a CharmBracelet. Sample Input3 aaa abca abcde Sample Output0 2 5 Authorpossessor WC SourceHDU 3rd “Vegetable-Birds Cup” Programming Open Contest Recommendlcy 题目大意有一个手环，由不同珠子构成，若要让他成为一个“魅力手环”需要使手环由大于等于两个，完全相同的首尾相接的子串构成。问需要补充多少珠子使手环变为魅力手环。 解题思路 求循环节以及判断是否完全循环，求差值 解题代码1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465666768697071727374757677787980818283848586878889//#include &lt;bits/stdc++.h&gt;#include &lt;cstdio&gt; #include &lt;cstring&gt;#include &lt;cstdlib&gt;#include &lt;iostream&gt;#include &lt;iomanip&gt;#include &lt;string&gt;#include &lt;map&gt;#include &lt;set&gt;#include &lt;algorithm&gt;#include &lt;queue&gt;#include &lt;vector&gt;#define pb push_back#define mp make_pairusing namespace std;typedef long long LL;typedef pair&lt;int,int&gt; PII;#define PI acos((double)-1)#define E exp(double(1))#define K 1000000+9#define rep(i,a,n) for(int i=a;i&lt;n;i++)#define per(i,a,n) for(int i=n-1;i&gt;=a;i--)#define ms(x,a) memset((x),(a),sizeof(a))const int maxn=1e6+5; int nt[maxn];char a[maxn],b[maxn];int n;//参数为模板串和next数组//字符串均从下标0开始void kmpGetNext(char *s,int *Next)&#123; Next[0]=0; int len=strlen(s); for(int i=1,j=0;i&lt;len;i++) &#123; while(j&amp;&amp;s[i]!=s[j]) j=Next[j]; if(s[i]==s[j]) j++; Next[i+1]=j; &#125;// Next[len]=0;&#125;int kmp(char *ss,char *s,int *Next)&#123; kmpGetNext(s,Next);// 调试输出Next数组// int len=strlen(s);// for(int i=0;i&lt;=n;i++)// cout&lt;&lt;Next[i]&lt;&lt;" ";// cout&lt;&lt;endl; // int ans=0;// int len1=strlen(ss);// int len2=strlen(s); for(int i=0,j=0;i&lt;2*n;i++) //倍长 &#123; while(j&amp;&amp;ss[i%n]!=s[j])j=Next[j]; if(ss[i%n]==s[j]) j++; if(j==n)&#123; return 1; &#125; &#125; return 0;&#125;int main(void)&#123; int t; scanf("%d",&amp;t); while(t--)&#123; scanf("%s",a); memset(nt,0,sizeof(nt)); n=strlen(a); kmpGetNext(a,nt); int ans; int k = n-nt[n];//循环节大小 if(k == n) //不循环，补充相同一串 ans = n; else if(n % k == 0) //完全循环，不需要补充 ans = 0; else //补充剩下的 ans = k - (n % k); printf("%d\n",ans); // cout&lt;&lt;endl; &#125; &#125; 收获与反思 对于KMP循环节的问题 $n-nt[n]$求得最长循环节的大小（可能是自身） $n%(n-nt[n])$求剩下的尾巴大小（可用来判断是不是完全循环）]]></content>
      <categories>
        <category>编程</category>
        <category>ACM</category>
      </categories>
      <tags>
        <tag>算法</tag>
        <tag>ACM</tag>
        <tag>2018暑假集训</tag>
        <tag>KMP</tag>
        <tag>HDU</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[【HDU-1686】解题报告（KMP）]]></title>
    <url>%2Fpost%2F6501181e.html</url>
    <content type="text"><![CDATA[原始题目Oulipo Time Limit: 3000/1000 MS (Java/Others) Memory Limit: 32768/32768 K (Java/Others) Total Submission(s): 21478 Accepted Submission(s): 8336 Problem DescriptionThe French author Georges Perec (1936–1982) once wrote a book, La disparition, without the letter ‘e’. He was a member of the Oulipo group. A quote from the book: Tout avait Pair normal, mais tout s’affirmait faux. Tout avait Fair normal, d’abord, puis surgissait l’inhumain, l’affolant. Il aurait voulu savoir où s’articulait l’association qui l’unissait au roman : stir son tapis, assaillant à tout instant son imagination, l’intuition d’un tabou, la vision d’un mal obscur, d’un quoi vacant, d’un non-dit : la vision, l’avision d’un oubli commandant tout, où s’abolissait la raison : tout avait l’air normal mais… Perec would probably have scored high (or rather, low) in the following contest. People are asked to write a perhaps even meaningful text on some subject with as few occurrences of a given “word” as possible. Our task is to provide the jury with a program that counts these occurrences, in order to obtain a ranking of the competitors. These competitors often write very long texts with nonsense meaning; a sequence of 500,000 consecutive ‘T’s is not unusual. And they never use spaces. So we want to quickly find out how often a word, i.e., a given string, occurs in a text. More formally: given the alphabet {‘A’, ‘B’, ‘C’, …, ‘Z’} and two finite strings over that alphabet, a word W and a text T, count the number of occurrences of W in T. All the consecutive characters of W must exactly match consecutive characters of T. Occurrences may overlap. InputThe first line of the input file contains a single number: the number of test cases to follow. Each test case has the following format: One line with the word W, a string over {‘A’, ‘B’, ‘C’, …, ‘Z’}, with 1 ≤ |W| ≤ 10,000 (here |W| denotes the length of the string W). One line with the text T, a string over {‘A’, ‘B’, ‘C’, …, ‘Z’}, with |W| ≤ |T| ≤ 1,000,000. OutputFor every test case in the input file, the output should contain a single number, on a single line: the number of occurrences of the word W in the text T. Sample Input3 BAPC BAPC AZA AZAZAZA VERDI AVERDXIVYERDIAN Sample Output1 3 0 Source华东区大学生程序设计邀请赛_热身赛 Recommendlcy 题目大意 计算T中W的出现次数，W的所有连续字符必须与T的连续字符完全匹配，可能重叠。 解题思路 裸KMP 解题代码123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081//#include &lt;bits/stdc++.h&gt;#include &lt;cstdio&gt; #include &lt;cstring&gt;#include &lt;cstdlib&gt;#include &lt;iostream&gt;#include &lt;iomanip&gt;#include &lt;string&gt;#include &lt;map&gt;#include &lt;set&gt;#include &lt;algorithm&gt;#include &lt;queue&gt;#include &lt;vector&gt;#define pb push_back#define mp make_pairusing namespace std;typedef long long LL;typedef pair&lt;int,int&gt; PII;#define PI acos((double)-1)#define E exp(double(1))#define K 1000000+9#define rep(i,a,n) for(int i=a;i&lt;n;i++)#define per(i,a,n) for(int i=n-1;i&gt;=a;i--)#define ms(x,a) memset((x),(a),sizeof(a))int nt[10006];char a[K],b[10005];int n,m;//参数为模板串和next数组//字符串均从下标0开始void kmpGetNext(char *s,int *Next)&#123; Next[0]=0; int len=strlen(s); for(int i=1,j=0;i&lt;len;i++) &#123; while(j&amp;&amp;s[i]!=s[j]) j=Next[j]; if(s[i]==s[j]) j++; Next[i+1]=j; &#125;// Next[len]=0;&#125;int kmp(char *ss,char *s,int *Next)&#123; kmpGetNext(s,Next);// 调试输出Next数组// int len=strlen(s);// for(int i=0;i&lt;=len;i++)// cout&lt;&lt;Next[i]&lt;&lt;" ";// cout&lt;&lt;endl; int ans=0; int len1=strlen(ss); int len2=strlen(s); for(int i=0,j=0;i&lt;len1;i++) &#123; while(j&amp;&amp;ss[i]!=s[j])j=Next[j]; if(ss[i]==s[j]) j++; if(j==len2)&#123; ans++;// return i-len2+2; &#125; &#125;// return -1; return ans;&#125;int main(void)&#123; int t; scanf("%d",&amp;t); while(t--) &#123; memset(a,0,sizeof(a)); memset(b,0,sizeof(b)); scanf("%s",b); scanf("%s",a); cout&lt;&lt; kmp(a,b,nt)&lt;&lt;endl; &#125; return 0;&#125; 收获与反思 KMP水题]]></content>
      <categories>
        <category>编程</category>
        <category>ACM</category>
      </categories>
      <tags>
        <tag>算法</tag>
        <tag>ACM</tag>
        <tag>2018暑假集训</tag>
        <tag>KMP</tag>
        <tag>HDU</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[【HDU-1358】解题报告（KMP，循环节）]]></title>
    <url>%2Fpost%2F3a3eaae1.html</url>
    <content type="text"></content>
      <categories>
        <category>编程</category>
        <category>ACM</category>
      </categories>
  </entry>
  <entry>
    <title><![CDATA[【HDU-2087】解题报告（KMP，去重）]]></title>
    <url>%2Fpost%2Fc5672df5.html</url>
    <content type="text"><![CDATA[原始题目剪花布条 Time Limit: 1000/1000 MS (Java/Others) Memory Limit: 32768/32768 K (Java/Others) Total Submission(s): 28902 Accepted Submission(s): 17700 Problem Description一块花布条，里面有些图案，另有一块直接可用的小饰条，里面也有一些图案。对于给定的花布条和小饰条，计算一下能从花布条中尽可能剪出几块小饰条来呢？ Input输入中含有一些数据，分别是成对出现的花布条和小饰条，其布条都是用可见ASCII字符表示的，可见的ASCII字符有多少个，布条的花纹也有多少种花样。花纹条和小饰条不会超过1000个字符长。如果遇见#字符，则不再进行工作。 Output输出能从花纹布中剪出的最多小饰条个数，如果一块都没有，那就老老实实输出0，每个结果之间应换行。 Sample Inputabcde a3 aaaaaa aa # Sample Output0 3 Authorqianneng Source冬练三九之二 Recommendlcy 题目大意如题 解题思路 模板加一句$Next[len]=0$，去重即可。 解题代码12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364656667686970717273747576777879808182//#include &lt;bits/stdc++.h&gt;#include &lt;cstdio&gt; #include &lt;cstring&gt;#include &lt;cstdlib&gt;#include &lt;iostream&gt;#include &lt;iomanip&gt;#include &lt;string&gt;#include &lt;map&gt;#include &lt;set&gt;#include &lt;algorithm&gt;#include &lt;queue&gt;#include &lt;vector&gt;#define pb push_back#define mp make_pairusing namespace std;typedef long long LL;typedef pair&lt;int,int&gt; PII;#define PI acos((double)-1)#define E exp(double(1))#define K 1000000+9#define rep(i,a,n) for(int i=a;i&lt;n;i++)#define per(i,a,n) for(int i=n-1;i&gt;=a;i--)#define ms(x,a) memset((x),(a),sizeof(a))int nt[10006];char a[K],b[10005];int n,m;//参数为模板串和next数组//字符串均从下标0开始void kmpGetNext(char *s,int *Next)&#123; Next[0]=0; int len=strlen(s); for(int i=1,j=0;i&lt;len;i++) &#123; while(j&amp;&amp;s[i]!=s[j]) j=Next[j]; if(s[i]==s[j]) j++; Next[i+1]=j; &#125;// Next[len]=0;&#125;int kmp(char *ss,char *s,int *Next)&#123; kmpGetNext(s,Next);// 调试输出Next数组// int len=strlen(s);// for(int i=0;i&lt;=len;i++)// cout&lt;&lt;Next[i]&lt;&lt;" ";// cout&lt;&lt;endl; int ans=0; int len1=strlen(ss); int len2=strlen(s); for(int i=0,j=0;i&lt;len1;i++) &#123; while(j&amp;&amp;ss[i]!=s[j])j=Next[j]; if(ss[i]==s[j]) j++; if(j==len2)&#123; ans++;// return i-len2+2; &#125; &#125;// return -1; return ans;&#125;int main(void)&#123;// ios::sync_with_stdio(false); int t; scanf("%d",&amp;t); while(t--) &#123; memset(a,0,sizeof(a)); memset(b,0,sizeof(b)); scanf("%s",a); scanf("%s",b); cout&lt;&lt; kmp(a,b,nt)&lt;&lt;endl; &#125; return 0;&#125; 收获与反思 KMP水题]]></content>
      <categories>
        <category>编程</category>
        <category>ACM</category>
      </categories>
      <tags>
        <tag>算法</tag>
        <tag>ACM</tag>
        <tag>2018暑假集训</tag>
        <tag>KMP</tag>
        <tag>HDU</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[【CSU-1598】解题报告（KMP）]]></title>
    <url>%2Fpost%2F9a9a4797.html</url>
    <content type="text"><![CDATA[原始题目1598: 最长公共前缀 Time Limit: 1 Sec Memory Limit: 128 Mb Submitted: 222 Solved: 186 Description给定两个字符串$s$和$t$，现有一个扫描器，从$s$的最左边开始向右扫描，每次扫描到一个$t$就把这一段删除，输出能发现$t$的个数。 Input第一行包含一个整数$ T ( T \le 50)$ ，表示数据组数。每组数据第一行包含一个字符串$s$，第二行一个字符串$t$，字符串长度不超过$1000000$。 Output对于每组数据，输出答案。 Sample Input2 ababab ab ababab ba Sample Output 3 2 HintSource国防科学技术大学第十八届银河之光文化节ACM程序设计竞赛初赛 题目大意如题 解题思路 加一个$Next[m]=0$即匹配完成后删除这一段（去重） 不过这个题目水，不加也过了 解题代码12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364656667686970717273747576777879808182//#include &lt;bits/stdc++.h&gt;#include &lt;cstdio&gt; #include &lt;cstring&gt;#include &lt;cstdlib&gt;#include &lt;iostream&gt;#include &lt;iomanip&gt;#include &lt;string&gt;#include &lt;map&gt;#include &lt;set&gt;#include &lt;algorithm&gt;#include &lt;queue&gt;#include &lt;vector&gt;#define pb push_back#define mp make_pairusing namespace std;typedef long long LL;typedef pair&lt;int,int&gt; PII;#define PI acos((double)-1)#define E exp(double(1))#define K 1000000+9#define rep(i,a,n) for(int i=a;i&lt;n;i++)#define per(i,a,n) for(int i=n-1;i&gt;=a;i--)#define ms(x,a) memset((x),(a),sizeof(a))int nt[10006];char a[K],b[10005];int n,m;//参数为模板串和next数组//字符串均从下标0开始void kmpGetNext(char *s,int *Next)&#123; Next[0]=0; int len=strlen(s); for(int i=1,j=0;i&lt;len;i++) &#123; while(j&amp;&amp;s[i]!=s[j]) j=Next[j]; if(s[i]==s[j]) j++; Next[i+1]=j; &#125; Next[len]=0;&#125;int kmp(char *ss,char *s,int *Next)&#123; kmpGetNext(s,Next);// 调试输出Next数组// int len=strlen(s);// for(int i=0;i&lt;=len;i++)// cout&lt;&lt;Next[i]&lt;&lt;" ";// cout&lt;&lt;endl; int ans=0; int len1=strlen(ss); int len2=strlen(s); for(int i=0,j=0;i&lt;len1;i++) &#123; while(j&amp;&amp;ss[i]!=s[j])j=Next[j]; if(ss[i]==s[j]) j++; if(j==len2)&#123; ans++;// return i-len2+2; &#125; &#125;// return -1; return ans;&#125;int main(void)&#123;// ios::sync_with_stdio(false); int t; scanf("%d",&amp;t); while(t--) &#123; memset(a,0,sizeof(a)); memset(b,0,sizeof(b)); scanf("%s",a); scanf("%s",b); cout&lt;&lt; kmp(a,b,nt)&lt;&lt;endl; &#125; return 0;&#125; 收获与反思 KMP水题]]></content>
      <categories>
        <category>编程</category>
        <category>ACM</category>
      </categories>
      <tags>
        <tag>算法</tag>
        <tag>ACM</tag>
        <tag>CSU</tag>
        <tag>2018暑假集训</tag>
        <tag>KMP</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[【CSU-1581】解题报告（思维，KMP）]]></title>
    <url>%2Fpost%2F742966af.html</url>
    <content type="text"><![CDATA[原始题目Problem H: Clock Pictures1581: Clock Pictures Time Limit: 3 Sec Memory Limit: 128 Mb Submitted: 322 Solved: 82 DescriptionYou have two pictures of an unusual kind of clock. The clock has n hands, each having the same length and no kind of marking whatsoever. Also, the numbers on the clock are so faded that you can’t even tell anymore what direction is up in the picture. So the only thing that you see on the pictures, are n shades of the n hands, and nothing else. You’d like to know if both images might have been taken at exactly the same time of the day, possibly with the camera rotated at different angles. Given the description of the two images, determine whether it is possible that these two pictures could be showing the same clock displaying the same time. InputThe ﬁrst line contains a single integer $n$ $(2 ≤ n ≤ 200 000)$, the number of hands on the clock. Each of the next two lines contains n integers $a_i$ $(0 ≤ a_i &lt; 360 000)$,representing the angles of the hands of the clock on one of the images,in thousandths of a degree. The ﬁrst line represents the position of the hands on the ﬁrst image, whereas the second line corresponds to the second image. The number $a_i$ denotes the angle between the recorded position of some hand and the upward direction in the image, measured clockwise. Angles of the same clock are distinct and are not given in any speciﬁc order. OutputOutput one line containing one word: possible if the clocks could be showing the same time,impossible otherwise. Sample Input6 1 2 3 4 5 6 7 6 5 4 3 1 Sample Outputimpossible HINT题目大意 一个有$n$个指针的表盘，看不清数字，以随机顺序给出n个指针相对记录位置（不固定）的顺时针旋转角度，问两个表盘经过旋转是否能够重合（是否表示一个表盘）。 解题思路 对于相同表盘，记录位置不固定，但是两个指针间的角度差固定，判断位移后可不可以相同。 注意第一个指针和末尾指针的角度差需要补3600000 将一组倍长做KMP可以解决这个问题，若位移后可以相同，那么倍长后2倍距离必包含另一串。 解题代码12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364656667686970717273747576777879808182838485868788899091929394//#include &lt;bits/stdc++.h&gt;#include &lt;cstdio&gt;#include &lt;cstring&gt;#include &lt;cstdlib&gt;#include &lt;iostream&gt;#include &lt;iomanip&gt;#include &lt;string&gt;#include &lt;map&gt;#include &lt;set&gt;#include &lt;algorithm&gt;#include &lt;queue&gt;#include &lt;vector&gt;#define pb push_back#define mp make_pairusing namespace std;typedef long long LL;typedef pair&lt;int,int&gt; PII;#define PI acos((double)-1)#define E exp(double(1))#define K 1000000+9#define rep(i,a,n) for(int i=a;i&lt;n;i++)#define per(i,a,n) for(int i=n-1;i&gt;=a;i--)#define ms(x,a) memset((x),(a),sizeof(a))const int maxn=2e5+5; int nt[maxn];int aa[maxn],bb[maxn];int a[maxn],b[maxn];int n;//参数为模板串和next数组//字符串均从下标0开始void kmpGetNext(int *s,int *Next)&#123; Next[0]=0;// int len=strlen(s); for(int i=1,j=0;i&lt;n;i++) &#123; while(j&amp;&amp;s[i]!=s[j]) j=Next[j]; if(s[i]==s[j]) j++; Next[i+1]=j; &#125;// Next[len]=0;&#125;int kmp(int *ss,int *s,int *Next)&#123; kmpGetNext(s,Next);// 调试输出Next数组// int len=strlen(s);// for(int i=0;i&lt;=n;i++)// cout&lt;&lt;Next[i]&lt;&lt;" ";// cout&lt;&lt;endl; // int ans=0;// int len1=strlen(ss);// int len2=strlen(s); for(int i=0,j=0;i&lt;2*n;i++) //倍长 &#123; while(j&amp;&amp;ss[i%n]!=s[j])j=Next[j]; if(ss[i%n]==s[j]) j++; if(j==n)&#123; return 1; &#125; &#125; return 0;&#125;int main(void)&#123; ios::sync_with_stdio(false); while(cin&gt;&gt;n) &#123; memset(a,0,sizeof(a)); memset(b,0,sizeof(b)); rep(i,0,n) cin&gt;&gt;aa[i]; rep(i,0,n) cin&gt;&gt;bb[i]; sort(aa,aa+n); sort(bb,bb+n); rep(i,0,n-1)&#123; a[i]=aa[i+1]-aa[i]; b[i]=bb[i+1]-bb[i]; &#125; a[n-1]=360000+aa[0]-aa[n-1];// rep(i,0,n) cout&lt;&lt;a[i]&lt;&lt;" ";// cout&lt;&lt;endl; b[n-1]=360000+bb[0]-bb[n-1];// rep(i,0,n) cout&lt;&lt;b[i]&lt;&lt;" ";// cout&lt;&lt;endl; if(kmp(a,b,nt)) cout&lt;&lt;"possible"&lt;&lt;endl; else cout&lt;&lt;"impossible"&lt;&lt;endl; &#125; return 0;&#125; 收获与反思 仔细读题，分析题目 倍长KMP可以判断自身位移的情况。]]></content>
      <categories>
        <category>编程</category>
        <category>ACM</category>
      </categories>
      <tags>
        <tag>算法</tag>
        <tag>ACM</tag>
        <tag>CSU</tag>
        <tag>2018暑假集训</tag>
        <tag>KMP</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[【HDU-6373】解题报告（物理力学，模拟，2018杭电多校第六场）]]></title>
    <url>%2Fpost%2Fd73de254.html</url>
    <content type="text"><![CDATA[原始题目Pinball Time Limit: 2000/1000 MS (Java/Others) Memory Limit: 262144/262144 K (Java/Others) Total Submission(s): 604 Accepted Submission(s): 264 Problem DescriptionThere is a slope on the 2D plane. The lowest point of the slope is at the origin. There is a small ball falling down above the slope. Your task is to find how many times the ball has been bounced on the slope. It’s guarantee that the ball will not reach the slope or ground or Y-axis with a distance of less than 1 from the origin. And the ball is elastic collision without energy loss. Gravity acceleration $g=9.8m/s^2$. InputThere are multiple test cases. The first line of input contains an integer T (1 ≤ T ≤ 100), indicating the number of test cases. The first line of each test case contains four integers a, b, x, y (1 ≤ a, b, -x, y ≤ 100), indicate that the slope will pass through the point(-a, b), the initial position of the ball is (x, y). OutputOutput the answer. It’s guarantee that the answer will not exceed 50. Sample Input1 5 1 -5 3 Sample Output2 Source2018 Multi-University Training Contest 6 Recommendchendu 题目大意 给定一个从原点向一个方向延长的斜板，以及初始小球的坐标，重力加速度。求能在斜板上弹跳几次（不考虑能量损失） 解题思路 物理题，把运动分解成沿板方向和垂直于板的方向的分运动，求出沿板子运动的时间$t1$，垂直于板子运动的（每一次上升/下降）的时间$t2$。 考虑一下，当$(2n+1)t2 \lebs t1 &lt; (2(n+1)+1)t2 $ 时，n即为答案 解题代码12345678910111213141516171819202122232425262728293031323334353637383940#include &lt;bits/stdc++.h&gt;#include &lt;cstdio&gt;#include &lt;cmath&gt;#include &lt;cstdlib&gt;#include &lt;cstring&gt;#include &lt;iostream&gt;#include &lt;set&gt;#include &lt;iomanip&gt;#include &lt;algorithm&gt;#include &lt;queue&gt;#include &lt;map&gt;#include &lt;string&gt;#define INF 0x3f3f3f3f#define rep(i,a,n) for(int i=a;i&lt;n;i++)#define per(i,a,n) for(int i=n-1;i&gt;=a;i--)#define ms(x,a) memset((x),(a),sizeof(a))using namespace std;const int maxn=1e5+5;int n,m,t;double a,b,x,y;void solve()&#123; double alfa=atan(b/a); double y1=(y-x*tan(alfa))*cos(alfa); double x1=y*sin(alfa)+x*cos(alfa);// cout&lt;&lt;y1&lt;&lt;" "&lt;&lt;x1&lt;&lt;endl; int n=floor(sqrt(x1/y1*a/b)); cout&lt;&lt;(n+1)/2&lt;&lt;endl;&#125;int main()&#123; ios::sync_with_stdio(false); cin&gt;&gt;t; while(t--)&#123; cin&gt;&gt;a&gt;&gt;b&gt;&gt;x&gt;&gt;y; x=-x; solve(); &#125;&#125; 收获与反思 分运动看时间比判断，队友想出来的= =。]]></content>
      <categories>
        <category>编程</category>
        <category>ACM</category>
      </categories>
      <tags>
        <tag>算法</tag>
        <tag>ACM</tag>
        <tag>2018暑假集训</tag>
        <tag>HDU</tag>
        <tag>2018杭电多校</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[【HDU-6362】解题报告（数学，积分，2018杭电多校第六场）]]></title>
    <url>%2Fpost%2Fb3ee770c.html</url>
    <content type="text"><![CDATA[原始题目oval-and-rectangle Time Limit: 2000/1000 MS (Java/Others) Memory Limit: 32768/32768 K (Java/Others) Total Submission(s): 647 Accepted Submission(s): 310 Problem DescriptionPatrick Star find an oval. The half of longer axes is on the x-axis with length $a$. The half of shorter axes is on the y-axis with length $b$. Patrick Star plan to choose a real number c randomly from $[0,b]$, after that, Patrick Star will get a rectangle : The four vertexes of it are on the outline of the oval. The two sides of it parallel to coordinate axis. One of its side is $y=c$. Patrick Star want to know the expectations of the rectangle’s perimeter. InputThe first line contain a integer $T$ (no morn than 10), the following is $T$ test case, for each test case : Each line contains contains two integer $a, b (0&lt;b&lt;a&lt;105)$. Separated by an white space. OutputFor each test case output one line denotes the expectations of the rectangle’s perimeter . You should keep exactly 6 decimal digits and ignore the remain decimal digits. It is guaranted that the 7-th decimal digit of answer wont be 0 or 9. Sample Input1 2 1 Sample Output8.283185 Source2018 Multi-University Training Contest 6 Recommendchendu 题目大意 椭圆半长轴为$a$，半短轴为$b$，从区间$[0,b]$随机抽实数$c$，求过$(0,c)$点的与椭圆内切，四边与坐标轴平行的长方形周长 解题思路 是个积分题，不过直接用积分函数计算到制定精度会T（没错我就这么T了一发） 手动算一下 最后除以b得到答案 注意要求不四舍五入，精度应该输出$ans-0.0000005$ 解题代码12345678910111213141516171819202122232425262728293031#include &lt;bits/stdc++.h&gt;#include &lt;cstdio&gt;#include &lt;cmath&gt;#include &lt;cstdlib&gt;#include &lt;cstring&gt;#include &lt;iostream&gt;#include &lt;set&gt;#include &lt;iomanip&gt;#include &lt;algorithm&gt;#include &lt;queue&gt;#include &lt;map&gt;#include &lt;string&gt;#define INF 0x3f3f3f3f#define rep(i,a,n) for(int i=a;i&lt;n;i++)#define per(i,a,n) for(int i=n-1;i&gt;=a;i--)#define ms(x,a) memset((x),(a),sizeof(a))using namespace std;const int maxn=1e5+5;#define PI acos(-1.0)int n,m,t;int a,b;int main()&#123; ios::sync_with_stdio(false); cin&gt;&gt;t; while(t--)&#123; cin&gt;&gt;a&gt;&gt;b; double ans=a*PI+2*b; cout&lt;&lt;fixed&lt;&lt;setprecision(6)&lt;&lt;ans-0.0000005&lt;&lt;endl; &#125;&#125; 收获与反思 高数教做人系列]]></content>
      <categories>
        <category>编程</category>
        <category>ACM</category>
      </categories>
      <tags>
        <tag>算法</tag>
        <tag>ACM</tag>
        <tag>2018暑假集训</tag>
        <tag>HDU</tag>
        <tag>2018杭电多校</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[【UVALive-3942】解题报告（字典树，dp）]]></title>
    <url>%2Fpost%2Ff279299a.html</url>
    <content type="text"><![CDATA[原始题目 题目大意 给定一个文本串和n个字符串，用这n个字符串组合成文本串有多少种可能。 解题思路 先将n个字符串储存到字典树里。 考虑DP $dp[i]$表示前i位字符进行第一次分割的可能数目 i从len-1-&gt;0逆序遍历，j从i到len-1遍历。 只要遍历j时遇到染色结点，表明可以在此再分割一次，由此推出状态转移方程。$dp[i] = (dp[i] + dp[j + 1]) % mod$ 解题代码123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145#include &lt;cstdio&gt;#include &lt;cstring&gt;#include &lt;iostream&gt;#include &lt;cstdlib&gt;#include &lt;set&gt;#include &lt;string&gt;#include &lt;cstring&gt;#include &lt;stack&gt;#define rep(i,a,n) for(int i=a;i&lt;n;i++)#define per(i,a,n) for(int i=n-1;i&gt;=a;i--)#define ms(x,a) memset((x),(a),sizeof(x))using namespace std;const int maxn=3e5+5;const int maxl=26;const int mod=20071027;typedef long long ll;typedef struct Trie&#123; int v; Trie* next[maxl];&#125;Trie; Trie *root;void iniTrie()&#123; root=(Trie*)malloc(sizeof(Trie)); for(int i=0;i&lt;maxl;i++) root-&gt;next[i]=NULL; root-&gt;v=-1;&#125;void creTrie(char* a)&#123; int l=strlen(a); Trie *p=root,*q; for(int i=0;i&lt;l;i++) &#123; int id=a[i]-'a'; //并非前缀不能有相同，而是不能在相同的分支上。 if(p-&gt;next[id]!=NULL) &#123; p=p-&gt;next[id]; if(i==l-1)&#123; p-&gt;v=1; return; &#125; &#125; else&#123; q=(Trie*)malloc(sizeof(Trie)); q-&gt;v=0; for(int j=0;j&lt;maxl;j++) q-&gt;next[j]=NULL; p-&gt;next[id]=q; p=p-&gt;next[id]; if(i==l-1)&#123; p-&gt;v=1; return; &#125; &#125; &#125;&#125;bool findTrie(string b)&#123; Trie *p=root; int l=b.length(); for(int i=0;i&lt;l;i++)&#123; int index=b[i]-'a'; if(p-&gt;next[index]!=NULL) p=p-&gt;next[index]; else return false; &#125; return p-&gt;v;&#125;void delTrie(Trie *p) &#123; int i; for(i=0;i&lt;maxl;i++) &#123; if(p-&gt;next[i] != NULL) delTrie(p-&gt;next[i]); &#125; free(p);// printf("1"); p==NULL; return ;&#125; int n,kase;int dp[maxn];char raw[maxn],s[1000];int Dp(char *s, int len) &#123; dp[len] = 1; for (int i = len - 1; i &gt;= 0; --i) &#123; Trie *pp = root;//根节点 for (int j = i; j &lt; len; ++j) &#123; int temp = s[j]-'a'; //cout &lt;&lt; s[j] &lt;&lt; endl; if (pp-&gt;next[temp] == NULL) &#123;//同dfs退出原理 break; &#125; pp = pp-&gt;next[temp]; if (pp-&gt;v == true) &#123; dp[i] = (dp[i] + dp[j + 1]) % mod;//更新方案数 //cout &lt;&lt; j + 1 &lt;&lt; " " &lt;&lt; len &lt;&lt; endl; &#125; &#125; dp[i] %= mod; &#125; return dp[0]; &#125;void solve()&#123; int ans=0; int len=strlen(raw); ms(dp,0); ans=Dp(raw,len); cout &lt;&lt; "Case " &lt;&lt; ++kase &lt;&lt; ": "; cout&lt;&lt;ans&lt;&lt;endl; &#125;int main()&#123;// freopen("in.txt", "r", stdin); ios::sync_with_stdio(false); while(cin&gt;&gt;raw)&#123; iniTrie(); cin&gt;&gt;n; rep(i,0,n)&#123; cin&gt;&gt;s; creTrie(s); &#125; solve(); delTrie(root); &#125;&#125; 收获与反思 字典树与dp结合 记忆化，dp的思想很重要！]]></content>
      <categories>
        <category>编程</category>
        <category>ACM</category>
      </categories>
      <tags>
        <tag>算法</tag>
        <tag>ACM</tag>
        <tag>DP</tag>
        <tag>2018暑假集训</tag>
        <tag>字典树</tag>
        <tag>UVALive</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[【CSU-1216】解题报告（01字典树，异或最大值）]]></title>
    <url>%2Fpost%2F16fa37a4.html</url>
    <content type="text"><![CDATA[原始题目1216: 异或最大值 Time Limit: 2 Sec Memory Limit: 128 Mb Submitted: 1282 Solved: 460 Description给定一些数，求这些数中两个数的异或值最大的那个值 Input多组数据。第一行为数字个数$n (1 \le n \le 10 ^ 5)$。接下来$n$行每行一个32位有符号非负整数。 Output任意两数最大异或值 Sample Input3 3 7 9 Sample Output14 HintSourceCSGrandeur的数据结构习题 题目大意如题 解题思路 和HDU-4825都是求异或最大值，裸的01字典树 正解： 每个数用二进制数表示，用32位的0、1数组（高位在前）储存到01字典树中。 对于每次询问q，将q也表示成01串，从高位到低位每次贪心的顺着字典树向下找相反的结点（0找1，1找0），因为这样可以保证让两个数的异或值尽可能地大（所以一定要从高位向下找）。 解题代码123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129#include &lt;cstdio&gt;#include &lt;cstring&gt;#include &lt;iostream&gt;#include &lt;cstdlib&gt;#include &lt;set&gt;#include &lt;string&gt;#include &lt;cstring&gt;#include &lt;stack&gt;#define rep(i,a,n) for(int i=a;i&lt;n;i++)#define per(i,a,n) for(int i=n-1;i&gt;=a;i--)#define ms(x,a) memset((x),(a),sizeof(a))#define L 32using namespace std;const int maxn=1e5+5;const int maxl=2;typedef long long ll;typedef struct Trie&#123; int v; Trie* next[maxl];&#125;Trie; Trie *root;void iniTrie()&#123; root=(Trie*)malloc(sizeof(Trie)); for(int i=0;i&lt;maxl;i++) root-&gt;next[i]=NULL; root-&gt;v=-1;&#125;void creTrie(int a)&#123; int temp[35]; int id=L-1; while(a)&#123; temp[id--]=(a&amp;1); a/=2; &#125; rep(i,0,id+1) temp[i]=0;// rep(i,0,L) cout&lt;&lt;temp[i];// cout&lt;&lt;endl&lt;&lt;endl; int l=L; Trie *p=root,*q; for(int i=0;i&lt;l;i++) &#123; int id=temp[i]; //并非前缀不能有相同，而是不能在相同的分支上。 if(p-&gt;next[id]!=NULL) &#123; p=p-&gt;next[id];// p-&gt;v++; &#125; else&#123; q=(Trie*)malloc(sizeof(Trie)); q-&gt;v=1; for(int j=0;j&lt;maxl;j++) q-&gt;next[j]=NULL; p-&gt;next[id]=q; p=p-&gt;next[id]; &#125; &#125;&#125;int findTrie(int a)&#123; int aa=a; int temp[35]; int id=L-1; while(a)&#123; temp[id--]=(a&amp;1); a/=2; &#125;// cout&lt;&lt;"#"&lt;&lt;a&lt;&lt;endl; rep(i,0,id+1) temp[i]=0; int aans=0; Trie *p=root; int l=L; for(int i=0;i&lt;l;i++)&#123; int index=!temp[i];// cout&lt;&lt;"index="&lt;&lt;index&lt;&lt;endl; if(p-&gt;next[index]!=NULL)&#123; aans=(aans&lt;&lt;1)+index; p=p-&gt;next[index]; &#125; else&#123; aans=(aans&lt;&lt;1)+temp[i]; p=p-&gt;next[temp[i]]; &#125; &#125; return aans^aa;&#125;void delTrie(Trie *p) &#123; int i; for(i=0;i&lt;maxl;i++) &#123; if(p-&gt;next[i] != NULL) delTrie(p-&gt;next[i]); &#125; free(p);// printf("1"); p==NULL; return ;&#125; int a[maxn],n;int main()&#123; ios::sync_with_stdio(false); while(cin&gt;&gt;n)&#123; iniTrie(); rep(i,0,n)&#123; cin&gt;&gt;a[i]; creTrie(a[i]); &#125; int fans=0; rep(i,0,n)&#123; fans=max(fans,findTrie(a[i])); &#125; cout&lt;&lt;fans&lt;&lt;endl; delTrie(root); &#125; &#125; 收获与反思 异或最大值可以考虑01字典树。]]></content>
      <categories>
        <category>编程</category>
        <category>ACM</category>
      </categories>
      <tags>
        <tag>算法</tag>
        <tag>ACM</tag>
        <tag>CSU</tag>
        <tag>2018暑假集训</tag>
        <tag>字典树</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[【HDU-4825】解题报告（01字典树，异或最大值）]]></title>
    <url>%2Fpost%2F6d52b9f2.html</url>
    <content type="text"><![CDATA[原始题目Xor Sum Time Limit: 2000/1000 MS (Java/Others) Memory Limit: 132768/132768 K (Java/Others) Total Submission(s): 4756 Accepted Submission(s): 2076 Problem DescriptionZeus 和 Prometheus 做了一个游戏，Prometheus 给 Zeus 一个集合，集合中包含了$N$个正整数，随后 Prometheus 将向 Zeus 发起$M$次询问，每次询问中包含一个正整数 $S$ ，之后 Zeus 需要在集合当中找出一个正整数 $K$ ，使得 $K$ 与 $S$ 的异或结果最大。Prometheus 为了让 Zeus 看到人类的伟大，随即同意 Zeus 可以向人类求助。你能证明人类的智慧么？ Input输入包含若干组测试数据，每组测试数据包含若干行。 输入的第一行是一个整数$ T(T &lt; 10)$，表示共有$T$组数据。 每组数据的第一行输入两个正整数$N,M( 1 &lt;\le N,M \le 100000)$，接下来一行，包含$N$个正整数，代表 Zeus 的获得的集合，之后$M$行，每行一个正整数$S$，代表 Prometheus 询问的正整数。所有正整数均不超过$2^{32}$。 Output对于每组数据，首先需要输出单独一行”Case #?:”，其中问号处应填入当前的数据组数，组数从1开始计算。 对于每个询问，输出一个正整数K，使得K与S异或值最大。 Sample Input2 3 2 3 4 5 1 5 4 1 4 6 5 6 3 Sample OutputCase #1: 4 3 Case #2: 4 Source2014年百度之星程序设计大赛 - 资格赛 Recommendliuyiding 题目大意如题 解题思路 直接找的话复杂度O（m*n），会T（本题显然不可能这么简单啊） 正解： 每个数用二进制数表示，用32位的0、1数组（高位在前）储存到01字典树中。 对于每次询问q，将q也表示成01串，从高位到低位每次贪心的顺着字典树向下找相反的结点（0找1，1找0），因为这样可以保证让两个数的异或值尽可能地大（所以一定要从高位向下找）。 解题代码123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135#include &lt;cstdio&gt;#include &lt;cstring&gt;#include &lt;iostream&gt;#include &lt;cstdlib&gt;#include &lt;set&gt;#include &lt;string&gt;#include &lt;cstring&gt;#include &lt;stack&gt;#define rep(i,a,n) for(int i=a;i&lt;n;i++)#define per(i,a,n) for(int i=n-1;i&gt;=a;i--)#define ms(x,a) memset((x),(a),sizeof(a))#define debugin freopen("in.txt","r",stdin)#define debugout freopen("out.txt","w",stdout)#define L 32using namespace std;const int maxn=1e5+5;const int maxl=2;typedef long long ll;typedef struct Trie&#123; int v; Trie* next[maxl];&#125;Trie; Trie *root;void iniTrie()&#123; root=(Trie*)malloc(sizeof(Trie)); for(int i=0;i&lt;maxl;i++) root-&gt;next[i]=NULL; root-&gt;v=-1;&#125;void creTrie(int a)&#123; int temp[35]; int id=L-1; while(a)&#123; temp[id--]=(a&amp;1); a/=2; &#125; rep(i,0,id+1) temp[i]=0;// rep(i,0,L) cout&lt;&lt;temp[i];// cout&lt;&lt;endl&lt;&lt;endl; int l=L; Trie *p=root,*q; for(int i=0;i&lt;l;i++) &#123; int id=temp[i]; //并非前缀不能有相同，而是不能在相同的分支上。 if(p-&gt;next[id]!=NULL) &#123; p=p-&gt;next[id];// p-&gt;v++; &#125; else&#123; q=(Trie*)malloc(sizeof(Trie)); q-&gt;v=1; for(int j=0;j&lt;maxl;j++) q-&gt;next[j]=NULL; p-&gt;next[id]=q; p=p-&gt;next[id]; &#125; &#125;&#125;int findTrie(int a)&#123;// int aa=a; int temp[35]; int id=L-1; while(a)&#123; temp[id--]=(a&amp;1); a/=2; &#125;// cout&lt;&lt;"#"&lt;&lt;a&lt;&lt;endl; rep(i,0,id+1) temp[i]=0; int aans=0; Trie *p=root; int l=L; for(int i=0;i&lt;l;i++)&#123; int index=!temp[i];// cout&lt;&lt;"index="&lt;&lt;index&lt;&lt;endl; if(p-&gt;next[index]!=NULL)&#123; aans=(aans&lt;&lt;1)+index; p=p-&gt;next[index]; &#125; else&#123; aans=(aans&lt;&lt;1)+temp[i]; p=p-&gt;next[temp[i]]; &#125; &#125; return aans; &#125;void delTrie(Trie *p) &#123; int i; for(i=0;i&lt;maxl;i++) &#123; if(p-&gt;next[i] != NULL) delTrie(p-&gt;next[i]); &#125; free(p);// printf("1"); p==NULL; return ;&#125; int a[maxn],n,t,m;int main()&#123; ios::sync_with_stdio(false);// debugin;// debugout; cin&gt;&gt;t; rep(l,1,t+1)&#123; cout&lt;&lt;"Case #"&lt;&lt;l&lt;&lt;":"&lt;&lt;endl; cin&gt;&gt;n&gt;&gt;m; //n树m询问 iniTrie(); rep(i,0,n)&#123; cin&gt;&gt;a[i]; creTrie(a[i]); &#125; rep(i,0,m)&#123; cin&gt;&gt;a[i]; cout&lt;&lt;findTrie(a[i])&lt;&lt;endl; &#125; delTrie(root); &#125; &#125; 收获与反思 异或最大值可以考虑01字典树。]]></content>
      <categories>
        <category>编程</category>
        <category>ACM</category>
      </categories>
      <tags>
        <tag>算法</tag>
        <tag>ACM</tag>
        <tag>2018暑假集训</tag>
        <tag>字典树</tag>
        <tag>HDU</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[【HDU-1251】解题报告（字典树）]]></title>
    <url>%2Fpost%2F585293b8.html</url>
    <content type="text"><![CDATA[原始题目统计难题 Time Limit: 4000/2000 MS (Java/Others) Memory Limit: 131070/65535 K (Java/Others) Total Submission(s): 55180 Accepted Submission(s): 19275 Problem DescriptionIgnatius最近遇到一个难题,老师交给他很多单词(只有小写字母组成,不会有重复的单词出现),现在老师要他统计出以某个字符串为前缀的单词数量(单词本身也是自己的前缀). Input输入数据的第一部分是一张单词表,每行一个单词,单词的长度不超过10,它们代表的是老师交给Ignatius统计的单词,一个空行代表单词表的结束.第二部分是一连串的提问,每行一个提问,每个提问都是一个字符串. 注意:本题只有一组测试数据,处理到文件结束. Output对于每个提问,给出以该字符串为前缀的单词的数量. Sample Inputbanana band bee absolute acm ba b band abc Sample Output2 3 1 0 AuthorIgnatius.L RecommendIgnatius.L 题目大意如题 解题思路 字典树裸题，建立字典树时每个单词每个结点权值++ 访问的时候不在树上输出0，在的话输出结尾结点的权值。 解题代码123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107#include &lt;cstdio&gt;#include &lt;cstring&gt;#include &lt;iostream&gt;#include &lt;cstdlib&gt;#include &lt;set&gt;#include &lt;string&gt;#include &lt;cstring&gt;#include &lt;stack&gt;using namespace std;const int maxn=1e5+5;const int maxl=26;typedef long long ll;typedef struct Trie&#123; int v; Trie* next[maxl];&#125;Trie; Trie *root;void iniTrie()&#123; root=(Trie*)malloc(sizeof(Trie)); for(int i=0;i&lt;maxl;i++) root-&gt;next[i]=NULL; root-&gt;v=-1;&#125;void creTrie(char* a)&#123; int l=strlen(a); Trie *p=root,*q; for(int i=0;i&lt;l;i++) &#123; int id=a[i]-'a'; //并非前缀不能有相同，而是不能在相同的分支上。 if(p-&gt;next[id]!=NULL) &#123; p=p-&gt;next[id]; p-&gt;v++; &#125; else&#123; q=(Trie*)malloc(sizeof(Trie)); q-&gt;v=1; for(int j=0;j&lt;maxl;j++) q-&gt;next[j]=NULL; p-&gt;next[id]=q; p=p-&gt;next[id]; &#125; &#125;&#125;//void printTrie()//&#123;// Trie* p=root;// stack&lt;Trie*&gt;s;// s.push(p);// while(!s.empty())// &#123;// Trie *now=s.top();// s.pop();// if(now-&gt;v==1) printf("%d\n",now-&gt;v);// for(int i=0;i&lt;maxl;i++)// if(now-&gt;next[i]!=NULL)// s.push(now-&gt;next[i]); // &#125;//&#125;int printTrie(char* b)&#123; Trie *p=root; int l=strlen(b); for(int i=0;i&lt;l;i++)&#123; int index=b[i]-'a'; if(p-&gt;next[index]!=NULL) p=p-&gt;next[index]; else&#123; return 0; &#125; &#125; return p-&gt;v;&#125;void delTrie(Trie *p) &#123; int i; for(i=0;i&lt;maxl;i++) &#123; if(p-&gt;next[i] != NULL) delTrie(p-&gt;next[i]); &#125; free(p);// printf("1"); p==NULL; return ;&#125; int t,ccount;int main()&#123; char a[20],c; iniTrie(); while(gets(a)&amp;&amp;a[0]!='\0') creTrie(a); while(~scanf("%s",a)) printf("%d\n",printTrie(a)); delTrie(root);&#125; 收获与反思 字典树裸题，注意建立的时候怎么打标记（染色）。]]></content>
      <categories>
        <category>编程</category>
        <category>ACM</category>
      </categories>
      <tags>
        <tag>算法</tag>
        <tag>ACM</tag>
        <tag>2018暑假集训</tag>
        <tag>字典树</tag>
        <tag>HDU</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[【POJ-1200】解题报告（字符串hash，进制）]]></title>
    <url>%2Fpost%2Fbc8586da.html</url>
    <content type="text"><![CDATA[原始题目Crazy Search Time Limit: 1000MS Memory Limit: 65536K Total Submissions: 32268 Accepted: 8900 DescriptionMany people like to solve hard puzzles some of which may lead them to madness. One such puzzle could be finding a hidden prime number in a given text. Such number could be the number of different substrings of a given size that exist in the text. As you soon will discover, you really need the help of a computer and a good algorithm to solve such a puzzle. Your task is to write a program that given the size, N, of the substring, the number of different characters that may occur in the text, NC, and the text itself, determines the number of different substrings of size N that appear in the text. As an example, consider N=3, NC=4 and the text “daababac”. The different substrings of size 3 that can be found in this text are: “daa”; “aab”; “aba”; “bab”; “bac”. Therefore, the answer should be 5. InputThe first line of input consists of two numbers, N and NC, separated by exactly one space. This is followed by the text where the search takes place. You may assume that the maximum number of substrings formed by the possible set of characters does not exceed 16 Millions. OutputThe program should output just an integer corresponding to the number of different substrings of size N found in the given text. Sample Input3 4 daababac Sample Output5 HintHuge input,scanf is recommended. SourceSouthwestern Europe 2002 题目大意 最多由nc种字符构成的原字符串，求长度为n的子串共有多少种。解题思路 字符串hash 由于最多不超过nc种字符，把每种字符映射到1到nc，字串即可看作类似nc进制的数（不含0） 用set或者vis数组维护一下记录不同数的个数即可。解题代码1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556//#include &lt;bits/stdc++.h&gt;#include &lt;cstdio&gt;#include &lt;cmath&gt;#include &lt;cstdlib&gt;#include &lt;cstring&gt;#include &lt;iostream&gt;#include &lt;set&gt;#include &lt;iomanip&gt;#include &lt;algorithm&gt;#include &lt;queue&gt;#include &lt;map&gt;#include &lt;string&gt;#define INF 0x3f3f3f3f#define rep(i,a,n) for(int i=a;i&lt;n;i++)#define per(i,a,n) for(int i=n-1;i&gt;=a;i--)#define ms(x,a) memset((x),(a),sizeof(a))using namespace std;const int maxn=1e5+5;#define PI acos(-1.0)typedef long long ll;typedef unsigned long long ull;int letter[300];char s[1000005];bool myhash[20000005];int n,nc;int main()&#123; ios::sync_with_stdio(false); while(cin&gt;&gt;n&gt;&gt;nc&gt;&gt;s)&#123; memset(letter,0,sizeof(letter)); memset(myhash,0,sizeof(myhash)); int len=strlen(s); int cnt=0; rep(i,0,len)&#123; if(!letter[s[i]]) &#123; letter[s[i]]=++cnt; if(cnt==nc) break; &#125; &#125; int ans=0; rep(i,0,len-n+1)&#123; int sum=0; for(int j=i;j&lt;i+n;j++)&#123; sum=sum*nc+letter[s[j]]; &#125; if(!myhash[sum])&#123;// cout&lt;&lt;"i="&lt;&lt;i&lt;&lt;endl; ans++; myhash[sum]=1; &#125; else continue; &#125; cout&lt;&lt;ans&lt;&lt;endl; &#125;&#125; 收获与反思 简单字符串hash，没有涉及取模操作]]></content>
      <categories>
        <category>编程</category>
        <category>ACM</category>
      </categories>
      <tags>
        <tag>算法</tag>
        <tag>ACM</tag>
        <tag>2018暑假集训</tag>
        <tag>字符串hash</tag>
        <tag>POJ</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[【HDU-1711】解题报告（KMP模板题，字符串hash）]]></title>
    <url>%2Fpost%2F531de0f8.html</url>
    <content type="text"><![CDATA[原始题目Number Sequence Time Limit: 10000/5000 MS (Java/Others) Memory Limit: 32768/32768 K (Java/Others) Total Submission(s): 39142 Accepted Submission(s): 16165 Problem DescriptionGiven two sequences of numbers : a[1], a[2], …… , a[N], and b[1], b[2], …… , b[M] (1 ≤ M ≤ 10000, 1 ≤ N ≤ 1000000). Your task is to find a number K which make a[K] = b[1], a[K + 1] = b[2], …… , a[K + M - 1] = b[M]. If there are more than one K exist, output the smallest one. InputThe first line of input is a number T which indicate the number of cases. Each case contains three lines. The first line is two numbers N and M (1 ≤ M ≤ 10000, 1 ≤ N ≤ 1000000). The second line contains N integers which indicate a[1], a[2], …… , a[N]. The third line contains M integers which indicate b[1], b[2], …… , b[M]. All integers are in the range of [-1000000, 1000000]. OutputFor each test case, you should output one line which only contain K described above. If no such K exists, output -1 instead. Sample Input2 13 5 1 2 1 2 3 1 2 3 1 3 2 1 2 1 2 3 1 3 13 5 1 2 1 2 3 1 2 3 1 3 2 1 2 1 2 3 2 1 Sample Output6 -1 SourceHDU 2007-Spring Programming Contest Recommendlcy 题目大意 给定一个数字串和一个模式串，输出最早匹配的位置，没有输出-1。 解题思路 KMP把字符匹配改成int即可。 解题代码123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869//#include &lt;bits/stdc++.h&gt;#include &lt;cstdio&gt; #include &lt;cstring&gt;#include &lt;cstdlib&gt;#include &lt;iostream&gt;#include &lt;iomanip&gt;#include &lt;string&gt;#include &lt;map&gt;#include &lt;set&gt;#include &lt;algorithm&gt;#include &lt;queue&gt;#include &lt;vector&gt;#define pb push_back#define mp make_pairusing namespace std;typedef long long LL;typedef pair&lt;int,int&gt; PII;#define PI acos((double)-1)#define E exp(double(1))#define K 1000000+9#define rep(i,a,n) for(int i=a;i&lt;n;i++)#define per(i,a,n) for(int i=n-1;i&gt;=a;i--)#define ms(x,a) memset((x),(a),sizeof(a))int nt[10006];int a[K],b[10005],n,m;//参数为模板串和next数组//字符串均从下标0开始void kmp_next(int *T,int *nt)&#123; nt[0]=0; for(int i=1,j=0;i&lt;m;i++) &#123; while(j&amp;&amp;T[i]!=T[j])j=nt[j-1]; if(T[i]==T[j])j++; nt[i]=j; &#125;&#125;int kmp(int *S,int *T,int *nt)&#123; kmp_next(T,nt); int ans=0; //n //m for(int i=0,j=0;i&lt;n;i++) &#123; while(j&amp;&amp;S[i]!=T[j])j=nt[j-1]; if(S[i]==T[j])j++; if(j==m)&#123;// ans++; return i-m+2; &#125; &#125; return -1;&#125;int main(void)&#123; ios::sync_with_stdio(false); int t;cin&gt;&gt;t; while(t--) &#123; cin&gt;&gt;n&gt;&gt;m; rep(i,0,n) cin&gt;&gt;a[i]; rep(i,0,m) cin&gt;&gt;b[i]; cout&lt;&lt; kmp(a,b,nt)&lt;&lt;endl; &#125; return 0;&#125;//1 2 1 2 3 1 2 3 1 3 2 1 2 3 1 2 3 收获与反思 单模匹配考虑KMP，熟悉模板和算法。]]></content>
      <categories>
        <category>编程</category>
        <category>ACM</category>
      </categories>
      <tags>
        <tag>算法</tag>
        <tag>ACM</tag>
        <tag>2018暑假集训</tag>
        <tag>KMP</tag>
        <tag>HDU</tag>
        <tag>字符串hash</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[【HDU-1224】解题报告（最长路，路径）]]></title>
    <url>%2Fpost%2Fcd18de84.html</url>
    <content type="text"><![CDATA[原始题目Free DIY Tour Time Limit: 2000/1000 MS (Java/Others) Memory Limit: 65536/32768 K (Java/Others) Total Submission(s): 8700 Accepted Submission(s): 2805 Problem DescriptionWeiwei is a software engineer of ShiningSoft. He has just excellently fulfilled a software project with his fellow workers. His boss is so satisfied with their job that he decide to provide them a free tour around the world. It’s a good chance to relax themselves. To most of them, it’s the first time to go abroad so they decide to make a collective tour. The tour company shows them a new kind of tour circuit - DIY circuit. Each circuit contains some cities which can be selected by tourists themselves. According to the company’s statistic, each city has its own interesting point. For instance, Paris has its interesting point of 90, New York has its interesting point of 70, ect. Not any two cities in the world have straight flight so the tour company provide a map to tell its tourists whether they can got a straight flight between any two cities on the map. In order to fly back, the company has made it impossible to make a circle-flight on the half way, using the cities on the map. That is, they marked each city on the map with one number, a city with higher number has no straight flight to a city with lower number. Note: Weiwei always starts from Hangzhou(in this problem, we assume Hangzhou is always the first city and also the last city, so we mark Hangzhou both 1 and N+1), and its interesting point is always 0. Now as the leader of the team, Weiwei wants to make a tour as interesting as possible. If you were Weiwei, how did you DIY it? InputThe input will contain several cases. The first line is an integer T which suggests the number of cases. Then T cases follows. Each case will begin with an integer N(2 ≤ N ≤ 100) which is the number of cities on the map. Then N integers follows, representing the interesting point list of the cities. And then it is an integer M followed by M pairs of integers [Ai, Bi] (1 ≤ i ≤ M). Each pair of [Ai, Bi] indicates that a straight flight is available from City Ai to City Bi. OutputFor each case, your task is to output the maximal summation of interesting points Weiwei and his fellow workers can get through optimal DIYing and the optimal circuit. The format is as the sample. You may assume that there is only one optimal circuit. Output a blank line between two cases. Sample Input2 3 0 70 90 4 1 2 1 3 2 4 3 4 3 0 90 70 4 1 2 1 3 2 4 3 4 Sample OutputCASE 1# points : 90 circuit : 1-&gt;3-&gt;1 CASE 2# points : 90 circuit : 1-&gt;2-&gt;1 AuthorJGShining（极光炫影） Source杭州电子科技大学第三届程序设计大赛 RecommendIgnatius.L 题目大意 自定义旅途路线，1和n+1结点权值为0，剩下结点权值给定，有向图，求最长路。 解题思路 改了一下Dijkstra最短路算法竟然A了。 解题代码123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108#include &lt;cstdio&gt;#include &lt;cstring&gt;#include &lt;string&gt;#include &lt;algorithm&gt;#include &lt;iostream&gt;#include &lt;stack&gt;#include &lt;set&gt;#include &lt;vector&gt;#include &lt;queue&gt;#include &lt;cmath&gt;#include &lt;cstdlib&gt;#include &lt;bits/stdc++.h&gt; using namespace std;#define eps 1e-8#define INF 0x3f3f3f3f#define rep(i,a,n) for(int i=a;i&lt;n;i++)#define per(i,a,n) for(int i=n-1;i&gt;=a;i--)#define all(x) x.begin(),x.end()#define pb push_back#define np next_permutation#define ms(x,a) memset((x),(a),sizeof(x))//优先队列迪杰斯特拉 const int maxn=1e5+5;struct Edge&#123; int u,v,w; Edge(int _u,int _v,int _w):u(_u),v(_v),w(_w)&#123; &#125;;&#125;;vector &lt;Edge&gt; edges[maxn];int dis[maxn],path[maxn],num[maxn],ans[maxn];bool vis[maxn];int n,m,uu,vv,ww,t;void init()&#123; //n个结点的边集都清空 rep(i,0,maxn)&#123; edges[i].clear(); &#125; ms(vis,0); ms(dis,-INF); ms(path,0); ms(num,0);&#125;void addEdge(int u,int v,int w)&#123; edges[u].pb(Edge(u,v,w));&#125;struct Node&#123; int Id,W; Node(int _Id,int _W):Id(_Id),W(_W)&#123; &#125;; bool operator &lt; (const Node &amp;b) const &#123;W&lt;b.W;&#125;&#125;;void Dijkstra(int s)&#123; priority_queue &lt;Node&gt; q; q.push(Node(s,0)) ,dis[s]=0; while(!q.empty())&#123; Node now=q.top(); q.pop(); int index=now.Id; if(dis[index]!=now.W) continue; rep(i,0,edges[index].size())&#123;// cout&lt;&lt;"dis="&lt;&lt;dis[edges[index][i].v]&lt;&lt;" new cost="&lt;&lt;dis[index]+edges[index][i].w; if(dis[edges[index][i].v]&lt;dis[index]+edges[index][i].w)&#123; dis[edges[index][i].v]=dis[index]+edges[index][i].w; q.push(Node(edges[index][i].v,dis[edges[index][i].v])); path[edges[index][i].v]=index;// cout&lt;&lt;" #"&lt;&lt; edges[index][i].v&lt;&lt;" #"&lt;&lt;index&lt;&lt;endl; &#125; &#125; &#125;&#125;int main()&#123;// freopen("in.txt","r",stdin); ios::sync_with_stdio(false); cin&gt;&gt;t; rep(T,1,t+1)&#123; if(T!=1) cout&lt;&lt;endl; cin&gt;&gt;n; init(); rep(i,1,n+1)&#123; cin&gt;&gt;num[i]; //输入点权值 &#125; cin&gt;&gt;m; rep(i,1,m+1)&#123; cin&gt;&gt;uu&gt;&gt;vv; addEdge(uu,vv,num[uu]); &#125; Dijkstra(1); //预处理路径 int cnt=0,ini=n+1; while(1)&#123; ans[cnt++]=ini; ini=path[ini]; if(ini==1) break; &#125; ans[cnt]=1; //输出 cout&lt;&lt;"CASE "&lt;&lt;T&lt;&lt;"#"&lt;&lt;endl&lt;&lt;"points : "&lt;&lt;dis[n+1]&lt;&lt;endl; cout&lt;&lt;"circuit : "; for(int i=cnt;i&gt;0;i--) cout&lt;&lt;ans[i]&lt;&lt;"-&gt;"; cout&lt;&lt;1&lt;&lt;endl; &#125; &#125; 收获与反思 需要研究一下Dij可否算最长路]]></content>
      <categories>
        <category>编程</category>
        <category>ACM</category>
      </categories>
      <tags>
        <tag>算法</tag>
        <tag>ACM</tag>
        <tag>Dijkstra</tag>
        <tag>HDU</tag>
        <tag>最长路</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[【HDU-2544】解题报告（最短路，dij）]]></title>
    <url>%2Fpost%2F34a049ac.html</url>
    <content type="text"><![CDATA[原始题目最短路 Time Limit: 5000/1000 MS (Java/Others) Memory Limit: 32768/32768 K (Java/Others) Total Submission(s): 88011 Accepted Submission(s): 38096 Problem Description在每年的校赛里，所有进入决赛的同学都会获得一件很漂亮的t-shirt。但是每当我们的工作人员把上百件的衣服从商店运回到赛场的时候，却是非常累的！所以现在他们想要寻找最短的从商店到赛场的路线，你可以帮助他们吗？ Input输入包括多组数据。每组数据第一行是两个整数N、M（N≤100，M≤10000），N表示成都的大街上有几个路口，标号为1的路口是商店所在地，标号为N的路口是赛场所在地，M则表示在成都有几条路。N=M=0表示输入结束。接下来M行，每行包括3个整数A，B，C（1≤A,B≤N,1≤C≤1000）,表示在路口A与路口B之间有一条路，我们的工作人员需要C分钟的时间走过这条路。输入保证至少存在1条商店到赛场的路线。 Output对于每组输入，输出一行，表示工作人员从商店走到赛场的最短时间 Sample Input2 1 1 2 3 3 3 1 2 5 2 3 5 3 1 2 0 0 Sample Output3 2 SourceUESTC 6th Programming Contest Online Recommendlcy 题目大意如题 解题思路 单源正权，Dijkstra最短路模板题 解题代码123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384#include &lt;cstdio&gt;#include &lt;cstring&gt;#include &lt;string&gt;#include &lt;algorithm&gt;#include &lt;iostream&gt;#include &lt;stack&gt;#include &lt;set&gt;#include &lt;vector&gt;#include &lt;queue&gt;#include &lt;cmath&gt;#include &lt;cstdlib&gt;#include &lt;bits/stdc++.h&gt; using namespace std;#define eps 1e-8#define INF 0x3f3f3f3f#define rep(i,a,n) for(int i=a;i&lt;n;i++)#define per(i,a,n) for(int i=n-1;i&gt;=a;i--)#define all(x) x.begin(),x.end()#define pb push_back#define np next_permutation#define ms(x,a) memset((x),(a),sizeof(x))//优先队列迪杰斯特拉 const int maxn=1e5+5;struct Edge&#123; int u,v,w; Edge(int _u,int _v,int _w):u(_u),v(_v),w(_w)&#123; &#125;;&#125;;vector &lt;Edge&gt; edges[maxn];int dis[maxn];bool vis[maxn];int n,m,uu,vv,ww;void init(int n)&#123; //n个结点的边集都清空 rep(i,0,maxn)&#123; edges[i].clear(); &#125;&#125;void addEdge(int u,int v,int w)&#123; edges[u].pb(Edge(u,v,w));&#125;struct Node&#123; int Id,W; Node(int _Id,int _W):Id(_Id),W(_W)&#123; &#125;; bool operator &lt; (const Node &amp;b) const &#123;W&gt;b.W;&#125;&#125;;void Dijkstra(int s)&#123; ms(vis,0); ms(dis,INF); priority_queue &lt;Node&gt; q; q.push(Node(s,0)) ,dis[s]=0; while(!q.empty())&#123; Node now=q.top(); q.pop(); int index=now.Id; if(dis[index]!=now.W) continue; rep(i,0,edges[index].size())&#123; if(dis[edges[index][i].v]&gt;dis[index]+edges[index][i].w)&#123; dis[edges[index][i].v]=dis[index]+edges[index][i].w; q.push(Node(edges[index][i].v,dis[edges[index][i].v])); &#125; &#125; &#125;&#125;int main()&#123; ios::sync_with_stdio(false); while(cin&gt;&gt;n&gt;&gt;m&amp;&amp;n+m)&#123; init(n); rep(i,1,m+1)&#123; cin&gt;&gt;uu&gt;&gt;vv&gt;&gt;ww; addEdge(uu,vv,ww); addEdge(vv,uu,ww); &#125; Dijkstra(1); cout&lt;&lt;dis[n]&lt;&lt;endl; &#125; &#125; 收获与反思 理解熟悉模板]]></content>
      <categories>
        <category>编程</category>
        <category>ACM</category>
      </categories>
      <tags>
        <tag>算法</tag>
        <tag>ACM</tag>
        <tag>2018暑假集训</tag>
        <tag>Dijkstra</tag>
        <tag>最短路</tag>
        <tag>HDU</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[《刺杀骑士团长》读书笔记]]></title>
    <url>%2Fpost%2Fd81c5363.html</url>
    <content type="text"><![CDATA[内容摘录第1部 显形理念篇 P95 “免色这个人物身上，总好像有悄然潜伏的什么。那个秘密已经放进带锁的小盒，深深埋入地下。很早以前埋的，如今上面长满绵柔茂密的绿草。而知晓埋那个小盒的场所的，这个世界上唯独免色一人。我不能不在其微笑的深处感觉出拥有那一类型的秘密带来的孤独。” P193 “就是有这一种类的梦。支离破碎犬牙交错的梦。每一块碎片诚然有其量感，但因相互纠缠而抵消了一尽。” P204 “我的感情在永无休止的沉默中犹如以刀具做成的沉重的摆子一样从一个极端画着大大的弧线摆向另一个极端。” P226 “就是说，在我们的人生中，现实与非现实的界线往往很难捕捉。那条界线看上去总是经常来来去去，就像每天兴之所至地随便移动的国境线——必须好好留意其动向才行。否则，就不知道自己现在是在哪一边了。我刚才说再在洞中停留下去可能危险，就是这个意思。” P293 “晚饭时间！人们大概同家人一起面对餐桌，即将把热乎乎的饭菜放入口中。我可以从那些灯光中感受到那种微笑的温煦。” P300 “‘一个人被关在又黑又窄的地方，最可怕的不是死，而是 开始考虑自己可能要永远在这里活下去，那比什么都可怕。那么一想，就吓得透不过气，就好像周围墙壁挤压过来直接把自己压瘪挤死——便是有那样汹涌的错觉。而在那里活下去，人就必须想方设法跨越那种恐惧，即克服自己。为此就需要无限接近死亡。’‘可那伴随着危险。’‘和接近太阳的伊卡洛斯一样。至于接近的极限在哪里，分辨那条生死攸关的线并非易事。那将成为玩命作业。’‘而若回避那种接近，就不能跨越恐惧克服自己。00p’” P333 “历史之中，就那样搁置在黑暗中为好的事件多的要命。正确知识未必使人丰富。客观未必凌驾于主观之上。事实未必吹灭妄想。”]]></content>
      <categories>
        <category>阅读</category>
      </categories>
      <tags>
        <tag>阅读</tag>
        <tag>小说</tag>
        <tag>村上春树</tag>
        <tag>刺杀骑士团长</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[【CSU-1980】解题报告（区间dp，树的中序遍历）]]></title>
    <url>%2Fpost%2Fdc981233.html</url>
    <content type="text"><![CDATA[原始题目1980: 不堪重负的树 Time Limit: 1 Sec Memory Limit: 128 Mb Submitted: 188 Solved: 83 Description小X非常喜欢树，然后他生成了一个大森林给自己玩。 玩着玩着，小X陷入了沉思。 一棵树由N个节点组成，编号为i的节点有一个价值Wi。 假设从树根出发前往第i个节点（可能是树根自己），一共需要经过Di个节点（包括起点和终点），那么这个节点对这棵树产生的负担就是Di与Wi的乘积。 对于一棵树而言，这棵树的负担值为所有节点对它产生的负担之和。 小X学习了dfs，如果他知道树的结构，他当然可以很容易地算出树的负担值。可是现在沉思中的小X并不知道树的结构形态，他只知道一棵二叉树的中序遍历以及每个节点的价值，那么这棵二叉树可能的最小负担值是多少呢？ Input第一行为一个正整数T(T≤20)表示数据组数。 每组数据包括三行。 第一行为一个正整数N(N≤200)。 第二行为N个正整数Wi(Wi≤108)，表示编号为i的节点的价值。 第三行为N个正整数Pi(Pi≤N)，为一个1~N的排列，表示二叉树的中序遍历结果。 Output对于每组数据，输出一行一个正整数，表示这棵树可能的最小负担值。 Sample Input2 4 1 2 3 4 1 2 3 4 7 1 1 1 1 1 1 1 4 2 3 5 7 1 6 Sample Output18 17 Hint对于第一个样例，树根为3，3的左儿子是2，3的右儿子是4，2的左儿子是1，这样构成的树可以达到最小负担。 对于第二个样例，对应的满二叉树可以达到最小负担。 Source2017年8月月赛 Authordevember 题目大意如题 解题思路 先求得中序遍历各节点的权值 预处理前缀和，以及dp数组（初始$dp[i][i]=f[i]$） 对于一棵树可以由左子树、右子树的最优解转移过来，区间dp 状态转移方程dp[i][j]=min(dp[i][k-1]+dp[k+1][j])+\sum_{m=i}^{j} f[i] (i]]></content>
      <categories>
        <category>编程</category>
        <category>ACM</category>
      </categories>
      <tags>
        <tag>算法</tag>
        <tag>ACM</tag>
        <tag>CSU</tag>
        <tag>2018暑假集训</tag>
        <tag>区间DP</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[【POJ-1651】解题报告（区间DP入门）]]></title>
    <url>%2Fpost%2F4fa396eb.html</url>
    <content type="text"><![CDATA[原始题目Multiplication Puzzle Time Limit: 1000MS Memory Limit: 65536K Total Submissions: 13111 Accepted: 8035 DescriptionThe multiplication puzzle is played with a row of cards, each containing a single positive integer. During the move player takes one card out of the row and scores the number of points equal to the product of the number on the card taken and the numbers on the cards on the left and on the right of it. It is not allowed to take out the first and the last card in the row. After the final move, only two cards are left in the row. The goal is to take cards in such order as to minimize the total number of scored points. For example, if cards in the row contain numbers 10, 1, 50, 20, 5, player might take a card with 1, then 20 and 50, scoring 10*1*50 + 50*20*5 + 10*50*5 = 500+5000+2500 = 8000If he would take the cards in the opposite order, i.e. 50, then 20, then 1, the score would be 1*50*20 + 1*20*5 + 10*1*5 = 1000+100+50 = 1150 InputThe first line of the input contains the number of cards $N (3 \le N \le 100)$. The second line contains $N$ integers in the range from $1$ to $100$, separated by spaces. OutputOutput must contain a single integer - the minimal score. Sample Input6 10 1 50 50 20 5 Sample Output3650 Source Northeastern Europe 2001, Far-Eastern Subregion 题目大意 抽卡片，分数每次增加所抽卡片以及其相邻两侧的卡片的数值。不允许抽第一个和最后一个，抽到最后仅剩下这两张卡片，求最小的分数。 解题思路 每个大区间的分数都由最后抽的一张牌分成两个小区间，区间dp问题 状态转移方程dp[i][j]=min(dp[i][k]+dp[k][j]+a[i]*a[k]*a[j]) (i\leq k \leq j)解题代码12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758#include &lt;vector&gt;#include &lt;queue&gt;#include &lt;cstdio&gt;#include &lt;cstring&gt;#include &lt;cstdlib&gt;#include &lt;iostream&gt;#include &lt;algorithm&gt;//#include &lt;bits/stdc++.h&gt;#define ms(i,a) memset((i),(a),sizeof(i))#define rep(i,a,n) for (int i=a;i&lt;n;i++)#define per(i,a,n) for (int i=n-1;i&gt;=a;i--)#define pb push_back#define mp make_pair#define np next_permutation#define all(x) x.begin(),x.end()#define fi first#define se second#define SZ(x) ((int)(x).size()) #define INF 0x3f3f3f3fusing namespace std;int n,t,m; int dp[105][105],a[105],sum[105]; //前缀和 void initial()&#123; ms(dp,0); rep(i,1,n+1)&#123; rep(j,i+2,n+1)&#123; if(j==i+2) dp[i][j]=a[i]*a[i+1]*a[i+2]; else dp[i][j]=INF; &#125; &#125; &#125;int main()&#123; ios::sync_with_stdio(false);// freopen("in.txt","r",stdin); while(cin&gt;&gt;n) &#123; sum[0]=0; rep(i,1,n+1)&#123; cin&gt;&gt;a[i];// sum[i]=sum[i-1]+m; &#125; initial(); for (int len = 4; len &lt;= n; ++len)&#123; for (int i = 1; i + len - 1 &lt;= n; ++i) &#123; int j = i + len - 1; for (int k = i; k &lt;= j; ++k) dp[i][j] = min(dp[i][j], dp[i][k] + dp[k][j] + a[i] * a[k] * a[j]);// cout&lt;&lt;"i="&lt;&lt;i&lt;&lt;" j="&lt;&lt;j&lt;&lt;" dp="&lt;&lt;dp[i][j]&lt;&lt;endl; &#125; &#125; cout&lt;&lt;dp[1][n]&lt;&lt;endl; &#125; return 0;&#125; 收获与反思 注意边界条件 注意dp数组的初始化]]></content>
      <categories>
        <category>编程</category>
        <category>ACM</category>
      </categories>
      <tags>
        <tag>算法</tag>
        <tag>ACM</tag>
        <tag>2018暑假集训</tag>
        <tag>区间DP</tag>
        <tag>POJ</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[【CSU-1592】解题报告（区间DP入门）]]></title>
    <url>%2Fpost%2Fc6d76e9a.html</url>
    <content type="text"><![CDATA[原始题目1592: 石子归并 Time Limit: 1 Sec Memory Limit: 128 Mb Submitted: 896 Solved: 421 Description现在有$n$堆石子，第$i$堆有$a_i$个石子。现在要把这些石子合并成一堆，每次只能合并相邻两个，每次合并的代价是两堆石子的总石子数。求合并所有石子的最小代价。 Input第一行包含一个整数$T ( T \le 50) $ ，表示数据组数。 每组数据第一行包含一个整数$ n ( 2 \le n \le 100 ) $，表示石子的堆数。 第二行包含$n$个正整数$ a_i ( a_i \le 100)$，表示每堆石子的石子数。 Output每组数据仅一行，表示最小合并代价。 Sample Input2 4 1 2 3 4 5 3 5 2 1 4 Sample Output19 33 HintSource国防科学技术大学第十八届银河之光文化节ACM程序设计竞赛初赛 题目大意如题 解题思路 区间dp 状态转移方程：$dp[i][j]=min(dp[i][j],dp[i][i+k]+dp[i+k+1][j]+sum[j]-sum[i-1])$; 解题代码1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859#include &lt;vector&gt;#include &lt;queue&gt;#include &lt;cstdio&gt;#include &lt;cstring&gt;#include &lt;cstdlib&gt;#include &lt;iostream&gt;#include &lt;algorithm&gt;//#include &lt;bits/stdc++.h&gt;#define ms(i,a) memset((i),(a),sizeof(i))#define rep(i,a,n) for (int i=a;i&lt;n;i++)#define per(i,a,n) for (int i=n-1;i&gt;=a;i--)#define pb push_back#define mp make_pair#define np next_permutation#define all(x) x.begin(),x.end()#define fi first#define se second#define SZ(x) ((int)(x).size()) #define INF 0x3f3f3f3fusing namespace std;int n,t,m; int dp[105][105],sum[105]; //前缀和 void initial()&#123; rep(i,1,n+1)&#123; rep(j,1,n+1)&#123; if(i==j) dp[i][j]=0; else dp[i][j]=INF; &#125; &#125; &#125;int main()&#123; ios::sync_with_stdio(false); cin&gt;&gt;t; while(t--) &#123; cin&gt;&gt;n; sum[0]=0; rep(i,1,n+1)&#123; cin&gt;&gt;m; sum[i]=sum[i-1]+m; &#125; initial(); for(int len=1; len&lt;n; len++) &#123; for(int i=1; i+len&lt;=n; i++) &#123; int j=i+len; for(int k=0; i+k&lt;j; k++) dp[i][j]=min(dp[i][j],dp[i][i+k]+dp[i+k+1][j]+sum[j]-sum[i-1]); &#125; &#125; cout&lt;&lt;dp[1][n]&lt;&lt;endl; &#125; return 0;&#125; 收获与反思 对于求区间问题最优解，考虑区间dp]]></content>
      <categories>
        <category>编程</category>
        <category>ACM</category>
      </categories>
      <tags>
        <tag>算法</tag>
        <tag>ACM</tag>
        <tag>CSU</tag>
        <tag>2018暑假集训</tag>
        <tag>区间DP</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[【HDU-1789】解题报告（贪心，多种思路）]]></title>
    <url>%2Fpost%2F9f8e212d.html</url>
    <content type="text"><![CDATA[原始题目Doing Homework again Time Limit: 1000/1000 MS (Java/Others) Memory Limit: 32768/32768 K (Java/Others) Total Submission(s): 17643 Accepted Submission(s): 10264 Problem DescriptionIgnatius has just come back school from the 30th ACM/ICPC. Now he has a lot of homework to do. Every teacher gives him a deadline of handing in the homework. If Ignatius hands in the homework after the deadline, the teacher will reduce his score of the final test. And now we assume that doing everyone homework always takes one day. So Ignatius wants you to help him to arrange the order of doing homework to minimize the reduced score. InputThe input contains several test cases. The first line of the input is a single integer T that is the number of test cases. T test cases follow.Each test case start with a positive integer N(1≤N≤1000) which indicate the number of homework.. Then 2 lines follow. The first line contains N integers that indicate the deadlines of the subjects, and the next line contains N integers that indicate the reduced scores. OutputFor each test case, you should output the smallest total reduced score, one line per test case. Sample Input3 3 3 3 3 10 5 1 3 1 3 1 6 2 3 7 1 4 6 4 2 4 3 3 2 1 7 6 5 4 Sample Output0 3 5 Authorlcy Source2007省赛集训队练习赛（10）_以此感谢DOOMIII Recommendlcy 题目大意 某同学参加完比赛回来补作业，每种作业有ddl天数和扣分值。想让总扣分值尽量少，输出最小值。 解题思路 思路1：贪心，按分值从大到小排序，对于每份作业优先从ddl天向前安排，如果所有天都安排满了，那么ans加上该作业的扣分值（合理性：先安排的作业扣分值一定更大） 思路2：贪心+优先队列，按时间从小到大排序，按天数递增安排作业，可安排则将扣分值入队，如果安排满了，那么]]></content>
      <categories>
        <category>编程</category>
        <category>ACM</category>
      </categories>
      <tags>
        <tag>算法</tag>
        <tag>ACM</tag>
        <tag>2018暑假集训</tag>
        <tag>Greedy</tag>
        <tag>HDU</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[【CSU-1588】解题报告（贪心，水题）]]></title>
    <url>%2Fpost%2F8ddc8a30.html</url>
    <content type="text"><![CDATA[原始题目1588: 合并果子 Time Limit: 1 Sec Memory Limit: 128 Mb Submitted: 1907 Solved: 906 Description现在有$n$堆果子，第$i$堆有 $a_i$个果子。现在要把这些果子合并成一堆，每次合并的代价是两堆果子的总果子数。求合并所有果子的最小代价。 Input第一行包含一个整数$T(T \le 50)$，表示数据组数。 每组数据第一行包含一个整数$ n( 2 \le n \le 1000 )$ ，表示果子的堆数。 第二行包含$n$个正整数$a_i ( a_i \le 100) $，表示每堆果子的果子数。 Output每组数据仅一行，表示最小合并代价。 Sample Input2 4 1 2 3 4 5 3 5 2 1 4 Sample Output19 33 HintSource国防科学技术大学第十八届银河之光文化节ACM程序设计竞赛初赛 题目大意如题 解题思路 贪心，优先队列，每次取顶上两堆果子。 解题代码1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253//#include &lt;bits/stdc++.h&gt;#include &lt;cstdio&gt;#include &lt;cmath&gt;#include &lt;cstdlib&gt;#include &lt;cstring&gt;#include &lt;iostream&gt;#include &lt;set&gt;#include &lt;iomanip&gt;#include &lt;algorithm&gt;#include &lt;queue&gt;#include &lt;map&gt;#include &lt;string&gt;#define INF 0x3f3f3f3f#define rep(i,a,n) for(int i=a;i&lt;n;i++)#define per(i,a,n) for(int i=n-1;i&gt;=a;i--)using namespace std;const int maxn=1e5+5; typedef long long ll;ll t,n,a[maxn];priority_queue&lt;ll, vector&lt;ll&gt;, greater&lt;ll&gt; &gt; pq;int main()&#123; ios::sync_with_stdio(false); int t; cin&gt;&gt;t; while(t--)&#123; while(!pq.empty()) pq.pop(); int n; ll sum=0,sum1,a; cin&gt;&gt;n; rep(i,0,n)&#123; cin&gt;&gt;a; pq.push(a); &#125; while(!pq.empty())&#123; sum1=pq.top(); pq.pop(); sum1+=pq.top(); pq.pop(); if(pq.empty())&#123;// cout&lt;&lt;"empty"&lt;&lt;sum1&lt;&lt;endl; sum+=sum1;break; &#125; else&#123; sum+=sum1;// cout&lt;&lt;"get"&lt;&lt;sum1&lt;&lt;endl; pq.push(sum1); &#125; &#125; cout&lt;&lt;sum&lt;&lt;endl; &#125;&#125; 收获与反思水题]]></content>
      <categories>
        <category>编程</category>
        <category>ACM</category>
      </categories>
      <tags>
        <tag>算法</tag>
        <tag>ACM</tag>
        <tag>CSU</tag>
        <tag>2018暑假集训</tag>
        <tag>Greedy</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[【HDU-6325】解题报告（计算几何，2018杭电多校第三场）]]></title>
    <url>%2Fpost%2F264a9c89.html</url>
    <content type="text"><![CDATA[原始题目Problem G. Interstellar Travel Time Limit: 4000/2000 MS (Java/Others) Memory Limit: 524288/524288 K (Java/Others) Total Submission(s): 638 Accepted Submission(s): 137 Problem DescriptionAfter trying hard for many years, Little Q has finally received an astronaut license. To celebrate the fact, he intends to buy himself a spaceship and make an interstellar travel. Little Q knows the position of $n$ planets in space, labeled by $1$ to $n$. To his surprise, these planets are all coplanar. So to simplify, Little Q put these $n$ planets on a plane coordinate system, and calculated the coordinate of each planet $(x_i,y_i)$. Little Q plans to start his journey at the $1$-th planet, and end at the $n$-th planet. When he is at the $i$-th planet, he can next fly to the $j$-th planet only if $x_i&lt;x_j$, which will cost his spaceship $x_i\times y_j-x_j\times y_i$ units of energy. Note that this cost can be negative, it means the flight will supply his spaceship. Please write a program to help Little Q find the best route with minimum total cost. InputThe first line of the input contains an integer $T(1\leq T\leq10)$, denoting the number of test cases. In each test case, there is an integer $n(2\leq n\leq 200000)$ in the first line, denoting the number of planets. For the next n lines, each line contains $2$ integers $x_i,y_i(0\leq x_i,y_i\leq 10^9)$, denoting the coordinate of the i-th planet. Note that different planets may have the same coordinate because they are too close to each other. It is guaranteed that $y_1=y_n=0,0=x_1&lt;x_2,x_3,…,x_{n-1}&lt;x_n$. OutputFor each test case, print a single line containing several distinct integers $p_1,p_2,…,p_m(1\leq p_i\leq n)$, denoting the route you chosen is $p_1\rightarrow p_2\rightarrow…\rightarrow p_{m-1}\rightarrow p_m$. Obviously $p_1$ should be $1$ and $p_m$ should be $n$. You should choose the route with minimum total cost. If there are multiple best routes, please choose the one with the smallest lexicographically. A sequence of integers $a$ is lexicographically smaller than $a$ sequence of $b$ if there exists such index $j$ that $a_i=b_i$ for all $i&lt;j$, but $a_j&lt;b_j$. Sample Input1 3 0 0 3 0 4 0 Sample Output1 2 3 Source2018 Multi-University Training Contest 3 Recommendchendu 题目大意 给了$n$个星球的横纵坐标，从第一个星球旅行到第n个星球，消耗的燃料是叉积（可能为负） 已知$y_1=y_n=0,0=x_1&lt;x_2,x_3,…,x_{n-1}&lt;x_n$，每次旅行下一个星球的$x$坐标要大于上一个星球。 求消耗燃料的最小值，输出字典序最小的满足条件的访问顺序。 解题思路 即求从第一个点到第n个星球的上半凸包（有向面积最小，负最大） 三点共线和同点的时候要满足字典序最小的要求。 共线时判断中间点字典序是不是小于后点，共点时保留序列最小的。 解题代码123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147148149150151152153154155156157158159160161162163164165166167168169170171172173174175176177178179180181182183184185186187188189190191192193194195196197198199200201202203204205206207208209210211212213214215216217218219220221222223224225226227228229230231232#include &lt;bits/stdc++.h&gt;using namespace std;#define rep(i,a,n) for (int i=a;i&lt;n;i++)#define per(i,a,n) for (int i=n-1;i&gt;=a;i--)#define pb push_back#define mp make_pair#define np next_permutation#define all(x) x.begin(),x.end()#define fi first#define se second#define SZ(x) ((int)(x).size()) const int maxn=2e5+5;const double eps=1e-9;typedef long long ll;ll n,cnt;//有的命名为sgn函数，高精度符号判断 ll dcmp(double x)&#123; //相等函数判断，减少精度问题 if(fabs(x)&lt;eps) return 0; else return x&lt;0?-1:1;&#125;//点的定义 class Point&#123; public: ll x,y; Point (ll x=0,double y=0):x(x),y(y)&#123;&#125; //构造函数，方便代码的编写 &#125;; typedef Point Vector;// 从程序实现上，Vector只是Point的别名//运算符重载 //向量+向量=向量，点+向量=点Vector operator + (const Vector &amp;A,const Vector &amp;B) &#123; return Vector(A.x+B.x,A.y+B.y); &#125;//向量-向量=向量，点-向量-点 Vector operator - (const Vector &amp;A,const Vector &amp;B) &#123; return Vector(A.x-B.x,A.y-B.y); &#125;//向量*数=向量 （数乘） Vector operator * (const Vector &amp;A,double p) &#123; return Vector(A.x*p,A.y*p); &#125;//向量/数=向量 （数除） Vector operator / (const Vector &amp;A,double p) &#123; return Vector(A.x/p,A.y/p); &#125;//向量（点乘）向量=数 （点乘）double operator * (const Vector &amp;A,const Vector &amp;B) &#123; return A.x*B.x+A.y*B.y; &#125;double dot(const Vector &amp;A,const Vector &amp;B)&#123; return A.x*B.x+A.y*B.y; &#125;//向量（叉乘）向量=向量 （叉乘） double operator ^ (const Vector &amp;A,const Vector &amp;B)&#123; return A.x*B.y-A.y*B.x; &#125;ll cross(const Vector &amp;A,const Vector &amp;B)&#123; return A.x*B.y-A.y*B.x; &#125;//计算向量模长 double abs(const Vector &amp;A)&#123; return sqrt(dot(A,A));&#125;//计算平行四边形方向面积double area2(const Point &amp;A,const Point &amp;B,const Point &amp;C)&#123; return cross(B-A,C-A) ;&#125; //按x值递增排序 bool operator &lt; (const Point &amp;A,const Point &amp;B) &#123; return A.x==B.x?A.y&lt;B.y:A.x&lt;B.x; &#125; //判定两个点是否相同，用到dcmp精度判定 bool operator == (const Point &amp;A,const Point &amp;B) &#123; return dcmp(A.x-B.x)==0&amp;&amp; dcmp(A.y-B.y)==0; &#125; //向量旋转Vector rotate(Vector A,double rad) &#123; return Vector(A.x*cos(rad)-A.y*sin(rad),A.x*sin(rad)+A.y*cos(rad));&#125;//计算单位法线，左转90Vector normal(Vector A)&#123; double l=abs(A); return Vector(-A.y/l,A.x/l);&#125; //线段定义 class Line &#123; public: Point s,e; Line()&#123;&#125; Line(Point _s,Point _e)&#123; s=_s;e=_e; &#125; &#125;line[maxn];//判断两线段是否相交 bool inter(Line l1,Line l2)&#123;// cout&lt;&lt;"L1 "&lt;&lt;l1.e.x&lt;&lt;","&lt;&lt;l1.e.y&lt;&lt;" "&lt;&lt;l1.s.x&lt;&lt;","&lt;&lt;l1.s.y&lt;&lt;endl;// cout&lt;&lt;"L2 "&lt;&lt;l2.e.x&lt;&lt;","&lt;&lt;l2.e.y&lt;&lt;" "&lt;&lt;l2.s.x&lt;&lt;","&lt;&lt;l2.s.y&lt;&lt;endl; return ( //根据题目要求端点相交是否算作相交来决定大于等于和小于等于 //排斥实验 max(l1.s.x,l1.e.x)&gt;=min(l2.s.x,l2.e.x) &amp;&amp; max(l2.s.x,l2.e.x)&gt;=min(l1.s.x,l1.e.x) &amp;&amp; max(l1.s.y,l1.e.y)&gt;=min(l2.s.y,l2.e.y) &amp;&amp; max(l2.s.y,l2.e.y)&gt;=min(l1.s.y,l1.e.y) &amp;&amp; //跨立实验 dcmp((l2.s-l1.s)^(l1.s-l1.e))*dcmp((l2.e-l1.s)^(l1.s-l1.e))&lt;0 &amp;&amp; dcmp((l1.s-l2.s)^(l2.s-l2.e))*dcmp((l1.e-l2.s)^(l2.s-l2.e))&lt;0 ) ;&#125;bool inter(Point a1,Point a2,Point b1,Point b2)&#123; Line l1(a1,a2),l2(b1,b2); return inter(l1,l2);&#125;//求两直线交点Point getinter(Line l1,Line l2)&#123; Vector v=l1.s-l1.e; Vector w=l2.s-l2.e; Vector u=l1.e-l2.e; double t=cross(w,u)/cross(v,w); return l1.e+v*t;&#125; Point getinter(Point a1,Point a2,Point b1,Point b2)&#123; Line l1(a1,a2); Line l2(b1,b2); return getinter(l1,l2);&#125;//判定点和线段的关系，//0:不在线段所在直线上//1:在线段内（不含端点） //2:在线段端点//3:在线段两侧的射线上 ll online(Point a,Line l)&#123; if(dcmp(cross(l.s-a,l.e-a))!=0) return 0; double pans=dcmp(dot(l.s-a,l.e-a));// cout&lt;&lt;(l.s-a).x&lt;&lt;","&lt;&lt;(l.s-a).y&lt;&lt;" "&lt;&lt;(l.e-a).x&lt;&lt;","&lt;&lt;(l.e-a).y&lt;&lt;endl; if(pans&lt;0) return 1; else if(pans==0) return 2; else if(pans&gt;0) return 3;&#125;ll online(Point a,Point b1,Point b2)&#123; Line l(b1,b2); return online(a,l);&#125;class node&#123; public: ll index; Point p;&#125; point[maxn],ans[maxn],pre[maxn];bool cmp(node a, node b)&#123; if(a.p.x==b.p.x)&#123; if(a.p.y==b.p.y) return a.index&gt;b.index; return a.p.y&lt;b.p.y; &#125; else &#123; return a.p.x&lt;b.p.x; &#125;&#125;ll ConvexHull()&#123; ll flag=0; ll m=0; for(ll i=1;i&lt;=cnt;i++)&#123; if(!flag &amp;&amp; point[i].index!=1) continue; if(point[i].index==1)&#123; flag=1; &#125; while(m&gt;1 &amp;&amp; cross(ans[m-1].p-ans[m-2].p,point[i].p-ans[m-2].p)&gt;=0) &#123; if(m&gt;1 &amp;&amp; cross(ans[m-1].p-ans[m-2].p,point[i].p-ans[m-2].p)==0)&#123; //判断字典序 if(point[i].index&lt;ans[m-1].index) m--; else break; &#125; else if(m&gt;1 &amp;&amp; cross(ans[m-1].p-ans[m-2].p,point[i].p-ans[m-2].p)&gt;0)&#123; m--; &#125; &#125; ans[m].p=point[i].p; ans[m].index=point[i].index;// cout&lt;&lt;m&lt;&lt;" ans.p=("&lt;&lt;ans[m].p.x&lt;&lt;","&lt;&lt;ans[m].p.y&lt;&lt;" index="&lt;&lt;ans[m].index&lt;&lt;endl;// cout&lt;&lt;"$$$$"&lt;&lt;ans[m].index&lt;&lt;" "&lt;&lt;n&lt;&lt;"$$$$"&lt;&lt;endl; m++; if(ans[m-1].index==n) break;// cout&lt;&lt;m&lt;&lt;" ans.p=("&lt;&lt;ans[m].p.x&lt;&lt;","&lt;&lt;ans[m].p.y&lt;&lt;" index="&lt;&lt;ans[m].index&lt;&lt;endl; &#125; return m;&#125;int main()&#123; ios::sync_with_stdio(false); ll t; cin&gt;&gt;t; while(t--)&#123; cin&gt;&gt;n; cnt=0; rep(i,1,n+1)&#123; cin&gt;&gt;pre[i].p.x&gt;&gt;pre[i].p.y; pre[i].index=i; &#125; sort(pre+1,pre+n+1,cmp); rep(i,1,n+1)&#123; if(i==1) point[++cnt]=pre[i]; else if(pre[i].p.x==point[cnt].p.x) point[cnt]=pre[i]; else point[++cnt]=pre[i]; &#125; ll len=ConvexHull(); rep(i,0,len)&#123; if(i==0) cout&lt;&lt;ans[i].index; else cout&lt;&lt;" "&lt;&lt;ans[i].index; &#125; cout&lt;&lt;endl; &#125;&#125; //1//7//1 1//3 5//3 1//1 3//2 4//7 2//9 1//2 //13//1 0 //3 5//3 1//2 4//5 3//4 6//2 4//7 2//6 13//9 1//3 0//10 1//11 0 收获与反思 注意long long 可能出现共点情况，三点共线情况，都要考虑字典序的要求]]></content>
      <categories>
        <category>编程</category>
        <category>ACM</category>
      </categories>
      <tags>
        <tag>算法</tag>
        <tag>ACM</tag>
        <tag>2018暑假集训</tag>
        <tag>HDU</tag>
        <tag>计算几何</tag>
        <tag>2018杭电多校</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[【POJ-1654】解题报告（计算几何，longlong）]]></title>
    <url>%2Fpost%2F98804e11.html</url>
    <content type="text"><![CDATA[原始题目Area Time Limit: 1000MS Memory Limit: 10000K Total Submissions: 21457 Accepted: 5826 DescriptionYou are going to compute the area of a special kind of polygon. One vertex of the polygon is the origin of the orthogonal coordinate system. From this vertex, you may go step by step to the following vertexes of the polygon until back to the initial vertex. For each step you may go North, West, South or East with step length of 1 unit, or go Northwest, Northeast, Southwest or Southeast with step length of square root of 2. For example, this is a legal polygon to be computed and its area is 2.5: InputThe first line of input is an integer t (1 ≤ t ≤ 20), the number of the test polygons. Each of the following lines contains a string composed of digits 1-9 describing how the polygon is formed by walking from the origin. Here 8, 2, 6 and 4 represent North, South, East and West, while 9, 7, 3 and 1 denote Northeast, Northwest, Southeast and Southwest respectively. Number 5 only appears at the end of the sequence indicating the stop of walking. You may assume that the input polygon is valid which means that the endpoint is always the start point and the sides of the polygon are not cross to each other.Each line may contain up to 1000000 digits. OutputFor each polygon, print its area on a single line. Sample Input4 5 825 6725 6244865 Sample Output0 0 0.5 2 SourcePOJ Monthly—2004.05.15 Liu Rujia@POJ 题目大意 在二维坐标系中点向8个方向移动，经过一系列移动后回到原点，并且边不相交（构成闭合的多边形），求其面积。 解题思路 由于坐标都是整数且很大，由于精度考虑，按照long long计算最后再除以2. 解题代码123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147148149150151152153154155156157158159160161162163164165166167168//计算几何模板，二维几何基础//使用印用注意避免直接在程序中调用构造函数构造无名对象。否则可能会导致程序出错 //#include &lt;bits/stdc++.h&gt;#include &lt;cstdio&gt;#include &lt;cmath&gt;#include &lt;cstdlib&gt;#include &lt;cstring&gt;#include &lt;iostream&gt;#include &lt;set&gt;#include &lt;iomanip&gt;#include &lt;algorithm&gt;#include &lt;queue&gt;#include &lt;map&gt;#include &lt;string&gt;#define INF 0x3f3f3f3f#define rep(i,a,n) for(int i=a;i&lt;n;i++)#define per(i,a,n) for(int i=n-1;i&gt;=a;i--)using namespace std;typedef long long ll;const double eps =1e-10;const int maxn=50;int n;//有的命名为sgn函数，高精度符号判断 int dcmp(double x)&#123; //相等函数判断，减少精度问题 if(fabs(x)&lt;eps) return 0; else return x&lt;0?-1:1;&#125;//点的定义 class Point&#123; public: ll x,y; Point (ll x=0,ll y=0):x(x),y(y)&#123;&#125; //构造函数，方便代码的编写 &#125;; typedef Point Vector;// 从程序实现上，Vector只是Point的别名//运算符重载 //向量+向量=向量，点+向量=点Vector operator + (const Vector &amp;A,const Vector &amp;B) &#123; return Vector(A.x+B.x,A.y+B.y); &#125;//向量-向量=向量，点-向量-点 Vector operator - (const Vector &amp;A,const Vector &amp;B) &#123; return Vector(A.x-B.x,A.y-B.y); &#125;//向量*数=向量 （数乘） Vector operator * (const Vector &amp;A,double p) &#123; return Vector(A.x*p,A.y*p); &#125;//向量/数=向量 （数除） Vector operator / (const Vector &amp;A,double p) &#123; return Vector(A.x/p,A.y/p); &#125;//向量（点乘）向量=数 （点乘）double operator * (const Vector &amp;A,const Vector &amp;B) &#123; return A.x*B.x+A.y*B.y; &#125;double dot(const Vector &amp;A,const Vector &amp;B)&#123; return A.x*B.x+A.y*B.y; &#125;//向量（叉乘）向量=向量 （叉乘） double operator ^ (const Vector &amp;A,const Vector &amp;B)&#123; return A.x*B.y-A.y*B.x; &#125;ll cross(const Vector &amp;A,const Vector &amp;B)&#123; return A.x*B.y-A.y*B.x; &#125;//计算向量模长 double abs(const Vector &amp;A)&#123; return sqrt(dot(A,A));&#125;//计算平行四边形方向面积double area2(const Point &amp;A,const Point &amp;B,const Point &amp;C)&#123; return cross(B-A,C-A) ;&#125; //按x值递增排序 bool operator &lt; (const Point &amp;A,const Point &amp;B) &#123; return A.x==B.x?A.y&lt;B.y:A.x&lt;B.x; &#125; //判定两个点是否相同，用到dcmp精度判定 bool operator == (const Point &amp;A,const Point &amp;B) &#123; return dcmp(A.x-B.x)==0&amp;&amp; dcmp(A.y-B.y)==0; &#125; //向量旋转Vector rotate(Vector A,double rad) &#123; return Vector(A.x*cos(rad)-A.y*sin(rad),A.x*sin(rad)+A.y*cos(rad));&#125;//计算单位法线，左转90Vector normal(Vector A)&#123; double l=abs(A); return Vector(-A.y/l,A.x/l);&#125; //线段定义 class Line &#123; public: Point s,e; Line()&#123;&#125; Line(Point _s,Point _e)&#123; s=_s;e=_e; &#125; &#125;line[maxn];//判断两线段是否相交 bool inter(Line l1,Line l2)&#123;// cout&lt;&lt;"L1 "&lt;&lt;l1.e.x&lt;&lt;","&lt;&lt;l1.e.y&lt;&lt;" "&lt;&lt;l1.s.x&lt;&lt;","&lt;&lt;l1.s.y&lt;&lt;endl;// cout&lt;&lt;"L2 "&lt;&lt;l2.e.x&lt;&lt;","&lt;&lt;l2.e.y&lt;&lt;" "&lt;&lt;l2.s.x&lt;&lt;","&lt;&lt;l2.s.y&lt;&lt;endl; return ( //根据题目要求端点相交是否算作相交来决定大于等于和小于等于 //排斥实验 max(l1.s.x,l1.e.x)&gt;=min(l2.s.x,l2.e.x) &amp;&amp; max(l2.s.x,l2.e.x)&gt;=min(l1.s.x,l1.e.x) &amp;&amp; max(l1.s.y,l1.e.y)&gt;=min(l2.s.y,l2.e.y) &amp;&amp; max(l2.s.y,l2.e.y)&gt;=min(l1.s.y,l1.e.y) &amp;&amp; //跨立实验 dcmp((l2.s-l1.s)^(l1.s-l1.e))*dcmp((l2.e-l1.s)^(l1.s-l1.e))&lt;0 &amp;&amp; dcmp((l1.s-l2.s)^(l2.s-l2.e))*dcmp((l1.e-l2.s)^(l2.s-l2.e))&lt;0 ) ;&#125;bool inter(Point a1,Point a2,Point b1,Point b2)&#123; Line l1(a1,a2),l2(b1,b2); return inter(l1,l2);&#125;//求两直线交点Point getinter(Line l1,Line l2)&#123; Vector v=l1.s-l1.e; Vector w=l2.s-l2.e; Vector u=l1.e-l2.e; double t=cross(w,u)/cross(v,w); return l1.e+v*t;&#125; Point getinter(Point a1,Point a2,Point b1,Point b2)&#123; Line l1(a1,a2); Line l2(b1,b2); return getinter(l1,l2);&#125;//判定点和线段的关系，//0:不在线段所在直线上//1:在线段内（不含端点） //2:在线段端点//3:在线段两侧的射线上 int online(Point a,Line l)&#123; if(dcmp(cross(l.s-a,l.e-a))!=0) return 0; double pans=dcmp(dot(l.s-a,l.e-a));// cout&lt;&lt;(l.s-a).x&lt;&lt;","&lt;&lt;(l.s-a).y&lt;&lt;" "&lt;&lt;(l.e-a).x&lt;&lt;","&lt;&lt;(l.e-a).y&lt;&lt;endl; if(pans&lt;0) return 1; else if(pans==0) return 2; else if(pans&gt;0) return 3;&#125;int online(Point a,Point b1,Point b2)&#123; Line l(b1,b2); return online(a,l);&#125; int main()&#123; int t; cin&gt;&gt;t; while(t--)&#123; Point pnow(0,0),pnext(0,0); ll area=0; string s; cin&gt;&gt;s; int len=s.size(); rep(i,0,len)&#123; pnow=pnext; switch(s[i])&#123; case '8': pnext.y++; break; case '2': pnext.y--; break; case '6': pnext.x++; break; case '4': pnext.x--; break; case '9': pnext.x++, pnext.y++; break; case '7': pnext.x--, pnext.y++; break; case '3': pnext.x++, pnext.y--; break; case '1': pnext.x--, pnext.y--; break; default: break; &#125; area+=cross(pnext,pnow); &#125; area=(area&lt;0?(0-area):area); if(area%2==0) cout&lt;&lt;area/2&lt;&lt;endl; else cout&lt;&lt;area/2&lt;&lt;".5"&lt;&lt;endl; &#125;&#125; 收获与反思 整数坐标注意开long long。 多边形有向面积模板题。]]></content>
      <categories>
        <category>编程</category>
        <category>ACM</category>
      </categories>
      <tags>
        <tag>算法</tag>
        <tag>ACM</tag>
        <tag>2018暑假集训</tag>
        <tag>计算几何</tag>
        <tag>POJ</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[【UVA-10652】解题报告（计算几何，凸包模板）]]></title>
    <url>%2Fpost%2F57bfde8d.html</url>
    <content type="text"><![CDATA[原始题目Board Wrapping 题目大意 给出平面直角坐标系n个长方形模具的中心点，长宽以及顺时针旋转角度，求一个能包含所有模具的最小多边形，并计算模具的面积占多边形面积的百分比。 解题思路 把长方形都看成四个点，则为凸包问题，求凸包面积以及长方形面积计算百分比即可。 解题代码123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147148149150151152153154155156157158159160161162163164165166167168169170171172173//计算几何模板，二维几何基础//使用印用注意避免直接在程序中调用构造函数构造无名对象。否则可能会导致程序出错 #include &lt;bits/stdc++.h&gt;#include &lt;cstdio&gt;#include &lt;cmath&gt;#include &lt;cstdlib&gt;#include &lt;cstring&gt;#include &lt;iostream&gt;#include &lt;set&gt;#include &lt;iomanip&gt;#include &lt;algorithm&gt;#include &lt;queue&gt;#include &lt;map&gt;#include &lt;string&gt;#define INF 0x3f3f3f3f#define rep(i,a,n) for(int i=a;i&lt;n;i++)#define per(i,a,n) for(int i=n-1;i&gt;=a;i--)using namespace std;typedef long long ll;const double eps =1e-10;const int maxn=2500; //注意修改 int n;//有的命名为sgn函数，高精度符号判断 int dcmp(double x)&#123; //相等函数判断，减少精度问题 if(fabs(x)&lt;eps) return 0; else return x&lt;0?-1:1;&#125;//点的定义 class Point&#123; public: double x,y; Point (double x=0,double y=0):x(x),y(y)&#123;&#125; //构造函数，方便代码的编写 &#125;point[maxn],pafter[maxn]; typedef Point Vector;// 从程序实现上，Vector只是Point的别名//运算符重载 Vector operator + (const Vector &amp;A,const Vector &amp;B) &#123; return Vector(A.x+B.x,A.y+B.y); &#125; //向量+向量=向量，点+向量=点Vector operator - (const Vector &amp;A,const Vector &amp;B) &#123; return Vector(A.x-B.x,A.y-B.y); &#125; //向量-向量=向量，点-向量-点 Vector operator * (const Vector &amp;A,double p) &#123; return Vector(A.x*p,A.y*p); &#125; //向量*数=向量 （数乘） Vector operator / (const Vector &amp;A,double p) &#123; return Vector(A.x/p,A.y/p); &#125; //向量/数=向量 （数除）double operator * (const Vector &amp;A,const Vector &amp;B) &#123; return A.x*B.x+A.y*B.y; &#125; //向量（点乘）向量=数 （点乘）bool operator &lt; (const Point &amp;A,const Point &amp;B) &#123; return A.x==B.x?A.y&lt;B.y:A.x&lt;B.x; &#125; //按x值递增排序 bool operator == (const Point &amp;A,const Point &amp;B) &#123; return dcmp(A.x-B.x)==0&amp;&amp; dcmp(A.y-B.y)==0; &#125; //判定两个点是否相同，用到dcmp精度判定 //点乘叉乘 double dot(const Vector &amp;A,const Vector &amp;B)&#123; return A.x*B.x+A.y*B.y; &#125; //向量（叉乘）向量=向量 （叉乘） double operator ^ (const Vector &amp;A,const Vector &amp;B)&#123; return A.x*B.y-A.y*B.x; &#125;double cross(const Vector &amp;A,const Vector &amp;B)&#123; return A.x*B.y-A.y*B.x; &#125;//模长面积 double abs(const Vector &amp;A)&#123; return sqrt(dot(A,A));&#125; //计算向量模长 double area2(const Point &amp;A,const Point &amp;B,const Point &amp;C)&#123; return cross(B-A,C-A) ;&#125; //计算平行四边形方向面积double PolygonArea(Point *p,int n) &#123; double area=0; rep(i,1,n-1)&#123;area+=cross(p[i]-p[0],p[i+1]-p[0]);&#125;return area/2.0; &#125; //计算多边形的有向面积//旋转Vector rotate(Vector A,double rad) &#123; return Vector(A.x*cos(rad)-A.y*sin(rad),A.x*sin(rad)+A.y*cos(rad));&#125; //旋转rad弧度 Vector normal(Vector A)&#123;double l=abs(A);return Vector(-A.y/l,A.x/l);&#125; //计算单位法线，左转90double torad(double deg) &#123; return deg/180*acos(-1); &#125; //角度转弧度 //线段定义 class Line &#123; public: Point s,e; Line()&#123;&#125; Line(Point _s,Point _e)&#123; s=_s;e=_e; &#125; &#125;line[maxn];//判断两线段是否相交 bool inter(Line l1,Line l2)&#123;// cout&lt;&lt;"L1 "&lt;&lt;l1.e.x&lt;&lt;","&lt;&lt;l1.e.y&lt;&lt;" "&lt;&lt;l1.s.x&lt;&lt;","&lt;&lt;l1.s.y&lt;&lt;endl;// cout&lt;&lt;"L2 "&lt;&lt;l2.e.x&lt;&lt;","&lt;&lt;l2.e.y&lt;&lt;" "&lt;&lt;l2.s.x&lt;&lt;","&lt;&lt;l2.s.y&lt;&lt;endl; return ( //根据题目要求端点相交是否算作相交来决定大于等于和小于等于 //排斥实验 max(l1.s.x,l1.e.x)&gt;=min(l2.s.x,l2.e.x) &amp;&amp; max(l2.s.x,l2.e.x)&gt;=min(l1.s.x,l1.e.x) &amp;&amp; max(l1.s.y,l1.e.y)&gt;=min(l2.s.y,l2.e.y) &amp;&amp; max(l2.s.y,l2.e.y)&gt;=min(l1.s.y,l1.e.y) &amp;&amp; //跨立实验 dcmp((l2.s-l1.s)^(l1.s-l1.e))*dcmp((l2.e-l1.s)^(l1.s-l1.e))&lt;0 &amp;&amp; dcmp((l1.s-l2.s)^(l2.s-l2.e))*dcmp((l1.e-l2.s)^(l2.s-l2.e))&lt;0 ) ;&#125;bool inter(Point a1,Point a2,Point b1,Point b2)&#123; Line l1(a1,a2),l2(b1,b2); return inter(l1,l2);&#125;bool cmp(Point a,Point b)&#123; if(a.x==b.x) return a.y&lt;b.y; else return a.x&lt;b.x;&#125;//求两直线交点Point getinter(Line l1,Line l2)&#123;Vector v=l1.s-l1.e;Vector w=l2.s-l2.e;Vector u=l1.e-l2.e;double t=cross(w,u)/cross(v,w);return l1.e+v*t;&#125; Point getinter(Point a1,Point a2,Point b1,Point b2)&#123;Line l1(a1,a2);Line l2(b1,b2);return getinter(l1,l2);&#125;//判定点和线段的关系，//0:不在线段所在直线上//1:在线段内（不含端点） //2:在线段端点//3:在线段两侧的射线上 int online(Point a,Line l)&#123; if(dcmp(cross(l.s-a,l.e-a))!=0) return 0; double pans=dcmp(dot(l.s-a,l.e-a));// cout&lt;&lt;(l.s-a).x&lt;&lt;","&lt;&lt;(l.s-a).y&lt;&lt;" "&lt;&lt;(l.e-a).x&lt;&lt;","&lt;&lt;(l.e-a).y&lt;&lt;endl; if(pans&lt;0) return 1; else if(pans==0) return 2; else if(pans&gt;0) return 3;&#125;int online(Point a,Point b1,Point b2)&#123; Line l(b1,b2); return online(a,l);&#125;//凸包int ConvexHull(Point *p,int n,Point *ch)&#123; sort(p,p+n,cmp); int m=0; for(int i=0;i&lt;n;i++)&#123; while(m&gt;1 &amp;&amp; cross(ch[m-1]-ch[m-2],p[i]-ch[m-2])&lt;=0) m--; ch[m++]=p[i]; &#125; int k=m; for(int i=n-2;i&gt;=0;i--)&#123; while(m&gt;k &amp;&amp; cross(ch[m-1]-ch[m-2],p[i]-ch[m-2])&lt;=0) m--; ch[m++]=p[i]; &#125; if(n&gt;1) m--; return m;&#125; int main()&#123; int t; ios::sync_with_stdio(false); cin&gt;&gt;t; while(t--)&#123; int n,pc=0; double area1=0; cin&gt;&gt;n; rep(i,0,n)&#123; double x,y,w,h,j,ang; cin&gt;&gt;x&gt;&gt;y&gt;&gt;w&gt;&gt;h&gt;&gt;j; Point o(x,y); //原始点 ang=-torad(j); point[pc++]=o+rotate(Vector(w/2,h/2),ang); point[pc++]=o+rotate(Vector(-w/2,h/2),ang); point[pc++]=o+rotate(Vector(w/2,-h/2),ang); point[pc++]=o+rotate(Vector(-w/2,-h/2),ang); area1+= w*h; &#125;// for(int i=0;i&lt;pc;i++) cout&lt;&lt;point[i].x&lt;&lt;","&lt;&lt;point[i].y&lt;&lt;endl; int len=ConvexHull(point,pc,pafter); double area2 = PolygonArea(pafter,len);// cout&lt;&lt;"len="&lt;&lt;len&lt;&lt;" area1="&lt;&lt;area1&lt;&lt;" area2="&lt;&lt;area2&lt;&lt;endl; cout&lt;&lt;fixed&lt;&lt;setprecision(1)&lt;&lt;area1*100/area2&lt;&lt;" %"&lt;&lt;endl; &#125; &#125; 收获与反思 凸包模板]]></content>
      <categories>
        <category>编程</category>
        <category>ACM</category>
      </categories>
      <tags>
        <tag>算法</tag>
        <tag>ACM</tag>
        <tag>2018暑假集训</tag>
        <tag>计算几何</tag>
        <tag>UVA</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[【POJ-1269】解题报告（计算几何，直线相交求交点）]]></title>
    <url>%2Fpost%2Ffb2f630e.html</url>
    <content type="text"><![CDATA[原始题目Intersecting Lines Time Limit: 1000MS Memory Limit: 10000K Total Submissions: 18318 Accepted: 7816 DescriptionWe all know that a pair of distinct points on a plane defines a line and that a pair of lines on a plane will intersect in one of three ways:1) no intersection because they are parallel,2) intersect in a line because they are on top of one another (i.e. they are the same line),3) intersect in a point. In this problem you will use your algebraic knowledge to create a program that determines how and where two lines intersect. Your program will repeatedly read in four points that define two lines in the x-y plane and determine how and where the lines intersect. All numbers required by this problem will be reasonable, say between -1000 and 1000. InputThe first line contains an integer N between 1 and 10 describing how many pairs of lines are represented. The next N lines will each contain eight integers. These integers represent the coordinates of four points on the plane in the order x1y1x2y2x3y3x4y4. Thus each of these input lines represents two lines on the plane: the line through (x1,y1) and (x2,y2) and the line through (x3,y3) and (x4,y4). The point (x1,y1) is always distinct from (x2,y2). Likewise with (x3,y3) and (x4,y4). OutputThere should be N+2 lines of output. The first line of output should read INTERSECTING LINES OUTPUT. There will then be one line of output for each pair of planar lines represented by a line of input, describing how the lines intersect: none, line, or point. If the intersection is a point then your program should output the x and y coordinates of the point, correct to two decimal places. The final line of output should read “END OF OUTPUT”. Sample Input5 0 0 4 4 0 4 4 0 5 0 7 6 1 0 2 3 5 0 7 6 3 -6 4 -3 2 0 2 27 1 5 18 5 0 3 4 0 1 2 2 5 Sample OutputINTERSECTING LINES OUTPUT POINT 2.00 2.00 NONE LINE POINT 2.00 5.00 POINT 1.07 2.20 END OF OUTPUT SourceMid-Atlantic 1996 题目大意给出n组两点确定的直线（不是线段），判断两条直线是平行，相交（给出交点）还是同一直线。 解题思路 计算几何基础题 先求两向量$v_1,v_2$的cross（叉积），若为零则从两条直线的点各取一个构成向量$v_3$和原向量其中一个求叉积，若也为零说明共线，不为零说明平行 非上述则求交点，套模板公式即可 解题代码123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147148149150151152153154155156157158//计算几何模板，二维几何基础//使用印用注意避免直接在程序中调用构造函数构造无名对象。否则可能会导致程序出错 //#include &lt;bits/stdc++.h&gt;#include &lt;cstdio&gt;#include &lt;cmath&gt;#include &lt;cstdlib&gt;#include &lt;cstring&gt;#include &lt;iostream&gt;#include &lt;set&gt;#include &lt;iomanip&gt;#include &lt;algorithm&gt;#include &lt;queue&gt;#include &lt;map&gt;#include &lt;string&gt;#define INF 0x3f3f3f3f#define rep(i,a,n) for(int i=a;i&lt;n;i++)#define per(i,a,n) for(int i=n-1;i&gt;=a;i--)using namespace std;typedef long long ll;const double eps =1e-10;const int maxn=50;int n;//有的命名为sgn函数，高精度符号判断 int dcmp(double x)&#123; //相等函数判断，减少精度问题 if(fabs(x)&lt;eps) return 0; else return x&lt;0?-1:1;&#125;//点的定义 class Point&#123; public: double x,y; Point (double x=0,double y=0):x(x),y(y)&#123;&#125; //构造函数，方便代码的编写 &#125;point[maxn]; typedef Point Vector;// 从程序实现上，Vector只是Point的别名//运算符重载 Vector operator + (const Vector &amp;A,const Vector &amp;B) &#123; return Vector(A.x+B.x,A.y+B.y); &#125; //向量+向量=向量，点+向量=点Vector operator - (const Vector &amp;A,const Vector &amp;B) &#123; return Vector(A.x-B.x,A.y-B.y); &#125; //向量-向量=向量，点-向量-点 Vector operator * (const Vector &amp;A,double p) &#123; return Vector(A.x*p,A.y*p); &#125; //向量*数=向量 （数乘） Vector operator / (const Vector &amp;A,double p) &#123; return Vector(A.x/p,A.y/p); &#125; //向量/数=向量 （数除）double operator * (const Vector &amp;A,const Vector &amp;B) &#123; return A.x*B.x+A.y*B.y; &#125; //向量（点乘）向量=数 （点乘）bool operator &lt; (const Point &amp;A,const Point &amp;B) &#123; return A.x==B.x?A.y&lt;B.y:A.x&lt;B.x; &#125; //按x值递增排序 bool operator == (const Point &amp;A,const Point &amp;B) &#123; return dcmp(A.x-B.x)==0&amp;&amp; dcmp(A.y-B.y)==0; &#125; //判定两个点是否相同，用到dcmp精度判定 //点乘叉乘 double dot(const Vector &amp;A,const Vector &amp;B)&#123; return A.x*B.x+A.y*B.y; &#125; //向量（叉乘）向量=向量 （叉乘） double operator ^ (const Vector &amp;A,const Vector &amp;B)&#123; return A.x*B.y-A.y*B.x; &#125;double cross(const Vector &amp;A,const Vector &amp;B)&#123; return A.x*B.y-A.y*B.x; &#125;//模长面积 double abs(const Vector &amp;A)&#123; return sqrt(dot(A,A));&#125; //计算向量模长 double area2(const Point &amp;A,const Point &amp;B,const Point &amp;C)&#123; return cross(B-A,C-A) ;&#125; //计算平行四边形方向面积double PolygonArea(Point *p,int n) &#123; double area=0; rep(i,1,n-1)&#123;area+=cross(p[i]-p[0],p[i+1]-p[0]);&#125;return area/2.0; &#125; //计算多边形的有向面积//旋转Vector rotate(Vector A,double rad) &#123; return Vector(A.x*cos(rad)-A.y*sin(rad),A.x*sin(rad)+A.y*cos(rad));&#125; //旋转rad弧度 Vector normal(Vector A)&#123;double l=abs(A);return Vector(-A.y/l,A.x/l);&#125; //计算单位法线，左转90//线段定义 class Line &#123; public: Point s,e; Line()&#123;&#125; Line(Point _s,Point _e)&#123; s=_s;e=_e; &#125; &#125;line[maxn];//判断两线段是否相交 bool inter(Line l1,Line l2)&#123;// cout&lt;&lt;"L1 "&lt;&lt;l1.e.x&lt;&lt;","&lt;&lt;l1.e.y&lt;&lt;" "&lt;&lt;l1.s.x&lt;&lt;","&lt;&lt;l1.s.y&lt;&lt;endl;// cout&lt;&lt;"L2 "&lt;&lt;l2.e.x&lt;&lt;","&lt;&lt;l2.e.y&lt;&lt;" "&lt;&lt;l2.s.x&lt;&lt;","&lt;&lt;l2.s.y&lt;&lt;endl; return ( //根据题目要求端点相交是否算作相交来决定大于等于和小于等于 //排斥实验 max(l1.s.x,l1.e.x)&gt;=min(l2.s.x,l2.e.x) &amp;&amp; max(l2.s.x,l2.e.x)&gt;=min(l1.s.x,l1.e.x) &amp;&amp; max(l1.s.y,l1.e.y)&gt;=min(l2.s.y,l2.e.y) &amp;&amp; max(l2.s.y,l2.e.y)&gt;=min(l1.s.y,l1.e.y) &amp;&amp; //跨立实验 dcmp((l2.s-l1.s)^(l1.s-l1.e))*dcmp((l2.e-l1.s)^(l1.s-l1.e))&lt;0 &amp;&amp; dcmp((l1.s-l2.s)^(l2.s-l2.e))*dcmp((l1.e-l2.s)^(l2.s-l2.e))&lt;0 ) ;&#125;bool inter(Point a1,Point a2,Point b1,Point b2)&#123; Line l1(a1,a2),l2(b1,b2); return inter(l1,l2);&#125;bool cmp(Point a,Point b)&#123; if(a.x==b.x) return a.y&lt;b.y; else return a.x&lt;b.x;&#125;//求两直线交点Point getinter(Line l1,Line l2)&#123;Vector v=l1.s-l1.e;Vector w=l2.s-l2.e;Vector u=l1.e-l2.e;double t=cross(w,u)/cross(v,w);return l1.e+v*t;&#125; Point getinter(Point a1,Point a2,Point b1,Point b2)&#123;Line l1(a1,a2);Line l2(b1,b2);return getinter(l1,l2);&#125;//判定点和线段的关系，//0:不在线段所在直线上//1:在线段内（不含端点） //2:在线段端点//3:在线段两侧的射线上 int online(Point a,Line l)&#123; if(dcmp(cross(l.s-a,l.e-a))!=0) return 0; double pans=dcmp(dot(l.s-a,l.e-a));// cout&lt;&lt;(l.s-a).x&lt;&lt;","&lt;&lt;(l.s-a).y&lt;&lt;" "&lt;&lt;(l.e-a).x&lt;&lt;","&lt;&lt;(l.e-a).y&lt;&lt;endl; if(pans&lt;0) return 1; else if(pans==0) return 2; else if(pans&gt;0) return 3;&#125;int online(Point a,Point b1,Point b2)&#123; Line l(b1,b2); return online(a,l);&#125;//凸包int ConvexHull(Point *p,int n,Point *ch)&#123; sort(p,p+n,cmp); int m=0; for(int i=0;i&lt;n;i++)&#123; while(m&gt;1 &amp;&amp; cross(ch[m-1]-ch[m-2],p[i]-ch[m-2])&lt;=0) m--; ch[m++]=p[i]; &#125; int k=m; for(int i=n-2;i&gt;=0;i--)&#123; while(m&gt;k &amp;&amp; cross(ch[m-1]-ch[m-2],p[i]-ch[m-2])&lt;=0) m--; ch[m++]=p[i]; &#125; if(n&gt;1) m--; return m;&#125; int main()&#123; cin&gt;&gt;n; cout&lt;&lt;"INTERSECTING LINES OUTPUT"&lt;&lt;endl; rep(i,0,n)&#123; Line l1,l2; cin&gt;&gt;l1.e.x&gt;&gt;l1.e.y&gt;&gt;l1.s.x&gt;&gt;l1.s.y&gt;&gt;l2.e.x&gt;&gt;l2.e.y&gt;&gt;l2.s.x&gt;&gt;l2.s.y; Vector v1=l1.s-l1.e; Vector v2=l2.s-l2.e; if(dcmp(cross(v1,v2))==0) &#123; Vector v3=l1.s-l2.e; if(dcmp(cross(v1,v3))==0) cout&lt;&lt;"LINE"&lt;&lt;endl; else cout&lt;&lt;"NONE"&lt;&lt;endl; continue; &#125; Point in=getinter(l1,l2); cout&lt;&lt;"POINT "&lt;&lt;fixed&lt;&lt;setprecision(2)&lt;&lt;in.x&lt;&lt;" "&lt;&lt;in.y&lt;&lt;endl; &#125; cout&lt;&lt;"END OF OUTPUT"&lt;&lt;endl;&#125; 收获与反思 第一次接触计算几何，模板积累。]]></content>
      <categories>
        <category>编程</category>
        <category>ACM</category>
      </categories>
      <tags>
        <tag>算法</tag>
        <tag>ACM</tag>
        <tag>2018暑假集训</tag>
        <tag>计算几何</tag>
        <tag>POJ</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[【POJ-1066】解题报告（计算几何，线段交点）]]></title>
    <url>%2Fpost%2F9c28a880.html</url>
    <content type="text"><![CDATA[原始题目Treasure Hunt Time Limit: 1000MS Memory Limit: 10000K Total Submissions: 7927 Accepted: 3269 DescriptionArcheologists from the Antiquities and Curios Museum (ACM) have flown to Egypt to examine the great pyramid of Key-Ops. Using state-of-the-art technology they are able to determine that the lower floor of the pyramid is constructed from a series of straightline walls, which intersect to form numerous enclosed chambers. Currently, no doors exist to allow access to any chamber. This state-of-the-art technology has also pinpointed the location of the treasure room. What these dedicated (and greedy) archeologists want to do is blast doors through the walls to get to the treasure room. However, to minimize the damage to the artwork in the intervening chambers (and stay under their government grant for dynamite) they want to blast through the minimum number of doors. For structural integrity purposes, doors should only be blasted at the midpoint of the wall of the room being entered. You are to write a program which determines this minimum number of doors. An example is shown below: InputThe input will consist of one case. The first line will be an integer n (0 ≤ n ≤ 30) specifying number of interior walls, followed by n lines containing integer endpoints of each wall x1 y1 x2 y2 . The 4 enclosing walls of the pyramid have fixed endpoints at (0,0); (0,100); (100,100) and (100,0) and are not included in the list of walls. The interior walls always span from one exterior wall to another exterior wall and are arranged such that no more than two walls intersect at any point. You may assume that no two given walls coincide. After the listing of the interior walls there will be one final line containing the floating point coordinates of the treasure in the treasure room (guaranteed not to lie on a wall). OutputPrint a single line listing the minimum number of doors which need to be created, in the format shown below. Sample Input7 20 0 37 100 40 0 76 100 85 0 0 75 100 90 0 90 0 71 100 61 0 14 100 38 100 47 47 100 54.5 55.4 Sample OutputNumber of doors = 2 SourceEast Central North America 1999 题目大意在一个100*100的正方形区域中，有n条两端点均在正方形边界的墙将区域分成许多个部分（房间），已知可以破坏每个区域房间墙壁的中点，区域中某个点是宝藏，问从外界到宝藏处最少需要破坏多少个墙壁。 解题思路 由于破坏墙中点后就可以移动到左右端点，故实际上破坏位置在不在中点没有区别。 不可能绕开墙壁，所以走直线最近，每个墙壁最多只会遭遇一次。 所以等价从边界上每个墙壁的端点到宝藏位置连一条线段，和其他线段的交点（严格相交）+1就是所求答案。 利用计算几何中的判断线段是否相交的函数。 解题代码123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147148149150151152153154155156157158159160161162163164165166167168169170171172//计算几何模板，二维几何基础//使用印用注意避免直接在程序中调用构造函数构造无名对象。否则可能会导致程序出错 //#include &lt;bits/stdc++.h&gt;#include &lt;cstdio&gt;#include &lt;cmath&gt;#include &lt;cstdlib&gt;#include &lt;cstring&gt;#include &lt;iostream&gt;#include &lt;set&gt;#include &lt;iomanip&gt;#include &lt;algorithm&gt;#include &lt;queue&gt;#include &lt;map&gt;#include &lt;string&gt;#define INF 0x3f3f3f3f#define rep(i,a,n) for(int i=a;i&lt;n;i++)#define per(i,a,n) for(int i=n-1;i&gt;=a;i--)using namespace std;typedef long long ll;const double eps =1e-10;const int maxn=50;int n;//有的命名为sgn函数，高精度符号判断 int dcmp(double x)&#123; //相等函数判断，减少精度问题 if(fabs(x)&lt;eps) return 0; else return x&lt;0?-1:1;&#125;//点的定义 class Point&#123; public: double x,y; Point (double x=0,double y=0):x(x),y(y)&#123;&#125; //构造函数，方便代码的编写 &#125;point[maxn]; typedef Point Vector;// 从程序实现上，Vector只是Point的别名//运算符重载 Vector operator + (const Vector &amp;A,const Vector &amp;B) &#123; return Vector(A.x+B.x,A.y+B.y); &#125; //向量+向量=向量，点+向量=点Vector operator - (const Vector &amp;A,const Vector &amp;B) &#123; return Vector(A.x-B.x,A.y-B.y); &#125; //向量-向量=向量，点-向量-点 Vector operator * (const Vector &amp;A,double p) &#123; return Vector(A.x*p,A.y*p); &#125; //向量*数=向量 （数乘） Vector operator / (const Vector &amp;A,double p) &#123; return Vector(A.x/p,A.y/p); &#125; //向量/数=向量 （数除）double operator * (const Vector &amp;A,const Vector &amp;B) &#123; return A.x*B.x+A.y*B.y; &#125; //向量（点乘）向量=数 （点乘）bool operator &lt; (const Point &amp;A,const Point &amp;B) &#123; return A.x==B.x?A.y&lt;B.y:A.x&lt;B.x; &#125; //按x值递增排序 bool operator == (const Point &amp;A,const Point &amp;B) &#123; return dcmp(A.x-B.x)==0&amp;&amp; dcmp(A.y-B.y)==0; &#125; //判定两个点是否相同，用到dcmp精度判定 //点乘叉乘 double dot(const Vector &amp;A,const Vector &amp;B)&#123; return A.x*B.x+A.y*B.y; &#125; //向量（叉乘）向量=向量 （叉乘） double operator ^ (const Vector &amp;A,const Vector &amp;B)&#123; return A.x*B.y-A.y*B.x; &#125;double cross(const Vector &amp;A,const Vector &amp;B)&#123; return A.x*B.y-A.y*B.x; &#125;//模长面积 double abs(const Vector &amp;A)&#123; return sqrt(dot(A,A));&#125; //计算向量模长 double area2(const Point &amp;A,const Point &amp;B,const Point &amp;C)&#123; return cross(B-A,C-A) ;&#125; //计算平行四边形方向面积double PolygonArea(Point *p,int n) &#123; double area=0; rep(i,1,n-1)&#123;area+=cross(p[i]-p[0],p[i+1]-p[0]);&#125;return area/2.0; &#125; //计算多边形的有向面积//旋转Vector rotate(Vector A,double rad) &#123; return Vector(A.x*cos(rad)-A.y*sin(rad),A.x*sin(rad)+A.y*cos(rad));&#125; //旋转rad弧度 Vector normal(Vector A)&#123;double l=abs(A);return Vector(-A.y/l,A.x/l);&#125; //计算单位法线，左转90//线段定义 class Line &#123; public: Point s,e; Line()&#123;&#125; Line(Point _s,Point _e)&#123; s=_s;e=_e; &#125; &#125;line[maxn];//判断两线段是否相交 bool inter(Line l1,Line l2)&#123;// cout&lt;&lt;"L1 "&lt;&lt;l1.e.x&lt;&lt;","&lt;&lt;l1.e.y&lt;&lt;" "&lt;&lt;l1.s.x&lt;&lt;","&lt;&lt;l1.s.y&lt;&lt;endl;// cout&lt;&lt;"L2 "&lt;&lt;l2.e.x&lt;&lt;","&lt;&lt;l2.e.y&lt;&lt;" "&lt;&lt;l2.s.x&lt;&lt;","&lt;&lt;l2.s.y&lt;&lt;endl; return ( //根据题目要求端点相交是否算作相交来决定大于等于和小于等于 //排斥实验 max(l1.s.x,l1.e.x)&gt;=min(l2.s.x,l2.e.x) &amp;&amp; max(l2.s.x,l2.e.x)&gt;=min(l1.s.x,l1.e.x) &amp;&amp; max(l1.s.y,l1.e.y)&gt;=min(l2.s.y,l2.e.y) &amp;&amp; max(l2.s.y,l2.e.y)&gt;=min(l1.s.y,l1.e.y) &amp;&amp; //跨立实验 dcmp((l2.s-l1.s)^(l1.s-l1.e))*dcmp((l2.e-l1.s)^(l1.s-l1.e))&lt;0 &amp;&amp; dcmp((l1.s-l2.s)^(l2.s-l2.e))*dcmp((l1.e-l2.s)^(l2.s-l2.e))&lt;0 ) ;&#125;bool inter(Point a1,Point a2,Point b1,Point b2)&#123; Line l1(a1,a2),l2(b1,b2); return inter(l1,l2);&#125;bool cmp(Point a,Point b)&#123; if(a.x==b.x) return a.y&lt;b.y; else return a.x&lt;b.x;&#125;//求两直线交点Point getinter(Line l1,Line l2)&#123;Vector v=l1.s-l1.e;Vector w=l2.s-l2.e;Vector u=l1.e-l2.e;double t=cross(w,u)/cross(v,w);return l1.e+v*t;&#125; Point getinter(Point a1,Point a2,Point b1,Point b2)&#123;Line l1(a1,a2);Line l2(b1,b2);return getinter(l1,l2);&#125;//判定点和线段的关系，//0:不在线段所在直线上//1:在线段内（不含端点） //2:在线段端点//3:在线段两侧的射线上 int online(Point a,Line l)&#123; if(dcmp(cross(l.s-a,l.e-a))!=0) return 0; double pans=dcmp(dot(l.s-a,l.e-a));// cout&lt;&lt;(l.s-a).x&lt;&lt;","&lt;&lt;(l.s-a).y&lt;&lt;" "&lt;&lt;(l.e-a).x&lt;&lt;","&lt;&lt;(l.e-a).y&lt;&lt;endl; if(pans&lt;0) return 1; else if(pans==0) return 2; else if(pans&gt;0) return 3;&#125;int online(Point a,Point b1,Point b2)&#123; Line l(b1,b2); return online(a,l);&#125;//凸包int ConvexHull(Point *p,int n,Point *ch)&#123; sort(p,p+n,cmp); int m=0; for(int i=0;i&lt;n;i++)&#123; while(m&gt;1 &amp;&amp; cross(ch[m-1]-ch[m-2],p[i]-ch[m-2])&lt;=0) m--; ch[m++]=p[i]; &#125; int k=m; for(int i=n-2;i&gt;=0;i--)&#123; while(m&gt;k &amp;&amp; cross(ch[m-1]-ch[m-2],p[i]-ch[m-2])&lt;=0) m--; ch[m++]=p[i]; &#125; if(n&gt;1) m--; return m;&#125; int main()&#123; cin&gt;&gt;n; rep(i,0,n)&#123; cin&gt;&gt;line[i].e.x&gt;&gt;line[i].e.y&gt;&gt;line[i].s.x&gt;&gt;line[i].s.y; &#125; cin&gt;&gt;point[0].x&gt;&gt;point[0].y; if(n==0) cout&lt;&lt;"Number of doors = 1"&lt;&lt;endl; else&#123; int ans=INF; rep(i,0,n)&#123; int cnt=0; Point pn=line[i].e; Line ln(point[0],pn); rep(j,0,n)&#123; if(inter(ln,line[j])) cnt++; &#125;// cout&lt;&lt;"p1 "&lt;&lt;cnt&lt;&lt;endl; ans=min(ans,cnt); cnt=0; pn=line[i].s; ln.s=point[0];ln.e=pn; rep(j,0,n)&#123; if(inter(ln,line[j])) cnt++; &#125; ans=min(ans,cnt);// cout&lt;&lt;"p2 "&lt;&lt;cnt&lt;&lt;endl; &#125; cout&lt;&lt;"Number of doors = "&lt;&lt;ans+1&lt;&lt;endl; &#125; &#125; 收获与反思 第一次接触计算几何，模板积累。]]></content>
      <categories>
        <category>编程</category>
        <category>ACM</category>
      </categories>
      <tags>
        <tag>算法</tag>
        <tag>ACM</tag>
        <tag>2018暑假集训</tag>
        <tag>计算几何</tag>
        <tag>POJ</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[【HDU-6322】解题报告（数论，2018杭电多校第三场）]]></title>
    <url>%2Fpost%2Fe8ae7612.html</url>
    <content type="text"><![CDATA[原始题目Problem D. Euler Function Time Limit: 2000/1000 MS (Java/Others) Memory Limit: 524288/524288 K (Java/Others) Total Submission(s): 150 Accepted Submission(s): 136 Problem DescriptionIn number theory, Euler’s totient function $\varphi(n)$ counts the positive integers up to a given integer $n$ that are relatively prime to $n$. It can be defined more formally as the number of integers $k$ in the range $1\leq k\leq n$ for which the greatest common divisor $\gcd(n, k)$ is equal to $1$. For example, $\varphi(9) = 6$ because $1,2,4,5,7$ and $8$ are coprime with $9$. As another example, $\varphi(1) = 1$ since for $n = 1$ the only integer in the range from $1$ to $n$ is 1 itself, and $\gcd(1, 1) = 1$ . A composite number is a positive integer that can be formed by multiplying together two smaller positive integers. Equivalently, it is a positive integer that has at least one divisor other than $1$ and itself. So obviously $1$ and all prime numbers are not composite number. In this problem, given integer $k$, your task is to find the $k$-th smallest positive integer n, that $\varphi(n)$ is a composite number. InputThe first line of the input contains an integer $T(1\leq T\leq100000)$, denoting the number of test cases.In each test case, there is only one integer $k(1\leq k\leq 10^9)$. OutputFor each test case, print a single line containing an integer, denoting the answer. Sample Input2 1 2 Sample Output5 7 Source2018 Multi-University Training Contest 3 Recommendchendu 题目大意求第k个正整数n，其欧拉函数$\varphi(n)$为合数。 解题思路 数论题 手写一下，发现数稍微大便全是合数。反向考虑$\varphi(n)$为质数。 已知$\varphi(n) = p_1^{k_1-1}(p_1-1)p_2^{k_2-1}(p_2-1)\cdots$，其中$\gcd(p_1, p_2 \cdots)=1$。分情况讨论： 情况1：$n$为$p^k$形式，即只有一个质因子。 子情况1.1：该质因子为$2$，那么要使$\varphi(n)$为质数，则$p^{k-1}$为质数，很明显$k=1,2$，所以该情况下$n$只能为$2,4$ 子情况1.2：该质因数不为$2$，那么要使$\varphi(n)$为质数，$p-1$也得为质数，很明显成立的只有$3$（相邻两个数均为质数） 情况2：$n$由两个质因子构成。 子情况1.1：其中一个为$2$，由于另一个会贡献一个$2$，要使$\varphi(n)$为质数,则$2$质因数指数只能为$1$，另一质因数只能为$3$，指数只能为$1$。 子情况2.2：均不为$2$，那么两个质因子各贡献一个$2$，那么$\varphi(n)$一定为4的倍数，不为质数。 当$n=1,2,3,4,6$时，$\varphi(n)$为质数。 解题代码12345678910111213141516#include&lt;bits/stdc++.h&gt;using namespace std;int main()&#123; int T; long long k; cin&gt;&gt;T; while(T--) &#123; cin&gt;&gt;k; if(k==1) cout&lt;&lt;5&lt;&lt;endl; else cout&lt;&lt;k+5&lt;&lt;endl; &#125; return 0;&#125; 收获与反思 数论先推前几项再分析 掌握欧拉函数的计算方法和性质。]]></content>
      <categories>
        <category>编程</category>
        <category>ACM</category>
      </categories>
      <tags>
        <tag>算法</tag>
        <tag>ACM</tag>
        <tag>2018暑假集训</tag>
        <tag>数论</tag>
        <tag>HDU</tag>
        <tag>2018杭电多校</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[【CSU-2059】解题报告（递推，几何）]]></title>
    <url>%2Fpost%2F34f53a10.html</url>
    <content type="text"><![CDATA[HDU-2050变式拓展 原始题目2059: Water Problem Time Limit: 1 Sec Memory Limit: 128 Mb Submitted: 576 Solved: 199 Description​ 一条‘Z’形线可以将平面分为两个区域，那么由N条Z形线所定义的区域的最大个数是多少呢？每条Z形线由两条平行的无限半直线和一条直线段组成 Input首先输入一个数字T（T&lt;100），代表有T次询问 每次询问输入一个数字N（N&lt;1e8），代表有N条Z形线 Output对于每次询问，在一行输出N条‘Z’形线所能划分的区域的最大个数为多少 Sample Input2 1 2 Sample Output2 12 Hint SourceAuthorcsutsz 题目大意如题 解题思路 先推导递推式，由于数据量大，再推导通项公式最后直接输出。 分析：第i条z形线比第i-1条z形线新分成的最多区域数为新增最多交点个数+1 第i条线最多与前i-1条z形线交 $4*(i-1)$ 个点。dp[i]=dp[i-1]+4\*(i-1)+! , dp[1]=2 所以得到通项公式dp[i]=\frac{9\*(i-1)\*(i)}{2}+i+1 解题代码123456789101112131415161718192021222324252627#include &lt;cstdio&gt;#include &lt;cstring&gt;#include &lt;iostream&gt;#include &lt;set&gt;#include &lt;algorithm&gt;#include &lt;queue&gt;#include &lt;map&gt;#include &lt;string&gt;#define eps 1e-8#define INF 0x3f3f3f3f#define rep(i,a,n) for(int i=a;i&lt;n;i++)#define per(i,a,n) for(int i=n-1;i&gt;=a;i--)using namespace std;const int maxn=1e8+2;typedef long long ll;using namespace std;int main()&#123; int t; cin&gt;&gt;t; for(ll i=0;i&lt;t;i++)&#123; ll a; cin&gt;&gt;a; if(a==1) cout&lt;&lt;2&lt;&lt;endl; else cout&lt;&lt;9*(a-1)*(a)/2+a+1&lt;&lt;endl; &#125;&#125; 收获与反思 折线，z形线，类似的都转化到与新增交点数的关系。]]></content>
      <categories>
        <category>编程</category>
        <category>ACM</category>
      </categories>
      <tags>
        <tag>ACM</tag>
        <tag>CSU</tag>
        <tag>2018暑假集训</tag>
        <tag>递推</tag>
        <tag>几何</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[【ZOJ-1633】解题报告（字符串递推，二分查找）]]></title>
    <url>%2Fpost%2F5e189593.html</url>
    <content type="text"><![CDATA[原始题目Big String Time Limit: 2 Seconds Memory Limit: 65536 KB We will construct an infinitely long string from two short strings: A = “^__^” (four characters), and B = “T.T” (three characters). Repeat the following steps: Concatenate A after B to obtain a new string C. For example, if A = “^__^” and B = “T.T”, then C = BA = “T.T^__^”. Let A = B, B = C — as the example above A = “T.T”, B = “T.T^__^”. Your task is to find out the n-th character of this infinite string. InputThe input contains multiple test cases, each contains only one integer $N (1 \le N \le 2^{63} - 1)$. Proceed to the end of file. OutputFor each test case, print one character on each line, which is the N-th (index begins with 1) character of this infinite string. Sample Input1 2 4 8 Sample OutputT . ^ T Author:CHENG, Long Source:Zhejiang University Local Contest 2003 题目大意由A=”^__^” ， B=”T.T” ， C=BA=”T.T^__^” ，再令C=B, B=A，重复这种操作，问如此构成的字符串第n个字符是什么。 解题思路 $dp[i]$ 表示第i个字符串由多少个字符构成，已知$dp[0]=4,dp[1]=3,dp[2]=7$，根据递推规则可知$dp[i+1]=dp[i]+dp[i-1]$ 折半查找第一个比n大的dp[i]，则第i串里的第n位与第i-1串里的第n-dp[i-1]（可以保证这一项大于零）位对应字符相同。递归操作直至n&lt;7。从”T.T^__^”寻找就可以了 解题代码123456789101112131415161718192021222324252627282930313233343536#include &lt;cstdio&gt;#include &lt;cstring&gt;#include &lt;iostream&gt;#include &lt;set&gt;#include &lt;algorithm&gt;#include &lt;queue&gt;#include &lt;map&gt;#include &lt;string&gt;#define eps 1e-8#define INF 0x3f3f3f3f#define rep(i,a,n) for(int i=a;i&lt;n;i++)#define per(i,a,n) for(int i=n-1;i&gt;=a;i--)using namespace std;using namespace std;typedef long long ll;ll a[95]; //保存字符串的长度int main()&#123; string C = "T.T^__^"; a[0] = 4; a[1] = 3; int i; for(i = 2; i &lt; 90; i++) a[i] = a[i-1] + a[i-2]; ll n; while(cin &gt;&gt; n) &#123; while(n &gt; 7) &#123; int pos = lower_bound(a, a+89, n) - a; n -= a[pos-1]; &#125; cout &lt;&lt; C[n-1] &lt;&lt; endl; &#125; return 0;&#125; 收获与反思 二分查找与递推的结合]]></content>
      <categories>
        <category>编程</category>
        <category>ACM</category>
      </categories>
      <tags>
        <tag>算法</tag>
        <tag>ACM</tag>
        <tag>2018暑假集训</tag>
        <tag>递推</tag>
        <tag>ZOJ</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[【CSU-1587】解题报告（递推，水题）]]></title>
    <url>%2Fpost%2F31f89579.html</url>
    <content type="text"><![CDATA[原始题目1587: 爬楼梯 Time Limit: 1 Sec Memory Limit: 128 Mb Submitted: 867 Solved: 514 Description小时候我们都玩过爬楼梯的游戏：两人猜拳，赢了可向上爬一级，谁先到最高级则获胜。作为大学生，我们应该玩一个更有水平的游戏。现在一个人要上n级楼梯，每一步可以选择上一级或者上两级，但是不能后退。求上这n级楼梯的方案数。 Input第一行只有一个整数$T(1 \le T \le 45)$，表示数据组数。下面的T行每一行有一个整数$ n ( 1 \le n \le 45)$ ，表示有多少级楼梯。 Output对于每一组数据输出一个整数s，表示方案数。 Sample Input4 1 2 3 4 Sample Output1 2 3 5 HintSource国防科学技术大学第十八届银河之光文化节ACM程序设计竞赛初赛 题目大意如题 解题思路 到第i级阶梯可由第i-1级阶梯爬一级或由第i-2级解题爬两层。 解题代码12345678910111213141516171819202122232425262728293031323334353637#include &lt;cstdio&gt;#include &lt;cstring&gt;#include &lt;iostream&gt;#include &lt;set&gt;#include &lt;algorithm&gt;#include &lt;queue&gt;#include &lt;map&gt;#include &lt;string&gt;#define eps 1e-8#define INF 0x3f3f3f3f#define rep(i,a,n) for(int i=a;i&lt;n;i++)#define per(i,a,n) for(int i=n-1;i&gt;=a;i--)using namespace std;const int maxn=1e5+5;typedef long long ll;ll dp[maxn];void solve()&#123; memset(dp,0,sizeof(dp)); dp[1]=1; dp[2]=2; rep(i,3,50)&#123; dp[i]=dp[i-1]+dp[i-2]; &#125; &#125;using namespace std;int main()&#123; int t; solve(); while(cin&gt;&gt;t)&#123; rep(i,0,t)&#123; ll a; cin&gt;&gt;a; cout&lt;&lt;dp[a]&lt;&lt;endl; &#125; &#125;&#125; 收获与反思暂无，水题]]></content>
      <categories>
        <category>编程</category>
        <category>ACM</category>
      </categories>
      <tags>
        <tag>算法</tag>
        <tag>ACM</tag>
        <tag>CSU</tag>
        <tag>2018暑假集训</tag>
        <tag>递推</tag>
        <tag>水题</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[【UVA-12034】解题报告（递推，DP）]]></title>
    <url>%2Fpost%2F5f341cbe.html</url>
    <content type="text"><![CDATA[原始题目12034 - Race Time limit: 1.000 seconds Disky and Sooma, two of the biggest mega minds of Bangladesh went to a far country. They ate, codedand wandered around, even in their holidays. They passed several months in this way. But everythinghas an end. A holy person, Munsiji came into their life. Munsiji took them to derby (horse racing).Munsiji enjoyed the race, but as usual Disky and Sooma did their as usual task instead of passing someromantic moments. They were thinking- in how many ways a race can finish! Who knows, maybe thisis their romance! In a race there are n horses. You have to output the number of ways the race can finish. Note that,more than one horse may get the same position. For example, 2 horses can finish in 3 ways. Both first horse1 first and horse2 second horse2 first and horse1 second InputInput starts with an integer T (≤ 1000), denoting the number of test cases. Each case starts with aline containing an integer n (1 ≤ n ≤ 1000). OutputFor each case, print the case number and the number of ways the race can finish. The result can bevery large, print the result modulo 10056. Sample Input3 1 2 3 Sample OutputCase 1: 1 Case 2: 3 Case 3: 13 题目大意一场赛马比赛中由n匹马，任意两匹马可以同时到达或者一先一后到达，问一共有多少种到达的可能。 解题思路 考虑dp。 $dp[i][j]$表示i匹马用j次到达的可能情况数。 考虑第i匹马的情况，可能和前i-1匹马一同到达，或者单独到达（即第i匹马到达时有并列，无并列）。$dp[i][j]=j*(dp[i-1][j]+dp[i-1][j-1])$，乘j是因为第i匹马名次有j种可能。 解题代码12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849#include &lt;cstdio&gt;#include &lt;cstring&gt;#include &lt;iostream&gt;#include &lt;set&gt;#include &lt;algorithm&gt;#include &lt;queue&gt;#include &lt;map&gt;#include &lt;string&gt;#define eps 1e-8#define INF 0x3f3f3f3f#define rep(i,a,n) for(int i=a;i&lt;n;i++)#define per(i,a,n) for(int i=n-1;i&gt;=a;i--)using namespace std;const int maxn=1e8+2;const int mod=10056;typedef long long ll;ll dp[1005][1005];ll ans[1005];int main()&#123; int t; memset(dp,0,sizeof(dp)); memset(ans,0,sizeof(ans)); dp[1][1]=1; ans[1]=1; for(int i=2;i&lt;=1000;i++)&#123; int sum=0; for(int j=1;j&lt;=i;j++)&#123; if(j==1) dp[i][j]=1; else dp[i][j]=j*(dp[i-1][j]+dp[i-1][j-1])%mod; sum=(sum+dp[i][j])%mod;// cout&lt;&lt;"ans["&lt;&lt;i&lt;&lt;"]="&lt;&lt;ans[i]&lt;&lt;endl; &#125; ans[i]=sum;// cout&lt;&lt;i&lt;&lt;" "&lt;&lt;ans[i]&lt;&lt; " "&lt;&lt;ans[i-1]&lt;&lt;endl; &#125;// for(int i=2;i&lt;=1005;i++)&#123;// cout&lt;&lt;"i="&lt;&lt;i&lt;&lt;" "&lt;&lt;ans[i]&lt;&lt;endl; // &#125; cin&gt;&gt;t; int n,cas=1; while(t--) &#123; cin&gt;&gt;n; cout&lt;&lt;"Case "&lt;&lt;cas++&lt;&lt;": " &lt;&lt;ans[n]&lt;&lt;endl; &#125;&#125; 收获与反思注意取模的运算规则，考虑dp与最终答案的关系。]]></content>
      <categories>
        <category>编程</category>
        <category>ACM</category>
      </categories>
      <tags>
        <tag>算法</tag>
        <tag>ACM</tag>
        <tag>2018暑假集训</tag>
        <tag>递推</tag>
        <tag>UVA</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[【URAL-1081】解题报告（递推，斐波那契）]]></title>
    <url>%2Fpost%2F40dfaace.html</url>
    <content type="text"><![CDATA[题目大意1081. Binary Lexicographic Sequence Time limit: 0.5 second Memory limit: 64 MB Consider all the sequences with length (0 &lt; N &lt; 44), containing only the elements 0 and 1, and no two ones are adjacent (110 is not a valid sequence of length 3, 0101 is a valid sequence of length 4). Write a program which finds the sequence, which is on K-th place (0 &lt; K &lt; 109) in the lexicographically sorted in ascending order collection of the described sequences. InputThe first line of input contains two positive integers N and K. OutputWrite the found sequence or −1 if the number K is larger then the number of valid sequences. Sampleinput3 1 output000 Problem Author:Emil Kelevedzhiev Problem Source:Winter Mathematical Festival Varna ‘2001 Informatics Tournament 题目大意求词典序下第K个长度为N且无相邻位置都为1的0、1序列。无解时输出-1。 解题思路 先考虑长度为n的符合要求序列有多少个。 1（2个）:0 1 2（3个）:00 01 10 3（5个）:000 001 010 100 101 4（8个）:0000 0001 0010 0100 0101 1000 1001 1010 5（13个）:00000 00001 00010 00100 00101 01000 01001 01010 10000 10001 10010 10100 10101 发现规律，个数为斐波那契数列。构成原因：dp[k+1]的前dp[k]项为前面补0，后dp[k-1]项为前面补10 解题代码12345678910111213141516171819202122232425262728293031323334353637383940414243444546#include &lt;cstdio&gt;#include &lt;cstring&gt;#include &lt;iostream&gt;#include &lt;set&gt;#include &lt;algorithm&gt;#include &lt;queue&gt;#include &lt;map&gt;#include &lt;string&gt;#define eps 1e-8#define INF 0x3f3f3f3f#define rep(i,a,n) for(int i=a;i&lt;n;i++)#define per(i,a,n) for(int i=n-1;i&gt;=a;i--)using namespace std;typedef long long ll;const int maxn=1e5+5;ll n,k;ll dp[maxn];void solve()&#123; dp[0]=1; dp[1]=2; dp[2]=3; rep(i,3,50)&#123; dp[i]=dp[i-1]+dp[i-2]; &#125;&#125;int main()&#123; solve(); while(~scanf("%lld%lld",&amp;n,&amp;k))&#123; if(k&gt;dp[n])&#123; printf("-1\n"); &#125; else &#123; while(n) &#123; n--; if(k&lt;=dp[n])printf("0"); else &#123; printf("1"); k-=dp[n]; &#125; &#125; printf("\n"); &#125; &#125;&#125; 收获与反思 注意观察斐波那契数列]]></content>
      <categories>
        <category>编程</category>
        <category>ACM</category>
      </categories>
      <tags>
        <tag>算法</tag>
        <tag>ACM</tag>
        <tag>2018暑假集训</tag>
        <tag>递推</tag>
        <tag>URAL</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[【HDU-2018】解题报告（递推，水题）]]></title>
    <url>%2Fpost%2F36bef409.html</url>
    <content type="text"><![CDATA[原始题目母牛的故事 Time Limit: 2000/1000 MS (Java/Others) Memory Limit: 65536/32768 K (Java/Others) Total Submission(s): 105012 Accepted Submission(s): 51527 Problem Description有一头母牛，它每年年初生一头小母牛。每头小母牛从第四个年头开始，每年年初也生一头小母牛。请编程实现在第n年的时候，共有多少头母牛？ Input输入数据由多个测试实例组成，每个测试实例占一行，包括一个整数n(0&lt;n&lt;55)，n的含义如题目中描述。n=0表示输入数据的结束，不做处理。 Output对于每个测试实例，输出在第n年的时候母牛的数量。每个输出占一行。 Sample Input2 4 5 0 Sample Output2 4 6 Authorlcy SourceC语言程序设计练习（三） Recommendlcy 题目大意如题 解题思路 $b[i]$表示第i年的母牛数，$s[i]$表示第i年的小牛数。有$b[i]=b[i-1]+b[i-3]$;$s[i]=s[i-1]-b[i-3]+b[i]$; 即第i年的母牛等于i-1年的母牛数加上三年前母牛产的小牛数（今年长成母牛），第i年的小牛数等于第i-1年的小牛数减去三年前新产的小牛数（今年长成母牛）加上今年新产的小牛。 输出大小牛的和解题代码123456789101112131415161718192021222324252627282930313233343536#include &lt;cstdio&gt;#include &lt;cstring&gt;#include &lt;iostream&gt;#include &lt;set&gt;#include &lt;algorithm&gt;#include &lt;queue&gt;#include &lt;map&gt;#include &lt;string&gt;#define eps 1e-8#define INF 0x3f3f3f3f#define rep(i,a,n) for(int i=a;i&lt;n;i++)#define per(i,a,n) for(int i=n-1;i&gt;=a;i--)using namespace std;const int maxn=1e8+2;typedef long long ll;int b[100],s[100];void solve()&#123; b[1]=b[2]=b[3]=b[4]=1; s[1]=0; s[2]=1; s[3]=2; s[4]=3; for(int i=5;i&lt;55;i++)&#123; b[i]=b[i-1]+b[i-3]; s[i]=s[i-1]-b[i-3]+b[i]; &#125; &#125;int n;int main()&#123; solve(); while(cin&gt;&gt;n&amp;&amp;n)&#123; cout&lt;&lt;b[n]+s[n]&lt;&lt;endl; &#125;&#125; 收获与反思暂无]]></content>
      <categories>
        <category>编程</category>
        <category>ACM</category>
      </categories>
      <tags>
        <tag>算法</tag>
        <tag>ACM</tag>
        <tag>2018暑假集训</tag>
        <tag>递推</tag>
        <tag>水题</tag>
        <tag>HDU</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[【POJ-1664】解题报告（递推，dp）]]></title>
    <url>%2Fpost%2Fbde4b1f8.html</url>
    <content type="text"><![CDATA[原始题目放苹果 Time Limit: 1000MS Memory Limit: 10000K Total Submissions: 37069 Accepted: 22825 Description把M个同样的苹果放在N个同样的盘子里，允许有的盘子空着不放，问共有多少种不同的分法？（用K表示）5，1，1和1，5，1 是同一种分法。 Input第一行是测试数据的数目$ t(0 \le t \le 20)$。以下每行均包含二个整数M和N，以空格分开。 $ 1 \le M , N \le 10 $。 Output对输入的每组数据M和N，用一行输出相应的K。 Sample Input1 7 3 Sample Output8 Sourcelwx@POJ 题目大意如题 解题思路 $dp[i][j]$ 表示i个苹果j个盘子的分法。 状态转移： 当$i&lt;j$时，$dp[i][j]=dp[i][i]$ （不区分盘子，所以盘子多余的情况数和盘子恰好和苹果数相等的情况数相等） 当$i\geqslantj$，$dp[i][j]=dp[i-j][j]+dp[i][j-1]$ （每个盘子都有苹果和有一个盘子没有苹果两种状况转移）注意初始的情况就好。解题代码1234567891011121314151617181920212223242526272829303132333435363738394041424344454647#include &lt;cstdio&gt;#include &lt;cstring&gt;#include &lt;iostream&gt;#include &lt;set&gt;#include &lt;algorithm&gt;#include &lt;queue&gt;#include &lt;map&gt;#include &lt;string&gt;#define eps 1e-8#define INF 0x3f3f3f3f#define rep(i,a,n) for(int i=a;i&lt;n;i++)#define per(i,a,n) for(int i=n-1;i&gt;=a;i--)using namespace std;const int maxn=1e8+2;typedef long long ll;ll dp[22][22];void solve()&#123; memset(dp,0,sizeof(dp)); dp[0][0]=1; for(int i=0;i&lt;=21;i++)&#123; for(int j=0;j&lt;=21;j++)&#123; if(i==0) dp[i][j]=1; else if(j==0) dp[i][j]=0; else if(j==1) dp[i][j]=1; else &#123; if(i&lt;j) dp[i][j]=dp[i][i]; else dp[i][j]=dp[i][j-1]+dp[i-j][j]; &#125; &#125; &#125;&#125;int main()&#123; int t; solve(); while(cin&gt;&gt;t)&#123; int m,n; rep(i,0,t)&#123; cin&gt;&gt;m&gt;&gt;n; cout&lt;&lt;dp[m][n]&lt;&lt;endl; &#125; &#125;&#125; 收获与反思注意边界情况的考量]]></content>
      <categories>
        <category>编程</category>
        <category>ACM</category>
      </categories>
      <tags>
        <tag>算法</tag>
        <tag>ACM</tag>
        <tag>2018暑假集训</tag>
        <tag>递推</tag>
        <tag>dp</tag>
        <tag>POJ</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[【HDU-2050】解题报告（递推，几何）]]></title>
    <url>%2Fpost%2F38f8b110.html</url>
    <content type="text"><![CDATA[原始题目折线分割平面 Time Limit: 2000/1000 MS (Java/Others) Memory Limit: 65536/32768 K (Java/Others) Total Submission(s): 37773 Accepted Submission(s): 25282 Problem Description我们看到过很多直线分割平面的题目，今天的这个题目稍微有些变化，我们要求的是n条折线分割平面的最大数目。比如，一条折线可以将平面分成两部分，两条折线最多可以将平面分成7部分，具体如下所示。 Input输入数据的第一行是一个整数$C$,表示测试实例的个数，然后是$C$ 行数据，每行包含一个整数$n ( 0 &lt; n \le 10000)$,表示折线的数量。 Output对于每个测试实例，请输出平面的最大分割数，每个实例的输出占一行。 Sample Input2 1 2 Sample Output2 7 Authorlcy Source递推求解专题练习（For Beginner） Recommendlcy 题目大意如题 解题思路折线类题目思路： dp[i]=dp[i-1]+新增交点数+1 题目数据过大则先手算通项公式。数据小可以直接递推 解题代码 递推写法 12345678910111213141516171819202122232425262728293031323334353637#include &lt;cstdio&gt;#include &lt;cstring&gt;#include &lt;iostream&gt;#include &lt;set&gt;#include &lt;algorithm&gt;#include &lt;queue&gt;#include &lt;map&gt;#include &lt;string&gt;#define eps 1e-8#define INF 0x3f3f3f3f#define rep(i,a,n) for(int i=a;i&lt;n;i++)#define per(i,a,n) for(int i=n-1;i&gt;=a;i--)using namespace std;const int maxn=1e5+5;typedef long long ll;ll dp[maxn];void solve()&#123; memset(dp,0,sizeof(dp)); dp[1]=1; dp[2]=2; rep(i,3,50)&#123; dp[i]=dp[i-1]+dp[i-2]; &#125; &#125;using namespace std;int main()&#123; int t; solve(); while(cin&gt;&gt;t)&#123; rep(i,0,t)&#123; ll a; cin&gt;&gt;a; cout&lt;&lt;dp[a]&lt;&lt;endl; &#125; &#125;&#125; 通项写法 123456789101112131415161718192021222324252627282930#include &lt;cstdio&gt;#include &lt;cstring&gt;#include &lt;iostream&gt;#include &lt;set&gt;#include &lt;algorithm&gt;#include &lt;queue&gt;#include &lt;map&gt;#include &lt;string&gt;#define eps 1e-8#define INF 0x3f3f3f3f#define rep(i,a,n) for(int i=a;i&lt;n;i++)#define per(i,a,n) for(int i=n-1;i&gt;=a;i--)using namespace std;const int maxn=1e5+5;typedef long long ll;using namespace std;int main()&#123; int t; while(cin&gt;&gt;t)&#123; rep(i,0,t)&#123; ll a; cin&gt;&gt;a;// cout&lt;&lt;dp[a]&lt;&lt;endl; cout&lt;&lt;(2*a+1)*(a-1)+2&lt;&lt;endl; &#125; &#125;&#125; 收获与反思 Z形线拓展]]></content>
      <categories>
        <category>编程</category>
        <category>ACM</category>
      </categories>
      <tags>
        <tag>算法</tag>
        <tag>ACM</tag>
        <tag>2018暑假集训</tag>
        <tag>递推</tag>
        <tag>几何</tag>
        <tag>HDU</tag>
        <tag>待补充</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[【HDU-2044】解题报告（递推，水题）]]></title>
    <url>%2Fpost%2F52730f61.html</url>
    <content type="text"><![CDATA[原始题目一只小蜜蜂… Time Limit: 2000/1000 MS (Java/Others) Memory Limit: 65536/32768 K (Java/Others) Total Submission(s): 93384 Accepted Submission(s): 33247 Problem Description有一只经过训练的蜜蜂只能爬向右侧相邻的蜂房，不能反向爬行。请编程计算蜜蜂从蜂房a爬到蜂房b的可能路线数。其中，蜂房的结构如下所示。 Input输入数据的第一行是一个整数N,表示测试实例的个数，然后是N 行数据，每行包含两个整数a和b(0&lt;a&lt;b&lt;50)。 Output对于每个测试实例，请输出蜜蜂从蜂房a爬到蜂房b的可能路线数，每个实例的输出占一行。 Sample Input2 1 2 3 6 Sample Output1 3 Authorlcy Source递推求解专题练习（For Beginner） Recommendlcy 题目大意如题 解题思路递推，dp初步，$dp[i]=dp[i-1]+dp[i-2]$ 解题代码1234567891011121314151617181920212223242526272829303132333435363738394041#include &lt;cstdio&gt;#include &lt;cstring&gt;#include &lt;iostream&gt;#include &lt;set&gt;#include &lt;algorithm&gt;#include &lt;queue&gt;#include &lt;map&gt;#include &lt;string&gt;#define eps 1e-8#define INF 0x3f3f3f3f#define rep(i,a,n) for(int i=a;i&lt;n;i++)#define per(i,a,n) for(int i=n-1;i&gt;=a;i--)using namespace std;const int maxn=1e5+5;typedef long long ll;ll dp[100][100];int main()&#123; ll t; memset(dp,0,sizeof(dp)); dp[0][0]=dp[1][1]=0; for(ll i=1;i&lt;=50-1;i++)&#123; for(ll j=1;j&lt;=50;j++)&#123; if(i==j)dp[i][j]=0; else if(j==i+1) dp[i][j]=1; else if(j==i+2) dp[i][j]=2; else dp[i][j]=dp[i][j-1]+dp[i][j-2];// cout&lt;&lt;i&lt;&lt;" "&lt;&lt;j&lt;&lt;endl; &#125; &#125; while(cin&gt;&gt;t)&#123; ll a,b; rep(i,0,t)&#123; cin&gt;&gt;a&gt;&gt;b; cout&lt;&lt;dp[a][b]&lt;&lt;endl; &#125; &#125;&#125; 收获与反思没啥]]></content>
      <categories>
        <category>编程</category>
        <category>ACM</category>
      </categories>
      <tags>
        <tag>算法</tag>
        <tag>ACM</tag>
        <tag>2018暑假集训</tag>
        <tag>递推</tag>
        <tag>水题</tag>
        <tag>HDU</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[【POJ-3111】解题报告（二分，牛顿迭代，最大化平均值）]]></title>
    <url>%2Fpost%2F8f9cfad3.html</url>
    <content type="text"><![CDATA[原始题目K Best Time Limit: 8000MS Memory Limit: 65536K Total Submissions: 13510 Accepted: 3466 Case Time Limit: 2000MS Special Judge DescriptionDemy has $n$ jewels. Each of her jewels has some value $v_i$ and weight $w_i$. Since her husband John got broke after recent financial crises, Demy has decided to sell some jewels. She has decided that she would keep k best jewels for herself. She decided to keep such jewels that their specific value is as large as possible. That is, denote the specific value of some set of jewels S = {i1, i2, …, ik} as Demy would like to select such k jewels that their specific value is maximal possible. Help her to do so. InputThe first line of the input file contains $n$ — the number of jewels Demy got, and $k$ — the number of jewels she would like to keep $(1 ≤ k ≤ n ≤ 100 000)$. The following $n$ lines contain two integer numbers each — $v_i$ and $w_i$ $(0 ≤ v_i ≤ 10^6, 1 ≤ w_i ≤ 10^6$, both the sum of all $v_i$ and the sum of all $w_i$ do not exceed $10^7$). OutputOutput $k$ numbers — the numbers of jewels Demy must keep. If there are several solutions, output any one. Sample Input3 2 1 1 1 2 1 3 Sample Output1 2 SourceNortheastern Europe 2005, Northern Subregion 题目大意给定 $n$ 个珍珠的价值和重量，要求取其中 $k$ 个并使这 $k$ 个珍珠的平均单位重量价值最大。 解题思路 对平均单位重量价值二分（二分答案），每一次更新每个珍珠 $r_i=v_i-k*w_i$ 即对平均单位重量价值的差值。 排序后取差值最大的3个珍珠，若差值之和大于零（说明平均单位重量价值还不够大），left=mid，否则right=mid。逐渐逼近答案 解题代码123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657#include &lt;cstdio&gt;#include &lt;cstring&gt;#include &lt;iostream&gt;#include &lt;set&gt;#include &lt;algorithm&gt;#include &lt;queue&gt;#include &lt;map&gt;#include &lt;string&gt;#define eps 1e-8#define INF 0x3f3f3f3f#define rep(i,a,n) for(int i=a;i&lt;n;i++)#define per(i,a,n) for(int i=n-1;i&gt;=a;i--)using namespace std;const int maxn=1e5+5;double l,r,mid;int n,k;struct jewl&#123; int id; double vi,wi,ri; &#125;jewls[maxn];bool cmp(jewl a,jewl b)&#123; return a.ri&gt;b.ri;&#125;int main()&#123; while(~scanf("%d%d",&amp;n,&amp;k))&#123; rep(i,1,n+1)&#123; scanf("%lf%lf",&amp;jewls[i].vi,&amp;jewls[i].wi); jewls[i].id=i; &#125; l=0;r=INF; //开始二分寻找答案 while(r-l&gt;eps)&#123; mid=(l+r)/2; rep(i,1,n+1)&#123; jewls[i].ri=jewls[i].vi-mid*jewls[i].wi; &#125; sort(jewls+1,jewls+n+1,cmp); //寻找最大的k个 double sum=0; rep(i,1,k+1)&#123; sum+=jewls[i].ri; &#125; if(sum&gt;=0) l=mid; else r=mid; &#125; rep(i,1,k+1)&#123; if(i==1) printf("%d",jewls[i].id); else printf(" %d",jewls[i].id); &#125; printf("\n"); &#125;&#125; 收获与反思 浮点数二分 最大化平均值经典题。]]></content>
      <categories>
        <category>编程</category>
        <category>ACM</category>
      </categories>
      <tags>
        <tag>算法</tag>
        <tag>ACM</tag>
        <tag>二分</tag>
        <tag>2018暑假集训</tag>
        <tag>POJ</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[【POJ-2785】解题报告（二分水题）]]></title>
    <url>%2Fpost%2F16b5efde.html</url>
    <content type="text"><![CDATA[原始题目4 Values whose Sum is 0 Time Limit: 15000MS Memory Limit: 228000K Total Submissions: 28507 Accepted: 8591 Case Time Limit: 5000MS DescriptionThe SUM problem can be formulated as follows: given four lists A, B, C, D of integer values, compute how many quadruplet (a, b, c, d ) ∈ A x B x C x D are such that a + b + c + d = 0 . In the following, we assume that all lists have the same size n . InputThe first line of the input file contains the size of the lists n (this value can be as large as 4000). We then have n lines containing four integer values (with absolute value as large as $2^{28}$ ) that belong respectively to A, B, C and D . OutputFor each input file, your program has to write the number quadruplets whose sum is zero. Sample Input6 -45 22 42 -16 -41 -27 56 30 -36 53 -37 77 -36 30 -75 -46 26 -38 -10 62 -32 -54 -6 45 Sample Output5 HintSample Explanation: Indeed, the sum of the five following quadruplets is zero: (-45, -27, 42, 30), (26, 30, -10, -46), (-32, 22, 56, -46),(-32, 30, -75, 77), (-32, -54, 56, 30). SourceSouthwestern Europe 2005 题目大意给定四个长度为n的数列，从每一个数列中抽取一个数，问和为零的共有多少种可能。 解题思路 预处理出前两个数列的和sum1与后两个数列的和sum2。 对sum1排序，二分查找sum2中每个元素的相反数，累加输出 注意不要用binary_search函数，而应该用upper_bound - lower_bound ，因为可能sum1数列中有多个元素值均为 -sum2[i] 。如果用binary_search 只能得到是否有，计数会少计。 解题代码12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849#include &lt;cstdio&gt;#include &lt;cstdlib&gt;#include &lt;iostream&gt;#include &lt;cstring&gt;#include &lt;algorithm&gt;#include &lt;stack&gt;#include &lt;vector&gt;#include &lt;set&gt;#include &lt;map&gt;using namespace std;#define rep(i,a,n) for (int i=a;i&lt;n;i++)#define per(i,a,n) for (int i=n-1;i&gt;=a;i--)//#define pb push_back//#define mp make_pair//#define np next_permutation//#define all(x) x.begin(),x.end()//#define fi first//#define se second//#define SZ(x) ((int)(x).size()) //typedef vector &lt;int&gt; vi;typedef long long ll;//typedef pair &lt;int,int&gt; pii;const int mod=1e9+7;const int maxn=4100;ll sum1[maxn*maxn],sum2[maxn*maxn];ll a[maxn],b[maxn],c[maxn],d[maxn];int main()&#123; int n; while(~scanf("%d",&amp;n))&#123; rep(i,0,n)&#123; scanf("%lld %lld %lld %lld",&amp;a[i],&amp;b[i],&amp;c[i],&amp;d[i]); &#125; rep(i,0,n)&#123; rep(j,0,n)&#123; sum1[i*n+j]=a[i]+b[j]; sum2[i*n+j]=c[i]+d[j]; &#125; &#125; sort(sum1,sum1+n*n); ll ans=0; rep(i,0,n*n)&#123; ans+=(upper_bound(sum1,sum1+n*n,-sum2[i])-lower_bound(sum1,sum1+n*n,-sum2[i])); &#125; printf("%lld\n",ans); &#125;&#125; 收获与反思 加深STL里三个函数应用和相互区别。]]></content>
      <categories>
        <category>编程</category>
        <category>ACM</category>
      </categories>
      <tags>
        <tag>算法</tag>
        <tag>ACM</tag>
        <tag>二分</tag>
        <tag>水题</tag>
        <tag>POJ</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[【CodeForces-348A】解题报告（直接或二分）]]></title>
    <url>%2Fpost%2Fdea65d58.html</url>
    <content type="text"><![CDATA[原始题目A. Mafia time limit per test2 seconds memory limit per test256 megabytes input：standard input output：standard output One day n friends gathered together to play “Mafia”. During each round of the game some player must be the supervisor and other n - 1 people take part in the game. For each person we know in how many rounds he wants to be a player, not the supervisor: the i-th person wants to play ai rounds. What is the minimum number of rounds of the “Mafia” game they need to play to let each person play at least as many rounds as they want? InputThe first line contains integer $n (3 ≤ n ≤ 10^5)$. The second line contains $n$ space-separated integers $a_1, a_2 \cdots a_n (1 ≤ a_i ≤ 10^9)$ — the i-th number in the list is the number of rounds the i-th person wants to play. OutputIn a single line print a single integer — the minimum number of game rounds the friends need to let the i-th person play at least ai rounds. Please, do not use the %lld specifier to read or write 64-bit integers in С++. It is preferred to use the cin, cout streams or the %I64d specifier. Examplesinput3 3 2 2 output4 input4 2 2 2 2 output3 NoteYou don’t need to know the rules of “Mafia” to solve this problem. If you’re curious, it’s a game Russia got from the Soviet times: http://en.wikipedia.org/wiki/Mafia_(party_game). 题目大意$n$ 个人进行游戏，每局游戏需要1人监管，剩下 $n-1$ 人参与游戏，现在给出 $n$ 人每人想至少参与游戏的此数，求满足每个人要求的最少游戏盘数。 解题思路水题，可以直接解或者二分 解题代码1234567891011121314151617181920212223#include &lt;iostream&gt;#include &lt;cstdio&gt;#include &lt;cstdlib&gt;#include &lt;algorithm&gt;#include &lt;cstring&gt;#include &lt;cmath&gt;using namespace std;long long a[200010];int main()&#123; int n; long long sum=0,MAX=0; scanf("%d",&amp;n); for(int i=1;i&lt;=n;i++) &#123; scanf("%I64d",a+i); sum+=a[i]; MAX=max(a[i],MAX); &#125; long long ans; if(sum%(n-1)==0) ans=sum/(n-1); else ans=sum/(n-1)+1; ans=max(MAX,ans); printf("%I64d\n",ans);&#125; 收获与反思 二分做法，下界为数列最大值，上界为数列总和，做下面划分12if(mid*(n-1)&gt;=sum) ri=mid;else le=mid+1;]]></content>
      <categories>
        <category>编程</category>
        <category>ACM</category>
      </categories>
      <tags>
        <tag>算法</tag>
        <tag>ACM</tag>
        <tag>二分</tag>
        <tag>2018暑假集训</tag>
        <tag>水题</tag>
        <tag>CodeForces</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[【CodeForces-600B】解题报告（二分，stl二分函数应用）]]></title>
    <url>%2Fpost%2F5aa5290d.html</url>
    <content type="text"><![CDATA[原始题目B. Queries about less or equal elements time limit per test2 seconds memory limit per test256 megabytes input：standard input output：standard output You are given two arrays of integers $a$ and $b$. For each element of the second array $b_j$ you should find the number of elements in array $a$ that are less than or equal to the value $b_j$. InputThe first line contains two integers $n, m (1 ≤ n, m ≤ 2·10^5)$ — the sizes of arrays $a$ and $b$. The second line contains n integers — the elements of array $a ( - 10^9 ≤ ai ≤ 10^9)$. The third line contains m integers — the elements of array $b ( - 10^9 ≤ bj ≤ 10^9)$. OutputPrint m integers, separated by spaces: the j-th of which is equal to the number of such elements in array $a$ that are less than or equal to the value $b_j$. Examplesinput5 4 1 3 5 7 9 6 4 2 8 output3 2 1 4 input5 5 1 2 1 2 5 3 1 4 1 5 output4 2 4 2 5 题目大意给定$a,b$两个数列，对$b$中每一项$b_i$，求$a$中小于等于$b_i$的项的个数。 解题思路 排序后二分，由于寻找小于等于$b_i$的个数，使用stl里的upper_bound函数。 解题代码12345678910111213141516171819202122232425262728293031323334353637383940414243#include &lt;bits/stdc++.h&gt;using namespace std;#define rep(i,a,n) for (int i=a;i&lt;n;i++)#define per(i,a,n) for (int i=n-1;i&gt;=a;i--)#define pb push_back#define mp make_pair#define np next_permutation#define all(x) x.begin(),x.end()#define fi first#define se second#define SZ(x) (int(x).size())typedef long long ll;typedef vector &lt;int&gt; vi;typedef pair&lt;int,int&gt; pii;const int maxn=2e5+5; vector &lt;ll&gt; va,vb;ll pa,pb;ll n,m;int main()&#123; while(~scanf("%lld%lld",&amp;n,&amp;m))&#123; va.clear(); for(ll i=1;i&lt;=n;i++)&#123; scanf("%lld",&amp;pa); va.pb(pa); &#125; sort(all(va)); for(ll i=1;i&lt;=m;i++)&#123; if(i!=1) printf(" "); scanf("%lld",&amp;pb); if(pb&gt;=*(--va.end())) printf("%lld",n); else if(pb&lt;*(va.begin())) printf("0"); else&#123; ll c=upper_bound(all(va),pb)-va.begin(); printf("%lld",c); &#125; &#125; printf("\n"); &#125;&#125; 收获与反思 二分思想练习 upper_bound 与 lower_bound 使用的一些注意 前提： 数组是一个非降序列 参数： 一个数组元素的地址（或者数组名来表示这个数组的首地址，用来表示这个数组的开头比较的元素的地址，不一定要是首地址，只是用于比较的“首”地址）， 一个数组元素的地址（对应的这个数组里边任意一个元素的地址，表示这个二分里边的比较的”结尾’地址）， 一个你要二分查找的那个数。 返回值： 是地址，不是指那个要查找的数的下标，所以就注定了在这个函数的后边就要减去一个尾巴，那就是这个数组用来比较的头地址。 upper_bound 返回的是键值为i的元素可以插入的最后一个位置（上界） lowe_bound 返回的是键值为i的元素可以插入的位置的第一个位置（下界）。 举例在升序的set里面： set里没有元素i的时候，两个元素的返回值是一样的。 1 2 4 5 这个序列，upp（3）和low（3）都返回位置2（下标） 如果只有一个元素i，low返回那个元素的位置，而upp返回那个元素的位置的后一个位置。 1 2 4 5 这个序列upp（2）返回下标2而low（2）返回下标1 多个元素i，low返回那个元素的位置，upp返回那多个元素中的最后一个的后一个位置。 1 2 2 4 5 这个序列 upp（2）返回下标3的位置，low（2）返回下标1的位置。 不存在时的情况： 特别注意：在一个升序的容器里，如果所有元素都大于i则，upp和low都返回begin。都小于i则返回end（越界了）。]]></content>
      <categories>
        <category>编程</category>
        <category>ACM</category>
      </categories>
      <tags>
        <tag>算法</tag>
        <tag>ACM</tag>
        <tag>二分</tag>
        <tag>2018暑假集训</tag>
        <tag>CodeForces</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[【CSU-2092】解题报告（模拟，物理）]]></title>
    <url>%2Fpost%2F15db1cd9.html</url>
    <content type="text"><![CDATA[原始题目2092: Space Golf Time Limit: 1 Sec Memory Limit: 512 Mb Submitted: 77 Solved: 35 SpecialJudge Description You surely have never heard of this new planet surface exploration scheme, as it is being carried out in a project with utmost secrecy. The scheme is expected to cut costs of conventional rover-type mobile explorers considerably, using projected-type equipment nicknamed “observation bullets”. Bullets do not have any active mobile abilities of their own, which is the main reason of their cost-efficiency. Each of the bullets, after being shot out on a launcher given its initial velocity, makes a parabolic trajectory until it touches down. It bounces on the surface and makes another parabolic trajectory. This will be repeated virtually infinitely. We want each of the bullets to bounce precisely at the respective spot of interest on the planet surface, adjusting its initial velocity. A variety of sensors in the bullet can gather valuable data at this instant of bounce, and send them to the observation base. Although this may sound like a conventional target shooting practice, there are several issues that make the problem more difficult. There may be some obstacles between the launcher and the target spot. The obstacles stand upright and are very thin that we can ignore their widths. Once the bullet touches any of the obstacles, we cannot be sure of its trajectory thereafter. So we have to plan launches to avoid these obstacles. Launching the bullet almost vertically in a speed high enough, we can easily make it hit the target without touching any of the obstacles, but giving a high initial speed is energy-consuming. Energy is extremely precious in space exploration, and the initial speed of the bullet should be minimized. Making the bullet bounce a number of times may make the bullet reach the target with lower initial speed. The bullet should bounce, however, no more than a given number of times. Although the body of the bullet is made strong enough, some of the sensors inside may not stand repetitive shocks. The allowed numbers of bounces vary on the type of the observation bullets. You are summoned engineering assistance to this project to author a smart program that tells the minimum required initial speed of the bullet to accomplish the mission. Figure D.1 gives a sketch of a situation, roughly corresponding to the situation of the Sample Input 4 given below. Figure D.1. A sample situation You can assume the following. The atmosphere of the planet is so thin that atmospheric resistance can be ignored. The planet is large enough so that its surface can be approximated to be a completely flat plane. The gravity acceleration can be approximated to be constant up to the highest points a bullet can reach. These mean that the bullets fly along a perfect parabolic trajectory. You can also assume the following. The surface of the planet and the bullets are made so hard that bounces can be approximated as elastic collisions. In other words, loss of kinetic energy on bounces can be ignored. As we can also ignore the atmospheric resistance, the velocity of a bullet immediately after a bounce is equal to the velocity immediately after its launch. The bullets are made compact enough to ignore their sizes. The launcher is also built compact enough to ignore its height. You, a programming genius, may not be an expert in physics. Let us review basics of rigid-body dynamics. We will describe here the velocity of the bullet $v$ with its horizontal and vertical components $v_x$ and $v_y$ (positive meaning upward). The initial velocity has the components $v_{ix}$ and $v_{iy}$, that is, immediately after the launch of the bullet, $v_x = v_ix$ and $v_y = v_iy$ hold. We denote the horizontal distance of the bullet from the launcher as $x$ and its altitude as $y$ at time $t$. The horizontal velocity component of the bullet is kept constant during its flight when atmospheric resistance is ignored. Thus the horizontal distance from the launcher is proportional to the time elapsed. x=v_{ix}t \tag{1} The vertical velocity component vy is gradually decelerated by the gravity. With the gravity acceleration of g, the following differential equation holds during the flight. \frac{d{v_y}}{dt}=-g \tag{2}Solving this with the initial conditions of vy = viy and y = 0 when t = 0, we obtain the following. \begin{eqnarray} y&=&-\frac{1}{2}gt^2+v_{iy}t \tag{3} \\ &=&-(\frac{1}{2}gt-v_{iy})t \tag{4} \end{eqnarray}The equation (4) tells that the bullet reaches the ground again when $t = \frac{2v_{iy}}{g}$. Thus, the distance of the point of the bounce from the launcher is $\frac{2v_{ix}v_{iy}}{g}$. In other words, to make the bullet fly the distance of l, the two components of the initial velocity should satisfy $2v_{ix}v_{iy}= lg$. Eliminating the parameter t from the simultaneous equations above, we obtain the following equation that escribes the parabolic trajectory of the bullet. y=-(\frac{g}{2v_{ix}^2})x^2+(\frac{v_{iy}}{v_{ix}})x \tag{5}For ease of computation, a special unit system is used in this project, according to which the gravity acceleration g of the planet is exactly 1.0. InputThe input consists of several tests case with the following format. d\ n\ b \\ p_1\ h_1 \\ p_2\ h_2 \\ \vdots \\ p_n\ h_n \\For each test, the first line contains three integers, $d$, $n$, and $b$. Here, $d$ is the distance from the launcher to the target spot $(1 ≤ d ≤ 10000)$, $n$ is the number of obstacles $(1 ≤ n ≤ 10)$, and $b$ is the maximum number of bounces allowed, not including the bounce at the target spot $(0 ≤ b ≤ 15)$. Each of the following $n$ lines has two integers. In the k-th line, $pk$ is the position of the k-th obstacle, its distance from the launcher, and hk is its height from the ground level. You can assume that 0 &lt; p1, pk &lt; pk + 1 for $k = 1,\cdots, n − 1$, and $pn &lt; d$. You can also assume that $1 ≤ hk ≤ 10000$ for $k = 1,\cdots, n$. OutputOutput the smallest possible initial speed vi that makes the bullet reach the target. The initial speed vi of the bullet is defined as follows. v_i=\sqrt{v_{ix}^2+v_{iy}^2}The output should not contain an error greater than 0.0001. Sample Input100 1 0 50 100 10 1 0 4 2 100 4 3 20 10 30 10 40 10 50 10 343 3 2 56 42 190 27 286 34 Sample Output14.57738 3.16228 7.78175 11.08710 HintSourceAsia Regional Contest, Tokyo, 2014 题目大意一道物理题，给定终点和起点的距离$d$，以及$n$个距离起点坐标不同的障碍物（板子）。一颗子弹从起点做抛物线运动，可以撞击地面再弹起$b$次（忽略能量损失），求可以越过障碍物恰好达到终点的初始速度值大小的最小值。 解题思路 模拟+贪心（不知道可不可以叫贪心） 转化一下，由于撞击地面弹起能量无损失。所以可以将撞击前后的两段转化为一段。对每个可能的距离更新最小值。 d_i=\frac{d}{i} (i=1,2,3 \cdots b-1) 对于每个$d_i$，先行判断45度（即$v_y=v_x$时）是否满足条件，若满足直接更新最小值。若不满足则根据轨迹方程不断更新直至能越过最高点。 解题代码123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657#include &lt;cstdio&gt;#include &lt;cmath&gt;#include &lt;cstring&gt;#include &lt;string&gt;#define INF 0x3f3f3f3f#define EPS 1e-8using namespace std;int n,b;double d,dis,vx,vy;//障碍物struct obstacles&#123; double h,x; &#125;ob[20];double x[20]; void cal(double x,double h)&#123; vx=sqrt((dis*x/2.0-x*x/2.0)/h); vy=dis/2.0/vx;&#125;int judge()&#123; //判断是否可以跨过所有障碍物 for (int i = 0; i &lt; n; i++)&#123; double h = vy*x[i] / vx - 0.5*x[i]*x[i] / (vx*vx); if (ob[i].h-h &gt;= EPS) return 0; &#125; return 1;&#125;double solve(int cnt)&#123; dis = d/cnt; //划分段 for(int i=0;i&lt;n;i++) x[i]=fmod(ob[i].x,dis); //浮点数取模 vy=vx=sqrt(dis/2); //先检测vy=vx时候 if(judge()) return vx*sqrt(2.0); double ans=INF; for(int i=0;i&lt;n;i++)&#123; cal(x[i],ob[i].h); //根据x[i],ob[i]初的障碍物更新vx vy的值。 if(judge()) ans=min(ans,sqrt(vx*vx+vy*vy)); &#125; return ans; &#125;int main()&#123; while(~scanf("%lf %d %d", &amp;d, &amp;n, &amp;b)) &#123; memset(ob,0,sizeof(ob)); memset(x,0,sizeof(x)); for (int i = 0; i &lt; n; i++) scanf ("%lf %lf", &amp;ob[i].x, &amp;ob[i].h); double ans = INF; for (int i = 1; i &lt;= b+1; i++) ans = min(ans, solve(i)); printf ("%.8f\n", ans); &#125;&#125; 收获与反思 从简单开始考虑，无障碍物的时候45度最远 将多段跳跃等效为一段。 浮点数取模函数 fmod 函数计算 x 除以 y 的 f 浮点余数，这样 x = i*y + f，其中 i 是整数，f 和 x 有相同的符号，而且 f 的绝对值小于 y 的绝对值。 1234result=fmod(x,y);printf("10.0%%-3.0= %f/n",result); //1.0result=fmod(y,x);printf("-3.0%%10.0= %f/n",result); //-3.0]]></content>
      <categories>
        <category>编程</category>
        <category>ACM</category>
      </categories>
      <tags>
        <tag>算法</tag>
        <tag>ACM</tag>
        <tag>CSU</tag>
        <tag>Imitation</tag>
        <tag>2018暑假集训</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[【HDU-6301】解题报告（贪心，预处理）]]></title>
    <url>%2Fpost%2Fc293d2b3.html</url>
    <content type="text"><![CDATA[原始题目Distinct Values Time Limit: 4000/2000 MS (Java/Others) Memory Limit: 32768/32768 K (Java/Others) Total Submission(s): 3168 Accepted Submission(s): 1017 Problem DescriptionChiaki has an array of $n$ positive integers. You are told some facts about the array: for every two elements $a_i$ and $a_j$ in the subarray $a_{l \cdots r} (l≤i&lt;j≤r)$, $a_i≠a_j$ holds. Chiaki would like to find a lexicographically minimal array which meets the facts. InputThere are multiple test cases. The first line of input contains an integer $T$, indicating the number of test cases. For each test case: The first line contains two integers $n$ and $m (1≤n,m≤105)$ — the length of the array and the number of facts. Each of the next $m$ lines contains two integers $l_i$ and $r_i$ $(1≤li≤ri≤n)$. It is guaranteed that neither the sum of all $n$ nor the sum of all $m$ exceeds 106. OutputFor each test case, output $n$ integers denoting the lexicographically minimal array. Integers should be separated by a single space, and no extra spaces are allowed at the end of lines. Sample Input3 2 1 1 2 4 2 1 2 3 4 5 2 1 3 2 4 Sample Output1 2 1 2 1 2 1 2 3 1 1 Source2018 Multi-University Training Contest 1 Recommendliuyiding 题目大意对于一个数列，已知其m个子区间，每个子区间内数列的项两两不同，求复合条件的字典序最小的数列。 解题思路 要求字典序最小，算法就是从前贪心的让每一位都是当前可使用数的最小值（从1开始）。 那么如何处理出第i位可用数字的最小值？ 预处理出$pre[i]$（包含第i位线段的最小左端点，即与第i位不相同的最早位置） 用set维护当前可使用的数，$pt$指向当前可用最小数的位置， 求每一位的$ans[i]$时，先检查，当$pt&lt;pre[i]$时，说明$pt$到$pre[i]$位置间使用过的数可以再次使用，所以开始向set容器里补充$pt$位置的数，直至$pt=pre[i]$，再取set容器中的最小值付给$ans[i]$ 如何与处理出$pre[i]$（见下图） 解题代码123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657#include &lt;bits/stdc++.h&gt;using namespace std;#define rep(i,a,n) for (int i=a;i&lt;n;i++)#define per(i,a,n) for (int i=n-1;i&gt;=a;i--)#define pb push_back#define mp make_pair#define np next_permutation#define all(x) x.begin(),x.end()#define fi first#define se second#define SZ(x) ((int)(x).size()) typedef vector&lt;int&gt; vi;typedef long long ll;typedef pair&lt;int,int&gt; pii;const int mod=1e9+7;const int maxn=2e5+5;set &lt;int&gt; s;int pre[maxn],n,m,ans[maxn]; //预处理出不可相同的区间前端点。 int main()&#123; int t; scanf("%d",&amp;t); while(t--)&#123; s.clear(); scanf("%d%d",&amp;n,&amp;m); rep(i,1,n+1)&#123; pre[i]=i; //没有限制条件，前端点都是自身 s.insert(i); &#125; rep(i,1,m+1)&#123; int l,r; scanf("%d%d",&amp;l,&amp;r); pre[r]=min(l,pre[r]); //有可能多个区间右端点相同。 //易错写成 pre[r]=l;忘记更新 &#125; per(i,1,n) pre[i]=min(pre[i],pre[i+1]); //易错写成n+1 //处理完毕 //初始set均可用 int pt=1; //pt记录当前不可用线段开头 rep(i,1,n+1)&#123; //开头更替，则往set里补充可用最小值 // cout&lt;&lt;"pt="&lt;&lt;pt&lt;&lt;" pre[i]="&lt;&lt;pre[i]&lt;&lt;endl; while(pt&lt;pre[i])&#123; s.insert(ans[pt++]); &#125; ans[i]=*s.begin(); s.erase(*s.begin()); &#125; rep(i,1,n+1)&#123; if(i==1) printf("%d",ans[i]); else printf(" %d",ans[i]); &#125; printf("\n"); &#125;&#125; 收获与反思 预处理出线段的左端点。 贪心的考虑每一位的最小值。]]></content>
      <categories>
        <category>编程</category>
        <category>ACM</category>
      </categories>
      <tags>
        <tag>算法</tag>
        <tag>ACM</tag>
        <tag>2018暑假集训</tag>
        <tag>Greedy</tag>
        <tag>HDU</tag>
        <tag>2018HDU多校</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[【HDU-6300】解题报告（简单几何贪心）]]></title>
    <url>%2Fpost%2F7fe193be.html</url>
    <content type="text"><![CDATA[原始题目Triangle Partition Time Limit: 2000/1000 MS (Java/Others) Memory Limit: 132768/132768 K (Java/Others) Total Submission(s): 1054 Accepted Submission(s): 533 Special Judge Problem DescriptionChiaki has $3n$ points $p_1,p_2,…,p_{3n}$. It is guaranteed that no three points are collinear. Chiaki would like to construct $n$ disjoint triangles where each vertex comes from the $3n$ points. InputThere are multiple test cases. The first line of input contains an integer $T$, indicating the number of test cases. For each test case: The first line contains an integer $n (1≤n≤1000)$ — the number of triangle to construct. Each of the next 3n lines contains two integers $x_i$ and $y_i (−109≤x_i,y_i≤109)$. It is guaranteed that the sum of all $n$ does not exceed 10000. OutputFor each test case, output $n$ lines contain three integers $a_i,b_i,c_i (1≤a_i,b_i,c_i≤3n)$ each denoting the indices of points the i-th triangle use. If there are multiple solutions, you can output any of them. Sample Input1 1 1 2 2 3 3 5 Sample Output1 2 3 Source2018 Multi-University Training Contest 1 Recommendliuyiding 题目大意给出$3n$个点，且任意三点军部贡献，要求按顺序给出$n$个三角形的三个顶点坐标，要求$n$个三角形两两不相交（不共点）。 解题思路反向理解 若两条线相交（如下图） 假设我们连三角形时先连A线再连，B线，若出现A2&gt;B1，则有可能会出现两线相交。 考虑到题目给出任意三点不共线，即人以三点都可以构成一个三角形。我们只要找到一种方法逐个连接出不相交的三角形就行。 按x轴将所有点排序，从小到大每次找三个点即可。 解题代码12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152#include &lt;bits/stdc++.h&gt;using namespace std;#define rep(i,a,n) for (int i=a;i&lt;n;i++)#define per(i,a,n) for (int i=n-1;i&gt;=a;i--)#define pb push_back#define mp make_pair#define np next_permutation#define all(x) x.begin(),x.end()#define fi first#define se second#define SZ(x) ((int)(x).size()) typedef vector&lt;int&gt; vi;typedef long long ll;typedef pair&lt;int,int&gt; pii;const int mod=1e9+7;const int maxn=1e4+5;struct node&#123; int index; pii point;&#125;a[maxn];ll t,n,m;bool cmp(node a, node b)&#123; if(a.point.first==b.point.first) return a.point.second&lt;b.point.second; else return a.point.first&lt;b.point.first;&#125;int main()&#123; ios::sync_with_stdio(false); cin&gt;&gt;t; while(t--)&#123; cin&gt;&gt;n; rep(i,1,3*n+1)&#123; a[i].index=i; cin&gt;&gt;a[i].point.first&gt;&gt;a[i].point.second; &#125; sort(a+1,a+1+3*n,cmp);// rep(i,1,3*n+1)&#123;// cout&lt;&lt;a[i].point.fi&lt;&lt;" "&lt;&lt;a[i].point.se&lt;&lt;endl;// &#125; rep(i,1,3*n+1)&#123; if(i==1) cout&lt;&lt;a[i].index; else cout&lt;&lt;" "&lt;&lt;a[i].index; &#125; cout&lt;&lt;endl; &#125; &#125; 收获与反思 简单的几何贪心，考虑两线相交的条件拓展即可。]]></content>
      <categories>
        <category>编程</category>
        <category>ACM</category>
      </categories>
      <tags>
        <tag>算法</tag>
        <tag>ACM</tag>
        <tag>2018暑假集训</tag>
        <tag>Greedy</tag>
        <tag>HDU</tag>
        <tag>2018HDU多校</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[【HDU-6298】解题报告（数论，整除）]]></title>
    <url>%2Fpost%2F60850415.html</url>
    <content type="text"><![CDATA[原始题目Maximum Multiple Time Limit: 4000/2000 MS (Java/Others) Memory Limit: 32768/32768 K (Java/Others) Total Submission(s): 1503 Accepted Submission(s): 653 Problem DescriptionGiven an integer $n$, Chiaki would like to find three positive integers $x$, $y$ and $z$ such that: $n=x+y+z$, $x∣n$, $y∣n$, $z∣n$ and $xyz$ is maximum. InputThere are multiple test cases. The first line of input contains an integer $T (1≤T≤106)$, indicating the number of test cases. For each test case:The first line contains an integer $n (1≤n≤106)$. OutputFor each test case, output an integer denoting the maximum xyz. If there no such integers, output −1 instead. Sample Input3 1 2 3 Sample Output-1 -1 1 Source 2018 Multi-University Training Contest 1 Recommend liuyiding 题目大意已知三个数的和为$n$，且三个数均能整除$n$，求三个数乘积的最大值。 解题思路数论问题 不妨设$a=\frac{n}{x},b=\frac{n}{y},c=\frac{n}{z}$。由题目条件可以得到 \frac{1}{a}+\frac{1}{b}+\frac{1}{c}=1由于$a,b,c$均为整数（正整数）。所以该方程共有三组解。分别为$a=3,b=3,c=3,xyz=\frac{n^3}{27}$或者$a=2,b=4,c=4,xyz=\frac{n^3}{32}$或者$a=2,b=3,c=6,xyz=\frac{n^3}{36}$ 故判断$n|3,n|4$整除即可。又因为若第三组解成立，则必有第三组解，而且第一组解对应的$xyz$值更大，故不考虑第三组。 解题代码1234567891011121314151617181920212223242526272829303132#include &lt;bits/stdc++.h&gt;using namespace std;#define rep(i,a,n) for (int i=a;i&lt;n;i++)#define per(i,a,n) for (int i=n-1;i&gt;=a;i--)#define pb push_back#define mp make_pair#define np next_permutation#define all(x) x.begin(),x.end()#define fi first#define se second#define SZ(x) ((int)(x).size()) typedef vector&lt;int&gt; vi;typedef long long ll;typedef pair&lt;int,int&gt; pii;const int mod=1e9+7;const int maxn=1e5+5;ll t,n,m;int main()&#123; ios::sync_with_stdio(false); cin&gt;&gt;t; while(t--)&#123; cin&gt;&gt;n; if(!(n%3)) cout&lt;&lt;1ll*n*n*n/27&lt;&lt;endl; else if(!(n%4)) cout&lt;&lt;1ll*n*n*n/32&lt;&lt;endl; else cout&lt;&lt;"-1"&lt;&lt;endl; &#125; &#125; 收获与反思 寻找条件的关系 数论学习]]></content>
      <categories>
        <category>编程</category>
        <category>ACM</category>
      </categories>
      <tags>
        <tag>算法</tag>
        <tag>ACM</tag>
        <tag>2018暑假集训</tag>
        <tag>数论</tag>
        <tag>HDU</tag>
        <tag>2018HDU多校</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[【HDU-6165】解题报告（BFS，搜索优化）]]></title>
    <url>%2Fpost%2F76485a7.html</url>
    <content type="text"><![CDATA[原始题目FFF at Valentine Time Limit: 6000/3000 MS (Java/Others) Memory Limit: 65536/65536 K (Java/Others) Total Submission(s): 1703 Accepted Submission(s): 722 Problem Description At Valentine’s eve, Shylock and Lucar were enjoying their time as any other couples. Suddenly, LSH, Boss of FFF Group caught both of them, and locked them into two separate cells of the jail randomly. But as the saying goes: There is always a way out , the lovers made a bet with LSH: if either of them can reach the cell of the other one, then LSH has to let them go. The jail is formed of several cells and each cell has some special portals connect to a specific cell. One can be transported to the connected cell by the portal, but be transported back is impossible. There will not be a portal connecting a cell and itself, and since the cost of a portal is pretty expensive, LSH would not tolerate the fact that two portals connect exactly the same two cells. As an enthusiastic person of the FFF group, YOU are quit curious about whether the lovers can survive or not. So you get a map of the jail and decide to figure it out. Input Input starts with an integer $T (T≤120)$, denoting the number of test cases. For each case, First line is two number $n$ and $m$, the total number of cells and portals in the jail.$(2≤n≤1000,m≤6000)$ Then next $m$ lines each contains two integer $u$ and $v$, which indicates a portal from $u$ to $v$. OutputIf the couple can survive, print “I love you my love and our love save us!” Otherwise, print “Light my fire!” Sample Input3 5 5 1 2 2 3 2 4 3 5 4 5 3 3 1 2 2 3 3 1 5 5 1 2 2 3 3 1 3 4 4 5 Sample OutputLight my fire! I love you my love and our love save us! I love you my love and our love save us! Source2017 Multi-University Training Contest - Team 9 Recommendliuyiding 题目大意给定一个有向图，问任意两点之间是否连通 解题思路暂时没有其他（正常）想法，SHL写了一个暴力BFS+优化，拿来学习一下。 解题代码12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061#include&lt;bits/stdc++.h&gt;using namespace std;vector&lt;int&gt; v[1010];int Flag[1010][1010],vis[1010];int ans;void bfs(int st)&#123; queue&lt;int&gt; q; while(!q.empty()) q.pop(); q.push(st); memset(vis,0,sizeof vis); vis[st] = 1; while(!q.empty()) &#123; int u = q.front();q.pop(); for(int i = 0; i &lt; v[u].size(); i++) &#123; if(vis[v[u][i]] == 0) &#123; vis[v[u][i]] = 1; q.push(v[u][i]); if(Flag[st][v[u][i]] == 0) &#123; Flag[st][v[u][i]] = Flag[v[u][i]][st] = 1; ans++; &#125; &#125; &#125; &#125;&#125;void Init()&#123; for(int i=0;i&lt;1010;i++) v[i].clear(); memset(Flag,0,sizeof Flag); ans=0;&#125;int main()&#123; int T,n,m;cin&gt;&gt;T; while(T--) &#123; Init(); scanf("%d%d",&amp;n,&amp;m); while(m--) &#123; int x,y; scanf("%d%d",&amp;x,&amp;y); v[x].push_back(y); &#125; for(int i = 1; i &lt;= n; i++) bfs(i); if(ans == n*(n-1)/2) printf("I love you my love and our love save us!\n"); else printf("Light my fire!\n"); &#125; return 0;&#125; 收获与反思待补充]]></content>
      <categories>
        <category>编程</category>
        <category>ACM</category>
      </categories>
      <tags>
        <tag>算法</tag>
        <tag>ACM</tag>
        <tag>2018暑假集训</tag>
        <tag>BFS</tag>
        <tag>HDU</tag>
        <tag>2017HDU多校</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[【HDU-6168】解题报告（数学，规律，分组）]]></title>
    <url>%2Fpost%2Fd9083bc4.html</url>
    <content type="text"><![CDATA[原始题目Numbers Time Limit: 4000/2000 MS (Java/Others) Memory Limit: 131072/131072 K (Java/Others) Total Submission(s): 1466 Accepted Submission(s): 692 Problem Descriptionzk has n numbers a1,a2,…,an. For each (i,j) satisfying 1≤i&lt;j≤n, zk generates a new number (ai+aj). These new numbers could make up a new sequence b1，b2,…,bn(n−1)/2. LsF wants to make some trouble. While zk is sleeping, Lsf mixed up sequence a and b with random order so that zk can’t figure out which numbers were in a or b. “I’m angry!”, says zk. Can you help zk find out which n numbers were originally in a? Input Multiple test cases(not exceed 10). For each test case: ∙The first line is an integer m(0≤m≤125250), indicating the total length of a and b. It’s guaranteed m can be formed as n(n+1)/2. ∙The second line contains m numbers, indicating the mixed sequence of a and b. Each ai is in [1,10^9] Output For each test case, output two lines. The first line is an integer n, indicating the length of sequence a; The second line should contain n space-seprated integers a1,a2,…,an(a1≤a2≤…≤an). These are numbers in sequence a. It’s guaranteed that there is only one solution for each case. Sample Input6 2 2 2 4 4 4 21 1 2 3 3 4 4 5 5 5 6 6 6 7 7 7 8 8 9 9 10 11 Sample Output3 2 2 2 6 1 2 3 4 5 6 Source 2017 Multi-University Training Contest - Team 9 Recommend liuyiding 题目大意已知一个数列由a，b两个数列构成，b数列中的每一项都是a数列中某两项的和，求原数列a 解题思路首先可以确定的几点是 数列$a$有$n$项，则数列$b$有$\frac{n(n-1)}{2}$项，则给定的$c$数列有$\frac{n(n+1)}{2}$项， 由于$a$中任意一项均&gt;=1（即，$a$为正数数列），所以$c$中的最小项极为$a$中的最小项。 也可以推得，$c$中第二小项也为$a$中第二小项。 再往后推 $c$项中第三小的可能是$a$中第三小的项，也可能是b项中第一小的项（即${a_1}+{a_2}$)。 由于$c$由$a$和$b$全部项构成，所以${b_1}={a_1}+{a_2}$必然在$c$中。 由此我们想到筛数的方法。 $c$中去掉${a_1}+{a_2}$的一项后剩下的最小项必然为$a_3$。 再从$c$中去掉${a_1}+{a_3}$，${a_2}+{a_3}$，剩下的最小项必然为$a_4$。 解题代码123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657#include &lt;cstdio&gt;#include &lt;cstring&gt;#include &lt;string&gt;#include &lt;iostream&gt;#include &lt;set&gt;#include &lt;algorithm&gt;#include &lt;iomanip&gt;#include &lt;vector&gt;#include &lt;map&gt;#include &lt;queue&gt;using namespace std;const int maxn=1e5+5;int n,m;vector &lt;int&gt; a,b,c,ans;map &lt;int,int&gt; num;int main()&#123; while(~scanf("%d",&amp;n))&#123; a.clear(); b.clear(); c.clear(); ans.clear(); num.clear(); int temp; for(int i=0;i&lt;n;i++)&#123; scanf("%d",&amp;temp); a.push_back(temp); if(num[temp]==0) num[temp]=1; else num[temp]++; //记录次数 &#125; sort(a.begin(),a.end()); ans.push_back(a[0]); //初始装进一个最小a1 num[a[0]]--; for(int i=1;i&lt;n;i++)&#123; if(!num[a[i]]) continue; for(int j=0;j&lt;ans.size();j++)&#123; num[a[i]+ans[j]]--; &#125; ans.push_back(a[i]); num[a[i]]--; &#125; printf("%d\n",ans.size()); vector &lt;int&gt; ::iterator it; for(it=ans.begin();it!=ans.end();it++)&#123; if(it==ans.begin()) cout&lt;&lt;*it; else cout&lt;&lt;" "&lt;&lt;*it; &#125; cout&lt;&lt;endl; &#125;&#125; 收获与反思 有序数列的构成注意寻找规律。 分组后更新数列状态。]]></content>
      <categories>
        <category>编程</category>
        <category>ACM</category>
      </categories>
      <tags>
        <tag>算法</tag>
        <tag>ACM</tag>
        <tag>2018暑假集训</tag>
        <tag>HDU</tag>
        <tag>规律</tag>
        <tag>2017HDU多校</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[【HDU-6170】解题报告（字符串，正则匹配，dp）]]></title>
    <url>%2Fpost%2F1eeab2ee.html</url>
    <content type="text"><![CDATA[原始题目Two strings Time Limit: 2000/1000 MS (Java/Others) Memory Limit: 65536/65536 K (Java/Others) Total Submission(s): 2511 Accepted Submission(s): 891 Problem DescriptionGiving two strings and you should judge if they are matched. The first string contains lowercase letters and uppercase letters. The second string contains lowercase letters, uppercase letters, and special symbols: “.” and “*”.. can match any letter, and * means the front character can appear any times. For example, “a.b” can match “acb” or “abb”, “a” can match “a”, “aa” and even empty string. ( “\” will not appear in the front of the string, and there will not be two consecutive “*”. InputThe first line contains an integer T implying the number of test cases. (T≤15)For each test case, there are two lines implying the two strings (The length of the two strings is less than 2500). OutputFor each test case, print “yes” if the two strings are matched, otherwise print “no”. Sample Input3 aa a* abb a.* abb aab Sample Outputyes yes no Source2017 Multi-University Training Contest - Team 9 Recommendliuyiding 题目大意给定 $a$，$b$ 两个字符串。$a$字符串只由字母构成，$b$字符串由字母和”.“，”*“两种符号组合成。有如下规则。 “符号可以匹配任意一个字母。 “*“符号可以匹配0个或多个上一字母，且不会出现在开头。判断$a$，$b$两字符串能否匹配。 解题思路改变了”*“规则的正则匹配。可以用C++正则匹配的库做，也可以使用dp做。 dp思路：bool型dp二维数组，$dp[i][j]$表示$a$字符串第i位和$b$字符串第j位能否匹配。 状态转移方程： 当$b_j$为”.“时，$dp[i][j]=dp[i-1][j-1]$。 当$b_j$为字母时，若$a_i=b_j$，则$dp[i][j]=dp[i-1][j-1]$。否则$dp[i][j]=0$。 当$b_j$为”*“时，根据”*“的规则。上一个字母出现次数为$n$。 当$n=0$时，匹配为上一个字母没有出现过，可从$dp[i][j-2]$转移过来。 当$n=1$时，匹配为上一个字母出现一次，可从$dp[i][j-1]$转移过来。 当$n=2$时，匹配为上一个字母出现两次，故若$a_i=a_{i-1}$时，可从$dp[i-1][j-1]$转移过来。否则$dp[i][j]=0$。 当$n&gt;2$时，匹配为上一个出现$n$次，若$a_i=a_{i-1}$时，$dp[i-1][j]$转移过来，可以不断回退直到到上一情况。 解题代码 正则匹配法 123456789101112131415161718192021222324252627282930313233343536373839#include &lt;iostream&gt;#include &lt;algorithm&gt;#include &lt;cstdio&gt;#include &lt;cmath&gt;#include &lt;cstring&gt;#include &lt;string&gt;#include &lt;string.h&gt;#include &lt;map&gt;#include &lt;set&gt;#include &lt;queue&gt;#include &lt;deque&gt;#include &lt;list&gt;#include &lt;bitset&gt;#include &lt;stack&gt;#include &lt;stdlib.h&gt;#include &lt;regex&gt;#define lowbit(x) (x&amp;-x)#define e exp(1.0)#define eps 1e-8//ios::sync_with_stdio(false);// auto start = clock();// cout &lt;&lt; (clock() - start) / (double)CLOCKS_PER_SEC;typedef long long ll;using namespace std; int main()&#123; ios::sync_with_stdio(false); int T; cin&gt;&gt;T; while(T--) &#123; string a,b; cin&gt;&gt;a&gt;&gt;b; b=regex_replace(b,regex("\\.\\*"),"(.)\\1*"); regex_match(a,regex(b))?cout&lt;&lt;"yes"&lt;&lt;endl:cout&lt;&lt;"no"&lt;&lt;endl; &#125; return 0;&#125; dp12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061#include &lt;bits/stdc++.h&gt;using namespace std;#define rep(i,a,n) for (int i=a;i&lt;n;i++)#define per(i,a,n) for (int i=n-1;i&gt;=a;i--)#define pb push_back#define mp make_pair#define np next_permutation#define all(x) x.begin(),x.end()#define fi first#define se second#define INF Ox3f3f3f3f#define SZ(x) ((int)(x).size()) //ios::sync_with_stdio(false);// auto start = clock();// cout &lt;&lt; (clock() - start) / (double)CLOCKS_PER_SEC;const int maxn=2510;char a[maxn],b[maxn];bool dp[maxn][maxn];int n,m;int main()&#123; int TT,T=0; scanf("%d",&amp;TT); while(TT--)&#123; scanf("%s",a+1); scanf("%s",b+1); n=strlen(a+1); m=strlen(b+1); memset(dp,0,sizeof(dp)); dp[0][0]=1; if (b[2]=='*') dp[0][2]=1; for(int i=1;i&lt;=n;i++)&#123; for(int j=1;j&lt;=m;j++)&#123; //字母情况 if(b[j]!='.'&amp;&amp;b[j]!='*')&#123; dp[i][j]=(a[i]==b[j]?dp[i-1][j-1]:0); &#125; else if(b[j]=='.')&#123; dp[i][j]=dp[i-1][j-1]; &#125; else if(b[j]=='*')&#123; dp[i][j]=dp[i][j-1]|dp[i][j-2]; if(a[i]==a[i-1]&amp;&amp;!dp[i][j]) dp[i][j]=dp[i-1][j-1]|dp[i-1][j]; //注意此处!dp[i][j] 否则会将状态由1更新为0，诸如 bb bba*就会出错 &#125; &#125; &#125; if(dp[n][m]) printf("yes\n"); else printf("no\n"); &#125; return 0;&#125;//1//bb//bba* 收获与反思 C++正则匹配regex库，涨姿势。 字符串dp，状态转移的思考需要学习一下。]]></content>
      <categories>
        <category>编程</category>
        <category>ACM</category>
      </categories>
      <tags>
        <tag>算法</tag>
        <tag>ACM</tag>
        <tag>2018暑假集训</tag>
        <tag>HDU</tag>
        <tag>2017HDU多校</tag>
        <tag>正则匹配</tag>
        <tag>dp</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[【CSU-1005】解题报告（数据结构，树入门，2018暑选入门B题）]]></title>
    <url>%2Fpost%2F19e79191.html</url>
    <content type="text"><![CDATA[原始题目1005: Binary Search Tree analogTime Limit: 1 SecMemory Limit: 128 MbSubmitted: 1630Solved: 473 DescriptionBinary Search Tree, abbreviated as BST, is a kind of binary tree maintains the following property: Each node has a Key value, which can be used to compare with each other. For every node in the tree, every Key value in its left subtree is smaller than its own Key value. For every node in the tree, every Key value in its right subtree is equal to or larger than its own Key value. Now we need to analog a BST, we only require one kind of operation: inserting. First, we have an empty BST. Input is a sequence of numbers. We need to insert them one by one flowing the rules below: If the inserted value is smaller than the root’s value, insert it to the left subtree. If the inserted value is larger than or equal to the value of the root’s value, insert it to the right subtree. After each input, we need to output the preorder, inorder, postorder traversal sequences. About tree traversal, the following is from Wikipedia: Depth-first TraversalTo traverse a non-empty binary tree in preorder, perform the following operations recursively at each node, starting with the root node: Visit the root. Traverse the left subtree. Traverse the right subtree. To traverse a non-empty binary tree in inorder (symmetric), perform the following operations recursively at each node: Traverse the left subtree. Visit the root. Traverse the right subtree. To traverse a non-empty binary tree in postorder, perform the following operations recursively at each node: Traverse the left subtree. Traverse the right subtree. Visit the root. Look at the folowing example: Intput is a sequence of 5 integers: 3 6 9 5 1 After each integer inserted the structure of the tree is illustrated in the flowing: 3 / \ 1 6 / \ 5 9 InputThe first integer of the input is T, the number of test cases. Each test case has two lines. The first line contain an integer N,(1≤N≤1000), the number of numbers need to be inserted into the BST. The second line contain N integers separated by space, each integer is in the range of [0,230]. OutputEach test case, output must contain three lines: the preorder, inorder and postorder traversal sequence. The numbers in each line should be separated by a single space and you should not output anything at the end of the line! Output a blank line after each case. Sample Input1 5 3 6 9 5 1 Sample Output3 1 6 5 9 1 3 5 6 9 1 5 9 6 3 HintSource中南大学第五届大学生程序设计竞赛-热身赛 题目大意构建二叉搜索树，然后将树按前序，中序，后序输出。 解题思路构建二叉树，写函数三种序输出即可。树入门题。 解题代码123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990#include &lt;cstdio&gt;#include &lt;cstring&gt;#include &lt;iostream&gt;#include &lt;set&gt;#include &lt;queue&gt;#include &lt;map&gt;#include &lt;algorithm&gt;using namespace std;typedef long long ll;const int maxn=1e5+5;struct node&#123; int x; struct node *left,*right;&#125;list[maxn];int t,i,n,x,flag1=1;struct node root,*p;void Insert(struct node *r,struct node *p)&#123; if(!r) return; if(r-&gt;x&gt;p-&gt;x) &#123; if(r-&gt;left) Insert(r-&gt;left,p); else r-&gt;left=p; &#125; else &#123; if(r-&gt;right) Insert(r-&gt;right,p); else r-&gt;right=p; &#125;&#125;void pretral(struct node *p)&#123; if(!p) return; if(flag1) printf("%d",p-&gt;x),flag1=0; else printf(" %d",p-&gt;x); pretral(p-&gt;left); pretral(p-&gt;right);&#125;void intral(struct node *p)&#123; if(!p) return; intral(p-&gt;left); if(flag1) printf("%d",p-&gt;x),flag1=0; else printf(" %d",p-&gt;x); intral(p-&gt;right);&#125;void postod(struct node *p)&#123; if(!p) return; postod(p-&gt;left); postod(p-&gt;right); if(flag1) printf("%d",p-&gt;x),flag1=0; else printf(" %d",p-&gt;x);&#125;int main()&#123; scanf("%d",&amp;t); while(t--) &#123; scanf("%d",&amp;n); scanf("%d",&amp;root.x); root.left=root.right=0; for(i=0;i&lt;n-1;i++) &#123; scanf("%d",&amp;x); p=&amp;list[i]; p-&gt;x=x; p-&gt;left=p-&gt;right=0; Insert(&amp;root,p); &#125; flag1=1; pretral(&amp;root); printf("\n"); flag1=1; intral(&amp;root); printf("\n"); flag1=1; postod(&amp;root); printf("\n"); printf("\n"); &#125;&#125; 收获与反思数据结构入门，二叉树熟悉，水题。]]></content>
      <categories>
        <category>编程</category>
        <category>ACM</category>
      </categories>
      <tags>
        <tag>算法</tag>
        <tag>ACM</tag>
        <tag>CSU</tag>
        <tag>数据结构</tag>
        <tag>2018暑期选拔</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[【CSU-1224】解题报告（BFS，水题，2018暑选入门A题）]]></title>
    <url>%2Fpost%2Ffb5efb9c.html</url>
    <content type="text"><![CDATA[原始题目1224: ACM小组的古怪象棋Time Limit: 1 SecMemory Limit: 128 MbSubmitted: 851Solved: 347 DescriptionACM小组的Samsara和Staginner对中国象棋特别感兴趣，尤其对马（可能是因为这个棋子的走法比较多吧）的使用进行深入研究。今天他们又在 构思一个古怪的棋局:假如Samsara只有一个马了，而Staginner又只剩下一个将，两个棋子都在棋盘的一边，马不能出这一半棋盘的范围，另外这 一半棋盘的大小很奇特(n行m列)。Samsara想知道他的马最少需要跳几次才能吃掉Staginner的将(我们假定其不会移动)。当然这个光荣的任 务就落在了会编程的你的身上了。 Input每组数据一行，分别为六个用空格分隔开的正整数$n,m,x1,y1,x2,y2$分别代表棋盘的大小$n,m$以及将的坐标和马的坐标。$(1 \le x1,x2 \le n \le 20 ,1 \le y1,y2 \le m \le 20)$ ，将和马的坐标不相同。 Output输出对应也有若干行，请输出最少的移动步数,如果不能吃掉将则输出“-1”(不包括引号)。 Sample Input8 8 5 1 4 5 Sample Output3 HintSourceCSU Monthly 2011 Dec. 题目大意如题 解题思路马的坐标为单入口BFS，如果搜索不到输出-1. 解题代码1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465666768697071727374757677787980#include &lt;queue&gt;#include &lt;cstdio&gt;#include &lt;cstring&gt;#include &lt;cstdlib&gt;#define maxn 35using namespace std; int n,m,x1,y1,x2,y2;bool vis[maxn][maxn];int dir[8][2]=&#123;&#123;-2,1&#125;,&#123;-2,-1&#125;,&#123;-1,2&#125;,&#123;-1,-2&#125;,&#123;1,2&#125;,&#123;1,-2&#125;,&#123;2,1&#125;,&#123;2,-1&#125;&#125;;struct State // BFS 队列中的状态数据结构&#123; int x,y; int Step_Counter; // 搜索步数统计器&#125;;//State a[maxn];int ans[maxn];bool CheckState(State next) // 约束条件检验&#123; if(next.x&gt;=1&amp;&amp;next.x&lt;=n&amp;&amp;next.y&gt;=1&amp;&amp;next.y&lt;=m&amp;&amp;!vis[next.x][next.y]) // 满足条件 &#123;// printf("next x=%d y=%d\n",next.x,next.y); return 1; &#125; else // 约束条件冲突 return 0;&#125;void bfs(State st)&#123; int flag=0; queue &lt;State&gt; q; // BFS 队列 State now,next; // 定义2个状态，当前和下一个 st.Step_Counter=0; // 计数器清零 q.push(st); // 入队 vis[st.x][st.y]=1; // 访问标记 while(!q.empty()) &#123; now=q.front(); // 取队首元素进行扩展// a[now.i].Step_Counter=++circle; if(now.x==x1&amp;&amp;now.y==y1) &#123; flag=1; printf("%d\n",now.Step_Counter); return ; &#125; for(int i=0;i&lt;8;i++) &#123; next.x=now.x+dir[i][0]; next.y=now.y+dir[i][1]; next.Step_Counter=now.Step_Counter+1; // 计数器加1 if(CheckState(next)) // 如果状态满足约束条件则入队 &#123; q.push(next);// printf("insert x=%d y=%d\n",next.x,next.y); vis[next.x][next.y]=1; //访问标记 &#125; &#125; q.pop(); // 队首元素出队 &#125; printf("-1\n"); return;&#125;int main()&#123; while(~scanf("%d%d%d%d%d%d",&amp;n,&amp;m,&amp;x1,&amp;y1,&amp;x2,&amp;y2)) &#123; memset(vis,0,sizeof(vis)); State start; start.x=x2; start.y=y2; bfs(start); &#125; return 0;&#125; 收获与反思bfs，可以考虑将模板改为bool型。]]></content>
      <categories>
        <category>编程</category>
        <category>ACM</category>
      </categories>
      <tags>
        <tag>算法</tag>
        <tag>ACM</tag>
        <tag>CSU</tag>
        <tag>2018暑期选拔</tag>
        <tag>BFS</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[《解忧杂货店》读书笔记]]></title>
    <url>%2Fpost%2F5555df5.html</url>
    <content type="text"><![CDATA[内容摘录第一章 回答在牛奶箱里 P49 “让深爱的人放弃梦想，这比死还让我痛苦。即使分隔两地，我们的心也会永远在一起。你不要有任何顾虑，我希望你无怨无悔地去追寻梦想。” 第三章 在思域车上等到天亮 P101 “不管是骚扰还是恶作剧，写这些信给浪失杂货店的人，和普通的咨询者再本质上是一样的。他们都是内心破了个洞，重要的东西正从那个破洞逐渐流失。” P106 “这么多年咨询信看下来，让我逐渐明白了一件事。很多时候，咨询的人心里已经有了答案，来咨询只是想确认自己的决定是对的。” P107 “或许雄治留恋的不是杂货店，二十烦恼咨询。他觉得一旦关了店离开这里，就不会有人来找他咨询了。” P175 “人与人之间情断义绝，并不需要什么具体的理由，就算表面上有，也很可能只是心已经离开的结果，事后才编造出的借口而已。因为倘若心没有离开，当将会导致关系破裂的事态发生时，理应有人努力去挽救。如果没有，说明其实关系早已破裂。所以那四个人谁也没有挽救披头士乐队，就像看客一般，眼睁睁看着船只沉没。” Last page “我衷心的祈祷你可以相信你自己，无悔地燃烧自己的人生。”]]></content>
      <categories>
        <category>阅读</category>
      </categories>
      <tags>
        <tag>阅读</tag>
        <tag>小说</tag>
        <tag>文学</tag>
        <tag>解忧杂货店</tag>
        <tag>东野圭吾</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[《如何阅读一本书》读书笔记]]></title>
    <url>%2Fpost%2F3c57c5dc.html</url>
    <content type="text"><![CDATA[内容摘录第一篇 阅读的层次第一章 阅读的活力与艺术 P9 “‘阅读的人’（readers），是指那些今天仍然习惯于从书写文字中汲取大量资讯，以增进对世界了解的人。” P10 “太多的咨询就如童太少的资讯一样，都是一种对理解力的阻碍。换句话说，现代的媒体正以压倒性的泛滥资讯阻碍了我们的理解力。” P11 “听众或读者的‘接收’，应该像是棒球赛中的捕手才对。……我们可以把这个类比的概念往前推。捕手的艺术就在能接住任何球的技巧——快速球、曲线球、变化球、慢速球等等。同样地，阅读的艺术也在尽可能掌握住每一种讯息的技巧。” P18 “蒙田说：‘初学者的无知在于未学’，而学者的无知在于学后。” P19 “倾听是从一位出现在你眼前的老师学习——一位活生生的老师——而阅读却是跟一位缺席的老师学习。如果你问一位活生生的老师一个问题，他可能会回答你。如果你还是不懂他的说的话，你可以再问他问题，省下自己思考的时间。然而如果你问一本书一个问题，你就必须自己回答这个问题。在这样的情况下，这本书就跟自然或世界一样。当你提出问题时，只有等你自己作了思考与分析之后，才会在书本上找到答案。” P22 “我们要懂得如何让书本来教导我们。事实上，这就是这本书最主要的目的。” 第二章 阅读的层次 阅读的四个层次，我们称之为基础阅读，检视阅读，分析阅读，主题阅读，这四个层次是渐进的。 P26 “如果说检视阅读是在涌现的时间内，最好也最完整的阅读，那么分析阅读就是在无限的时间里，最好也最完整的阅读。” P27 “弗兰西斯·培根曾今说过：‘有些书可以浅尝辄止，有些书是要生吞活剥，只有少数的书是要咀嚼与消化的。’分析阅读就是要咀嚼与消化一本书。” P27 “在做主题阅读时，阅读者会越读很多书，而不是一本书，并列举出这些书之间相关之处，提出一个所有的书都谈到的主题。但只是书本里字里行间的比较还不够。主题阅读涉及的远不止此。借助他所阅读的书籍，主题阅读这要能够架构出一个可能在哪一本书里都没提过的主题分析。” 第三章 阅读的第一个层次：基础阅读 P37 “我们的历史一直强调，无限制的受教育机会是一个社会能够提供给人民最有价值的服务——或说得正确一点，只有当一个人的自我期许，能力与需要受限制时，教育机会才会受到限制。我们还没有办法提供这种机会之前，不表示我们就有理由要放弃尝试。” 第四章 阅读的第二个层次：检视阅读 P39 “略读的i管应该用不着花太多时间，下面是要如何去做的一些建议：（1）先看书名页，然后如果有序就先看序。（2）研究目录页。（3）如果书中富有索引，也要检阅一下。（4）不妨读一下出版者的介绍。（5）开始挑几个看起来跟主题息息相关的篇章来看。（6）最后一步，把书打开翻看，有时候连续读几页，但不要太多。” P47 “拍摄下来的眼睛在活动时的影片，显示年轻或未受过训练的阅读者，在阅读一行字的时候会在五六个地方发生‘逗留’（fixate）现象。（眼睛在移动时看不见，只有停下来时才能看见。）因此，他们在读这一行字的时候，只能间隔着看到一个个单字或最多两三个字的组合。更糟的是，这些不熟练的阅读这在看过每两三行后，眼睛就自然地‘倒退’（regress）到原点——也就是说，他们又会倒退到先前读过的句子与那一行去了。所有这些习惯不但浪费而且显然降低了阅读的的速度。之所以说是浪费，因为我们的头脑跟眼睛不一样，并不需要一次只‘读’一个字或一个句子。我们的头脑是个惊人的工具，可以在‘一瞥’之间掌握住一个句子或段落——只要眼睛能提供足够资讯。” P50 “在阅读一本书的时候，慢不该慢到不值得，快不该快到有损于满足与理解。不论怎么说，阅读的速度，不论是快还是慢，只不过是阅读问题一个微笑的部分而已。” P51 “在第一次阅读一本很难得书时，不要企图了解每一个子句。这是最最重要的一个规则。这也是检视阅读的基本概念。不要害怕，或是但又自己似乎读得很肤浅。就算是最难读的书也快快地读一遍。当你再度第二次时，你就已经准备好要读这本书了。” 第五章 如何做一个自我要求的读者 P52 “在阅读的时候想要保持清醒，或昏昏入睡，主要看你的阅读目标是什么。如果你的月度目标是获得利益——不论是心灵或精神上的成长——你就得保持清醒。这也意味着在阅读时要尽可能地保持主动，同时还要做一番努力——而这番努力是会有回馈的。” P53 “关于一本书，你一定要提出四个主要的问题。（1）整体来说，这本书到底在谈些什么？（2）作者细部说了什么，怎么说的？（3）这本书说得有道理吗？是全部有道理。还是部分有道理（4）这本书跟你有什么关系？” P60 “所谓艺术或技巧，只属于哪个能养成习惯，而且能依照规则来运作的人。这也是艺术家或任何领域的工匠与众不同之处。” 第二篇 阅读的第三个层次：分析阅读第六章 一本书的分类 实用性vs.理论性作品，理论——是什么，实用——怎么做。 P74 “实用是与某种有效的做法有关，不管是立即或长程的功效。而理论所关注的却是去明白或了解某件事。” P74 “纯科学于应用科学的区别，或是像通常非常粗糙的那种说法，也就是科学与科技之间的区别。有些书或有些老师，只对他们要传达的知识本身感兴趣。这并不是说他们否定知识的实用性，或是他们坚持只该为知识而知识。他们知识将自己限制在某一种沟通或教学方式中，而让其他人去用别的方式。其他这些人的兴趣则在追求知识本身以外的事上，他们关切的是哪些知识能帮忙解决的人生问题。他们也传递知识，但永远带着一种强调知识的实际应用的观点。” P78 “质疑某件事的有效性是理论，而质疑任何事的目的，却是实用。” P75 “要让知识变成有用，就要有操作的规则。我们一定要超越‘知道这是怎么回事’，进而明白‘如果我想做些什么，应该怎么利用它’。”知与行的区别，而本书就是一本告诉我们该怎么做的实用的书。 P81 “如果一本理论的书所强调的内容，超乎你日常、理性、正常生活的经验，那就是科学的书。否则就是一本哲学的书。” 第七章 透视一本书 P85 “对于‘整体内容’这件事，光是一个模糊的认知是不够的，你必须要确切清楚地了解才行。只有一个方法能知道你是否成功了。你必须能用几句话，告诉你自己，或别人，这整本书在说的是什么。（如果你要说的话太多，表示你还没有将整体的内容看清楚，而只是看到了多样的内容。）” P106 “分析阅读的第一阶段，或，找出一本书在谈些什么的四个规则：（1）依照书本的种类与主题作分类。（2）用最简短的句子说出整本书在谈些什么。（3）按照顺序与关系，列出全书的重要部分。将全书的纲要拟出来之后，再将各个部分的纲要也一一列出。（4）找出作者在问的问题，或作者想要解决的问题。” 第八章 与作者找出共通的词义 P116 “就积极面来说，只要熟悉一下哪个领域，你就能找出这些专门的单字；就消极面来说，你只要看到不是平常惯见的单字，就会知道那些字一定是专门用语。” P116 “另外一个线索是，作者与其他作者争执的某个用语就是重要的字。” P119 “你一定要利用上下文自己已经了解的所有字句，来推敲出你所不了解的那个字的意义。” P132 “第五个规则：找出关键字，与作者达成共识。第六个规则可以说是：将一本书中最重要的句子圈起来，找出其中的主旨。第七个规则是：从相关文句的关联中，设法架构出一本书的基本论述。” P133 “从一个赌这的观点来看，对你重要的句子就是一些需要花一点努力来诠释的句子，因为你第一眼看到这些句子时并不能完全理解…….最重要的句子就是在整个论述中，阐述作者判断的部分。” 未完待续 中间换了一个版本，所以页码乱掉了]]></content>
      <categories>
        <category>阅读</category>
      </categories>
      <tags>
        <tag>阅读</tag>
        <tag>社科</tag>
        <tag>如何阅读一本书</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[C++运算符重载与无名对象引用问题的一点思考]]></title>
    <url>%2Fpost%2Fab4ed95b.html</url>
    <content type="text"><![CDATA[问题的发现今天复习C++运算符重载时候的意外发现：关于类的临时对象以及引用的一些思考。来源于C++程序设计（小红书）上给出了“+”号运算符重载的样例。 基本知识回顾重载运算符的习惯 C++规定，赋值运算符=、下标运算符[]、函数调用运算符()、成员运算符-&gt;必须作为成员函数。 流插入运算符&lt;&lt; 和流提取运算符 &gt;&gt;、类型转换运算符不能定义为类的成员函数，只能作为友元函数。 一般将单目运算符和复合运算符重载为成员函数 一般将双目运算符重载为友元函数。NextSo 根据上述的习惯，我对着屏幕敲了书上的样例的类定义的代码。 1234567891011121314151617181920212223242526272829303132333435363738394041424344class Complex&#123; public: Complex() &#123; real=0; imag=0; &#125; Complex(double d)&#123; real=d; imag=0; &#125; Complex(double r,double i)&#123; real =r; imag=i; &#125; friend Complex operator + (Complex &amp;a,Complex &amp;b); friend ostream&amp; operator &lt;&lt; (ostream &amp;,Complex &amp;); private: double real; double imag;&#125;;Complex operator +(Complex &amp;a,Complex &amp;b)&#123; Complex temp; temp.real=a.real+b.real; temp.imag=a.imag+b.imag; return temp;&#125;ostream&amp; operator &lt;&lt; (ostream&amp; output,Complex &amp;a )&#123; cout&lt;&lt;"("&lt;&lt;a.real&lt;&lt;","&lt;&lt;a.imag&lt;&lt;"i)"; return output;&#125;int main()&#123; Complex c1(3,4),c2(5,-10),c3; c3=c1+4.0; cout&lt;&lt;c3&lt;&lt;endl; c3=c3+c1; cout &lt;&lt;c3&lt;&lt;endl;&#125; 写完感觉看着是没什么问题对吧（我真觉的没什么问题）。然而运行了一下就报错了，那…报什么错了？ [Error] no match for &#39;operator+&#39; (operand types are &#39;Complex&#39; and &#39;double&#39;) [Note] candidates are: [Note] Complex operator+(Complex&amp;, Complex&amp;) [Note] no known conversion for argument 2 from &#39;Complex&#39; to &#39;Complex&amp;&#39; 哦哦看了下报错，原来是重载函数写的问题，我先去查了一下代码。 课本上给出的重载运算符声明和定义是： friend Complex operator + (Complex a,Complex b); ... 我自己看走眼敲成了： friend Complex operator + (Complex &amp;a,Complex &amp;b); ... 看出问题在哪了么？没错就是一个”&amp;”的差别，即形参是Complex类对象的引用还是Complex类对象。 问题展开与解决去掉”&amp;”后程序果然可以正常运行的。不过我考虑了一下程序的实现过程，不对啊，一个简单的相加，我传递一个类对象的引用不应该出现什么问题啊，”+”本身又不会对引用的对象进行什么操作，返回类型是一个Complex类的对象。问题出现在哪里了？ 一些奇葩（正经）的实验于是乎我把之前写的简单的”+”重载的程序，函数的形参都改为对象的引用，再运行。结果更奇怪了，除了上述程序，都没有报错。这个程序又独特在哪里了？ 问题点再返回去读一读程序，这个样例用到了转换构造函数。 c3=c1+4.0; 在保留注释掉以后程序果然可以正常运行了，问题确实出现在这里。既然是转换构造函数的问题，隐式调用（默认执行的）方式不可行，那我试一试显式的 c3=c1+Complex(4.0); 然而…报错依旧，只有微小的变化 [Error] no match for &#39;operator+&#39; (operand types are &#39;Complex&#39; and &#39;Complex&#39;) 对照之前的 [Error] no match for &#39;operator+&#39; (operand types are &#39;Complex&#39; and &#39;double&#39;) 原来最开始的程序并没有成功的调用转换构造函数。编译器没有检测到？看来是哪里出了什么之前没考虑过的问题。 思考（不摔桌！不摔桌！冷静！）如果通过引用进行参数传递，可以免去建立实参的拷贝，空间和时间上都可以得到优化，逻辑推理一下，那这种传参的方式应该被推行啊，相近的例子就是流提取和流插入运算符的重载，第二个参数都是自定义类的引用。 那…为何”+”的重载不采用这种方式呢？看来是有问题的，结合之前的实验，在不出现转换构造函数调用的情况下，形参为引用是行得通的。看来这个问题和转换构造函数也相关。 再回过头来看报错信息 [Error] no match for &#39;operator+&#39; (operand types are &#39;Complex&#39; and &#39;Complex&#39;) [Note] candidates are: [Note] Complex operator+(Complex&amp;, Complex&amp;) [Note] no known conversion for argument 2 from &#39;Complex&#39; to &#39;Complex&amp;&#39; 最后一句：Complex到Complex&amp;转换出了问题，这个比较稀奇。从类对象到类对象的引用不应该是顺理成章的事情么，别名而已。Emm问题就在这个别名身上 引用&lt;-&gt;别名转换构造函数出现的无名对象转换构造函数是构造函数的重载，在使用转换构造函数的过程中，我们可以建立一个有名对象，也可以建立一个无名对象。书上中的代码样例 Complex c1(3.5); //调用转换构造函数建立对象c1 Complex(3.6); //调用转换构造函数建立无名对象，合法，但无法使用。 就是这个无名对象的锅，我们回过头来看最开始发现的问题点： c3=c1+Complex(4.0); 由于Complex(4.0)建立的是一个无名对象，而采用我错误写出的以引用作为形参的 “+”运算符重载，会发生什么？没有名字，自然无法引用啊。这也就解释了报错信息为什么Complex到Complex&amp;转换出了问题。无名的对象无法建立引用（没名字你怎么给它找个别名）。 事后诸葛亮根据简单的实验其实能得到一些结论 涉及转换构造函数的运算符重载，形参都应该是类对象而不是类对象的引用。 C++自己实现的”=”应该也是用类对象作形参，因为 c1=Complex(3.6); 这一句是可以正常执行的。 算作对引用以及构造函数的一个探索吧:)]]></content>
      <categories>
        <category>编程</category>
        <category>C++</category>
      </categories>
      <tags>
        <tag>C++</tag>
        <tag>课程学习</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[【CSU-1895】解题报告（数学，矩阵快速幂）]]></title>
    <url>%2Fpost%2F7d8e4f2a.html</url>
    <content type="text"><![CDATA[原始题目1895: Apache is late again Time Limit: 1 Sec Memory Limit: 128 Mb Submitted: 141 Solved: 45 DescriptionApache is a student of CSU. There is a math class every Sunday morning, but he is a very hard man who learns late every night. Unfortunate, he was late for maths on Monday. Last week the math teacher gave a question to let him answer as a punishment, but he was easily resolved. So the math teacher prepared a problem for him to solve. Although Apache is very smart, but also was stumped. So he wants to ask you to solve the problem. Questions are as follows: You can find a m made (1 + sqrt (2)) ^ n can be decomposed into sqrt (m) + sqrt (m-1), if you can output $m% 100000007$ otherwise output No. InputThere are multiply cases. Each case is a line of $n (|n| \le 10 ^ {18})$ OutputLine, if there is no such m output No, otherwise output m% 100,000,007. Sample Input2 Sample Output9 HintSource中南大学第十一届大学生程序设计竞赛 题目大意给定n，若${1 + \sqrt {2}} ^ n$，能表示成$\sqrt {m} + \sqrt {m-1}$，则输出m，否则输出No 解题思路当$n&gt;0$时,试着写出前几项 $(1+\sqrt{2})^1=\sqrt{2}+\sqrt{1}=\sqrt{1^2+1}+\sqrt{1^2}$ $(1+\sqrt{2})^2=\sqrt{9}+\sqrt{8}=\sqrt{3^2}+\sqrt{3^2-1}$ $(1+\sqrt{2})^3=\sqrt{50}+\sqrt{49}=\sqrt{7^2+1}+\sqrt{7^2}$ $(1+\sqrt{2})^4=\sqrt{289}+\sqrt{288}=\sqrt{17^2}+\sqrt{17^2-1}$ 若只观察含有$\sqrt{2}$的项，我们能得到下面的数列 a_1=1,a_2=2,a_3=5,a_4=12,\cdots可以看作是一个二阶差分方程，其通项的矩阵表达 \begin{bmatrix} a_n \\ a_{n-1} \\ \end{bmatrix}=\begin{bmatrix} 2&1 \\1&0 \end{bmatrix}\begin{bmatrix} a_{n-1}\\ a_{n-2}\end{bmatrix}={\begin{bmatrix} 2&1\\ 1&0\end{bmatrix} }^{n-2}\begin{bmatrix}a_2\\ a_1 \end{bmatrix}给定$a_1=1$，$a_2=2$，通过矩阵快速幂计算$a_n$ 解题代码123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293#include &lt;cstdio&gt;#include &lt;cstring&gt;#include &lt;iostream&gt;#include &lt;set&gt;#include &lt;queue&gt;#define mod 100000007 //这里定义模 using namespace std;const int maxn=1e5+5;typedef long long ll;struct Matrix&#123; ll a[2][2]; Matrix() &#123; memset(a,0,sizeof(a)); &#125; Matrix operator * (const Matrix y) &#123; Matrix ans; for(int i = 0; i &lt; 2; i++) for(int j = 0; j &lt; 2; j++) for(int k = 0; k &lt; 2; k++) ans.a[i][j] += (a[i][k]*y.a[k][j])%mod; return ans; &#125; Matrix operator = (const Matrix y) &#123; for(int i=0;i&lt;2;i++) for(int j=0;j&lt;2;j++) a[i][j]=y.a[i][j]; &#125; Matrix operator *= (const Matrix y) &#123; Matrix ans; for(int i=0;i&lt;2;i++) for(int j=0;j&lt;2;j++) for(int k=0;k&lt;2;k++) ans.a[i][j] += (a[i][k]*y.a[k][j])%mod; for(int i=0;i&lt;2;i++) for(int j=0;j&lt;2;j++) a[i][j]=ans.a[i][j]; &#125;&#125;;Matrix qpow(ll x)&#123; Matrix ans; ans.a[0][0]=ans.a[1][1]=1; //单位矩阵 Matrix mul; mul.a[0][0]=2; mul.a[0][1]=mul.a[1][0]=1; while(x) &#123; if(x&amp;1) ans *= mul; mul *= mul; x&gt;&gt;=1; &#125; return ans;&#125;ll pow(ll a,ll b)&#123; ll ans=1; while(b) &#123; if(b&amp;1) ans=(ans*a%mod); a=a*a%mod; b&gt;&gt;=1; &#125; return ans; &#125;ll n;int main()&#123; while(~scanf("%lld",&amp;n)) &#123; if(n&lt;0) printf("No\n"); else if(n==0) printf("1\n"); else if(n==1) printf("2\n"); else if(n==2) printf("9\n"); else if(n==3) printf("50\n"); else &#123; Matrix m=qpow(n-2); ll ans=(m.a[0][0]*2%mod+m.a[0][1]%mod)%mod; if(n&amp;1) printf("%lld\n",ans*ans*2%mod); else printf("%lld\n",(ans*ans%mod*2+1)%mod); &#125; &#125;&#125; 收获与反思 矩阵快速幂练习 注意n&lt;0时候输出No，因为这个T了好几次。]]></content>
      <categories>
        <category>编程</category>
        <category>ACM</category>
      </categories>
      <tags>
        <tag>算法</tag>
        <tag>ACM</tag>
        <tag>2018春季训练</tag>
        <tag>CSU</tag>
        <tag>矩阵快速幂</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[【CSU-2138】解题报告（数学，矩阵快速幂）]]></title>
    <url>%2Fpost%2Fb0d6c7.html</url>
    <content type="text"><![CDATA[原始题目2138: Rikka’s Set Time Limit: 1 Sec Memory Limit: 128 Mb Submitted: 44 Solved: 11 DescriptionRikka is poor at math. Now she asks you for help. A set is known as extraordinary set when the minimum integer of it is equal to its size.min{x : x ∈ S}=|S|For example, S = {3, 7, 8} is extraordinary. gn is the number of extraodinary subsets of {1, 2, …, n}. Rikka wants to know the value of gn. InputInput consists of one integer n(1 ≤ n ≤ 1018) OutputOutput a single integer gnmod1000000009 Sample Input16 Sample Output987 HintSourceAuthorxm 题目大意给定一个{1,2,3……n}的集合，问有多少个集合中元素个数等于集合中元素最小值的子集。 解题思路 对于给定的n， n=1，易知为1 n=2，易知为1 n&gt;=3，我们很容易根据题目想到答案的表达式Mathjax显示不出来好吧。。。就是 C(n-i,i-1) i从2到n的求和+1。 列出前几项，我们发现实际为斐波那契数列（等价证明还没想明白） 运用矩阵快速幂可得到答案。 解题代码12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364656667686970717273747576777879808182838485868788899091#include &lt;cstdio&gt;#include &lt;cstring&gt;#include &lt;iostream&gt;#include &lt;set&gt;#include &lt;queue&gt;#define mod 1000000009 //这里定义模 using namespace std;const int maxn=1e5+5;typedef long long ll;struct Matrix&#123; ll a[2][2]; Matrix() &#123; memset(a,0,sizeof(a)); &#125; Matrix operator * (const Matrix y) &#123; Matrix ans; for(int i = 0; i &lt; 2; i++) for(int j = 0; j &lt; 2; j++) for(int k = 0; k &lt; 2; k++) ans.a[i][j] += (a[i][k]*y.a[k][j])%mod; return ans; &#125; Matrix operator = (const Matrix y) &#123; for(int i=0;i&lt;2;i++) for(int j=0;j&lt;2;j++) a[i][j]=y.a[i][j]; &#125; Matrix operator *= (const Matrix y) &#123; Matrix ans; for(int i=0;i&lt;2;i++) for(int j=0;j&lt;2;j++) for(int k=0;k&lt;2;k++) ans.a[i][j] += (a[i][k]*y.a[k][j])%mod; for(int i=0;i&lt;2;i++) for(int j=0;j&lt;2;j++) a[i][j]=ans.a[i][j]; &#125;&#125;; Matrix qpow(ll x)&#123; Matrix ans; ans.a[0][0]=ans.a[1][1]=1; //单位矩阵 Matrix mul; mul.a[0][0]=mul.a[0][1]=mul.a[1][0]=1; while(x) &#123; if(x&amp;1) ans *= mul; mul*=mul; x&gt;&gt;=1; &#125; return ans;&#125;ll pow(ll a,ll b)&#123; ll ans=1; while(b) &#123; if(b&amp;1) ans=(ans*a%mod); a=a*a%mod; b&gt;&gt;=1; &#125; return ans; &#125;ll n;int main()&#123; while(~scanf("%lld",&amp;n)) &#123; if(n==1) printf("1\n"); else if(n==2) printf("1\n"); else if(n==3) printf("2\n"); else if(n==4) printf("3\n"); else if(n==5) printf("5\n"); else &#123; Matrix m=qpow(n-2); printf("%lld\n",(m.a[0][0]+m.a[0][1])%mod); &#125; &#125;&#125; 收获与反思 多尝试一下前几项，发现规律 矩阵快速幂练习]]></content>
      <categories>
        <category>编程</category>
        <category>ACM</category>
      </categories>
      <tags>
        <tag>算法</tag>
        <tag>ACM</tag>
        <tag>2018春季训练</tag>
        <tag>CSU</tag>
        <tag>矩阵快速幂</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[【AtCoder-4152】解题报告（数学，进制，贪心）]]></title>
    <url>%2Fpost%2F918fcaa1.html</url>
    <content type="text"><![CDATA[原始题目C - Strange Bank Time limit : 2sec Memory limit : 256MB Score : 300 points Problem StatementTo make it difficult to withdraw money, a certain bank allows its customers to withdraw only one of the following amounts in one operation: 1 yen (the currency of Japan) 6 yen, 62(=36) yen, 63(=216) yen, … 9 yen, 92(=81) yen, 93(=729) yen, … At least how many operations are required to withdraw exactly N yen in total? It is not allowed to re-deposit the money you withdrew. Constraints1≤N≤100000N is an integer. InputInput is given from Standard Input in the following format: N OutputIf at least x operations are required to withdraw exactly N yen in total, print x. Sample Input 1127 Sample Output 14 By withdrawing 1 yen, 9 yen, 36(=62) yen and 81(=92) yen, we can withdraw 127 yen in four operations. Sample Input 23 Sample Output 23 By withdrawing 1 yen three times, we can withdraw 3 yen in three operations. Sample Input 344852 Sample Output 316 题目大意规定三种取钱的方法，一次可以取1元，6^k元或者9^k元 （k&gt;=1） ，问取n元最少的次数是多少。 解题思路将n拆成i和n-i。分别用6和9进制表示，维护系数和最小值即可。 解题代码123456789101112131415161718192021222324#include &lt;cstdio&gt;#include &lt;iostream&gt; using namespace std;int n;int main()&#123; while(~scanf("%d" ,&amp;n)) &#123; int res=n; //最大情况肯定为n次 全部每次取1元 for(int i=0;i&lt;=n;i++) &#123; int cc=0; int t=i; while(t) cc+=t%6,t/=6; //计算6进制的系数和 t=n-i; while(t) cc+=t%9,t/=9; //计算9进制的系数和 if(res&gt;cc) res=cc; &#125; printf("%d\n",res); &#125;&#125; 收获与反思 理解题意，三种方法算最小值其实就是求一个数用6/9进制混合表达的系数最小值。 把n拆成两部分，维护系数最小值。 while(t) cc+=t%k,t/=k; 该方法得到的cc为t用k进制表达的系数和。]]></content>
      <categories>
        <category>编程</category>
        <category>ACM</category>
      </categories>
      <tags>
        <tag>算法</tag>
        <tag>ACM</tag>
        <tag>AtCoder</tag>
        <tag>math</tag>
        <tag>2018春季训练</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[【CodeForces-978F】解题报告（二分，排序，数据结构）]]></title>
    <url>%2Fpost%2F32dc51f4.html</url>
    <content type="text"><![CDATA[原始题目Mentors time limit per test3 seconds memory limit per test256 megabytes inputstandard input outputstandard output In BerSoft n programmers work, the programmer i is characterized by a skill ri. A programmer a can be a mentor of a programmer b if and only if the skill of the programmer a is strictly greater than the skill of the programmer b (ra&gt;rb) and programmers a and b are not in a quarrel. You are given the skills of each programmers and a list of k pairs of the programmers, which are in a quarrel (pairs are unordered). For each programmer i, find the number of programmers, for which the programmer i can be a mentor. InputThe first line contains two integers n and k (2≤n≤2⋅105, 0≤k≤min(2⋅105,n⋅(n−1)2)) — total number of programmers and number of pairs of programmers which are in a quarrel. The second line contains a sequence of integers r1,r2,…,rn (1≤ri≤109), where ri equals to the skill of the i-th programmer. Each of the following k lines contains two distinct integers x, y (1≤x,y≤n, x≠y) — pair of programmers in a quarrel. The pairs are unordered, it means that if x is in a quarrel with y then y is in a quarrel with x. Guaranteed, that for each pair (x,y) there are no other pairs (x,y) and (y,x) in the input. OutputPrint n integers, the i-th number should be equal to the number of programmers, for which the i-th programmer can be a mentor. Programmers are numbered in the same order that their skills are given in the input. ExamplesInput4 2 10 4 10 15 1 2 4 3 Output0 0 1 2 Input10 4 5 4 1 5 4 3 7 1 2 5 4 6 2 1 10 8 3 5 Output5 4 0 5 3 3 9 0 2 5 NoteIn the first example, the first programmer can not be mentor of any other (because only the second programmer has a skill, lower than first programmer skill, but they are in a quarrel). The second programmer can not be mentor of any other programmer, because his skill is minimal among others. The third programmer can be a mentor of the second programmer. The fourth programmer can be a mentor of the first and of the second programmers. He can not be a mentor of the third programmer, because they are in a quarrel. 题目大意给定n个人员skill值，并给出k个有矛盾的对，对于每个人，可以做skill值比自己小且没有矛盾人的导师。输出每一个人可做多少人的导师。 解题思路 排序后对每个人的skill值二分查找，存储到ans[]中。 对于每个矛盾对，skill值大的ans减1即可。 解题代码12345678910111213141516171819202122232425262728293031323334353637383940414243444546#include &lt;iostream&gt;#include &lt;cstdio&gt;#include &lt;iomanip&gt;#include &lt;cstring&gt;#include &lt;map&gt;#include &lt;set&gt;#include &lt;queue&gt;#include &lt;algorithm&gt;#define eps 1e-8#define INF 0x3f3f3f3fusing namespace std;typedef long long ll;const int maxn=2e5+5;ll a[maxn],b[maxn];int ans[maxn],n,t,k;int main()&#123; while(~scanf("%d%d",&amp;n,&amp;k)) &#123; for(int i=0;i&lt;n;i++) &#123; scanf("%I64d",&amp;a[i]); b[i]=a[i]; &#125; sort(b,b+n); for(int i=0;i&lt;n;i++) &#123; ans[i]=lower_bound(b,b+n,a[i])-b;// printf("--%d--\n",ans[i]); &#125; for(int i=0;i&lt;k;i++) &#123; int temp1,temp2; scanf("%d%d",&amp;temp1,&amp;temp2); if(a[temp1-1]&gt;a[temp2-1]) ans[temp1-1]--; else if(a[temp2-1]&gt;a[temp1-1]) ans[temp2-1]--; &#125; for(int i=0;i&lt;n;i++) &#123; if(i==0) printf("%d",ans[i]); else printf(" %d",ans[i]); &#125; printf("\n"); &#125;&#125; 收获与反思 二分查找 lower_bound的运用。 注意quarrel列的在线计算。]]></content>
      <categories>
        <category>编程</category>
        <category>ACM</category>
      </categories>
      <tags>
        <tag>算法</tag>
        <tag>ACM</tag>
        <tag>2018春季训练</tag>
        <tag>二分</tag>
        <tag>CodeForces</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[【CodeForces-978E】解题报告（暴力，数学）]]></title>
    <url>%2Fpost%2Ffcb9464d.html</url>
    <content type="text"><![CDATA[原始题目Bus Video System time limit per test1 second memory limit per test256 megabytes inputstandard input outputstandard output The busses in Berland are equipped with a video surveillance system. The system records information about changes in the number of passengers in a bus after stops. If x is the number of passengers in a bus just before the current bus stop and y is the number of passengers in the bus just after current bus stop, the system records the number y−x. So the system records show how number of passengers changed. The test run was made for single bus and n bus stops. Thus, the system recorded the sequence of integers a1,a2,…,an (exactly one number for each bus stop), where ai is the record for the bus stop i. The bus stops are numbered from 1 to n in chronological order. Determine the number of possible ways how many people could be in the bus before the first bus stop, if the bus has a capacity equals to w (that is, at any time in the bus there should be from 0 to w passengers inclusive). InputThe first line contains two integers n and w (1≤n≤1000,1≤w≤109) — the number of bus stops and the capacity of the bus. The second line contains a sequence a1,a2,…,an (−106≤ai≤106), where ai equals to the number, which has been recorded by the video system after the i-th bus stop. OutputPrint the number of possible ways how many people could be in the bus before the first bus stop, if the bus has a capacity equals to w. If the situation is contradictory (i.e. for any initial number of passengers there will be a contradiction), print 0. ExamplesInput3 5 2 1 -3 Output3 Input2 4 -1 1 Output4 Input4 10 2 4 1 2 Output2 NoteIn the first example initially in the bus could be 0, 1 or 2 passengers. In the second example initially in the bus could be 1, 2, 3 or 4 passengers. In the third example initially in the bus could be 0 or 1 passenger. 题目大意给定公交车经历的站数和最大容载量，并给出在各个公交站上/下车的人数，求最初车上人数有几种可能。 解题思路初始sum为0，上下车人数，记录最大值和最小值，计算最大差值，ans=m-(mmax-mmin)+1。 解题代码12345678910111213141516171819202122232425262728293031323334#include &lt;cstdio&gt;#include &lt;cstring&gt;#include &lt;iostream&gt;#include &lt;set&gt;#include &lt;queue&gt;#include &lt;map&gt;#include &lt;vector&gt;#include &lt;algorithm&gt;#define eps 1e-8#define INF 0x3f3f3f3fusing namespace std;const int maxn=2e5+5;typedef long long ll;ll b[maxn],d[maxn],n,m,t,sum,ans;int main()&#123; while(~scanf("%I64d%I64d",&amp;n,&amp;m)) &#123; sum=0; ll mmax=0,mmin=0; for(int i=1;i&lt;=n;i++) &#123; scanf("%I64d",&amp;b[i]); sum+=b[i]; if(sum&gt;mmax) mmax=sum; if(sum&lt;mmin) mmin=sum; &#125;// printf("%I64d %I64d\n",mmin,mmax); ll ans=m-(mmax-mmin)+1; if(ans&lt;=0) printf("0\n"); else printf("%I64d\n",ans); &#125;&#125; 收获与反思 简单数学问题]]></content>
      <categories>
        <category>编程</category>
        <category>ACM</category>
      </categories>
      <tags>
        <tag>算法</tag>
        <tag>ACM</tag>
        <tag>math</tag>
        <tag>2018春季训练</tag>
        <tag>CodeForces</tag>
        <tag>暴力</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[【CodeForces-978D】解题报告（暴力，数学讨论）]]></title>
    <url>%2Fpost%2F44505a5b.html</url>
    <content type="text"><![CDATA[原始题目Almost Arithmetic Progression time limit per test1 second memory limit per test256 megabytes inputstandard input outputstandard output Polycarp likes arithmetic progressions. A sequence [a1,a2,…,an] is called an arithmetic progression if for each i (1≤i&lt;n) the value ai+1−ai is the same. For example, the sequences [42], [5,5,5], [2,11,20,29] and [3,2,1,0] are arithmetic progressions, but [1,0,1], [1,3,9] and [2,3,1] are not. It follows from the definition that any sequence of length one or two is an arithmetic progression. Polycarp found some sequence of positive integers [b1,b2,…,bn]. He agrees to change each element by at most one. In the other words, for each element there are exactly three options: an element can be decreased by 1, an element can be increased by 1, an element can be left unchanged. Determine a minimum possible number of elements in b which can be changed (by exactly one), so that the sequence b becomes an arithmetic progression, or report that it is impossible. It is possible that the resulting sequence contains element equals 0. InputThe first line contains a single integer n (1≤n≤100000) — the number of elements in b. The second line contains a sequence b1,b2,…,bn (1≤bi≤109). OutputIf it is impossible to make an arithmetic progression with described operations, print -1. In the other case, print non-negative integer — the minimum number of elements to change to make the given sequence becomes an arithmetic progression. The only allowed operation is to add/to subtract one from an element (can’t use operation twice to the same position). ExamplesInput4 24 21 14 10 Output3 Input2 500 500 Output0 Input3 14 5 1 Output-1 Input5 1 3 6 9 12 Output1 NoteIn the first example Polycarp should increase the first number on 1, decrease the second number on 1, increase the third number on 1, and the fourth number should left unchanged. So, after Polycarp changed three elements by one, his sequence became equals to [25,20,15,10], which is an arithmetic progression. In the second example Polycarp should not change anything, because his sequence is an arithmetic progression. In the third example it is impossible to make an arithmetic progression. In the fourth example Polycarp should change only the first element, he should decrease it on one. After that his sequence will looks like [0,3,6,9,12], which is an arithmetic progression. 题目大意给定一组数，对每一个数可以不操作，或者+1，或者-1（加减记录改变次数），问这一组数是否可以通过操作变为等差数列 若可以，输出所需改变次数的最小值。 若不可以，输出-1. 解题思路对每种可能的gap遍历数据，更新需要更改的次数的最小值。gap由前两项a[0],a[1]确定，共有9种可能。确定gap后开始从a[2]开始遍历数组，一旦出现不符合则跳出，全部符合则更新最小操作数。 解题代码12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364656667686970717273747576777879808182838485868788#include &lt;cstdio&gt;#include &lt;cmath&gt;#include &lt;cstring&gt;#include &lt;iostream&gt;#include &lt;set&gt;#include &lt;string&gt;#include &lt;iomanip&gt;#include &lt;algorithm&gt;#include &lt;queue&gt;#include &lt;vector&gt;#include &lt;map&gt;#define INF 0x3f3f3f3f#define eps 1e-8using namespace std;const int maxn=1e5+5;typedef long long ll;ll a[maxn+10];int ans; int n,m,t;int main()&#123; while(~scanf("%d",&amp;n)) &#123; ans=INF; for(int i=0;i&lt;n;i++) scanf("%I64d",&amp;a[i]); if(n==1) &#123; printf("0\n"); continue; &#125; ll gap=a[1]-a[0]; ll origin0=a[0],origin1=a[1],ogap=a[1]-a[0]; //第一种情况 for(int i=0;i&lt;9;i++) &#123; int ccnt=0; if(i==0) a[0]=origin0-1,a[1]=origin1-1,ccnt=2; else if(i==1) a[0]=origin0,a[1]=origin1-1,ccnt=1; else if(i==2) a[0]=origin0+1,a[1]=origin1-1,ccnt=2; else if(i==3) a[0]=origin0-1,a[1]=origin1,ccnt=1; else if(i==4) a[0]=origin0,a[1]=origin1,ccnt=0; else if(i==5) a[0]=origin0+1,a[1]=origin1,ccnt=1; else if(i==6) a[0]=origin0-1,a[1]=origin1+1,ccnt=2; else if(i==7) a[0]=origin0,a[1]=origin1+1,ccnt=1; else if(i==8) a[0]=origin0+1,a[1]=origin1+1,ccnt=2; gap=a[1]-a[0]; //开始遍历剩余 int j=2; ll last=a[1]; for(;j&lt;n;j++) &#123;// printf("before a[j]-last=%d\n",a[j]-last); if(a[j]-last==gap) &#123; last=a[j]; continue; &#125; else if(a[j]-last==gap+1) &#123; last=a[j]-1; ccnt++; continue; &#125; else if(a[j]-last==gap-1) &#123; last=a[j]+1; ccnt++; continue; &#125; else break; &#125; if(j==n) ans=min(ans,ccnt); &#125; if(ans==INF) printf("-1\n"); else printf("%d\n",ans); &#125;&#125; 收获与反思 想到可能的等差gap值。 暴力遍历每种gap的可能。]]></content>
      <categories>
        <category>编程</category>
        <category>ACM</category>
      </categories>
      <tags>
        <tag>算法</tag>
        <tag>ACM</tag>
        <tag>math</tag>
        <tag>2018春季训练</tag>
        <tag>CodeForces</tag>
        <tag>暴力</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[【CodeForces-978C】解题报告（水题，前缀和）]]></title>
    <url>%2Fpost%2F9c649212.html</url>
    <content type="text"><![CDATA[原始题目Letters time limit per test4 seconds memory limit per test256 megabytes inputstandard input outputstandard output There are n dormitories in Berland State University, they are numbered with integers from 1 to n. Each dormitory consists of rooms, there are ai rooms in i-th dormitory. The rooms in i-th dormitory are numbered from 1 to ai. A postman delivers letters. Sometimes there is no specific dormitory and room number in it on an envelope. Instead of it only a room number among all rooms of all n dormitories is written on an envelope. In this case, assume that all the rooms are numbered from 1 to a1+a2+⋯+an and the rooms of the first dormitory go first, the rooms of the second dormitory go after them and so on. For example, in case n=2, a1=3 and a2=5 an envelope can have any integer from 1 to 8 written on it. If the number 7 is written on an envelope, it means that the letter should be delivered to the room number 4 of the second dormitory. For each of m letters by the room number among all n dormitories, determine the particular dormitory and the room number in a dormitory where this letter should be delivered. InputThe first line contains two integers n and m (1≤n,m≤2⋅105) — the number of dormitories and the number of letters. The second line contains a sequence a1,a2,…,an (1≤ai≤1010), where ai equals to the number of rooms in the i-th dormitory. The third line contains a sequence b1,b2,…,bm (1≤bj≤a1+a2+⋯+an), where bj equals to the room number (among all rooms of all dormitories) for the j-th letter. All bj are given in increasing order. OutputPrint m lines. For each letter print two integers f and k — the dormitory number f (1≤f≤n) and the room number k in this dormitory (1≤k≤af) to deliver the letter. ExamplesInput3 6 10 15 12 1 9 12 23 26 37 Output1 1 1 9 2 2 2 13 3 1 3 12 Input2 3 5 10000000000 5 6 9999999999 Output1 5 2 1 2 9999999994 NoteIn the first example letters should be delivered in the following order: the first letter in room 1 of the first dormitory the second letter in room 9 of the first dormitory the third letter in room 2 of the second dormitory the fourth letter in room 13 of the second dormitory the fifth letter in room 1 of the third dormitory the sixth letter in room 12 of the third dormitory 题目大意给出n个公寓的房间数，给出从第一个房间开始计数的房间号，要求输出按公寓分开后每个房间对应的公寓号码和在本公寓的房间号码 解题思路根据n个公寓的房间数处理出前缀和，顺序遍历前缀和数组，对每个查询求差值即可。 解题代码123456789101112131415161718192021222324252627282930313233343536373839404142434445464748#include &lt;cstdio&gt;#include &lt;cstring&gt;#include &lt;iostream&gt;#include &lt;set&gt;#include &lt;queue&gt;#include &lt;map&gt;#include &lt;vector&gt;#include &lt;algorithm&gt;#define eps 1e-8#define INF 0x3f3f3f3fusing namespace std;const int maxn=2e5+5;typedef long long ll;ll gcd(ll a,ll b)&#123; return a?gcd(b%a,a):b;&#125;ll lcm(ll a,ll b)&#123; return a/gcd(a,b)*b; &#125; ll n,m,vis[maxn],ans[maxn],cnt;ll a[maxn],sum[maxn];int main()&#123; while(~scanf("%lld%d",&amp;n,&amp;m)) &#123; sum[0]=0; for(ll i=1;i&lt;=n;i++) &#123; scanf("%lld",&amp;sum[i]); sum[i]+=sum[i-1]; //处理前缀和 &#125; ll temp; ll j=0; for(ll i=0;i&lt;m;i++) &#123; scanf("%I64d",&amp;temp); while(temp&gt;sum[j]) j++; printf("%I64d %I64d\n",j,temp-sum[j-1]); &#125; &#125;&#125; 收获与反思前缀和应用。注意如果查询不按顺序的话应该采用二分查找。]]></content>
      <categories>
        <category>编程</category>
        <category>ACM</category>
      </categories>
      <tags>
        <tag>算法</tag>
        <tag>ACM</tag>
        <tag>2018春季训练</tag>
        <tag>水题</tag>
        <tag>CodeForces</tag>
        <tag>前缀和</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[【CodeForces-978B】解题报告（水题，贪心，字符串）]]></title>
    <url>%2Fpost%2F5abc6d45.html</url>
    <content type="text"><![CDATA[原始题目File Name time limit per test1 second memory limit per test256 megabytes inputstandard input outputstandard output You can not just take the file and send it. When Polycarp trying to send a file in the social network “Codehorses”, he encountered an unexpected problem. If the name of the file contains three or more “x” (lowercase Latin letters “x”) in a row, the system considers that the file content does not correspond to the social network topic. In this case, the file is not sent and an error message is displayed. Determine the minimum number of characters to remove from the file name so after that the name does not contain “xxx” as a substring. Print 0 if the file name does not initially contain a forbidden substring “xxx”. You can delete characters in arbitrary positions (not necessarily consecutive). If you delete a character, then the length of a string is reduced by 1. For example, if you delete the character in the position 2 from the string “exxxii”, then the resulting string is “exxii”. InputThe first line contains integer n (3≤n≤100) — the length of the file name. The second line contains a string of length n consisting of lowercase Latin letters only — the file name. OutputPrint the minimum number of characters to remove from the file name so after that the name does not contain “xxx” as a substring. If initially the file name dost not contain a forbidden substring “xxx”, print 0. ExamplesInput6 xxxiii Output1 Input5 xxoxx Output0 Input10 xxxxxxxxxx Output8 NoteIn the first example Polycarp tried to send a file with name contains number 33, written in Roman numerals. But he can not just send the file, because it name contains three letters “x” in a row. To send the file he needs to remove any one of this letters. 题目大意文件名中超过n个（n&gt;=3）连续的x时需要修改n-2次。 解题思路每次贪心的取最大连续个x值，然后判断累加即可。 解题代码12345678910111213141516171819202122232425262728293031323334353637383940414243444546#include &lt;cstdio&gt;#include &lt;cstring&gt;#include &lt;iostream&gt;#include &lt;set&gt;#include &lt;queue&gt;#include &lt;map&gt;#include &lt;vector&gt;#include &lt;algorithm&gt;#define eps 1e-8#define INF 0x3f3f3f3fusing namespace std;const int maxn=1e5+5;typedef long long ll;ll gcd(ll a,ll b)&#123; return a?gcd(b%a,a):b;&#125;ll lcm(ll a,ll b)&#123; return a/gcd(a,b)*b; &#125; int n,m,vis[maxn],ans[maxn],cnt;char a[maxn];int main()&#123; while(~scanf("%d",&amp;n)) &#123; getchar(); cnt=0; int ccnt=0;char temp; gets(a); for(int i=0;i&lt;n;i++) &#123; if(a[i]=='x') ccnt++; else &#123; if(ccnt&gt;=3) cnt+=ccnt-2; ccnt=0; &#125; &#125; if(ccnt&gt;=3) cnt+=ccnt-2; printf("%d\n",cnt); &#125; &#125; 收获与反思字符串简单贪心]]></content>
      <categories>
        <category>编程</category>
        <category>ACM</category>
      </categories>
      <tags>
        <tag>算法</tag>
        <tag>ACM</tag>
        <tag>2018春季训练</tag>
        <tag>Greedy</tag>
        <tag>CodeForces</tag>
        <tag>字符串</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[【CodeForces-978A】解题报告（水题）]]></title>
    <url>%2Fpost%2F36e5881d.html</url>
    <content type="text"><![CDATA[原始题目Remove Duplicates time limit per test1 second memory limit per test256 megabytes inputstandard input outputstandard output Petya has an array a consisting of n integers. He wants to remove duplicate (equal) elements. Petya wants to leave only the rightmost entry (occurrence) for each element of the array. The relative order of the remaining unique elements should not be changed. InputThe first line contains a single integer n (1≤n≤50) — the number of elements in Petya’s array. The following line contains a sequence a1,a2,…,an (1≤ai≤1000) — the Petya’s array. OutputIn the first line print integer x — the number of elements which will be left in Petya’s array after he removed the duplicates. In the second line print x integers separated with a space — Petya’s array after he removed the duplicates. For each unique element only the rightmost entry should be left. ExamplesInput6 1 5 5 1 6 1 Output3 5 6 1 Input5 2 4 2 4 4 Output2 2 4 Input5 6 6 6 6 6 Output1 6 NoteIn the first example you should remove two integers 1, which are in the positions 1 and 4. Also you should remove the integer 5, which is in the position 2. In the second example you should remove integer 2, which is in the position 1, and two integers 4, which are in the positions 2 and 4. In the third example you should remove four integers 6, which are in the positions 1, 2, 3 and 4. 题目大意给一组数，输出不重复的数个数，按序输出。 解题思路水题 解题代码123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354#include &lt;cstdio&gt;#include &lt;cstring&gt;#include &lt;iostream&gt;#include &lt;set&gt;#include &lt;queue&gt;#include &lt;map&gt;#include &lt;vector&gt;#include &lt;algorithm&gt;#define eps 1e-8#define INF 0x3f3f3f3fusing namespace std;const int maxn=1e5+5;typedef long long ll;ll gcd(ll a,ll b)&#123; return a?gcd(b%a,a):b;&#125;ll lcm(ll a,ll b)&#123; return a/gcd(a,b)*b; &#125; int a[maxn],n,m,vis[maxn],ans[maxn],cnt;int main()&#123; while(~scanf("%d",&amp;n)) &#123; cnt=0; memset(vis,0,sizeof(vis)); for(int i=1;i&lt;=n;i++) &#123; scanf("%d",&amp;a[i]); &#125; for(int i=n;i&gt;=1;i--) &#123;// printf("%d",a[i]); if(!vis[a[i]]) &#123; ans[cnt++]=a[i]; vis[a[i]]=1; &#125; &#125; printf("%d\n",cnt); for(int i=cnt-1;i&gt;=0;i--) &#123; if(i==0) printf("%d",ans[i]); else printf("%d ",ans[i]); &#125; printf("\n"); &#125;&#125; 收获与反思无，注意细节一遍成功即可。]]></content>
      <categories>
        <category>编程</category>
        <category>ACM</category>
      </categories>
      <tags>
        <tag>算法</tag>
        <tag>ACM</tag>
        <tag>2018春季训练</tag>
        <tag>水题</tag>
        <tag>CodeForces</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[【CSU-1023】解题报告（二分）]]></title>
    <url>%2Fpost%2F109aa3c8.html</url>
    <content type="text"><![CDATA[原始题目1023: 修路 Time Limit: 1 Sec Memory Limit: 128 Mb Submitted: 632 Solved: 340Description前段时间，某省发生干旱，B山区的居民缺乏生活用水，现在需要从A城市修一条通往B山区的路。假设有A城市通往B山区的路由$m$条连续的路段组成，现在将这m条路段承包给$n$个工程队$(n ≤ m ≤ 300)$。为了修路的便利，每个工程队只能分配到连续的若干条路段（当然也可能只分配到一条路段或未分配到路段）。假设每个工程队修路的效率一样，即每修长度为$1$的路段所需的时间为$1$。现在给出路段的数量$m$，工程队的数量$n$，以及$m$条路段的长度（这$m$条路段的长度是按照从A城市往B山区的方向依次给出，每条路段的长度均小于$1000$），需要你计算出修完整条路所需的最短的时间（即耗时最长的工程队所用的时间）。 Input第一行是测试样例的个数T ，接下来是T个测试样例，每个测试样例占2行，第一行是路段的数量m和工程队的数量n，第二行是m条路段的长度。 Output对于每个测试样例，输出修完整条路所需的最短的时间。 Sample Input2 4 3 100 200 300 400 9 4 250 100 150 400 550 200 50 700 300 Sample Output400 900 HintSource中南大学第四届大学生程序设计竞赛 解题思路 每个队伍必须连续修路，每个队伍效率相同（每天都修单位长度） 可以得到修路的下限和上限，二分修路长度最终得到答案 解题代码123456789101112131415161718192021222324252627282930313233343536373839404142434445464748#include &lt;cstdio&gt;#include &lt;cstring&gt;#include &lt;iostream&gt;#include &lt;set&gt;#include &lt;queue&gt;#include &lt;algorithm&gt;#include &lt;queue&gt;using namespace std;const int maxn=1e5+5;int t,n,m;int road[maxn];int main()&#123; scanf("%d",&amp;t); while(t--) &#123; memset(road,0,sizeof(road)); scanf("%d%d",&amp;m,&amp;n); int high=0,low=0; for(int i=0;i&lt;m;i++) &#123; scanf("%d",&amp;road[i]); high+=road[i]; low=max(road[i],low); &#125; while(low&lt;high) //二分修路的长度 &#123; int mid=(high+low)&gt;&gt;1;// printf("now mid=%d\n",mid); int tot=n-1,sum=road[0]; //一共还有n-1个人可以用 for(int i=1;i&lt;m;i++) &#123; if(sum+road[i]&gt;mid) &#123; tot--; sum=road[i]; &#125; else sum+=road[i]; if(tot&lt;0) break; &#125; if(tot&lt;0) low=mid+1; else high=mid; &#125; printf("%d\n",low); &#125; &#125; 收获与反思 二分思维转换 已知上界下界后利用二分逼近答案]]></content>
      <categories>
        <category>编程</category>
        <category>ACM</category>
      </categories>
      <tags>
        <tag>算法</tag>
        <tag>ACM</tag>
        <tag>2018春季训练</tag>
        <tag>CSU</tag>
        <tag>二分</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[【HDU-1166】解题报告（线段树求和，点维护）]]></title>
    <url>%2Fpost%2F454c2118.html</url>
    <content type="text"><![CDATA[原始题目敌兵布阵 Time Limit: 2000/1000 MS (Java/Others) Memory Limit: 65536/32768 K (Java/Others) Total Submission(s): 111269 Accepted Submission(s): 46637 Problem Description C国的死对头A国这段时间正在进行军事演习，所以C国间谍头子Derek和他手下Tidy又开始忙乎了。A国在海岸线沿直线布置了N个工兵营地,Derek和Tidy的任务就是要监视这些工兵营地的活动情况。由于采取了某种先进的监测手段，所以每个工兵营地的人数C国都掌握的一清二楚,每个工兵营地的人数都有可能发生变动，可能增加或减少若干人手,但这些都逃不过C国的监视。中央情报局要研究敌人究竟演习什么战术,所以Tidy要随时向Derek汇报某一段连续的工兵营地一共有多少人,例如Derek问:“Tidy,马上汇报第3个营地到第10个营地共有多少人!”Tidy就要马上开始计算这一段的总人数并汇报。但敌兵营地的人数经常变动，而Derek每次询问的段都不一样，所以Tidy不得不每次都一个一个营地的去数，很快就精疲力尽了，Derek对Tidy的计算速度越来越不满:”你个死肥仔，算得这么慢，我炒你鱿鱼!”Tidy想：“你自己来算算看，这可真是一项累人的工作!我恨不得你炒我鱿鱼呢!”无奈之下，Tidy只好打电话向计算机专家Windbreaker求救,Windbreaker说：“死肥仔，叫你平时做多点acm题和看多点算法书，现在尝到苦果了吧!”Tidy说：”我知错了。。。”但Windbreaker已经挂掉电话了。Tidy很苦恼，这么算他真的会崩溃的，聪明的读者，你能写个程序帮他完成这项工作吗？不过如果你的程序效率不够高的话，Tidy还是会受到Derek的责骂的. Input第一行一个整数$T$，表示有$T$组数据。每组数据第一行一个正整数$N(N \le 50000)$,表示敌人有$N$个工兵营地，接下来有$N$个正整数,第$i$个正整数$a_i$代表第$i$个工兵营地里开始时有$a_i$个人$(1 \le ai \le 50)$。接下来每行有一条命令，命令有4种形式：(1) Add i j,i和j为正整数,表示第i个营地增加j个人（j不超过30）(2)Sub i j ,i和j为正整数,表示第i个营地减少j个人（j不超过30）;(3)Query i j ,i和j为正整数,i&lt;=j，表示询问第i到第j个营地的总人数;(4)End 表示结束，这条命令在每组数据最后出现;每组数据最多有$40000$条命令 Output对第i组数据,首先输出“Case i:”和回车,对于每个Query询问，输出一个整数并回车,表示询问的段中的总人数,这个数保持在int以内。 Sample Input1 10 1 2 3 4 5 6 7 8 9 10 Query 1 3 Add 3 6 Query 2 7 Sub 10 2 Add 6 3 Query 3 10 End Sample OutputCase 1: 6 33 59 AuthorWindbreaker RecommendEddy 题目大意见中文 解题思路线段树入门题目，点修改（含正负情况），区间询问，注意 解题代码123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106#include &lt;cstdio&gt;#include &lt;cstring&gt;#include &lt;cmath&gt;#include &lt;iostream&gt;#include &lt;iomanip&gt;#include &lt;set&gt;#include &lt;queue&gt;#include &lt;map&gt;#include &lt;vector&gt;#include &lt;algorithm&gt;#include &lt;stack&gt;using namespace std;typedef long long ll;const int maxn=2e5+5;struct node&#123; ll l,r,sum;&#125;tree[maxn];ll a[maxn];void build(ll k, ll l,ll r)&#123; tree[k].l=l; tree[k].r=r; if(tree[k].l==tree[k].r) &#123; tree[k].sum=a[l]; return ; &#125; ll mid=(tree[k].l+tree[k].r)&gt;&gt;1; build(k&lt;&lt;1,l,mid); build(k&lt;&lt;1|1,mid+1,r); tree[k].sum=tree[k&lt;&lt;1].sum+tree[k&lt;&lt;1|1].sum;// printf("k==%lld k.sum==%lld\n",k,tree[k].sum);&#125;void change(ll k,ll d,ll x)&#123; if(tree[k].l==tree[k].r&amp;&amp;tree[k].r==d) &#123; tree[k].sum=tree[k].sum+x; return ; &#125; int mid=(tree[k].l+tree[k].r)&gt;&gt;1; if(d&gt;=tree[k].l&amp;&amp;d&lt;=mid) change(k&lt;&lt;1,d,x); else change(k&lt;&lt;1|1,d,x); tree[k].sum=tree[k&lt;&lt;1].sum+tree[k&lt;&lt;1|1].sum; &#125;ll query(ll k,ll l,ll r)&#123; if(tree[k].l==l&amp;&amp;tree[k].r==r) return tree[k].sum; ll mid=(tree[k].l+tree[k].r)&gt;&gt;1; if(r&lt;=mid) return query(k&lt;&lt;1,l,r); else if(l&gt;=mid+1) return query(k&lt;&lt;1|1,l,r); else return query(k&lt;&lt;1,l,mid)+query(k&lt;&lt;1|1,mid+1,r); &#125;char ch[10];ll t,n,d,x;int main() &#123;// freopen("in.txt","r",stdin);// freopen("out.txt","w",stdout); while(~scanf("%lld",&amp;t)) &#123; int cnt=0; while(t--) &#123; memset(tree,0,sizeof(tree)); memset(a,0,sizeof(a)); cnt++; printf("Case %d:\n",cnt); scanf("%lld",&amp;n); for(int i=1;i&lt;=n;i++) scanf("%lld",&amp;a[i]); build(1,1,n); while(scanf("%s",ch)&amp;&amp;ch[0]!='E') &#123; if(ch[0]=='Q') &#123; scanf("%lld%lld",&amp;d,&amp;x); printf("%lld\n",query(1,d,x)); &#125; else if(ch[0]=='A') &#123; scanf("%lld%lld",&amp;d,&amp;x); change(1,d,x); &#125; else if(ch[0]=='S') &#123; scanf("%lld%lld",&amp;d,&amp;x); change(1,d,-x); &#125; &#125; &#125; &#125; &#125; 收获与反思 Emmm，WA了两次是因为数组开的不够大，这个以为够用了，待分析原因。 进一步熟悉模板。 注意long long。]]></content>
      <categories>
        <category>编程</category>
        <category>ACM</category>
      </categories>
      <tags>
        <tag>算法</tag>
        <tag>ACM</tag>
        <tag>2018春季训练</tag>
        <tag>HDU</tag>
        <tag>线段树</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[【POJ-3468】解题报告（线段树求和，区间维护）]]></title>
    <url>%2Fpost%2F481e8abf.html</url>
    <content type="text"><![CDATA[原始题目A Simple Problem with Integers Time Limit: 5000MS Memory Limit: 131072K Total Submissions: 129411 Accepted: 40139 Case Time Limit: 2000MS Description You have N integers, A1, A2, … , AN. You need to deal with two kinds of operations. One type of operation is to add some given number to each number in a given interval. The other is to ask for the sum of numbers in a given interval. InputThe first line contains two numbers N and Q. 1 ≤ N,Q ≤ 100000.The second line contains N numbers, the initial values of A1, A2, … , AN. -1000000000 ≤ Ai ≤ 1000000000.Each of the next Q lines represents an operation.“C a b c” means adding c to each of Aa, Aa+1, … , Ab. -10000 ≤ c ≤ 10000.“Q a b” means querying the sum of Aa, Aa+1, … , Ab. OutputYou need to answer all Q commands in order. One answer in a line. Sample Input10 5 1 2 3 4 5 6 7 8 9 10 Q 4 4 Q 1 10 Q 2 4 C 3 6 3 Q 2 4 Sample Output4 55 9 15 HintThe sums may exceed the range of 32-bit integers. SourcePOJ Monthly—2007.11.25, Yang Yi 题目大意对于一组序列A,有两种操作，询问：给出对应区间序列的和，增加：给出对应区间区间内所有点增加固定值。 解题思路线段树模板题，区间询问，区间修改，注意long long即可。 解题代码123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147148149150151152153154155156#include &lt;cstdio&gt;#include &lt;cstring&gt;#include &lt;cmath&gt;#include &lt;cmath&gt;#include &lt;iostream&gt;#include &lt;iomanip&gt;#include &lt;string&gt;#include &lt;set&gt;#include &lt;queue&gt;#include &lt;vector&gt;#include &lt;map&gt;using namespace std;const int maxn=2e5+5;typedef long long ll;ll n,m;ll d,x;ll b,e;ll a[maxn];struct node&#123; ll l; ll r; ll sum; ll tag; ll maxnum;&#125;tree[maxn&lt;&lt;2];char ch[2];void build(ll k,ll l,ll r) //k为线段树的角标 &#123; tree[k].l=l; tree[k].r=r; if(l==r) &#123; tree[k].sum=a[l]=a[r]; //叶子节点，单点的sum即是本身 return ; &#125; ll mid=(l+r)&gt;&gt;1; build(k&lt;&lt;1,l,mid); //递归构建左线段（左子树） build(k&lt;&lt;1|1,mid+1,r); //递归构建右线段（右子树） tree[k].sum=tree[k&lt;&lt;1].sum+tree[k&lt;&lt;1|1].sum; return ; &#125;void change1(ll k,ll d,ll x)&#123; if(tree[k].l==tree[k].r&amp;&amp;tree[k].r==d) //找到索引点 &#123; tree[k].maxnum=x; //修改最大值 return ; //修改后再开始回溯 &#125; ll mid=(tree[k].l+tree[k].r)&gt;&gt;1; if(d&gt;=tree[k].l&amp;&amp;d&lt;=mid) //查找点在左子树 change1(k&lt;&lt;1,d,x); //k&lt;&lt;1为左子树, else //查找点在右子树， change1(k&lt;&lt;1|1,d,x); //k&lt;&lt;1|1为右子树 tree[k].maxnum=max(tree[k&lt;&lt;1].maxnum,tree[k&lt;&lt;1|1].maxnum); //递归从新计算非叶结点的值 &#125;void change(ll k) //懒惰操作，有标记才操作一次，有记忆性 &#123; if(tree[k].l==tree[k].r) tree[k].sum+=tree[k].tag; else &#123; tree[k].sum+=(tree[k].r-tree[k].l+1)*tree[k].tag; tree[k&lt;&lt;1].tag+=tree[k].tag; tree[k&lt;&lt;1|1].tag+=tree[k].tag; &#125; tree[k].tag=0; //自身标记清零 &#125;void add(ll k,ll l,ll r,ll x)&#123; if(tree[k].tag) &#123;// printf("--"); change(k); &#125; if(tree[k].l==l&amp;&amp;tree[k].r==r) //在固定的区间打标记 &#123; tree[k].tag+=x; //向下打标记 // printf("k=%lld l=%lld r=%lld tag=%lld\n",k ,l,r,tree[k].tag); return ; &#125;// printf("1 %lld\n",tree[k].sum); tree[k].sum+=(r-l+1)*x;// printf("2 %lld\n",tree[k].sum); ll mid=(tree[k].r+tree[k].l)&gt;&gt;1; if(r&lt;=mid) add(k&lt;&lt;1,l,r,x); else if(l&gt;=mid+1) add(k&lt;&lt;1|1,l,r,x); else &#123; add(k&lt;&lt;1,l,mid,x); add(k&lt;&lt;1|1,mid+1,r,x); &#125;&#125;ll query(ll k,ll l,ll r)&#123;// printf("query %lld .tag=%lld\n",k,tree[k].tag); if(tree[k].tag) &#123;// printf("$"); change(k); &#125; ll mid=(tree[k].l+tree[k].r)&gt;&gt;1; if(tree[k].l==l&amp;&amp;tree[k].r==r) return tree[k].sum; if(r&lt;=mid) return query(k&lt;&lt;1,l,r); else if(l&gt;=mid+1) return query(k&lt;&lt;1|1,l,r); else return query(k&lt;&lt;1,l,mid)+query(k&lt;&lt;1|1,mid+1,r); //中线跨区间 &#125;int main()&#123; while(~scanf("%lld%lld",&amp;n,&amp;m)) &#123; memset(tree,0,sizeof(tree)); for(ll i=1;i&lt;=n;i++) &#123; scanf("%lld",&amp;a[i]); &#125; build(1,1,n); for(ll i=1;i&lt;=m;i++) &#123; scanf("%s",ch); if(ch[0]=='Q') &#123; scanf("%lld%lld",&amp;b,&amp;e);// printf("11"); printf("%lld\n",query(1,b,e)); &#125; else &#123; scanf("%lld%lld%lld",&amp;b,&amp;e,&amp;x); add(1,b,e,x); &#125; &#125; &#125;&#125; 收获与反思 注意数组不要越界，注意long long。 写模板注意sum的写法和取最大值的写法略有不同。 理解lazy（tag）标记，即访问到时才进行一次向下扩展，每次修改并不直接作用于叶子节点。]]></content>
      <categories>
        <category>编程</category>
        <category>ACM</category>
      </categories>
      <tags>
        <tag>算法</tag>
        <tag>ACM</tag>
        <tag>2018春季训练</tag>
        <tag>HDU</tag>
        <tag>线段树</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[【HDU-1754】解题报告（线段树最大值，点维护）]]></title>
    <url>%2Fpost%2F4e876bc2.html</url>
    <content type="text"><![CDATA[原始题目I Hate It Time Limit: 9000/3000 MS (Java/Others) Memory Limit: 32768/32768 K (Java/Others) Total Submission(s): 92291 Accepted Submission(s): 35036 Problem Description很多学校流行一种比较的习惯。老师们很喜欢询问，从某某到某某当中，分数最高的是多少。这让很多学生很反感。 不管你喜不喜欢，现在需要你做的是，就是按照老师的要求，写一个程序，模拟老师的询问。当然，老师有时候需要更新某位同学的成绩。 Input本题目包含多组测试，请处理到文件结束。在每个测试的第一行，有两个正整数 N 和 M ( 0&lt;N≤200000,0&lt;M&lt;5000 )，分别代表学生的数目和操作的数目。学生ID编号分别从1编到N。第二行包含N个整数，代表这N个学生的初始成绩，其中第i个数代表ID为i的学生的成绩。接下来有M行。每一行有一个字符 C (只取’Q’或’U’) ，和两个正整数A，B。当C为’Q’的时候，表示这是一条询问操作，它询问ID从A到B(包括A,B)的学生当中，成绩最高的是多少。当C为’U’的时候，表示这是一条更新操作，要求把ID为A的学生的成绩更改为B。 Output对于每一次询问操作，在一行里面输出最高成绩。 Sample Input5 6 1 2 3 4 5 Q 1 5 U 3 6 Q 3 4 Q 4 5 U 2 9 Q 1 5 Sample Output5 6 5 9 HintHuge input,the C function scanf() will work better than cin Authorlinle Source2007省赛集训队练习赛（6）_linle专场 Recommendlcy 题目大意如中文 解题思路线段树模板题，点修改，维护最大值 解题代码1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465666768697071727374757677787980818283848586878889909192939495969798#include &lt;cstdio&gt;#include &lt;cstring&gt;#include &lt;cmath&gt;#include &lt;cmath&gt;#include &lt;iostream&gt;#include &lt;iomanip&gt;#include &lt;string&gt;#include &lt;set&gt;#include &lt;queue&gt;#include &lt;vector&gt;#include &lt;map&gt;using namespace std;const int maxn=2e5+5;int n,m;int d,x;int a[maxn];struct node&#123; int l; int r; int maxnum;&#125;tree[maxn&lt;&lt;2];char ch[2];void build(int k,int l,int r) //k为线段树的角标 &#123; tree[k].l=l; tree[k].r=r; if(l==r) &#123; tree[k].maxnum=a[l]=a[r]; //叶子节点，单点的max值就是该点的值 return ; &#125; int mid=(l+r)&gt;&gt;1; build(k&lt;&lt;1,l,mid); //递归构建左线段（左子树） build(k&lt;&lt;1|1,mid+1,r); //递归构建右线段（右子树） tree[k].maxnum=max(tree[k&lt;&lt;1].maxnum,tree[k&lt;&lt;1|1].maxnum); //根节点的最大值是左右子树最大值的max return ; &#125;void change(int k,int d,int x)&#123; if(tree[k].l==tree[k].r&amp;&amp;tree[k].r==d) //找到索引点 &#123; tree[k].maxnum=x; //修改最大值 return ; //修改后再开始回溯 &#125; int mid=(tree[k].l+tree[k].r)&gt;&gt;1; if(d&gt;=tree[k].l&amp;&amp;d&lt;=mid) //查找点在左子树 change(k&lt;&lt;1,d,x); //k&lt;&lt;1为左子树, else //查找点在右子树， change(k&lt;&lt;1|1,d,x); //k&lt;&lt;1|1为右子树 tree[k].maxnum=max(tree[k&lt;&lt;1].maxnum,tree[k&lt;&lt;1|1].maxnum); //递归从新计算非叶结点的值 &#125;int query(int k,int l,int r)&#123; int maxnum; if(tree[k].l==l&amp;&amp;tree[k].r==r) return tree[k].maxnum; int mid=(tree[k].l+tree[k].r)&gt;&gt;1; if(r&lt;=mid) maxnum=query(k&lt;&lt;1,l,r); else if(l&gt;=mid+1) maxnum=query(k&lt;&lt;1|1,l,r); else maxnum=max(query(k&lt;&lt;1,l,mid),query(k&lt;&lt;1|1,mid+1,r)); //中线跨区间 return maxnum;&#125;int main()&#123; while(~scanf("%d%d",&amp;n,&amp;m)) &#123; memset(tree,0,sizeof(tree)); for(int i=1;i&lt;=n;i++) &#123; scanf("%d",&amp;a[i]); &#125; build(1,1,n); for(int i=1;i&lt;=m;i++) &#123; scanf("%s%d%d",ch,&amp;d,&amp;x); if(ch[0]=='Q') //查询输入 &#123; printf("%d\n",query(1,d,x)); &#125; else change(1,d,x); &#125; &#125;&#125; 收获与反思 对模板的理解都写在注释里了 本题是维护最大值，可以用int替换ll 切记memset数组]]></content>
      <categories>
        <category>编程</category>
        <category>ACM</category>
      </categories>
      <tags>
        <tag>算法</tag>
        <tag>ACM</tag>
        <tag>2018春季训练</tag>
        <tag>HDU</tag>
        <tag>线段树</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[【CSU-1977】解题报告（二进制，位运算，读题》]]></title>
    <url>%2Fpost%2F4f352d.html</url>
    <content type="text"><![CDATA[原始题目Bit-reversal Permutation Time Limit: 1 Sec Memory Limit: 128 Mb Submitted: 81 Solved: 27 DescriptionA fast Fourier transform (FFT) algorithm computes the discrete Fourier transform (DFT) of a sequence, or its inverse (IFFT). Fourier analysis converts a signal from its original domain (often time or space) to a representation in the frequency domain and vice versa. An FFT rapidly computes such transformations by factorizing the DFT matrix into a product of sparse (mostly zero) factors. As a result, it manages to reduce the complexity of computing the DFT from O(n2), which arises if one simply applies the definition of DFT, to O(nlogn), where n is the data size. ——From Wikipedia During this summer holiday, csuxushu feels so bored to learn FFT. Because FFT is a complicated algorithm, he need to apply a bit-reversal permutation to a sequence first before DFT which is a part of FFT. In applied mathematics, a bit-reversal permutation is a permutation of a sequence of n items, where n = 2^k is a power of two. It is defined by indexing the elements of the sequence by the numbers from 0 to n − 1 and then reversing the binary representations of each of these numbers (padded so that each of these binary numbers has length exactly k). Each item is then mapped to the new position given by this reversed value. Because all fellows in CSU(California State University ) can apply FFT, NTT or even FWT, it is a shame that he even doesn’t know how to take the first step. As one of the best computer programmer in CSU, can you help him? You may think this problem is too hard to solve. In fact, it is a piece of cake to you. Remember to see the hint :-) InputThe first line of the input gives the number of test cases T(T≤10); T test cases follow.Each test case contains a number sequence.In each case, the first line is a number N(1≤N≤10^5), the number of elements in the following sequence.The second line is the sequence.Its length may not be exactly a power of two, so you can append some zeros to make it the minimal power of two larger than or equal to N. OutputFor each test case, output the sequence from input in bit-reversal order. Sample Input1 6 21 58 96 12 45 65 Sample Output21 45 96 0 58 65 12 0 HintBit-reverse Order （图片待添加） 中文提示：可以看到，我们最终处理的系数从左至右的编号的二进制形式分别为000,100,010,110,001,101,011,111，若将其二进制反序，可得000,001,010,011,100,101,110,111，这些反序的二进制编码是从小到大排列的。也就是说，我们可以按照每个下标的二进制编码来确定处理系数的顺序。这种方法就称为位逆序置换(Bit-reversal permutation)。 Source2017年8月月赛 Author徐戍 题目大意将给定序列按位反转后的顺序输出 解题思路看中文提示和图示就能不明白，将序列顺序（从0开始）用二进制位表示后位反转，按反转后从小到大顺序输出。 解题代码123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051#include &lt;cstdio&gt;#include &lt;cstring&gt;#include &lt;set&gt;#include &lt;cmath&gt;#include &lt;map&gt;#include &lt;queue&gt;#include &lt;algorithm&gt;#include &lt;map&gt;using namespace std;const int maxn=2e5+5;int raw[maxn];int t;int m,n;int main()&#123; while(~scanf("%d",&amp;t)) &#123; while(t--) &#123; scanf("%d",&amp;m); &#123; n=0; memset(raw,0,sizeof(raw)); while(pow(2,n)&lt;m) n++; for(int i=0;i&lt;m;i++) &#123; scanf("%d",&amp;raw[i]); &#125; int len=pow(2,n); for(int i=0;i&lt;len;i++) &#123; int bit=0,b=i; for(int j=0;j&lt;n;j++) &#123; bit=bit|(b&amp;1); b&gt;&gt;=1; bit&lt;&lt;=1; &#125;// printf("bit=%d\n",bit); bit&gt;&gt;=1; if(i==0) printf("%d",raw[bit]); else printf(" %d",raw[bit]); &#125; printf("\n"); &#125; &#125; &#125;&#125; 收获与反思用二进制计算方法（按位与、按位或、左移右移），来替代pow(2,n)。否则超时比如将序号进行位反转后再十进制化的代码。 // b为原始序列号 bit为位反转再十进制化的序列号 int bit=0,b=i; for(int j=0;j&lt;n;j++) { bit=bit|(b&amp;1); b&gt;&gt;=1; bit&lt;&lt;=1; } 这一过程不要用 int bit=0,b=i; for(int j=0;j&lt;n;j++) { if(b&amp;1) bit+=pow(n-1-j); b/=2; } //乘方会慢很多很多]]></content>
      <categories>
        <category>编程</category>
        <category>ACM</category>
      </categories>
      <tags>
        <tag>算法</tag>
        <tag>ACM</tag>
        <tag>2018春季训练</tag>
        <tag>CSU</tag>
        <tag>位运算</tag>
        <tag>补图</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Hello Hexo]]></title>
    <url>%2Fpost%2Fa1751c09.html</url>
    <content type="text"><![CDATA[今日博客搬家 bing 基于Hexo-Next-Gemini 还在搬运Evernote和CSDN上的东西 还有很多功能没有添加，欢迎各位提意见]]></content>
  </entry>
  <entry>
    <title><![CDATA[《1Q84》读书笔记]]></title>
    <url>%2Fpost%2F280fbdcb.html</url>
    <content type="text"><![CDATA[内容摘录第一部 P371 “世界这个东西，青豆啊，就是一种记忆和相反的另一种记忆永无休止的斗争。” 第二部 P262 “人的生命虽然本质上是孤独的存在，却不是孤立的存在。” P270 “但店内除了天吾，只有一对像是大学生的青年男女并肩坐在吧台前，正在交头接耳，起劲地说着悄悄话。望着他们，天吾感到了许久不曾有过的深深地寂寞。在这个世界上，自己是孤独的，和谁都没有关联。” P274 “我当时看见了月亮。青豆也看见了同一个月亮。浮在下午三点半依然十分明亮的天上的灰色岩块。沉默而孤独的卫星。两人并肩而立，望着那个月亮。但是，那究竟意味着什么？难道月亮会领我去青豆所在的地方吗？” P276 “天吾专注着望着月光，心中从远古时代传承下来的记忆般的东西被唤醒了。远在人类获得火、工具和语言之前，月亮就始终不变地是人们的朋友。它作为天赐地灯火，不时照亮黑暗的世界，缓解了人们的恐惧。它地圆缺给了人们时间观念。对月亮这种无偿地感谢之情，纵然在黑暗已从绝大部分地域驱逐的现在，似乎依然牢牢烙印在人类的遗传因子里。作为一种温暖的集体记忆。” P311 “我隔着一条马路看到了她，还因为可能被他拥入怀中而颤抖。虽说只有几分钟，我毕竟也全身心地题为过那种激烈的喜悦和期待。她闭上眼睛，紧攥着滑梯的扶手，咬住嘴唇。” P312 “不过这将无所谓。我将为他而死。我不能为自己而活，这种可能性从一开始就被剥夺了。可是，我却能为他而死。这样就够了。我可以微笑着去死。 这不是谎言。” P338 “他像被遗弃在风暴逝去后的静谧中，无法在任何事物上集中精神。” P341 “父亲依旧纹丝不动，他的双眼被牢牢封闭在那黑暗地深坑底部，望去仿佛在静静地等待降雪，将深坑填成白色。” Emmm…我喜欢带鼓点的纯音乐，因为在不知哪个关键的时刻，想起的鼓点声总能巧妙地切合这个场景。 P350 “这二十年间，他心里时时刻刻装着这位少女的面容。 青豆，天吾叫出声来。 少女沉在深深的睡眠中。似乎是很深的自然的睡眠，连呼吸都极其微弱。她的心脏也只是轻微地鼓动着，虚幻得传不到人的耳朵里。甚至连抬起眼睑得力量都没有……青豆在遥远的地方听见了这呼唤。天吾君，她在心中念道，还清晰地呼出声来。但这句话却不会掀动躺在空气蛹中少女的嘴唇，也不会传入天吾的耳朵。”]]></content>
      <categories>
        <category>阅读</category>
      </categories>
      <tags>
        <tag>阅读</tag>
        <tag>小说</tag>
        <tag>村上春树</tag>
        <tag>1Q84</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[《黑豹》观后感]]></title>
    <url>%2Fpost%2F4255f31a.html</url>
    <content type="text"><![CDATA[总的来说，是近几年漫威出的质量比较高的一部电影了，没有过分卖腐，卖情怀。一点点人格之间的矛盾，一点点反思，剧情衔接也很不错，虽然有一点套路，但是在可接受的范围内。 表弟Killmonger让我想起了铁血孤儿团三日月一众人，还有麦基利斯。悲情么？悲情。可惜么？不可惜。他们的行为注定是孤独的悲情的，但欣慰的是他们的死亡是注入世界的一剂良药，让目睹他们死亡的人能感受到他们心中那一点点不同，然后做出改变（就像黑豹和艾里安议长）。或许人们不会记得他们，但历史会。 黑豹带表弟去看生命中第一次也是最后一次瓦坎达的日落，是为自己的父亲赎罪，也是对叔叔的缅怀。他将不在时电影开头的那个黑豹，从此，父亲与叔叔的两种感情将汇聚在他一人身上。月型草被一把火烧了个干干净净，或许他死后也不会再去自己父亲那里了吧。 但是表弟最后嘴里说出的那句“不自由，毋宁死”确实是把原文的意思曲解了。去Google了一下。原句是这样的 “Bury me in the ocean with my ancestors who jumped from ships, cause they knew death was better than bondage,” 我个人更倾向于表弟想表达的是：不愿意在此处与瓦坎达独享安宁（在他眼里是一种绑架，被历史、被先祖的传统绑架），的不自由（矛盾的焦点不在于他们是否拥有走出瓦坎达的边境的freedom，而在于是否应该向外输出自己的科技，武装世界其他角落受压迫的黑人对）。而且，“不自由，毋宁死.”这一句本是美国独立战争时期，Patrick Henry在弗吉尼亚议会演讲的最后一句“Give me liberty or give me death.”的翻译。 忙里偷闲独自看一场电影，还不错。]]></content>
  </entry>
  <entry>
    <title><![CDATA[《亲爱的安德烈》读书笔记]]></title>
    <url>%2Fpost%2Ffd581850.html</url>
    <content type="text"><![CDATA[内容摘录认识一个十八岁的人 P4 “虽然心中有爱，但是爱，冻结在经年累月的沉默里，好像一个疼痛的伤口，没有纱布可绑。” P5 “我们是两代人，中间隔个三十年。我们也是两国人，中间隔个东西文化。我们原来也可能再他十八岁那年，就像水上浮萍一样各自荡开，从此天涯淡泊。 日后的人生旅程，当然还是要漂萍离散——人生哪有恒长的厮守？但是三年的海上旗语，茹月色满怀，我还奢求什么呢。” 第1封信 十八岁那一年 P13 “那‘愚昧无知’的渔村，确实没有给我知识，但是给了我一种能力，悲悯同情的能力。” P14 “你们这一代‘定锚’的价值是什么？终极的关怀是什么？你认为美丽的热带鱼游泳也要在P乎方向吗？或者，你要挑衅地说，这是一个无谓的问题，因为热带鱼只为自己而活？” 第3封信 逃避国家 P21 “觉得德国是个不错得国家这种感觉是没有人敢显露，大家都要藏起来的。” P25 “如果是五十个德国人在街上大喊‘德国第一；’德国万岁‘，会把人给吓死，第二天可以上《纽约时报》了，对吧？” 第5封信 对玫瑰花的反抗 P37 “玩，可以说是天地间学问的根本。” 第6封信 一切都是小小地 P41 “每个人都在走自己的路，每个人都在选择自己的品味， 搞自己的游戏，设定自己的对和错的标准，一切都是小小的、个人的，因为，我们的时代已经不在有’伟大‘的任何特征。” 第7封信 有没有时间革命？ P48 “这世上/没有真实世界这回事/只有谎言/迫使你设法穿越” 第8封信 我是个百分之百的混蛋 P56 “世界上那么多不公正的存在，怎么可能没有‘反叛’的需要？所差的只不过在于你是否愿意看见，是否愿意站起来，行动不行动而已” P56 “至少，我清楚看见自己的生存状态，而且至少，我并不以我的生存状态为荣。” 第9封信 两种道德 P63 “这些国家里的人民，准许，或说要求，他们的政府把大量的钱，花在离他们很遥远但是贫病交迫的人们身上。” 第11封信 阳光照进你的路 P79 “对美的迷恋可以打败任何智者自以为是的心得报告。我只能让你跌倒，看着你跌倒，只能希望你会在跌倒的地方爬起来，希望阳光照过来，照亮你藏着忧伤的心，照亮你眼前看不见尽头的路。” 第13封信 向左走，向右走 P93 “然而母亲想念成长的孩子，总是单向的；充满青春活力的孩子奔向他人生的愿景，眼睛热切望着前方，母亲只能在后头张望他越来越小的背影，揣摩，那地平线有多远，有多长，怎么一下子，就看不见了。” 第14封信 秘密的、私己的美学 P101 “流行文化经过时间的筛子，泥沙被淘汰，金块被留下，留下的就叫做经典或古典……” （文化，大浪淘沙） 第16封信 藏在心中的小镇 P112 “所以我坐在这阳台上，细细回想我们共有的美好时光，把回忆拥在心里，是得往前走，但是直到我从哪里来。” 第17封信 你是哪国人？ P116 “‘逃民’被时代的一把剑切断了她和土地、和传统、和宗族友群的连结韧带，她漂浮，她悬在半空中，因为，她也许对这个世界看得特别透彻，因为她不在友群里，视线不被挡住，但是她处在一种灵魂的孤独中。” P116 “她不要你和她一样，做一个灵魂的漂泊者——那也许是文学的美好境界，却是生活的苦楚。” P118 “可是不管国家这种单位发生了什么根本的变化，有了或没了，兴盛了或灭亡了，变大了或变小了，安德烈，小镇不会变。泥土和记忆不会变。 我很欢喜你心中有一个小镇，在你驶向大海远走高飞之前。” 第20封信 在一个没有咖啡馆的城市里 P134 “酒吧跟咖啡馆，在欧洲，其实就是社区文化。朋友跟街坊邻居习惯去那里聊天，跟老板及侍者也像老友。香港却显得很‘浅’——不知道这个词用得对不对。这里没有咖啡馆，只有蹩脚的连锁店星巴克和太平洋咖啡，要不然就是贵的要死其实根本不值得的大饭店。” P135 “人跟人之间愿意花时间交流，坐下来为了喝咖啡而喝咖啡，为了聊天而聊天，在欧洲是生活很大的一部分，是很重要得一种生活艺术。香港没有这样的生活艺术。” 第21封信 文化，因为逗留香港印象 P144 “那天很热，我背着很重的书，一条街一条街寻找，以为和台北一样，转个弯一定可以看到。可是没有。真的没有。去茶餐厅吧，可是那是一个油腻腻、甜滋滋得地方，匆忙拥挤而喧嚣，有人硬是站在你旁边瞅着你的位子。去星巴克或太平洋吧，可是你带着对跨国企业垄断得不满，疑惧他们对本土产业的消灭。不情愿在那里消费。” P145 “我们在谈的这个所谓‘咖啡馆’，当然不只是一个卖咖啡得的地方，它是一个‘个人’开的小馆，意思是，老板不是一个你看不见摸不着的抽象财团，因此小馆里处处洋溢着小店主人的气质和个性；它是社区的公共‘客厅’，是一个荒凉的大城市里最温暖的小据点。来喝咖啡的人彼此面熟，老板的绰号人人知道。如果因缘际会，来这里的人多半是创作者——作家、导演、学者、反对运动家……那么咖啡馆就是这个城市的文化舞台。” P146 “这个城市，连群众示威的大广场都没有。群众示威，和咖啡馆酒吧里的彻夜闲聊一样，是培养社区共识的行为，对加深文化认同多么关键。示威游行，绝对是极其重要的一种‘逗留文化’。但是，香港是个没有闲人，‘请勿逗留’的城市。” 第22封信 谁说香港没文化？ P156 （读者来信）“在你们的文章中，一再提到咖啡馆，并说明欧洲的咖啡馆出过多少名人。我想来想去，的确想不出，中国历史上这么多著名的文人学者，有谁是在咖啡馆完成大作的。但，他们就因为没有在咖啡馆沉思过，就不能获得你们的认同吗？今天和今后，东方的咖啡馆还是无法和西方咖啡馆相比，但东方的文化今天的成就与未来，就肯定将因此而逊色和不被看好吗？”（个人感触：龙应台先生和安德烈先生来往信件中提到的咖啡馆，代表这一类能给人以文化气息，静下来逗留的场所。既然台北和香港都属于东方地域中受西方文化影响最为深远的城市，作为西方许多文化甚至文明诞生发展的一大影响因素，分布在各个城市角落里的这些充满个人气息的“咖啡厅”，理应也被吸纳进两个城市的发展洪流中。然而事实是，并没有。不知道是怎样的一种过滤方式，这些文明根源的事物就这么被无情的抛掉了，不禁令人遗憾和惋惜。诸子百家以及之后几百年内的各个中国古代先贤，自然不是在咖啡厅里完成自己的大作的，可以是旷野的星空下，可以是周游马车上，但无疑，他们需要这样一个与他人，或者与自我，静下来，慢慢交流咀嚼的契机。西方的工业革命把生产力水平不知翻了多少倍，人们的生活节奏也自然被迫推着加速着，加速着。但是就是这么神奇，历史的车轮再快，也巧妙地避开了城市地一个个咖啡厅，保留了这一份每个人奢求地文化角落，这种保留是奢侈的，也是必要的。） 第26封信 孩子，你喝哪瓶奶？ P177 “你从坏的吃起，到明天，那好的也逐渐变坏了，结果你就一路在追赶那坏的，你永远在吃那不新鲜的苹果。你为什么不能就直接享受那最好的呢？” P179 “请问品味是什么？它不就是细致的分辨、性格的突出，以及独立个体的呈现吗？每一件，都正好是贫穷所吝啬给你的，也是威权政治所剥夺于你的。” P180 “如果太好的环境赋予了你美感和品味，那么它剥夺了你些什么？你的一切，是否其实有另一种的‘贫穷’？” 第28封信 给河马刷牙 P195 “对我最重要的，安德烈，不是你有否成就，而是你是否快乐。而在现代的生活架构里，什么样的工作比较可能给你快了？第一，它给你意义；第二，它给你时间。你的工作是你觉得有意义的，你的工作不绑架你使你成为工作的俘虏，容许你去充分体验生活，你就比较可能是快乐的。至于金钱和名声，哪里是快乐的核心元素呢？假定说，横在你眼前的选择，是到华尔街做银行经理或者到动物园做照顾狮子、河马的管理员，而你是一个喜欢动物研究的人，我就完全不认为银行经理比较有成就，或者狮子、河马的管理员‘平庸’。每天为钱的数字起伏而紧张而斗争，很可能不如每天给大象洗澡，给河马刷牙。” P195 “当你的工作在你心目中有意义，你就有成就感。当你的工作给你时间，不剥夺你的生活，你就有尊严。成就感和尊严，给你快乐。” P195 “我怕你变成画长颈鹿的提摩，不是因为他没钱没名，而是因为他找不到意义。我也要求你读书用功，不是因为我要你跟别人比成就，而是因为，我希望你将来会拥有选择的权利，选择有意义、有时间的工作，而不是被迫谋生。” P195 “如果我们不是在跟别人比名比利，而只是为自己找心灵安适之所在，那么连‘平庸’这个词都不太有意义了。‘平庸’是跟别人比，心灵的安适是跟自己比。我们最终极的负责对象，安德烈，千山万水走到最后，还是‘自己’二字。因此，你当然更没有理由去跟你的上一代比，或者为了符合上一代对你的想象而活。” 第29封信 第二颗眼泪 Kitsch让两颗眼泪快速出场。第一颗眼泪说：孩子在草地上跑，太感动了！第二颗眼泪说，孩子在草地上跑，被感动的感觉实在太棒了。跟全人类一起被感动，尤其棒！使Kitsch成为Kitsch的，使那第二颗眼泪。——《生命中不能承受之轻》 “还好昆德拉说，那第一颗眼泪不是，第二颗才是Kitsch。” 第31封信 两只老虎跑得慢、跑得快 “‘你以后一定不能忍受城乡差距、贫富不均所带来的不公平。’也就是说，‘失败启蒙’给我的教训，不是打入‘成功者’的行列，而是，你要去挑战，去质疑‘成功者’的定义。” 第33封信 人生诘问 “安德烈：我想知道，你怎么面对人家总是期待你有思想、有智慧这个现实？ 安德烈，一半的人在赞美我的同时，总有另外一半的人在批判我。我有充分机会学习如何‘宠辱不惊’。至于人们的‘期待’，那是一种你自己必须学会去‘抵御’的东西，因为那个东西是最容易把你绑死的圈套。不知道就不要说话，傻就不假装聪明。你现在明白为何我推掉几乎所有的演讲、座谈、上电视的邀请吧？我本来就没那么多知识和智能可以天天去讲。” 第35封信 独立宣言 不繁文缛节，却也不失礼貌，给人以必要的人格尊重，这就是你要做的。 在时光里 “‘马克·吐温说，’安德烈伸手拿起一粒绿色的橄榄，放在嘴里，似乎在品尝，然后慢条斯理地说，‘我评判一个人的品格，不看他如何对待比他地位高地人，我看他如何对待比他地位低地人。’”]]></content>
      <categories>
        <category>阅读</category>
      </categories>
      <tags>
        <tag>阅读</tag>
        <tag>书信</tag>
        <tag>龙应台</tag>
        <tag>安德烈</tag>
        <tag>亲爱的安德烈</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[《岛上书店》读书笔记]]></title>
    <url>%2Fpost%2F11246bdd.html</url>
    <content type="text"><![CDATA[书中书目 P97《白鲸》 赫尔曼·麦尔维尔 P99《古拉格群岛》 索尔仁尼琴 P99《纳尼亚传奇》系列 C.S.刘易斯 P107 《洛城机密》詹姆斯·埃尔罗伊 犯罪小说 P119 《真爱如血》电视剧 P132 《好人难寻》弗兰纳里·奥康纳 P135 《卡拉维拉显驰名的跳蛙》 马克吐温 P135 《所罗门之歌》 托妮·莫里森 P135 《奥丽芙·基特里奇》 伊丽莎白·斯特鲁特 P183 《与父亲的对话》 格蕾斯·佩利 P197 《逮香蕉鱼的最佳日子》 J.D.塞林格（A.J.谈到对玛雅作品的建议，移情，为什么人们会做他们想做的事？ P209 《泄密的心》 埃德加·爱伦·坡 P213 《我们的小镇》 桑顿·怀尔德 P216 《德伯家的苔丝》《约翰尼上战场》《永别了，武器》《为欧文·米尼起到》《呼啸山庄》《织工马南》《他们眼望上苍》《我们的秘密城堡》 P223 《铁头》 艾梅·本德 P235 《追忆似水年华》 马塞尔·普鲁斯特 P246 《尘雾家园》 安德烈·迪比三世 P249 《当我们谈论爱情时我们再谈论什么》 雷蒙德·卡佛 P257 《书店老板》 罗尔德·达尔 P269 《美国众神》尼尔·盖曼 因为从心底害怕自己不值得被爱，我们独来独往，然而就是因为独来独往，才让我们以为自己不值得被爱。有一天，你不知道是什么时候，你会驱车上路。有一天，你不知道是什么时候，你会遇到他（她）。你会被爱，因为你今生第一次真正不再孤单。你会选择不在孤单下去。 内容摘录 P210 “一个地方如果没有一家书店，就算不上个地方了。” （AJ和妮可） P266 “没有书店的地方算不上是个地方。”（兰比亚斯和伊斯梅） P261 他会再试试，他永远不会放弃尝试。“玛雅，我们会成为我们所爱的那样。是爱成就了我们。” 玛雅在摇头。“爸爸，对不起，我听不明白。” “我们不是我们所收集的、得到的、所读的东西，只要我们还或者，我们就是爱，我们所爱的事物，我们所爱的人。所有这些，我认为真的会存活下去。” 她还在摇头。“我听不懂你的话，爸爸。我希望我能。你想让我找艾米吗？要么也许你可以打出来？” 他在冒汗。交谈不再是有趣的，以前曾经很容易。好吧，他想。如果必须用一个单词，那就必须用一个单词吧。 ”爱？”他问。他祈祷自己说得对。 她皱起眉头，努力去辨读他的表情。“手套？”她问，“是你的手冷吗，爸爸？” 她点点头。她把她的手放在她手里。他的手本来冷，这时暖和了，他想好了今天说的够接近了。也许明天，他就能知道该怎么说了。]]></content>
      <categories>
        <category>阅读</category>
      </categories>
      <tags>
        <tag>阅读</tag>
        <tag>文学，小说</tag>
        <tag>岛上书店</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[《1988：我想和这个世界谈谈》读书笔记]]></title>
    <url>%2Fpost%2Ffdc06f3f.html</url>
    <content type="text"><![CDATA[内容摘录 P45 “我说，丁丁哥哥，你去做什么啊？ 丁丁哥哥说，我去和他们谈谈。 我说，你和谁谈谈啊？ 丁丁哥哥唇边露出微笑，急切地说，这个世界。” P62 “这样的旅行在我年少时曾经幻想过无数次，夜晚的国道李，我等待着自己梦寐以求的女子，开着自己梦寐以求的车，去往未知旅程的终点。未知旅程怎么会有终点，旅途上没有疲劳和困意，我们聊着电影和音乐，穿越群山和丛林，最终停在一泓无人的湖水旁边，有一个没有任何经济头脑的人开的酒店，干净便宜。” P86 “混乱的地面道路是最好的地方。1988就像我周围的人，国道就像这个杂乱的世界，在越无序的地方，我越能寻觅到安全感。这安全感的代价就是你要时刻集中精神，否则你就会被庞大的交通工具碾过。” P87 “生活它不是深渊，它是你走过的平原和你想登上的高山，它就像我们睡过的每一张床，你从来不会陷下去，也许它不属于我们，但它一定属于你，你觉得它在往下，是因为引力，它绝不会把你拖下深渊，它指向让你伏在地上，听听它的声音，当你休息好了，听够了，你随时可以站起来，你懂吗？” P97 “小学的离别，那是最不能知道你身边的人未来将变成一个什么样的人的时刻。” 这句话是后面很多故事开展的一个引子。 P98 “在一个陌生的环境里，我可以重新塑造一遍我自己，没有什么事不会改变的，我上一个角色已经演完了，这是我接的新戏。” P124 “我说：‘……但难道就没有人正儿八经的做新闻么？’ 朋友说，都有，每一拨李都有那么几个。 我说，那那些在哪里？ 朋友说，辞退了。” P124 “我坚信邪恶不能压倒正义……嗯。但是他们可以定义正义和邪恶。” P126 “你相信么，在这样一个世界里，你用脑子想过的事情，你总是以为你已经做过了，” P127 “其实温水煮青蛙是一个错误的俗语，温水煮不了青蛙的……不要拿青蛙给现实改变自己找借口，温水是煮不了青蛙的，青蛙没有那么蠢，这就是现实。”不是显示改变了自己，你很强，你没有跳出来，只是你自己不想，事你自己屈服，自己变了。 P141 “我早就想通了，人们埋怨一成不变，但也埋怨居无定所，人其实都无所谓，只要是给日子找点岔子而已，似乎只有违背现在的生活，才真正懂得了生活，生活就是一个婊子、一个戏子。一个你能想到的一切，你所有的比喻就在里面扔吧，你总是对的。因为生活太强大了，最强者总是懒得跟你反驳，甚至任你修饰，然后悄悄地把锅盖盖住。” P163 “当我的生命力只能讲一个故事的时候，我愿将这个故事说出来，这个故事平淡无奇，平铺直叙，既没有曲折，也没有高潮，也就是寻找，相识，分开，就如同走在路上看见一盏红绿灯一样稀松平常，但若驻足，你会发现，它永远闪着黄灯。我就一直看着这盏信号灯，在灯下等了很久，始终不知道黄灯结束以后将要亮起的是红色还是绿色，一直等成了一个红绿色盲。” P164 “我不知道是否有一种很奇怪的感情，它深到你想去结束它，或者冰封它。只因为它出现在错误的时间里，于是你要去等待一个正确时间重启它，而不是让错误的时间去消耗它。少则一天，多则一生。” P177 “移动着的人永远比固定着的人更]]></content>
      <categories>
        <category>阅读</category>
      </categories>
      <tags>
        <tag>阅读</tag>
        <tag>小说</tag>
        <tag>韩寒</tag>
        <tag>1988：我想和这个世界谈谈</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[《水滴直播，让你我的隐私再也不滴水不漏》]]></title>
    <url>%2Fpost%2F75794199.html</url>
    <content type="text"><![CDATA[无意间从朋友圈里看到了一条说说，主体内容是一段搬运自微博：“嘻哈公社”的自媒体采访视频，很短，但简单，却很现实。不知道是不是因为上了大学，看新闻的时间少了，还是真的社会已经适应了这种“直播”的存在，而我成了另类？ 抛开直播圈的其他乱象不说（你们都懂，某平台的某些知名主播的蛇皮操作，各种公关闹剧简直是一出年末大戏），我一直以为直播和生活的界限还是分的很开的。直播归直播，那是镜头上的人物，是在表演，可以有感情的虚假，可以有套路，可以有剧本，起码和“生活”总隔着一个界限。这个界限，你说不出是个怎样的存在，但都能感觉到它在这里，真实的在这里。 我也依稀记得斗鱼之前有过一个户外板块（不知道现在是否还存在），专门供主播分享户外生活的点点滴滴，直播里自然会出现其他“路人”，不过“路人”们都清楚的明白，有一个手持的直播设备在对着自己，无论愿意还是不愿意，至少，他们都是知情者，清楚自己已经穿过那条“界限”，站在这个直播平台提供的“舞台”上，成为了万千观众眼中的表演者。 然而，我从未想到过，我会被剥夺这份知情权，被永远剥夺。 某天，你打开某上市公司的直播平台 你会惊奇的发现 镜头上表情呆滞的自己， 柜台前输入密码的自己， 和密友讨论私事的自己， 表演出丑后尴尬的自己， 买东西犹豫不决的自己， 和那个他/她亲热的自己， 失恋后酒吧买醉的自己， 而且，不仅有你自己，还有无数磕着瓜子吃着西瓜，以单身不知多少年的手速敲击键盘，享受着这种360度全方位无死角的窥屏狂魔们。你生活的一切横截面，无论你想或不向，都会成为这些人的娱乐自我的资源。 我从不认为有错的技术，只有错的人与错误的利用方式。 谢谢水滴直播，谢谢周总，让我明白《楚门的世界》有机会成为现实。 谢谢水滴直播，谢谢周总，让我知道天网监控对个人隐私的侵害是多么的彻底。 谢谢水滴直播，谢谢周总，让我知道删掉360不仅是对电脑的保护，更是对自我的保护。 谢谢水滴直播，谢谢周总，让我知道身边的一切private things是多么的宝贵。]]></content>
      <categories>
        <category>随笔</category>
      </categories>
      <tags>
        <tag>随笔</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[读《还好我不是新加坡人》有感 转自新浪微博]]></title>
    <url>%2Fpost%2F662b8b80.html</url>
    <content type="text"><![CDATA[转自新浪微博 原文地址 作者龙应台是台湾著名社会批评家，八十年代她在宝岛“放火”，一时间名声大噪，那本《野火集》让她从此广为人知。而上世纪九十年代，她又在新加坡“放火”,写下了这么一篇极具争议性的文章。 龙应台一向以文笔犀利老辣，说话微言大义而出名，这篇文章显然也有这一特点。细细读来，这篇杂文和她的大多数作品一样，都是着一时事或是小事出发，从而牵引出一个相当大的命题。在本文中她先是提出对新加坡外长在国际会议上以亚洲人代表自居，将狮城文化等同于亚洲文化的不满，在此基础上，她开始批判新加坡的某些法律条文和政府政策。其中最一针见血的要属那句：“给我再高的经济成长，再好的治安，再效率十足的政府，对不起，我也不愿意放弃我那一点个人自由与尊严。” 意料之中的，这篇短文遭到一片骂名。龙应台觉得委屈，另外发文称自己将主要火力放在了外长未经其它亚洲人考据和同意就把自己、乃至把新加坡当作亚洲代表这一点上，她不满外长以亚洲之名发出新加坡人的声音。然而，令那些愤怒的新加坡人真正不满的却是她在文章最后对于狮城的举例讽刺与挖苦。 在我想来，在这场唇舌交战中无论作者还是读者都有点小题大做的嫌疑。众所皆知，一篇好的批判性文章必须夺人眼球，因此，这篇文章的标题和结尾必须令人眼前一亮。龙应台不满自己的亚洲人身份“被代表”，这体现了她尊重人权、支持自由的一面，当然这与她的身份和多年留洋经历是分不开的。而想想新加坡文化与西亚文化、印度文化的巨大差别，让它来代表亚洲人说话的确有点名不正而言不顺。但实际上，我们也必须承认，在特定场合里，让新加坡代表亚洲人说法也未尝不可，本来这就是个多民族的国家，它的文化融合了中华文化、马来回教文化、印度文化，作为亚洲文化的大熔炉，在非正式场合把自己当代表那还是有点说服力的，我们不也常常理直气壮地说“我们亚洲如何如何”吗？但鉴于那是在国际官方会议上的讲话，加之明明知道事后会被西方媒体大肆渲染一番，这为代表实在不合适。 再看那最令狮城人民不满的部分，即龙应台对狮城政策的批判，说真的这部分占全文的比例并不大，又何以一石惊起千层浪呢并且几无附和龙文之音呢?对此龙应台的解释是：一是新加坡人确实比较满意于现状，乐于接受由权威政府领导的生活方式；或者，在权威的笼罩之中，不同基调的声音根本还不敢冒出来。”我觉得这两个原因都有可能。的确，新加坡这个蕞尔小国近几年的发展倍受瞩目，亚洲四小龙之一的实力实在不容小觑。有很多人都在羡慕“花园城市”的廉政与洁净。短短几十年就有了如此大的进步和成就，狮城人民很有可能是对政府十分满意甚至是充满感恩的。当然，这并不代表这个国家就没有问题，但是很明显这种政体、甚至是这份普遍的感激都极有可能成为“敢怒而不敢言者”沉默的原因。所以说，第二个假设也可以成立。 这么说来，是龙应台恶意赚取噱头，鸡蛋里挑骨头了？当然不是。我们必须承认她的出发点是善意的，甚至可以说是极具理想化的，事实上无论在哪一个国家，知识分子愿意为社会的鸡毛蒜皮小事而生气、而发出批判之声，这是一件很幸运的事情，何况和她当年批判台湾相比，这篇文章已经很客气。正因我们身处于这样不够完美的社会与时代，我们才应该对小事看不顺眼、对琐事斤斤计较—只要我们都是为了让这个社会变得更好。批评，让学者们慎思、明辨。也正因如此，当今不少学者都认为，将眼下大热的龙应台和周国平放在一起，两者固然没什么可比性，但是对青年人而言，读多一点龙应台也许会对这个国家更有益。如果硬要就新加坡到底好不好来说，或许只能是：子非鱼安知鱼之乐。 读罢这篇杂文，我想这其中还有很多东西值得我们深思：同是一个多民族国家，新加坡何以拥有这么强的核心凝聚力？再者，如果连这般清廉、法制完善的新加坡都被人这样批评，我们正在崛起的中国又该何去何从？换句话说，如果现在让龙应台来批判中国大陆，她又会有多少文章可作？ 一番深思熟虑后，我想我最欣赏的还要属新加坡《联合早报》，它居然胆敢在本国报纸上刊登这么一篇必将刺痛人民神经的文章。我也钦佩龙应台，她居然胆敢在自己的文集里放进这么多批评自己的文字。看似是拿自己的手打了自己的脸，但为何此时此刻，我有种回到百家争鸣时代的错觉呢?]]></content>
      <categories>
        <category>随笔</category>
      </categories>
      <tags>
        <tag>龙应台</tag>
        <tag>随笔</tag>
        <tag>读后感</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[《野火集》读书笔记]]></title>
    <url>%2Fpost%2Fa4efe87.html</url>
    <content type="text"><![CDATA[内容摘录 P10 “说穿了，龙应台所传承、传递的野火，其实就是一种乌托邦的想象。教导我们在现代的荒原上培养价值的火种，批判的火种，或点灯或放火，在众多的小天地和大天地，边缘和中间之间，找到一种新的文化串联的策略……”《野火集》中野火的多层含义，一方面是指如同普罗米修斯为人类带来神火，龙应台给台湾带来思想与意识观念的”野火“，她这个”盗火的玉娇龙“，背负着维护古典价值的使命，在哪个时代挂起漫野的星星之火。 P11 “如福柯所说，我们一再发现自己处于开始的位置；因为这样，我们更应该一起思索未来，以新的火焰挑战者、文化挑战者为己任，化被动为主动，大力叩问个体生命的意义，将我们共同的困境，化成一场戏剧性的自我追寻，扩张梦想的蓝图和坐标，脚踢东西文明，甚至期待有一天，将龙应台的野火放回西方去。” P24 “……倒觉得八零年代就是太近的昨天，时间很长，路却走得不十分远。” P28 “八零年代，我从台北走到北京，在从莫斯科走到东伯里的大街上，秋色萧萧，已是年代末了。我看见作家在对群众演说，群众在对天空呐喊，天空，默然下起了冷雨，雨水冲洗着人们脸上悲愤激情的泪水。 那是一个最坏也最好的时代，最黑暗也最光明的时代。因为黑暗，所以人们充满了追求光明的力气和反抗黑暗的激情，而且黑白分明，奋斗的目标多么明确。力气、激情、目标明确——八零年代是理想主义风起云涌的时代。只有在得到”光明“之后，在”光明“中面对个人自我的黑暗，发现那黑暗更深不可测，我们才进入了疑惑不安的九零年代，世纪之末。” P31 “个人要从民意的强大束缚中解放出来，要向民意的平庸统治争取不同流俗的权利。极权瓦解之后，压迫着个人的是无数个个人所结成的集体，’民意’.” P31 “梁启超在七十年前说过的话，更令我惊诧其早熟：‘……岂独裁军阀财阀的专横可憎可恨，就是工团的同盟抵抗乃至社会革命还不是同一种强权作用！只不过从前强权，在那一班少数人手里，往后的强权，移在这一班多数人手里罢了。’” P33 “个人，当他是反对者的时候，她不被捕杀就是圣洁的英雄。当他不再是反对者，严酷的测验就来了：他是否能抵挡权力腐化，他是否能承担责任，他是否能容忍异己。许多事实表明：那打破了专制的英雄们竟是无数个专制的个人。个人，才是黑暗的真正来源。” P62 “我爱惜我的学生；像努力迎取阳光的黄色向日葵，他们聪慧、纯洁、奋发，对老师尤其一片真情。但是，他们也是典型的中国学生：缺乏独立自主的个性，盲目服从权威，更严重的，他们没有——完全没有——独立思考的能力。 错在学生吗？ 当然不是。学生是一抔混沌的黏土，在教育者的手中揉搓成形。从小学到大专联考这个漫长过程中的种种问题，暂且不谈，让我们看看这些‘不敢’、‘泪眼汪汪’、‘没有意见’的大学生正在接受什么样的高等教育…….我一直以为大学校长是高瞻远瞩，指导学术与教育大方向的决策人，而不是管馒头稀饭的保姆，但这也暂且不提。这一类型的教育者的用心，毋庸置疑，当然是善意的，问题是，我们论‘事’的时候，用心如何根本不重要，重要的是实际的后果，而教育的后果和其严重！这种喂哺式、育婴式的大学教育刚好吻合心理学家Levy早在一九四三年给所谓‘过度保护’（Overprotection）所作的诠释：第一，给予过多的接触——‘有任何问题，随时来找我’；第二，禁止他独立自主——‘你不许……’；第三，将他‘婴儿化’——‘乖，早睡早起。’；第四，把自己的价值取向加诸其身——‘你听我的……’在这种过度呵护的幼稚教育下成长的大学生，遇事时，除了‘泪眼汪汪’之外又能做什么呢？” 1984，奥威尔的台湾 P117 “要出书时，书稿要送印刷厂了，出版人和我面对面发愁，这一篇，收不收进书里？收进去，可能使整个书被查禁销毁，前功尽弃；不收进去，唉，龙应台实在，实在不甘心！ 夜很深了，我抬起头，说：‘收。’” P120 “那么我们要不要言论自由？这个问题本身大概就是一个忌讳——我们对外号称‘自由’，当然本来就有言论自由，而且是宪法保障的，问‘要不要’简直是自打耳光。可是自打耳光总比等着让别人来打要好得多。” P121 “一方面鼓励学生去努力追求真理，真相。一方面有用各种手段防止学生得到某种知识——学生难道是智能不足。我们希冀他不会发现这两种态度间的严重冲突？这种掩藏式的做法不仅暴露出执政者及教育者的虚伪。而且更可笑的，他根本行不通！思考是追求真理的工具，学生一旦获得这个工具，我们就不可能对他说：你去治学问，但不要碰政治。譬如说一个有能力深思经济问题，文学问题的人，他一定也有能力分析政治问题。反过来说，如果我们执意不让学生在政治问题上刨根问底，唯一的办法就是根本不教他追求真理的原则与方法，不给他‘思考’那个刨根问底的工具——但是这样一来，我们还谈什么教育？” 麦尔教授的老鼠实验——“以不变应万变”的古板愚蠢，甚至还在一代代的加重，“遗传”给后人。 P126 “一个国家，又何尝不是个精神可能崩溃的老鼠？！……如何能不受制于旧习惯、旧观念、就方法，如何不搞‘拧’了去老撞一闪没有乳酪的门而撞得鼻青脸肿，需要的是弹性与智慧。 智慧布政使人之所以为人，鼠之所以为鼠的差别吗？” P131 “在台湾革新很难，一方面固然是由于许多制度的僵化……另外还有保守的执政单位对社会自觉运动的移惧。一个更大的障碍，确实民众本身的缺乏动力。” P142 “‘野火’只有一个简单的要求：撕掉蒙眼布。对‘野火’狂热的反响或许也就传达了那么一个简单但迫切、坚决的讯息：我们不要蒙眼布！让子女，学生，人民都用自己的眼睛去看。自己的头脑去想。” P166 “脱法行为频繁，公权力低落，有一个更根本的原因：执法者与执政者同体……执法者虽然有心执法，但是因为与执政者通体，执法起来就难免背上‘迫害’的大帽子。为了避嫌，只好让法律放个假。” 我的台湾意识 P169 “战前的日本，跟目前的中国台湾一样，所有的教科书都由政府统一编制……把教育作为一种政治手段，就是家永一类的学者所惧怕的，他们害怕历史的大悲剧重演。战后的日本和多数欧美国家一样，教科书由民间自行编制，政府只能审核品质，但是不能操纵它的内容。这种做法的目的，当然在避免一个政府有计划、有系统地制造易于统治的顺民。” 寒食节 P205 “唐朝时，中国的文化到达空前的高峰，是当时世界上最强盛的国家。我们对唐文化的了解有限，尤其是唐朝的节日。 唐人很重视的节日是寒食，设定在冬至后的一百零五日，大约在清明节前的一日。这天全长安城的炉灶内都不能有火，人们吃冷粥及冷饼，等到第二天一早，由大明宫内传出薪火，到家家户户的灶内。 这是一个充满了象征意义的节日，而且非常严厉地执行，寒食日仍起火者，要处以死刑的。”]]></content>
      <categories>
        <category>阅读</category>
      </categories>
      <tags>
        <tag>阅读</tag>
        <tag>龙应台</tag>
        <tag>杂文集</tag>
        <tag>野火集</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[《天幕红尘》读后感]]></title>
    <url>%2Fpost%2F772fc02c.html</url>
    <content type="text"><![CDATA[转自豆瓣 原文地址 数年前，看电视剧《天道》的时候，面对剧尾的那一场诉讼，我佩服得五体投地，于是，给某人出了一道题：如果一个农村家庭作坊被人谴责为滥用童工，怎么辩护？彼时，还算是民商法才子的某人给了一个答案。但是，我依然觉得是电视剧中的辩护词更赞。 电视剧中，中年的农民大叔说，农村的孩子，谁不是从小就帮着家里干活的呢？难道这也是用童工？其实，当时我转述问题的时候也有所遗漏。但是，不管怎么样，《天道》惊艳了我，豆豆也惊艳了我。只是，豆豆创作的小说数量并不多。而我，又属于那种心理洁癖者，很少在看完电视剧以后再看原著小说或者在看完原著小说后又去看电视剧的。所以，我并没有读过《天道》的原著小说《遥远的救世主》，我读了《背叛》。豆豆的小说有着明显的style，就像是大树的年轮，早已融于自身，无法消除。 豆豆的男主，都是有着绝顶的智慧的，就像是罗贯中笔下羽扇纶巾的诸葛亮，对方的一举一动、事态的发展，皆在自己的预料之中。无论是宋一坤，还是丁元英，抑或是叶子农，都是那种其貌不扬，扔在人堆里就找不到的主儿，但是，却具有翻手为云覆手为雨的能力。而他们的这种操纵乾坤的智慧和能力，在小说里，则体现为游走于法律的边缘。这句话，用通俗的说法叫做“打法律的擦边球”。无论是丁元英设计的“劫富济贫”，还是叶子农策划的“劳务输出”，较了真，其实都是违法行为。 但是，叶子农则认为自己的这种行为并非钻法律的空子，因为他的所思所想所作所为，均在法律认可的范围以内，既然法律没有明确禁止，那就是合法的。呵，这个人，倒是懂得将私法上的“法无禁止即自由”的思想应用于实践。“情深不寿，慧极必伤。”善于谋划，并且算无遗策的人，是一种“只可远观”的神话；从某种程度上来讲，他们的存在对于他人来说也是一种“危害”。这样的人，要么屹立于社会之巅，操纵着芸芸众生；要么，注定无法容于世。所以，天神一般的神机妙算的诸葛亮只是罗贯中在正统思想下塑造出来的“演义”。 所以，宋一坤用鲜血来洗刷自己的罪孽；所以，丁元英孤独终老；所以，叶子农倒在了异国他乡。 作品中，人物身上的种种智慧，事实上，都是作者自身智慧的投影。]]></content>
      <categories>
        <category>阅读</category>
      </categories>
      <tags>
        <tag>阅读</tag>
        <tag>小说</tag>
        <tag>豆豆</tag>
        <tag>天幕红尘</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[2018-02-03武汉游记]]></title>
    <url>%2Fpost%2F4f8fe65a.html</url>
    <content type="text"><![CDATA[第一天 2.3号。原本打算集训完直接回家的，临走前两天打开携程，下一站并不是石家庄，而是武汉。脑子里突然想起了那个“一时冲动”。哈，虽然不像自己的风格，但是既然买了票，那就一去吧 2.2集训完，晚上收拾寝室+整理行李就鼓捣到了2点多，拜托馨馨没睡的话6点钟把我叫起来，不过好在重要的事情自己心里也都有个谱，虽然睡眠时间不多，第二天一早还是自然醒了。把计划好的事情一件件做完，还了宁哥的电车钥匙，把没吃完的枇杷送给宿管阿姨，拎着强行塞下的行李箱和电脑包，地铁来到了长沙南站，本想着高铁一路还能看看南方这边郊外的风景，不过也许是前一天晚上收拾得有些晚了，上了高铁倒头就睡，一觉醒来已经是“列车即将到达武汉站“。精神迷糊得导致我下车时候应该把我仅带得一本小说《月亮与六便士》落在了座位上，可能是真的不打算让我读完它了哈哈哈（这可是我仅带的一本小说啊）。下了高铁在武汉站里吃了热干面，听了一个好心大姐的建议，在吃饭的地方换了些零钱然后买了一张城市交通一卡通（后来事实证明它发挥了无比巨大的作用）。午饭过后，乘地铁到了户部巷附近，入住如家，由于是内宾，光线不是很好，得，困意再次袭来，我一个午睡足足睡到了7点钟。还因此错过了我妈的电话，搞得她老人家着急了一番（生怕我这个一米八几的人在武汉被拐了）。 好好的休息了一番后，我便开始了晚上的自由行程，先是户部巷吃了些小吃（热干面，鸭架，哦对那个糊米酒不错，少数我能吃得惯的酒酿产品。。），有意思的是，户部巷里排队最长的竟然是长沙的臭豆腐和大香肠，哇，我这半个长沙人心里也莫名有了几分自豪。顺着巷子走，尽头是一个不起眼的藏酸奶，再一拐面前就是沿江大道了，时间已经过了八点，人并不是很多，江风阵阵，江堤边有不同用处的码头，还有供行人夜赏江景的平台。自小在北方长大的我一直很向往这种有水伴城的感觉，与家乡的人工水系最大的不同，这里是”水养人“，而非”人养水“，面朝江河，或是风平浪静、波澜不惊，亦或是怒浪卷云、波涛汹涌，自然的表现从不因你的喜恶而改变，或者更严谨的说，其内蕴之博大更难凭你一人的感情去左右。如此，无论自己有什么烦恼，跑到江边，去听，去感受，你总会静下来，与人不一样，它无需承诺，无论你在或不在，它总在那里，不怨，不悔，不念，不恼，它的存在，对我自己而言，已是一种终不可达的傲然姿态，对它的这种敬佩，是心底里的。 步行了一段时间，我搭上了来往过武汉长江大桥的公交，回来的时候应该恰好是末班吧。下了车能望到夜里灯光装饰的黄鹤楼，照旧，不喜自拍，但不想错过景致，拍了几张照，走回了旅店，这一小段路也顺便摸清了明早跑步的路线，晚上和三五好友聊了些天，睡觉时候好像也不早了（似乎自己上了大学后一直没有早睡过）。 第二天 2.4号。前一天睡得不早，不过今天早晨还是兴致勃勃的7点钟起来了，既然拿了跑步的衣服，又有如此兴致（PS重点是我竟然起来了），当然要粗发啦，还能留个纪念。 半个小时4.5km跑了武汉长江大桥一个来回，新成就get哈哈，回来的时候看到了纪念碑，上面有毛主席所写的”一桥飞架南北，天堑变通途“。当然，希望自己今后和村上春树先生一样，能坚定的做自己爱干的事业，同时还能坚定的做一个跑者。上午抓紧时间把武昌有文化存留的这一个区域都逛了一遍，黄鹤楼景区无论是火爆的还是冷门的景点都看了一遍，不曾想除了语文书中所提到的崔颢创作《黄鹤楼》，以及李白搁笔的故事，这座”天下江山第一楼“还与诸多历史名人有着千丝万缕的联系。过费祎亭，知晓了传说费祎死后登仙，每乘黄鹤于此憩驾。学了些历史知识，南朝刘宋就三国孙权所建夏口城扩建而成郢州城，地理位置就位于武汉市武昌蛇山，也就是黄鹤楼所在的这一片区域，而此处在宋朝时就是岳飞抗金作战的前线，而岳飞在郢州驻军时间最久，黄鹤楼景区内也有岳飞这一历史名将的雕塑，供后人瞻仰。哦对还有一点，黄鹤楼多次被毁重修，如今的黄鹤楼实际上是建国后重新修建的，清光绪十年（1884年）大火，留下来的只有黄鹤楼东侧的古铜顶。 游完黄鹤楼景区，旁边的首义公园是旧武汉省图书馆所在，但是现在已是危房，修缮中并没有对外开放。我便乘公交，过武昌路隧道，向北，到了沿江边的红色景点区，包括毛泽东旧居，中共五大会议旧址，革命时代的记忆，因为没有相似的经历，所以看革命先辈抛头颅，洒热血，更多的是敬佩，为信仰而奋斗，无需其他理由。之后又回户部巷，到老字号蔡林记吃的武汉正宗热干面。嗯对顺便尝了下恩施小土豆。看了看日期，今天是星期日，想起来多数博物馆都是周一闭馆，作为一个博物馆狂人，赶紧下午麻溜的跑到湖北省博物馆，先把最出名的看了再说，剩下的。。总之以后还会到武汉来的嘛。 博物馆的镇馆之宝应该就是曾侯乙编钟和越王勾践剑了，听了app上的讲解（竟然不是免费的，还很难用，差评），这两件文物以及相关历史和考古知识讲解的都比较仔细，剩下的，知识的系统性和文物的丰富性并比不上陕西历史博物馆等。但凡是参观博物馆，多看看，有收获就是好的。出了博物馆，这时旁边的湖北省美术馆已经关门了，好吧虽然有些可惜，不过还算留下了再来武汉游玩的决心。回去的路上经过现在的武汉省图书馆，不得不说比家乡的河北省图书馆要大好多啊。。外部造型和内部构造以及环境氛围都很让人有静下心来读书的赶脚，进馆的每个人也都很自觉地压低了自己的声音，总之氛围很好。 回到如家拿上行李，准备开拔到民宿的小姐姐家，公交到了楚河汉街附近，也是她强烈安利的，em或许不是因为这个，我也不会选择这边的民宿吧，哈。楚河汉街处于武汉中央文化区，地理位置相当于武汉市的几何中心，官方说明为”万达集团投资500亿元人民币，倾力打造的以文化为核心，兼具旅游、商业、商务、居住功能的世界级文化旅游项目“。晚上一个人走了个来回，哈确实不同的人总会找到不同的吸引点，购物达人-&gt;时装品牌，美食博主-&gt;小吃街，文艺青年-&gt;文创书店，都有适合你的那一个。我吃了点小吃然后就在文华书城看了会儿书，重点是，里！面！有!3D-JP！拼图店！突然回忆起了那段和拼图斗智斗勇，哦不，只有斗智的时光。 第三天 2.5号。emm早晨睡了个懒觉，今天是公交车上的一天哈哈。上车坐公交坐错方向了，不过正好公交线路正好是沿着东湖走一圈，干脆一不做二不休，坐到了终点站再坐回来（不愧是时间多），音乐与东湖美景相伴，这一趟值了。经过武汉长江二桥，我来到了汉阳，听了天骄的安利想着去看一下江汉关博物馆，不过么，确实博物馆周一都不开，江汉关也不例外。不过呐，以江汉关博物馆作为东头，恰巧是汉口地区最出名的文化购物一条街（一条街上足足有三四个阿迪达斯的专卖店。。），建筑都是民国风的，当然，这里不同于汉街，有不少是“真民国”，比如上海银行汉口分行旧址（现在在这里是工商银行的地界了），三段式立面，中段采用爱奥尼双柱巨柱式，还有四明银行旧址（现在是OCE的专卖店），以及不知道是不是真民国遗存的中国银行（看得挺像得），闲逛一小圈后，我又搭乘地铁来到了琴台附近，先去东边得汉阳造文化创意产业园游览了一番，这里的工作氛围并不像大型公司那样紧凑忙碌充满商业气息，相反，一股“文新”感觉扑面而来，作为比较小众的景点，步行游览的人也有，但并不多，三三两两，时而有看着像因公来此处的轿车出入，靠近入口的知音书店或许是和我的生活相交最多了吧，在门口张望了一阵子，书店里的灯透过帘子隐约感觉韩式亮的，但是并没有看到里面有人在的迹象，我还是被好奇心驱使着推开门进了这家书店，少往里一拐，一个年纪比我稍长几岁的姐姐还在吧台读着书，确实没有其他客人，不过看到我来还是很热情的走来欢迎。环顾书店，并不大，中间整齐的放置着六张木制桌椅，很复古，再往里还有一个“国学讲坛”，整体风格相较于现代的书咖更传统些，书籍也是很规则的摆放在两边靠墙的书架上。一杯海盐咖啡，一本1Q84陪着我度过了一个下午，在这里工作的姐姐并没有怎么打扰我，难以言说的“温暖孤独”。 傍晚时分来到了西边的古琴台，这里规划成了一个集成剧院和音乐厅的休闲公园，地图上标记为“月湖风景区”，一个北方人，看到水和湖，又是一脸羡慕的表情，景色还是蛮不错的，公园还很贴心的规划了步行推荐路线，我也确实见到几个在附近居住的武汉市民在这里步行健身。 晚上在光谷逛了一番，emm规划的很大，不过整体的感觉有点杂乱，看看时间已经十年了，再一想，十年！十年前武汉这么靠东的地方就有这样规格的购物广场了，确实发展步伐要快很多啊。比较有意思的小插曲就是晚上部门培训，哇花着全国流量举着手机看了一路（怕是被路人误当成追剧少年了哈哈哈）。 归途，返程。]]></content>
      <categories>
        <category>旅行</category>
      </categories>
      <tags>
        <tag>旅行</tag>
        <tag>游记，武汉</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[【POJ-1458】解题报告（DP，最长相同子序列）]]></title>
    <url>%2Fpost%2F104a4c5d.html</url>
    <content type="text"><![CDATA[原始题目Common Subsequence Time Limit: 1000MS Memory Limit: 10000K Total Submissions: 56895 Accepted: 23740 Problem Description A subsequence of a given sequence is the given sequence with some elements (possible none) left out. Given a sequence X = &lt; x1, x2, …, xm &gt; another sequence Z = &lt; z1, z2, …, zk &gt; is a subsequence of X if there exists a strictly increasing sequence &lt; i1, i2, …, ik &gt; of indices of X such that for all j = 1,2,…,k, xij = zj. For example, Z = &lt; a, b, f, c &gt; is a subsequence of X = &lt; a, b, c, f, b, c &gt; with index sequence &lt; 1, 2, 4, 6 &gt;. Given two sequences X and Y the problem is to find the length of the maximum-length common subsequence of X and Y. InputThe program input is from the std input. Each data set in the input contains two strings representing the given sequences. The sequences are separated by any number of white spaces. The input data are correct. OutputFor each set of data the program prints on the standard output the length of the maximum-length common subsequence from the beginning of a separate line. Sample Inputabcfbc abfcab programming contest abcd mnp Sample Output4 2 0 SourceSoutheastern Europe 2003 题目大意给定两个字符串，求最长相同子序列的长度。 解题思路入门dp，状态转移方程为：dp[i][j]={dp[i-1][j-1]+1(a[i]=a[j]), max(dp[i-1][j],dp[i][j-1])(a[i]!=a[j]} 解题代码12345678910111213141516171819202122232425262728293031#include &lt;cstring&gt;#include &lt;cstdio&gt;#include &lt;algorithm&gt;using namespace std;const int maxn=1005;int len1,len2;char s1[maxn],s2[maxn];int dp[maxn][maxn];void solve()&#123; for(int i=0;i&lt;len1;i++) &#123; for(int j=0;j&lt;len2;j++) &#123; if(s1[i]==s2[j]) dp[i][j]=dp[i-1][j-1]+1; else dp[i][j]=max(dp[i-1][j],dp[i][j-1]); &#125; &#125;&#125;int main()&#123; while(~scanf("%s%s",s1,s2)) &#123; memset(dp,0,sizeof(dp)); len1=strlen(s1),len2=strlen(s2); solve(); printf("%d\n",dp[len1-1][len2-1]); &#125; return 0;&#125; 收获与反思熟悉格式。]]></content>
      <categories>
        <category>编程</category>
        <category>ACM</category>
      </categories>
      <tags>
        <tag>算法</tag>
        <tag>ACM</tag>
        <tag>DP</tag>
        <tag>2018寒假集训</tag>
        <tag>POJ</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[【HDU-1518】解题报告（DFS，极易TLE，剪枝）]]></title>
    <url>%2Fpost%2F3d8072b.html</url>
    <content type="text"><![CDATA[原始题目Square Time Limit: 10000/5000 MS (Java/Others) Memory Limit: 65536/32768 K (Java/Others) Total Submission(s): 17274 Accepted Submission(s): 5409 Problem DescriptionGiven a set of sticks of various lengths, is it possible to join them end-to-end to form a square? InputThe first line of input contains N, the number of test cases. Each test case begins with an integer 4 ≤ M ≤ 20, the number of sticks. M integers follow; each gives the length of a stick - an integer between 1 and 10,000. OutputFor each case, output a line containing “yes” if is is possible to form a square; otherwise output “no”. Sample Input3 4 1 1 1 1 5 10 20 30 40 50 8 1 7 2 6 4 4 3 5 Sample Outputyes no yes SourceUniversity of Waterloo Local Contest 2002.09.21 RecommendLL 题目大意给定M个小木棍的长度，问能否组成一个正方形。 解题思路题目很简单啊，思路也很简单啊，但是写出来就TLE了啊。。。如此可见dfs剪枝是多么的重要。 解题代码12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364656667686970717273747576777879808182#include &lt;queue&gt;#include &lt;cstdio&gt;#include &lt;cstring&gt;#include &lt;cmath&gt;#include &lt;cstdlib&gt;#include &lt;algorithm&gt;using namespace std;//dfsconst int maxn=25;int stick[maxn]; bool vis[maxn];int M,T,sum,len,flag,mmax,mmin; bool cmp(int a, int b)&#123; return a&gt;b?1:0;&#125;void dfs(int count,int now,int index)&#123; if(flag) return; if(count==4) &#123; flag=1; return; &#125; if(now==0) &#123; dfs(count+1,len,M-1); if(flag) return; &#125; else if(now&lt;mmin) return; for(int i=index;i&gt;=0;i--) //剪枝1：从index开始遍历 &#123; if(!vis[i]&amp;&amp;now&gt;=stick[i]) &#123; vis[i]=1; dfs(count,now-stick[i],i-1); //i已经使用过 if(flag) return; vis[i]=0; if(index==M-1)&lt;span class="space" style="white-space:pre;display:inline-block;text-indent:2em;line-height:inherit;"&gt;//剪枝2（重要剪枝）：由于每一边长度都相等，一边不能利用最长木棍的话，那么肯定这组数据肯定过不了，不需要检测了。&lt;/span&gt; &#123; return; &#125; //相同的忽略 while(stick[i]==stick[i-1])&lt;span class="space" style="white-space:pre;display:inline-block;text-indent:2em;line-height:inherit;"&gt; //剪枝3：同样长度的都过不了，无需再走一遍&lt;/span&gt; &#123;// printf("!1"); i--; &#125; &#125; &#125; return ;&#125;int main()&#123;// freopen("in.txt","r",stdin); scanf("%d",&amp;T); while(T--) &#123; memset(vis,0,sizeof(vis)); scanf("%d",&amp;M); flag=sum=0; for(int i=0;i&lt;M;i++) &#123; scanf("%d",&amp;stick[i]); sum+=stick[i]; &#125; sort(stick,stick+M); mmax=stick[M-1],mmin=stick[0]; len=sum/4; if(sum%4||mmax&gt;len) printf("no\n"); else &#123; dfs(0,len,M-1); if(flag) printf("yes\n"); else printf("no\n"); &#125; &#125; return 0; &#125; 收获与反思跟TLE斗智斗勇了一下午，慢慢嚼代码，想剪枝，确定剪枝的效果。（等待补图）]]></content>
      <categories>
        <category>编程</category>
        <category>ACM</category>
      </categories>
      <tags>
        <tag>算法</tag>
        <tag>ACM</tag>
        <tag>2018寒假集训</tag>
        <tag>补图</tag>
        <tag>HDU</tag>
        <tag>DFS</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[【CodeForces-455A】解题报告（DP，long long）]]></title>
    <url>%2Fpost%2Fa1fc03d8.html</url>
    <content type="text"><![CDATA[原始题目A. Boredom time limit per test 1 second memory limit per test 256 megabytes input standard input output standard output Alex doesn’t like boredom. That’s why whenever he gets bored, he comes up with games. One long winter evening he came up with a game and decided to play it. Given a sequence a consisting of n integers. The player can make several steps. In a single step he can choose an element of the sequence (let’s denote it ak) and delete it, at that all elements equal to ak + 1 and ak - 1 also must be deleted from the sequence. That step brings ak points to the player. Alex is a perfectionist, so he decided to get as many points as possible. Help him. InputThe first line contains integer n (1 ≤ n ≤ 105) that shows how many numbers are in Alex’s sequence. The second line contains n integers a1, a2, …, an (1 ≤ ai ≤ 105). OutputPrint a single integer — the maximum number of points that Alex can earn. Examplesinput2 1 2 output2 input3 1 2 3 output4 input9 1 2 1 3 2 2 2 2 3 output10 NoteConsider the third test example. At first step we need to choose any element equal to 2. After that step our sequence looks like this [2, 2, 2, 2]. Then we do 4 steps, on each step we choose any element equals to 2. In total we earn 10 points. 题目大意给出一个数列a1,a2,a3…ai…an。每次选定一个数ai，并且所有与ai-1，ai+1相等的数全部消去，这样消去一次得分为ai。最终把数列全部消去完，问最终最高得分是多少。 解题思路dp，数组A[ai]表示ai出现的次数，并且记录最大值mmax，从0到mmax走一遍dp。 状态转移方程为dp[i]=max(dp[i-1],dp[i-2]+A[i]*i)，即从小到大消去到ai=i时的最高得分为：消去到i-1的最高得分（因为消去i-1时所有i=i-1+1全部被消去）与消去到i-2的最高得分加上消去A[i]个i的得分（即跳过i-1不消去）。 由于涉及求和，ai乘上出现次数会超int范围，故使用long long。 解题代码1234567891011121314151617181920212223242526272829303132333435363738394041#include &lt;queue&gt;#include &lt;cstdio&gt;#include &lt;cstring&gt;#include &lt;cmath&gt;#include &lt;cstdlib&gt;#include &lt;algorithm&gt;//dp[i]=max(dp[i-1],dp[i-2]+a[i]*i)using namespace std;const int maxn=100100;long long dp[maxn],a[maxn];long long n,t,mmax;void solve()&#123; //0不出现，初始化 1 dp[1]=a[1]; for(long long i=2;i&lt;=mmax;i++) &#123; dp[i]=max(dp[i-1],dp[i-2]+a[i]*i); &#125; printf("%lld\n",dp[mmax]);&#125;int main()&#123; while(~scanf("%lld",&amp;n)) &#123; memset(dp,0,sizeof(dp)); memset(a,0,sizeof(a)); long long maxx=0; for(long long i=1;i&lt;=n;i++) &#123; scanf("%lld",&amp;t); if(t&gt;mmax) mmax=t; a[t]++; &#125;// for(long long i=1;i&lt;=n;i++)// printf("a[%d]=%d\n",i,a[i]); solve(); &#125; return 0;&#125; 收获与反思建立好状态转移方程就好，注意long long。]]></content>
      <categories>
        <category>编程</category>
        <category>ACM</category>
      </categories>
      <tags>
        <tag>算法</tag>
        <tag>ACM</tag>
        <tag>DP</tag>
        <tag>2018寒假集训</tag>
        <tag>CodeForces</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[【AtCoder-3881】解题报告（简单DP）]]></title>
    <url>%2Fpost%2Ffbf7f335.html</url>
    <content type="text"><![CDATA[原始题目C - Candies Time limit : 2sec Memory limit : 256MB Score : 300 points Problem Statement We have a 2×N grid. We will denote the square at the i-th row and j-th column (1≤i≤2, 1≤j≤N) as (i,j). You are initially in the top-left square, (1,1). You will travel to the bottom-right square, (2,N), by repeatedly moving right or down. The square (i,j) contains Ai,j candies. You will collect all the candies you visit during the travel. The top-left and bottom-right squares also contain candies, and you will also collect them. At most how many candies can you collect when you choose the best way to travel? Constraints 1≤N≤100 1≤Ai,j≤100 (1≤i≤2, 1≤j≤N) InputInput is given from Standard Input in the following format: N A1,1 A1,2 … A1,N A2,1 A2,2 … A2,N OutputPrint the maximum number of candies that can be collected. Sample Input 1 5 3 2 2 4 1 1 2 2 2 1 Sample Output 1 14The number of collected candies will be maximized when you: move right three times, then move down once, then move right once. Sample Input 2 4 1 1 1 1 1 1 1 1 Sample Output 2 5 You will always collect the same number of candies, regardless of how you travel. Sample Input 3 7 3 3 4 5 4 5 3 5 3 4 4 2 3 2 Sample Output 3 29 Sample Input 4 1 2 3 Sample Output 4 5 题目大意2*N个格子，每个格子里均含有不同数量的蜡烛。每一次只能向右或者向下走，问从（1，1）走到（2，N）最多能收集多少根蜡烛（包括首尾）。 解题思路入门DP，简化成2*N了，状态转移方程：dp[i][j]=max(dp[i-1][j],dp[i][j-1])+a[i][j] 解题代码 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556#include &lt;cstdio&gt;#include &lt;cstring&gt;#include &lt;cmath&gt;#include &lt;iostream&gt;#include &lt;iomanip&gt;#include &lt;set&gt;#include &lt;queue&gt;#include &lt;stack&gt;#include &lt;vector&gt;#include &lt;string&gt;#include &lt;sstream&gt;#include &lt;bits/stdc++.h&gt;#define rep(i,a,n) for(int i=a;i&lt;n;++i)#define per(i,a,n) for(int i=n-1;i&gt;=a;--i);#define ms(x,a) memset((x),a,sizeof((x))) #define INF 0x3f3f3f3f#define eps 1e-8#define fi first#define se second#define mp make_pair#define pb push_back#define np next_permutation#define gapline cout&lt;&lt;"##======================##"&lt;&lt;endlusing namespace std;const int maxn=300;const int maxl=26;const int maxm=1e5+5;typedef long long ll;typedef unsigned long long ull;typedef vector&lt;int&gt; vi;typedef pair&lt;int,int&gt; pii;int n,m;int dp[maxn][maxn],a[maxn][maxn];void solve()&#123; rep(i,1,n+1)&#123; rep(j,1,m+1)&#123; dp[i][j]=max(dp[i-1][j],dp[i][j-1])+a[i][j]; &#125; &#125;&#125; int main()&#123; ios::sync_with_stdio(false); while(cin&gt;&gt;m)&#123; ms(dp,0); n=2; rep(i,1,n+1)&#123; rep(j,1,m+1) cin&gt;&gt;a[i][j]; &#125; solve(); cout&lt;&lt;dp[2][m]&lt;&lt;endl; &#125;&#125; 收获与反思 第一次小比赛实战应用dp，看了看大神们也都是dp秒出说明思路是正确的。能写好状态转移方程就行。 2018.8.23更新 代码优化，利用dp外围空白。]]></content>
      <categories>
        <category>编程</category>
        <category>ACM</category>
      </categories>
      <tags>
        <tag>算法</tag>
        <tag>ACM</tag>
        <tag>AtCoder</tag>
        <tag>DP</tag>
        <tag>2018寒假集训</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[【SCU-1114】解题报告（DP，路径，DFS）]]></title>
    <url>%2Fpost%2Ff4bfd16b.html</url>
    <content type="text"><![CDATA[原始题目下图是个数字三角，请编写一个程序计算从顶部至底部某处一条路径，使得该路径所经过的数字总和最大。 7 3 8 8 1 0 2 7 4 4 每一步可沿左斜线向下或右斜线向下走； 1≤三角形行数≤100 三角形中的数字为整数 0，1，……，99。 如果有多种情况结果都最大，任意输出一种即可。 输入：第一行一个整数N，代表三角形的行数。 接下来N行，描述了一个数字三角。 输出：第一行一个整数，代表路径所经过底数字总和。 第二行N个数，代表所经过的数字。 样例：输入：4 7 3 8 8 1 0 2 7 4 4 输出：25 7 3 8 7 解题思路入门dp，状态转移方程为dp[i][j]=max(dp[i+1][j],dp[i+1][j+1])+a[i][j]; dp[i][j]表示i行j列（即第i行j个数字到底部的最大和）。根据该状态转移方程递归实现即可。 本题不仅需要记录最终的和，还需要记录路径，这时候就需要根据dp的表再用dfs走一遍。 解题代码123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778#include &lt;cstdio&gt;#include &lt;cstring&gt;#include &lt;cstdlib&gt;#include &lt;cmath&gt;using namespace std;const int maxn=1e2+10; int n,m;//n行，m列 int a[maxn][maxn];int f[maxn][maxn];int ans[maxn];int flag;//f[i,j]=max(f[i+1,j],f[i+1,j+1])+a[i,j]int max(int a,int b)&#123; return a&gt;b?a:b;&#125;int dp(int i,int j)//递归实现 &#123; int t; if(i==n)//到底部 &#123; t=a[i][j]; return f[i][j]=t; &#125; else &#123; t=max(dp(i+1,j),dp(i+1,j+1))+a[i][j]; return f[i][j]=t; &#125; &#125;void dfs(int i,int j,int tot,int n) &#123; //cout&lt;&lt;i&lt;&lt;" "&lt;&lt;j&lt;&lt;endl; if(flag) return; if(i==n) &#123; for(int i=1;i&lt;n;i++) printf("%d ",ans[i]); printf("%d\n",ans[n]); flag=1; &#125; int tmp=tot-a[i][j]; if(tmp==f[i+1][j]) &#123; ans[i+1]=a[i+1][j]; dfs(i+1,j,tmp,n); &#125; else if(tmp==f[i+1][j+1]) &#123; ans[i+1]=a[i+1][j+1]; dfs(i+1,j+1,tmp,n); &#125; &#125; int main()&#123; while(~scanf("%d",&amp;n)) &#123; memset(a,0,sizeof(a)); memset(f,0,sizeof(f)); for(int i=1;i&lt;=n;i++) &#123; for(int j=1;j&lt;=i;j++) &#123; scanf("%d",&amp;a[i][j]); &#125; &#125; dp(1,1); printf("%d\n",f[1][1]); flag=0; dfs(0,0,f[1][1],n); &#125; return 0;&#125; 收获与反思开始在怎么寻找路径这里卡住了，学到的东西得反复看啊。。不然真的不会用。]]></content>
      <categories>
        <category>编程</category>
        <category>ACM</category>
      </categories>
      <tags>
        <tag>算法</tag>
        <tag>ACM</tag>
        <tag>DP</tag>
        <tag>2018寒假集训</tag>
        <tag>DFS</tag>
        <tag>SCU</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[【HDU-2717】解题报告（BFS）]]></title>
    <url>%2Fpost%2F5c86d06a.html</url>
    <content type="text"><![CDATA[原始题目Catch That Cow Time Limit: 5000/2000 MS (Java/Others) Memory Limit: 32768/32768 K (Java/Others) Total Submission(s): 17820 Accepted Submission(s): 5260 Problem Description Farmer John has been informed of the location of a fugitive cow and wants to catch her immediately. He starts at a point N (0 ≤ N ≤ 100,000) on a number line and the cow is at a point K (0 ≤ K ≤ 100,000) on the same number line. Farmer John has two modes of transportation: walking and teleporting. Walking: FJ can move from any point X to the points X - 1 or X + 1 in a single minute Teleporting: FJ can move from any point X to the point 2 × X in a single minute. If the cow, unaware of its pursuit, does not move at all, how long does it take for Farmer John to retrieve it? InputLine 1: Two space-separated integers: N and K OutputLine 1: The least amount of time, in minutes, it takes for Farmer John to catch the fugitive cow. Sample Input5 17 Sample Output4 HintThe fastest way for Farmer John to reach the fugitive cow is to move along the following path: 5-10-9-18-17, which takes 4 minutes. SourceUSACO 2007 Open Silver Recommendteddy 题目大意一个人想用最短的时间去抓住一头牛，牛不会动，人的移动规则是：下一次移动可以移动到X+1位置，X-1位置，或者2*X位置（X为当前位置坐标），现在给定人和牛的坐标，求人抓到牛所需要的最短时间（次数） 解题思路很直接的广搜，搜索规则可以理解成三个direction，+1，-1，*2；最后可以加上一点处理（不知道算不算剪枝）因为坐标横大于0，那么若牛的初始坐标值小于人，那么无需广搜可以得到最短次数即坐标值之差（每次左移一个单位），另由于广搜深度增加，每次搜索的量会很大，可以加入判断搜索到结果时立即跳脱循环。 解题代码123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384#include &lt;queue&gt;#include &lt;cstdio&gt;#include &lt;cstring&gt;#include &lt;cmath&gt;#include &lt;cstdlib&gt;#include&lt;algorithm&gt;using namespace std;const int maxn=100001; int n,m; bool vis[maxn]; // 访问标记int dir[3]; //struct State // BFS 队列中的状态数据结构//&#123;// int x;// int Step_Counter; // 搜索步数统计器//&#125;;queue &lt;int&gt; q;int step[maxn];bool CheckState(int X) // 约束条件检验&#123;// int X=now.x; if(X&gt;=0&amp;&amp;X&lt;=100000&amp;&amp;!vis[X]) // 满足条件 &#123;// printf("next X=%d, step=%d\n",X,now.Step_Counter+1); return 1; &#125; else // 约束条件冲突 return 0;&#125;void bfs(int st)&#123; int now,next; // 定义2个状态，当前和下一个 q.push(st); step[st]=0; vis[st]=true; // 访问标记 while(!q.empty()) &#123; now=q.front(); // 取队首元素进行扩展 if(now==m) // 出现目标态，此时为Step_Counter 的最小值，可以退出即可 &#123; printf("%d\n",step[now]); return; &#125; //按照规则搜索下一组数 //两种形式，一种左右，一种倍乘。 dir[0]=-1;dir[1]=1;dir[2]=now; int flag=0; for(int i=0;i&lt;3;i++) &#123; next=now+dir[i];// printf("check X=%d, step=%d\n",next,step[now]+1); if(next==m)//剪枝，立即跳出循环 &#123; while(!q.empty()) q.pop(); step[next]=step[now]+1; q.push(now); q.push(next); break; &#125; if(CheckState(next)) &#123; step[next]=step[now]+1; vis[next]=true; //不要忘了标记已访问 q.push(next); &#125; &#125; q.pop(); // 队首元素出队 &#125; return;&#125;int main()&#123;// freopen("in.txt","r",stdin); while(~scanf("%d%d",&amp;n,&amp;m)) &#123; while(!q.empty()) q.pop(); memset(vis,0,sizeof(vis)); memset(step,0,sizeof(step)); if(n&gt;=m) printf("%d\n",n-m); else bfs(n); &#125;&#125; 收获与反思使用模板里的结构时出现了两次MLE，不知道是什么个情况，有待检查。]]></content>
      <categories>
        <category>编程</category>
        <category>ACM</category>
      </categories>
      <tags>
        <tag>算法</tag>
        <tag>ACM</tag>
        <tag>2018寒假集训</tag>
        <tag>BFS</tag>
        <tag>HDU</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[【POJ-3126】解题报告（BFS，换门牌号，素数筛）]]></title>
    <url>%2Fpost%2F409dbc1a.html</url>
    <content type="text"><![CDATA[原始题目Prime Path Time Limit: 1000MS Memory Limit: 65536K Total Submissions: 24280 Accepted: 13417 Problem Description The ministers of the cabinet were quite upset by the message from the Chief of Security stating that they would all have to change the four-digit room numbers on their offices. — It is a matter of security to change such things every now and then, to keep the enemy in the dark. — But look, I have chosen my number 1033 for good reasons. I am the Prime minister, you know! — I know, so therefore your new number 8179 is also a prime. You will just have to paste four new digits over the four old ones on your office door. — No, it’s not that simple. Suppose that I change the first digit to an 8, then the number will read 8033 which is not a prime! — I see, being the prime minister you cannot stand having a non-prime number on your door even for a few seconds. — Correct! So I must invent a scheme for going from 1033 to 8179 by a path of prime numbers where only one digit is changed from one prime to the next prime. Now, the minister of finance, who had been eavesdropping, intervened. — No unnecessary expenditure, please! I happen to know that the price of a digit is one pound. — Hmm, in that case I need a computer program to minimize the cost. You don’t know some very cheap software gurus, do you? — In fact, I do. You see, there is this programming contest going on… Help the prime minister to find the cheapest prime path between any two given four-digit primes! The first digit must be nonzero, of course. Here is a solution in the case above. 1033 1733 3733 3739 3779 8779 8179 The cost of this solution is 6 pounds. Note that the digit 1 which got pasted over in step 2 can not be reused in the last step – a new 1 must be purchased. InputOne line with a positive number: the number of test cases (at most 100). Then for each test case, one line with two numbers separated by a blank. Both numbers are four-digit primes (without leading zeros). OutputOne line for each case, either with a number stating the minimal cost or containing the word Impossible. Sample Input3 1033 8179 1373 8017 1033 1033 Sample Output6 7 0 SourceNorthwestern Europe 2006 题目大意换门牌号，要求每次只能更换一位，且更换完之后的新数字要是素数，问更换到指定号码的最少步数是多少。 解题思路按个十百千位广搜，&lt;40入口，搜索的规则是，该数没有被搜索过，且该数为素数。由于是BFS，所以第一次搜索到最终更改的门牌号时一定是最少步数，输出该值即可。如果广搜入口全部遍历一编还是未能搜索到最终更改的门牌号，即为不可能，输出Impossible。 要点： 由于要求是素数，所以个位只需要搜索奇数即可，以及千位避开0； 涉及素数，可以用最基础的素数判断（即从2开始逐个除，若有因子则返回false），或者使用素数筛先建立素数表然后直接查表（待补充） 解题代码 素数传统判断 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130#include &lt;queue&gt;#include &lt;cstdio&gt;#include &lt;cstring&gt;#include &lt;cmath&gt;#include &lt;cstdlib&gt;#include&lt;algorithm&gt;#define maxn 10100using namespace std;int n,m; bool vis[maxn]; // 访问标记//int dir[4][2]=&#123;0,1,0,-1,1,0,-1,0&#125;; // 方向向量//int dir[8][2]=&#123;&#123;1,1&#125;,&#123;1,0&#125;,&#123;1,-1&#125;,&#123;0,1&#125;,&#123;0,-1&#125;,&#123;-1,1&#125;,&#123;-1,0&#125;,&#123;-1,-1&#125;&#125; ;struct State // BFS 队列中的状态数据结构&#123; int x; int Step_Counter; // 搜索步数统计器&#125;;bool isPrime(int x)&#123; if(x==0||x==1) return false; else if(x==2||x==3) return true; else &#123; for(int i=2;i&lt;=(int)sqrt(x);i++) &#123; if(x%i==0) return false; &#125; return true; &#125;&#125; State a[maxn];bool CheckState(int s,State now) // 约束条件检验&#123; if(s!=now.x&amp;&amp;!vis[s]&amp;&amp;isPrime(s)) // 满足条件 &#123;// printf("next s=%d, step=%d\n",s,now.Step_Counter+1); return 1; &#125; else // 约束条件冲突 return 0;&#125;void bfs(State st)&#123; queue &lt;State&gt; q; State now,next; // 定义2个状态，当前和下一个 st.Step_Counter=0; // 计数器清零 q.push(st); // 入队 vis[st.x]=1; // 访问标记 while(!q.empty()) &#123; now=q.front(); // 取队首元素进行扩展 if(now.x==m) // 出现目标态，此时为Step_Counter 的最小值，可以退出即可 &#123; printf("%d\n",now.Step_Counter); return; &#125; //按照规则搜索下一组数 for(int i=1;i&lt;=9;i+=2) &#123; int s=now.x/10*10+i; if(CheckState(s,now)) &#123; vis[s]=1; next.x=s; next.Step_Counter=now.Step_Counter+1; q.push(next); &#125; &#125; for(int i=0;i&lt;=9;i++) &#123; int s = now.x / 100 * 100 + i * 10 + now.x % 10; if(CheckState(s,now)) &#123; vis[s]=1; next.x=s; next.Step_Counter=now.Step_Counter+1; q.push(next); &#125; &#125; for(int i=0;i&lt;=9;i++) &#123; int s=now.x/1000*1000+i*100+now.x%100; if(CheckState(s,now)) &#123; vis[s]=1; next.x=s; next.Step_Counter=now.Step_Counter+1; q.push(next); &#125; &#125; for(int i=1;i&lt;=9;i++) &#123; int s=i*1000+now.x%1000; if(CheckState(s,now)) &#123; vis[s]=1; next.x=s; next.Step_Counter=now.Step_Counter+1; q.push(next); &#125; &#125; q.pop(); // 队首元素出队 &#125; printf("Impossible\n"); return;&#125;int main()&#123; int t; scanf("%d",&amp;t); for(int i=0;i&lt;t;i++) &#123;// printf("%d %d\n",t,n);// while(!q.empty()) q.pop(); memset(vis,0,sizeof(vis)); scanf("%d%d",&amp;n,&amp;m); struct State tmp; tmp.x=n; tmp.Step_Counter=0; bfs(tmp); &#125; return 0;&#125; 非线性埃式素数筛 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132#include &lt;queue&gt;#include &lt;cstdio&gt;#include &lt;cstring&gt;#include &lt;cmath&gt;#include &lt;cstdlib&gt;#include&lt;algorithm&gt;#define maxn 10100using namespace std;int n,m; bool vis[maxn]; // 访问标记//int dir[4][2]=&#123;0,1,0,-1,1,0,-1,0&#125;; // 方向向量//int dir[8][2]=&#123;&#123;1,1&#125;,&#123;1,0&#125;,&#123;1,-1&#125;,&#123;0,1&#125;,&#123;0,-1&#125;,&#123;-1,1&#125;,&#123;-1,0&#125;,&#123;-1,-1&#125;&#125; ;struct State // BFS 队列中的状态数据结构&#123; int x; int Step_Counter; // 搜索步数统计器&#125;;bool isPrime[maxn]; void solvePrime() //埃式素数筛 &#123; memset(isPrime,1,sizeof(isPrime)); isPrime[0]=isPrime[1]=false; for(int i=2;i&lt;=maxn;i++) &#123; if(isPrime[i]) &#123; for(int j=i*i;j&lt;=maxn;j+=i) &#123; isPrime[j]=false; &#125; &#125; &#125;&#125;State a[maxn];bool CheckState(int s,State now) // 约束条件检验&#123; if(s!=now.x&amp;&amp;!vis[s]&amp;&amp;isPrime[s]) // 满足条件 &#123;// printf("next s=%d, step=%d\n",s,now.Step_Counter+1); return 1; &#125; else // 约束条件冲突 return 0;&#125;void bfs(State st)&#123; queue &lt;State&gt; q; State now,next; // 定义2个状态，当前和下一个 st.Step_Counter=0; // 计数器清零 q.push(st); // 入队 vis[st.x]=1; // 访问标记 while(!q.empty()) &#123; now=q.front(); // 取队首元素进行扩展 if(now.x==m) // 出现目标态，此时为Step_Counter 的最小值，可以退出即可 &#123; printf("%d\n",now.Step_Counter); return; &#125; //按照规则搜索下一组数 for(int i=1;i&lt;=9;i+=2) &#123; int s=now.x/10*10+i; if(CheckState(s,now)) &#123; vis[s]=1; next.x=s; next.Step_Counter=now.Step_Counter+1; q.push(next); &#125; &#125; for(int i=0;i&lt;=9;i++) &#123; int s = now.x / 100 * 100 + i * 10 + now.x % 10; if(CheckState(s,now)) &#123; vis[s]=1; next.x=s; next.Step_Counter=now.Step_Counter+1; q.push(next); &#125; &#125; for(int i=0;i&lt;=9;i++) &#123; int s=now.x/1000*1000+i*100+now.x%100; if(CheckState(s,now)) &#123; vis[s]=1; next.x=s; next.Step_Counter=now.Step_Counter+1; q.push(next); &#125; &#125; for(int i=1;i&lt;=9;i++) &#123; int s=i*1000+now.x%1000; if(CheckState(s,now)) &#123; vis[s]=1; next.x=s; next.Step_Counter=now.Step_Counter+1; q.push(next); &#125; &#125; q.pop(); // 队首元素出队 &#125; printf("Impossible\n"); return;&#125;int main()&#123; solvePrime(); int t; scanf("%d",&amp;t); for(int i=0;i&lt;t;i++) &#123;// printf("%d %d\n",t,n);// while(!q.empty()) q.pop(); memset(vis,0,sizeof(vis)); scanf("%d%d",&amp;n,&amp;m); struct State tmp; tmp.x=n; tmp.Step_Counter=0; bfs(tmp); &#125; return 0;&#125; 收获与反思题目本身没什么问题，两次TLE都是因为输入输出格式的问题最后一直等待输入，需要再细心一点。 对于素数筛知识的补充。 传统方法：根据是否有大于1小于本身的因子来判断，复杂度为O(nlognlogn) （虽然还不会证明）。 素数筛方法 埃式筛法，即埃拉托斯特尼筛法，本题采用。原理就是排除0，1，从2开始当前未筛去的数最小的数即为素数 改进前后两次的时间对比（图待补充） 另外还有欧拉筛法（线性）有待学习。]]></content>
      <categories>
        <category>编程</category>
        <category>ACM</category>
      </categories>
      <tags>
        <tag>算法</tag>
        <tag>ACM</tag>
        <tag>2018寒假集训</tag>
        <tag>BFS</tag>
        <tag>补图</tag>
        <tag>素数筛</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[【CodeForces-689B】解题报告（BFS）]]></title>
    <url>%2Fpost%2F454c2358.html</url>
    <content type="text"><![CDATA[原始题目B. Mike and Shortcuts time limit per test 3 seconds memory limit per test 256 megabytes input standard input output standard output Recently, Mike was very busy with studying for exams and contests. Now he is going to chill a bit by doing some sight seeing in the city. City consists of n intersections numbered from 1 to n. Mike starts walking from his house located at the intersection number 1 and goes along some sequence of intersections. Walking from intersection number i to intersection j requires |i - j| units of energy. The total energyspent by Mike to visit a sequence of intersections p1 = 1, p2, …, pk is equal to units of energy. Of course, walking would be boring if there were no shortcuts. A shortcut is a special path that allows Mike walking from one intersection to another requiring only 1 unit of energy. There are exactly n shortcuts in Mike’s city, the ith of them allows walking from intersection i to intersection ai (i ≤ ai ≤ ai + 1) (but not in the opposite direction), thus there is exactly one shortcut starting at each intersection. Formally, if Mike chooses a sequence p1 = 1, p2, …, pk then for each 1 ≤ i &lt; k satisfying pi + 1 = api and api ≠ pi Mike will spend only 1 unit of energy instead of |pi - pi + 1| walking from the intersection pi to intersection pi + 1. For example, if Mike chooses a sequence p1 = 1, p2 = ap1, p3 = ap2, …, pk = apk - 1, he spends exactly k - 1 units of total energy walking around them. Before going on his adventure, Mike asks you to find the minimum amount of energy required to reach each of the intersections from his home. Formally, for each 1 ≤ i ≤ n Mike is interested in finding minimum possible total energy of some sequence p1 = 1, p2, …, pk = i. InputThe first line contains an integer n (1 ≤ n ≤ 200 000) — the number of Mike’s city intersection. The second line contains n integers a1, a2, …, an (i ≤ ai ≤ n , , describing shortcuts of Mike’s city, allowing to walk from intersection i to intersection ai using only 1 unit of energy. Please note that the shortcuts don’t allow walking in opposite directions (from ai to i). OutputIn the only line print n integers m1, m2, …, mn, where mi denotes the least amount of total energy required to walk from intersection 1 to intersection i. Examplesinput3 2 2 3 output0 1 2 input5 1 2 3 4 5 output0 1 2 3 4 input7 4 4 4 4 7 7 7 output0 1 2 1 2 3 3 NoteIn the first sample case desired sequences are: 1: 1; m1 = 0; 2: 1, 2; m2 = 1; 3: 1, 3; m3 = |3 - 1| = 2. In the second sample case the sequence for any intersection 1 &lt; i is always 1, i and mi = |1 - i|. In the third sample case — consider the following intersection sequences: 1: 1; m1 = 0; 2: 1, 2; m2 = |2 - 1| = 1; 3: 1, 4, 3; m3 = 1 + |4 - 3| = 2; 4: 1, 4; m4 = 1; 5: 1, 4, 5; m5 = 1 + |4 - 5| = 2; 6: 1, 4, 6; m6 = 1 + |4 - 6| = 3; 7: 1, 4, 5, 7; m7 = 1 + |4 - 5| + 1 = 3. 题目大意给出n个点，如果直接从a1点到an点，耗费|xn-x1|的能量，不过每个点都存在一个到另一个点的“快速路径”，消耗能量为1，现在求从第一个点开始到每一个点消耗能量的最小值。 解题思路广搜，下一次搜索的规则是，左右相邻的点和该点快速路径到达的点（即消耗能量均为1的点），三个方向，这样一层一层往下搜索，第一次到达ai点时消耗的能量（计数器)即为从第一个点到该点消耗的最小能量。 解题代码123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102#include &lt;queue&gt;#include &lt;cstdio&gt;#include &lt;cstring&gt;#include &lt;cmath&gt;#include &lt;cstdlib&gt;#define maxn 200010using namespace std;int n;//个数 bool vis[maxn]; // 访问标记//int dir[4][2]=&#123;0,1,0,-1,1,0,-1,0&#125;; // 方向向量//int dir[8][2]=&#123;&#123;1,1&#125;,&#123;1,0&#125;,&#123;1,-1&#125;,&#123;0,1&#125;,&#123;0,-1&#125;,&#123;-1,1&#125;,&#123;-1,0&#125;,&#123;-1,-1&#125;&#125; ;int dir[3];struct State // BFS 队列中的状态数据结构&#123; int i; int ai; int Step_Counter; // 搜索步数统计器 bool first; int min;&#125;;State a[maxn];int ans[maxn];bool CheckState(State next) // 约束条件检验&#123; if(next.i&gt;0&amp;&amp;next.i&lt;=n&amp;&amp;!vis[next.i]) // 满足条件 &#123;// printf("next %d %d\n",next.i,next.ai); return 1; &#125; else // 约束条件冲突 return 0;&#125;void bfs(State st)&#123; queue &lt;State&gt; q; // BFS 队列 State now,next; // 定义2个状态，当前和下一个 st.Step_Counter=0; // 计数器清零 q.push(st); // 入队 vis[st.i]=1; // 访问标记 int circle=0; while(!q.empty()) &#123; now=q.front(); // 取队首元素进行扩展// a[now.i].Step_Counter=++circle; if(a[now.i].first) // 出现目标态，此时为Step_Counter 的最小值，可以退出即可 &#123; // 做相关处理// printf("first visit i=%d, min=%d\n",now.i,now.Step_Counter); a[now.i].min=now.Step_Counter; a[now.i].first=false;// return; &#125; else if(a[now.i].min&lt;now.Step_Counter) a[now.i].min=now.Step_Counter; dir[0]=now.i-1;dir[1]=now.i+1;dir[2]=now.ai; //生成下一组方向 for(int i=0;i&lt;3;i++) &#123; next.i=dir[i];// 按照规则生成 下一个状态 next.ai=a[dir[i]].ai; next.Step_Counter=now.Step_Counter+1; // 计数器加1 if(CheckState(next)) // 如果状态满足约束条件则入队 &#123; q.push(next);// printf("insert i=%d ai=%d\n",next.i,next.ai); vis[next.i]=1; //访问标记 &#125; &#125; q.pop(); // 队首元素出队 &#125; return;&#125;int main()&#123; while(~scanf("%d",&amp;n)) &#123; memset(vis,0,sizeof(vis)); for(int j=1;j&lt;=n;j++) &#123; a[j].i=j; a[j].first=true; scanf("%d",&amp;a[j].ai); &#125; bfs(a[1]); int flag=1; for(int j=1;j&lt;=n;j++) &#123; if(flag) &#123; printf("%d",a[j].min); flag=0; &#125; else printf(" %d",a[j].min); &#125; printf("\n"); &#125; return 0;&#125; 收获与反思思路清楚的话还是比较好写的，这里没有绝对的目标状态，所以全部遍历一遍每一个都打上Step值，然后输出就行。]]></content>
      <categories>
        <category>编程</category>
        <category>ACM</category>
      </categories>
      <tags>
        <tag>算法</tag>
        <tag>ACM</tag>
        <tag>2018寒假集训</tag>
        <tag>BFS</tag>
        <tag>CodeForces</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[【ZOJ-1709】解题报告（BFS）]]></title>
    <url>%2Fpost%2F42a619f7.html</url>
    <content type="text"><![CDATA[原始题目Oil Deposits Time Limit: 2 Seconds Memory Limit: 65536 KB The GeoSurvComp geologic survey company is responsible for detecting underground oil deposits. GeoSurvComp works with one large rectangular region of land at a time, and creates a grid that divides the land into numerous square plots. It then analyzes each plot separately, using sensing equipment to determine whether or not the plot contains oil. A plot containing oil is called a pocket. If two pockets are adjacent, then they are part of the same oil deposit. Oil deposits can be quite large and may contain numerous pockets. Your job is to determine how many different oil deposits are contained in a grid. InputThe input file contains one or more grids. Each grid begins with a line containing m and n, the number of rows and columns in the grid, separated by a single space. If m = 0 it signals the end of the input; otherwise 1 ≤ m ≤ 100 and 1 ≤ n ≤ 100. Following this are m lines of n characters each (not counting the end-of-line characters). Each character corresponds to one plot, and is either ‘*’, representing the absence of oil, or ‘@’, representing an oil pocket. OutputFor each grid, output the number of distinct oil deposits. Two different pockets are part of the same oil deposit if they are adjacent horizontally, vertically, or diagonally. An oil deposit will not contain more than 100 pockets. Sample Input1 1 * 3 5 *@*@* **@** *@*@* 1 8 @@****@* 5 5 ****@ *@@*@ *@**@ @@@*@ @@**@ 0 0 Sample Output0 1 2 2 SourceMid-Central USA 1997 题目大意给定一个用*和@标记的油田，找出不连续的油田总数。 解题思路每一个点入口BFS，搜索过的标记，最后记录广搜的总次数就行。 解题代码123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596#include &lt;queue&gt;#include &lt;cstdio&gt;#include &lt;cstring&gt;#include &lt;cstdlib&gt;#define maxn 105using namespace std;char map[maxn][maxn];//图int n,m;//n为行数，m为列数bool vis[maxn][maxn]; // 访问标记//int dir[4][2]=&#123;0,1,0,-1,1,0,-1,0&#125;; // 方向向量int dir[8][2]=&#123;&#123;1,1&#125;,&#123;1,0&#125;,&#123;1,-1&#125;,&#123;0,1&#125;,&#123;0,-1&#125;,&#123;-1,1&#125;,&#123;-1,0&#125;,&#123;-1,-1&#125;&#125; ;struct State // BFS 队列中的状态数据结构&#123; int x,y; // 坐标位置 int Step_Counter; // 搜索步数统计器&#125;;State a[maxn];bool CheckState(State s) // 约束条件检验&#123; if(s.x&gt;=0&amp;&amp;s.x&lt;m&amp;&amp;s.y&gt;=0&amp;&amp;s.y&lt;n&amp;&amp;map[s.x][s.y]&amp;&amp;!vis[s.x][s.y]) // 满足条件 &#123;// printf("next %d %d\n",s.x,s.y); return 1; &#125; else // 约束条件冲突 return 0;&#125;void bfs(State st)&#123; queue &lt;State&gt; q; // BFS 队列 State now,next; // 定义2个状态，当前和下一个 st.Step_Counter=0; // 计数器清零 q.push(st); // 入队 vis[st.x][st.y]=1; // 访问标记 while(!q.empty()) &#123; now=q.front(); // 取队首元素进行扩展// if(now==G) // 出现目标态，此时为Step_Counter 的最小值，可以退出即可// &#123;// ...... // 做相关处理// return;// &#125; for(int i=0;i&lt;8;i++) &#123; next.x=now.x+dir[i][0]; // 按照规则生成 下一个状态 next.y=now.y+dir[i][1];// printf("insert %d %d\n",next.x,next.y); next.Step_Counter=now.Step_Counter+1; // 计数器加1 if(CheckState(next)) // 如果状态满足约束条件则入队 &#123; q.push(next);// printf("insert %d %d\n",next.x,next.y); vis[next.x][next.y]=1; //访问标记 &#125; &#125; q.pop(); // 队首元素出队 &#125; return;&#125;int main()&#123; while(~scanf("%d%d",&amp;m,&amp;n)&amp;&amp;m+n) &#123; memset(vis,0,sizeof(vis)); for(int i=0;i&lt;m;i++) &#123; scanf("%s",map[i]); for(int j=0;j&lt;n;j++) &#123; if(map[i][j]=='*') map[i][j]=0; else if(map[i][j]=='@') map[i][j]=1; &#125; &#125; int count=0; for(int i=0;i&lt;m;i++) &#123; for(int j=0;j&lt;n;j++) &#123; if(map[i][j]&amp;&amp;!vis[i][j]) //此区域有油&amp;&amp;没有被访问过 &#123; count++; State curst; curst.x=i;curst.y=j;// printf("search %d %d\n",i,j); bfs(curst);//BFS搜索 &#125; &#125; &#125; printf("%d\n",count); &#125; return 0;&#125; 收获与反思第一次使用模板，对于这种图表示的还比较顺手，如何按照规则查找出下一个状态是广搜的关键。 PS：注意一些细节，比如1和i的区别，一点打错了要debug半天真的伤不起啊。]]></content>
      <categories>
        <category>编程</category>
        <category>ACM</category>
      </categories>
      <tags>
        <tag>算法</tag>
        <tag>ACM</tag>
        <tag>2018寒假集训</tag>
        <tag>BFS</tag>
        <tag>ZOJ</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[【CodeForces-600C】解题报告（贪心，字符串）]]></title>
    <url>%2Fpost%2F265c0f5.html</url>
    <content type="text"><![CDATA[原始题目C. Make Palindrome time limit per test 2 seconds memory limit per test 256 megabytes input standard input output standard output Problem Description A string is called palindrome if it reads the same from left to right and from right to left. For example “kazak”, “oo”, “r” and “mikhailrubinchikkihcniburliahkim” are palindroms, but strings “abb” and “ij” are not. You are given string s consisting of lowercase Latin letters. At once you can choose any position in the string and change letter in that position to any other lowercase letter. So after each changing the length of the string doesn’t change. At first you can change some letters in s. Then you can permute the order of letters as you want. Permutation doesn’t count as changes. You should obtain palindrome with the minimal number of changes. If there are several ways to do that you should get the lexicographically (alphabetically) smallest palindrome. So firstly you should minimize the number of changes and then minimize the palindrome lexicographically. InputThe only line contains string s (1 ≤ |s| ≤ 2·105) consisting of only lowercase Latin letters. OutputPrint the lexicographically smallest palindrome that can be obtained with the minimal number of changes. Examplesinputaabc outputabba inputaabcd outputabcba 题目大意任意输入一串字符，要求输出改动次数最少（移动交换位置不算做改动）且字典序最小的回文串。 解题思路贪心的想法比较直观。由于移动交换位置不算改动。贪心的从两端对称输出典序最小的字母，如果该字母出现次数位奇数，则从字典序最大的字母开始搜索，直至找到第一个出现个数也为奇数的字母（当然也是最大的），大字母的个数-1，小字母个数+1（即用小替换大），偶数个数会调整全部字母出现次数为偶数然后结束，奇数个数的话则需要额外判断，如果搜索到的字母和原字母相同，则说明该字母是中间字母（不一定该字母都在中间！）易错点：把中间字母单独提出来然后相邻的放到中间。 比如aabbhhwwhwwhhbbaa输入本应该原样输出，但是却输出了aabbwwhhhhhwwbbaa，这样会使字典序增大，需要对中间字母特殊处理（正常左右两端输出，只不过最后留一个在中间打印就行。） 解题代码123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147148149150151152153154155156157158159160161162163164165166167168#include &lt;cstdio&gt;#include &lt;iostream&gt;#include &lt;cstring&gt;#include &lt;cmath&gt;#include &lt;algorithm&gt;#define maxn 200100using namespace std;char s[maxn];char outs[maxn];//int alpha[26];bool mark[26];struct node&#123; char letter; int times;&#125;alpha[26];bool cmp(struct node n1,struct node n2)&#123; return n1.letter&gt;n2.letter;&#125;bool cmp1(struct node n1,struct node n2)&#123; return n1.letter&lt;n2.letter;&#125;void odd(int len)&#123;// printf("in odd\n"); for(int i=0;i&lt;len;i++) &#123; alpha[s[i]-97].times++; &#125; sort(alpha,alpha+26,cmp);// for(int i=0;i&lt;26;i++)// &#123;// printf("%d %c %d\n",i,alpha[i].letter,alpha[i].times);// &#125; int point=0,target=0; for(int i=0;i&lt;26;i++) &#123; if(!(alpha[i].times%2)) continue; else &#123; target=i; int j; for(j=target,point=0;j&lt;26;j++) &#123; if(!(alpha[j].times%2)) continue; else point=j; &#125; if(point==0) break; else &#123; alpha[point].times++; alpha[target].times--; &#125; &#125; &#125;// for(int i=0;i&lt;26;i++)// &#123;// printf("%d %c %d\n",i,alpha[i].letter,alpha[i].times);// &#125; char c=alpha[target].letter; char t=alpha[target].times;// printf("target=%c\n",c);// target 中间单值 int count=0; int leftlen=len-alpha[target].times; sort(alpha,alpha+26,cmp1);// printf("now len=%d\n",leftlen); for(int i=0;count&lt;(len-1)/2;i++) &#123; if(alpha[i].letter==c) for(int j=0;j&lt;(alpha[i].times-1)/2;j++) outs[count++]=alpha[i].letter; else for(int j=0;j&lt;alpha[i].times/2;j++) outs[count++]=alpha[i].letter; &#125; int i; for(i=0;i&lt;count;i++) &#123; printf("%c",outs[i]); &#125; printf("%c",c); for(i=count-1;i&gt;=0;i--) &#123; printf("%c",outs[i]); &#125; printf("\n");&#125;void even(int len)&#123;// printf("in even\n"); for(int i=0;i&lt;len;i++) &#123; alpha[s[i]-97].times++; &#125; sort(alpha,alpha+26,cmp);// for(int i=0;i&lt;26;i++)// &#123;// printf("%d %c %d\n",i,alpha[i].letter,alpha[i].times);// &#125; int point=0,target=0; for(int i=0;i&lt;26;i++) &#123;// if(i==25 ) printf("YOO\n"); if(!(alpha[i].times%2)) continue; else &#123; target=i; int j; for(j=target,point=0;j&lt;26;j++) &#123; if(!(alpha[j].times%2)) continue; else point=j; &#125; if(point==0) break; else &#123; alpha[point].times++; alpha[target].times--; &#125; &#125; &#125;// char c=alpha[target].letter;// char t=alpha[target].times;// printf("target=%c\n",c);// //target 中间单值 int count=0;// int leftlen=len-alpha[target].times; sort(alpha,alpha+26,cmp1);// printf("now len=%d\n",leftlen); for(int i=0;count&lt;len/2;i++) &#123; for(int j=0;j&lt;alpha[i].times/2;j++) outs[count++]=alpha[i].letter; &#125; int i; for(i=0;i&lt;count;i++) &#123; printf("%c",outs[i]); &#125; for(i=count-1;i&gt;=0;i--) &#123; printf("%c",outs[i]); &#125; printf("\n");&#125;int main()&#123;// freopen("in.txt", "r", stdin);//其实in.txt是可以修改成其他名字的 比如“输入.txt”，都是可以的，这里只是为了方便起见，下同； // freopen("outmy.txt", "w", stdout); while(~scanf("%s",s)) &#123; memset(alpha,0,sizeof(alpha)); for(int i=0;i&lt;26;i++) &#123; alpha[i].letter='a'+i; alpha[i].times=0; &#125; int len=strlen(s); if(len%2)//Odd odd(len); else even(len); &#125; return 0;&#125; 收获与反思（第一次写贪心，由于开始理解有偏差，改了很多次，代码也很丑陋= =而且太冗长= =，好在最后AC了，需要后面再优化下。）]]></content>
      <categories>
        <category>编程</category>
        <category>ACM</category>
      </categories>
      <tags>
        <tag>算法</tag>
        <tag>ACM</tag>
        <tag>2018寒假集训</tag>
        <tag>Greedy</tag>
        <tag>CodeForces</tag>
        <tag>字符串</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[【HDU-1716】解题报告（排列STL）]]></title>
    <url>%2Fpost%2Fe3e37943.html</url>
    <content type="text"><![CDATA[原始题目排列2 Time Limit: 1000/1000 MS (Java/Others) Memory Limit: 32768/32768 K (Java/Others) Total Submission(s): 9524 Accepted Submission(s): 3467 Problem DescriptionRay又对数字的列产生了兴趣：现有四张卡片，用这四张卡片能排列出很多不同的4位数，要求按从小到大的顺序输出这些4位数。 Input每组数据占一行，代表四张卡片上的数字（0≤数字≤9），如果四张卡片都是0，则输入结束。 Output对每组卡片按从小到大的顺序输出所有能由这四张卡片组成的4位数，千位数字相同的在同一行，同一行中每个四位数间用空格分隔。每组输出数据间空一行，最后一组数据后面没有空行。 Sample Input1 2 3 4 1 1 2 3 0 1 2 3 0 0 0 0 Sample Output1234 1243 1324 1342 1423 1432 2134 2143 2314 2341 2413 2431 3124 3142 3214 3241 3412 3421 4123 4132 4213 4231 4312 4321 1123 1132 1213 1231 1312 1321 2113 2131 2311 3112 3121 3211 1023 1032 1203 1230 1302 1320 2013 2031 2103 2130 2301 2310 3012 3021 3102 3120 3201 3210 解题思路先利用sort排序，然后利用C++STL中的next_permutation()函数将符合要求的排列逐个输出，本题需要注意输出格式有以下几点要求： 需要检测千位发生变化时换行（同一个数的排列每一行打印的四位数个数不一定相等） 含0的序列0不做首位（但是却经历这些排列，注意换行和空格的问题） 老样子，每一行最后一个四位数后没有空格，没有空格，没有空格（输出格式经常出的问题）。 除最后一行之外均有空行。 解题代码123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566#include &lt;cstdio&gt;#include &lt;cstring&gt;#include &lt;cmath&gt;#include &lt;algorithm&gt;using namespace std;int a[4];bool cmp(int a,int b)&#123; return a&lt;b;&#125;int main()&#123;// freopen("in.txt", "r", stdin);// freopen("out.txt", "w", stdout); int i,count=0,num=0; for(i=0;i&lt;4;i++) &#123; int c; scanf("%d",&amp;c); a[count++]=c;// printf("i=%d a[i]=%d\n",i,a[i]); &#125; sort(a,a+count,cmp); while(a[0]||a[1]||a[2]||a[3]) &#123; int circle=0; int qian=a[0]; if(qian&amp;&amp;num) printf("\n"); int sum=0; do &#123; int j; if(a[0]==0) continue; //跳过0开头的排列 if(a[0]!=qian) //换行判定 &#123; qian=a[0]; printf("\n%d",a[0]); &#125; else if(sum) printf(" %d",a[0]); //sum标记第一个数，sum非零四位数前均打印一个空格 else printf("%d",a[0]); for(j=1;j&lt;count-1;j++) &#123; printf("%d",a[j]); &#125; printf("%d",a[j]); sum++; &#125;while(next_permutation(a,a+count)); //使用do while 先打印一次再变为下个排列 printf("\n"); num++; count=0,i=0; for(i=0;i&lt;4;i++) &#123; int c; scanf("%d",&amp;c);// if(c)// &#123; a[count++]=c;// &#125;// printf("i=%d a[i]=%d\n",i,a[i]); &#125; sort(a,a+count,cmp); &#125; return 0; &#125; 收获与反思再次运用next_permutation函数，加深印象，以及对于输出格式的严格控制。]]></content>
      <categories>
        <category>编程</category>
        <category>ACM</category>
      </categories>
      <tags>
        <tag>算法</tag>
        <tag>ACM</tag>
        <tag>2018寒假集训</tag>
        <tag>STL</tag>
        <tag>HDU</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[【POJ-2260】解题报告（模拟，图论引申）]]></title>
    <url>%2Fpost%2F88e8ae98.html</url>
    <content type="text"><![CDATA[原始题目Error Correction Time Limit: 1000MS Memory Limit: 65536K Total Submissions: 6820 Accepted: 4286 Problem Description A boolean matrix has the parity property when each row and each column has an even sum, i.e. contains an even number of bits which are set. Here’s a 4 x 4 matrix which has the parity property: 1 0 1 0 0 0 0 0 1 1 1 1 0 1 0 1 The sums of the rows are 2, 0, 4 and 2. The sums of the columns are 2, 2, 2 and 2.Your job is to write a program that reads in a matrix and checks if it has the parity property. If not, your program should check if the parity property can be established by changing only one bit. If this is not possible either, the matrix should be classified as corrupt. InputThe input will contain one or more test cases. The first line of each test case contains one integer n (n&lt;100), representing the size of the matrix. On the next n lines, there will be n integers per line. No other integers than 0 and 1 will occur in the matrix. Input will be terminated by a value of 0 for n. OutputFor each matrix in the input file, print one line. If the matrix already has the parity property, print “OK”. If the parity property can be established by changing one bit, print “Change bit (i,j)” where i is the row and j the column of the bit to be changed. Otherwise, print “Corrupt”. Sample Input4 1 0 1 0 0 0 0 0 1 1 1 1 0 1 0 1 4 1 0 1 0 0 0 1 0 1 1 1 1 0 1 0 1 4 1 0 1 0 0 1 1 0 1 1 1 1 0 1 0 1 0 Sample OutputOK Change bit (2,3) Corrupt SourceUlm Local 1998 题目大意给定一个n*n的由0/1构成的boolean矩阵，判断是否各行各列和均为偶数。 若是输出OK，若不是，可否更改其中一点的位置使行列均为偶数。输出这个点，若不可以，输出Corrupt 解题思路改一个点即可的充要条件为行和列之中存在且仅有一行与一列的各自的和为奇数。 或者利用邻接矩阵的知识转化为有向图+深度优先搜索？？学姐讲的图论知识，还没有深入学习。]]></content>
      <categories>
        <category>编程</category>
        <category>ACM</category>
      </categories>
      <tags>
        <tag>算法</tag>
        <tag>ACM</tag>
        <tag>2018寒假集训</tag>
        <tag>Imitation</tag>
        <tag>Graph</tag>
        <tag>POJ</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[【POJ-1328】解题报告（二维转一维，贪心）]]></title>
    <url>%2Fpost%2Fcea184b4.html</url>
    <content type="text"><![CDATA[原始题目Radar Installation Time Limit: 1000MS Memory Limit: 10000K Total Submissions: 96097 Accepted: 21364 Problem Description Assume the coasting is an infinite straight line. Land is in one side of coasting, sea in the other. Each small island is a point locating in the sea side. And any radar installation, locating on the coasting, can only cover d distance, so an island in the sea can be covered by a radius installation, if the distance between them is at most d. We use Cartesian coordinate system, defining the coasting is the x-axis. The sea side is above x-axis, and the land side below. Given the position of each island in the sea, and given the distance of the coverage of the radar installation, your task is to write a program to find the minimal number of radar installations to cover all the islands. Note that the position of an island is represented by its x-y coordinates. Figure A Sample Input of Radar Installations InputThe input consists of several test cases. The first line of each case contains two integers $n (1 \le n \le 1000)$ and d, where n is the number of islands in the sea and d is the distance of coverage of the radar installation. This is followed by n lines each containing two integers representing the coordinate of the position of each island. Then a blank line follows to separate the cases. The input is terminated by a line containing pair of zeros OutputFor each test case output one line consisting of the test case number followed by the minimal number of radar installations needed. “-1” installation means no solution for that case. Sample Input3 2 1 2 -3 1 2 1 1 2 0 2 0 0 Sample OutputCase 1: 2 Case 2: 1 SourceBeijing 2002 题目大意给定二维平面N个点的坐标作为小岛坐标，给定雷达辐射半径，求坐标轴上放置雷达的最少个数。 解题思路将小岛在二维平面钟的坐标转化为一维坐标轴上的线段也即数轴上的闭区间。两个闭区间的交集表示可以同时辐射到这两个小岛的雷达可放置的区域。 由此，要使放置雷达的个数最少。将线段按左端点递增排序，采用贪心策略，对于下一个小岛能利用之前的雷达就利用，条件为，下一条线段的左端点小于公用范围（线段）右边界。否则雷达+1，并以该线段作为新雷达的公用范围。 注意：1.共用范围（线段）是不断减小的，后一条线段的有端点大于共用范围右端，则无影响，若小于右端，则新右边界变为该线段的右端点。 解题代码1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465666768697071727374#include &lt;cstdio&gt;#include &lt;cstring&gt;#include &lt;cmath&gt;#include &lt;algorithm&gt;#include &lt;queue&gt;#define maxn 10010using namespace std;struct line&#123; double left; double right;&#125;island[10002];bool cmp(struct line s1,struct line s2)&#123; return s1.left&lt;s2.left;&#125;int main()&#123;// freopen("in.txt", "r", stdin);// freopen("out.txt", "w", stdout); int ni,nd; scanf("%d%d",&amp;ni,&amp;nd); int count=0; while(ni||nd) &#123; bool flag=false; for(int i=0;i&lt;ni;i++) &#123; double x,y; scanf("%lf%lf",&amp;x,&amp;y); if(y&gt;nd) flag=true;// printf("x=%lf y=%lf\n",x,y); island[i].left=x-sqrt(nd*nd-y*y); island[i].right=x+sqrt(nd*nd-y*y); &#125; if(flag) &#123; printf("Case %d: -1\n",++count); scanf("%d%d",&amp;ni,&amp;nd); &#125; else &#123; sort(island,island+ni,cmp);// for(int i=0;i&lt;ni;i++)// printf("island[%d] left=%lf right=%lf\n",i,island[i].left,island[i].right); int num=1; double minright=island[0].right; for(int i=0;i+1&lt;ni;i++) &#123; if(island[i+1].left&lt;=minright) &#123; if(island[i+1].right&lt;minright) &#123; minright=island[i+1].right; &#125; &#125; else &#123; num++;// printf("num++\n"); minright=island[i+1].right; &#125; &#125; printf("Case %d: %d\n",++count,num); scanf("%d%d",&amp;ni,&amp;nd); &#125; &#125;// fclose(stdin);//关闭文件 // fclose(stdout);//关闭文件 return 0;&#125; 收获与反思二维问题转一维，学习一下。]]></content>
      <categories>
        <category>编程</category>
        <category>ACM</category>
      </categories>
      <tags>
        <tag>算法</tag>
        <tag>ACM</tag>
        <tag>2018寒假集训</tag>
        <tag>Greedy</tag>
        <tag>POJ</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[【CodeForces-825B】解题报告（模拟，五子棋）]]></title>
    <url>%2Fpost%2F74479d01.html</url>
    <content type="text"><![CDATA[原始题目B. Five-In-a-Row time limit per test 1 second memory limit per test 256 megabytes input standard input output standard output Alice and Bob play 5-in-a-row game. They have a playing field of size 10 × 10. In turns they put either crosses or noughts, one at a time. Alice puts crosses and Bob puts noughts. In current match they have made some turns and now it’s Alice’s turn. She wonders if she can put cross in such empty cell that she wins immediately. Alice wins if some crosses in the field form line of length not smaller than 5. This line can be horizontal, vertical and diagonal. InputYou are given matrix 10 × 10 (10 lines of 10 characters each) with capital Latin letters ‘X’ being a cross, letters ‘O’ being a nought and ‘.’ being an empty cell. The number of ‘X’ cells is equal to the number of ‘O’ cells and there is at least one of each type. There is at least one empty cell. It is guaranteed that in the current arrangement nobody has still won. OutputPrint ‘YES’ if it’s possible for Alice to win in one turn by putting cross in some empty cell. Otherwise print ‘NO’. ExamplesinputXX.XX..... .....OOOO. .......... .......... .......... .......... .......... .......... .......... .......... outputYES inputXXOXX..... OO.O...... .......... .......... .......... .......... .......... .......... .......... .......... outputNO 题目大意给定一个五子棋棋盘，判断X棋一步之后能否胜利。 解题思路没什么，自己写模拟。遍历每个可下的点判断横竖和斜方向上能否实现大于等于五子相连。 注意边界问题，可以采用左右上下各拓展4行4列。 解题代码123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114#include &lt;cstdio&gt;#include &lt;cstring&gt;#include &lt;cmath&gt;#include &lt;algorithm&gt;#include &lt;queue&gt;#define maxn 10010using namespace std;char map[20][20];bool check(int a,int b)&#123; map[a][b]=1;// printf("begin check %d %d\n",a,b); int conti,i,j; for(conti=0,i=a-4;i&lt;=a+4;i++) //横向判断 &#123; if(map[i][b]==1) &#123; conti++; if(conti&gt;4) return true; &#125; else &#123; conti=0; continue; &#125; &#125; for(conti=0,j=b-4;j&lt;=b+4;j++) //纵向判断 &#123; if(map[a][j]==1) &#123; conti++; if(conti&gt;4) return true; &#125; else &#123; conti=0; continue; &#125; &#125; for(conti=0,i=a-4,j=b-4;i&lt;=a+4;i++,j++) //斜向判断1 &#123; if(map[i][j]==1) &#123; conti++; if(conti&gt;4) return true; &#125; else &#123; conti=0; continue; &#125; &#125; for(conti=0,i=a-4,j=b+4;i&lt;=a+4;i++,j--) //斜向判断1 &#123; if(map[i][j]==1) &#123; conti++; if(conti&gt;4) return true; &#125; else &#123; conti=0; continue; &#125; &#125; map[a][b]=0; return false; &#125;int main()&#123;// freopen("in.txt", "r", stdin);//其实in.txt是可以修改成其他名字的 比如“输入.txt”，都是可以的，这里只是为了方便起见，下同； for(int i=0+4;i&lt;10+4;i++) &#123; scanf("%s",map[i]+4); &#125; for(int i=0+4;i&lt;10+4;i++) &#123; for(int j=0+4;j&lt;10+4;j++) &#123; switch(map[i][j]) &#123; case 'X': map[i][j]=1;break; case 'O': map[i][j]=2;break; case '.': map[i][j]=0;break; &#125;// printf("%d ",map[i][j]); &#125;// printf("\n"); &#125; int flag=0; for(int i=0+4;i&lt;10+4;i++) &#123; for(int j=0+4;j&lt;10+4;j++) &#123; if(map[i][j]||!map[i-1][j]&amp;&amp;!map[i+1][j]&amp;&amp;!map[i][j-1]&amp;&amp;!map[i][j+1]&amp;&amp;!map[i-1][j-1]&amp;&amp;!map[i+1][j+1]&amp;&amp;!map[i-1][j+1]&amp;&amp;!map[i+1][j-1]) continue; else flag=check(i,j); if(flag) &#123;// printf("%d %d \n",i-4,j-4); break; &#125; &#125; if(flag) break; &#125; if(flag) printf("YES\n"); else printf("NO\n");// fclose(stdin);// fclose(stdout); return 0;&#125; 总结与反思模拟的时候要注意细节，尽量不要返工。 能简化的简化（后面会学到剪纸），比如判定周围一圈没有棋子可以直接continue跳过该循环。]]></content>
      <categories>
        <category>编程</category>
        <category>ACM</category>
      </categories>
      <tags>
        <tag>算法</tag>
        <tag>ACM</tag>
        <tag>2018寒假集训</tag>
        <tag>Imitation</tag>
        <tag>CodeForces</tag>
        <tag>Graph</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[【HDU-1027】解题报告（排列STL）]]></title>
    <url>%2Fpost%2Fa4c66bf4.html</url>
    <content type="text"><![CDATA[原始题目Ignatius and the Princess II Time Limit: 2000/1000 MS (Java/Others) Memory Limit: 65536/32768 K (Java/Others) Total Submission(s): 9305 Accepted Submission(s): 5446 Problem Description Now our hero finds the door to the BEelzebub feng5166. He opens the door and finds feng5166 is about to kill our pretty Princess. But now the BEelzebub has to beat our hero first. feng5166 says, “I have three question for you, if you can work them out, I will release the Princess, or you will be my dinner, too.” Ignatius says confidently, “OK, at last, I will save the Princess.” “Now I will show you the first problem.” feng5166 says, “Given a sequence of number 1 to N, we define that 1,2,3…N-1,N is the smallest sequence among all the sequence which can be composed with number 1 to N(each number can be and should be use only once in this problem). So it’s easy to see the second smallest sequence is 1,2,3…N,N-1. Now I will give you two numbers, N and M. You should tell me the Mth smallest sequence which is composed with number 1 to N. It’s easy, isn’t is? Hahahahaha……”Can you help Ignatius to solve this problem? InputThe input contains several test cases. Each test case consists of two numbers, $N$ and $M$ (1 \le N \le 1000, 1 \le M \le 10000). You may assume that there is always a sequence satisfied the BEelzebub’s demand. The input is terminated by the end of file. OutputFor each test case, you only have to output the sequence satisfied the BEelzebub’s demand. When output a sequence, you should print a space between two numbers, but do not output any spaces after the last number. Sample Input6 4 11 8 Sample Output1 2 3 5 6 4 1 2 3 4 5 6 7 9 8 11 10 AuthorIgnatius.L 题目大意定义排列逆序，输出对应编号的排列 解题思路利用C++STL中的next_permutation()函数实现对数组排列，调用m-1次该函数然后按格式输出即可。 解题代码12345678910111213141516171819202122232425262728293031323334#include &lt;iostream&gt; #include &lt;algorithm&gt;#include &lt;string&gt;#include &lt;stack&gt;#include &lt;vector&gt;#define maxn 100010using namespace std;int a[maxn];int main()&#123; int n,m; while(cin&gt;&gt;n&gt;&gt;m)// cin&gt;&gt;n&gt;&gt;m;&#123; for(int i=0;i&lt;n;i++) &#123; a[i]=i+1; &#125;// vector&lt;int&gt; v1(a,a+n); 没有利用上vector 待补充 // vector&lt;int&gt;::iterator p=v1.begin(); int count=m-1; //设置计数器 do //注意使用dowhile &#123;// for(int j=0;j&lt;n;j++)// cout&lt;&lt;a[j]&lt;&lt;" ";// cout&lt;&lt;endl; count--; &#125;while(next_permutation(a,a+n)&amp;&amp;count); for(int j=0;j&lt;n-1;j++) cout&lt;&lt;a[j]&lt;&lt;" "; cout&lt;&lt;a[n-1]&lt;&lt;endl; //输出格式最后一个数后面没有空格 &#125; return 0;&#125; 收获与反思图片待添加]]></content>
      <categories>
        <category>编程</category>
        <category>ACM</category>
      </categories>
      <tags>
        <tag>算法</tag>
        <tag>ACM</tag>
        <tag>2018寒假集训</tag>
        <tag>补图</tag>
        <tag>STL</tag>
        <tag>HDU</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[《乌合之众——群体心理研究》读后感]]></title>
    <url>%2Fpost%2F94c9baee.html</url>
    <content type="text"><![CDATA[内容摘录 P51 影响大众想象力的不是是事实本身，而是他所扩展和传播的方式。 P56 群体的所有信仰都采取宗教形式，对群体来说，必须有个神，否则什么都谈不上。 P92 理性从来就不曾指导过群体，这值得后悔吗？我们不敢这么说。理性把人类带向了文明之路，但缺乏幻觉所激起的那种热情和勇敢。这些幻觉也许是必要的，它们是支配我们的无意识造成的。 P100 第二种领导，意志持久……他们聪明过人，还是智慧有限，这不重要。世界将永远属于他们。他们所拥有的持久意志是一种十分罕见而强大的能力，能战胜一切。 P160 （议会制）它反映了一种心理上错误但被普遍认同的观点，即对某个问题，许多人聚在一起比一小部分人更能做出明智而独立的决定。 P177 随着古老理想的彻底丧失，种族将最终完全失去自己的灵魂，成了一群独处的个人，回到了起点：群体，表现出一切短时间的特征，步调不一，没有前途。文明失去了稳定性，只能随风飘散。民众掌握了至高无上的大权，社会变得越来越野蛮。文明似乎还能辉煌一段时间，因为它扔拥有漫长历史所建的外墙，但那其实是一座已经被虫蛀空的大厦，支撑不了多久，暴风雨一来就会倒塌。从野蛮到文明，一路追逐着梦想，而当这种梦想失去了力量，便开始衰落，走向死亡，这就是一个民族的生命周期。]]></content>
      <categories>
        <category>阅读</category>
      </categories>
      <tags>
        <tag>阅读</tag>
        <tag>社科</tag>
        <tag>古斯塔夫・勒庞</tag>
        <tag>乌合之众</tag>
      </tags>
  </entry>
</search>
