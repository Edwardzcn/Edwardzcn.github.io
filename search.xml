<?xml version="1.0" encoding="utf-8"?>
<search>
  <entry>
    <title><![CDATA[算法与数据结构学习——DP背包问题备课提纲]]></title>
    <url>%2Fpost%2Fbc73800d.html</url>
    <content type="text"><![CDATA[动态规划（DP）简介 Those who cannot remember the past are condemned to repeat it. 什么是动态规划算法 Dynamic programming is both a mathematical optimization method and a computer programming method. The method was developed by Richard Bellman in the 1950s and has found applications in numerous fields, from aerospace engineering to economics. In both contexts it refers to simplifying a complicated problem by breaking it down into simpler sub-problems in a recursive manner. Dynamic programming has evolvd into a major paradigm of algorithm design in computer science. The name was coined in 1957 by Richard Bellman to decribe a type of optimum control problem. 根据前述内容以及余老师 PPT 上的介绍，动态规划（DP）诞生初用于描述一类问题而非描述一种求解方式。不过随着时间演变，现在 DP 更常用来表示一类算法（尤其在 CS 领域）。 核心思想 解决小规模的子问题 将小规模问题的解（解集）储存起来 利用小规模问题解集状态转移至大规模问题的解集状态 最终解（最大规模的 final 解）即为我们所求的最终解 适用条件 There are two key attributes that a problem must have in order for dynamic programming to be applicable: optimal substructure and overlapping sub-problems. 最优子结构（Optimal structure）A problem is said to have optimal substructure if an optimal solution can be constructed efficiently from optimal sulutions to its subprolems. Also is called Principle of Optimality by Bellman. 子问题重叠（Overlapping sub-problems）子问题重叠并不是定义 DP 类型问题的必要条件，但是当子问题出现大规模重叠时，DP 算法更能体现效果，最简单直接的例子：分治思想和 DP 思想求解斐波那契额数列。 随便谈谈与分治法（Divide and Conquer）对比 If a problem can be solved by combining optimal solutions to non-overlapping sub-problems, the strategy is called “divide and conquer” instead.[1] This is why merge sort and quick sort are not classified as dynamic programming problems — Introduction to Algorithms (2nd ed.), MIT Press. 子问题孤立，更适用于分治法，这点出了“Divide and Conquer”与“Dynamic Programming”，两种算法思想的本质不同。此外，求解过程中，分治法倾向于从顶向下递归分解问题然后再递归合成大规模问题的解，而动态规划算法则初始计算小问题的解，根据状态转移方程自底向上计算所求状态的解。 与贪心算法（Greedy）对比贪心算法，对于尚未加入解集的元素按固定策略（最大或最小）选取状态转移，妄图从局部最优达到整体最优，也具有最优子结构性质。 以即将要讨论的 01 背包问题为例，贪心想法是在一次选择中选取未选择物体中价值/重量比最高的。这个局部选择是最优的，但不考虑整体背包选择方案是否最优。而动态优化则要求当前拾取物体从之前状态（减去该物体重量的最优态）转移过来，这样就保证了一定的全局性质。 前向性No backwards: depending on the current state. 下一时刻的状态只与当前状态有关，而和当前状态之前的状态无关，当前的状态是对以往决策的总结，个人理解，这就是Dynamic的体现。 经典 DP 问题：背包问题背包问题相信大家都不陌生，动态规划算法学习过程中不得不提得经典系列问题，而 01 背包问题又是系列问题得基础，在编程实现过程中，我们常会使用空间优化与常数优化来加速程序的执行，在程序设计竞赛中我们关注点在程序的运行结果是否与标程的运行结果是否一致，但对于优化的影响却不甚关心，我记得在自己学习编译原理优化一章时，我的老师常常谈起优化的代价，那么今天后面的时间主要内容便是介绍 DP 算法求解 01 背包问题，优化方法及其代价。 01 背包题目有$N$件物品和一个容量为$V$的背包。放入第$i$件物品耗费的费用是$C_i^1$，得到的价值是$Value_i$。求解将哪些物品装入背包可使价值总和最大。 基本解题思路因为每种物品只有一件，选择只有放（1）、不放（0）两种状态，所以称这类问题为 01 背包问题。 该问题对应的子问题为：前$i$件物品放入背包得到的最大价值。，根据该子问题，我们定义状态$F[i,v]$为前$i$件物品放入限制重量为$v$所能得到的最大价值，然后我们可以想出状态转移方程。 F[i,v] = max \{ F[i-1,v] , F[i-1,v-C_i] + Value_i \}其含义为：逐个拾取编号问题过程中，拾取$i$号且背包限制为$v$重量时（$F[i,v]$），其只由两种状态转移而来，不选择该物体（则状态同相同限重量拾取上个物体时的状态 $F[i-1,v]$），选择该物体（则状态由上次选择时，限重为当下限重减去此次拾取物体重量的状态转移而来$F[i-1,v-C_i]+Value_i$）。 最优子结构性质与无后向性是可证的，见下一节附加内容。 原文特别强调了上述转移方程的重要性，也做了相应的解释： 这个方程非常重要，基本上所有跟背包象关的问题的方程都是由它衍生出来的。所以有必要将它详细解释一下：“将前$i$件物品放入容量为$v$的背包中”这个子问题，若只考虑第$i$件物品的策略（放或不放），那么就可以转化为一个只和前$i-1$件物品相关的问题。如果不放第$i$件物品，那么问题就转化为“前$i-1$件物品放入容量为$v$的背包中”，价值为$F[i-1,v]$；如果放第$i$件物品，那么问题就转化为“前$i-1$件物品放入剩下的容量为$v-C_i$的背包中”，此时能获得的最大价值就是$F[i-1,v-C_i]$再加上通过放入第$i$件物品获得的价值$Value_i$。 伪代码描述： 1234F[0,0..V] ← 0for i ← 1 to n for v ← w[i] to V F[i,v] ← max&#123;F[i-1,v] , F[i-1,v-w[i]]+v[i]&#125; 附加：最优子结构证明学习自博客01 背包存在最优子结构的证明 表述： $n$为背包重量限制，$w[i]$为$i$物体重量，$v[i]$为$i$物体价值，如果$(z_1,z_2 \cdots z_k)$是问题$f_k(n)$的最优解，那么 对于任意$1 \le j \le k$，有$z_j = 1$（确定$j$物体状态为取），则有$(z_1,z_2 \cdots z_{j_1} , z_{j+1} , z_{j+2} \cdots z_k)$是问题$f_{k-1}(n-w[j])+ v[j]$的最优解 对于任意$1 \le j \le k$，有$z_j = 0$（确定$j$物体状态为不取），则有$(z_1,z_2 \cdots z_{j_1} , z_{j+1} , z_{j+2} \cdots z_k)$是问题$f_{k-1}(n)$的最优解。 这里 $i$ 表示子问题的规模，表述为将 $i$ 个物品放入容量为$v$的背包中， 证明（反证法）： 假设子问题不是最优解，对于情况 1，假设存在$(z_1’,z_2’ \cdots z_{j-1}’ , z_{j+1}’ ,\cdots z_k’)$ 是子问题的最优解，那么 $f_k(n)$的最优解将会是$(z_1’,z_2’ \cdots z_{j-1}’ , z_j , z_{j+1}’ \cdots z_k’)$，与假设矛盾。 算法优化与代价空间复杂度优化由于要使用$dp[n][v]$状态空间，如果储存全部状态，根据伪代码思路，该动态优化算法的时间和空间复杂度均为$O(VN)$，汽中时间复杂度应该已经不能再优化了，但空间复杂度却可以优化到$O(V)$。 我们观察状态转移方程 F[i,v] = max \{ F[i-1,v] , F[i-1,v-C_i] + Value_i \}我们每轮计算前$i$个在不同限重背包的最优值时，利用的状态只有$i-1$时的状态，也即上一轮外层循环得到的值，据此我们可以使用一些优化方法。 滚动数组每次都使用固定的几个存储空间，来达到压缩\节省存储空间的目的。主要应用在递推或动态规划中。 代码描述 1234567891011for (i=1 ;i &lt;= n; i++)&#123; for (v = w[i] ; v &lt;= V ; v++) &#123; dp[1][v] = max(dp[0][v],dp[0][v-w[i]]+v[i]); &#125; // 一轮更新结束后统一翻转 for (v = 0; v&lt;=V ; v++)&#123; dp[0][v] = dp[1][v]; &#125;&#125; 当然我们还发现状态转移方程中，只会利用背包限重状态小于等于要更新状态的已知状态，所以我们按逆序（从大到小）遍历内层循环，就可以避免在同一轮外层循环中先更新的影响后更新的值，由此修改滚动数组代码。 123456789for (i=1 ;i &lt;= n; i++)&#123; for (v = V ; v &gt;= w[i] ; v--) &#123; dp[1][v] = max(dp[0][v],dp[0][v-w[i]]+v[i]); dp[0][v] = dp[1][v]; &#125;&#125; 压缩至一维数组那既然逆序已经避免同一轮更新中先更新的影响后更新的值，实际上滚动数组也非必要了。我们使用一维数组便可实现状态转移，并且保证计算$dp[v]$时，$dp[v-w[i]]$保存的是对应二维$dp[i-1][v-w[i]]$的值。 12345678for (i=1 ;i &lt;= n; i++)&#123; for (v = V ; v &gt;= w[i] ; v--) &#123; dp[v] = max(dp[v],dp[v-w[i]]+v[i]); &#125;&#125; 时间复杂度常数优化伪代码中 12for i ← 1 to n for v ← V to w[i] 《背九》原作者给出可以优化为$V \quad to \quad max(V − \sum_i^N C_i, C_i)$。我个人认为可以严格到$V \quad to \quad max(V - \sum_{i+1}^N C_i,C_i)$。 12for i ← 1 to n for v ← V to max(w[i],V-(w[i+1]+...+w[n])) 如何理解这个常数优化？，我们需要回过头来再看看状态转移方程。 F[i,v] = max \{ F[i-1,v] , F[i-1,v-C_i] + Value_i \}我们固定某一限重状态随$i$递增的变化，不妨研究与最终答案相关的，$final(i)= F[i][V]$。我们发现在$i$递增一轮过程中。$final$只会变动一次，且只有两个可能的方向，不变（延续$i$上一轮递增后得到的结果），改变（受$F[i-1][V-w[i]]$影响）。 如果我们将，可以影响$final$的所有限重状态，随$i$减小（逆序），画出来，我们可以发现能够影响到答案（最终状态）的边界是逐渐减小的。 我们可以发现，能够影响$final$的重量状态是有限的，并且随$i$减小，可影响的状态逐渐扩张，最后一次只有$final=dp[n][V]$单一状态影响最终答案（因为它本身就是最终答案），每一轮可能影响到$final$的边界应是，$max(V - \sum_{i+1}^N Value_i,C_i)$，这里可以补充一下，原作者认为是求和下限应为$i$，带入最后$i=N$我们发现在最后一轮除了更新$dp[N]$还更新了其他与最终答案无关的状态，所以我觉得这个更严格的界限是正确的。 反过来想也可以，在计算$dp[v]$时，若某一限重状态最终能够影响$final$，必然要经过几轮$i$递增（理想状态是，$dp[v+w[i+1]$每次都能受到影响），这也提醒我们，某一状态影响最终结果是需要一定时间限制的，在$i$逐渐靠近$n$时，即便我们遇到重量很小但是价值很大的一颗“金子”，我们也不一定需要从它的重量开始更新状态。 举例来讲比如最后三个物体是 12345// n = 10 V = 50// 当前dp[50]=150w[n-2]=2 v[n-2]=100 //金子w[n-1]=5 v[n-1]=40w[n]=3 v[n]=50 此时$w[i] = 2$,$V-sum=42$（按照底为$i+1$的求和）。如果只是为了获得正确的$dp[50]$，我们需要从$v=50$更新到$v=42$就够了呢？还是说要更新到$v=2$，显然，我们更新到$v=42$就够了，即便后面两个物体在最优解中都要取，$dp[42]$会影响下一轮的$dp[47]$，进而影响最终的$dp[50]$。 优化的代价 优化不是无代价的 承上面例子，显然根据常数优化算法，我们最终可以得到正确的$dp[50]$，但我们在想，有没有少些什么？ 很明显啊，在倒数第三轮外层循环我们没有计算新的$dp[2]$（而大概率碰到金子，2 格背包我们应该捡起来啊！），那么不更新的代价是什么呢？ 针对题目，影响最终答案么？ 不影响。 不针对题目，影响答案么？ 影响，因为改变了状态空间解集。 朴素二维动态规划得到的解集$dp[n][V]$储存了（在该遍历序下）任意小于序长度前缀，任意小于最大限制容量的解集。也即在不增删修改物品条件下，后续满足上述条件的任意询问$Q_1$，都可以在$O(1)$的时间给出答案。 一维压缩空间优化得到的解集$dp[V]$储存了长度等于序长，任意小于最大限制容量的解集。同样，不改变物体，对该序询问容量小于限制的背包问题$Q_2$，都可以在$O(1)$的时间给出答案，但是如果想询问前缀问题（而非序长），则不能获得，因为在外层循环迭代中，没有保留这部分结果。 空间优化+常数优化的解集只能保证$dp[i],i=V$单个值是正确的，而其他值均无意义。 这些发现很明显在提醒，如果关注单捷，那么空间+常数优化自然是很好的选择，但是如果数据固定而频繁询问，那么朴素方法或许才是最好的，优化不应该是盲目的，有些优化需要我们理解背后更深的意义及影响，才能更好的应用于我们程序中]]></content>
      <categories>
        <category>编程</category>
        <category>数据结构与算法</category>
      </categories>
      <tags>
        <tag>DP</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[算法与数据结构学习——01背包问题常数优化算法对问题解集的影响]]></title>
    <url>%2Fpost%2F1590e320.html</url>
    <content type="text"><![CDATA[再述 01 背包问题本篇博文使用题目及符号的习惯表达方式均来自于《背包问题九讲》。 背包问题相信大家都不陌生，动态规划算法学习过程中不得不提得经典系列问题，而 01 背包问题又是系列问题得基础，在编程实现过程中，我们常会使用空间优化与常数优化来加速程序的执行，在程序设计竞赛中我们关注点在程序的运行结果是否与标程的运行结果是否一致，但对于优化的影响却不甚关心，我记得在自己学习编译原理优化一章时，徐老师常常谈起优化的代价，今天这篇博文主题便是这个经典问题空间优化与常数优化的影响与代价。 对原题目非常熟悉的请直接跳过前面题目和思路以及优化方法介绍，阅览最后两节内容。 题目有$N$件物品和一个容量为$V$的背包。放入第$i$件物品耗费的费用是$C_i^1$，得到的价值是$Value_i$。求解将哪些物品装入背包可使价值总和最大。 基本解题思路因为每种物品只有一件，选择只有放（1）、不放（0）两种状态，所以称这类问题为 01 背包问题。 该问题对应的子问题为：前$i$件物品放入背包得到的最大价值。，根据该子问题，我们定义状态$F[i,v]$为前$i$件物品放入限制重量为$v$所能得到的最大价值，然后我们可以想出状态转移方程。 F[i,v] = max \{ F[i-1,v] , F[i-1,v-C_i] + Value_i \}其含义为：逐个拾取编号问题过程中，拾取$i$号且背包限制为$v$重量时（$F[i,v]$），其只由两种状态转移而来，不选择该物体（则状态同相同限重量拾取上个物体时的状态 $F[i-1,v]$），选择该物体（则状态由上次选择时，限重为当下限重减去此次拾取物体重量的状态转移而来$F[i-1,v-C_i]+Value_i$）。 最优子结构性质与无后向性是可证的，见下一节附加内容。 原文特别强调了上述转移方程的重要性，也做了相应的解释： 这个方程非常重要，基本上所有跟背包象关的问题的方程都是由它衍生出来的。所以有必要将它详细解释一下：“将前$i$件物品放入容量为$v$的背包中”这个子问题，若只考虑第$i$件物品的策略（放或不放），那么就可以转化为一个只和前$i-1$件物品相关的问题。如果不放第$i$件物品，那么问题就转化为“前$i-1$件物品放入容量为$v$的背包中”，价值为$F[i-1,v]$；如果放第$i$件物品，那么问题就转化为“前$i-1$件物品放入剩下的容量为$v-C_i$的背包中”，此时能获得的最大价值就是$F[i-1,v-C_i]$再加上通过放入第$i$件物品获得的价值$Value_i$。 伪代码描述： 1234F[0,0..V] ← 0for i ← 1 to n for v ← w[i] to V F[i,v] ← max&#123;F[i-1,v] , F[i-1,v-w[i]]+v[i]&#125; 附加：最优子结构证明学习自博客01 背包存在最优子结构的证明 表述： $n$为背包重量限制，$w[i]$为$i$物体重量，$v[i]$为$i$物体价值，如果$(z_1,z_2 \cdots z_k)$是问题$f_k(n)$的最优解，那么 对于任意$1 \le j \le k$，有$z_j = 1$（确定$j$物体状态为取），则有$(z_1,z_2 \cdots z_{j_1} , z_{j+1} , z_{j+2} \cdots z_k)$是问题$f_{k-1}(n-w[j])+ v[j]$的最优解 对于任意$1 \le j \le k$，有$z_j = 0$（确定$j$物体状态为不取），则有$(z_1,z_2 \cdots z_{j_1} , z_{j+1} , z_{j+2} \cdots z_k)$是问题$f_{k-1}(n)$的最优解。 这里 $i$ 表示子问题的规模，表述为将 $i$ 个物品放入容量为$v$的背包中， 证明（反证法）： 假设子问题不是最优解，对于情况 1，假设存在$(z_1’,z_2’ \cdots z_{j-1}’ , z_{j+1}’ ,\cdots z_k’)$ 是子问题的最优解，那么 $f_k(n)$的最优解将会是$(z_1’,z_2’ \cdots z_{j-1}’ , z_j , z_{j+1}’ \cdots z_k’)$，与假设矛盾。 空间复杂度优化由于要使用$dp[n][v]$状态空间，如果储存全部状态，根据伪代码思路，该动态优化算法的时间和空间复杂度均为$O(VN)$，汽中时间复杂度应该已经不能再优化了，但空间复杂度却可以优化到$O(V)$。 我们观察状态转移方程 F[i,v] = max \{ F[i-1,v] , F[i-1,v-C_i] + Value_i \}我们每轮计算前$i$个在不同限重背包的最优值时，利用的状态只有$i-1$时的状态，也即上一轮外层循环得到的值，据此我们可以使用一些优化方法。 滚动数组每次都使用固定的几个存储空间，来达到压缩\节省存储空间的目的。主要应用在递推或动态规划中。 代码描述 1234567891011for (i=1 ;i &lt;= n; i++)&#123; for (v = w[i] ; v &lt;= V ; v++) &#123; dp[1][v] = max(dp[0][v],dp[0][v-w[i]]+v[i]); &#125; // 一轮更新结束后统一翻转 for (v = 0; v&lt;=V ; v++)&#123; dp[0][v] = dp[1][v]; &#125;&#125; 当然我们还发现状态转移方程中，只会利用背包限重状态小于等于要更新状态的已知状态，所以我们按逆序（从大到小）遍历内层循环，就可以避免在同一轮外层循环中先更新的影响后更新的值，由此修改滚动数组代码。 123456789for (i=1 ;i &lt;= n; i++)&#123; for (v = V ; v &gt;= w[i] ; v--) &#123; dp[1][v] = max(dp[0][v],dp[0][v-w[i]]+v[i]); dp[0][v] = dp[1][v]; &#125;&#125; 一维数组那既然逆序已经避免同一轮更新中先更新的影响后更新的值，实际上滚动数组也非必要了。我们使用一维数组便可实现状态转移，并且保证计算$dp[v]$时，$dp[v-w[i]]$保存的是对应二维$dp[i-1][v-w[i]]$的值。 12345678for (i=1 ;i &lt;= n; i++)&#123; for (v = V ; v &gt;= w[i] ; v--) &#123; dp[v] = max(dp[v],dp[v-w[i]]+v[i]); &#125;&#125; 时间复杂度常数优化伪代码中 12for i ← 1 to n for v ← V to w[i] 原作者给出可以优化为$V \quad to \quad max(V − \sum_i^N C_i, C_i)$。我个人认为可以严格到$V \quad to \quad max(V - \sum_{i+1}^N C_i,C_i)$。 12for i ← 1 to n for v ← V to max(w[i],V-(w[i+1]+...+w[n])) 背包九讲中没有对这一优化做阐述，我自己的理解是这样的： 再回过头来看状态转移方程。 F[i,v] = max \{ F[i-1,v] , F[i-1,v-C_i] + Value_i \}我们固定某一限重状态随$i$递增的变化，不妨研究与最终答案相关的，$final(i)= F[i][V]$。我们发现在$i$递增一轮过程中。$final$只会变动一次，且只有两个可能的方向，不变（延续$i$上一轮递增后得到的结果），改变（受$F[i-1][V-w[i]]$影响）。 如果我们将，可以影响$final$的所有限重状态，随$i$减小（逆序），画出来，我们可以发现能够影响到答案（最终状态）的边界是逐渐减小的。 我们可以发现，能够影响$final$的重量状态是有限的，并且随$i$减小，可影响的状态逐渐扩张，最后一次只有$final=dp[n][V]$单一状态影响最终答案（因为它本身就是最终答案），每一轮可能影响到$final$的边界应是，$max(V - \sum_{i+1}^N Value_i,C_i)$，这里可以补充一下，原作者认为是求和下限应为$i$，带入最后$i=N$我们发现在最后一轮除了更新$dp[N]$还更新了其他与最终答案无关的状态，所以我觉得这个更严格的界限是正确的。 反过来想也可以，在计算$dp[v]$时，若某一限重状态最终能够影响$final$，必然要经过几轮$i$递增（理想状态是，$dp[v+w[i+1]$每次都能受到影响），这也提醒我们，某一状态影响最终结果是需要一定时间限制的，在$i$逐渐靠近$n$时，即便我们遇到重量很小但是价值很大的一颗“金子”，我们也不一定需要从它的重量开始更新状态。 举例来讲比如最后三个物体是 12345// n = 10 V = 50// 当前dp[50]=150w[n-2]=2 v[n-2]=100 //金子w[n-1]=5 v[n-1]=40w[n]=3 v[n]=50 此时$w[i] = 2$,$V-sum=42$（按照底为$i+1$的求和）。如果只是为了获得正确的$dp[50]$，我们需要从$v=50$更新到$v=42$就够了呢？还是说要更新到$v=2$，显然，我们更新到$v=42$就够了，即便后面两个物体在最优解中都要取，$dp[42]$会影响下一轮的$dp[47]$，进而影响最终的$dp[50]$。 Special 优化的代价 优化不是无代价的 承上面例子，显然根据常数优化算法，我们最终可以得到正确的$dp[50]$，但我们在想，有没有少些什么？ 很明显啊，在倒数第三轮外层循环我们没有计算新的$dp[2]$（而大概率碰到金子，2 格背包我们应该捡起来啊！），那么不更新的代价是什么呢？ 针对题目，影响最终答案么？ 不影响。 不针对题目，影响答案么？ 影响，因为改变了状态空间解集。 朴素二维动态规划得到的解集$dp[n][V]$储存了（在该遍历序下）任意小于序长度前缀，任意小于最大限制容量的解集。也即在不增删修改物品条件下，后续满足上述条件的任意询问$Q_1$，都可以在$O(1)$的时间给出答案。 一维压缩空间优化得到的解集$dp[V]$储存了长度等于序长，任意小于最大限制容量的解集。同样，不改变物体，对该序询问容量小于限制的背包问题$Q_2$，都可以在$O(1)$的时间给出答案，但是如果想询问前缀问题（而非序长），则不能获得，因为在外层循环迭代中，没有保留这部分结果。 空间优化+常数优化的解集只能保证$dp[i],i=V$单个值是正确的，而其他值均无意义。 这些发现很明显在提醒，如果关注单捷，那么空间+常数优化自然是很好的选择，但是如果数据固定而频繁询问，那么朴素方法或许才是最好的，优化不应该是盲目的，有些优化需要我们理解背后更深的意义及影响，才能更好的应用于我们程序中 本来这篇文章只想讨论这个内容，不过写着写着就补充了许多其他内容（飘了），希望和大家今后继续关注这些不该被忽略的小细节 hh。]]></content>
      <categories>
        <category>编程</category>
        <category>数据结构与算法</category>
      </categories>
      <tags>
        <tag>01背包</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[【洛谷-P2430】解题报告（01背包）]]></title>
    <url>%2Fpost%2Fa65b0def.html</url>
    <content type="text"><![CDATA[原始题目P2430 严酷的训练 题目大意给定时间限制，每道问题耗费的时间以及奖励，求限制时间内最大奖励。 解题思路将时间限制理解为背包容量，题目耗费的时间与其价值为装入背包物体的重量与价值，裸 01 背包问题。 解题代码123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657#include &lt;bits/stdc++.h&gt;using namespace std;typedef long long ll;typedef unsigned long long ull;typedef pair&lt;int, int&gt; pii;typedef vector&lt;int&gt; vi;#define rep(i, a, n) for (int i = a; i &lt; n; ++i)#define per(i, a, n) for (int i = n - 1; i &gt;= a; --i)#define fi first#define se secondconst int maxn = 1e4 + 5;const int maxm = 200;int a, b;int mark[maxn];int m, n, t;int dp[maxn], v[maxn], w[maxn];int main()&#123; ios::sync_with_stdio(false); while (cin &gt;&gt; a &gt;&gt; b) &#123; int tt = b / a; cin &gt;&gt; m &gt;&gt; t; rep(i, 1, t + 1) &#123; cin &gt;&gt; mark[i]; &#125; int sum = 0; w[0] = 0; rep(i, 1, m + 1) &#123; cin &gt;&gt; w[i] &gt;&gt; v[i]; w[i] = mark[w[i]]; w[0] += w[i]; &#125; cin &gt;&gt; n; n /= tt; // cout &lt;&lt; "n= " &lt;&lt; n &lt;&lt; endl; memset(dp, 0, sizeof(dp)); rep(i, 1, m + 1) &#123; sum += w[i]; per(j, max(w[i], n - w[0] + sum), n + 1) &#123; dp[j] = max(dp[j], dp[j - w[i]] + v[i]); &#125; &#125; cout &lt;&lt; dp[n] &lt;&lt; endl; &#125;&#125; 收获与反思回顾此题目时对 0 1 背包的常数优化的原理及代价在另一篇博文中详细讨论]]></content>
      <categories>
        <category>编程</category>
        <category>ACM</category>
      </categories>
      <tags>
        <tag>编程</tag>
        <tag>ACM</tag>
        <tag>2019春季训练</tag>
        <tag>洛谷</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[分布式系统学习——Hadoop初试]]></title>
    <url>%2Fpost%2Fb894091d.html</url>
    <content type="text"></content>
  </entry>
  <entry>
    <title><![CDATA[多媒体原理与系统——音频wave文件]]></title>
    <url>%2Fpost%2F32dcdd6d.html</url>
    <content type="text"><![CDATA[波形音频文件分析波形音频文件概念波形音频文件是存储数字音频样本序列的格式文件，这些样本直接记录了音频的波形，故称为波形音频文件。MIDI、MP3等编码压缩过的音频文件最终都要转化成波形音频文件进行使用播放。 WAVE，使用最广泛，遵循RIFF格式标准。头四个字节是RIFF。WAVE文件由多个chunk组成。 RIFF Wave Chunk部分以RIFF作为开始表示，紧跟着size字段，最后是type字段位‘wave’。size是wav文件减去id和size占用的字节数。File字节-8=size。 Format Chunk部分id补了一个空格，和其他chunk保持一致，都是4字节。 Fact Chunk部分可选字段，当wav文件从一些专用软件转化来时，包含该chunk。包括三部分，id、size、data，都为4字节大小。 Data Chunk部分是真正保存wav数据的地方，以‘data’作为该chunk的标示。然后是数据大小，紧接着就是wav数据。 实操PlaySound函数使用内置，无需调用MF。]]></content>
      <categories>
        <category>多媒体</category>
      </categories>
      <tags>
        <tag>多媒体</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[近期整理的一些问题]]></title>
    <url>%2Fpost%2Fc37f0e45.html</url>
    <content type="text"><![CDATA[问题SJTD IPADS Chinasys 见闻 第一天 session2 的第 6 个报告是来自华中科技大学的工作，相关论文 Mitigating Asymmetric Read and Write Costs in Cuckoo Hashing for Storage Systems 发表在 USENIX ATC’19 上。Cuckoo hash 是一种为了有效解决 hash 冲突，提高空间利用率并且能够在$O(1)$时间内能够进行迅速查找的哈希方式。在插入 x 的时候会计算两个哈希函数，找到两个表中的位置，放到任意一个空的位置。如果两个表中相应的位置都满，那么需要把其中一个位置中的值踢到另一张表中的相应位置，如下图所示。 Cuckoo hash 为什么双哈希函数两表可以有效解决哈希冲突？ 近期整理一些值得看的网站 专业知识 李老师的 Thesis LerGAN 论文 CCF 形式化验证——模型检测 Model Checking 视频 吴恩达——机器学习 NN 密码学同态加密论文 触类旁通 西安交通大学的 LaTeX 讲座讲义 Hexo 文章置顶 Pandoc 命令：pandoc —filter pandoc-citeproc —bibliography=testref.bib —csl=chinese-gb7714-2005-numeric.csl Hello-Hexo.m -o Hello.docx]]></content>
      <categories>
        <category>随笔</category>
      </categories>
      <tags>
        <tag>随笔</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[分布式系统学习——TensorFlow理解]]></title>
    <url>%2Fpost%2F5824281a.html</url>
    <content type="text"></content>
  </entry>
  <entry>
    <title><![CDATA[《文化商人——21世纪的出版业》读后感]]></title>
    <url>%2Fpost%2Fe9133a78.html</url>
    <content type="text"><![CDATA[略读体会以英美出版业为首的英语世界出版业的确与我所了解到的中国出版界大有不同。首先是分工的细化，或许是历史上对知识产权的重视，英美很早就有了著作代理人这样的角色，成为著作人和出版商之间的桥梁，这一角色是书本第二章主要介绍的内容。出版社，集团等概念也充分反映出整个行业的细化，而这些是我从未了解过的（或许也是因为我并不属于这个行业，对中国出版业了解不深） 读完之后顺便咨询了些文新院的同学，毕业以后做编辑，进入出版业的同学有多少？所有人的回答都是，不多。学姐A：“学长学姐以及他们这一届很少去当回复的”，学姐B：“应该有吧，但是我身边没有，实习有一些对口的岗位”，学姐C咨询了一下她的辅导员，回复说：“身边没有，整个年级数量也不多，差不多10来个人吧”。对比整个年级近200人的数量，也是非常小众的一部分人。而同届同学D则回复：“没有了解过，应该有的吧。我们大部分毕业了是去读研，很少是直接工作的。专业内想当老师的偏多，当然想去新媒体或者新闻行业的也有。” 像我所在层级的学校步入这个行业的都很少，也可以从一个侧面反映出我国出版业整体人才吸引力不足。]]></content>
      <categories>
        <category>阅读</category>
      </categories>
      <tags>
        <tag>阅读</tag>
        <tag>出版业</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[机器学习——复习大纲]]></title>
    <url>%2Fpost%2F9626187a.html</url>
    <content type="text"><![CDATA[题型 一定会考的：决策树，神经网络，过拟合，集成学习 ppt 提出的问题会以选择题形式考察 不会考数学推导和证明 必须要带计算器！ 12.31（周二）下午 4-5 点半。B206 Chap1 基本概念基本术语：属性，属性值，属性空间，训练样本，测试样本 监督学习与非监督学习 区别，给出一个问题确定是哪种问题类型。分类和回归，分类和聚类。 标签的问题。 李： ！！线性判别分析，两类现行判别分析，内部方差，中心距离！！如何求判别线 Chap2 线性模型归一化 特征尺度归一化（确保特征在相同的尺度） 范围归一化：使得每个特征尽量接近某个范围，如$0 \le x_i \le 1$ 零均值归一化：用$x_i - \mu_i$替代$x_i$，即$x_i - \mu_i \rightarrow x_i$，其中$\mu_i = \frac{1}{m} \sum_{i=1}^m x_i$ 零均值+范围归一化，如$-0.5 \le x_i \le 0.5$ 零均值单位方差归一化：$\frac{x_i - \mu_i}{\sigma_i} \rightarrow x_i$ 机器学习三要素 模型、策略、算法？ 数据、模型、算法？哪个对 线性模型基本形式f(x) = w^{T}x+b = \theta^T x两种表示，注意前式中带偏秩，但是并不表达在矩阵相乘中。 J(\theta) = \frac{1}{2m} \sum_{i=1}^{m} (h_\theta (x^{(i)}) - y ^{(i)})^2求解损失函数最小值，梯度下降方法为常见方法之一，梯度下降只能达到局部最优，凸函数可以达到全局最优。 什么是线性关系、 一元线性回归，损失函数相关，最小化损失函数。 梯度下降法，梯度的方向。 欠拟合、过拟合。 学习率 怎样确保梯度下降算法正确的执行（收敛性） 自动收敛测试：每次迭代损失函数$J(\theta)$是否减少 收敛条件：定义不再进行迭代的收敛阈值（如$10^{-3}$） 怎样选择学习率$\alpha$ 对于足够小的$\alpha$，$J(\theta)$应该在每一次迭代中减少 如果$\alpha$太小，梯度下降算法则会收敛很慢 如果$\alpha$太大，梯度下降算法则不会收敛：发散或震荡 用户可以以非常低的学习率开始训练模型，在每一次迭代过程中逐渐提高学习率（线性提高或者指数提高都可以），用户可以用这种方法估计出最佳学习率。 改进方法 正规方程（The normal equations） 对于求函数极小值问题，令函数微分为零，然后求解方程（而非每次对梯度递减）可得到解析解 西瓜数 P54 P55 现在使用的梯度下降为批量梯度下降（BGD），每次需要计算所有的样本（1-&gt;m），可以采用随机梯度下降（SGD）（随机选取一个样本，伪梯度下降） 梯度下降的改进方法动量法动量法是一种非常简单的改进方法，已经成功应用数十年。动量法的核心思想是：在梯度方向一致的地方加速，在梯度方向不断改变的地方减速。 在下降初期，使用前一次的大比重下降方向，加速。 在越过函数谷面时，异常的学习率，会使得两次更新方向基本相反，在原地“震荡” 此时，动量因子使得更新幅度减小，协助越过函数谷面。 在下降中后期，函数面局部最小值所在的吸引盆数量较多，一旦陷进吸引盆地当中，梯度趋于零，会导致止步不前，学习无法进行。如果有动量项的话，动量因子使得更新幅度增大，协助跃出吸引盆。 NAM略 Chap3 logistic 回归分类问题，线性模型可以通过设置阈值来达成判别。阈值选择有一点困难，因为线性模型值域 R 太广，逻辑斯特回归则希望预测函数值限制在[0,1]，$0 \le h_{\theta} (x) \le 1$。 Sigmoid 函数的性质g(z) = \frac{1}{1+ e^{-z}}g'(z) = g(z) (1 - g(z))概率解释P(Y = 1 | x) = h_\theta(x) = g(\theta^{T}x) = \frac{1}{1+e^{-\theta^Tx}}输入 $x$ ，输出 $y=1$ 的可能性 物理含义：对比线性模型的平滑过度，logistic 回归在分界值前后变化剧烈，希望达到理想的二值 Sigmoid 的函数，但由于需要合适的损失函数求解 $\theta$ 参数矩阵，没有使用不连续的二值 Sigmoid 函数 损失函数选择回顾凸函数，线性模型带入$h_\theta(x) = \theta^Tx$入平方损失函数$J(\theta) = \frac{1}{2m} \sum_{i=1}^{m} (h_\theta (x^{(i)}) - y ^{(i)})^2$，得到的是凸函数，也可解。 凸函数 等价于 $f’’(x) \ge 0 , \forall x$ 若$x$ 为矢量，则对应的条件变为 Hessian 矩阵$H$为半正定矩阵 严格凸（小于） 对于矢量，则对应条件变为 Hessian 矩阵$H$正定 可以通过极大似然估计$\theta$，见西瓜书 P59 交叉熵损失 为什么选择交叉熵而不选择平方损失，平方损失求导中间多两项，在明确分类的两端下降率接近 0， Chap4 过拟合和正则化过拟合举例 为什么出现过拟合 最小化训练集上的损失（损失错误） 一般而言，模型越复杂（阶数高或特征多），训练得到的模型经验错误越低，但却更容易出现过拟合 选择哪个模型更合适？随机分成两部分：训练集和验证集（Validation Set） 训练误差和验证误差 如何判断是否出现了过拟合或者欠拟合根据曲线判断，bias（偏差）和 variance（方差），会有 trade off（分界分离），选择靠近该分界点的模型，从而减小整体误差。 如何解决过拟合或者欠拟合问题 欠拟合（Large Bias）：增加模型的附加都 收集新的特征 增加多项式组合特征 过拟合（Large Variance） 增加数据（有效但是实践意义不大） 降低模型的复杂度 减小特征：特征选择 正则化（Regularization）：增加偏差 正则化 $\lambda$：正则化参数 问题：思考正则化参数的取值范围 \lambda \sum_{j=1}^{n} \theta_j^2正则化线性回归 正则化 Logistic 回归 模型性能评估 我们用训练集优化参数$\theta^{*} = arg min \frac{1}{m} \sum_{i=1}^{m} l(h_{\theta}(x^{(i)}),y^{(i)})$ 用验证集选择模型 但真正关心的是模型在新的测试数据的性能（泛化能力） 训练集：训练参数 验证集（开发集，Development set）：用于调参（正规化参数、多项式阶数等）、特征选择等 测试集：仅仅用于性能评估 Chap5 神经网络引入原因与神经结构 类比人类的学习方式，The “one learning algorithm” hypotheis。人类的学习行为都是通过神经元结构完成。 神经元模型：Logistic unit 神经网络结构 前向传播 梁: 为什么要引入神经网络 神经网络的结构 会算前向传播和 BP 多分类，softmax，交叉熵 掌握标准激活函数，特点 掌握各种方法更新梯度 为什么不能用 0 初始化权重矩阵 李： 神经网络，损失函数，表达式！ Chap6 SVMMargin 对比 Logistic 回归：在测试新样本时，当$\theta^Tx \gg 0$，或者$\ll 0$，我们可以非常自信地给出预测 按实际训练中我们不能很好的找到一个参数矩阵使得$\theta^Tx \gg 0$，当$y^{i} = 1$时以及相反时候。 重新定义符号 （不要求掌握优化推导和 SMO） 什么是支持向量，margin，分类面 给数据，算方程、画超平面 kernel，可能会有大题 基本概念： 主问题，对偶问题，惩罚因子（分别对应对应 hard/soft SVM 去掌握） 调节 kernel 参数能够防止 SVM 出现过拟合嘛？ 李: 支持向量、怎样求最优超平面 核函数相关。 Chap6.5 决策树信息增益 Shannon 1948 年提出的信息论理论 熵：信息量大小的度量，即表示随机变量不确定性的度量 事件$a_i$的信息量$I(a_i)$可如下度量：$I(a_i) = -p(a_i)\log p(a_i)$ 假设$n$个两两不相容事件$a_1,a_2, \cdots ,a_n$，它们中有且仅有一个发生，则平均的信息量（熵）可以如下度量： $I(a_1, \cdots , a_n) = \sum_i I(a_i) = -\sum_i p(a_i) \log p(a_i)$ 假设当前样本集 D 中第$k$类样本的比例为$p_k$，对应的信息熵为 Ent(D) = - \sum_k p_k \log p_k $Ent(D)$越小。表示数据越有序，纯度越高（一类是 0），分类效果越好 假设某离散属性$a$有$V$个可能值，若采用该属性对样本集划分，则会产生 V 个分支，每个分支节点包含的数据记为$D^v$ 用属性$a$对样本集$D$进行划分，获得的信息增益为： Gain(D,a) = Ent(D) - \sum_v \frac{|D^v|}{D} Ent(D^v) 选择具有最大信息增益的属性来划分： $a^* = arg \quad max_aGain(D,a)$ （ID3 算法） 信息增益比 ID3 算法以信息增益为选择属性，对于取值较多的属性有所偏好（带编号的显然不适合） 信息增益比 Gain\_ratio(D,a) = \frac{Gain(D,a) }{ IV(a)}其中 IV 成为属性的固有值（intrinsic value），属性可取值越多，IV 通常越大。 IV(a) = - \sum_{v=1}^V \frac{|D^v|}{|D|} \log \frac{ |D^v| }{|D|} 增益率准则对可取值数目较少的属性有所偏好 C4.5 并不是直接选择增益率最大的候选划分属性，而是使用了一个启发式算法，先从划分属性中找出信息增益高于平均水平的属性，再从中选择信息增益率最高的属性 a。 基尼指数 数据集的纯度用基尼值来衡量 Gini(D) = \sum_{k=1}^{|y|} \sum_{k' \not ={k}} p_k p_k' = 1 - \sum_{k=1}^{|y|} p_k^2 直观来说，基尼值反映了从数据集$D$中随机抽取两个样本，其类别标记不一致的概率，因此基尼值越小，数据集纯度越高 属性 a 的基尼指数定义为 Gini\_index(D,a) = \sum_{v=1}^{V} \frac{D^v}{D}Gini(D^v) CART vs. ID3 二元划分：二叉树不易产生数据碎片，精确度往往也会高于多叉树 属性选择不同 剪枝决策树的剪枝减少决策树的规模（模型复杂度），是处理“过拟合”的主要手段 前剪枝见西瓜书 P81 给出的方法，将数据集划分为训练集、测试集，每一次选出最优划分属性后，对测试集做划分前后比对，划分后精度下降的禁止划分（图 4.5 图 4.6 以及下面的文字表述）。 预剪枝基于贪心禁止分支展开，带来一定欠拟合的风险。 后剪枝生成完整树后做替换检查，见 P83 连续与缺失值处理连续属性处理 离散化，最简单的是二分法 本质是连续的，但是对于有限采样数据是离散的 对于离散区间中取任意值产生的划分结果相同 对于包含$n-1$个元素的候选划分点集合 T_a = \{ \frac{a^i + a^{i+1}}{2} | 1 \le i \le n-1 \} 即把区间$[a^i,a^{i+1}]$的中位点作为候选划分点 处理时对多属性需要多一轮枚举循环，找到划分后纯度更高的划分点 CART 则将这些划分点当成多离散值处理，见后面。 CART 属性取值离散超过两种的处理 组合的方式转化成多个二取值问题（类似 OvR），取其中划分后 Gini_index，最小的二分情况 Chap7 集成学习 构建多个学习器一起来结合来完成具体地学习任务 也成为多分类器系统 学习器可以是同类型地，也可以是不同类型 通过将多个学习器进行结合，常可获得比单一学习器显著优越地泛化性能，对“弱学习器”尤为明显 理论分析指出：假设各分类器地错误率相互独立，则随着集成个体分类器数目增大，集成的错误率将指数级下降 现实中个体学习器是为解决同一个问题训练出来的，不可能相互独立 如何产生并结合“好而不同”的个体学习器是集成学习研究的核心。 集成学习分类 个体学习器间存在强依赖关系，必须串行生成的序列化方法。代表：Boosting（AdaBoost，Gradient Boosting Machine） 个体学习器间不存在强依赖关系，可同时生成的并行化方法。代表：Bagging 和随机森林（Random Forest） AdaBoost李重点 GBDT略 Bagging 随机森林（Random Forest） 决策融合策略 平均法 加权平均法 投票法 绝对大多数投票（Majority Voting）：超过半数，则决策，否则拒绝 少数服从多数（Plurality Voting）：得票最多的标记 学习法 用各学习器的输出生成新的训练数据，再去训练一个学习器（如线性 SVM 等） Chap8 聚类梁： GMM 不考 k-means 一定考 高斯分布和贝叶斯系列（10’） 李： K-means 以及初始类簇中心点的确认 Chap9 降维 （流形学习不考） PCA/LDA 考其一 Chap10 应用 各种评价指标：精度等，一级二级指标 混淆矩阵 ROC 曲线。Kappa 系数，AUC 值 多分类学习多分类学习的拆解：OvO，OvR，MvM。投票机制，拆解原则。 海明距离、欧式距离。 混淆矩阵，一些指标的计算， 欠拟合的改良方法 贝叶斯回顾概率公式，全概率公式，先验概率、后验概率]]></content>
      <categories>
        <category>机器学习</category>
      </categories>
      <tags>
        <tag>机器学习</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Linux操作系统——Linux复习]]></title>
    <url>%2Fpost%2F68340cec.html</url>
    <content type="text"><![CDATA[Linux 重点复习题选择/填空题 当系统工作负载增加时，CPU 的（用户时间）将占很大比重 fsck 对文件系统的检查最先是从文件系统的（超级块）开始的。 系统交换分区的类型代号是（82） 为了得到外壳程序中命令行输入参数个数，我们可以使用变量（$#） 为了得到所有的命令行输入的参数，我们可以使用变量（$@） Linux 启动的第一个进程 init 启动的第一个第一个脚本程序是（/etc/rc.d/rc.sysinit） LILO 的配置文件是（/etc/lilo.conf） 哪一个命令能用来删除当前目录及其子目录下名为‘core’的文件（find . -name core -exec rm {} \ -） 所谓 LILO（LinuxLoader）是指（一种安装内核加载，开机管理的程序） 分区表示（hd 表示 IDE 硬盘，sd 表示 SCSI 硬盘，a 表示第一块硬盘，1-4 都是主分区） 为了知道谁正在注册到你的机器上可以使用命令（who） 通过文件名存取文件时，文件系统内部的操作过程是通过（文件名在目录中查找对应的 i 节点，通过 i 节点存取文件数据）（补充：创建文件时最后一步， 文件名和 i-节点号之间的对应关系将文件名和文件和文件的内容属性连接起来，找到文件名就找到文件的 i-节点号，通过 i-节点号就能找到文件的属性和内容。） Linux 的核心代码存放于（****/usr/src/linux） 一个进程调用 fork 系统调用后，会有什么结果（‌）（补充：fork 函数将运行着的程序分成 2 个（几乎）完全一样的进程，每个进程都启动一个从代码的同一位置开始执行的线程。这两个进程中的线程继续执行，就像是两个用户同时启动了该应用程序的两个副本。） 文件系统中的（超级块）主要用来记录整个逻辑文件系统的基本管理信息。 通过 Makefile 来安装已编译过的代码的命令是（make install）（补充：configure 是用来生成 Makefile，make 用来编译，make install 用来进行安装）。 （lsmod）命令显示所有装在的模块 下面关于 inode 节点描述错误的是（i 节点和文件名是一一对应的）。（补充：其他正确的说法，i 节点能描述文件占用的块数，i 节点描述了文件大小和指向数据块的指针、通过 i 节点实现稳健的逻辑结构和物理结构的转换。inode 索引节点内容包括：文件的字节数、文件拥有者的 User ID、文件的读 rwx 权限、文件的时间戳、链接数：指多少个文件名指向这个 inode 硬链接会改变、文件数据 block 的位置） “.Z”后缀是（compress）命令压缩的，用（uncompress）解压。 已知 Linux 系统中的唯一一块硬盘是第一个 IDE 接口的 master 设备，该硬盘按顺序有 3 个主分区和 1 个扩展分区，这个扩展分区又划分了 3 个逻辑分区，则该硬盘上的第二个逻辑分区在 Linux 中的设备名称为（/dev/hda6）（补充：在 linux 中第一块硬盘分区为 hda 分区，主分区编号为 hda1-4，逻辑分区从 5 开始。） Redhat Linux 系统中，所有文件系统的挂载信息存放在（/etc/fstab）中。（补充：系统开机时会主动读取/etc/fstab 这个文件中的内容，根据文件里面的配置挂载磁盘。这样我们只需要将磁盘的挂载信息写入这个文件中我们就不需要每次开机启动之后手动进行挂载了。） 系统当前已经加载的所有文件系统在（/etc/mtab）文件中得到反映。（补充：/etc/fstab 开机自动挂载配置文件，在开机时起作用。/etc/mtab 是当前的分区挂载情况，记录的是当前系统已挂载的分区，每次挂载/卸载分区的时候会更新/etc/mtab） 以下哪个运行级别是管理用的单用户模式（1 为单用户模式）（补充：0 为停机模式，6 为重启模式） 如何显示 Linux 系统中注册的用户数（wc- -lines /etc/passwd） 在使用 mkdir 命令创建新的目录时，在其父目录不存在时先创建父目录的选项是（-p） Linux 允许一个文件名有 256 个字符，但为了保证兼容性和可移植性，建议文件名长度控制在（14）个字符以内 比较重要的系统配置资料，一般来说大部分位于（/etc）目录下 大部分主要的 Linux 系统文件是存放在下面的（/bin）目录中 （du）命令用来显示文件盒目录占用的磁盘空间 （df）命令用来显示已安装的文件系统占用的磁盘空间 简答题 简述 Linux 下虚拟文件系统的作用 Linux 通过虚拟文件系统 VFS 将不同文件系统的实现细节隐藏起来，因而从外部看上去，所有的文件系统都是一样的。 VFS 是建在具体文件系统之上的，它为用户程序提供一个统一、抽象、虚拟的文件系统界面。这个抽象的界面主要由一组标准、抽象的文件操作构成，以系统调用的形式提供给用户程序。所以 VFS 必须管理所有同时安装的文件系统。它通过使用描述整个 VFS 的数据结构和描述实际安装的文件系统的数据结构来管理这些不同的文件系统。 简述 Linux 下软连接和硬连接实现文件共享的区别。 硬链接记录的是目标的 inode，符号链接记录的是目标的 path。硬链接创建的是指向 inode 的指针，成功后，文件的索引数会加一，而软链接就像快捷方式，并不会导致该变化。符号链接可以跨分区 link，而硬链接由于 inode 的缘故，只能在本分区中做 link，所以符号链接的使用频率要高得多。 简述 Linux 的用户模式 0： 系统停机（关机）模式，系统默认运行级别不能设置为 0，否则不能正常启动，一开机就自动关机。 1: 单用户模式，root 权限，用于系统维护，禁止远程登陆，就像 Windows 下的安全模式登录。 2: 多用户模式，没有 NFS 网络支持。 3: 完整的多用户文本模式，有 NFS，登陆后进入控制台命令行模式。 4: 系统未使用，保留一般不用，在一些特殊情况下可以用它来做一些事情。例如在笔记本电脑的电池用尽时，可以切换到这个模式来做一些设置。 5: 图形化模式，登陆后进入图形 GUI 模式或 GNOME、KDE 图形化界面，如 X Window 系统。 6: 重启模式，默认运行级别不能设为 6，否则不能正常启动，就会一直开机重启开机重启。 简述动态优先级多级反馈循环调度算法思想及优缺点 简述: 动态优先级是指系统根据优先级 Priority 顺序分配时间片，但优先级会随着进程运行改变。 系统先计算每个进程的一个优先权，该优先权反映了一个进程获取 CPU 使用权的资格 系统从处于就绪队列（状态）的进程中选择优先权最高的进程，分配时间片进入运行态。 运行过程中，优先权随时间递减。 进程时间片结束或进程运行完毕，系统动态完成一次对当前进程优先级的计算 再次进行进程调度，从处于就绪队列（状态）的进程中在选出最高优先级的进程，设置调度标志。 把那些被抢夺了占有权的进程反馈大优先级队列中，等待下一轮调度（对于抢占式而言） 优点: 相较于固定优先级，减少了对低优先级的歧视，更有可能被调度。 缺点：对于高优先级的实时任务随着 CPU 占用时间增大优先级降低，对紧急任务不能保证率先完成。 Linux 进程间通信主要有哪几种形式 最常用的方式是信号、管道以及 UNIX 系统支持的 System Ⅴ IPC 机制（即消息通信、共享数据段和信号量） 管道（Pipe）：管道可用于具有亲缘关系进程间的通信，允许一个进程和另一个与它有共同祖先的进程之间进行通信。 命名管道（named pipe）:命名管道克服了管道没有名字的限制，因此，除具有管道所具有的功能外，它还允许无亲缘关系进程间的通信。命名管道在文件系统中有对应的文件名。命名管道通过命令 mkfifo 或系统调用 mkfifo 来创建 信号（Signal）：信号是比较复杂的通信方式，用于通知接受进程有某种事件发生，除了用于进程间通信外，进程还可以发送信号给进程本身；linux 除了支持 Unix 早期信号语义函数 sigal 外，还支持语义符合 Posix.1 标准的信号函数 sigaction(实际上，该函数是基于 BSD 的，BSD 为了实现可靠信号机制，又能够统一对外接口，用 sigaction 函数重新实现了 signal 函数). 消息（Message）队列：消息队列是消息的链接表，包括 Posix 消息队列 System V 消息队列。有足够权限的进程可以向队列中添加消息，被赋予读权限的进程则可以读走队列中的消息。消息队列克服了信号承载信息量少，管道只能承载无格式字节流以及缓冲区大小受限等缺点。 共享内存：使得多个进程可以访问同一块内存空间，是最快的可用 IPC 形式。是针对其他通信机制运行效率低而设计的。往往与其他通信机制，如信号量结合使用，来达到进程间的同步互斥。 信号量（semaphore）：主要作为进程间以及同一个进程不同线程之间的同步手段。 套接字（Socket）：更为一般的进程间通信机制，可用于不同机器之间的进程间通信。起初是由 Unix 系统的 BSD 分支开发出来的，但现在一般可以移植到其它类 Unix 系统上：Linux 和 System V 的变种都支持套接字。 简要说明面向连接和无连接两种网间进程通信方式的主要区别。 面向连接的协议，再正式手法数据前，双方必须建立可靠的连接。连接的建立要经历三次“握手”才能建立起来，建立后通信比较稳定。 面向非连接的协议，不与对方建立连接，而是直接就把数据包发送过去。 程序设计题 定时任务 定时任务中的时间的说明，时间的格式大概是这样的* * * * * 五个 *号代表的意思分别是分，时，日，月，周的顺序来排列的 如果想每分钟都执行一次的话就采用默认的 * * * * *，如果想每五分钟执行一次可以 */5 * * * * ，如果是每两个小时执行一次的话那就是 * */2 * * *来设置; /n 表示每 n-m 表示区间 解决方案： crontab -e ，输入 i 添加新的定时任务。]]></content>
      <categories>
        <category>Linux</category>
      </categories>
      <tags>
        <tag>Linux</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[数字图像处理——章节总复习]]></title>
    <url>%2Fpost%2F572ecb4f.html</url>
    <content type="text"><![CDATA[数字图像基础对应梁老师课件第二章，着重掌握基本概念。 图像的获取略 图像的采样与量化 大多数传感器的输出是连续电压波形 为了产生一幅数字图像，需要把连续的感知数据转化为数字形式 这包括两种处理：采样和量化 采样 图像空间坐标的数字化（离散化） 决定了图像的空间分辨率 行采样像素$M$个，列采样$N$个构成$M \times N$的实数矩阵 为编程方便采用矩阵坐标系 量化 图像像素灰度值的数字化（离散化） 从模拟量到数字量（离散量） 决定了图像的幅度（灰度级）分辨率 采样点数和量化级数的关系对一幅图像，当量化级数一定时，采样点数对图像质量有着显著的影响。采样点数越多，图像质量越好； 当采样点数减少时，图上的块状效应就逐渐明显。 同理，当图像的采样点数一定时，采用不同量化级数的图像质量也不一样。量化级数越多，图像质量越好，当量化级数越少时，图像质量越差，量化级数最小的极端情况就是二值图像，图像出现假轮廓。 像素间基本关系通路 距离 主要区分$D_e$欧式距离，$D_4$距离和$D_8$距离。 图像类型 二值图像(Binary images) 二值图像也叫黑白图像，编程实现中就指是图像象素只存在 0,1 两个值的逻辑数组。 亮度图像(Intensity images) 亮度图像是包含亮度级的图像，如 64 级，256 级等。 如当亮度图像像素用 unit8 或 unit16 表示时，每个像素的整数取值范围分别是[0,255]和[0,65535]。 如当亮度图像像素用 double 表示时，则像素的取值为浮点数，规定双精度归一化亮度图像的取值范围为[0,1]。 索引图像(Indexed images) 索引图像把像素值直接作为索引颜色的序号。 根据索引颜色的序号就可以找到该像素的实际颜色。 当把索引图像读入计算机时，索引颜色将被存储到调色板中。 RGB 图像(RGB images) 一副 RGB 图像就是彩色像素的一个 M×N×3 数组，其中每一个彩色像素点都是在特定空间位置的彩色图像对应的红、绿、蓝三个分量。也可视为由三幅灰度图像形成的“堆”。 这类图像不使用单独的调色板，每一个像素的颜色由存储在相应位置的红，绿，蓝颜色分量共同决定。 RGB 图像是 24 位图像，红绿蓝分量分别占用 8 位，理论上可以包含 16M 种不同的颜色。 空间域图像处理对应梁老师课件第三章，王老师第二、三、四单元。着重掌握二值化，gamma 矫正，直方图均衡/匹配。 点运算空间域增强：$g(x,y) = T [ f(x,y )]$ 若将邻域限制为$1 \times 1$，则可简化为$s=T(r)$即点运算。 点运算将输入图象映射为输出图象，输出图象每个象素点的灰度值仅由对应的输入象素点的值决定。 常用于改变图象的灰度范围及分布 也称为对比度增强、对比度拉伸或灰度变换； 点运算可以是线性的，也可以是平方的,对数的,或其它任意单调函数的灰度变换； 点运算可以利用一个 LUT（Look-up table）容易实现（或在彩色至少 R、G、B 三个 LUT）。 基本的变换 图像反转 $s = L-1-r$ 对数运算 $s = c \log(1+r)$ 有时原图的动态范围太大，超出某些显示设备的允许动态范围，如直接使用原图，则一部分细节可能丢失。 解决办法是对原图进行灰度压缩，如对数变换 幂次变换 $s = cr^\gamma$ $\gamma=1$等幂变换与原图像相同。 $\gamma&gt;1$用于过亮图像变暗。 $\gamma&lt;1$用于过暗图像变亮。 伽马矫正 对比拉伸 单调增函数保证灰度值变化保序。 将需要提升差值的部分拉大灰度值极差从而达到提高对比度的效果。 灰度切割 提高图像中特定灰度范围的亮度 位图切割 gamma 矫正和二值化的代码实现 gamma 矫正 1234567891011121314151617181920 # 建表以后LUTdef GammaTable(gamma): invGamma = 1.0 / gamma table = np.array([((i / 255.0) ** invGamma) * 255 for i in np.arange(0, 256)]).astype("uint8") return tabledef LUT(image , lutTable): # image: grayscale or RGB color image # luTable: [255,] 1D numpy array mapping 0-255 values to ohter values lut = lambda x: lutTable[x] return lut(image) # 直接伽马函数映射def DirectGammaFunc(image,gamma): invGamma = 1.0/gamma fuc = lambda x: ((x/255.0)**invGamma)*255 return fuc(image).astype("uint8") # R为单通道灰度图 # 调用 R_crrt = LUT(R,GammaTable(1.5)) R_crrt = DirectGammaFunc(R,1.5) 二值化（三种写法，见注释） 123456789101112131415161718192021222324252627282930313233# 朴素循环def ImThresh(im, minv, maxv): BinImg = np.zeros(im.shape, dtype=im.dtype) for i in range(im.shape[0]): for j in range(im.shape[1]): if im[i,j]&gt;=minv and im[i,j]&lt;=maxv: BinImg[i,j]=1 else: BinImg[i,j]=0 return BinImg# 向量运算def ImThreshv2(image, minv, maxv): assert(len(image.shape)==2) # 二值逻辑 group1 = image &gt;= minv group2 = image &lt;= maxv # 与操作 即要求满足 像素值&gt;=minv 又要 &lt;=maxv return (group1*group2).astype(np.uint8)# 杰哥的写法（也是向量运算）def ImThreshv3(image, minv, maxv): assert(len(image.shape)==2) # 只是这里用的非逻辑值，数字化为0，1（uint8类型） newimg = np.copy(image) newimg[newimg &gt; maxv] = 0 newimg[newimg &lt; minv] = 0 newimg[newimg != 0] = 1 return newimg.astype(np.uint8)# 调用Threshimg = Imthresh(R,120,256)Threshimg2 = Imthreshv2(R,120,256) 直方图均衡直方图 定义：将所收集的测定值或数据之全距分为几个相等的区间作为横轴,并将各区间内之测定值所出现次数累积而成的面积,用柱子排起来的图形； 表示图像中具有某种属性（如灰度、颜色等）的像素的个数,反映了图像中每种属性级出现的频率,是图像的基本统计特征之一。 均衡 直方图均衡化是通过灰度变换将一幅图象转换为另一幅具有均衡直方图，即在每个灰度级上都具有相同（离散情况下是相近）的象素点数的过程。这样就增加了像素灰度值的动态范围，从而达到增强图像整体对比度的效果 使用的方法是灰度级变换：$s = T(r)$ 为什么概率累计曲线可以用来实现直方图均衡化的效果概率论基础（问题基础）根据课本 P74 页，$p_r(r)$和$p_s(s)$分别表示随机变量$r$和$s$的概率密度函数，概率论的一个基本结果是，如果$p_r(r)$和$T(r)$已知且$s = T(r)$具备单调性，在感兴趣的值域上是连续且可微的，则变换后的变量$s$的概率密度函数可由下面的简单公式得到： p_s(s) = p_r(r) \left| \frac{\mathrm{d}r}{\mathrm{d}s} \right|这个式子怎么推导的呢？实际上我们就是在求一个随机变量函数的概率分布，概率论是学过的，这里回忆一下给出推导。 设$r$为随机变量，其概率分布符合$p_r(r)$，另有一单调的函数（变换）$s = T(r)$，现在求$s$的概率分布，设$r$值域均为$[0,L-1]$。 由分布函数公式 F(x) = \int_{0}^{x} p(m) \mathrm{d}m得$r$得分布函数 F_r(r) = \int_{0}^{r} p_r(m) \mathrm{d}m又因为$s = T(r)$为单调函数，存在反函数$r = T^{-1}(s)$ F_s(s) = F_r(T^{-1}(s)) = \int_{0}^{ T^{-1}(s) } p_r(m) \mathrm{d}m概率密度函数为分布函数的导数 p_s(s) = \left| \frac{\mathrm{d} F_s(s)}{\mathrm{d}s} \right|应用链式求导法则 p_s(s) = \left| \frac{\mathrm{d}F_s(s)}{\mathrm{d}s} \right|p_s(s) = \frac{\mathrm{d}F_r(r)}{\mathrm{d}r} \left| \frac{ \mathrm{d} r}{ \mathrm{d}s} \right|p_s(s) = p_r(r) \left| \frac{ \mathrm{d} r}{ \mathrm{d}s} \right|则得到了书本上的公式。 均衡变换（回答问题）问题即为，为何任何随机变量的概率分布函数，若变换为累积分布函数，则变换后的随机变量的概率分布为均匀分布？这实际上是累积分布函数的一个特殊的性质，下面给出证明。 若$T(r)$恰为$r$的分布函数，则 s = T(r) = \int_{0}^{r} p_r(m) \mathrm{d}m\frac{\mathrm{d}s}{\mathrm{d}r} = p_r(r)p_s(s) = p_r(r) \left| \frac{ \mathrm{d} r}{ \mathrm{d}s} \right| = p_r(r) \frac{1}{p_r(r)} = 1则$s$为均匀分布$s \in [0,1]$ 且$p_s(s)$值恒为$1$ 若$T(r)$为$r$分布函数映射到$[0,L-1]$，则 s = T(r) = (L-1) \int_{0}^{r} p_r(m) \mathrm{d}mp_s(s) = p_r(r) \frac{1}{(L-1) p_r(r)} = \frac{1}{L-1}则$s$为均匀分布，且$p_s(s)=\frac{1}{L-1}$ 这便是我们想要的函数变换，无论$p_r(r)$分布如何，经过这种类分布函数的函数变换，得到的$p_s(s)$就是一个均匀分布。 直方图均衡化代码实现1234567891011121314151617181920212223242526272829303132333435def CaculateHistogram(input_image): # 参数1. 图像 # 输出1. 总像素值 # 输出2. 灰度值分布计数 # 输出3. 灰度值分布前缀和（用来做后续直方图平局奴化） # 区分单通道还是三通道图像 if len(np.shape(input_image)) == 3: height,width,level = np.shape(input_image) summ = height*width*level else : height,width = np.shape(input_image) summ = height*width caculate_num,index_x = np.histogram(input_image,np.arange(0,256)) caculate_num = np.append(caculate_num,1) # 前缀和 sum_num = np.copy(caculate_num) for i in range(1,256): sum_num[i] = sum_num[i-1] + sum_num[i] return summ,caculate_num,sum_num# 计算直方图数组def cumsum(img, bins): histogram = np.zeros(bins) for pixel in np.arange(0, bins, 1): # 向量化计算像素值为piexel的像素数量 histogram[pixel] += len(img[img==pixel]) return histogram# 直方图均衡接口函数，利用了LUTdef HistogramEqualizationLUT(input_image): size,data,data_sum = CaculateHistogram(input_image) fxy = lambda x: (255*data_sum[x])//size table = np.array([fxy(i) for i in range(256)]) lut = lambda x: table[x] return lut(input_image),table 直方图匹配方法：求两图均衡化，有逆函数存在，可实现匹配。 证明我们易知$s$服从均匀分布，我们寻找一个$z$随机变量符合另一特殊分布$p_z(z)$，易知存在一函数（变换）： s = G(z) = (L-1) \int_{0}^{z} p_z(m) \mathrm{d}m由于$G(z)$为累积分布函数，单调，故存在反函数$G^{-1}(z)$，则有新变换 $N = G^{-1} \cdot T$，使得$r$随机变量经$N$变换后符合$z$的分布特征。 z = G^{-1}(s) = G^{-1}(T(r)) = N(r)由此，我们找到了某值域内求从某一分布随机变量$r$变换到指定分布随机变量$z$的方法。 空间域滤波基础书本 P93 页有详细概念。 平滑和锐化公式太多就贴 PPT 了 梯度算子 添加噪声代码实现注意椒盐 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152# 参考资料上的def noisy(noise_typ,image): if noise_typ == "gauss": row,col,ch= image.shape mean = 0 var = 0.1 sigma = var**0.5 gauss = np.random.normal(mean,sigma,(row,col,ch)) gauss = gauss.reshape(row,col,ch) noisy = image + gauss return noisy elif noise_typ == "s&amp;p": row,col,ch = image.shape s_vs_p = 0.5 amount = 0.004 out = np.copy(image) # Salt mode num_salt = np.ceil(amount * image.size * s_vs_p) coords = [np.random.randint(0, i - 1, int(num_salt)) for i in image.shape] out[coords] = 1 # Pepper mode num_pepper = np.ceil(amount* image.size * (1. - s_vs_p)) coords = [np.random.randint(0, i - 1, int(num_pepper)) for i in image.shape] out[coords] = 0 return out elif noise_typ == "poisson": vals = len(np.unique(image)) vals = 2 ** np.ceil(np.log2(vals)) noisy = np.random.poisson(image * vals) / float(vals) return noisy elif noise_typ =="speckle": row,col,ch = image.shape gauss = np.random.randn(row,col,ch) gauss = gauss.reshape(row,col,ch) noisy = image + image * gauss return noisy# 自己写的# 生成随机椒盐噪点def MakeNoise(input_image,number_of_noise=1000): res_image = np.copy(input_image) row,column = np.shape(input_image)# 还可以加对三通道的特判 for i in range(number_of_noise): x = np.random.randint(0,row) y = np.random.randint(0,column) borw = np.random.randint(0,2) if borw == 0: res_image[x][y] = 0 else: res_image[x][y] = 255 return res_image 均值滤波代码实现1234567891011121314def Smooth(input_image,kernal_size = 3): ans = input_image.copy() border = np.uint8(kernal_size/2) # 根据核大小扩充边界 addBorder = cv2.copyMakeBorder(input_image,border,border,border,border,cv2.BORDER_REFLECT_101) filWin = np.ones((kernal_size,kernal_size),dtype=np.int64) row,column = np.shape(addBorder) for i in range(border,row-border): for j in range(border,column-border): # 以图像i,j为中心，大小为2border+1的区域 temp = addBorder[i-border:i+border+1,j-border:j+border+1] temp_sum = np.sum(temp*filWin) ans[i-border][j-border] = temp_sum/(kernal_size**2) return ans Laplace 锐化滤波代码实现1234567891011121314151617181920212223242526def Laplace(input_image,lap_template): x,y = np.shape(lap_template) if(x!=y): print("Shape of Laplace template wrong!") pass print("The Laplace template is: ") print(lap_template) border = x//2 ans = np.zeros(np.shape(input_image), dtype = np.int64) # 扩充边界 addBorder = cv2.copyMakeBorder(input_image,border,border,border,border,cv2.BORDER_REFLECT_101) row,column = np.shape(addBorder) for i in range(border,row-border): for j in range(border,column-border): ans[i-border][j-border] = np.sum(lap_template*addBorder[i-border:i+border+1 , j-border: j+border+1]) return ans# Laplace 常用算子 [[-1,-1,-1],[-1,8,-1],[-1,-1,-1]]laplace_template_4 = np.array([[0,-1,0],[-1,4,-1],[0,-1,0]])laplace_template_8 = np.array([[-1,-1,-1],[-1,8,-1],[-1,-1,-1]])lap_img_4 = Laplace(im,laplace_template_4) 频率域图像处理频率域分析基础这次课，我们首次接触了“频率域分析”方法。我们从高数中学习过的“无穷级数”概念切入，讲到基于三角函数的傅里叶级数。其中的关键思路是：任意周期函数都可以用傅里叶级数展开，而傅里叶级数的基函数是频率各异的三角函数；也就是说任意周期函数都可以用一组频率各异的三角函数的线性组合来表示。而线性组合系数，即基函数的加权系数，就可以解读为原函数在基函数上的“投影系数”（或坐标，或两者的相似度）。 如果能够求出傅里叶级数中的加权系数，那么就可以实现对原函数的“频域分解”，即原函数主要可以由哪些频率的三角函数叠加而成，也可以解读为原函数主要包含哪些频率的分量。而“频率”对于图像而言是有直观意义的。一般而言，低频成分对应图像中的总体形状和总体色彩和明暗分布；而高频成分对应图像中的细节和边缘信息。如果我们把图像看作是二维函数，并能够将其进行频域分解，那么增强其低频分量就是相当于平滑操作，增强其高频分量就相当于锐化操作。这就是我们除了前几章学习的“空间域分析”方法之外，又多了一个全新的视角和全新的方法。 傅里叶变换就是求解傅里叶级数中的加权系数的方法。其思路很简单，由于加权系数对应原函数与基函数的相似程度，我们可以用两者的离散采样点组成的向量的点积来估计二者的相似程度。因为向量的点积与向量的夹角的余弦成正比，夹角越小代表两个向量越相似，其余弦值就越大。工程上有一种名为“快速傅里叶变换”（FFT）的数值运算方法，可以快速求解傅里叶变换。但对于图像而言，它要求图像的长宽为 2 的整数次幂。 傅里叶逆变换是运用傅里叶级数来重构原函数的方法。其表达式就是傅里叶级数的表达式。有了基函数和加权系数，进行傅里叶逆变换是很直接的。 在工程上，傅里叶变换（FT）一般是对离散数据进行处理的，故名为离散傅里叶变换(DFT)。又因为常用快速傅里叶变换算法来求解，所以常用快速傅里叶变换(FFT)表示，其逆变换为 iFFT。无论是 FFT 还是 iFFT 都有现成的高度优化过的软件包使用，一般不用你自己实现。在 Python 语言中的 Numpy 包中就有相关实现，在 C++语言中也有 OpenCV 包中的对应实现。 我们在讲解了上述原理后，就尝试对一张图像（黑色背景的中央有个白色长方形）进行了傅里叶变换，对变换系数矩阵组成的图像进行了对数化（压缩值的分布，以便看清楚微弱的分布细节），观察了图像的频率域分解效果。然后我们分别演示了基于频率域分析的图像平滑（将 FFT 系数矩阵的边缘区域置零，再逆变换回空间域）和图像锐化（将 FFT 系数矩阵的中央区域置零，再逆变换回空间域，得到边缘图，再与原图进行叠加以便锐化图像）。这部分的演示，请看附件中的代码。 使用 OpenCV 实现 DFTOpenCV 也提供的工具用于实现离散傅里叶变换，分别是cv2.dft()和cv2.idft()函数。返回有两个通道，第一个通道是结果的实部，第二个通道是结果的虚部。所以在计算其幅度的时候需要先手动转化一次。 123456789101112131415161718192021222324252627## Magnitude spectrum## 使用Numpy实现DFT## 进行二维DFT变换f_img1 = np.fft.fft2(img1)## 对换象限fshift_img1 = np.fft.fftshift(f_img1)## 幅度谱 对数化？manitude_img1 = 20*np.log(np.abs(fshift_img1))## img2图像也做相同的处理f_img2 = np.fft.fft2(img2)fshift_img2 = np.fft.fftshift(f_img2)manitude_img2 = 20*np.log(np.abs(fshift_img2))## 使用OpenCV实现DFTf_img3 = cv2.dft(np.float32(img3), flags = cv2.DFT_COMPLEX_OUTPUT)fshift_img3 = np.fft.fftshift(f_img3)# manitude_img3 = 20*np.log(np.abs(fshift_img3))# 手动转化计算magnitudemanitude_img3 = 20*np.log(cv2.magnitude(fshift_img3[:,:,0],fshift_img3[:,:,1])+1e-15)## 使用OpenCV实现DFTf_img4 = cv2.dft(np.float32(img4), flags = cv2.DFT_COMPLEX_OUTPUT)fshift_img4 = np.fft.fftshift(f_img4)manitude_img4 = 20*np.log(cv2.magnitude(fshift_img4[:,:,0],fshift_img4[:,:,1])) 理想滤波器所谓”理想”是指无法通过硬件实现的硬截断 理想低通滤波器 ILPF在圆外“阻断”所有频率，而在圆内无衰减的通过所有频率，这种二维低通滤波器称为理想低通滤波器（ILPF），由下面的函数确定 H_{ILPF}(u,v) = \left \{ \begin{aligned} 1, & D(u,v) \le D_0 \\ 0, & D(u,b) > D_0 \end{aligned} \right.其中$D_0$是一个正常数，$D(u,v)$表示频率域中的点$(u,v)$距离频率域中心$(\frac{P}{2},\frac{Q}{2})$的距离。 理想高通滤波器 IHPF与低通类似，高通是将阈值的圆内“阻断”所有频率，而在圆外无衰减的通过所有频率，描述如下 H_{IHPF}(u,v) = \left \{ \begin{aligned} 0, & D(u,v) \le D_0 \\ 1, & D(u,b) > D_0 \end{aligned} \right.代码实现代码实现低通滤波器并展示其频率域透视图、频率域图像显示、空间域图像显示和径向剖面图。 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061# 获得指定大小的理想滤波器def getIdealMask(mask_shape, filter_d0,hl_type): assert hl_type in ("lpf","hpf") rows,cols = mask_shape[0],mask_shape[1] crow = rows/2 ccol = cols/2 mask = np.zeros((rows,cols)) for i in range(rows): for j in range(cols): dis = sqrt((i-crow)**2 + (j-ccol)**2) if hl_type == "lpf": if dis &lt;= filter_d0: mask[i,j] = 1 else: mask[i,j] = 0 elif hl_type == "hpf": if dis &lt;= filter_d0: mask[i,j] = 0 else: mask[i,j] = 1 return mask# 测试ILPF# 参数设置mask_shape = (100,100)d = 20filter_type = "lpf"# 获得滤波器myfilter = getIdealMask(mask_shape,d,filter_type)# 绘图plt.figure(figsize=(12,12))ax1=plt.subplot(221,projection = "3d")ax2=plt.subplot(222)ax3=plt.subplot(223)ax4=plt.subplot(224)drawPerspective(ax1,myfilter,title = "ILPF Perspective Axes3D", cmap = "gray")# 不想进行列表解析,需要调用frompyfunc构建np可以用的分段函数ufunc1 = np.frompyfunc(lambda x: 0 if (x-d)&gt;0 else 1, 1, 1)drawCurv(ax2,[ufunc1],["ILPF"],d,title = "ILPF Curv")drawPanel(ax3,myfilter,title = "ILPF Frequency Panel Axes2D")spatial_myfilter = frequencyToSpatial(myfilter)drawPanel(ax4,spatial_myfilter,title = "ILPF Spatial Panel Axes2D")plt.show()# 测试IHPFd = 20filter_type = "hpf"myfilter = getIdealMask(mask_shape,d,filter_type)plt.figure(figsize=(12,12))ax1=plt.subplot(221,projection = "3d")ax2=plt.subplot(222)ax3=plt.subplot(223)ax4=plt.subplot(224)drawPerspective(ax1,myfilter,title = "IHPF Perspective Axes3D", cmap = "gray")# 不想进行列表解析,需要调用frompyfunc构建np可以用的分段函数ufunc1 = np.frompyfunc(lambda x: 1 if (x-d)&gt;0 else 0, 1, 1)drawCurv(ax2,[ufunc1],["IHPF"],d,title = "Curv")drawPanel(ax3,myfilter,title = "IHPF Frequency Panel Axes2D")spatial_myfilter = frequencyToSpatial(myfilter)drawPanel(ax4,spatial_myfilter,title = "IHPF Spatial Panel Axes2D")plt.show() 理想低通 ILPF 结果四图 理想高通 IHPF 结果四图 布特沃斯滤波器可通过硬件实现，可以通过阶数进行控制，一些资料中又称之为“巴特沃斯滤波器”。 布特沃斯低通滤波器 BLPF截止频率位于距原点$D_0$的$n$阶布特沃斯滤波器（BLPF）的传递函数定义为： H_{BLPF}(u,v) = \dfrac{1}{ 1 + {[ \dfrac {D(u,v)}{D_0} ]}^{2n} }布特沃斯高通滤波器 BHPF对应的传递函数定义为： H_{BHPF}(u,v) = \dfrac{1}{ 1 + {[ \dfrac {D_0}{D_(u,v)} ]}^{2n} }（分母分子颠倒） 两式中$n$对应了即阶参数，下面的代码给出巴特沃斯滤波器的实现，其频率域透视图、频率域图像显示、空间域图像显示和径向剖面图，曲线图绘制出不同阶下的取值。 代码实现12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364656667686970717273747576777879808182838485# 获得指定大小的布特沃斯滤波器def getButterworthMask(mask_shape,filter_d0,hl_type,butter_n = 1): assert hl_type in ("lpf","hpf") rows,cols = mask_shape[0],mask_shape[1] crow = rows/2 ccol = cols/2 mask = np.zeros((rows,cols)) for i in range(rows): for j in range(cols): dis = sqrt((i-crow)**2 + (j-ccol)**2) if hl_type == "lpf": mask[i,j] = 1.0/(1+(dis/filter_d0)**(2*butter_n)) elif hl_type == "hpf": # 除以0情况特判一下 if np.abs(dis)&lt;eps: mask[i,j] = 0 else: mask[i,j] = 1.0/(1+(filter_d0/dis)**(2*butter_n)) return mask# 测试BLPF# 参数设置mask_shape = (100,100)d = 20filter_type = "lpf"# 获得滤波器myfilter = getButterworthMask(mask_shape,d,filter_type, butter_n=2)# 绘图plt.figure(figsize=(12,12))ax1=plt.subplot(221,projection = "3d")ax2=plt.subplot(222)ax3=plt.subplot(223)ax4=plt.subplot(224)drawPerspective(ax1,myfilter,title = "BLPF(n=2) Perspective Axes3D", cmap = "gray")funcs = []labels = []for i in range(1,6): labels.append("BLPF "+"n="+str(i))funcs.append(lambda x:1.0/(1+(x/d)**(2*1)))funcs.append(lambda x:1.0/(1+(x/d)**(2*2)))funcs.append(lambda x:1.0/(1+(x/d)**(2*3)))funcs.append(lambda x:1.0/(1+(x/d)**(2*4)))funcs.append(lambda x:1.0/(1+(x/d)**(2*5)))drawCurv(ax2,funcs,labels,d,title = "BLPF(n=1,2,3,4,5) Curv")drawPanel(ax3,myfilter,title = "BLPF(n=2) Frequency Panel Axes2D")spatial_myfilter = frequencyToSpatial(myfilter)drawPanel(ax4,spatial_myfilter,title = "BLPF(n=2) Spatial Panel Axes2D")plt.show()# 测试BHPFd = 20filter_type = "hpf"myfilter = getButterworthMask(mask_shape,d,filter_type, butter_n=1)plt.figure(figsize=(12,12))ax1=plt.subplot(221,projection = "3d")ax2=plt.subplot(222)ax3=plt.subplot(223)ax4=plt.subplot(224)drawPerspective(ax1,myfilter,title = "BHPF(n=2) Perspective Axes3D", cmap = "gray")funcs = []labels = []for i in range(1,6):# funcs.append(lambda x:1.0/(1+(d/x)**(2*i)))# ufunc = np.frompyfunc(lambda x: 0 if np.abs(x)&lt;eps else 1.0/(1+(d/x)**(2*i)), 1, 1)# funcs.append(ufunc) labels.append("BHPF "+"n="+str(i))ufunc1 = np.frompyfunc(lambda x: 0 if np.abs(x)&lt;eps else 1.0/(1+(d/x)**(2*1)), 1, 1)ufunc2 = np.frompyfunc(lambda x: 0 if np.abs(x)&lt;eps else 1.0/(1+(d/x)**(2*2)), 1, 1)ufunc3 = np.frompyfunc(lambda x: 0 if np.abs(x)&lt;eps else 1.0/(1+(d/x)**(2*3)), 1, 1)ufunc4 = np.frompyfunc(lambda x: 0 if np.abs(x)&lt;eps else 1.0/(1+(d/x)**(2*4)), 1, 1)ufunc5 = np.frompyfunc(lambda x: 0 if np.abs(x)&lt;eps else 1.0/(1+(d/x)**(2*5)), 1, 1)funcs.append(ufunc1)funcs.append(ufunc2)funcs.append(ufunc3)funcs.append(ufunc4)funcs.append(ufunc5)drawCurv(ax2,funcs,labels,d,title = "BHPF(n=1,2,3,4,5) Curv")drawPanel(ax3,myfilter,title = "BHPF(n=2) Frequency Panel Axes2D")spatial_myfilter = frequencyToSpatial(myfilter)drawPanel(ax4,spatial_myfilter,title = "BHPF(n=2) Spatial Panel Axes2D")plt.show() 布特沃斯低通 BLPF 结果四图 布特沃斯高通 BHPF 结果四图 高斯低通滤波器 GLPF高斯低通滤波器二维形式由下式给处： H_{GLPF}(u,v) = e^{\dfrac{-D^2(u,v)}{2 \sigma^2}}$\sigma$描述了中心的扩散速度，和其他滤波器描述式统一，通过令$\sigma = D_0$，可以用表示其他滤波器的方法表示高斯滤波器。 H_{GLPF}(u,v) = e^{\dfrac{-D^2(u,v)}{2 D_0^2}}高斯高通滤波器 GHPF如下： H_{GHPF}(u,v) =1 - e^{\dfrac{-D^2(u,v)}{2 D_0^2}}代码实现123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051# 获得指定大小的高斯滤波器def getGaussianMask(mask_shape,filter_d0,hl_type): assert hl_type in ("lpf","hpf") rows,cols = mask_shape[0],mask_shape[1] crow = rows/2 ccol = cols/2 mask = np.zeros((rows,cols)) for i in range(rows): for j in range(cols): dis = sqrt((i-crow)**2 + (j-ccol)**2) if hl_type == "hpf": mask[i,j] = 1-np.exp(-(dis**2) / (2*(filter_d0**2))) elif hl_type == "lpf": mask[i,j] = np.exp(-(dis**2)/(2*(filter_d0**2))) return mask# 测试GLPF# 参数设置mask_shape = (200,200)d = 20filter_type = "lpf"# 获得滤波器myfilter = getGaussianMask(mask_shape,d,filter_type)# 绘图plt.figure(figsize=(12,12))ax1=plt.subplot(221,projection = "3d")ax2=plt.subplot(222)ax3=plt.subplot(223)ax4=plt.subplot(224)drawPerspective(ax1,myfilter,title = "GLPF Perspective Axes3D", cmap = "gray")drawCurv(ax2,[lambda x:np.exp(-(x**2)/(2*(d**2)))],["GLPF"],d,title = "GLPF Curv")drawPanel(ax3,myfilter,title = "GLPF Frequency Panel Axes2D")spatial_myfilter = frequencyToSpatial(myfilter)drawPanel(ax4,spatial_myfilter,title = "GLPF Spatial Panel Axes2D")plt.show()# 测试GHPFd = 20filter_type = "hpf"myfilter = getGaussianMask(mask_shape,d,filter_type)plt.figure(figsize=(12,12))ax1=plt.subplot(221,projection = "3d")ax2=plt.subplot(222)ax3=plt.subplot(223)ax4=plt.subplot(224)drawPerspective(ax1,myfilter,title = "GLPF Perspective Axes3D", cmap = "gray")drawCurv(ax2,[lambda x:1-np.exp(-(x**2)/(2*(d**2)))],["GHPF"],d,title = "GLPF Curv")drawPanel(ax3,myfilter,title = "GLPF Frequency Panel Axes2D")spatial_myfilter = frequencyToSpatial(myfilter)drawPanel(ax4,spatial_myfilter,title = "GLPF Spatial Panel Axes2D")plt.show() 高斯低通 GLPF 结果四图 高斯高通 GHPF 结果四图 滤波器对比总结在规定滤波器为 100x100，阈值为 20 时，可以明显观察到，理想滤波器-&gt;高阶布特沃斯滤波器-&gt;低阶布特沃斯滤波器-&gt;高斯滤波器，可以由函数 Curv 看出对应的过渡。 我们同时也发现理想滤波器确实会存在振铃特性，这个将在后面的文章中再做分析学习。 振铃特性理想低通滤波器实验中，我们也可以很明显的发现振铃现象，间隙处原本统一的纹理由于模糊变得有明暗起伏。而随着被滤去的高频内容的数量的减少，图像的纹理变得越来越好，甚至我们仔细看第三幅图，也能发现振铃现象的纹理，课本是这么评价振铃现象和 ILPF 的。 这种振铃现象是理想滤波器的一种特性，从这个例子我们可以清楚地看到，理想低通滤波器并不是非常实用。然而，作为滤波概念发展的一部分，研究这种滤波器的特性非常有用。 振铃现象的一些见解12345678910111213141516171819# 绘制空间域表示图和水平线灰度剖面图for d in d_list: fre_mask=getIdealMask((688,688),d,"lpf") spa_mask=frequencyToSpatial(fre_mask) X = [i for i in range(spa_mask.shape[0])] Y = spa_mask[spa_mask.shape[0]//2] plt.figure(figsize=(8,4)) ax1 = plt.subplot(121) ax2 = plt.subplot(122) ax1.set_title(f"Spatial Img with $D_0 = &#123;d&#125;$") ax2.set_title(f"Grayscale with $D_0 = &#123;d&#125;$") ax1.imshow(spa_mask,cmap = "gray") ax2.plot(X,Y) ax2.spines['left'].set_color('none') ax2.spines['top'].set_color('none') ax2.spines['right'].set_color('none') ax2.set_yticks([]) ax2.set_yticklabels([]) 分别对应了上面的阈值，观察其滤波器的空间与表示，在$D_0$较小的时候有很明显的波动函数形状。 ILPF 的模糊和振铃特性可用卷积定理来解释。由于 ILPF 在频率域的剖面图类似于盒状滤波器，因此可以预料相应空间滤波器具有 sinc 函数形状。空间域滤波可通过$h(x,y)$于图像卷积来实现。讲图像中的每个像素想象为一个离散冲击，它的强度与所在位置的灰度成正比。一个 sinc 函数与一个冲激卷积就是在冲激处复制这个 sinc 函数。sinc 函数的中心波瓣是引起模糊的主因，而外侧较小的波瓣是造成振铃的主要原因。sinc 函数“展开度”与$H(u,v)$半径成反比，所以$D_0$越大，空间 sinc 函数就趋近于一个卷积时不会导致模糊但也不会产生振铃的冲激。 图像去模糊（图像复原）引言前面所接触的图像增强是一个，已知原图像，经处理后，得到增强图像的一个过程，而这一章将要深入的图像复原（重建），则是希望从（被污染）过的图像，经处理后，得到原图像的过程，是以预先确定的目标来改善图像。图像复原试图利用退化现象的某种先验知识来复原被退化的图像。因而，复原技术时面向退化模型的，并且采用相反的过程进行处理，以便恢复出原图像。虽然图像增强和图像复原两者在覆盖的领域和使用的技术栈有所重叠，其中还是有几点区别我们还是要提起注意的。 形象化的描述 图像增强主要是一个主观的过程，而图像复原大部分是一个客观的过程。 已知与未知的区别 图像增强已知原始图像与变换（卷积核或者其频率域的谱），对于增强效果是未知且非预先确定的（只有一个大概方向，比如模糊还是锐化），而图像复原则已知污染图像，且对原始图像是预先确定的（测试条件下甚至是有标准比对的原始图像，是已知的），对于复原变换（污染变换的逆）常常是未知的，这就要求我们在做图像处理时常常需要“估计”我们的复原变换。 期望与探索的区别由于两者已知和未知上的差距，这就导致图像复原通常会涉及设立一个最佳准则来产生期望结果的最佳估计。相比之下，图像增强技术基本上是一个探索性过程，即根据人类视觉系统的生理特点来设计改善图像的方法。 背景知识线性系统可加性，$x_1(t)+x_2(t) = y_1(t)+y_2(t)$，从而有$a \times x_1(t) = a \times y_1(t)$ 平移不变性 卷积卷积、离散二维卷积 从而可以利用卷积这个工具。 冲激响应：输入为一个脉冲信号，输出是一个冲激响应$h(x)$，实际上可以就是之前接触过的卷积核。 图形复原复原 试图利用退化过程的先验知识使已退化的图像恢复本来面目 根据退化的原因，分析引起退化的环境因素 建立相应的数学模型 沿着使图像降质的逆过程回复图像 原因 由于对焦不准导致的图像模糊是很常见的 此时，物体的外观信息并未丢失，而是被分散叠加显示了 如果能够把分散叠加的信息彼此分离，就可能去除模糊 目的 在于消除或减轻退化的影响 方法 由于退化系统是黑盒的，盲复原往往很困难，噪声干扰也为复原过程带来了困难和不确定性 图像复原是寻求在一定优化准则下的原始图象的最有估计。因此，不同的优化准则会获得不同的图像复原。评价指标的选择目前也是研究的方向之一，如峰值信号比等。 图像退化/复原过程模型退化过程（污染过程）的描述：建模为一个退化函数和一个加性噪声项，对于输入图像（原图像）$f(x,y)$进行处理，产生一副退化后的图像$g(x,y)$，图像复原目的就是已知$g(x,y)$的前提下，希望得到原图像的一个估计，这个估计越接近原始输入图像越好。空间域中的退化图像可由下式给出： g(x,y) = h(x,y) \star f(x,y) + \eta(x,y)上式中$h(x,y)$是退化函数的空间表示，由第四章内容，我们可以将上式的模型写成等价的频率域表示： g(u,v) = H(u,v) F(u,v) + N(u,v)这两个式子是本章后面大部分复原内容的基础。 采用频率域滤波图像复原的原因在频率域滤波进行图像复原主要在两个方面效果较好，其一是利用频率域滤波消除周期噪声，另一个是利用频率域做退化函数的逆滤波。 为什么要在频率域做逆滤波？观察之前退化模型的两个式子，我们不难发现： g(x,y) = h(x,y) \star f(x,y) + \eta(x,y) \tag 1g(u,v) = H(u,v) F(u,v) + N(u,v) \tag 2对(1)式空间域来说，想要从$g(x,y)$恢复$f(x,y)$，避不开的是“卷积”的逆运算，这在定义和实现的复杂上都比较困难，而转化到频率域，从(2)式我们或许可以通过一个“除法”来实现逆滤波，结合之前噪声模型相关内容，我们尝试在频率域上对仅退化函数影响的图像，和更复杂一些的，退化函数和加性噪声双重影响的图像进行复原。 逆滤波退化函数已给出，或者由上面退化函数的估计方法获得后，最简单的复原方法是直接做逆滤波，即： \hat{F}(u,v) = \dfrac{G(u,v)}{H(u,v)}然而根据前述我们知道，在噪声的影响下，$\hat{F}(u,v)$和$F(u,v)$仍有差别，即 \hat{F}(u,v) = F(u,v) \dfrac{N(u,v)}{H(u,v)}这个式子两点启发： 知道退化函数也不能完全复原未退化图像，因为噪声函数未知。 如果退化函数是零或是非常小的值，那么噪声影响会被放大 最小均方误差（维纳）滤波实际上维纳滤波是在这里是相对逆滤波来说的，而并非指特别的滤波函数，且不仅应用在运动模糊滤波中。 \hat{F}(u,v) =[\dfrac{1}{H(u,v)} \dfrac{ {|H(u,v)|}^2 }{ {|H(u,v)|}^2+ S_{\eta}(u,v)/S_f(u,v) }] G(u,v)$S_{\eta}(u,v)$为噪声的功率谱而$S_f(u,v)$是未退化图像的功率谱，比值为噪信比。而由于谱${|N(u,v)|}^2$是一个常数，这大大简化了处理。我们常用下面的表达式来近似。 \hat{F}(u,v) =[\dfrac{1}{H(u,v)} \dfrac{ {|H(u,v)|}^2 }{ {|H(u,v)|}^2+ K }] G(u,v)理解与启发： 当频域某处没有噪声时， 𝑁/𝑆 的值为 0，方括号中表达式的值为 1，表示此时不需要对 𝐺/𝐻 修正。（回到逆滤波） 当频域某处噪声大时， 𝑁/𝑆 的值比较大，方括号表达式的值小于 1，相当于对此处 𝐺/𝐻 的值进行抑制，以降低噪声的影响。 实现： 123456789101112131415161718192021def wienerFiltering(input_img, h, NSR ,htype = "frequency"): assert htype in ("frequency","spatial") # 输入图像的傅里叶变换 input_img_fft = np.fft.fft2(input_img) input_img_fft = np.fft.ifftshift(input_img_fft) if(htype == "spatial"): # 模糊化函数的傅里叶变换 h_fft = np.fft.fft2(h) else : h_fft = h # 退化函数模值的平方 h_abs_square = np.abs(h_fft)**2 # 维纳滤波 # 使用的是 共轭/模方+NSR的形式，并非 9 10 式 output_image_fft = np.conj(h_fft) / (h_abs_square + NSR) # 输出图像傅里叶反变换 output_image = np.fft.ifft2(output_image_fft * input_img_fft) output_image = np.abs(np.fft.fftshift(output_image)) return output_image 多重曝光融合 曝光程度对照片质量有影响 不同曝光程度的照片中都包含有用场景信息 成像质量计算 为什么不直接用直方图均衡化来解决过曝光和欠曝光问题过曝光和曝光不足是完全丧失了信息，而多重曝光得到的多幅图像则保留了这部分信息。举曝光不足的例子。比如黑色背景和灰色城堡，在曝光不足的情况下灰度值均为 0，显示为相同的黑色，实际上已经丢失了城堡和背景区分的信息，即便使用直方图均衡，可预知的结果是城堡和背景灰度值增加但是仍保持相同，无法区分两者。所以直方图均衡无法解决此类信息彻底丢失的问题。多重曝光则有多幅原始图像，可以对局部选择信息保留的部分进行融合。过曝光同理 计算问题直接按下式进行加权融合会出现问题 $𝒑=𝒘^′∗𝒑^′+𝒘^{′′}∗𝒑^{′′}+𝒘^{′′′}∗𝒑^{′′′}$ 解决办法 基于原图边缘信息的图像融合 用照片的边缘图把质量系数矩阵中的边缘过滤掉 Laplace 边缘图*成像系数矩阵 基于多尺度边缘信息的图像融合 单个 Laplacian 边缘图只包含图像中某个尺度的边缘信息 所以将图像缩放，计算多尺度的边缘图，进行融合 图像压缩三种冗余P335，编码冗余、空间和时间冗余、不相关信息 一些基本的压缩方法哈夫曼编码、算术编码、LZW 编码（课本 P348-P350） LZW 编码步骤 在词典中搜索与输入字符串的当前位置形成最大匹配的词汇 w； 输出 w 的索引值； 把 wa 输入词典，其中 a 是最大匹配后面的字符 可用字典树加速查询最大匹配 代码实现12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364656667686970717273func (c *Encoder) Circle() &#123; fmt.Println("Start Encode Circle!") for key, char := range c.befComp &#123; outIndex, addflag, _ := c.Digest(char) if addflag == true &#123; c.preString = []byte&#123;&#125; c.preString = append(c.preString, char) c.aftComp = append(c.aftComp, outIndex) if key == len(c.befComp)-1 &#123; c.aftComp = append(c.aftComp, char) &#125; &#125; else &#123; // 在末尾的时候特判 if key == len(c.befComp)-1 &#123; // c.preString = []byte&#123;&#125; c.aftComp = append(c.aftComp, outIndex) &#125; &#125; &#125; // fmt.Println("Test print:") // fmt.Println("before compression: ", c.befComp) // fmt.Println("after compression: ", c.aftComp)&#125;func (c *Encoder) Digest(scanChar byte) (outIndex byte, flag bool, err error) &#123; // 将Pre字符串和扫描的字符组合成为checkString checkString := append(c.preString, scanChar) // 这列可以换成 lastroot 有待改进 nowPtr, isFind := c.FindTreeptr(checkString, c.root) if isFind == true &#123; // 变更pre continue // 不做输出 c.preString = checkString return byte(nowPtr.index), false, nil &#125; else &#123; // 加入新结点 outIndex, err := c.AddTreeptr(nowPtr, scanChar) // 先输出 return outIndex, true, err &#125;&#125;func (c *Encoder) FindTreeptr(leftString []byte, treeRoot *TreeNode) (addptr *TreeNode, flag bool) &#123; tempChar := leftString[0] if treeRoot.childNode[tempChar] != nil &#123; // 已经有节点 if len(leftString) == 1 &#123; // 返回本结点 return treeRoot.childNode[tempChar], true &#125; else &#123; // 递归 return c.FindTreeptr(leftString[1:], treeRoot.childNode[tempChar]) &#125; &#125; else &#123; // 未有节点 // 返回父亲结点（输出过程需要知道index） return treeRoot, false &#125;&#125;func (c *Encoder) AddTreeptr(faptr *TreeNode, addchar byte) (outIndex byte, err error) &#123; outIndex = byte(faptr.index) if c.capacity &gt;= 256 &#123; return outIndex, errors.New("Dictionary Full!") &#125; // 由于获取父结点index需要所以这么操作 faptr.childNode[addchar] = new(TreeNode) faptr.childNode[addchar].index = int(c.capacity) c.capacity++ // c.dict[newIndex] = return outIndex, nil&#125; LZW 解码步骤 解码步骤 初始化词典； 翻译首个索引值为 w，输出 w； 把 w？放入词典，其中？为待定字符； 代码实现1234567891011121314151617181920212223242526272829303132333435363738394041424344func (c *Decoder) Circle() &#123; fmt.Println("Start Decoder Circle!") for _, value := range c.befComp &#123; if len(c.storeString) == 0 &#123; c.aftComp = append(c.aftComp, value) // 第一个 特判 变更storeString c.storeString = append(c.storeString, value) continue &#125; // 其他情况 // (错误)写： aftComp是byte切片 storeString 也是byte切片 // 先从字典获取现在值对应的字符串 lookUpString := c.dict[value] // 加入输出 c.aftComp = append(c.aftComp, []byte(lookUpString)...) // XX? 变成XXX // 把查到的字典加进来 if flag := c.CheckDicFull(); flag == true &#123; continue &#125; else &#123; c.StoreDic(c.storeString, lookUpString) // 将storeString 转化为当前 XX？ c.storeString = []byte(lookUpString) &#125; &#125;&#125;func (c *Decoder) CheckDicFull() (flag bool) &#123; if len(c.dict) == 256 &#123; return true &#125; return false&#125;func (c *Decoder) StoreDic(original []byte, prefix string) &#123; // 原始+这次扫描的第一个byte（） newcontent := append(original, prefix[0]) length := len(c.dict) fmt.Println(length, string(newcontent)) c.dict[byte(length)] = string(newcontent)&#125; 阶段总结 行程编码是利用数据的稀疏分布特点进行编码 词典编码是根据词典将输入字符转换为对应词条的索引输出 LZW 方法在编码时根据输入的字符串动态生成词典 LZW 方法在解码时根据编码值和待定字符法进行词典的复原 LZ77 编码图解 搜索缓存区远大于编码缓存区(32KB v.s. 258 Bytes) 成块地读取字符以减轻 I/O 负担 编码完成后采用哈夫曼法对三元组进行再编码 编码质量一般优于 LZW 法 LZW 法的词典中存在没有使用的词汇 在 LZW 法中已经扫描过的字符不能重组为词汇 应用非常广泛(zip, rar, gzip, png, arj) 阶段总结 LZ77 是隐式词典法 LZ77 存储隐式词典增大后，编码效率降低的问题 窗口 LZ77 编码法同时限制隐式词典的大小和搜索缓冲区的大小，进而保证编码效率 LZ77 法的编码值是三元组，具有不随着词典增大而增大的优点 窗口 LZ77 编码的三元组定义具有特殊性 其他课件内容DCT 相关 常见压缩思路 二值图像压缩思路：行程编码 灰度值图像压缩思路： 设置阈值转换为 n 幅二值图像，分别用游程编码压缩 用预测编码法，降低图像的信息熵，如简单的 yt+1=yt 变换编码法（如离散余弦变换 DCT） 真彩色图像的压缩思路：RGB 分为三幅灰度图像转灰度图像压缩。 常见图片压缩格式实现思路 图像形态学概述 形态学一般指生物学中研究动物和植物结构的一个分支 用数学形态学（也称图像代数）表示以形态为基础对图像进行分析的数学工具 基本思想是用具有一定形态的结构元素去度量和提取图像中的对应形状以达到对图像分析和识别的目的 形态学图像处理的数学基础和所用语言是集合论 形态学图像处理的应用可以简化图像数据，保持它们基本的形状特性，并除去不相干的结构 形态学图像处理的主要运算有 4 个：膨胀、腐蚀、开操作和闭操作 四种运算 开操作的 3 条性质 AoB 是 A 的子集合 如果 C 是 D 的子集，则 CoB 是 DoB 的子集 (AoB)oB= AoB 闭操作的 3 条性质 A 是 A•B 的子集合 如果 C 是 D 的子集，则 C•B 是 D•B 的子集 (A•B)•B= A•B 形态学主要应用边界提取：B 先对 A 腐蚀，A 减去腐蚀得到边界 区域填充： 联通分量提取 图像分割概述分割的目的：将图像划分为不同区域。 三大类方法： 根据区域间灰度不连续搜寻区域之间的边界，在间断检测、边缘连接和边界检测介绍 以像素性质的分布进行阈值处理，在阈值处理介绍 直接搜寻区域进行分割，在基于区域的分割中介绍 Q&amp;A：多尺度的边缘检测仍然需要选择确定的尺度，不能智能辨识。 间断检测类型点检测、线检测、边缘检测 差分、数值微分：$\partial$ 一阶对应线检测、二阶对应点检测 间断检测：拉普拉斯算子∇^2f ＝4z_5 - (z_2 + z_4 + z_6 + z_8)∇^2f ＝8z_5 - (z_1 + z_2 + z_3 + z_4 + z_5 + z_6 + z_7 + z_8 + z_9) 缺点： 拉普拉斯算子对噪声具有敏感性 拉普拉斯算子的幅值产生双边缘 拉普拉斯算子不能检测边缘的方向 优点： 可以利用零交叉的性质进行边缘定位 可以确定一个像素是在边缘暗的一边还是亮的一边 Derivative of Gaussian Filter 根据交换律，先进性高斯模糊核与边缘提取核先计算，从而减少整体的计算量。 课后探索：边缘提取：Canny 算法 Mask-RCNN 彩色图像色彩的本质人对色彩的感知：视杆细胞，视锥细胞 色彩空间（英语：Color space）是对色彩的组织方式。借助色彩空间和针对物理设备的测试，可以得到色彩的固定模拟和数字表示。色彩空间可以只通过任意挑选一些颜色来定义，比如像彩通系统就只是把一组特定的颜色作为样本，然后给每个颜色定义名字和代码；也可以是基于严谨的数学定义，比如 Adobe RGB、sRGB。 CIE 1931 xyz 是第一次人眼对色彩感知度量建立色彩空间的尝试，几乎所有其它色彩空间的基础。有一些变体。 CIELUV CIE L*A*B* 基于人眼 RGB 加法混色法，从暗处叠加产生颜色（sRGB，Adobe RGB） CMYK 减法混色法 HSV 艺术家们常用，使用色相饱和度和明度HSL 用亮度（Lightness）代替明度（Value/Brightness） 其他讨论区问题调研 C/C++语言中 main 函数的两个常见参数的意义和用法，将调研结果写在下面的讨论区主函数程序应当含有一个名为 main 的全局函数，它被指定为程序的启动点。它应当有下列形式之一： 123int main () &#123; body &#125; (1)int main (int argc, char _argv[]) &#123; body &#125; (2)// 其他由实现定义的形式，返回类型为 int (3) argc - 非负数，表示从程序运行的环境传递给程序的实参个数。 argv - 指针，指向包含 argc + 1 个指针的数组的首元素。数组末元素为空指针，若其前面有任何元素，则它们指向空终止多字节字符串，表示从执行环境传递给程序的若干参数。若 argv[0] 不是空指针，或等价地 argc &gt; 0 ，则它指向表示用于调用程序的名称的字符串，或空字符串。 body - 主函数的函数体名字 argc 和 argv 是任取的，而且形参的类型的表示方式也是：int main(int ac, char** av) 同样合法。 main() 的一种常见的由实现定义的形式还有（除 argc 和 argv 之外的）第三个参数，类型为 char*[] ，指向指向执行环境变量的指针数组。]]></content>
      <categories>
        <category>数字图像处理</category>
      </categories>
      <tags>
        <tag>数字图像处理</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[数字图像处理——色彩]]></title>
    <url>%2Fpost%2F2af9aa70.html</url>
    <content type="text"><![CDATA[彩色图像色彩的本质人对色彩的感知：视杆细胞，视锥细胞 色彩空间（英语：Color space）是对色彩的组织方式。借助色彩空间和针对物理设备的测试，可以得到色彩的固定模拟和数字表示。色彩空间可以只通过任意挑选一些颜色来定义，比如像彩通系统就只是把一组特定的颜色作为样本，然后给每个颜色定义名字和代码；也可以是基于严谨的数学定义，比如 Adobe RGB、sRGB。 CIE 1931 xyz 是第一次人眼对色彩感知度量建立色彩空间的尝试，几乎所有其它色彩空间的基础。有一些变体。 CIELUV CIE L*A*B* 基于人眼 RGB 加法混色法，从暗处叠加产生颜色（sRGB，Adobe RGB） CMYK 减法混色法 HSV 艺术家们常用，使用色相饱和度和明度HSL 用亮度（Lightness）代替明度（Value/Brightness） 数字图像处理考试安排 选择题 10/20 分 填空题 5/10 分 简答题 5/20 分 分析设计题 2/10 分 主要来源：学习平台上的代码 18 周周三 12.25 下午考]]></content>
      <categories>
        <category>数字图像处理</category>
      </categories>
      <tags>
        <tag>数字图像处理</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[数字图像处理——图像分割]]></title>
    <url>%2Fpost%2Ffe69cba9.html</url>
    <content type="text"><![CDATA[图像分割科研的主要方向：分割、识别、跟踪 主要期刊会议：ICIP（数字图像向）、CVPR（计算机视觉）、ICCV（计算机视觉） 数字图像处理（Image Process）与计算机视觉（Computer Vision）存在大量的交叠。 本章要点：概述、边缘连接和边界检测、阈值处理（前述提到）、基于区域的分割（较新）、分割中运动的应用（较新）。 概述分割的目的：将图像划分为不同区域。 三大类方法： 根据区域间灰度不连续搜寻区域之间的边界，在边缘检测、边缘连接和边界检测介绍 以像素性质分布进行阈值处理，在阈值处理介绍 直接搜寻区域进行分割，在基于区域的分割中介绍 Q&amp;A：多尺度的边缘检测仍然需要选择确定的尺度，不能智能辨识。 间断检测点检测、线检测、边缘检测 差分、数值微分：$\partial$ 一阶对应线检测、二阶对应点检测 Derivative of Gaussian Filter 根据交换律，先进性高斯模糊核与边缘提取核先计算，从而减少整体的计算量。 课后探索：边缘提取：Canny 算法 Mask-RCNN]]></content>
      <categories>
        <category>数字图像处理</category>
      </categories>
      <tags>
        <tag>数字图像处理</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[机器学习——PCA原理研究]]></title>
    <url>%2Fpost%2Fb17c259a.html</url>
    <content type="text"><![CDATA[PCA 原理研究前两次课介绍 PCA，大家应该对主成分分析降维有了一定的了解，我还有两个问题没有解决，课下自己查阅了些资料。 主成分分析步骤是如何推导出来的？ 协方差矩阵的 n-1 如何了解？ 主成分分析步骤的推导PPT 上和老师分享的视频实际上在开头都有描述，较为简略。由于我们更关注 PCA 的实际操作步骤，更容易如何求矩阵的特征值和特征向量，不过这样，容易忽略：我们为什么要做矩阵正交化？我们需要回到优化目标上。 思路梳理 降维 -&gt; 基变换、投影 分散-&gt; 投影的方差最大 保留特征-&gt; 基重叠最少-&gt; 基正交（如果能找到） 引入优化目标：寻找 K 维的新正交基，使得数据变换到这组基上后方差值最大。 优化目标的实现： 上面我们导出了优化目标，但是这个目标似乎不能直接作为操作指南（或者说算法），因为它只说要什么，但根本没有说怎么做。所以我们要继续在数学上研究计算方案。 我们发现最终要达到的目的与字段内方差及字段间协方差有密切关系。 用协方差矩阵来描述我们的优化目标： 优化目标矩阵对角化等价 寻找矩阵对角化方式 求特征值，特征向量。 协方差矩阵对角化根据上述推导，我们发现要达到优化目前，等价于将协方差矩阵对角化：即除对角线外的其它元素化为 0，并且在对角线上将元素按大小从上到下排列，这样我们就达到了优化目的。这样说可能还不是很明晰，我们进一步看下原矩阵与基变换后矩阵协方差矩阵的关系：]]></content>
      <categories>
        <category>机器学习</category>
      </categories>
      <tags>
        <tag>机器学习</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[计算机图形学——复习]]></title>
    <url>%2Fpost%2F1cc3e298.html</url>
    <content type="text"><![CDATA[第一讲 绪论什么是计算机图形学计算机图形学(Computer Graphics，简称CG)的内容比较丰富，与很多学科都有交叉，因此笔者认为是无法严格定义的。 在“Wiki百科”和“百度百科”上，对“计算机图形学”的解释为：计算机图形学是一种使用数学算法将二维或三维图形转化为计算机显示器的栅格形式的科学。简单地说，计算机图形学的主要研究内容就是研究如何在计算机中表示图形、以及利用计算机进行图形的计算、处理和显示的相关原理与算法。狭义地理解，计算机图形学是数字图象处理或计算机视觉的逆过程。 图形学的研究对象图形：能在人的视觉系统中产生视觉印象的客观对象 图形学的目的在计算机中表示、生成、处理和显示图形 和其他学科交叉 数字图像处理：利用计算机对数字图像处理进行底层信息处理 计算机视觉：从数字图像中提取高层次信息 计算机图形学：将各层次信息表达为视觉元素 趋势：这些学科方向不断的交叉融入，形成一个更大的学科方向，可称之为“可视计算”(Visual Computing) 计算机图形学的主要研究内容建模（Modeling） 在计算机中表达、生成与处理三维模型的数据结构与算法 三维模型的生成方法是当前的热点问题，图形学大众化应用的关键技术难题 主要采取的方法： 计算机辅助设计（CAD）中的主流方法是采用NURBS方法，存在如非正规曲面光滑拼合，复杂曲面表达等问题仍未解决 戏份曲面造型方法，离散迭代曲面构造方法，过程朴素简单实现容易。 渲染（Rendering） 有了模型场景，怎么画出来产生图像，这个核心任务就是渲染要解决的。 常用的真实感绘制方法：光线追踪方法和辐射度方法。 各种渲染技术：全局光照模型、Photo mapping、BTF、BRDF、基于GPU的渲染技术 动画（Animation） 讲义中pass了，也非课程重点 中科大教授解释：连续播放静止图像产生物体运动的效果，制作景物动画，高度物理真实感动态模拟（如各种形变、燃烧爆炸老化等） 人机交互HCI，人与计算机之间以一定的交互方式活交互界面，来完成确定任务的人与计算机之间的信息交换过程。 其他：渲染只讲了光线追踪相关，额外的没有拓展、GAMS 第二讲 三维模型几何建模在计算机中表达一个真实世界的三维对象或虚拟三维形象，就必须先描述其形状。 几何建模：三维对象的表达、构造和处理的计算机算法和过程。 离散化数字化几何数据： 易于表达和传输 渲染硬件和软件的基础数据 大多数获取设备的输出格式 大多数模拟/分析工具需要的输入 走样（aliasing）：用离散数量像素表示连续的量而引起的失真，称为走样。 反走样（在图形显示过程中，用于减少或消除走样的方法），方法：提高分辨率、非加权区域采样、加权区域采样。和某个像素求交，计算相交区域面积，确定像素值。 OpenGL反走样：glEnable(GL_BLEND) //启用混合 glEnable(GL_LINE_SMOOTH) //启用线段反走样 3D模型表达 原始数据：体素、点云、深度图像、多边形 实体模型：八叉树、BSP树、CSG、Sweep 曲面：曲面王哥、细分曲面、参数曲面、隐式曲面 高层次语义结构：Scene Graph 什么是网格（Mesh） 图形学中最常用的表达 简单 可表达复杂形状 图形硬件支持 一般为三角网格 为什么是三角网格 其他多边形网格可以容易剖分为三角形 三点共面：保证平面性 可以容易地定义内外方向、插值操作等 一些概念 边界边：只与一个面相邻 正则边：与且仅与两个面相邻 奇异边：与多于两个面相邻 流行网络：没有奇异边的网格 封闭网络：没有边界边的网格 v+f-e = 2(c-g) - b 网格的数据结构表达应用：渲染、几何查询（点面关系）、几何操作。大部分网格难以支持高效的上述操作，一般采用三角流行网格。 判断网格的数据结构是否优秀： 构建数据结构的时间复杂度（建立时间复杂度） 进行一个查询操作的时间复杂度（查询时间复杂度） 进行一个网格编辑操作的时间复杂度（更新时间复杂度） 空间复杂度 数据结构表示举例 面列表： 顶点列表：（x,y,z坐标） 面列表：逆时针顶点三元组（v1，v2，v3） 查询复杂度：面包含顶点O(1),顶点相邻O(n) 优点：方便紧凑、可表达非流形网络 缺点：不能有效地支持点、面之间的邻接关查询 邻接矩阵 顶点列表+表示顶点相邻的邻接矩阵 查询复杂度：面包含顶点O(1),顶点相邻O(1),顶点与面相邻O(n) 优点：支持vv的高效查询、支持非流形网络 缺点：没有边的显示逼到啊，不支持如vf，ve，ev等的快速查询 半边结构 流行于大部分几何建模应用 优点：所有查询操作时间复杂度均为O(1)，所有编辑操作时间复杂度均为O(1) 缺点：只能表达流形网络 面列表、邻接表（矩阵）、半边结构。 仔细了解，明白优劣，能写代码。 细分曲面 虽然理论上可以手动地设定每一个顶点、边、面，但这是异常繁琐的。理想的情况：手工构造一个低分辨率的网格，然后逐渐地用自动化算法光滑化，添加更多细节。 细分曲线、NURBS、隐式曲面、实体建模（CSG） 几何建模经典方法（常用的建模方法） 扫描 构造一个对象的三维模型需要一张或多张深度图像 距离扫描仪测量的是物体表面的三维坐标，并以m*n的距离网格形式返回测量值， 这个网格称作深度图像 如果有多张深度图像，对每张图像需要计算出一个刚性变换，以与其他深度图像对齐 使用改进版本ICP算法来计算合适的刚性变换，使得两张深度图像之间点对的最小二乘距离最小 基于图像的建模 从海量图片中构造三维模型 利用计算机诗句的方法来估计每张照片的相对摄影机位置与朝向，同时得到对象的稀疏点云表达 基本的思想：一个点的位置可以通过多张不同位置拍摄的照片确定 给定了这些相机参数和稀疏的点云，有许多致密的重建算法可以用来重建致密的模型 过程式建模 使用算法创建模型 可容易地构造多样化的模型 一般用来构造复杂的、规则性强的模型（地形、植物、建筑、城市） 用一个小的数据集或规则来描述目标模型的高层次语义信息 用算法来生成全部的模型（加入随机性，递归算法） L-system 用来进行植物建模典型系统 递归的形式化语法（符号字母表、生成规则集、非端点富豪递归地生成新的符号或符号序列） 整个过程从一个初符号开始，最后由一个解释器将生成的符号解释为几何结构。 分形 从一个形状开始，用缩放的初始形状来替换形状的一部分 递归地进行替换 几何建模应用举例 去燥/光滑化 输入一个带有噪声的网格，输出一个光滑的网格 目标是去掉高频信息 网格简化 网格常常包含了比需要显示质量更多的面片（一些网格生成算法的分辨率是固定的，不考虑曲面细节，网格可能会在不同的设备上使用） 因此，网格简化的目的是在保持视觉准确性的前提下减少面片的数量 网格编辑 网格分割（将网格分割成有意义的部分） 网格、网格的典型数据结构、几何建模典型方法、几何建模典型应用。 重点讲网格，网格的重要属性。 半边结构只能表达流形网格。 NERBS 曲线 曲面。 第三讲 OpenGL 编程OpenGL 绘制几何图元 改变状态、指定绘图元素 第四讲 数学基础回顾重心坐标、插值 线性代数：向量变换，矩阵板换 第五讲照相机与OpenGL渲染管线模型变换-摆放物体——从物体坐标系到世界坐标系 视图变换-摆放相机——从世界坐标系到相机坐标系 投影变换-调整焦距——确定放大倍数 视口变换-选择底片——确定照片大小 视图变换——相当于把照相机固定在三脚架上，并使它对准场景。模型变换——设置模型的位置和方向。如何选择？本质上是一致的，把这两种变换割裂开来是没有意义的，有时候使用一种变换要比使用另外一种变换要方便得多。 变换模型变换-摆放物体 二维变换变换的矩阵表示，矩阵蕴含表达式（图 ） 旋转的矩阵表达（图） 缩放的矩阵表达（图） 平移的矩阵表达（图） 齐次坐标：扩展一维，看上去不自然，但是使得图形学中的变换操作更简便 为什么要用采用齐次坐标 将平移、旋转和缩放等仿射变换统一为矩阵乘法操作 在软硬件实现上更简单 注意顺序 齐次坐标 1 和 0 表示什么（区分坐标和向量0向量1坐标） 视图变换与模型变换 三维齐次坐标下三维旋转与缩放（图，隔一层右上-sin，隔两层左下-sin） 绕任意轴进行旋转（图） v旋转（绕x轴）旋转到xz平面（Rx） v旋转（绕y轴）旋转到z轴（Ry） 绕v旋转一角度 前面变换坐标的逆（旋转矩阵的转置是旋转矩阵的逆） 投影变换 投影变换定义了一个视景体（视景体决定了一个物体是如何映射到屏幕上的，视景体定义了场景中的哪些部分被裁剪到最终的图像之外） 正交投影 glOrtho() 成像尺寸不随深度改变 正交投影将z方向坐标变换为0 透视投影 glPerspective() z方向坐标对x、y方向坐标剪向形变的影响 齐次坐标系 齐次坐标的第四维可以是任意非零值 齐次坐标的四个维度同时乘以一个非零值，所表达的对象（点）不变 当齐次坐标等于0 表达无穷远处的“点” 表达一个向量 不受平移影响直线透视（透视除法） 视口变换 选择窗口中的绘图区域 对应于选择被冲洗照片的大小 glViewport 注意视口的纵横比与视景体的纵横比保持一致 操纵矩阵堆栈矩阵的操作还需要复习 void glPushMatrix 复制栈顶矩阵void glPopMatrix 丢弃栈顶矩阵 12345678910draw_car_body();glPushMatrix(); glTranslate(); draw_wheel_and_bolte_1();glPopMatrix();glPushMatrix(); glTranslate(); draw_wheel_and_bolte_2();glPopMatrix(); 第六讲 纹理贴图（Texture）为什么要纹理贴图我们如何给模型添加更多的细节？ 添加更多的几何元素：更多的三角面片 优点：在光照和其它表面交互中具有真实的表现 缺点：难以生成，并消耗更多的存储和计算资源 将纹理映射到模型上 优点：使用简单、方便，消耗的资源少，可重用 缺点：过于简化、表面几何仍然是光滑的 什么是纹理 计算机图形学的定义（广义）：以图像（包括二维和三维）方式存储的资源，如位图等。 纹理合成的定义（狭义）：具有某种重复模式的图像 纹理贴图的形式化描述 从模型表面S到二维参数域U的映射函数 $f: S \rightarrow U$ 给定模型表面S上任一点p，均有f(p)属于U 这个映射称为纹理映射 S上的顶点在U中的坐标称为纹理坐标 纹理图像与参数域U之间存在自然的映射 几何图形表面材质，表达方法。 从模型表面到二维参数的映射函数 球面全局参数化。 启用纹理贴图功能1234567891011121314151617181920212223242526//清理缓存glClear(GL_COLOR_BUFFER_BIT|GL_DEPTH_BUFFER_BIT);//启用纹理贴图glEnable(GL_TEXTURE_2D);//指定纹理贴图与材质的混合模式glTexEnvf(GL_TEXTURE_ENV, AGL_TEXTURE_ENV_MODE,GL_DECAL);//绑定纹理glBindTexture(GL_TEXTURE_2D, texName);//绘制场景 提供纹理坐标和几何坐标glBegin(GL_QUADS); glTexCoord2f(0.0, 0.0); glVertex3f(-2.0, -1.0, 0.0); glTexCoord2f(0.0, 1.0); glVertex3f(-2.0, 1.0, 0.0); glTexCoord2f(1.0, 1.0); glVertex3f(0.0, 1.0, 0.0); glTexCoord2f(1.0, 0.0); glVertex3f(0.0, -1.0, 0.0); glTexCoord2f(0.0, 0.0); glVertex3f(1.0, -1.0, 0.0); glTexCoord2f(0.0, 1.0); glVertex3f(1.0, 1.0, 0.0); glTexCoord2f(1.0, 1.0); glVertex3f(2.41421, 1.0, -1.41421); glTexCoord2f(1.0, 0.0); glVertex3f(2.41421, -1.0, -1.41421);glEnd();glFlush();glDisable(GL_TEXTURE_2D); 其他映射方法： 凹凸映射 环境映射 法向贴图 置换贴图 GL固定流水线过程（图） 固定流水线，回顾 第七讲 自由曲线和自由曲面曲线曲面造型概论 平面模型：用多边形网格描述形体表面 曲面模型：由曲面片代替平面模型中的小平面片 自由曲线和曲面因不能由画法几何与机械制图方法表清楚，称为工程师们首要解决的问题。人们一直在寻找用数学方法唯一定义自由曲线和曲面的形状 对形状数学描述的要求 从计算机处理的角度 唯一性 几何不变形（形状跟坐标系无关） 易于定界 统一性（统一的数学表达，便于建立统一的数据库） 从形状表示与设计的角度来看 丰富的表单能力：表达两类曲线曲面 易于实现光滑连接 形状易于预测、控制和修改 从其他角度来看 导数易计算 易渲染 易碰撞检测 发展过程：1971 Bazier曲线、1974 B样条曲线和曲面、1975 有理B样条方法 80年代后期 发展成非均匀有理B样条（NURBS）方法，NURBS称为当前大多数商用CAD软件系统的内部表达技术（Solid Edge、CATIA、Inventor等） 曲线曲面的一般参数样条表达略 Bezier曲线为什么用参数曲线？ 一条曲线可用多边形、折线段来金丝 不能缩放 需要较多的点使曲线变得光滑 阴式曲线 制定。难于制图 参数曲线可以指明运动的点在时刻t时的位置 多项式曲线的优点：容易计算、可微 不用标准多项式来设计的原因：参数对于曲线没有直观意义，不容易调整。 Bezier曲线：用$\}(1-t)^2,2(1-t),t^2\}$，而不是幂函数$\{1,t,t^2\}$作为基函数，使得系数有了某种直观意义，控制点。 Bezier曲线由一条折线决定 称为控制多边形，多边形的顶点称为控制点 控制点按顺序形成一条折线 控制顶点可以为任意数量，3个或者4个是最常见的 曲线的阶 = 控制点的数量 曲线的次数= 曲线的阶- 1 Bézier 曲线逼近控制多边形，通过第一个和最后一个顶点，但一般不通过其它的顶点 用样条曲线而不用多项式曲线的原因。 图：Bernserin多项式 要求根据公式画形状。 性质 端点性质：曲线通过首末顶点。带入参数可验证 切矢性质：曲线在首末亮点相切于多边形的起、止边。对三次Bezier曲线求一阶导数：首为3(P1-P0)、末为3(P3-P2)。 对称性：对称点反序仍然可以得到相同的形状 凸包性：Bezier曲线不会越出特征多边形顶点围成的凸包。 插值 在参数空间[0,1]进行均匀茶汁，计算对应的坐标点，然后连接成线，就是折线逼近Bezier曲线 不足：Bezier曲线有三点不足 一是特征多边形顶点数决定了Bezier曲线的阶次，n很大时，特征多边形对形状的控制将减弱。 二是Bezier曲线不能作局部修改，改变任一控制点将波及整条曲线。 三是绘制复杂曲线需要拼接，比较繁琐。 因此发展了B样条曲线，1972年Gordon等用B样条基代替Bernstein基函数，从而改进上述缺点。 后面补充B样条曲线内容 第八讲 真实感绘制真实感绘制，逐个逐个添加，要素：明暗、阴影、高光 光线跟踪基本实现的伪代码，理解，掌握。 两个关键技术 光照明模型 求交加速算法 第九讲 光照明模型熟记，入射光，法线如何计算反射光 Phong 照明模型 Blim-Phong I 那个公式 明暗处理 shading 第十讲 光线求交发现计算 M^T的问题 包围盒、层次包围盒、均匀网格、八叉树、K-DTree 需要了解四种数据结构构造方法。 题目设置：选择、填空、判断，证明/程序实现/问答题]]></content>
      <categories>
        <category>计算机图形学</category>
      </categories>
      <tags>
        <tag>计算机图形学</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[数据分析与融合——粗糙集理论算法优化]]></title>
    <url>%2Fpost%2F295036cf.html</url>
    <content type="text"><![CDATA[粗糙集理论算法优化研究摘要本文回顾了 Pawlak 粗糙集理论的基础知识，对该理论框架下如等价类划分，相对正域计算，约简过程等问题朴素算法的复杂度进行分析，介绍并总结了前人针对上述问题提出的各种优化算法。 引言20 世纪 80 年代，波兰的 Pawlak 教授提出了粗糙集的概念，并用数学形式明确了粗糙集的定义以及计算规则[@Pawlak]，为描述系统的不确定性并计算规约相关决策规则提供了一项新的工具。粗糙集理论引起了许多数学家、逻辑学家和计算机学家的兴趣，在过去的二十年中，他们在 Pawlak 提出的粗糙集理论基础上进行了大量的研究工作。主要包括粗糙集数学性质[@]、基于其他关系的粗糙集拓展模型、多属性决策分析理论和应用[@安利平]、粗糙集理论与其他不确定方法的关系和结合[@]、粗糙集上的高效算法等。其中《基于粗集理论的多属性决策分析》[@安利平] 相较于 Zadeh 于 1965 年提出的模糊集理论[@Zadeh]，粗糙集给出了可计算的，更准确的描述模糊边界的方式以及量化边界模糊元素的方法。在智能计算、数据挖掘领域，有效且可行的数学描述带来的一大便利便是可以通过计算的方式从数据中抽取有效的经验和知识，粗糙集理论也因此成为数据科学家的有效工具。对于多属性决策分析，粗糙集理论引入了集合近似、约简、核、确定性和可能性规则等新型概念及计算方法，不仅对决策分析问题提供了解释机制，如发现重要的事实和关系，而且利用决策规则形式的偏好模型可以表示决策者的决策政策，提供决策支持。 《数据分析与融合》课程中对粗糙集进行了较为系统的讲解，但是课程避开了粗糙集相关算法的具体实现和复杂度分析。事实上，现有粗糙集算法计算的低效性在一定程度上限制了粗糙集理论的广泛应用，因此寻求高效的粗糙集算法具有重要的意义，也自然成为粗糙集理论研究的一个主要研究分支。 本文首先对粗糙集理论主要内容及其相关数学性质进行回顾，总结前人的相关文献成果，分析了算法低效性的根源 ，解释并实现一种高效的粗糙集基本算法。 粗糙集的基本概念经典粗集理论是基于不可分辨关系的，下面首先介绍粗糙集的基本概念。 信息表和不可分辨关系定义 2.1 一个信息系统可以表示为 S = \langle U,A,V,f \rangle \tag{2-1}其中, $U$ 是一非空有限对象集（即论域），$U = \{ x_1,x_2, \cdots , x_n \}$ ，$A$ 是非空有限属性集 ，$A = \{ a_1,a_2,a_3 \}$，$V_a$表示属性 $a$ 的值域 ，$V = \bigcup_{a \in A} V_a$ ，$f : U \times A \rightarrow V$ 是信息函数。它指定 $U$ 中每一个对象 $x$ 的属性值, 即对 $x \in U , a \in A$ ，有 $f(x , a) \in V_a$。 在粗集理论中，信息系统也被称为信息表、属性值表、数据表，可简记为$S = \langle U,A\rangle$，或者$S = \langle U,A,V \rangle$。粗集理论利用信息表（决策表）来描述论域对象及其属性，它是一个二维表，每一行表示一个对象，每一列表示对象的一个属性。与数据库的“表”概念不同，粗集理论所研究的表并不要求两个对象可完全区分，即至少存在一个属性列使得两个对象对应的属性值不同。粗糙集关注的是粒度，而非单个元素。 定义 2.2 在信息系统 S 中 ,对于每个属性子集$B \subseteq A$ ,可以定义一个不可分辨关系 $IND(B)$（在不引起歧义的情况下可简写为$I_B$）: IND(B) = \{ (x,y) \in U \times U : f(x,a) = f(y,a) , \forall a \in B \} \tag{2-2}如果$(x,y) \in I_B$，则$x$和$y$称为$B$不可分辨，显然$I_B$满足自反性、对称性和传递性，根据离散数学的内容我们知道，$I_B$是以等价关系，$I_B$的所有等价类族，即由$B$决定的划分，用$U/I_B$表示，包含元素$x$的等价类用$I_B(x)$ 表示 相容关系表述和转化探究在考虑决策表时，常常会考虑是否有如下情况出现：决策表元素出现属性相同（即具备不可分辨关系）的多个元素，却有不同的决策属性值。我们常常将这样类似的性质描述为决策表的相容性。若要通过决策表为自动化程序或者固定流程提供指导，我们希望决策表是相容的，在不断约简决策表过程中，我们也希望决策表保持原有的相容性，否则，具备不可分辨关系的两元素就会出现决策差异，这与程序设计与工业流程中要求的“确定性”产生了根本的对立。当然，若是考虑引入新的知识项（属性）、关联上下文等方法，我们或许可以将不相容的决策表转化为新的相容决策表且决策能力不变，但这已经超出了基本粗糙集和决策表约简的讨论范围，在此也不考虑这种拓展情形。 相容性的刻画有很多方法，从定义上划分可以在不同资料 设$S = \langle U,C \cup D \rangle$为一决策表，不可分辨关系$I_C$将论域划分为$U/C$，称为条件分类（条件粒度），不可分辨关系$I_D$将论域划分为$U/D$，称为决策分类（决策粒度）。对于单属性决策，则$D = {d}$，若非单属性决策，则$D$表示所有决策属性列的集合，决策表的相容关系有如下两种表述。 定义 2.3 设$S = \langle U,C \cup D \rangle$为一决策表，对于其条件分类$U/C$与决策分类$U/D$，若有$U/C$细分$U/D$，则称$S$为相容决策表，否则成$S$为不相容决策表。 相关文献讨论了通过决策值归纳函数来描述决策表相容性的方法，不过讨论局限在$D = {d}$，即决策属性单一的情况。为了与定义 2.3 保持等价性，这里给出拓展$D$不仅为单属性列情况下的定义。 定义 2.4 设$S = \langle U,C \cup D \rangle$为一决策表，$B \subseteq C$，定义$S$的$B$决策值归纳函数为 \partial_B : U \times D \rightarrow P(V_d) \tag{2-3}\partial_B (x,d) = \{ i: \exists x_0 \in I_B(x) , f(x,d) = i \} \tag{2-4}其中$P(V_d))$表示对应属性列取值$V_d$的幂集。 如果$\forall x \in U, \forall d \in D ,|\partial_C (x,d)| = 1$，则$S$称为相容决策表，否则，$S$称为不相容决策表。 下面证明两定义的等价性，即证$U/C$细分$U/D$是$\forall x \in U, \forall d \in D ,|\partial_C (x,d)| = 1$的充要条件 证明 2.1 充分性 应用反证法： 假设$\exists x_0 \in U, \exists d_0 \in D, | \partial_C (x_0,d_0) | \geq 2$。由细分关系$I_C \subseteq I_D$。因为$|\partial_C (x_0,d_0) | \geq 2$，不妨设$\partial_C (x_0,d_0) = \{r_0,r_1, \cdots \}$，同时我们假设$r_0$表示为$x_0$在属性$d_0$上的值（即信息函数值），$f(x_0,d_0) = r_0$，则由决策归纳函数定义，必然$\exists x_1 \in I_C(X_0), f(x_1,d_0) = r_1$。 因为$f(x_1,d_0)$不等于$f(x_0,d_0)$，所以明显$x_0$不等于$x_1$，即表示两个论域元素。又因为决策归纳函数的限制，$(x_0,x_1)\in I_C$也即（$x_0 I_C x_1$）。而根据定义 2.2，因为$f(x_1,d_0)$不等于$f(x_0,d_0)$，则对于$I_D$，$(x_0,x_1) \notin I_D$，与$I_C \subseteq I_D$相矛盾，充分性得证。 所以$U/C$细分$U/D$是$\forall x \in U, \forall d \in D ,|\partial_C (x,d)| = 1$的充分条件。 证明 2.2 必要性 因为$\forall x \in U, \forall d \in D, |\partial_C(x,d)| = 1$，那么对于$\forall (x_0,x_1) \in I_C$，我们可以得到，$\forall d \in D, |\partial_C(x_0,d)| = |\partial_C(x_1,D)| = 1$。 对于决策属性族的任意属性$d$，不妨设此时$f(x_0,d) = r, f(x_1,d) = r’$，因为$\partial_C(x_0,d) = \{ r \}$，根据决策归纳函数定义，应有$f(x_1,d) = r$，故$r = r’$。综合前述，即$\forall (x_0,x_1) \in I_C, \forall d \in D, f(x_0,d) = f(x_1,d)$，根据定义 2.2，则$(x_0,x_1) \in I_D$。即退出$I_C \subseteq I_D$，由等价关系性质可得$U/C$细分$U/D$，必要性得证，证毕。 不相容决策表可以通过决策值归纳函数转化为相容决策表$S = \langle U, C\cup (\bigcup_{d \in D} \partial(d))$。 集合的近似和相关性质由于不同文献中所用的习惯表示方法不尽相同，所以这里我们用原作者 Pawlak 在[@Pawlak1982]使用的定义方式来表示集合的近似及其相关性质，并根据原文献补充部分课上未涉及的概念。 定义 2.5 设$S$未信息表,$X$为$U$的非空子集，属性$A$下$X$包含的最大粒度集合被称为$X$的$A$下近似$\underline{\mathrm{Apr}_A}(X)$，属性$A$下包含$X$的最小粒度集合被称为$X$的$A$上近似$\overline{\mathrm{Apr}_A}(X)$，当$A$均已知的时候可以省略。 \underline{\mathrm{Apr}_A}(X) = \{ x\in U: I_A(x) \subseteq X \} \tag{2-5}\overline{\mathrm{Apr}_A}(X) = \{ x\in U: I_A(x) \cap X \not ={\emptyset} \tag{2-6}在集合近似的基础上，我们可以给出拓展的论域元素与集合近似成员关系的定义，$\underline{\in}_{A}$与$\overline{\in}_{A}$，具体定义如下： 定义 2.6 x \underline{\in}_{A} X \quad \mathrm{iff} \quad x \in \underline{\mathrm{Apr}_A}(X) \tag{2-7}x \overline{\in}_{A} X \quad \mathrm{iff} \quad x \in \overline{\mathrm{Apr}_A}(X) \tag{2-8}如果$x \underline{\in}_{A} X$，我们称“在属性$A$下$x$ 必然 属于$X$”，而如果$x \overline{\in}_{A} X$，我们称“在属性$A$下$x$，可能 属于$X$”。如此通过模态逻辑中的必然性和可能性来解释近似性。 在集合近似的基础上，我们还可以根据属性$B$，将论域$U$中的所有元素针对给定的集合$X$划分到不同域中。$\underline{\mathrm{Apr}_A}(X)$实际上是由根据已知的属性划分出的知识粒度，判断肯定属于$X$的论域元素所构成的最大集合，所以也被称为$X$的$A$正域，记为$POS_A(X)$。而根据已有知识推断的必然不属于$X$的论域元素称为$X$的$A$负域，记为$NEG_A(X)$，$\overline{\mathrm{Apr}_A}(X)$应为可能属于$X$的论域元素构成的最大集合。根据当前已有知识，既不能推断属于$POS_A(X)$也不能推断属于$NEG_A(X)$的元素则属于边界域（可域）$BND_A(X)$（部分资料上写为$Bn_A(X)$），不能肯定其中的元素是否属于$X$，具体定义如下： 定义 2.7 POS_A(X) = \underline{\mathrm{Apr}_A}(X) \tag{2-9}NEG_A(X) = U - \overline{\mathrm{Apr}_A}(X) \tag{2-10}BND_A(X) = \overline{\mathrm{Apr}_A}(X) - \underline{\mathrm{Apr}_A}(X) \tag{2-11}容易得出在各属性域限制下，论域元素集合$X,Y \subseteq U$，符合下述性质： \underline{\mathrm{Apr}}(X) \subseteq X \subseteq \overline{\mathrm{Apr}}(X) \tag{2-12}\underline{\mathrm{Apr}}(\emptyset) = \overline{\mathrm{Apr}}(\emptyset) = \emptyset \tag{2-13}\underline{\mathrm{Apr}}(U) = \overline{\mathrm{Apr}}(U) = U \tag{2-14}\underline{\mathrm{Apr}}(X \cap Y) = \underline{\mathrm{Apr}}(X) \cap \underline{\mathrm{Apr}}(Y) \tag{2-15}\overline{\mathrm{Apr}}(X \cup Y) = \overline{\mathrm{Apr}}(X) \cup \overline{\mathrm{Apr}}(Y) \tag{2-16}\underline{\mathrm{Apr}}(X \cup Y) \supseteq \underline{\mathrm{Apr}}(X) \cup \underline{\mathrm{Apr}}(Y) \tag{2-17}\overline{\mathrm{Apr}}(X \cap Y) \subseteq \overline{\mathrm{Apr}}(X) \cap \overline{\mathrm{Apr}}(Y) \tag{2-18}\underline{\mathrm{Apr}}(-X) = - \overline{\mathrm{Apr}}(X) \tag{2-19}\overline{\mathrm{Apr}}(-X) = - \underline{\mathrm{Apr}}(X) \tag{2-20}\underline{\mathrm{Apr}}(\underline{\mathrm{Apr}}(X)) = \overline{\mathrm{Apr}}(\underline{\mathrm{Apr}}(X)) = \underline{\mathrm{Apr}}(X) \tag{2-21}\overline{\mathrm{Apr}}(\overline{\mathrm{Apr}}(X)) = \underline{\mathrm{Apr}}(\overline{\mathrm{Apr}}(X)) = \overline{\mathrm{Apr}}(X) \tag{2-22}其中$-X$ 表示$U - X$，即以论域元素集合为全集得补集。 上述列出为常见的性质，其中性质$\tag{2-12}$表示，如果严肃$x$属于$\underline{\mathrm{Apr}}(X)$时，则$x$一定属于$X$，而当$x$属于$\overline{\mathrm{Apr}}(X)$时，$x$可能属于$X$，而性质$\tag{2-17}$与性质$\tag{2-18}$则表明，不同集合近似的分布计算要慎重，并集的上近似等于上近似的并集，交集的下近似等于下近似的交集，但是如果考虑交集的上近似、并集的下近似，则会出现忽略粒度和过度包含粒度的情况出现，等式关系不再成立，转而变为包含与被包含的关系，证明这里从略。在实际应用中，这提醒我们如果信息表被分成几个部分先行计算近似与整体计算近似，可能得到不同的结果。 当然，由近似引出的性质还可以继续深入研究，比如满足德摩根定律形式的一些性质，以及不同集合差集近似的性质，]]></content>
      <categories>
        <category>数据分析与融合</category>
      </categories>
      <tags>
        <tag>数据分析与融合</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[人机交互——总结笔记]]></title>
    <url>%2Fpost%2Fbba0ae0d.html</url>
    <content type="text"><![CDATA[第一章 绪论什么是人机交互（Human-Computer Interection）是关于设计、评价和实现供人们使用的交互式计算机系统，并围绕相关的主要现象进行研究的学科。——ACM SIGCHI 狭义的讲，人机交互主要研究人与计算机之间的信息交换。 综合学科，与认知心理学、人机工程学（理论基础）、多媒体技术、虚拟现实技术（相互交叉渗透）等密切相关。 人机交互研究内容 人机交互界面的表示模型与设计方法（Model and Methodology） 交互界面好坏影响软件开发的成败，研究表示模型与设计方法是 HCI 研究的重要内容 可用性分析与评估（Usability and Evaluation） 关系到 HCI 是否能达到用户期待目标。主要涉及到支持可用性的设计原则和可用性的评估方法。 多通道技术（Multi-Modal） 多通道交互界面的表示模型、多通道交互界面的评估方法以及多通道信息融合。 认知与智能用户界面（Intelligent User Interface, IUI） 目标：自然方便、上下文感知、三维输入、语音识别、手写识别、自然语言理解。 群件（Groupware） 群件指为群组协同工作提供计算机支持的协作环境。与 HCI 相关的研究内容主要包括群件系统的体系结构、计算机支持交流与共享信息的方式、交流中的决策支持工具、应用程序共享以及同步实现方法等内容。 Web 设计（Web-Interection） Web 界面模型结构、设计基本思想和原则、设计工具和技术、可用性分析和评估方法。 移动界面设计（Mobile and Ubicomp） 移动界面设计方法、可用性与评估原则、开发工具和实现技术。 HCI 发展历史命令行界面交互阶段-&gt;图形用户界面交互阶段-&gt;自然和谐的人机交互阶段 命令行 第一代人机交互界面，操作员，被动反应，缺乏自然性 GUI 主要特点：桌面隐喻、WIMP、直接操纵、所见即所得 单一通道（手）、占用较多屏幕空间、难以表达支持非空间性的抽象信息交互。 Window,Icon,Menu,Pointing Device 自然和谐 多通道交互（并行、非精确）、情感计算（上下文理解）、虚拟现实、智能用户界面、自然语言理解。 第二章 感知和认知基础人的感知 视觉 背景：人类从中为世界获取的信息约有 80%是通过视觉得到的，因此视觉显示是人机交互系统中应用的最多的人机界面 视觉感知可以分为两个阶段：受到外部刺激接收信息阶段和解释信息阶段。 视觉感知特点：一方面，眼睛和视觉系统的物理特性决定了人类无法看到某些事物；另一方面，视觉系统进行解释处理信息时可对不完全信息发挥一定的想象力。 大小、距离、深度、视敏度、视错觉、亮度、色彩（波长 400μm-700μm）、 阅读 过程：感知形状-&gt;编码为内部语言表示-&gt;解释语义 过程与交互标准：成年人阅读是通过字的特征加以识别。改变字的显示方式，会影响到阅读的速度和准确性。9 ～ 12 号的标准字体（英文）更易于识别，页面的宽度在 58 ～ 132mm 之间阅读效果最佳。在明亮的背景下显示灰暗的文字比在灰暗的背景下显示明亮的文字更能提高人的视敏度，增强文字的可读性。 听觉 能够听到的频率：16/20Hz~20kHz（高感 1000Hz~4000Hz，可辨识语音 260~5600Hz） 听觉系统就像视觉系统一样，利用以前的经验来解释输入。 输入划分：噪声和可以忽略的不重要声音、赋予意义的非语言声音、组成语言的有意义声音。 触觉 重要性：可以反馈多种信号，对于能力缺陷的人更加重要，有助于基于触觉的交互设备的设计， 不同：触觉的感知机理与视觉和听觉的最大不同在于它的非局部性（感受器遍布全身）。但不同部位对察觉的敏感度差异很大，如人的手指的触觉敏感度是前臂的触觉敏感度的 10 倍。 内部感觉 知觉的特性选择性、整体性、理解性和恒常性。 选择性 （在某一瞬间，选择某一事物为知觉对象，而把其他事物作为知觉背景，这就是知觉选择性，与注意的选择性有关）。分化对象和背景的选择性是知觉最基本的特性，背景往往衬托着、弥漫着、扩展着，对象往往轮廓分明、结构完整。 整体性 （人不会把知觉的对象感知为个别的孤立部分，而总是把它感知为一个统一的整体，这种特性叫做知觉的整体性）当一个残缺不全的部分呈现到眼前时，人脑中的神经联系马上被激活，从而把知觉对象补充完整。 知觉的理解性 （理解性指人利用过去所获得的有关知识经验，对感知对象进行加工理解。）实质是旧经验与新刺激建立多维度、多层次的联系，以保证理解的全面和深刻。 知觉的恒常性 客观条件一定范围改变时，人的知觉映像相当程度上保持稳定性。 认知过程和交互式设计原则概念模型及对概念模型的认知分布式认知第三章 交互设备人机工程学大纲从本身和系统本身的角度，研究人机关系专门的一门课程 定义 （研究人和机器、环境的相互作用及其合理结合，使设计的机器和环境系统适合人的生理、心理等特征，达到在工作、生活中提高效率、安全、健康和舒适的目的。） 人机工程学可定义为：按照人的特性设计和改善人——机环境系统的科学。 人机工程学相关问题 控制装置和显示布局在逻辑上分组布局，组织形式包括：功能的：相关功能放在一起；顺序的：按照执行的顺序放在一起；经常性：根据使用频率排序。 交互的物理环境 考虑工作环境：使用地点、使用人、使用方式（姿势） 健康问题 身体姿势（舒适的触及所有控制装置，可以看见所有的显示）、温度（高温低温环境下用户反应恶化，精神无法集中）、光线（能看见屏幕，舒适，不疲劳）、噪声（有害健康，使用户烦躁）、时间 颜色的使用问题 输入设备文字输入设备 手写输入设备 从社会科学、认知科学的角度来看，手写输入更符合人的认知习惯，是一种自然高效的交互方式。 手写板是一种常见的支持手写输入的交互设备，分为电阻式、电磁式、电容式三类，除了压感级数，精度和手写面积也是手写板的通用评测指标 手写识别 手写识别经过多年的发展已经产业化，广泛应用在触屏手机、GPS 等。提供了一种输入选择方式。 优点：方便、直观：适合没有键盘的情况；缺点：速度慢 举例：中科院自动化所“汉王笔” 语音识别 作为另一种文字输入设备，代替键盘。很有前途（和机器对话交谈是人们的理想），存在问题：识别率问题、模糊性、不确定性、口音、周围噪声 应用场景：在键盘是不现实或不可能的地方使用：电话信息系统、辅助残疾人、双手不方便（军事、无重力） 举例：IBM/Via Voice 微软语音识别系统 图像输入设备 二维扫描仪已经成为计算机不可缺少的图文输入工具之一，由光学系统和步进电机组成。性能指标包括：扫描速度、分辨率等。扫描速度决定了扫描仪的工作效率，分辨率决定了最高扫描精度。 数字摄像头 作为一种视频输入设备，被广泛应用在视频聊天、实时监控等方面。数字摄像头可以直接捕捉影响，然后通过计算机的串口、并口或者 USB 接口传送到计算机。解析度是数字摄像头比较重要的技术指标，又有照相解析度和视频解析度之分。 三维信息输入设备在许多领域：如机器视觉、面形检测、实物仿形、自动加工、产品质量控制、生物医学等，物体的三维信息必不可少。 三维扫描仪 根据传感方式分类：接触式和非接触式 接触式的三维扫描仪采用探测头直接接触物体表面，痛殴探测头反馈回来的光电信号转化为物体表面形状的数字信息，以三维坐标测量机伟代表。优点：校稿准确性和可靠性。缺点：测量速度慢、费用高、探头易磨损、误差修正。 非接触式的三维扫描仪主要有三维激光扫描仪，照相式三维扫描仪等，分别是基于激光扫描测量和结构光测量等技术设计的。优点：扫描速度快，易于操作，不需要直接接触。 三维激光扫描仪 三维激光扫描仪通过高速激光扫描测量技术，获取被测对象表面的空间坐标数据。常采用 TOF（Time-of-Flight，飞行时间）测量发或者三角测量法进行深度数据获取 结构光三维扫描仪 这是一种面扫描技术，通过投影仪向被测物体投射光栅模版图像，如正弦条纹光栅图像，正弦光栅在物体表面发生调制变形，其周期与相位的变化反映了物体表面的三维信息。通过相机拍摄物体表面的正弦光栅图像，检测出相位变化值，再利用双目视觉法计算出三维数据。 虚拟现实和三维交互设备 动作（运动）捕捉设备 机械式：利用可伸缩机械安装于捕捉物体上，以取得各部分的运动量。优点：成本低廉。缺点：限制物体自由运动，由于机械设备尺寸重量等问题，限制了其应用范围。 电磁式：若干低频磁场感应器安装在捕捉物体上，根据感应器接收到的磁场，可以计算出接收器相对于发射器的位置和方向。易受电磁干扰影响捕捉数据的精度和稳定性，对于作业场地的要求也十分严格。 光学式：利用计算机视觉原理。利用两台摄像机摆设图像和参数确定一点的位置。摄像机以足够高的速率连续拍摄时，从图像序列中就可以取得该点的运动轨迹。利用这一点通过对特定光电的监视和跟踪来完成运动捕捉的任务。 体感输入设备与光学式动作捕捉设备基本原理相似，体感输入设备牺牲了一定的捕捉精度，但可以更简易、快捷的实现动作捕捉，支持用户通过肢体动作控制计算机应用，如体感游戏。举例：Leap 公司的 Leap Motion，微软公司 Kinect 指点输入设备常用于完成定位，选择物体的交互任务。一维、二维、三维或更高维空间。 鼠标 机械鼠标：轮子滚动把 x-y 坐标传递给计算机。三按钮，进行选择或者点击。容易磨损、堵塞。 光电鼠标：通过感应红色光反射强度变动来获得 x-y 坐标。容易保持干净。需要粗糙纹理表面，不能放置在光滑表面。 脚鼠： 轨迹球：原理与内部结构与机械鼠标相似，不同点是轨迹球工作时球在上面，直接用手拨动。优点：占用空间小，不需要大幅度平动，节省空间，减少手腕疲劳，多用于笔记本电脑等小型便携机。 操纵杆/键盘触头 间接输入设备，占用空间小。绝对操纵杆：通过运动来操纵位置（游戏中常用，与飞机汽车等操纵杆相似）。等度操纵杆：通过感知压力来控制光标（IBM 笔记本的小红点） 触摸屏 工作方式：手指终端一个光线阵列。屏幕既是输入也是输出，不存在其他的硬件损坏。 优点：速度快、适合恶劣复杂环境、大众信息系统界面。缺点：手指的油污，很难精细选择，最佳倾斜角 15。 尖笔 精确定位，不使屏幕受油污污染，可以使用尖笔，一般 PDA 附带。 优点：精细操作、绘图。缺点：一会儿提起、一会儿放下、麻烦。 数字化画板 专业设备，用来画画代替鼠标，分辨率高，可以用手/尖笔/需要一定的空间 眼睛凝视 工作原理：带上眼镜/头盔，低能量激光摄入眼镜，然后从视网膜反射出去，随着眼睛角度改变，反射也发生改变。 优点：速度快，精度高，应用于军事和残障事业。缺点：精度越高价格越贵。可以做选择但是不能拖拽。 输出设备显示器显示器是计算机的重要输出设备，是人机对话的重要工具。它的主要功能是接收主机发出的信息，经过一系列的变换，最后以光的形式将文字和图形显示出来。 阴极射线管显示器 构成：由阴极、电平控制器（即控制极）、聚焦系统、加速系统、偏转系统和阳极荧光粉涂层组成，这六部分都在真空管内。其中，阴极、电平控制器（即控制极）、聚焦系统、加速系统等统称为电子枪。 工作原理：当显像管内部的电子枪阴极发出的电子束，经强度控制、聚焦和加速后变成细小的电子流，再经过偏转线圈的作用向正确目标偏离，穿越荫罩的小孔或栅栏，轰击到荧光屏上的荧光粉发出光线。彩色 CRT 光栅扫描显示器有三个电子枪，它的荧光屏上涂有三种荧光物质，分别能发红、绿、蓝三种颜色的光 液晶显示器 在充电条件下，液晶能改变分子排列，继而造成光线的扭曲或折射。 液晶显示器工作原理是通过能阻塞或传递光的液晶材料，传递来自周围的或内部光源的偏振光。以电流刺激液晶分子产生点、线、面配合背部灯管构成画面。 LCD 比 CRT 显示器具有更好的图像清晰度，画面稳定性和更低的功率消耗，但液晶材质粘滞性比较大，图像更新需要较长响应时间，因此不适合显示动态图象。 等离子显示器 等离子显示器诞生于二十世纪 60 年代，它采用等离子管作为发光材料，1 个等离子管负责一个像素的显示：等离子管内的氖氙混合气体在高压电极的刺激下产生紫外线，紫外线照射涂有三色荧光粉的玻璃板，荧光粉受激发出可见光 。 优点：重量较轻、完全无 X 射线辐射，而且屏幕亮度非常均匀，不存在明显的亮区和暗区；由于各个发光单元的结构完全相同，因此不会出现 CRT 显示器那样存在某些区域聚焦不良或因使用时间过长出现散焦的毛病。 缺点：是价格较高，由于显示屏上的玻璃较薄使屏幕较脆弱。 投影仪投影仪，又称投影机，是一种可以将数字图像或视频投射到幕布上的设备。 根据投影仪的工作方式不同，主要分为 CRT 型、LCD 型及 DLP 型三种不同类型的投影仪，而其中 LCD 投影仪与 DLP 投影仪又是目前商用投影仪中的主流。 打印机打印机是目前非常通用的一种输出设备，其结构可分为机械装置和控制电路两部分。 常见的有针式、喷墨、激光打印机三类。 打印分辨率、速度、幅面、最大打印能力等是衡量打印机性能的重要指标。 3D 打印机 3D 打印机又称三维打印机，它以数字模型文件为输入，运用特殊蜡材、粉末状金属或塑料等可粘合材料，通过打印一层层的粘合材料来制造三维的物体。 3D 打印机与传统打印机最大的区别在于它使用的“墨水”是实实在在的原材料，可用于打印的介质种类多样，从繁多的塑料到金属、陶瓷以及橡胶类物质。有些打印机还能结合不同介质，令打印出来的物体一头坚硬而另一头柔软。 分为喷墨式，熔积成型，激光烧结三种类型的 3D 打印机 一个桌面尺寸的三维打印机可以满足设计者或概念开发小组制造模型的需要。 语音交互设备语音作为一种重要的交互手段，日益受到人们的重视。 基本的语音交互设备：耳机、麦克风、声卡 第四章 交互技术人机交互输入模式背景：由于输入设备是多种多样的，而且对一个应用程序而言，可以有多个输入设备，同一个设备又可能为多个任务服务，这就要求对输入过程的处理要有合理的模式。 分类：请求模式、采样模式、事件模式 重点概念：一个应用程序可以同时再几种输入模式下使用几个不同的输入设备来进行工作，提供各种不同的交互功能，使用户能方便、高效地完成工作。 请求模式 在请求模式下，输入设备的启动是在应用程序中设置的。应用程序执行过程中需要输入数据时，暂停程序的执行，直到从输入设备接受到请求的输入数据后，才继续执行程序。 一般是指在高级语言的应用程序执行时需要输入一个数据，可以在应用程序中设置一条输入命令。该命令初始化输入数倍并等待用户输入。直到用户输入了一个信息，控制返回给应用程序，再继续执行应用程序 图 采样模式 输入设备和应用程序独立地工作。输入设备连续不断地把信息输入进来，信息的输入和应用程序中的输入命令无关。应用程序在处理其它数据的同时，输入设备也在工作（加入缓冲，可以并行），新的输入数据替换以前的输入数据。当应用程序遇到取样命令时，读取当前保存的输入设备数据。 优点：这种模式对连续的信息流输入比较方便，也可同时处理多个输入设备的输入信息。 缺点：当应用程序的处理时间较长时，可能会失掉某些输入信息。 图 事件模式 输入设备和程序并行工作。输入设备把数据保存到一个输入队列，也称为事件队列，所有的输入数据都保存起来，不会遗失。应用程序随时可以检查这个事件队列，处理队列中的事件，或删除队列中的事件。 图 基本交互技术 定位 确定平面或空间的一个点的坐标，是交互中最基本的输入技术之一。 直接定位：用定位设备直接指定某个对象的位置，是一种精确定位方式。 间接定位：通过定位设备的运动控制屏幕上的映射光标进行定位，是一种非精确定位方式。其允许指定的点位于一个坐标范围内，一般用鼠标等指点设备配合光标来实现。 笔划 笔划输入用于输入一组顺序的坐标点。它相当于多次调用定位输入，输入的一组点常用于显示折线或作为曲线的控制点。 定值 定值（或数值）输入用于设置物体旋转角度、缩放比例因子等。（键盘输入、比例尺调整） 选择 单个元素选择：单个元素选择是在某个选择集中选出一个元素，通过注视、指点或接触一个对象，使对象成为后续行为的焦点，是操作对象时不可缺少的一部分。操作：键盘 Ctrl+A 全选、鼠标点击。 区域选择：区域选择是在选择集中选出一组元素或者选择一个区域，通过使用区域选择工具完成该交互操作。常用：选框工具、套索工具、快速选择工具、懒惰选择工具 选框工具：目前常用的选框工具有矩形选框工具和椭圆选框工具，凡是和选框工具选择区域相交的元素均会被选择。该方法交互简单，但是选择对象往往不够精确 套索工具：为了使得选择区域更加精确，套索工具所勾画的封闭区域范围内的所有元素均被选中，该方法需要用户进行精细选择才能得到较为精确的选择结果，交互量比较大。 快速选择工具：为了提高选择精度且减少交互量，目前软件系统提供快速选择工具，这些工具采用快速选择算法，通过选择和选择点颜色相近的区域作为选择元素。 懒惰选择工具：懒惰选择方法，可以依据选择对象的形状、位置等关系信息，对用户手指划过的区域对象进行智能选择，但是这种交互技术尚不成熟，目前尚未广泛应用。 字符串 键盘是目前输入字符串最常用的方式，现在用写字板输入字符也已经很流行。 语音输入也是字符串输入以及功能选择的一种输入方法，语音输入需要使用语音识别技术。 二维图形交互技术图形用户界面又称为 WIMP 界面——是第二代人机界面，是基于图形方式的人机界面。 图形用户界面由窗口(windows)、图标(icons)、菜单(meum)、指点设备(pointing device)四位一体，形成桌面(desktop)，输出可以为静态或动态的二维图形或图像。 图 几何约束 可以用于对图形的方向、对齐方式等进行规定和校准。 定位约束：网格吸附。方向约束：检测夹角。 引力场 引力场也可以看作是一种定位约束，通过在特定图素（如直线段）周围假想有一个区域，当光标中心落在这个区域内时，就自动地被直线上最近的一个点所代替，就好像一个质点进入了直线周围的引力场，被吸引到这条直线上去一样。 引力场的大小要适中，太小了不易进入引力区，太大了线和线的引力区相交，光标在进入引力区相交部分时可能会被吸引到不希望选的线段上去，增大误接的概率。 拖动 要把一个对象移动到一个新的位置时，如果我们不是简单地用光标指定新位置的一个点，而是当光标移动时拖动着被移动的对象，这样会使用户感到更直观，并可使对象放置的位置更恰当。 橡皮筋技术 被拖动对象的形状和位置随着光标位置的不同而变化。 不断地进行画图－擦除－画图的过程（从开始到(x,y)绘图，擦除，从开始到(x,y) 加偏移量绘图）。 操作柄技术 可以用来对图形对象进行缩放、旋转、错切等几何变换。先选择要处理的图形对象，该图形对象的周围会出现操作柄，移动或旋转操作柄就可以实现相应的变换。 三维图形交互技术 面临问题： 三维交互技术采用六自由度输入设备。所谓六自由度，指沿三维空间 X、Y、Z 轴平移和绕 X、Y、Z 轴旋转，而现在流行的用于桌面型图形界面的交互设备，如鼠标、轨迹球、触摸屏等只有两个自由度(沿平面 X、Y 轴平移)。 窗口、菜单、图符和传统的二维光标在三维交互环境中会破坏空间感，用户难以区分屏幕上光标选择到对象的深度值和其他显示对象的深度值，使交互过程非常不自然。 直接操纵 通过三维光标，用户可以选择并直接操作虚拟对象。三维光标可以是人手的三维模型，输入设备的位置和方向被映射为虚拟手的位置和方向。 三维光标必须有深度感，即必须考虑光标与观察者距离，离观察者近的时候较大，离观察者远的时候较小。 为保持三维用户界面的空间感，光标在遇到物体时不能进入到或穿过物体内部。 为了增加额外的深度线索，辅助三维对象的选择，可以采用半透明三维光标。 三维光标可以是人手的三维模型 三维 Widgets 三维交互界面中的一些小工具：三维空间中漂浮的菜单、用于拾取物体的手的三维图标、平移和旋转指示器等。 1992 年美国 Brown 大学计算机系提出三维 Widget 设计原则 三视图输入用二维输入设备在一定程度上实现三维的输入。 自然交互技术Bill Gates 提出自然用户界面（Nature User Interface） 多点触控技术 多点触控技术是指借助光学和材料学技术，构建能同时检测多个触点的触控平台，使得用户能够运用多个手指同时操作实现基于手势的交互，甚至可以让多个用户同时操作实现基于协同手势的交互。 多点触控技术由硬件和软件两部分组成。 多点触控软件技术：触点检测和定位、手指触点跟踪、触摸手势识别。 触点检测和定位 图像预处理过程包括：灰度变换、平滑去噪、去除背景、图像分割等。 手指触点分割，如背景减除法。即将当前帧图像与背景图像相减，若差分图像中某个像素的灰度值大于某个阈值，则判断该像素点属于运动目标区域，即触点，否则属于背景区域。 触点定位：1）对所有分割后的触点区域提取出其外轮廓，并对轮廓图进行筛选，把面积小于一定大小和外形不是凸包的触点轮廓去掉，保留真正的触点目标；2）基于触点轮廓计算手指触摸点的信息，如重心坐标等，完成触点定位。 手指触点跟踪 多点触控系统检测和定位出多个触点后，需要对每个触点进行跟踪，记录每个触点的轨迹信息，再做基于轨迹的动态手势识别，才能实现基于手势的自由交互。触点跟踪方法有 Meanshift 算法、Kalman 滤波、Kuhn-Munkres 算法及 CamShift 算法等。 触摸手势识别 多点触控交互桌面上使用的多为单手多指手势，或者双手对称手势等。单手多指手势和双手对称手势识别，是在触点检测与稳定跟踪的基础上，通过标记、分析触点轨迹，识别手势含义。 常用的手势识别方法采用隐马尔科夫模型（HMM，Hidden Markov Model）或神经网络的统计模式识别方法进行识别。基本思想是：提取手指触点特征 ，采用手势样本训练分类器，输出手势识别概率。 手势识别技术 手势分割 三类分割方法：一是基于直方图的分割，即阈值法；二是基于局部区域信息的分割；三是基于颜色等物理特征的分割方法。 特征提取和选择 常用的手势特征有：轮廓、边缘、图像矩、图像特征向量以及区域直方图特征等。 手势识别 模板匹配技术：它将待识别手势的特征参数与预先存储的模板特征参数进行匹配，通过测量两者之间的相似度来完成识别任务。 统计分析技术：通过统计样本特征向量来确定分类器的基于概率统计理论的分类方法。 神经网络技术：该技术具有自组织和自学习能力，具有分布性特点，能有效的抗噪声和处理不完整模式以及具有模式推广能力。 表情识别技术 从表情识别过程来看，表情识别可分为三部分：人脸图像的获取与预处理、表情特征提取和表情分类。 人脸面部表情识别特征主要方法： 灰度特征：从表情图像的灰度值上提取的，利用不同表情用不同灰度值来得到识别的依据。 运动特征：利用了不同表情情况下人脸的主要表情点的运动信息来进行识别。 频率特征：利用了表情图像在不同的频率分解下的差别进行识别，速度快是其显著特点。 语音交互技术 语音识别（Speech Recognition）是计算机通过识别和理解过程把语音信号转变为相应的文本文件或命令的技术，其所涉及的领域包括：信号处理、模式识别、概率论和信息论、发声机理和听觉机理、人工智能等。一个完整的语音识别系统大致可分为语音特征提取，声学模型与模式匹配，以及语言模型与语义理解三部分。]]></content>
      <categories>
        <category>人机交互</category>
      </categories>
      <tags>
        <tag>人机交互</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[FPGA学习——Week1]]></title>
    <url>%2Fpost%2Fcfbb3381.html</url>
    <content type="text"><![CDATA[Week 1第一周内容主要为后续 FPGA 学习奠定基础，主要包含三部分内容 History of Programmable Logic 用以介绍可编程逻辑器件的历史，引入 FPGA 发展的背景。 CPLD, its architecture and performance 研究第一个可重变成期间，其架构以及对性能的影响。 Introduce FPGA, contrast with CPLD, and LUT makeup 介绍 FPGA，对比 CPLD。 什么是 FPGA？ What is an FPGA? Generally, it is an integrated circuit consisting of an array of programmable logic blocks with programmable routing between the blocks, that allows the device to be configured to perform complex digital logic functions. 资料 FPGAs for Dummies, Altera Version, available here: link, Chapters 1, 2, and 5 (27 pages)Rapid Prototyping of Digital Systems: SOPC Edition, by Hamblen, Hall and Furman; ISBN 9780387726700, Chapter 3 (14 pages)Design Recipes for FPGAs Using Verilog and VHDL, 2nd Edition, by Peter Wilson, Chapter 2 (7 pages) A Brief History of Programmable LogicFPGA 是可编程器件的一个子集 发展历程 1956 PROM Invented （Programmable Read Only Memory） 1971 EPROM （Eraseable Programmable Read-only Memory） 1975 PLAs （Programmable Logic Arrays） 1978 PALs （Programmable Array Logic） 图示：硬连接、可编程连接、无连接 PAL，PLA 区别貌似是在与门可编程还是或门可编程上，而 CPLD 和 FPGA 更像是两个框架，不同公司会给出不同的优劣评判。]]></content>
      <categories>
        <category>FPGA</category>
      </categories>
      <tags>
        <tag>FPGA</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[服务外包——多方数据安全计算平台解析]]></title>
    <url>%2Fpost%2F23762466.html</url>
    <content type="text"></content>
  </entry>
  <entry>
    <title><![CDATA[投资银行学——Lec4]]></title>
    <url>%2Fpost%2F4cf23916.html</url>
    <content type="text"><![CDATA[CAPM 模型作为理论和实践的桥梁 理论与实践的差异和关联 成功得投资是未来收回的现金流现值远大于当前透出的现金流限制 DCF 从理论而言是最准确的估值方法，基于未来预期收益额 CAPM 模型实际上是起到了一个“行路靠右”规范的作用 现金流折现方法 DCF销售额、XXXXXX 在不知道折现率的情况下如何算 NPV 衡量两家公司的状况 套用市场无风险利率? ANS：IRR，NPV 为 0 的时候计算内部收益率。 持续经营的投资定价模型 投资于经营活动产生红利，因此：股权价值=期望股利的现值 持续经营预期下：股权价值=期望股利的现值+期望到期价值的现值 永续年金/增长型永续年金]]></content>
      <categories>
        <category>投资银行学</category>
      </categories>
      <tags>
        <tag>投资银行学</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[数据分析与融合——幂集格角度分析证据计算与粗糙集的关系]]></title>
    <url>%2Fpost%2F83759fa6.html</url>
    <content type="text"><![CDATA[引言在前述的课程中，我们学习了粗糙集理论以及其应用：决策系统代数约简。在上一篇相关文章《数据分析与融合——偏序格角度看决策系统代数约简》，我也总结了课程的相关内容，其中，有一个明显而又重要的结论：决策系统的约简实际上是在论域元素$U$的细分偏序格上的寻优过程。 随着课程深入，我们又接连学习了分辨矩阵、证据理论、证据计算等，在学习证据计算这一章节时，由证据理论，我们引入了证据空间，基元等概念，从知识粒度的角度思考，其理论框架和前述学习的粗糙集及其所应用的决策系统约简有一定的相似性。 本文主要从一个基本问题——有限集合的幂集上的包含关系是否构成格，来研究粗糙集与证据理论这两套框架的相似性。 离散数学基础 集合、关系： 按照离散数学中学习的定义（虽然我不大清楚所学是朴素集合论还是康托尔公理化集合论）。 偏序关系： $R$是集合$S$上的一个二元关系，且$R$满足：自反性、反对称性、传递性，则$R$为集合$S$上的偏序关系，记作$\preceq$ 偏序集： 若在集合$S$上给定一个偏序关系$\preceq$，则称集合$S$按偏序关系 $\preceq$ 构成一个偏序集合，集合 $S$ 和偏序 $\preceq$ 一起称为偏序集，记作$(S,\preceq)$ 哈塞图： 解释略 极大元素与极小元素： $a$在偏序集$(S,\preceq)$中是极大的，当不存在$b \in S$使得$a \preceq b$ $a$在偏序集$(S,\preceq)$中是极小的，当不存在$b \in S$使得$b \preceq a$ 上界与下界： $\exists u \in S$使得$\forall a \in A, a \preceq u$，即$u$偏序大于偏序集$(S, \preceq)$的子集$A$中所有元素。那么$u$叫做$A$的一个上界。 $\exists l \in S$使得$\forall a \in A, l \preceq a$，即$l$偏序小于偏序集$(S, \preceq)$的子集$A$中所有元素。那么$l$叫做$A$的一个下界。 若$S$的子集$A$存在一个上界$u_0$，偏序小于所有其他$A$的上界，则称为$A$的最小上界。 若$S$的子集$A$存在一个下界$l_0$，偏序大于所有其他$A$的下界，则称为$A$的最大上界。 偏序格定义（格的集合定义）：如果一个偏序集的每对元素（构成的子集）都有最小上界和最大下界，就称这个偏序集为格。 代数格定义（格的代数定义）：在集合 $L$ 中定义两个代数运算 $∨$ 和 $∧$，这两个代数运算满足：幂等律、交换律、结合律、吸收率，则称该代数系统为格。 温习离散数学相关知识，我们知道一个子集$A$可能有上界但无最小上界，有下界但无最大下界，“有界”是“有最界”的必要而非充分条件。 格，则是偏序集加上了对“最界”存在的限制，由于单元素集合上下最界就是其集合所含的唯一元素，显然成立，那么要求每对元素都有最界，那么任意子集就是有最界的（易证，略），从格的代数定义理解，实际上就是满足了交和并代数运算的完备性。 幂格回到课堂上那个问题，集合的幂集与其上的包含关系构成格吗？ 答案是肯定的。 我在机械工业出版社《离散数学及其应用》（Knneth H.Rosen 著）上找到了例题说明，而且，证明幂格存在也是简单的。 证明正如图所给，我写完整一些，$S$为集合，$P(S)$（有些习惯写为$2^{S}$）为$S$的幂集，证明过程如下： 首先证明$(P(S), \subseteq)$是偏序集： 自反性，对于任意$A \subseteq S$（也即$A \in P(S)$），$A \subseteq A$，满足自反性。 反对称性：由$A \subseteq B$，$B \subseteq A$可推出$A = B$，满足反对称性。 传递性：$A \subseteq B$，$B \subseteq C$可推出$A \subseteq C$，满足传递性 所以$(P(S), \subseteq)$是偏序集。 接着再构造性证明$(P(S), \subseteq)$是格，从序理论证明有点困难（我确实没想到证交、并为最小上界和最大下界的方法），所以应用格的两个定义的等价性&gt;)，我们尝试证明$(P(S),\cup,\cap)$为代数格。 $A,B \in P(S)$，即 $A,B$ 为原集合$S$的任意两个子集，则必为幂集的两个元素，构造$C = A \cup B, D = A \cap B$，显然$C,D \in P(S)$。 交换律：$A \cap B = B \cap A$，$A \cup B = B \cup A$ 结合律：$A \cap (B \cap C) = (A \cap B) \cap C$，$A \cup (B \cup C) = (A \cup B) \cup C$ 吸收律：$A \cup (A \cap B) = A$，$A \cap (A \cup B) = A$ 幂等律：$A \cap A = A$，$A \cup A = A$ 所以$(P(S), \subseteq)$（代数表示为$(P(S),\cup,\cap)$）是格。 举一个简单的幂格的例子，并用哈斯图形式表示出来，即《离散数学及其应用》430 页所给的$(P({a,b,c}), \subseteq)$的哈斯图。 显然，由图我们也可以直观看出，三元素集合的幂集是一个格，它有底和顶。 那么我自己绘制了一个四元素集合幂集的格图，如下 两种粒度我自己的理解，粗糙集理论的粒度模型是不可分辨关系（等价关系）确定的划分构成的，而证据计算的粒度模型是对于有限集幂集构成的证据空间讨论的，由于$2^{U}$包含了所有的粒度（从空到完整）。 简单的数学表述： 问题$X$的所有可能取值构成非空有限集$U = \{ x_1,x_2, \cdots ,x_{n-1}, x_n \}$。 粗糙集模型： （这里按照《基于粗集理论的多属性决策分析》（后文简称《粗集理论》）一书的习惯性表述来写） 粗糙集一般应用在决策表中，引入全属性集$A$，则$B$属性集族定义一个不可分辨关系$I_B = \{ (x,y) \in U \times U : f(x,a) = f(y,a), \forall a \in B \}$，这个定义是针对决策表属性讲的（直观表述即两论域元素$x,y$对$B$属性集中任意属性列取值均相同，所以不可分辨）。 讨论空间：集合上的所有划分形成的空间 原子集（信息基本粒子）：等价类$I_B(X)$ 复合集：原子集的任意并集 证据计算模型 讨论空间：集合的幂集空间 原子集/复合集（信息的各种粒度）：所有可能子集，其中单点集对应确定命题，复合集对应不确定命题 所以实际上证据计算模型我的理解是是给了从最细粒度（单点集）到最粗粒度（原命题）所有的粒度，并给不同粒度独立进行赋值。 粗糙集中近似与证据理论信度函数的关系我们先来看定义 粗糙集的近似： 课件中： 下近似： $\underline{apr}(X) = \{ x | [x]_R \subseteq X \}$ 上近似：$\overline{apr}(X) = \{ x| [x]_R \cap X \not ={\emptyset} \}$ 《粗集理论》中： 设$S$为信息表，$X$为$U$的非空子集，$B \subseteq A$且$B \not ={\emptyset}$，集合$X$的$B$下近似和$B$上近似为： 下近似：$\underline{B}(X) = \{x \in U : I_B(x) \subseteq X\}$ 上近似：$\overline{B}(X) = \{x \in U : I_B(x) \cap X \not ={\emptyset}\}$ 实际上老师课件中给出的$R$实际上就是属性族$B$所定义的不可分辨关系（等价关系$I_B$），所以两种表述实际上只是形式不同而已。 我们不难发现，近似的结果仍为$U$的一个子集，近似运算实际上是定义在$U \times U$的 证据理论的信度函数 那我们再来看信度函数(信任函数和似然函数)，按照老师的课件上来，为了和上面对应把$X$，$A$表示调换了一下，没有实际影响。 信任函数：$BEL(X) = \sum_{A \subseteq X} m(A)$ 似然函数：$PL(X) = \sum_{A \cap X \not ={\emptyset}} m(A)$ 实际上我们已经发现其形式和粗糙集的“近似”有了相关性，为了方便进一步思考，我们将信度函数的计算拆分成两步——1. 找集合 2.概率累加。首先寻找满足条件的子集$A$，然后将其基本概率分配（bpa）$m_S$累加起来。 联系与区别联系 X 均表示当前命题 下近似/信任函数表示命题完全包含的知识粒度（或其对应的取值） 上近似/似然函数表示与命题相交的所有知识粒度（或其对应的取值） 区别 粒度表示不同 粗糙集粒度是等价关系决定的等价类，划分的等价类两两不相交，而一个属性子集就确定了一个等价关系。 证据计算的粒度是所有可能子集，子集间还有包含、相交等关系，不需要由属性确定等价关系，所有子集的空间（幂格）本身就是完备的。 格对应的层级不同 虽然“格”的概念在粗糙集和证据理论中都有出现，但是其表征的含义，和所在的层级确是不同的。 粗糙集中，“格”出现在决策表约简过程中，不同属性集对应不同的等价关系$I_B$从而决定了细分偏序格中的位置，而不同的划分实际上表示了不同的“知识粒度”的不同。 证据计算中，“格”出现在粒度本身的定义中，由于该框架下知识粒度本身就有粗细结构（虽然基本概率独立赋值），其知识本身就呈现“格”结构。 图示下面举出一个四元素集合$\{ x_1,x_2,x_3,x_4 \}$的例子，来表示上述的分析结果。 总结经过查阅相关资料以及自己动手实践，我确信了以下几个结论： 有限集合的幂集确实是格 证据理论幂集格与决策表约简的细分偏序格虽有相似，但是格结构描述层级不一样，幂集格描述的是粒度本身的关系，而细分偏序格描述的是不同粒度描述之间的关系 拓展我在查阅《粗集理论》这本参考书时，发现作者在绪论章节描述“粗集理论与其他不确定性理论的融合”这部分时提到了粗集理论和证据理论的关系，在此摘录，日后可深入学习。 粗集和 Dempster-Shafer 的证据理论]]></content>
      <categories>
        <category>数据分析与融合</category>
      </categories>
      <tags>
        <tag>数据分析与融合</tag>
        <tag>抽象代数</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Go学习——《Go语言程序设计》Chap7]]></title>
    <url>%2Fpost%2F79f64e2.html</url>
    <content type="text"></content>
      <categories>
        <category>编程</category>
        <category>Go</category>
      </categories>
      <tags>
        <tag>Go</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Go学习——《Go语言程序设计》Chap6]]></title>
    <url>%2Fpost%2F70985474.html</url>
    <content type="text"></content>
      <categories>
        <category>编程</category>
        <category>Go</category>
      </categories>
      <tags>
        <tag>Go</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[投资银行学——Lec3]]></title>
    <url>%2Fpost%2Fd296acb5.html</url>
    <content type="text"><![CDATA[上一周，主要讨论了的是 IPO 相关内容，由于政策的非确定性，粗略将了一下。 提问环节 监管机构，证监会（财务部-&gt;中国人民银行-&gt;证监会监管管理的改变） 招股说明书，和金融学同学写过的报告哪个最为相似？ 从某种程度讲，招股说明书有点像商业项目书 什么是买壳上市 买壳方：未上市 壳公司：债务情况不够良好 反向收购？被收购方的控制人，成了实际上的控制人 买壳风险：需要承担壳公司先前的债务负担，需要清壳，注入资产的过程，业务关联性较大的公司会降低一定的买壳风险（对债务的评估以及轻壳以后的业务发展有较好的帮助。 上市公司再融资有时候 IPO 并不赋予融资功能，不如开始的新三板，就有相关的业务。公司上市有了融资的平台，配股增发等举措。 从大的方面来讲，主要有三种方法：银行贷款融资、债券融资、股票融资等。 公司IPO有一种“财富放大器”的效用。 上市公司发行新股分增发和配股 增发与配股的比较： 在发行条件和程序方面：配股是向原有股东按一定比例配售，不涉及引入新的股东,因此发行条件要低于增发（以现行股价一定折扣来配售），发行程序也较为甲东南，成为上市公司最常规的再融资方式 从定价方式看，配股价格由承销商和上市公司根据市场预期，采用现行估价折扣法确定，而增发的定价方式更为市场化（公募增发采用询价方式，相比配股的定价方式，与IPO询价大同小异，更具市场化） 公募增发原则上没有数量的限制，可能是倍数关系（而非配股的10配3），从而在市场上可以募集到更多的资金。这笔资金可以成为处于高速成长阶段，一般涉及大规模的资产重组。 一些细微差别，配股是定向的，而增发则根据募集方式而不一定是定向的，它分为公募增发和定向增发；配股不需要项目支持，可以用于补充公司资本，增发则需要配套项目支持。（香港市场比A股市场管制要松一些，对于增发限制更低，A股市场需要报批证监会）（配股不吃会由中介机构吃下） 在我国，1998年5月以前，配股基本上是我国上市公司再融资的唯一方式。 课下思考，为何？ 2001年，证监会发布《上市公司发行可转债实施办法》，（老师评：发行可转债要求要比增发、配股更低，配股要求是三年平均下来净资产收益率不低于7%，当时的怪现象，公司伪造业绩低迷来避免7%的迫近导致人们警觉“圈钱”）。 2007年之后，定向增发成为了上市公司再融资的重要方式，同时，转摘亦由传统方式转变为可分离债的方式。 上市公司发行可转换公司债券再融资的承销风险]]></content>
      <categories>
        <category>投资银行学</category>
      </categories>
      <tags>
        <tag>投资银行学</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Go学习——《Go语言程序设计》Chap5]]></title>
    <url>%2Fpost%2Fe99105ce.html</url>
    <content type="text"><![CDATA[过程式编程我学习的主要关注点是 Go 语言的并发编程，而过程式编程是并发编成和面向对象编程的基础，这一节主要细致探究过程式编程中的一些问题（语句控制结构、自定义类型和函数等） 语句基础形式上 Go 语言语法需要分号，但是编译器帮我们完成了这项任务，在以字母字面量、字符串字面量、右括号系列、一些特定关键字和增建操作符结尾的非空行末尾自动加上了分号。 两个地方必须使用分号： 一行中放入一条或者多条语句 原始 for 循环 自动插入分号的一个重要结果是一个左大括号不能单独成行（变相限制了代码风格），比如下面这个就是不可通过编译的 12345// 错误代码for i := 0; i &lt; 5; i++&#123; fmt.Println(i)&#125; 内置函数 除了之前见到较多的append()，len()，cap()，make()等，要着重关注学习异常相关的两个内置函数： panic(x) 抛出一个运行时异常，其值为 x。 recover() 捕获一个运行时异常。 快速声明操作符快速声明操作符号:=用于同时在一个语句中声明和赋值一个变量。多个逗号分割的用法和=赋值操作符一样，需要强调的是，其本身不会新建作用域，即除了必须至少有一个非空变量为新的，如果变量已经存在了，它就会被直接赋值，而不会新建一个变量，除非该:=操作符位于作用域的起始处，如if或者for语句中的初始化语句。 :=可以创建“影子”变量覆盖外层同名变量的值，这很方便，但在有些地方可能会引起失误和问题。 我们可以在有一到多个命名返回值的函数中写无需返回值的裸 return。这种情况下，返回值将是命名的返回值，它们在函数入口被初始化为其类型零值。 如果出现了返回值同名“影子”变量且涉及到 return，好在 Go 编译器会给出一个错误消息，正如下面这个样子。 类型转换转换语法 1resultOfType := Type(expression) 非数值类型之间的转换不会丢失精度，但是数值类型之间可能会。 类型断言方式有安全/非安全（抛出异常）两种 12resultOfType, boolean := expression.(Type) // 安全类型断言resultOfType := expression.(Type) //非安全类型断言，失败时panic() if+类型断言赋值给同名变量（影子变量）很常见，如果目标类型可以是很多类型之一，我们可以使用类型开关。 分支if 语句Go 里面的经典用法： 1234567if optionalSatement1; booleanExpression1&#123; block1&#125;else if optionalStatement2; booleanExpression2&#123; block2&#125;else &#123; block3&#125; 放在 if 语句中的optionalStatement作用于整个 if…else…if 语句，也限制于其中。 switch 语句Go 语言中有两种类型的 switch 语句：表达式开关（expression switch）和类型开关（type switch）。表达式开关语句对于 C/C++/Java 程序员来说比较熟悉，然而类型开关语句是 Go专有的。 需要强调的是，不同于 C/C++/Java，Go 语言的 switch 语句不会自动地乡下贯穿（因此不用每个 case 后面都加 break），相反，我们可以在需要的时候通过显式地调用 fallthrough 语句来这样做。 表达式开关紧凑经典实用举例： 只使用一个表达式，一个带返回类型的函数，然后用逗号分割相同操作的不同 case（而舍弃用 fallthrough 贯穿写）。 12345678switch Suffix(file)&#123; case ".gz": return GzipFileList(file) case ".tar", ".tar.gz", "tgz": return TarFileList(file) case ".zip": return ZipFileList(file)&#125; 字符开关与类型断言相似，但是使用type关键字代替实际类型，以用于表示任意类型 1234567891011121314switch x.(type)&#123; case bool: block1 case float64: block2 case int,int8,int16,int32,int64: block3 case nil: block4 case string: block5 default: block6&#125; 经典应用，反序列化一个内部结构未知的原始 JSON 对象，并创建和打印 JSON 对象的字符串表示。 for 循环语句for 和 for…range，记住 Go 的循环全是 for，包括但不限于 for{} -&gt; while(1) for Expression -&gt; while(expression) for k,v := range() -&gt; for k,v in … 通信和并发语句通信与并发特性在第 7 章详讲，这里描述基本语法。 goroutine goroutine是程序中与其他goroutine完全相互独立而并发执行的函数或者方法调用。每一个 Go 程序都至少有一个，即 main 函数中运行的。 goroutine非常像轻量级的线程或者协程。它们可以被大批量地创建。所有的goroutine共享相同的地址空间。同时 Go 语言提供了锁原语 🔓 来保证数据能够安全地跨goroutine共享。然而，Go 语言推荐的并发编程方式是通信，而非共享数据。 创建方式 12go function(argu) // 调用已有的函数go func(parameters) &#123; block &#125; (argu) // 调用一个临时创建的匿名函数 被调用函数执行会立即进行，但是是在另一个goroutine上执行，并且当前goroutine（包含 go 语句的）会从下一条语句中恢复。 通信 通过通信管道实现多个goroutine之间通信（发送接受数据）。发送分为阻塞发送 （channeel &lt;- value）和非阻塞发送（select实现） 创建通道的方式 12make(chan Type) //未指定容量，同步make(chan Type, capacity) //指定容量，异步。 我的实验代码，实验结果输出至 testoutput.txt，发现每次运行，输出顺序不一致，可以体现不同goroutine的相对独立。 1234567891011121314151617181920212223// createChannel 接受一个int类型的参数，返回一个int类型的通道func createChannel(startInt int, chanName string) chan int &#123; next := make(chan int) // 建立新的goruntime go func(i int, name string) &#123; for &#123; next &lt;- i fmt.Printf("Channel %8s is now adding number %d\n", name, i) i++ &#125; &#125;(startInt, chanName) // 由于chan是引用类型，所以返回以后在子goruntime还会继续运行 return next&#125;func main() &#123; counterA := createChannel(8, "ChannelA") counterB := createChannel(108, "ChannelB") for i := 0; i &lt; 20; i++ &#123; a := &lt;-counterA fmt.Printf("(A-&gt;%d, B-&gt;%d)\n", a, &lt;-counterB) &#125;&#125; select语句，在一个select语句中，如果发现任意一句可以继续执行（没有被阻塞），则选择。如果全部通道都被阻塞，有 default 则执行并从select后恢复，否则整个语句阻塞，直到一一句可以继续执行。 defer、panic 和 recoverdefer 语句用于延迟一个函数或者方法（或者当前所创建的匿名函数）的执行，它会再外围函数或者方法返回之前但是其返回值计算之后执行。这样就有可能在一个延迟执行的函数内部修改函数的命名返回值。多个 defer 语句按 LIFO 顺序执行。 defer 最常用是保证一个文件使用完以后关闭defer file.Close() panic 和 revover，前文已经阐述过 Go 语言将错误和异常区分对待，错误（可预期的）常通过函数的返回值形式实现，而对于“不可能发生”的情况（异常）我们使用内置的panic()函数。 当内置的panic()函数被调用时，外围函数或者方法的执行会立即中止。然后，任何延迟执行的函数或者方法都会被调用，就像返回一样。最后，调用返回到该外围函数的调用者，就像该外围调用函数或者方法调用了panic()一样，该过程在调用栈中重复发生：函数停止执行，调用延迟执行函数等。当到达main()函数时不再有可以返回的调用者，因此这时程序会中止，并将包含传入原始panic()函数中的值的调用栈信息输出到os.Stderr。 上面所描述的只是一个异常发生时正常情况下所展开的。然而，如果其中有个延迟执行的函数或者方法包含一个对内值的recover()函数（可能值在一个延迟执行的函数或者方法中调用），该异常展开就会中止（被捕获）。这种情况下，我们就能够以任何我们想要的方式相应该异常（忽略，转错误等）。 异常和错误的使用规范绝大多数情况下，Go 语言标准库实验嗯 error 值而非异常。（标准库的规范），对于我们手写的自定义的包，尽量不要使用panic()，如果要使用，也要避免异常离开这个自定义包的边界，可以用recover()捕获异常并返回一个相应的错误值，就像标准库中所作的那样。 作为一个程序员，如果程序中有逻辑错误，我们希望程序能够立马崩溃，以便我们可以发现并修改该问题。但一旦程序部署好了，我们就不想让我们的程序崩溃。 对于任何特殊情况下可能运行也G可能不运行的函数或者方法，如果调用了panic()函数或者调用了发生异常的函数或者方法，我们应该使用recover()以保证将异常转换成错误。理想情况下，recover()函数应该在尽可能接近于panic()的地方背调用，并在设置其外围函数 error 返回值之前尽可能合理的将程序恢复到健康状态。对于 main 包的main()函数，我们可以放入一个“捕获一切”的recover函数，用于记录任何捕获的异常。 自定义函数这里内容有点繁杂，需要自己多动手实践体会 关于返回值：如果函数有返回值，则函数必须至少有一个 return 语句或者panic()调用，如果返回值不是命名的，则 return 语句必须指定和返回值列表一样多的值。如果有命名，也尽量写全 return（空 return 语句虽然合法，但是被认为是一种拙劣的写法。） 函数参数 函数调用可以作为函数参数 需要类型和数量匹配，如Heron(a,b,c)与Heron(PythagoreanTriple(i,i+1))，其中PythagoreanTriple(i,i+1)返回三个整数值。 可变函数参数 最后一个类型前面加一个省略号，在函数里面这个参数实际上变成了一个对应参数类型的切片。如我们有一个签名是Join(first string, xs ...String)的函数，xs类型实际上是[]string 常见的可变参数设置是：完全任意（可空参），至少一参，至少两参（前面单独列出即可）。 可选参数 Go 没有直接支持可选参数，要实现也不难，只需增加一个额外的结构体即可，而且 Go 语言能保证所有值都会被初始化为零值。 一个比较优雅的做法是这样定义函数 ProcessItems(items Items, options Options)，其中 Options 结构体保存了所有其他参数的值，其结构为： 123456type Options struct&#123; First int //要处理的第一项 Last int //要处理的最后一项 Audit bool //如果为true，所有动作都被记录 ErrorHandler func(item Item)&#125; Go 保证结构体传入初始化为零值，大部分需要默认场合（全零值的情况），调用很简单，如果需要制定一个或者多个，则填入对应的字段名即可，如下： 12ProcessItems(items, Options&#123;&#125;)ProcessItems(items, Options&#123;Audit: true, ErrorHandler: errorHandler&#125;) init()函数和 main()函数Go 语言保留两个函数名：init()函数用来导入包后执行，全main()函数，作为入口，这两个函数不显示调用，也不可接受任何参数，不返回任何结果。建议一个包最多只用一个init()函数。 程序启动顺序如下： 闭包这是个重要的概念，所谓闭包就是一个函数“捕获”了和它在同意作用域地其他常量和变量（或许可以理解成声明时就调用了在这个作用域地其他常量和变量），闭包使用这些捕获的量且不关心它们是否已经超出作用域，所以只要闭包还在使用它，这些变量就还会存在。在 Go 语言里，所有的匿名函数（Go 语言规范中称之为函数字面量）都是闭包。 闭包没有名字，通常使用方法时赋值给一个变量或者将它放在一个数据结构里（如映射/切片）。 另外，工厂函数（装饰函数）返回的也常为一个函数闭包，函数闭包也常出现在一些函数参数中 运行时选择函数在 Go 语言里，函数属于第一类值（first-class value），也就是说，你可以将它保存到一个变量（实际上是一个引用）里，这样我们就可以在运行时决定要执行哪一个函数（比 if-else 运行时选择来的快）。 根据书上写的实验]]></content>
      <categories>
        <category>编程</category>
        <category>Go</category>
      </categories>
      <tags>
        <tag>Go</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[服务外包——赛题类别及可做行梳理]]></title>
    <url>%2Fpost%2F45783d4c.html</url>
    <content type="text"><![CDATA[主要是梳理关键词、难点与可做性。 可能需要加商学院同学 A01 基于绿色出行场景个人碳排放积分系统开发与运营 （Pass） 命题方向： 消费互联（消费、娱乐） 题目类别：商业类 背景核心关键词：碳积分系统、量化公共交通减排、激励引导机制 项目说明： 要求：充分利用碳积分可交易流通的资产属性。游戏元素、积分道具、交易变现等方式，在既有公共出行互联网平台上设计，APP 内嵌入应用。 目的：用户活跃度与用户黏度。 技术难点： 高并发、高延迟场景，网络状况不佳场景，定位信号问题，数据统计需求，运营体系设计。 A02 基于地铁出行场景的小游戏设计 （Pass） 命题方向：文创娱乐（娱乐） 题目类别： 应用类 背景核心关键词：游戏化设计，应用内游戏，场景结合 项目说明： 要求：基于地铁出行场景设计APP 内嵌入小游戏 目的：场景特点+趣味性吸引用户。 技术难点： 游戏设计技术（基于 H5），场景结合（可能涉及 AR 技术），地铁场景信号问题，高并发、定位、延迟等（与 A02 类似）。 A03 工业物联网——高性能边缘计算轻量级容器管理引擎设计 （Pass 难度太高） 命题方向： 智能制造 题目类别：应用类 核心关键词：容器，容器引擎，高性能边缘计算（网卡），工业数据协议 项目说明： 要求：基于容器技术实现水平扩展运行？与边缘计算网关应用程序框架，提供通用数据发布、接收、持久化等接口。 目的：设计应用于工业物联网（工业数据传输）的容器管理引擎+应用。 技术难点： 这个挑战真的很大，感觉是个从系统+应用全方位的设计，且需要考虑安全性。 系统方面：详见任务清单，包括设计轻量级容器引擎及其下属的镜像文件管理、容器管理、参数管理、文件系统管理、权限管理等要求。 接口与协议方面：了解接口/协议，如何统一不同工业数据协议（二级协议？），接口标准化怎么做（怎么做有优势？），脏数据的预处理。 安全方面：如何实现项目文档的要求：提升边缘计算网关的可靠性？无法侵入设备网络和传感网络？（物理隔离/信号等等知识） 编程方面：系统级编程，SmartSIM 编程？ A04 工夹具全寿命管理系统（TMS） （保留 .NET） 命题方向： 企业服务 题目类别：应用类 核心关键词：B/S 架构 MVC 局域网网站，跟踪管理系统，可查询可追溯，预警， 项目说明： 要求：开发工具有要求！基于.NET C#开发一个 B/S 架构的 MVC 网站，前端兼具美观性，完成工具夹跟踪管理系统。详细的流程和权限要求见原始文档。 目的：自动化管理工具夹 Web 技术难点： 主要不同点是命题企业限制了开发工具环境等等，VS，.NET，MVC架构，C#，Bootstrap，JQuery 报警机制的实现，其他的主要是完全符合项目要求。 A05 基于人工智能的视觉识别技术（车间安全帽检测） （保留） 命题方向： 智能计算 题目类别：应用类 核心关键词：图像处理/特征识别，数据挖掘，基于模型的实时监测，系统部署 项目说明： 要求：实现一个安全帽识别算法（机器学习/图像处理），并实现对应的实时监测系统部署 目的：场景实时识别佩戴安全帽/未佩戴 技术难点： 数据挖掘：数据挖掘衡量标准（泛化能力等等） 系统方面：实时监测图像的预处理，基于模型的系统实现，系统部署 A06 交通时空大数据分析挖掘系统 （保留） 命题方向： 智能制造 题目类别：应用类 核心关键词：容器，容器引擎，高性能边缘计算（网卡），工业数据协议 项目说明： 关键点：出勤/驻留；密度/热力分析/前端展示/实时热力图（前端重点）；后端必须使用大数据技术（伪分布式/单机环境） A07 酒店视觉 AI 解决方案（保留） 命题方向： 智能制造 题目类别：应用类 核心关键词：容器，容器引擎，高性能边缘计算（网卡），工业数据协议 项目说明： A08 智·会学习——今目标“智慧校园”场景挖掘与实践应用（Pass） 命题方向： 智能制造 题目类别：应用类 核心关键词：容器，容器引擎，高性能边缘计算（网卡），工业数据协议 项目说明： A09 僵尸企业画像及分类（Pass）A10 金融科技服务平台企业数据的无监督分类系统（Pass）A11 多方数据安全计算平台的设计与实现 （保留） 关键点（视频提到）：中间计算步骤不可解密（即便泄露也不会透露任何初级信息）- A12 基于算法的配送路线优化系统 （Pass）A13 运用文本相似度实现主观题自动评阅 （暂时 Pass）A14 金融领域公司实体消歧系统构建 （Pass）保留 A04 A05 A06 A11 12.31 12 月中旬。]]></content>
      <categories>
        <category>服务外包</category>
      </categories>
      <tags>
        <tag>服务外包</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[IOS——IOS系统使用Google服务]]></title>
    <url>%2Fpost%2Fbb820b96.html</url>
    <content type="text"><![CDATA[今天在 PC 整理 Timetable 时使用的是 Google Calendar，觉得颇为好用，就想在移动端上进行同步，不过 Google 同步由于一些不可抗力因素无法进行。直接的不行，就曲线救国吧。 Apple 美区自行寻找方法，淘也好，注册也好，在此不再赘述。购买完成后记得改密码换问题答案。 Kits…😈 软件由于阴影小火箭等软件在国内都被搜索屏蔽，我从官方网站上只找到了 Kits…😈（全程自行官网搜索）的软件，支持 v-core 可自定义配置。 TB 上可以搜到美区的兑换码，购入，切美区，填码，下载。 然后从指定位置导入config.json即可，配置文件可以从 PC 端正在使用的客户端导出。 BTW，Kits…😈也有安卓端。]]></content>
      <categories>
        <category>IOS</category>
      </categories>
      <tags>
        <tag>IOS</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Go学习——《Go语言程序设计》Chap4]]></title>
    <url>%2Fpost%2F9e963558.html</url>
    <content type="text"><![CDATA[集合类型Go 语言的指针与 C/C++中的之后怎类似，无论是语法上还是语意上。但是 Go 语言的指针不支持指针运算，这样就消除了在 C/C++程序中一类潜在的 bug。Go 语言也不用 free()函数或者 delete 操作符号，因为 Go 语言有垃圾回收器，并且自动管理内存。 值、指针和引用类型通常情况下 Go 语言的变量持有相应的值。也就是说，我们可以将一个变量想象成它所持有的值来使用。其中有些例外是对于通道、函数、方法、映射以及切片的引用变量。它们持有的都是引用，也即保存指针的变量。 对于字符串，如果修改一个传入的字符串（例如，使用+=操作符），Go 语言必须创建一个新的字符串，并且复制原始的字符串，并将其加到该字符串之后，这对于大字符串来说很可能代价非常大。（实际上，如Chap3里面讲的，更多时候我们会准备一个字符切片[]string,或者用bytes.Buffer对应方法实现） 剩下的指针与 C/C++及其类似，在此不再赘述，需要特别了解的是，虽然 Go 编译器可能在内部将栈和堆的内存区分对待，但是 Go 程序员从不需要担心这些，因为 Go 语言自己会在内部处理好内存管理的事情。 我的测试 12345678z := 37pi := &amp;zppi := &amp;pifmt.Println(z, *pi, **ppi)**ppi++fmt.Println(z, *pi, **ppi)fmt.Println(reflect.TypeOf(pi))fmt.Println(reflect.TypeOf(ppi)) 测试结果 123437 37 3738 38 38*int**int 对于 swap 等操作（需要对变量本身而非变量的副本进行操作），C/C++的常见思路是将需要操作的原始变量的指针以参数形式传入函数并进行修改，而 Go 提供了一个更人性化的方法，一般而言，对于少量这样的变量，我们仍采用按值传递的方式，然后通过多返回值的设计完成需要，或者，对于大量的，我们会传入一个切片来达到效果。 表示成功与失败，C/C++中习惯传入一个布尔类型指针，Go 语言中直接以最后一个返回值的形式返回一个布尔型的成功标志（或者最好是一个 error 值）的写法更好用。 数组和切片数组的创建方法123[length]Type[N]Type&#123;v1,v2,v3,...,vn&#125;[...]Type&#123;v1,v2,v3,...,vn&#125; ...在这种场景下使用，Go 会自动补全，我们可以理解为定长度的（与后面切片的变长相对应）。 一般而言，Go 语言的切片比数组更加灵活、强大且方便。数组是按值传递的（即传递副本，虽然可以通过传递指针来避免，PS 这么操作的话 Go 比 C/C++还反人类）。 虽然数组和切片所保存的元素类型相同，但在实际使用中并不受此限。这是因为其类型也可以是一个接口。因此我们可以保存任意满足所声明的接口的元素（即它们定义了该接口所需的方法）。然后我们可以让一个数组或者切片为空接口 interface{}，这意味着我们可以存储任意类型的元素，不过这导致我们在获取一个元素时需要使用类型断言或者类型转变，或者两者配合使用。 切片的创建方法1234make([]Type, length, capacity)make([]Type, length)[]Type&#123;&#125;[]Type&#123;value1,value2,...,valueN&#125; 切片创建时会创建一个隐藏的初始化为零值的数组（如果使用第四种方法则是有初始值的）。一个切片的容量即为其隐藏数组的长度，而其长度为不超过容量的任意值。 实际中使用空切片，make()创建会更实用，只需将长度设为 0，并且将容量设为一个我们估计需要保存元素的个数。 切片再切片是引用，切片参数也是引用，都是对同一底层数组的引用，其中一个改变会影响到其他所有指向该相同数组的任何其他引用。 二维切片的实验： 使用长度为 3（即包含三个切片和容量为 3（默认容量为其长度）来创建一个切片的切片 grid），我们尝试让内层切片长度不一样。 1234567891011121314151617181920212223242526package mainimport ( "fmt" "os" "strconv")func main() &#123; // debug参数设定为 ["3","4","5"] if len(os.Args) &lt; 4 &#123; fmt.Println("This program needs three int:") os.Exit(1) &#125; grid1 := make([][]int, 3) for index := 0; index &lt; 3; index++ &#123; parint, _ := strconv.ParseInt(os.Args[index+1], 10, 0) grid1[index] = make([]int, parint) &#125; fmt.Println(grid1) grid1[0][0], grid1[1][1], grid1[2][2] = 1, 2, 3 fmt.Println(grid1) // [[0 0 0] [0 0 0 0] [0 0 0 0 0]] // [[1 0 0] [0 2 0 0] [0 0 3 0 0]] // 符合预期&#125; 遍历切片for…range 循化，带循环计数器的循环，（”_“）表示丢弃该值 我的实验： 12345678910grid2 := make([]int, 5)for _, i := range grid2 &#123; fmt.Println(i) i = 2&#125;fmt.Println(grid2)for k, _ := range grid2 &#123; grid2[k] = 2&#125;fmt.Println(grid2) 输出为 123456700000[0 0 0 0 0][2 2 2 2 2] 发现取到的值是值，改变并不会引起切片的改变，如果我们想要修改切片中的项，我们必须使用可以提供有效切片索引而非仅仅是元素副本的 for 循环，需要区分切片本身引用与 for 循环取值副本的差别。 切片的修改12345678s = []string&#123;&#125;t = []string&#123;"a","b","c","d"&#125;s = append(s,"h","i","j") //添加多个单一值s = append(s, t...) //添加t整个切片中所有值s = append(s, t[1:3]...) // 添加一个子切片所有值b := []byte&#123;'U','V'&#125;letters := "WXY"b = append(b, letters...) //将字符串字节添加到字节且片中 ...这时候很像解包，把切片拆解为底层构成元素然后统一放入。 排序和搜索切片一些常用方法：sort.Float64s(),sort.Ints(),sort.IntsAreSorted()等等。 sort.Sort()函数能够对任意类型进行排序，只需其类型提供了sort.Int结果义的方法，**即只要这些类型根据相应的签名实现了Len(结果 Swap()`**等方法，便可以使用函数排序，下面是自己对结果 12345678910111213141516171819202122232425262728293031package m结果import ( "fmt"结果 "sort" "strings")type FoldedString []stringfunc (slice FoldedString) Len() int &#123; return len(slice)&#125;func (slice FoldedString) Less(i int, j int) bool &#123; return strings.ToLower(slice[i]) &lt; strings.ToLower(slice[j])&#125;func (slice FoldedString) Swap(i int, j int) &#123; slice[i], slice[j] = slice[j], slice[i]&#125;func main() &#123; test1 := make(FoldedString, 2) test1 = append(test1, "who") test1 = append(test1, "What") test1 = append(test1, "Answer") fmt.Println(test1) sort.Sort(test1) fmt.Println(test1)&#125; sort.Search()提供了一个二分搜索算法的函数。该函数两个参数：长度、与元素比较的函数（必须为闭包，闭包在下一节涉及）。 映射某些场合也成为散列映射、散列表、无序映射、字典。 映射的操作 语法 含义/结果 make[k] = v 用键 k 将值 v 赋给映射 m。如果映射中存在，抛弃原先值。 Delete(m,k) 将键 k 及其值从映射 m 删除，如果不存在则安全地不进行任何操作。 v:= m[k] 从映射 m 中取得键 k 的值赋给 v，如果不存在则赋类型 0 值 v,found := m[k] v 同上，存在则 found 为 true，否则为 false len(m) 返回映射 m 中的项数 创建删除等过程和切片很类似（make 方式），时间复杂度直接索引要比切片慢两个数量级（非正式数据） 例子：猜测分割符例子很简单，二维切片counts [][]int，外层是sepIndex（分割符的 index），内层是lineIndex行数，统计一下内层全相同且不为 0 的就可以了。 例子：词频统计这个例子里面涉及到 UTF 编码文件的分割和映射反转（多值），所以详细看了下。 处理文件 主函数 123456789101112131415func main() &#123; if len(os.Args) == 1 || os.Args[1] == "-h" || os.Args[1] == "--help" &#123; fmt.Printf("usage: %s &lt;file1&gt; [&lt;file2&gt; [... &lt;fileN&gt;]]\n", filepath.Base(os.Args[0])) os.Exit(1) &#125; frequencyForWord := map[string]int&#123;&#125; // Same as: make(map[string]int) for _, filename := range commandLineFiles(os.Args[1:]) &#123; updateFrequencies(filename, frequencyForWord) &#125; reportByWords(frequencyForWord) wordsForFrequency := invertStringIntMap(frequencyForWord) reportByFrequency(wordsForFrequency)&#125; 主函数描述了基本流程，建立空映射，便利文件处理更新映射。得到第一个映射后就输出第一份报告reportByWords()这是以字符为键的，然后进行映射反转构建以频数为键的多值映射，并输出第二份报告reportByFrequency()。 Windows 通配符处理函数 1234567891011121314func commandLineFiles(files []string) []string &#123; if runtime.GOOS == "windows" &#123; args := make([]string, 0, len(files)) for _, name := range files &#123; if matches, err := filepath.Glob(name); err != nil &#123; args = append(args, name) // Invalid pattern &#125; else if matches != nil &#123; // At least one match args = append(args, matches...) &#125; &#125; return args &#125; return files&#125; 由于 cmd 不支持通配符，对传入参数（文件名）进行预处理 文件处理函数 12345678910func updateFrequencies(filename string, frequencyForWord map[string]int) &#123; var file *os.File var err error if file, err = os.Open(filename); err != nil &#123; log.Println("failed to open the file: ", err) return &#125; defer file.Close() readAndUpdateFrequencies(bufio.NewReader(file), frequencyForWord)&#125; 打开文件，并用defer让函数返回时关闭文件句柄，并将文件作为*bufferio.Reader传给实际工作函数，实际工作函数readAndUpdateFrequencies()按行读取而不是读取字节流。 实际工作函数 123456789101112131415161718func readAndUpdateFrequencies(reader *bufio.Reader, frequencyForWord map[string]int) &#123; for &#123; line, err := reader.ReadString('\n') for _, word := range SplitOnNonLetters(strings.TrimSpace(line)) &#123; if len(word) &gt; utf8.UTFMax || utf8.RuneCountInString(word) &gt; 1 &#123; frequencyForWord[strings.ToLower(word)] += 1 &#125; &#125; if err != nil &#123; if err != io.EOF &#123; log.Println("failed to finish reading the file: ", err) &#125; break &#125; &#125;&#125; 一个无限循环一行一行读取文件，出现错误的时候报告并给 log，但不直接退出程序（因为还有其他文件需要处理）。 按行读取reader.ReadString(&#39;\n&#39;)，然后内循环处理每行，对单词进行分割并忽略掉非单词的字符。一开始使用strings.TrimeSpace(line)去除行开头和结束的空白。 为了快速检查，使用 if 的两个分句，首先检查其长度是否大于 UTF 最多需要的字节，如果多，则必为符合要求的 word（因为分割是按照非 unicode 的 letter 分割的），如果少，那么再特判断，检查 rune 的个数。 分割函数 1234func SplitOnNonLetters(s string) []string &#123; notALetter := func(char rune) bool &#123; return !unicode.IsLetter(char) &#125; return strings.FieldsFunc(s, notALetter)&#125; 用于对行进行字符切分，应用的是strings.FieldsFunc，传入原始字符串和 bool 类型返回值的函数，进行多字符切分（字符串一节有涉及），strings.Split和strings.FieldsFunc详细解释，可以看着一篇Medium:strings.FieldsFunc vs strings.Split。 统计、反映射与输出函数 给出实现，不再分析 1234567891011121314151617181920212223242526272829303132333435func reportByWords(frequencyForWord map[string]int) &#123; words := make([]string, 0, len(frequencyForWord)) wordWidth, frequencyWidth := 0, 0 for word, frequency := range frequencyForWord &#123; words = append(words, word) if width := utf8.RuneCountInString(word); width &gt; wordWidth &#123; wordWidth = width &#125; if width := len(fmt.Sprint(frequency)); width &gt; frequencyWidth &#123; frequencyWidth = width &#125; &#125; sort.Strings(words) gap := wordWidth + frequencyWidth - len("Word") - len("Frequency") fmt.Printf("Word %*s%s\n", gap, " ", "Frequency") for _, word := range words &#123; fmt.Printf("%-*s %*d\n", wordWidth, word, frequencyWidth, frequencyForWord[word]) &#125;&#125;func reportByFrequency(wordsForFrequency map[int][]string) &#123; frequencies := make([]int, 0, len(wordsForFrequency)) for frequency := range wordsForFrequency &#123; frequencies = append(frequencies, frequency) &#125; sort.Ints(frequencies) width := len(fmt.Sprint(frequencies[len(frequencies)-1])) fmt.Println("Frequency → Words") for _, frequency := range frequencies &#123; words := wordsForFrequency[frequency] sort.Strings(words) fmt.Printf("%*d %s\n", width, frequency, strings.Join(words, ", ")) &#125;&#125;]]></content>
      <categories>
        <category>编程</category>
        <category>Go</category>
      </categories>
      <tags>
        <tag>Go</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[投资银行学——Lec2]]></title>
    <url>%2Fpost%2Fa5919c23.html</url>
    <content type="text"><![CDATA[股份有限公司公司的概念和类别公司是企业法人组织的一种重要形式（法人，经营主体）。（老师讲评：国内 IPO 前一些公司特有的“改制”，将一部分资产进行股份制改造，改造过程中会涉及一些资产的剥离等，国外资本主义环境，基本上都是自负盈亏的经营主体，IPO 前不会涉及这一特殊过程。） 公司的类别依照不同的标准，可以对公司做不同分类。 根据股东承担责任的大小划分为：有限责任公司、无限责任公司、股份有限公司、两合公司（有限合伙制） 有限责任公司 股份公司一定是有限责任的，但是有限责任不一定为股份公司 有限责任公司股东人数既有最低限也有最高限，我国为 1 人以上 50 人以下。 股份有限公司 我国对股份有限公司的股东人数有最低限制，要求有二人以上二百人以下发起 由于股份公司是公开向社会发股筹资的股东人数多，因此各国法律都要求股份有限公司应将其财务公开。（我国特殊规定，我国股份有限公司成立需要报批省级以上国资委） 股份有限公司的优点 两合公司（有限合伙制） 指由负责有限责任的股东和负无限责任的股东两种成员组成的公司，也成为有限合伙制。 在这类公司中，无限责任股东除负债 股份有限公司的设立 xx 设立 募集设立 也叫“渐次设立”， 公众公司和非公众公司 公众公司 非公众公司 经历天使人、AB 轮，都是非公众公司 公开上市公开上市的好处 持续融资的便利 公司形象的改善 比如一些投资公司有投资上的洁癖，烟草等公司就不投资，迫使一些公司做形象上的改善 提供相对合理的定价 比如国有资产的评估，可以根据市值来看，使一些评价标准化，也更加合理。 股权的流动性 管理权、控制权，相对控股（20%），就可以获得一个控制的权力，而非上市前需要达到绝对控股（51%） 股权激励计划 提供给员工的股权激励计划，高新技术]]></content>
      <categories>
        <category>投资银行学</category>
      </categories>
      <tags>
        <tag>投资银行学</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[投资银行学——Lec1]]></title>
    <url>%2Fpost%2F3c98cd99.html</url>
    <content type="text"><![CDATA[有证券交易市场开始约 5-10 年后才出现了《证券法》 2000 年出现的问题： 由于评估是一种倒推的现象，国有股和法人股原本每股价 0.5/0.7，经过评估以后接近 1，所以产生了溢价，市场上恐慌情绪蔓延。 998 股改 股权分置改革 我国投资银行的发展特点 监管模式 集中监管模式经历了早期的：财政部独立管理阶段（1981-1985）、中国人民银行主管阶段（1986-1992）、国务院证券委员会主管阶段（1992-1998）和中国证监会主管阶段（1998 年至今） 监管方式：分业监管。不过随着金融机构边界逐渐模糊，分业向各机构协调监管靠拢 根据证券公司评价计分的高地，将证券公司分为 A（AAA、AA、A）、B（BBB、BB、B）、C（CCC、CC、C）、D、E 等五个大类十一个级别。 抗风险能力 证券公司的主要风险体现在证券市场的系统性风险方面，盈利结构单一、业务单向操作是我国证券公司目前最大的风险。 与美国的投资银行相比，我国证券公司的长期以来主要靠资本金运作，较少利用贷款融资和债券融资，杠杆比率普遍较低。（老师的观点：证券公司主要是中介的服务，应较少在市场里实际投入资金，实际投入大头应该为投资公司，证券公司主要做各种证券的承销。） 较低的杠杆率降低了政权公司的盈利能力，提高杠杆率成为未来我国证券公司发展年的一个特点，同时也带来了高杠杆率之下的风险控制要求。 （老师的观点：过去上市发行股票，股票定价是被忽视的一点，常由证监会给出建议，定价在市盈率 10 倍-20 倍，现在来说，股票估值越发被看重。）]]></content>
      <categories>
        <category>投资银行学</category>
      </categories>
      <tags>
        <tag>投资银行学</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Python学习——Anaconda使用相关]]></title>
    <url>%2Fpost%2F2e186184.html</url>
    <content type="text"><![CDATA[Anaconda环境克隆我已经在 A 服务器上配置好了一套我的 conda 环境，但是我现在又多出来了几台服务器，我想配置一模一样的，又不想一个一个包地重装一遍，能不能 conda 的环境直接移植到新的计算机上呢？ 答案肯定是能的。只是中文的网站资料上基本没人提过这个东西。 conda 本身的命令里是有移植这个选项的。假如前提是，在本地的 conda 里已经有一个 AAA 的环境，我想创建一个新环境跟它一模一样的叫 BBB，那么这样一句就搞定了： 1conda create -n BBB --clone AAA 但是如果是跨计算机呢。 其实是一样的，查询 conda create 命令的说明： –clone ENV Path to (or name of) existing local environment. 所以 1conda create -n BBB --clone ~/path]]></content>
      <categories>
        <category>编程</category>
        <category>Python</category>
      </categories>
      <tags>
        <tag>Python</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Go学习——《Go语言程序设计》Chap3]]></title>
    <url>%2Fpost%2Ff2a0fb.html</url>
    <content type="text"><![CDATA[字符串本章讲解 Go 语言的字符串类型 一个 Go 语言字符串是一个任意字节的常量序列。大部分情况下，一个字符串的字节使用 UTF-8 编码表示 Unicode 文本。 字面量、操作符和转义字符串字面量使用双引号（”）或者反引号（’）来创建，主要区别如下 &quot; 双引号创建可解析的字符串字面量，比如带转义，但不能用来引用多行。 &#39; 反引号创建原生的子字符串字面量，这些字符串可能由多行组成，不支持任何转义序列，并且可以包含除了反引号之外的任何字符。 可解析的字符串使用得最广泛，而原生的字符串字面量则用于书写多行消息、HTML 以及正则表达式，这里有一些例子。 如果想创建一个长的可解析字符串字面量，但又不想在代码中写同样长的一行（想要换为多行），我们可以考虑使用+级联，或者+=追加。（当然这不是来追加的更好的方式，见下一节） 1234book := "The Spirit Level" + " by Richard Wilkinson"book += " and Kate Pickett"fmt.Print(book) 字符和字符串一个字符串可以使用语法chars := []rune(s)转换成一个rune（即码点）切片，其中s是一个字符串类型的值。变量chars的类型为[]int32，因为rune是int32的同义词（基本数据类型处解释过）。这在我们需要逐个字符解析字符串，同时需要在解析过程中能产看前一个或后一个字符时会有用。相反的转换也同样简单，其语法为s := string(chars)。两个转化时间代价都是$O(n)$ 虽然方便，但是使用+=操作符并不是一个循环中往字符串末尾追加字符串最有效的方式。一个更好的方式（Python 程序员熟悉）是准备好一个字符串切片（[]string），然后使用strings.Join()函数一次性将其中所有字符串串连起来。但在 Go 语言中还有一个更好的方法，其原理类似 Java 中的StringBuilder，例子如下： 12345678var buffer bytes.Bufferfor &#123; if piece, ok := getNextValidString(); ok&#123; buffer.WriteString(piece) &#125; else &#123; break &#125;&#125; 将一个bytes.Buffer类型中的字符串累加起来可能比+=操作符在节省内存和操作符方面高效得多，特别当级联的字符串数量很大时。 字符串索引与切片切片并不是万能的，对于字符全是 7 位 ASCII 编码的字符情况下切片简单又方便，因为字节与索引位置是一一对应的，而这种情况下字节和字符也是一一对应的。 然而当处理非 ASCII 码文本则更有挑战，因为这些字符可能用一个或者多个字节表示，如下图展示。 通常我们完全不需要切片一个字符串，只需要for...range循环将其一个字符一个字符的迭代（注意这里是按字符），但是有些情况下我们确实需要使用切片来获得一个子字符串，精确得到切片索引的方法strings.Index()、strings.LastIndex()。 下面是一个自己写的例子 12345678910111213141516171819202122232425262728293031// 我的测试s := "What ever you input 👿"// for ... range 循环输出for _, x := range s &#123; fmt.Printf("-%c-", x)&#125;fmt.Println(s)fmt.Print("Last index of ' ' = ")// LastIndex 说明// LastIndex returns the index of the last instance of substr in s, or -1 if substr is not present in s.// LastIndex 输出的是末尾，也即不包含值，对于单个字节应为该字节后面一个索引fmt.Println(strings.LastIndex(s, " "))// 👿最后的index实验以及输出evilBeginIndex := strings.LastIndex(s, " ")evilLastIndex := strings.LastIndex(s, "")fmt.Print("Begin index of 👿: ")fmt.Println(evilBeginIndex)fmt.Print("Last index of 👿: ")fmt.Println(evilLastIndex)fmt.Println("")fmt.Print("Differ of the two index: ")fmt.Println(evilLastIndex - evilBeginIndex)fmt.Print("Print the evil: ")fmt.Println(s[evilBeginIndex:evilLastIndex])// 输出长度len := len(s)fmt.Println(len)// 一个切片 恒等式 i \in [0,len(s)]i := len / 2fmt.Println(s == s[:i]+s[i:])// 一个实际的切片例子 使用 fmt 包来格式化字符串一些常见的方法，注意区分带F前缀为，写入到指定 writer 的（不带则是输出到os.Stdout），带f后缀的则是按字符串格式format填入参数（不带则是按格式%v以空格分割、换行结尾写），这样举一反三一下就大体知道输出函数的类别了。 格式指令 含义 %% 一个%字面量 %b 一个二进制整数值（基数为 2），或者是一个（高级的）用科学技术法表示的指数为 2 的浮点数 %c 一个 Unicode 字符的码点值（rune 类型输出） %d 一个十进制数值（基数为 10） %e 以科学计数法 e 表示的浮点数或者复数值 %E 以科学计数法 E 表示的浮点数或者复数值 %f 以标准计数法表示的浮点数或者复数值 %g 略 %G 略 %o 一个以八进制表示的数字（基数为 8） %p 以十六进制（基数为 16）表示的一个值的地址，前缀为 0x，字母使用小写的 a~f 表示（用于调试） %q 使用 Go 语法以及必要时使用转义，以双引号括起来的字符串或者字节切片[]byte，或者单引号括起来的数字 %s 以原生的 UTF-8 字节表示的字符串或者[]byte 切片，对于一个给定的文本文件或者一个能够显示 UTF-8 编码的控制台，它会产生正确的 Unicode 输出 %t 布尔值 %T 使用 Go 语法输出值的类型 %U 使用 Unicode 表示法表示整形码点 %v 使用默认格式输出的内置或者自定义类型的值，或者是使用类型的 String()方法输出的自定义值 %x 以十六进制表示的整形值（基数为 16）、字符串或者[]byte 数组，a~f 表示 %X 以十六进制表示的整形值（基数为 16）、字符串或者[]byte 数组，A~F 表示 需要注意的是，和 C/C++的 format 输出非常相似，但是存在一些细微的差别。例如。Go 语言的%d 可以用于任何整数，无论它的大小如何和有无符号（完美～）。 例子：m3u2pls]]></content>
      <categories>
        <category>编程</category>
        <category>Go</category>
      </categories>
      <tags>
        <tag>Go</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[UbuntuToGo——Ubuntu系统便捷设置]]></title>
    <url>%2Fpost%2Fc8194796.html</url>
    <content type="text"><![CDATA[合盖休眠更改由于笔者经常中午带着🎧趴在电脑上睡觉，Windows上面电源设置可以更改合盖休眠的默认设定，所以想在Ubuntu上也作相同设置（不然一合上盖子就休眠了），方法如下： root账户编辑/etc/systemd/logind.conf，修改HandleLidSwitch=suspend为HandleLidSwitch=ignore 保存修改后systemctl restart systemd-logind，重启服务生效。（我的机子卡住了，要不就重启好了。。） 输入 sudo vim /etc/systemd/logind.conf , 摁 i 编辑 去掉如下的行前面的 “#”，最后一个”HandleLidSwitch” 的值改为Lock ，如下图： 这样关上盖子就不会休眠了。（享受音乐，午休～） 截屏快捷键Screenshot是个很好的工具，截图用来插图片或者分享给朋友都很好用。不过每次都要通过功能键找应用未免太麻烦了。 虽然也可以命令行gnome-screenshot -a，不过好像更麻烦了？搜索了一下发现可以自定义快捷键+命令，如此便可一键截图，还可以自定义方式，方法如下： Settings-&gt;Keyboard找到Keyboard Shortcuts，点击最下方”+”，增加快捷键设置。 编辑快捷键名，快捷键命令，以及按键 保存测试即可 Screenshot命令行详情参见gnome-screenshot -h，如下： 所以我自己根据需要设置了两个： 交互式截屏：Ctrl+Alt+I 代替命令为gnome-screenshot -i 效果等同于点击应用，出现UI，可选择截屏方式、储存位置，是我在Ubuntu图形界面的主要截屏方式。 快捷截屏：Ctrl+Alt+A 代替命令为gnome-screenshot -a 效果等同于窗口截屏，选定窗口即截屏并放置在默认路径（Picture)。 阿里云OSS Linux版客户端下载安装阿里云OSS Linux版客户端（ossbrowser），方便管理资源。 下载网址]]></content>
      <categories>
        <category>操作系统</category>
        <category>UbuntuToGo</category>
      </categories>
      <tags>
        <tag>Ubuntu</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Go学习——《Go语言程序设计》Chap2]]></title>
    <url>%2Fpost%2F77f5906d.html</url>
    <content type="text"><![CDATA[布尔与数值类型注释//单行注释被编译器当作一个换行符，/* */多行注释划定同行被当作一个空格，多行被当作换行符。 常量和变量1234567const limit = 512 // 常量，其类型兼容任何数字const top uint16 = 1421 // 常量，类型，uint16start := -19 // 变量，推断类型，intend := int64(9876543210) // 变量。类型，int64var i int // 变量，类型，intvar debug = false // 变量，推断类型，bool 多个常量，用一个const组合 12345const &#123; Cyan = 0 Magenta = 1 Yellow = 2&#125; iota预定义的标识符表示连续的无类型整数常量。每次关键字const出现时，它的值重设为 0（因此，每次都会定义一组新的常量），而每个常量的声明的增量为 1。 布尔与布尔表达式布尔类型：ture,false 布尔操作符：与 C 常见（除了位运算）相同。 注意&amp;&amp;,||仍然是短路规则的。 用于比较操作符（小于大于等）进行比较的值，Go 会严格筛选，两个值必须是相通类型的，或者如果它们是接口，就必须实现了相同的接口类型。如果有一个值是常量，那么他的类型必须与另一个类型兼容。这意味着一个无类型的数值常量可以跟另一个任意数值类型的值进行比较，但是不同类型且非常量的数值不能直接比较。 数值类型类型转换用type(value)的形式。 大整数的用法（Machin 公式），一些方法会再返回时将结果保存回其接收器中，也即big.Int类型大部分方法会修改他的接收器（这样做是为了节省创建大量临时big.Int值的开销）。 1234567891011121314func π(places int) *big.Int &#123; digits := big.NewInt(int64(places)) unity := big.NewInt(0) ten := big.NewInt(10) exponent := big.NewInt(0) unity.Exp(ten, exponent.Add(digits, ten), nil) pi := big.NewInt(4) left := arccot(big.NewInt(5), unity) left.Mul(left, big.NewInt(4)) right := arccot(big.NewInt(239), unity) left.Sub(left, right) pi.Mul(pi, left) return pi.Div(pi, big.NewInt(0).Exp(ten, ten, nil))&#125; 浮点类型Go 内置的浮点类型：float32,float64,complex64（实部虚部都是一个 float32）,complex128（实部虚部都是一个 float64）。 介绍了一些 math 包中的常量与函数 例子：statistics一个 Web 服务器统计工具 实现一个简单的统计函数定义类型 12345type statistics struct &#123; numbers []float64 mean float64 median float64&#125; 123456789func getStats(numbers []float64) (stats statistics) &#123; // 切片赋值 stats.numbers = numbers // 修改了 sort.Float64s(stats.numbers) stats.mean = sum(numbers) / float64(len(numbers)) stats.median = median(numbers) return stats&#125; getStatus 函数作用就是传入[]float64切片，然后统计，返回制定类型（带切片、统计数据的 statistics 聚合类型）。 其中计算中位数使用了sort包里的Float64s()函数对原数组进行排序，也就是说getStatus修改了切片参数，这种情况在传切片、引用或者指针到函数时很常见。如果要保留原始切片，可以使用 Go 语言内置的copy()函数，将它赋值到一个临时变量，使用临时变量来工作。 实现一个基本的 HTTP 服务器123456func main() &#123; http.HandleFunc("/", homePage) if err := http.ListenAndServ (":9002", nil); err != nil &#123; log.Fatal("failed to start server", err) &#125;&#125; http.HandleFunc()函数用来注册“路径-函数”，两个参数：一个路径，一个当这个路径被请求时会被执行的函数的引用。 http.ListenAndServe()函数使用给定的 TCP 地址启动一个 Web 服务器，第二个参数支持自定义服务器，为空的花表示使用默认的类型。]]></content>
      <categories>
        <category>编程</category>
        <category>Go</category>
      </categories>
      <tags>
        <tag>Go</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[机器学习——支持向量机]]></title>
    <url>%2Fpost%2F7ac02bb8.html</url>
    <content type="text"><![CDATA[支持向量机 Support Vector Machine前情提要 95 年首先提出 是一种统计识别方法，二分类问题上有很大应用。 过学习问题 根据统计学习理论，学习机器的实际风险由经验风险值和置信风险值两部分组成。而基于经验风险最小化准则的学习方法只强调了训练样本的经验风险最小误差，没有最小化置信范围值，因此其泛化能力较差。 支持向量机是一种基于统计学习理论的模式识别方法，主要应用于模式识别领域。 基本思想是在样本空间或特征空间构造出最优超平面，使得超平面与不同类样本集之间的距离最大，从而达到最大的泛化能力。 支持向量机可以做什么手写体的识别 LeNe 、多项式 SVM 性别判断 （温习机器学习一般流程） （温习评价指标：查全率、查重率、ROC 曲线） 支持向量机基本原理SVM 是在两类线性可分情况下，获得最优分类面问题中提出的。 分类间隔：假设$H$表示分类线，$H_1,H_2$使两条平行于分类线$H$的支线，并且他们分别过每类离分类线$H$最近的样本，$H1$和$H2$之间的距离叫做分类间隔（margin）。 Margin 越大，对新样本的分类（抗干扰）能力越强。 线性判别函数和判别面 一个线性判别函数是指由$x$的各个分量的线性组合而成的函数 g(x) = w^T x + w_0 两类情况：对于两类问题 的决策规则为： $g(x)&gt;0$，判定为$C_1$ $g(x)&lt;0$，判定为$C_2$ $g(x)==0$，边界拒绝分类。 方程$g(x)= 0$定义了一个判别面，把归类于$C_1$的点与$C_2$的点分开来。 当$g(x)$是线性函数时，这个平面被称为“超平面”（hyperplane） 当$x_1,x_2$都在判定面上时 w^Tx_1 = w^Tx_2w^T(x_1 - x_2) = 0说明超平面上任意向量均与法向量正交。 硬间隔和支持向量SVM 分类问题大致有三种：线性可分问题、近似线性可分问题、线性不可分问题。 对应支持向量机包含由简至繁的三种模型： 线性可分支持向量机：当数据线性可分时，通过硬间隔最大化，学习一个线性的分类器，也称硬间隔支持向量机 线性支持向量机：当数据近似线性可分，通过软间隔使 非线性支持向量机： 关键点 $\min \dfrac{1}{2} | w^2 | , y^{(i)}(w^T+ b ) \ge 1$ 对偶问题 函数间隔 几何间隔 相差是一个I2范式 基本想法，找到一个超平面使几何间隔最大化 几何间隔最大化确定的超平面是唯一的，在此不做证明。 求法： 变换几何间隔到函数间隔，最大化转最小化]]></content>
      <categories>
        <category>机器学习</category>
      </categories>
      <tags>
        <tag>机器学习</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Go学习——《Go语言程序设计》Chap1]]></title>
    <url>%2Fpost%2Feefcc1d7.html</url>
    <content type="text"><![CDATA[开始编辑、编译与运行Go 语言的官方编译器被称为 gc，包括编译工具5g、6g和8g，链接工具5l、6l和8l，以及文档查看工具godoc，这些古怪的命名习惯源自 Plan 9 操作系统，例如用数字来表示处理器的架构（5 代表 ARM，6 代表包括 Intel 64 位处理器在内的 AMD64 架构，而 8 则代表 Intel 386） Go 语言针对的处理单元是包而非文件，这意味着我们可以将包拆分成任意数量的文件。在 Go 编译器看来，如果所有这些文件的包声明都是一样的，那么它们就同样属于一个包，这跟把所有内容放在一个单一的文件里是一样的。 执行顺序：init()-&gt;main()，如果一个包里包含了一个或多个 init()函数，那么它们会在 main()函数之前被自动执行，而且 init()函数不能被显示调用。 :=操作符，在 Go 语言中叫做快速变量声明，这条语句同时声明并初始化了一个变量，也就是说我们不必声明一个具体类型的变量，因为 Go 语言可以从其初始化值中推导出其类型，但需要强调的是，Go 是强类型的语言，即便使用了快速变量声明，后续也只能将对应识别类型的值赋给该变量。 切片1var lowPrimes = []int&#123;2,3,5,7,11,13,17,19&#125; 循环C、C++、Java 习惯的for row := 0; row&lt; len; row++可以，同时也提供for ... range的语法，与 Python 类似，更短更方便。(++在 Go 中只可用于语句而非表达式，更进一步，只可用做后缀操作符而非前缀操作府） 自定义类型及其方法一些 7788虽然 Go 语言支持面向对象变成，但它既没有类也没有继承（is-a 关系）这样的概念。但是 Go 语言支持创建自定义类型，而且很容易创建聚合（has-a 关系）结构。Go 语言也支持将其数据和行为完全分离，同时也支持鸭子类型（一种抽象机制）。 所有这些一起，提供了一种游离于类和继承之外的更加灵活强大的选择，但如果要从 Go 语言的面向对象特性中获益，习惯于传统方法的我们必须在概念上做一些重大调整。 Go 语言使用内置的基础类型如 bool、int 和 string 等类型来表示数据，或者使用 struct 来对基本类型进行聚合 （不同于 C++，Go 的 struct 不是伪类）。 接口也是一种类型，可以通过指定一组方法的方式定义。接口是抽象的，因此不可以实例化。如果某个具体类型实现了某个接口所有的方法，那么这个类型就被认为实现了该接口。 空接口（没有定义方法的接口）用interfae{}来表示，可以用来表示任意值（效果上相当于一个指向任意类型的指针，类似 Java 中的Object或者 C/C++中的void*）。 自定义类型的导入一个 Go 语言程序或者包的导入语句会首先搜索GOPATH定义的路径，然后再搜索GOROOT定义的路径。 包导入路径使用 Unix 风格的“/”来声明。 1234import &#123; "fmt" "stacker/stack"&#125; 自定义类型的定义使用按照管理，该文件开始处生命包，然后导入使用的包 1234567891011package stackimport "errors"// 下面每个export的类型或者方法按照VScode golint的要求需要附上注释说明，以方法/类型名开头// Stack is a typetype Stack []interface()func (stack Stack) Len() int &#123; return len(stack)&#125; 函数和方法都用关键字func定义。但是，定义方法的时候，方法所作用的值的类型需写在func关键字之后方法名之前，并用圆括号包围起来（如上面代码段的stack Stack）。函数或方法名之后，则是小括号包围起来的参数列表，每个参数用逗号分隔（每个参数以variableName type这种形式命名，和 C/C++/Java 类型在前的形式有差别）。参数后面，可以直接是左大括号，或者一个单一返回之，也可以是一对圆括号包围起来的返回值列表之后再紧跟一个作大括号。 调用该方法的值命名，Go 术语为“接收器”，接收器命名与包名并不冲突，区分按值（对原接收器不作改变）、按地址、按引用传递。 Go 语言使用nil来表示空指针（以及空引用），与 C/C++中的 NULL 或 0，Java 中的 null，Objective-C 中的 nil 是等价的。 文件、映射和闭包I/O 处理包 buffio包提供了带缓冲的 I/O 处理的功能，包括从 UTF-8 编码文件中读写字符串的能力。 io包提供了底层的 I/O 功能 io/ioutil包提供了一系列高级文件处理函数 regexp包提供了强大的正则表达式支持 panic 异常在 Go 语言中，panic是一个运行时错误（很像其他语言中的异常，本书将panic直接翻译为“异常”）。我们可以使用内置的panic()函数来触发一个异常，还可以使用recover()函数来在其调用栈上阻止该异常的传播。理论上，Go 语言的panic/recover功能可以用于多用途的错误处理机制，但我们并不推荐这么用。更合理的错误处理方式是让函数或者方法返回一个error值作为其最后或者唯一的返回值（如果没错就返回nil），并让其他调用方式来检查所收到的错误值。panic/recover机制的目的是用来处理真正的异常（即不可预料的异常）而非常规错误。 并发简述Go 语言的一个关键特性在于其充分利用现代计算机的多处理器和多核的功能，且无需给程序员带来太大负担。完全无需任何显式锁 🔓 就可写出许多并发程序（虽然 Go 语言也提供了锁原语以便在底层代码需要用到时使用，我们将在第 7 章中详细阐述）。 Go 语言有两个特性使得用它座并发编程非常轻松。 无需继承什么“线程”（thread）类，就可创建 goroutine（实际上是非常轻量级的县城或者协程）。 通道（channel）为 goroutine 之间提供了类型安全的单项或者双向通信，这也可以用来同步 goroutine。 示例：极坐标到笛卡尔坐标交互程序 引入的包 1234567import ( "bufio" "fmt" "math" "os" "runtime") math包提供了操作浮点数的数学函数 runtime包提供了一些运行时控制 123456789type polar struct &#123; radius float64 θ float64&#125;type cartesian struct &#123; x float64 y float64&#125; 聚合两个内置类型 float64 来构建自定义类型，Go 语言的结构体是一种能够用来保存（聚合或者嵌入）一个或者多个通道据字段的类型。 需要注意通道是，虽然这两个结构体恰好包含了完全相同的通道段类型，但它们仍属不同类型，两者之间也不能自通道地相互转换（这符合我们对强类型语言的印象）。通道 通道基于 Unix 上管道思想被设计出来的，FIFO 队列行为，保序，通道内数据不可被删除。 通道创建 1msessages := make(chan string, 10) 利用make()创建通道，语法为chan Type, num，表示通道接受的数据类型和缓冲区大小。 向通道发送 &lt;-做二元运算符，左操作数必须是一个通道，右操作数必须是发往该通道的数据。I 1messages &lt;- "Leader" 从通道接受 &lt;-做一元运算符，左操作数必须是一个通道，是一个接收器，一直阻塞知道获得一个可以返回的数据。 123456789101112131415161718192021222324252627282930313233343536373839404142func main() &#123; questions := make(chan polar) defer close(questions) answers := createSolver(questions) defer close(answers) interact(questions, answers)&#125;func createSolver(questions chan polar) chan cartesian &#123; answers := make(chan cartesian) go func() &#123; for &#123; polarCoord := &lt;-questions θ := polarCoord.θ * math.Pi / 180.0 // degrees to radians x := polarCoord.radius * math.Cos(θ) y := polarCoord.radius * math.Sin(θ) answers &lt;- cartesian&#123;x, y&#125; &#125; &#125;() return answers&#125;func interact(questions chan polar, answers chan cartesian) &#123; reader := bufio.NewReader(os.Stdin) fmt.Println(prompt) for &#123; fmt.Printf("Radius and angle: ") line, err := reader.ReadString('\n') if err != nil &#123; break &#125; var radius, θ float64 if _, err := fmt.Sscanf(line, "%f %f", &amp;radius, &amp;θ); err != nil &#123; fmt.Fprintln(os.Stderr, "invalid input") continue &#125; questions &lt;- polar&#123;radius, θ&#125; coord := &lt;-answers fmt.Printf(result, radius, θ, coord.x, coord.y) &#125; fmt.Println()&#125; 原理解释： 用户输入了合法数字并已经以polar结构体的格式发送到questions通道，那么就会阻塞主goroutine，等待 answers 通道的响应。createSolver()函数额外创建的一个goroutine会阻塞等待questions通道接收到一个polar类型的数据，因此当我们发送polar数据后，这个goroutine将会执行计算，并将计算结果发送会answer通道，然后等待另一个问题的输入（在开始阻塞自身），而一旦interact()函数在answers通道上接收到cartesian，就不再阻塞，这样就会打印出相关信息。]]></content>
      <categories>
        <category>编程</category>
        <category>Go</category>
      </categories>
      <tags>
        <tag>Go</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[++百里毅行]]></title>
    <url>%2Fpost%2F8278c2d3.html</url>
    <content type="text"><![CDATA[前面九月份看到今年秋季百里毅行开始报名时，基本没怎么犹豫。点开“幺零零”，看了一眼价钱可以接受，便填信息、付款、短信确认，没有拖泥带水，没有呼朋引伴，没有犹豫迟疑，仿佛早就做好了打算要参加一样。事后回想，我好像只是想再去“体验”一下那种感觉，那种可以卸下所有思想的负担，聚焦所有精神到眼前与脚下的感觉。 准备工作是简单的，毅行前的一周每天还是早七点半到图书馆放下资料，上课时间去两百米外的教学楼上个课，该吃饭了就去后湖或者 B 座食堂填饱肚子，只是由于九月和十月落下的脚伤还没有好利索，不时还得穿着洞洞鞋度日，晚上洗完澡要用碘酒擦拭伤口。到了前一天，我采购了一下必要的护膝和热量补充食品，打理好包裹，调整了作息。虽然说最后一天晚上怎样都没有睡着，无梦，但或许是这些天休息的太过充足了，五点钟下了床，拿了包跟舍友说了声再见就出发了（他还没睡）。 我的毅行 “我绝对忘不了可以张开双臂，闭上眼，听着歌，坦荡走的感觉” 只有走在毅行的路上，每个人才能找到行走下去的意义。]]></content>
      <categories>
        <category>随笔</category>
      </categories>
      <tags>
        <tag>随笔</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[行为金融学——禀赋效应]]></title>
    <url>%2Fpost%2F2c8cec8f.html</url>
    <content type="text"><![CDATA[问题 1. 请列举现实生活中或金融决策中禀赋效应的例子禀赋效应重点是发现了人在不同的环境下，对同一个东西的偏好(preference)出现了偏差 (偏好是通过出价，也就是”人愿意付出的最高买价”和”人愿意接受的最低卖价”，来衡量的。 现实生活中只要满足 “当一个人拥有某个东西的时候，他对该物品的估价(或者说偏好)要大于没有拥有该物品的时候（的偏好）”，都可以被说成是“禀赋效应”。 人们对自己的工作、学习成果要比观摩他人的学习、工作成果觉得更有成就感。 “不满意七天可以退货”的商品，或许真的可以退货，但当人把一件商品带回家试用时，“禀赋效应”就已经开始在身上起作用了。人们不太可能把已经拥有的东西退回去。 金融决策中一旦买入某一只股票，立刻对这家公司产生好感。如果股票涨了，舍不得卖。总觉得这只股票非常好，会一直上涨，其实不舍得卖，一方面是贪婪，另一方面是，个人喜爱。下跌时也一样，更多的人看到 5%的亏损，不会立刻出手。他们总是相信自己最初的选择，认为这只股票比其他的强，会莫名其妙的产生好感，不愿意卖出。 问题 2. 假设一个地区正在分配产权，将矿山分给了善于打鱼的渔夫，将渔场分给了擅长采矿的矿工，你觉得他们会怎么做渔夫和矿工都对自己已分配的资源更加珍视，而且考虑到自己已有资源对对方来说利用率更高，且对方占据的资源状况缺少相关信息。 两人都会要求对方除了现有资源外还要附加其他条件来交换自己手里占据的资源，即，渔夫要求矿工用渔场+现金（或者其他补偿）来交换自己手里的矿山，矿工则相反，最终两人难以达成平等高效的贸易交换。]]></content>
      <categories>
        <category>行为金融学</category>
      </categories>
      <tags>
        <tag>行为金融学</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[分布式系统学习——MIT6.824Lec01_Introduction]]></title>
    <url>%2Fpost%2F8df28acc.html</url>
    <content type="text"><![CDATA[Lecture 1: Introduction什么是分布式系统 多台机器共同协作 大型网站的存储，MapReduce，P2P 文件共享，&amp;c 许多关键基础设施是分布式的 为什么需要（选择）分布式 为了连接，组织物理上分离的实体 为了通过隔离（isolation）实现安全性 为了通过备份（replication）实现容错性 为了通过并行的 CPUs，内存，硬盘，网络，实现扩容 担心的地方 多个并发部分导致的复杂性问题 必须处理部分部分失败的情况 难以发挥性能潜力 为什么选择这门课 有趣 — hard problems, powerful solutions 应用在实际系统中 — 被大网站的崛起驱动 活跃的研究领域 — 许多进展产生，同时又有很多待解决的问题 上手做 — 在 labs 实验中会自己动手建立严密的系统 课程组成 课程 大的想法，论文讨论和实验 阅读 研究文献包含经典的和新颖的，文章描述了主要思想和重要的细节。许多 Lec 关注点都放在论文上。请课前阅读研究论文，否则你会觉得上课内容很无聊，而且你无法不费力地学会， 每篇论文都有为你准备的小问题，请务必给我们发送你阅读论文的时候存在的疑问， 晚上十点前给我们发送问题和答案。 两次考试 期中期末考试 实验 实验目标： 深入理解一些重要的技术 掌握分布式编程经验 每周一个 实验安排： Lab 1: MapReduce Lab 2: replication for fault-tolerance using Raft Lab 3: fault-tolerant key/value store Lab 4: sharded key/value 主题这是一门关于会被应用程序抵用的基础设施的课程，它会对应用程序隐藏分布式系统的复杂性而进行抽象，包括下面的三个抽象 存储（Storage） 通讯（Communication） 计算（Computation）。 上述主题会被重复提及。 主题：实现（implementation） RPC 技术, 线程 threads, 并发控制 concurrency control 主题：性能（performance） 理想目标：可伸缩的吞吐量。 通过购买更多的机器就可以实现更大的负载。 随着数量增长，扩展变得困难 负载不均衡，straggler 问题。 不可并行的代码段：如初始化 initialization， 交互 interaction。 由共享资源引起的 Bottleneck，比如网络。 一些无法通过扩展解决的新跟那个问题 比如降低用户相应耗时，可能更需要编程人员的工作而非更多的机器。 主题：容错（fault tolerance） 数千台机器加上复杂网络，总会 something broken，我们希望对应用程序掩藏这些故障，同时我们还希望： 高可用性（Availability）——即便出现故障，应用程序仍能工作。 暂时性（Durability）——故障修复后应用会回归到正常状态。 重要理念：复制服务器。 如果一个服务器崩溃了，客户可以转而使用其他复制的服务器。 主题：一致性（Consistency） 多用途的底层设施需要良定义的行为。例如： Get(k) 获取到的值应该是最近的 Put(k,v)设置的。 但实现良好行为是很困难的 复制的服务端难一实现完全统一。 客户端在进行多步更新的中途崩溃。 服务端在尴尬时刻崩溃，比如执行完成但没来得及反馈信息。 网络可能会使存活的服务器看起来跟挂了一样;存在“脑裂的风险“ 案例学习： MapReduce让我们将 MR 作为一个案例进行讨论。 MR 是课程 6.284 主题的一个很好的例子，也是实验 1 的主要关注点。 MapReduce 概要背景: 几个小时处理完 TB 基本的数据集 例如：实验分析爬行网页的结构，通常不是由分布式系统开发的爱好者开发的这就会非常痛苦，如如何处理错误。总体目标: 非专业程序员可以轻松的在合理的效率下解决的巨大的数据处理问题。程序员定义 Map 函数和 Reduce 函数、顺序代码一般都比较简单。 MR 在成千的机器上面运行处理大量的数据输入，隐藏全部分布式的细节。 MapReduce 的抽象视图 输入原始数据集为 &lt;k1,v1&gt; MR 调用在每个分片上调用 Map()函数，产生中间数据集&lt;k2,v2&gt;（每日此 Map()调用称为一个 Map 任务），并且聚集相同k2值的v2，并将它们传送给 Reduce()函数调用。 最后的输出是数据集&lt;k2,v3&gt; MapReduce API — map(k1,v1) -&gt; list(k2,v2) -&gt; reduce(k2, list(v2)) -&gt; list(k2, v3) MapReduce 举例1234567Map(k,v) split v into words for each word w emit(w,"1")Reduce(k,v) emit(len(v)) MapReduce 隐藏的细节MR 隐藏了很多让人痛苦的细节 如何在 server 上启动 s/w 任务 如何跟踪哪个任务是完成的 数据传输（data movement） 错误恢复 MapReduce 易实现扩展N 台计算机可以同时执行 Nx 个 Map 函数和 Reduce 函数，Map()可以并行执行，因为他们不需要交互（相互等待或共享数据）。Reduce()工作也一样 他们之间的交互仅有 maps 和 reduces 之间的数据传送（”shuffle”）。 因此你可以通过购买更多的计算机来获得更大的吞吐量，而非应用专用的高效并行，计算机要比程序员便宜得多。 什么限制了性能We care since that’s the thing to optimize. CPU？内存？硬盘？网络？ MR 的数据传输都是通过网络进行的，而网络的全内容量通常远小于主机网络链接速度，因此更加关心减少通过网络传输的数据。 更多细节（文章图 1） master：给 workers 分配工作，记录中间输出的位置。 M/R task：输入分割，输入存储在 GFS，每个拷贝三份，全部电脑都运行 GFS 和 MR workers，对于输入的分片远远多于 worker 的数量，master 会让每台机器上面均执行 Map 任务，并在当原来的任务完成之后会处理新的任务， worker 按中间输出的 key 哈希（hash）输出到对应 R 分区保存在本地硬盘上，（提问：这样的实现有什么优势？） 当全部 Maps 任务完成时， Reduces 任务将会开始执行。master 告诉 Reducers 去获取 Map workers 产生的中间数据分区，Reduce worker 将最终的结果输出到 GFS。 有哪些详细的设计帮助提示网络性能 Map 的输入来自建立在本地硬盘上的 GFS 副本而非网络。 中间数据只在网络上面传输一次，Map worker 产生的中间输出保存在本地硬盘，而不是 GFS（不会传 1 备 3）。 中间数据通过 key 被划分到多个文件，”大网络传输“更加有效。（问题：为什么中间数据不通过 TCP 以流的方式传输 reducer） 如何处理负载均衡 对扩展来说至关重要——最坏情况：剩余 N-1 个 server 等待 1 个 server 完成工作。而一些任务很有可能会比其他任务耗时更长。 解决方案：使任务数（task）远大于工作机（worker）的数量，根据不断完成、不断供给的方式使工作机持续工作，这样的分片不会使哪一片任务是过大的以至于影响到总的完成时间，这样快的工作机就会比慢的处理更多任务，最后一同完成整体 MR 工作。 如何处理容错比如：如果服务器在执行 MR 工作时崩溃怎么办？隐藏这个错误非常困难（问题：为什么不重新执行整个工作呢？） MR 只重新执行失败的 Map 函数和 Reduce 函数,他们是纯函数——他们不会改变数据输入、不会保持状态、不共享内存、不存在 map 和 map，或者 reduce 和 reduce 之间的联系， 所以重新执行也会产生相同的输出。纯函数的这个需求是 MR 相对于其他并行编程方案的主要限制，但它同时也对 MR 的简洁性起到了至关重要的作用。 处理 worker 崩溃的细节 Map worker 崩溃 如何发现 worker 崩溃：maskter 发现无法 ping 通 worker，崩溃导致崩溃的 worker 本地储存的中间输出丢失。 Reduce workers 已经获取全部的中间数据，那么 master 不需要重启 Map 函数。 Reduce workers 并未获取全部的中间数据，出发了 reduce 任务的崩溃，那么会前置重新执行依赖的失败的 map 任务。 Reduce worker 崩溃 输出任务是正常的 — 储存在 GFS，伴随副本，master 必须在其他 worker 上面重新开始该任务。 输出过程中崩溃，GFS 会自动进行原子重命名输出，然后使其保持不可见直到 Reduce 完成，所以 master 在其他地方再次运行 Reduce worker 将会是安全的。 其他错误和问题 假如 master 意外的开启两个 Map worker 处理同一个输入（进行相同的 Map 任务）会怎么样？ 它只会告诉 Reduce worker 其中的一个。 假如两个 Reduce worker 处理中间数据的同一个分区会怎么样？ 它们都会将同一份数据写到 GFS 上面，GFS 的原子重命名操作会触发，避免混淆，先完成的获胜将使结果可见。 假如一个 worker 非常慢怎么办（掉队者）？ 产生原因可能是非常糟糕的硬件设施。 master 会对这些最后的任务创建第二份拷贝任务执行（见原文 Backup Tasks）， 假如一个 worker 因为软件或者硬件的问题导致计算结果错误怎么办？ 太糟糕了！MR 假设是建立在”fail-stop”（而非拜占庭故障）的 cpu 和软件之上。 假如 master 崩溃怎么办？ 从 check-point 点恢复，或放弃整个 job，（原文章意思是直接重启整个任务）。 MapReduce 模式适用性并不是所以工作都适合 map/shuffle/reduce 这种模式 小的数据，因为管理成本太高,如非网站后端 大数据中的小更新，比如添加一些文件到大的索引 不可预知的读（Map 和 Reduce 都不能选择输入） 多重传输（Multiple shuffles）, e.g. page-rank (can use multiple MR but not very efficient) 实际 Web 公司如何应用 MapReduce总结Conclusion MapReduce single-handedly made big cluster computation popular. $\times$ 不是最高效灵活的。Not the most efficient or flexible. $\checkmark$ 易于拓展。Scales well. $\checkmark$ 易于编程。Easy to program — failures and data movement are hidden. 上述几点是很好的权衡，在后续课程我们可以看到更多高级、成功的例子。]]></content>
      <categories>
        <category>分布式系统</category>
      </categories>
      <tags>
        <tag>分布式系统</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[数字图像处理——图像复原（频率域）]]></title>
    <url>%2Fpost%2F8809c911.html</url>
    <content type="text"><![CDATA[频率域滤波图像复原在频率域滤波进行图像复原主要在两个方面效果较好，其一是利用频率域滤波消除周期噪声，另一个是利用频率域做退化函数的逆滤波，周期噪声还没有细致研究，这篇文章主要关注其逆滤波相关的问题。 为什么要在频率域做逆滤波？观察之前退化模型的两个式子，我们不难发现： g(x,y) = h(x,y) \star f(x,y) + \eta(x,y) \tag 1g(u,v) = H(u,v) F(u,v) + N(u,v) \tag 2对(1)式空间域来说，想要从$g(x,y)$恢复$f(x,y)$，避不开的是“卷积”的逆运算，这在定义和实现的复杂上都比较困难，而转化到频率域，从(2)式我们或许可以通过一个“除法”来实现逆滤波，结合之前噪声模型相关内容，我们尝试在频率域上对仅退化函数影响的图像，和更复杂一些的，退化函数和加性噪声双重影响的图像进行复原。 估计退化函数在图像复原时，主要有 3 种用于估计退化函数的方法：（1）观察法，（2）试验法，（3）数学建模法。这里我们着重讲建模估计。 湍流模糊 Hufnagel and Stanley[1964]根据大气湍流的物理特性提出了一个退化模型，其通式为： H(u,v) = e^{-k{(u^2+v^2)}^{5/6}}式中，$k$是与湍流性质有关的常熟。除了指数为$5/6$之外，该式与高斯低通极其相似。 实现： 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748def getVesMask(mask_shape,k): rows,cols = mask_shape[0],mask_shape[1] crow = rows/2 ccol = cols/2 mask = np.zeros((rows,cols)) for i in range(rows): for j in range(cols): dis = (i-crow)**2 + (j-ccol)**2 mask[i,j] = np.exp(-k*(dis**(5/6))) return maskdef getVesFilterPassImg(input_img : np.array, k , size = None): f_img = np.fft.fft2(input_img , s = size) shift_img = np.fft.fftshift(f_img) mask_shift_img = getVesMask(f_img.shape,k) new_shift_img = mask_shift_img*shift_img new_manitude_img = 20*np.log(np.abs(new_shift_img+eps)) new_f_img = np.fft.ifftshift(new_shift_img) new_img = np.fft.ifft2(new_f_img) new_img = np.abs(new_img) return new_img# 测试# 参数设置mask_shape = (480,480)k = [0,0.0025,0.001,0.00025]plt.figure(figsize=(12,12))ax = [plt.subplot(221,projection = "3d"),plt.subplot(222,projection = "3d"),plt.subplot(223,projection = "3d"),plt.subplot(224,projection = "3d")]# 获得滤波器for i in range(4): if i == 0: drawPerspective(ax[i],np.ones(mask_shape),title ="Original Img",cmap = "gray") else: myfilter = getVesMask(mask_shape,k[i]) drawPerspective(ax[i],myfilter,title = f"Ves Mask with $k=&#123;k[i]&#125;$", cmap = "gray")plt.show()test_img = cv2.imread("./5_3Photo/Fig0525(a).tif",0)plt.figure(figsize=(12,12))ax = [plt.subplot(221),plt.subplot(222),plt.subplot(223),plt.subplot(224)]for i in range(4): if i == 0: ax[i].imshow(test_img,cmap = "gray") ax[i].set_title("Original Img") else: out_img = getVesFilterPassImg(test_img,k[i]) ax[i].imshow(out_img,cmap = "gray") ax[i].set_title(f"Ves Mask with $k=&#123;k[i]&#125;$") 运动模糊 是从基本原理开始推导的一个数学模型，光学成像图像获取时被被图像与传感器之间的均匀线性运动模糊了，最终$g(x,y)$反映为$f(x,y)$不同时间间隔内瞬时曝光量叠加形成的，（空间域）数学表达为： g(x,y) = \int_0^{T}{ f [x-x_0(t),y-y_0(t)] } \mathrm{d}t频率域中的操作，应用傅里叶变换，中间省略，最后根据$F(u,v)$与$t$无关得出，我们想要的频率域退化函数表达： H(u,v) = \int_0^T {e^{-j2\pi[ux_0(t)+vy_0(t)]}} \mathrm{d}t满足 x,y 方向做匀速直线运动$x_0(t) = at/T$和$y_0(t) = bt/T$，则退化函数可以直接由上式得。 H(u,v) = \dfrac{T}{\pi (ua+vb)} sin[\pi(ua+vb)] e^{-j\pi[ua+vb]}那么我们用$(u,v)$对该式取样，就可以生成一个离散滤波器，我的实现是（这个实现 bug 了）： 1234567891011121314151617181920212223242526272829303132333435363738def getMoveMask(mask_shape,param_a,param_b,param_T): rows,cols = mask_shape[0],mask_shape[1] crow = rows/2 ccol = cols/2 mask = np.zeros((rows,cols), dtype = np.complex) for i in range(rows): for j in range(cols): if i == 0 and j== 0: continue else: temp = i*param_a+j*param_b temp2 = np.exp(np.complex(0,-np.pi*temp)) mask[i,j] = temp2*np.sin(np.pi*temp)*param_T/(np.pi*temp) return maskdef getMoveFilterPassImg(input_img : np.array, a,b,T , size = None): f_img = np.fft.fft2(input_img , s = size) shift_img = np.fft.fftshift(f_img) mask_shift_img = getMoveMask(f_img.shape,a,b,T) new_shift_img = mask_shift_img*shift_img new_manitude_img = 20*np.log(np.abs(new_shift_img+eps)) new_f_img = np.fft.ifftshift(new_shift_img) new_img = np.fft.ifft2(new_f_img) new_img = np.abs(new_img) return new_img,new_manitude_imgtest_img = cv2.imread("./5_3Photo/Fig0526.tif",0)a = 0.2b = 0.15T = 1plt.figure(figsize=(12,6))ax1 = plt.subplot(121)ax2 = plt.subplot(122)ax1.imshow(test_img,cmap = "gray")ax1.set_title("Original Img2")out_img,test = getMoveFilterPassImg(test_img,a,b,T)ax2.imshow(out_img,cmap="gray")plt.show() 12345678910111213141516171819202122232425262728293031323334def getMotionMask(mask_shape,param_len,param_theta): rows,cols = mask_shape[0],mask_shape[1] crow = (rows-1)/2 ccol = (cols-1)/2 mask = np.zeros((rows,cols)) sin_val = np.sin(param_theta*np.pi/180) cos_val = np.cos(param_theta*np.pi/180) for i in range(param_len): x_offset = round(sin_val*i) y_offset = round(cos_val*i) mask[int(crow+x_offset),int(ccol+y_offset)] =1 mask = mask/mask.sum() return np.fft.fft2(mask)def getMotionFilterPassImg(input_img : np.array, l,t , size = None): f_img = np.fft.fft2(input_img , s = size) mask_img = getMotionMask(f_img.shape,l,t) new_img = f_img*mask_img new_img = np.fft.ifft2(new_img) output_img = np.fft.ifftshift(new_img) output_img = np.abs(output_img) return output_imgtest_img = cv2.imread("./5_3Photo/Fig0526.tif",0)l = 50t = 30plt.figure(figsize=(12,6))ax1 = plt.subplot(121)ax2 = plt.subplot(122)ax1.imshow(test_img,cmap = "gray")ax1.set_title("Original Img2")out_img = getMotionFilterPassImg(test_img,l,t)ax2.imshow(out_img,cmap="gray")plt.show() 逆滤波退化函数已给出，或者由上面退化函数的估计方法获得后，最简单的复原方法是直接做逆滤波，即： \hat{F}(u,v) = \dfrac{G(u,v)}{H(u,v)}然而根据前述我们知道，在噪声的影响下，$\hat{F}(u,v)$和$F(u,v)$仍有差别，即 \hat{F}(u,v) = F(u,v) \dfrac{N(u,v)}{H(u,v)}这个式子两点启发： 知道退化函数也不能完全复原未退化图像，因为噪声函数未知。 如果退化函数是零或是非常小的之，那么噪声影响会被放大 最小均方误差（维纳）滤波实际上维纳滤波是在这里是相对逆滤波来说的，而并非指特别的滤波函数，且不仅应用在运动模糊滤波中。 \hat{F}(u,v) =[\dfrac{1}{H(u,v)} \dfrac{ {|H(u,v)|}^2 }{ {|H(u,v)|}^2+ S_{\eta}(u,v)/S_f(u,v) }] G(u,v)$S_{\eta}(u,v)$为噪声的功率谱而$S_f(u,v)$是未退化图像的功率谱，比值为噪信比。而由于谱${|N(u,v)|}^2$是一个常数，这大大简化了处理。我们常用下面的表达式来近似。 \hat{F}(u,v) =[\dfrac{1}{H(u,v)} \dfrac{ {|H(u,v)|}^2 }{ {|H(u,v)|}^2+ K }] G(u,v)123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051def wienerFiltering(input_img, h, NSR ,htype = "frequency"): assert htype in ("frequency","spatial") # 输入图像的傅里叶变换 input_img_fft = np.fft.fft2(input_img) input_img_fft = np.fft.ifftshift(input_img_fft) if(htype == "spatial"): # 模糊化函数的傅里叶变换 h_fft = np.fft.fft2(h) else : h_fft = h # 退化函数模值的平方 h_abs_square = np.abs(h_fft)**2 # 维纳滤波 # 使用的是 共轭/模方+NSR的形式，并非 9 10 式 output_image_fft = np.conj(h_fft) / (h_abs_square + NSR) # 输出图像傅里叶反变换 output_image = np.fft.ifft2(output_image_fft * input_img_fft) output_image = np.abs(np.fft.fftshift(output_image)) return output_image# 测试 逆滤波nsr = 0h = getMotionMask(test_img.shape,l,t)output_img= getMotionFilterPassImg(test_img,l,t)plt.figure(figsize=(12,6))ax1 = plt.subplot(121)ax2 = plt.subplot(122)ax1.imshow(output_img,cmap = "gray")ax1.set_title("Original Img2")inverse_img = wienerFiltering(out_img,h,nsr,"frequency")ax2.imshow(inverse_img,cmap="gray")plt.show()nsr = 0.01h = getMotionMask(test_img.shape,l,t)output_img = getMotionFilterPassImg(test_img,l,t)plt.figure(figsize=(12,6))ax1 = plt.subplot(121)ax2 = plt.subplot(122)ax1.imshow(output_img,cmap = "gray")ax1.set_title("Original Img2")inverse_img = wienerFiltering(out_img,h,nsr,"frequency")ax2.imshow(inverse_img,cmap="gray")plt.show()]]></content>
      <categories>
        <category>数字图像处理</category>
      </categories>
      <tags>
        <tag>数字图像处理</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[数字图像处理——图像复原（空间域）]]></title>
    <url>%2Fpost%2Fc7192b31.html</url>
    <content type="text"><![CDATA[空间域滤波图像复原在5_1 图像复原与重建初步中，我们研究了图像的噪声退化模型，以及常见的噪声模型及其实现，实际上这些噪声模型帮我们解决了前一篇文章(1)式中$\eta(x,y)$的取值问题，同时再观察(1)式我们也能发现，当一幅图像中唯一存在的退化是噪声时，式(1)和式(2)会变成（简化）如下： g(x,y) = f(x,y) + \eta (x,y)和 G(u,v) = F(u,v) + N(u,v)我们发现没了“退化函数”，复原在空间域和频率域都是一个可加形式，估计噪声情况后，便可得到原图像的一个估计，故在仅存在加性噪声的情况下，可以选择空间滤波方法。 一些简单实现在前面第三章已经讨论过，比如算数均值滤波器，这一章节主要是做更深入的研究。 均值滤波器统计排序滤波器自适应滤波器有待后续学习补充。]]></content>
      <categories>
        <category>数字图像处理</category>
      </categories>
      <tags>
        <tag>数字图像处理</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[数字图像处理——图像复原与重建初步]]></title>
    <url>%2Fpost%2F199b3bb2.html</url>
    <content type="text"><![CDATA[图像复原与重建初步梳理所学重点知识 引言前面所接触的图像增强是一个，已知原图像，经处理后，得到增强图像的一个过程，而这一章将要深入的图像复原（重建），则是希望从（被污染）过的图像，经处理后，得到原图像的过程，是以预先确定的目标来改善图像。图像复原试图利用退化现象的某种先验知识来复原被退化的图像。因而，复原技术时面向退化模型的，并且采用相反的过程进行处理，以便恢复出原图像。虽然图像增强和图像复原两者在覆盖的领域和使用的技术栈有所重叠，其中还是有几点区别我们还是要提起注意的。 形象化的描述 图像增强主要是一个主观的过程，而图像复原大部分是一个客观的过程。 已知与未知的区别 图像增强已知原始图像与变换（卷积核或者其频率域的谱），对于增强效果是未知且非预先确定的（只有一个大概方向，比如模糊还是锐化），而图像复原则已知污染图像，且对原始图像是预先确定的（测试条件下甚至是有标准比对的原始图像，是已知的），对于复原变换（污染变换的逆）常常是未知的，这就要求我们在做图像处理时常常需要“估计”我们的复原变换。 期望与探索的区别由于两者已知和未知上的差距，这就导致图像复原通常会涉及设立一个最佳准则来产生期望结果的最佳估计。相比之下，图像增强技术基本上是一个探索性过程，即根据人类视觉系统的生理特点来设计改善图像的方法。 背景知识线性系统可加性，$x_1(t)+x_2(t) = y_1(t)+y_2(t)$，从而有$a \times x_1(t) = a \times y_1(t)$ 平移不变性 卷积卷积、离散二维卷积 从而可以利用卷积这个工具。 冲激响应：输入为一个脉冲信号，输出是一个冲激响应$h(x)$，实际上可以就是之前接触过的卷积核。 图形复原复原 试图利用退化过程的先验知识使已退化的图像恢复本来面目 根据退化的原因，分析引起退化的环境因素 建立相应的数学模型 沿着使图像降质的逆过程回复图像 目的 在于消除或减轻退化的影响 方法 由于退化系统是黑盒的，盲复原往往很困难，噪声干扰也为复原过程带来了困难和不确定性 图像复原是寻求在一定优化准则下的原始图象的最有估计。因此，不同的优化准则会获得不同的图像复原。评价指标的选择目前也是研究的方向之一，如峰值信号比等。 图像退化/复原过程模型退化过程（污染过程）的描述：建模为一个退化函数和一个加性噪声项，对于输入图像（原图像）$f(x,y)$进行处理，产生一副退化后的图像$g(x,y)$，图像复原目的就是已知$g(x,y)$的前提下，希望得到原图像的一个估计，这个估计越接近原始输入图像越好。空间域中的退化图像可由下式给出： g(x,y) = h(x,y) \star f(x,y) + \eta(x,y)上式中$h(x,y)$是退化函数的空间表示，由第四章内容，我们可以将上式的模型写成等价的频率域表示： g(u,v) = H(u,v) F(u,v) + N(u,v)这两个式子是本章后面大部分复原内容的基础。 噪声模型噪声的空间和频率特性一些重要概念： 当噪声的傅里叶谱是常量时，噪声通常成为白噪声，这个术语是从白光的物理特性派生出来的，它以相等的比例包含可见光谱中的几乎所有频率。 除了空间周期噪声之外，本章假设其他噪声与空间坐标无关，并且噪声与图像本身不想管（即像素值与噪声成分的值之间不相关）。虽然这些假设至少在某些应用中（例如 X 射线和医学成像的有限量子成像就是一个很好的例子）是无效的，但处理空间相关和相关性噪声的复杂性超出了我们讨论的范围。 一些重要的噪声概率密度函数概率论回顾 高斯（正态）噪声 其 PDF 由下式给出： p(z) = \dfrac{1}{\sqrt{2 \pi} \sigma} e^{ \frac{ {(z- \overline{z})}^2 }{2 \sigma^2} }$\overline{z}$表示$z$的均值，$\sigma$表示$z$的标准差。 瑞利噪声 其 PDF 由下式给出： $$ p(z)=\left \{ \begin{aligned} \frac{2}{b}(z-a)e^{ \frac{-{(z-a)}^2}{b} } & , & z \ge a \\ 0 & , & z < a \end{aligned} \right. $$ 概率密度的均值与方差的给出：$\overline{z} = a + \sqrt{ \pi b / 4}$，$\sigma ^2 = \dfrac{b(4-\pi)}{4}$ 爱尔兰（伽马）噪声 其 PDF 由下式给出： $$ p(z)=\left \{ \begin{aligned} \dfrac{a^b z^ {b-1} } { (b-1)!}e^{ -az} & , & z \ge a \\ 0 & , & z < a \end{aligned} \right. $$ 概率密度的均值与方差的给出：$\overline{z} = \dfrac{b}{a}$ ，$\sigma ^2 = \dfrac{b}{a^2}$ 指数噪声 其 PDF 由下式给出： p(z)=\left \{ \begin{aligned} ae^{ -az} & , & z \ge a \\ 0 & , & z < a \end{aligned} \right.可以看作是$b=1$时爱尔兰 PDF 的特殊情况。概率密度的均值和方差是：$\overline{z} = \dfrac{1}{a}$，$\sigma^2 = \dfrac{1}{a^2}$ 均匀噪声 其 PDF 由下式给出： p(z)=\left \{ \begin{aligned} \dfrac{1}{b-a} & , & a \le z \le b \\ 0 & , & 其他 \end{aligned} \right.概率密度的均值与方差的给出：$\overline{z} = \dfrac{a+b}{2}$，$\sigma^2 = \dfrac { { (b-a)}^2}{12}$ 脉冲（椒盐）噪声 其 PDF 由下式给出： p(z)=\left \{ \begin{aligned} P_a & , & z = a \\ P_b & , & z = b \\ 1-P_a-P_b & , & 其他 \end{aligned} \right. 12345678910111213141516171819202122# 编写 添加噪声函数 并显示噪声情况def getGaussianNoise(loc,scale,size = None): return np.random.normal(loc,scale,size)def getRayleighNoise(scale,size = None): # b = 2 scle^2 这里统一根据使用 scale return np.random.rayleigh(scale,size)# 测试，展示高斯和瑞利的分布直方图mu = 0.5sigma = 0.1sigma2 = 0.2gnoise = getGaussianNoise(mu,sigma,1000)rnoise = getRayleighNoise(sigma2,1000)plt.figure(figsize=(10,7))ax1 = plt.subplot(111)ax1.hist(gnoise,80,density = True,histtype = 'stepfilled',edgecolor = "white",label = "Gaussian Noise",alpha = 0.7)ax1.hist(rnoise,80,density = True,histtype = 'stepfilled',edgecolor = "white", label = "Rayleigh Noise" , alpha = 0.7)ax1.legend()plt.show() 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849# 给图像加噪声def getGaussianNoiseImg(input_img, loc, scale,rate = 1): """ getGaussianNoiseImg 获得被高斯白噪声污染的图像 :param input_img: 输入原始图像 :param loc: 高斯分布均值 :param scale: 高斯分布标准差 :return: 加噪的图像 """ float_img = np.array(input_img/255, dtype = np.float64) noise = np.random.normal(loc,scale,float_img.shape) output_img = float_img+noise*rate output_img = np.clip(output_img,0,1.0) output_img = np.uint8(output_img*255) return output_imgdef getRayleighNoiseImg(input_img, scale,rate = 1): """ getRayleighNoiseImg 获得被瑞利白噪声污染的图像 :param input_img: 输入原始图像 :param scale: 瑞利分布的scale 与b相关 a为0（没找到调整方法） :return: 加噪的图像 """ float_img = np.array(input_img/255, dtype = np.float64) noise = np.random.rayleigh(scale,float_img.shape) output_img = float_img+noise*rate output_img = np.clip(output_img,0,1.0) output_img = np.uint8(output_img*255) return output_imgmu = 0.5sigma1 = 0.1sigma2 = 0.2img1 = cv2.imread('./5_1Photo/Fig0503.tif',0)gnoise_img1 = getGaussianNoiseImg(img1,mu,sigma1,0.3)rnoise_img1 = getRayleighNoiseImg(img1,sigma2,0.5)img2 = getRGB('./5_1Photo/4.tif')gnoise_img2 = getGaussianNoiseImg(img2,mu,sigma1,0.3)rnoise_img2 = getRayleighNoiseImg(img2,sigma2,0.5)showThreeImg(img1,gnoise_img1,rnoise_img1,"Original Img1","Gaussian Noise with rate = 0.3","Rayleigh Noise with rate = 0.5")showThreeImg(img2,gnoise_img2,rnoise_img2,"Original Img2","Gaussian Noise with rate = 0.3","Rayleigh Noise with rate = 0.5")]]></content>
      <categories>
        <category>数字图像处理</category>
      </categories>
      <tags>
        <tag>数字图像处理</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[数据分析与融合——偏序格角度看决策系统代数约简]]></title>
    <url>%2Fpost%2Fbe292322.html</url>
    <content type="text"><![CDATA[偏序格角度看决策系统代数约简基本知识： 一个集合的所有划分构成一个细分偏序格。 决策系统约简始终保持决策系统的一致性（不存在条件相同，决策不同）。 对于一个决策系统来说，约简是条件分类$U/C → U/A$的过程，而条件分类$U/C$细分$U/A$。 引发思考： 课程的结尾老师提到我们的决策系统约见过程，其条件分类可以看作是在一个论语元素的全部划分构成的细分偏序格上寻优的过程。 直观上给人的感觉是这样的，这篇文章主要是想回过头来，从偏序格角度回看这一寻优过程，并解决以下疑惑： Q1.为什么可以看做是细分偏序格上的寻优？ Q2.寻优的终点（极小值）对应的是哪个（些）结点，有没有什么特征？ Q3.寻优的路径是怎样的，有没有什么特征，是否会与“偏序”产生关系？ 带着这些疑问，我开始了自己的琢磨。 由于里面一些很数学的东西并没有细致详尽的证明，我只能从数学角度看待，还不算科学的证明，有待于后面复习时巩固数学部分的证明。 Q1.寻优的解释为方便描述，我们使用老师所给出的决策系统样例。 同时做以下约定，与一些教材（包括老师提供的讲稿）中有些许不同： $U$为论域元素集合 $Road_1,Road_2 \cdots$ 表示约简路径 1，2 等等。 $C$为最初的属性集合，为方便约见过程中属性集的变换，我们再做以下规定。 $C_{i1}$表示约简路径$Road_i$上的第$1$次约简后的属性集，及初始状态，所以易知，$C_{i0} = C$ $C_{ij},j \not ={0}$表示约简路径$i$上的第$j$次约简后的属性集。 $D$为决策值集合 约定都完成了，我们该如何解释“约简”可以看做是细分偏序格上的寻优过程呢？我想可以从细分偏序格上结点，和路径两点与我们约简不同阶段的状态和转移过程对应起来 结点 and 状态细分偏序格图示上每个结点对应一个划分，而我们决策系统约简过程中，每一个约简前后的状态实际上也是一个论域的划分。 举例 1，根结点，未分类状态。 此时也未进行决策系统一致性检测，这么说的原因是，我们还未用$C_{i1}$进行任何一次属性集上的等价类划分，此时每个元素都是相互分开的， 举例 2，初始决策系统检测结点，由于我们这个表中没有重复项，所以应用$C_{i1} = C$（对于任意一条路径都一样，所以用了$i$表示），得到的划分仍然是原来的划分（对于带重复项的则不然）。 举例 3，$C_{01} = C_{00}- a_1$，约简$a_1$后，划分$U/C_{11} = \{ \{ x_1, x_6 \} , \{ x_2, x_8 \} , \{ x_3 \} , \{ x_4 \} ,\{ x_5 \} , \{ x_7 \} \}$。 其对应的结点为 路径 and 转移过程在最前面的基本知识已经提到了： 对于一个决策系统来说，约简是条件分类$U/C → U/A$的过程，而条件分类$U/C$细分$U/A$。 换言之，我们一条路径上约简的结点状态变化应该为$U/C_{i1} \rightarrow U/C_{i2} \rightarrow U/C_{i3} \cdots$，而前者都是细分后者的，所以必然是细分偏序格向上的方向。 一点数学解释：由于是约简，我们可以确定一条路径上 $C_{ij}\subseteq C_{ik}$对任意$j&lt;k$，故其确定的等价关系 $R_{ij} \subseteq C_{ik}$，而由商集的性质易知其细分关系。 举例，如约简两次达到最终的不可约简状态，转移图。 需要提起注意的是，箭头并非只代表细分偏序格 Hasse 图中的那些边，而是代表 precede，可能是多条 Hasse 图中边（即跨越了一些状态），这也是我后面探索的问题的来源。 Q2.最终状态点与极小属性集在课上我也问到了老师这样一个问题，我们找到的约见后条件属性集是“极小”而非最小，因而有可能会存在多个。 而这个样例中确实存在两个“极小”。分别应该是： $C_{13} = \{a_2,a_3 \}$ 即刚刚演示的路径和最终状态 $C_{23} = \{a_2,a_4 \}$ 进一步观察，他们对应细分偏序格上的状态是不同的（路径也是不同的），也即$U/C_{13} \not ={ U/C_{23}}$，相同特征是，他们必位于他们各自寻优路径 他们对应的划分如下： U/C_{13} = \{ \{ x_1, x_6 \} , \{ x_2, x_8 \} , \{ x_3 \} , \{ x_4 ,x_5 \} , \{ x_7 \} \}U/C_{23} = \{ \{ x_1, x_6 \} , \{ x_2, x_8 \} , \{ x_3 \} , \{ x_4 ,x_7 \} , \{ x_5 \} \}路径图示如下： 发现改变在$x_4,x_5,x_7$上，试图寻找一些关联性。我回去复查了以下原始的表。 发现在决策列$x_4,x_5,x_7$均为$1$，这其中有什么相关性吗？联想上图下面给出的决策划分： U/D = \{ \{ x_1, x_3 ,x_6 \} , \{ x_2, x_4,x_G5 ,x_7, x_8 \} \}同时联想到我们约简过程，相对正域，始终都必须要满足我们的条件划分元素$X_i$被决策划分的元素$Y_j$包含，所以我们的约简过程最初就存在一个上界，就是$U/D$，图示如下。 还是数学上的解释，唯有当我们的划分$U/C = U/D$即条件划分与决策划分相等时，这时就存在寻优后的“最小”集了，而且是唯一的，除此之外，都有可能出现多条路径多种划分方式，而且不同路径上的划分状态一般是不可比的（除非是“分叉”路径，后面会举例），如下面$U/C_{23}$和$U/C_{12}$就不具备可比性。 还有一些其他性质，比如我们发现的$x_4,x_5,x_7$决策值相等，我们实际上时可以证明的。当两个极小划分满足下列情况时有相关结论： 划分$U/C_p$有如下元素$\{ x_i,x_k , \cdots \}$ 划分$U/C_q$有如下元素$\{ x_i,x_l , \cdots \}$ 则可证$x_i[d] = x_k[d] = x_l[d]$ ，其中$[d]$表示元素对应的决策值。 证明：可用上述上界证明，由于$U/D$的存在，而$U/C_p \le U/D$，$U/C_q \le U/D$，则$U/D$中必存在一集合$A$，满足$x_i,x_k,x_l \in A$，因而三者的决策值相等。 Q3 寻优路径相关根据前述，我已经解释过，我们一次约简并不对应 Hasse图中的一条短边，而可能是多条边的集合，上面的手绘图已经给出了，从根节点到原属性划分时的跳跃情况。 这里，我关心的心问题是，对于$Road_1$来说，由偏序关系，当我确定我一条路径的最终状态$U/C_{13}$，这个划分后，易知其必定被其他$U/C_p$细分，$C_p$满足$C_p \subseteq C_{13},C_{13} = \{a_2,a_3\}$ ，而与我去掉属性的先后顺序无关，简言之，对于我们实验的这个表，实际上还有很多路径，现在尝试手绘描述以下。 绿色框特殊标注，因其在后面可以产生到两个极小的状态。 这也实验直观感受了，即便我们的寻优是多条 Hasse 图边的组合，其路径依然在最终状态确定后反推时具备多样性。]]></content>
      <categories>
        <category>数据分析与融合</category>
      </categories>
      <tags>
        <tag>数据分析与融合</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[人机交互——中南大学计算机学院主页Web交互设计文档]]></title>
    <url>%2Fpost%2Fa793738.html</url>
    <content type="text"><![CDATA[全局说明权限说明访问权限由指定 URL 均可访问本网站。 访问者均以游客身份访问，主页上没有“登录”或注册等功能引导，主要以学院内容展示为主。 交互说明键盘交互针对 PC 端和 iPad（平板电脑）设备端，进行内容搜索时不上浮出底部的字母键盘，而是直接交由键盘进行交互。 页面交互 图标：通过点击指定图标显示下拉菜单、唤醒弹窗或实现页面跳转。 图片：概览界面图片点击会进入对应的详情界面，详情界面图片不再设计其他交互细节。 文字：概览界面文字标题点击会进入对应的详情界面，文字导航也同样实现该效果，对应页面内的正文不再设计其他交互细节。 其他机制与规则排序规则通知按发布的时间先后顺序，降序排列展示 搜索规则搜索结果按匹配度和相关度综合排序，降序排列展示 页面功能详细说明主页颜色：#0d5690 校徽院徽 校徽院徽部分设计保持不变，并保持整体底色为中南蓝。 导航按钮 增加按钮样式，触发导航栏时更改其图标样式。 导航栏 移动端导航栏参考清华大学、北京大学、上海交通大学移动端主页的设计，发现导航栏动态隐藏、显示的模式常会出现以下问题： 布局与便捷性冲突 点击导航按钮后触发弹出的数个菜单栏，对于一般学院网站，导航栏栏数并不少，这样就导致了，导航栏使用便捷性与保护原有页面布局两难问题的出现。以中南大学计算机学院现有移动端主页和北京大学现有移动端主页为例： 点击导航栏图标后，中南计算机院采取的策略是从顶栏（包含校徽院徽）下面插入多条导航栏目，每一条所占空间为一行。保证了一定的便捷性（不同栏目不大会误触），但是不得已把所有主体内容推到下方，略微给人一种“脖子长”的感受，难以保证原有的布局风格与内容。 北大的策略类似，只是整体的导航部分都抬到了头部，且每个导航项目不再占完整一行，而是三个占据一行，牺牲了一定的便捷性（栏目更加聚集，误触易，区分难），虽然还是可以展示一些主体内容，布局还是受到了一定程度的影响，给人一种“顶部重压”的感觉。 个人觉得清华的移动端 滚动图片 新闻烂 通知公告分栏 学术信息分栏 科研动态分栏 学工动态分栏 备案联系栏]]></content>
      <categories>
        <category>人机交互</category>
      </categories>
      <tags>
        <tag>人机交互</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[数字图像处理——理想滤波器与振铃特性]]></title>
    <url>%2Fpost%2F430a4378.html</url>
    <content type="text"><![CDATA[理想滤波器频率域平滑锐化常用的几个滤波器的数学表达和实现都已经在数字图像处理——频率域平滑锐化图像常用滤波器一文中实现。 之前我们讨论到了振铃现象，本文中的实验主要是动手实现测试了 ILPF 对图片的模糊效果及其振铃现象，并且跟随课本尝试解释 ILPF 在空间域的振铃特性。 理想低通滤波器 ILPF描述如下 H_{ILPF}(u,v) = \left \{ \begin{aligned} 1, & D(u,v) \le D_0 \\ 0, & D(u,b) > D_0 \end{aligned} \right.其中$D_0$是一个正常数，$D(u,v)$表示频率域中的点$(u,v)$距离频率域中心$(\frac{P}{2},\frac{Q}{2})$的距离。 理想高通滤波器 IHPF描述如下 H_{IHPF}(u,v) = \left \{ \begin{aligned} 0, & D(u,v) \le D_0 \\ 1, & D(u,b) > D_0 \end{aligned} \right.代码实现代码实现getIdealMask()也在数字图像处理——频率域平滑锐化图像常用滤波器给出，在此不再转述。 两组测试均为 100x100 大小，截至半径为 20 的低通和高通滤波器实验结果。 使用一个 ILPF 平滑图像1234567891011121314151617181920212223242526def getIdealFilterPassImg(input_img : np.array, filter_type : str , filter_d0, size = None): assert filter_type in ("lpf","hpf") # 内部进行填充 （mask大小与原图相等 进行2K-1的0填充） pad_img = getPaddingImg(input_img,input_img.shape,"corner") f_img = np.fft.fft2(input_img , s = size) shift_img = np.fft.fftshift(f_img) mask_shift_img = getIdealMask(f_img.shape,filter_d0,filter_type) new_shift_img = mask_shift_img*shift_img new_manitude_img = 20*np.log(np.abs(new_shift_img+eps)) new_f_img = np.fft.ifftshift(new_shift_img) new_img = np.fft.ifft2(new_f_img) new_img = np.abs(new_img) # 内部进行裁剪 new_img = cutOriginalImg(new_img, input_img.shape, "corner") return new_img,new_manitude_img,mask_shift_img# 使用书上例子，cv库读取图像original_img = cv2.imread('./DIP3E_Original_Images_CH04/Fig0441(a)(characters_test_pattern).tif',0)# 设定截止半径d_list = [10,30,60,160,460]for d in d_list: smmoth_img,manitude_img,mask_img = getIdealFilterPassImg(original_img, "lpf" , d) showTwoImg(smmoth_img,manitude_img,f"Smooth Img with $D_0$ = &#123;d&#125;", f"Manitude with $D_0$ = &#123;d&#125;") 振铃现象由上图可以看出随着阈值增大，频谱中保留功率的增大，图像细节逐渐明晰，模糊效果越来越差。这说明我们的滤波器是成功的（不过这里与课本 P171 图比较会清晰一些，不清楚原因） 另外，我们也可以很明显的发现振铃现象，间隙处原本统一的纹理由于模糊变得有明暗起伏。而随着被滤去的高频内容的数量的减少，图像的纹理变得越来越好，甚至我们仔细看第三幅图，也能发现振铃现象的纹理，课本是这么评价振铃现象和 ILPF 的。 这种振铃现象是理想滤波器的一种特性，从这个例子我们可以清楚地看到，理想低通滤波器并不是非常实用。然而，作为滤波概念发展的一部分，研究这种滤波器的特性非常有用。 振铃现象的一些见解12345678910111213141516171819# 绘制空间域表示图和水平线灰度剖面图for d in d_list: fre_mask=getIdealMask((688,688),d,"lpf") spa_mask=frequencyToSpatial(fre_mask) X = [i for i in range(spa_mask.shape[0])] Y = spa_mask[spa_mask.shape[0]//2] plt.figure(figsize=(8,4)) ax1 = plt.subplot(121) ax2 = plt.subplot(122) ax1.set_title(f"Spatial Img with $D_0 = &#123;d&#125;$") ax2.set_title(f"Grayscale with $D_0 = &#123;d&#125;$") ax1.imshow(spa_mask,cmap = "gray") ax2.plot(X,Y) ax2.spines['left'].set_color('none') ax2.spines['top'].set_color('none') ax2.spines['right'].set_color('none') ax2.set_yticks([]) ax2.set_yticklabels([]) 分别对应了上面的阈值，观察其滤波器的空间与表示，在$D_0$较小的时候有很明显的波动函数形状。 ILPF 的模糊和振铃特性可用卷积定理来解释。由于 ILPF 在频率域的剖面图类似于盒状滤波器，因此可以预料相应空间滤波器具有 sinc 函数形状。空间域滤波可通过$h(x,y)$于图像卷积来实现。讲图像中的每个像素想象为一个离散冲击，它的强度与所在位置的灰度成正比。一个 sinc 函数与一个冲激卷积就是在冲激处复制这个 sinc 函数。sinc 函数的中心波瓣是引起模糊的主因，而外侧较小的波瓣是造成振铃的主要原因。sinc 函数“展开度”与$H(u,v)$半径成反比，所以$D_0$越大，空间 sinc 函数就趋近于一个卷积时不会导致模糊但也不会产生振铃的冲激]]></content>
      <categories>
        <category>数字图像处理</category>
      </categories>
      <tags>
        <tag>数字图像处理</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[数字图像处理——高斯滤波器与零填充避免DFT固有周期性影响]]></title>
    <url>%2Fpost%2Fd140a694.html</url>
    <content type="text"><![CDATA[2019.10.24 更新，与数字图像处理——频率域平滑锐化图像常用滤波器中滤波器公式保持一致，并更新填充函数的写法。 高斯滤波高斯高通滤波 GaussianHPF频率域高斯高通滤波公式如下，注意公式$D$和$D_0$的区别 H(u,v) = 1-e^{\dfrac{-D^2(u,v)}{2D_0^2}}高斯低通滤波 GaussianLPF频率域高斯低通滤波公式如下 H(u,v) = e^{\dfrac{-D^2(u,v)}{2D_0^2}}1234567891011121314151617181920212223242526def getGaussianMask(mask_shape,filter_d0,hl_type): assert hl_type in ("lpf","hpf") rows,cols = mask_shape[0],mask_shape[1] crow = rows/2 ccol = cols/2 mask = np.zeros((rows,cols)) for i in range(rows): for j in range(cols): dis = sqrt((i-crow)**2 + (j-ccol)**2) if hl_type == "hpf": mask[i,j] = 1-np.exp(-(dis**2) / (2*(filter_d0**2))) elif hl_type == "lpf": mask[i,j] = np.exp(-(dis**2)/(2*(filter_d0**2))) return maskdef getGaussianFilterPassImg(input_img : np.array, filter_type : str , filter_d0 , size = None): assert filter_type in ("lpf","hpf") f_img = np.fft.fft2(input_img , s = size) shift_img = np.fft.fftshift(f_img) mask_shift_img = getGaussianMask(f_img.shape,filter_d0,filter_type) new_shift_img = mask_shift_img*shift_img new_manitude_img = 20*np.log(np.abs(new_shift_img+eps)) new_f_img = np.fft.ifftshift(new_shift_img) new_img = np.fft.ifft2(new_f_img) new_img = np.abs(new_img) return new_img,new_manitude_img,mask_shift_img DFT 固有周期影响实现方法，由于 numpy.fft.fft2 方法参数中可以指定输出图像的大小，官方描述如下： s : sequence of ints, optional _Shape (length of each transformed axis) of the output (s[0] refers to axis 0, s[1] to axis 1, etc.). This corresponds to n for fft(x, n). Along each axis, if the given shape is smaller than that of the input, the input is cropped. If it is larger, the input is padded with zeros. if s is not given, the shape of the input along the axes specified by axes is used._ 该参数默认为 DFT 变换后大小为原图大小，若指定输出大小大于原图大小，则进行 0 填充，我们可以利用该参数实现我们的测试。 不经填充裁剪直接以 s 的默认值（None）调用 numpy.fft.fft2 实际上就是进行的非 0 填充 调用我之前写的方法，实现如下 1lpf_cycle_img, manitude_cycle_img,mask_img = getGaussianFilterPassImg(cycle_img , "lpf" , 5 ) 或者如下 1lpf_cycle_img, manitude_cycle_img,mask_img = getGaussianFilterPassImg(cycle_img , "lpf" , 5 ,size = None) 进行填充裁剪根据教材 P157 解释以及 P159、P163 页，二维零填充避免缠绕错误的结论与一维相同，令$f(x)$和$h(x)$分别是大小为$A \times B$和$C \times D$像素的图像阵列。循环卷积中的缠绕错误可以通过下面函数进行零填充来避免，方法如下： f_p(x,y)=\left \{ \begin{aligned} f(x,y) & , & 0 \le x \le A-1 和 0 \le y\le B-1 \\ 0 & , & A \le x \le P 或 B \le y \le Q \end{aligned} \right.和 h_p(x,y)=\left \{ \begin{aligned} h(x,y) & , & 0 \le x \le C-1 和 0 \le y\le D-1 \\ 0 & , & C \le x \le P 或 D \le y \le Q \end{aligned} \right.其中， P \ge A+C -1和 Q \ge B+D-1那么实现方法就有两种： 通过其他方法进行补 0 后调用 s 为 None 的 DFT 通过调整 s 为(P,Q)大小调用 DFT 填充的代码实现： 12345678910111213141516171819202122232425def getPaddingSize(shape1,shape2): return shape1[0]+shape2[0]-1,shape1[1]+shape2[1]-1def getPaddingImg(fimg,himg_shape, position = "corner"): fimg = np.array(fimg) himg = np.array(himg_shape) assert position in ("corner","middle") fimg = np.array(fimg) rows,cols = fimg.shape prows,pcols = getPaddingSize(fimg.shape,himg_shape) if position == "corner": new_img = np.pad(fimg,((0,prows-rows),(0,pcols-cols)),'constant', constant_values = 0) else: cal = lambda x,y: ((x-y)//2 , x-y-(x-y)//2) new_img = np.pad(fimg,(cal(prows,rows),cal(pcols,cols)),'constant', constant_values = 0) return new_imgdef cutOriginalImg(pad_img,originalsize,position = "corner"): assert position in ("corner","middle") if(position == "corner"): return pad_img[0:originalsize[0],0:originalsize[1]] else: padsizer = pad_img.shape[0]-originalsize[0] padsizec = pad_img.shape[1]-originalsize[1] return pad_img[padsizer//2:padsizer//2+originalsize[0],padsizec//2:padsizec//2+originalsize[1]] 1234567891011121314cycle_img = cv2.imread('./DIP3E_Original_Images_CH04/Fig0432(a)(square_original).tif',0)cycle_img_corner = getPaddingImg(cycle_img,(1000,1000),position = "corner")cycle_img_middle = getPaddingImg(cycle_img,(1000,1000),position = "middle")plt.figure(figsize=(12,8))ax1 = plt.subplot(131)ax1.imshow(cycle_img, cmap = "gray")ax1.set_title("Original Test Img")ax2 = plt.subplot(132)ax2.imshow(cycle_img_corner, cmap = "gray")ax2.set_title("After Padding Img (Corner)")ax3 = plt.subplot(133)ax3.imshow(cycle_img_middle, cmap = "gray" )ax3.set_title("After Padding Img (Middle)")plt.show() 123456789101112131415161718192021222324252627282930313233343536373839def showThreeImg(img1,img2,img3,img_name1 = None,img_name2 = None,img_name3 = None): plt.figure(figsize=(12,4)) ax1 = plt.subplot(131) ax1.set_title(img_name1) ax1.imshow(img1 , cmap = "gray") ax2 = plt.subplot(132) ax2.imshow(img2, cmap = "gray") ax2.set_title(img_name2) ax3 = plt.subplot(133) ax3.imshow(img3,cmap = "gray") ax3.set_title(img_name3) plt.show()mfilter_size = 8# 先构建mask# 尝试方法零（不填充）# 通过自编写方法补零后再进行DFT加高斯低通滤波lpf_cycle_img_nopadding, manitude_cycle_img,mask_img = getGaussianFilterPassImg(cycle_img , "lpf" , mfilter_size)showThreeImg(lpf_cycle_img_nopadding,manitude_cycle_img,mask_img,"Original Img Without Padding","Manitude","Mask")# 尝试方法1 （预填充）## Cornerpad_cycle_img_corner = getPaddingImg(cycle_img,(mfilter_size,mfilter_size),"corner")lpf_cycle_img_padcorner_m1, manitude_cycle_img,mask_img = getGaussianFilterPassImg(pad_cycle_img_corner , "lpf" , mfilter_size)cut_lpf_cycle_img_padcorner_m1 = cutOriginalImg(lpf_cycle_img_padcorner_m1,cycle_img.shape,"corner")showThreeImg(cut_lpf_cycle_img_padcorner_m1,manitude_cycle_img,mask_img,"Corner Padding Method 1 (After Cut)","Manitude (No Cut)","Mask (No Cut)")## Middlepad_cycle_img_middle = getPaddingImg(cycle_img,(mfilter_size,mfilter_size),"middle")lpf_cycle_img_padmiddle_m1, manitude_cycle_img,mask_img = getGaussianFilterPassImg(pad_cycle_img_middle , "lpf" , mfilter_size)cut_lpf_cycle_img_padmiddle_m1 = cutOriginalImg(lpf_cycle_img_padmiddle_m1,cycle_img.shape,"middle")showThreeImg(cut_lpf_cycle_img_padmiddle_m1,manitude_cycle_img,mask_img,"Middle Padding Method 1 (After Cut)","Manitude (No Cut)","Mask (No Cut)")# 尝试方法2 （限定s自动零填充）## 实现了相同的效果lpf_cycle_img_padcorner_m2, manitude_cycle_img,mask_img = getGaussianFilterPassImg(cycle_img , "lpf" , mfilter_size , size = getPaddingSize(cycle_img.shape,np.array([mfilter_size,mfilter_size])))cut_lpf_cycle_img_padcorner_m2 = cutOriginalImg(lpf_cycle_img_padcorner_m2,cycle_img.shape,"corner")showThreeImg(cut_lpf_cycle_img_padcorner_m2,manitude_cycle_img,mask_img,"Corner Padding Method 2 (After Cut)","Manitude (No Cut)","Mask (No Cut)") 123456print(lpf_cycle_img_padmiddle_m1.shape)print(cut_lpf_cycle_img_padmiddle_m1.shape)print("Really Cut")print((cut_lpf_cycle_img_padcorner_m1==cut_lpf_cycle_img_padcorner_m2).all())print("Method 2 has the same effect as Method 1 and generalize the same img.") 12345(775, 775)(768, 768)Really CutTrueMethod 2 has the same effect as Method 1 and generalize the same img. 上述实验证明了 DFT 固有周期带来的一些影响，未进行零填充的 Original Img 由于固有周期亮色部分左右仍旧是亮色部分，所以使滤波器丧失了能力，在一些情况下我们希望避免这种固有周期带来的影响，因而才引入了零填充的方式。 正如课本 P163 以及 P164 所讲： 用 0 填充图像后，在周期序列的周围建立了一个平坦的边界。 从这个例子可以看到，错误地填充一幅图像会导致错误的结果。 当然，这种错误只存在于“ 边界” 如果滤波的目的仅是粗糙的视觉分析，那么有时可以跳过填充步骤。 根据两种方式 Padding 得到的最终裁减后图像的比较（All True），也证明了我使用的两种方法，Method 1：手动填充 0 金和 Method 2：利用numpy.fft.fft2()中自动 0 填充的方式确实都得到了相同的结果。]]></content>
      <categories>
        <category>数字图像处理</category>
      </categories>
      <tags>
        <tag>数字图像处理</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[数字图像处理——频率域平滑锐化图像常用滤波器]]></title>
    <url>%2Fpost%2Fe371c683.html</url>
    <content type="text"><![CDATA[频率域滤波器本文主要是动手实现一些常见的滤波器，并展示其频率域和空间域图像。 这里介绍的常见滤波器为：（高通/低通）理想滤波、布特沃斯滤波器和高斯滤波器，根据书本 P169 页，他们的区别与联系如下： 这三种滤波器涵盖了从非常急剧（理想）的滤波到非常平滑（高斯）的滤波范围。布特沃斯滤波器有一个参数，它成为滤波器的“阶数”。当阶数较高时，布特沃斯滤波器接近于理想滤波器。对于较低的阶数值，布特沃斯滤波器更像高斯滤波器。这样，布特沃斯滤波器可视为两种“极端”滤波器的过渡。 为了方便后续实验，对一些辅助代码模块化编写，主要以可视化部分为主，见文末附录部分。 理想滤波器所谓”理想”是指无法通过硬件实现的硬截断 理想低通滤波器 ILPF在圆外“阻断”所有频率，而在圆内无衰减的通过所有频率，这种二维低通滤波器称为理想低通滤波器（ILPF），由下面的函数确定 H_{ILPF}(u,v) = \left \{ \begin{aligned} 1, & D(u,v) \le D_0 \\ 0, & D(u,b) > D_0 \end{aligned} \right.其中$D_0$是一个正常数，$D(u,v)$表示频率域中的点$(u,v)$距离频率域中心$(\frac{P}{2},\frac{Q}{2})$的距离。 理想高通滤波器 IHPF与低通类似，高通是将阈值的圆内“阻断”所有频率，而在圆外无衰减的通过所有频率，描述如下 H_{IHPF}(u,v) = \left \{ \begin{aligned} 0, & D(u,v) \le D_0 \\ 1, & D(u,b) > D_0 \end{aligned} \right.代码实现代码实现低通滤波器并展示其频率域透视图、频率域图像显示、空间域图像显示和径向剖面图。 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061# 获得指定大小的理想滤波器def getIdealMask(mask_shape, filter_d0,hl_type): assert hl_type in ("lpf","hpf") rows,cols = mask_shape[0],mask_shape[1] crow = rows/2 ccol = cols/2 mask = np.zeros((rows,cols)) for i in range(rows): for j in range(cols): dis = sqrt((i-crow)**2 + (j-ccol)**2) if hl_type == "lpf": if dis &lt;= filter_d0: mask[i,j] = 1 else: mask[i,j] = 0 elif hl_type == "hpf": if dis &lt;= filter_d0: mask[i,j] = 0 else: mask[i,j] = 1 return mask# 测试ILPF# 参数设置mask_shape = (100,100)d = 20filter_type = "lpf"# 获得滤波器myfilter = getIdealMask(mask_shape,d,filter_type)# 绘图plt.figure(figsize=(12,12))ax1=plt.subplot(221,projection = "3d")ax2=plt.subplot(222)ax3=plt.subplot(223)ax4=plt.subplot(224)drawPerspective(ax1,myfilter,title = "ILPF Perspective Axes3D", cmap = "gray")# 不想进行列表解析,需要调用frompyfunc构建np可以用的分段函数ufunc1 = np.frompyfunc(lambda x: 0 if (x-d)&gt;0 else 1, 1, 1)drawCurv(ax2,[ufunc1],["ILPF"],d,title = "ILPF Curv")drawPanel(ax3,myfilter,title = "ILPF Frequency Panel Axes2D")spatial_myfilter = frequencyToSpatial(myfilter)drawPanel(ax4,spatial_myfilter,title = "ILPF Spatial Panel Axes2D")plt.show()# 测试IHPFd = 20filter_type = "hpf"myfilter = getIdealMask(mask_shape,d,filter_type)plt.figure(figsize=(12,12))ax1=plt.subplot(221,projection = "3d")ax2=plt.subplot(222)ax3=plt.subplot(223)ax4=plt.subplot(224)drawPerspective(ax1,myfilter,title = "IHPF Perspective Axes3D", cmap = "gray")# 不想进行列表解析,需要调用frompyfunc构建np可以用的分段函数ufunc1 = np.frompyfunc(lambda x: 1 if (x-d)&gt;0 else 0, 1, 1)drawCurv(ax2,[ufunc1],["IHPF"],d,title = "Curv")drawPanel(ax3,myfilter,title = "IHPF Frequency Panel Axes2D")spatial_myfilter = frequencyToSpatial(myfilter)drawPanel(ax4,spatial_myfilter,title = "IHPF Spatial Panel Axes2D")plt.show() 理想低通 ILPF 结果四图 理想高通 IHPF 结果四图 布特沃斯滤波器可通过硬件实现，可以通过阶数进行控制，一些资料中又称之为“巴特沃斯滤波器”。 布特沃斯低通滤波器 BLPF截止频率位于距原点$D_0$的$n$阶布特沃斯滤波器（BLPF）的传递函数定义为： H_{BLPF}(u,v) = \dfrac{1}{ 1 + {[ \dfrac {D(u,v)}{D_0} ]}^{2n} }布特沃斯高通滤波器 BHPF对应的传递函数定义为： H_{BHPF}(u,v) = \dfrac{1}{ 1 + {[ \dfrac {D_0}{D_(u,v)} ]}^{2n} }（分母分子颠倒） 两式中$n$对应了即阶参数，下面的代码给出巴特沃斯滤波器的实现，其频率域透视图、频率域图像显示、空间域图像显示和径向剖面图，曲线图绘制出不同阶下的取值。 代码实现12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364656667686970717273747576777879808182838485# 获得指定大小的布特沃斯滤波器def getButterworthMask(mask_shape,filter_d0,hl_type,butter_n = 1): assert hl_type in ("lpf","hpf") rows,cols = mask_shape[0],mask_shape[1] crow = rows/2 ccol = cols/2 mask = np.zeros((rows,cols)) for i in range(rows): for j in range(cols): dis = sqrt((i-crow)**2 + (j-ccol)**2) if hl_type == "lpf": mask[i,j] = 1.0/(1+(dis/filter_d0)**(2*butter_n)) elif hl_type == "hpf": # 除以0情况特判一下 if np.abs(dis)&lt;eps: mask[i,j] = 0 else: mask[i,j] = 1.0/(1+(filter_d0/dis)**(2*butter_n)) return mask# 测试BLPF# 参数设置mask_shape = (100,100)d = 20filter_type = "lpf"# 获得滤波器myfilter = getButterworthMask(mask_shape,d,filter_type, butter_n=2)# 绘图plt.figure(figsize=(12,12))ax1=plt.subplot(221,projection = "3d")ax2=plt.subplot(222)ax3=plt.subplot(223)ax4=plt.subplot(224)drawPerspective(ax1,myfilter,title = "BLPF(n=2) Perspective Axes3D", cmap = "gray")funcs = []labels = []for i in range(1,6): labels.append("BLPF "+"n="+str(i))funcs.append(lambda x:1.0/(1+(x/d)**(2*1)))funcs.append(lambda x:1.0/(1+(x/d)**(2*2)))funcs.append(lambda x:1.0/(1+(x/d)**(2*3)))funcs.append(lambda x:1.0/(1+(x/d)**(2*4)))funcs.append(lambda x:1.0/(1+(x/d)**(2*5)))drawCurv(ax2,funcs,labels,d,title = "BLPF(n=1,2,3,4,5) Curv")drawPanel(ax3,myfilter,title = "BLPF(n=2) Frequency Panel Axes2D")spatial_myfilter = frequencyToSpatial(myfilter)drawPanel(ax4,spatial_myfilter,title = "BLPF(n=2) Spatial Panel Axes2D")plt.show()# 测试BHPFd = 20filter_type = "hpf"myfilter = getButterworthMask(mask_shape,d,filter_type, butter_n=1)plt.figure(figsize=(12,12))ax1=plt.subplot(221,projection = "3d")ax2=plt.subplot(222)ax3=plt.subplot(223)ax4=plt.subplot(224)drawPerspective(ax1,myfilter,title = "BHPF(n=2) Perspective Axes3D", cmap = "gray")funcs = []labels = []for i in range(1,6):# funcs.append(lambda x:1.0/(1+(d/x)**(2*i)))# ufunc = np.frompyfunc(lambda x: 0 if np.abs(x)&lt;eps else 1.0/(1+(d/x)**(2*i)), 1, 1)# funcs.append(ufunc) labels.append("BHPF "+"n="+str(i))ufunc1 = np.frompyfunc(lambda x: 0 if np.abs(x)&lt;eps else 1.0/(1+(d/x)**(2*1)), 1, 1)ufunc2 = np.frompyfunc(lambda x: 0 if np.abs(x)&lt;eps else 1.0/(1+(d/x)**(2*2)), 1, 1)ufunc3 = np.frompyfunc(lambda x: 0 if np.abs(x)&lt;eps else 1.0/(1+(d/x)**(2*3)), 1, 1)ufunc4 = np.frompyfunc(lambda x: 0 if np.abs(x)&lt;eps else 1.0/(1+(d/x)**(2*4)), 1, 1)ufunc5 = np.frompyfunc(lambda x: 0 if np.abs(x)&lt;eps else 1.0/(1+(d/x)**(2*5)), 1, 1)funcs.append(ufunc1)funcs.append(ufunc2)funcs.append(ufunc3)funcs.append(ufunc4)funcs.append(ufunc5)drawCurv(ax2,funcs,labels,d,title = "BHPF(n=1,2,3,4,5) Curv")drawPanel(ax3,myfilter,title = "BHPF(n=2) Frequency Panel Axes2D")spatial_myfilter = frequencyToSpatial(myfilter)drawPanel(ax4,spatial_myfilter,title = "BHPF(n=2) Spatial Panel Axes2D")plt.show() 布特沃斯低通 BLPF 结果四图 布特沃斯高通 BHPF 结果四图 高斯低通滤波器 GLPF高斯低通滤波器二维形式由下式给处： H_{GLPF}(u,v) = e^{\dfrac{-D^2(u,v)}{2 \sigma^2}}$\sigma$描述了中心的扩散速度，和其他滤波器描述式统一，通过令$\sigma = D_0$，可以用表示其他滤波器的方法表示高斯滤波器。 H_{GLPF}(u,v) = e^{\dfrac{-D^2(u,v)}{2 D_0^2}}高斯高通滤波器 GHPF如下： H_{GHPF}(u,v) =1 - e^{\dfrac{-D^2(u,v)}{2 D_0^2}}代码实现123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051# 获得指定大小的高斯滤波器def getGaussianMask(mask_shape,filter_d0,hl_type): assert hl_type in ("lpf","hpf") rows,cols = mask_shape[0],mask_shape[1] crow = rows/2 ccol = cols/2 mask = np.zeros((rows,cols)) for i in range(rows): for j in range(cols): dis = sqrt((i-crow)**2 + (j-ccol)**2) if hl_type == "hpf": mask[i,j] = 1-np.exp(-(dis**2) / (2*(filter_d0**2))) elif hl_type == "lpf": mask[i,j] = np.exp(-(dis**2)/(2*(filter_d0**2))) return mask# 测试GLPF# 参数设置mask_shape = (200,200)d = 20filter_type = "lpf"# 获得滤波器myfilter = getGaussianMask(mask_shape,d,filter_type)# 绘图plt.figure(figsize=(12,12))ax1=plt.subplot(221,projection = "3d")ax2=plt.subplot(222)ax3=plt.subplot(223)ax4=plt.subplot(224)drawPerspective(ax1,myfilter,title = "GLPF Perspective Axes3D", cmap = "gray")drawCurv(ax2,[lambda x:np.exp(-(x**2)/(2*(d**2)))],["GLPF"],d,title = "GLPF Curv")drawPanel(ax3,myfilter,title = "GLPF Frequency Panel Axes2D")spatial_myfilter = frequencyToSpatial(myfilter)drawPanel(ax4,spatial_myfilter,title = "GLPF Spatial Panel Axes2D")plt.show()# 测试GHPFd = 20filter_type = "hpf"myfilter = getGaussianMask(mask_shape,d,filter_type)plt.figure(figsize=(12,12))ax1=plt.subplot(221,projection = "3d")ax2=plt.subplot(222)ax3=plt.subplot(223)ax4=plt.subplot(224)drawPerspective(ax1,myfilter,title = "GLPF Perspective Axes3D", cmap = "gray")drawCurv(ax2,[lambda x:1-np.exp(-(x**2)/(2*(d**2)))],["GHPF"],d,title = "GLPF Curv")drawPanel(ax3,myfilter,title = "GLPF Frequency Panel Axes2D")spatial_myfilter = frequencyToSpatial(myfilter)drawPanel(ax4,spatial_myfilter,title = "GLPF Spatial Panel Axes2D")plt.show() 高斯低通 GLPF 结果四图 高斯高通 GHPF 结果四图 总结在规定滤波器为 100x100，阈值为 20 时，可以明显观察到，理想滤波器-&gt;高阶布特沃斯滤波器-&gt;低阶布特沃斯滤波器-&gt;高斯滤波器，可以由函数 Curv 看出对应的过渡。 我们同时也发现理想滤波器确实会存在振铃特性，这个将在后面的文章中再做分析学习。 附录辅助代码 12345678import numpy as npimport cv2import imageioimport matplotlib.pyplot as pltfrom math import sqrtfrom mpl_toolkits.mplot3d import Axes3Deps = np.finfo(float).eps 绘制三维透视图1234567891011121314def drawPerspective(handleax,input_matrix,title=None,cmap = "gray"): handleax.set_title(title) handleax.set_zlabel('Z') # 坐标轴 handleax.set_ylabel('Y') handleax.set_xlabel('X') x,y = input_matrix.shape X = np.arange(0,x,1) Y = np.arange(0,y,1) # 由于图像x,y坐标和 meshigrid出来是互反的 # 这里需要调转一下 # 否则会出现mismatch的现象 X,Y = np.meshgrid(Y, X) handleax.plot_surface(Y, X, input_matrix, cmap=cmap)# handleax.plot_wireframe(Y, X, input_matrix, cmap=cmap) 绘制平面图12345def drawPanel(handleax,input_matrix,title=None,cmap = "gray"): handleax.set_title(title) handleax.set_ylabel('Y') handleax.set_xlabel('X') handleax.imshow(input_matrix,cmap = cmap) 绘制曲线图12345678910111213141516def drawCurv(handleax,functions,labels,filter_d0,title=None,cmap = "gray"): # 绘制从0到 3D_0的函数剖面图 handleax.set_title(title) handleax.set_xlabel("$D(u,v)$") handleax.set_ylabel("$H(u,v)$") # 标出D_0点 # handleax.annotate(r"$D_0$", xy = (filter_d0,0) , weight='heavy') for func,lab in zip(functions,labels): # 对每一对func和label绘图 （针对需要画多条线的情况） X = np.arange(0,3*filter_d0+1,0.1) Y = func(X) handleax.plot(X,Y,label = lab) handleax.set_xticks([0,filter_d0]) handleax.set_xticklabels(["$0$","$D_0$"]) handleax.legend() 频率域转空间域1234567def frequencyToSpatial(input_matrix): # 这里不太明白为什么shift与否最后都需要添加一个fftshift来得到想要的空间域图像 shift_input_matrix = np.fft.ifftshift(input_matrix)# shift_input_matrix = input_matrix spatial_img = np.abs(np.fft.ifft2(shift_input_matrix)) spatial_img = np.fft.fftshift(spatial_img) return spatial_img 对三维透视可视化代码进行测试 12345678910111213# 测试1test_img1 = cv2.imread('./DIP3E_Original_Images_CH02/Fig0207(a)(gray level band).tif',0)test_img2 = cv2.imread('./DIP3E_CH07_Original_Images/Fig0726(a).tif',0)plt.figure(figsize=(16,12))ax1 = plt.subplot(221,projection = "3d")ax2 = plt.subplot(222)ax3 = plt.subplot(223,projection = "3d")ax4 = plt.subplot(224)drawPerspective(ax1,test_img1,"Test Fig0726(a) Axes3D","rainbow")drawPanel(ax2,test_img1,"Test Fig0726(a) Axes2D","rainbow")drawPerspective(ax3,test_img2,"Test Fig0726(a) Axes3D","rainbow")drawPanel(ax4,test_img2,"Test Fig0726(a) Axes2D","rainbow")plt.show() 测试结果 对绘制函数曲线代码进行测试 123456789101112131415161718# 测试2test_d0 = 10test_funcs1 = []test_funcs1.append(lambda x: np.sin(x))test_funcs1.append(lambda x: np.cos(x))test_labels1 = ["$sin(x)$","$cos(x)$"]test_funcs2 = []test_funcs2.append(lambda x: np.sqrt(x))test_funcs2.append(lambda x: np.exp(-(x**2)/(2*(test_d0)**2)))test_labels2 = ["$x$","$e^&#123;\dfrac&#123;-D^2(u,v)&#125;&#123;2 D_0^2&#125;&#125;$"]plt.figure(figsize=(14,7))ax1 = plt.subplot(121)ax2 = plt.subplot(122)drawCurv(ax1,test_funcs1,test_labels1,test_d0,title="Test sin(x) and cos(x)")drawCurv(ax2,test_funcs2,test_labels2,test_d0,title="Test x and gaussian")plt.show() 测试结果]]></content>
      <categories>
        <category>数字图像处理</category>
      </categories>
      <tags>
        <tag>数字图像处理</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[行为金融学——线性成长与指数成长]]></title>
    <url>%2Fpost%2F684a8ddc.html</url>
    <content type="text"><![CDATA[请描绘线性成长与指数成长的规律，你从中得到了什么启示用数学公式描述两种成长模式 线性成长狭义：一次线性 Q(t) = a_1 t + a_0广义：多项式线性 Q(t) = a_n t^n + a_{n-1} t^{n-1} + \cdots + a_1 t + a_0理解性描述：线性成长是一种可按差值描述“成长度”的成长模式，稍微数学解释一下应该是在某个阶差分为 0（则在上一阶是个等差变化），属于增长值“固定”的一种增长模式。 指数成长Q(t) = a r^t理解性描述：指数成长则是一种按比率描述“成长度”的成长模式，最基本的指数成长实际上就是我们高中所学的一个首项为正，公比为正的等比数列通项公式，这种成长模式是不能用差分来描述的，而需要比率描述，属于增长率“固定”的一张增长模式。 启示看了网上一段话，将两种增长模式与人的自身发展联系起来，他是这么说的： _线性成长可以让一个人变得优秀，但是要成为人中的佼佼者，让自己变得卓越，则一定是指数式的成长。指数式成长其实就是一种复利的作用，每一天的努力、坚持可以产生复利效应。_ 这段话有点结语结论的味道，话虽不错，但是没有给出一定程度的解释，我自己补充了一些。 首先，对于一个大多数活着的人来说，每天都有各式各样的“新”知识通过人的各种感官进入脑部中枢，清洗，筛选，分析，学习。所以对于这些大多数，成长是必然的，相较于前一天必然有数值的增大。 但要解释大多数中的那些小部分“枭雄”，我们不仅要看到增长，还要区分增长的模式。接纳新事物，学习新知识，若是做的好的话，在较长时间跨度内都能保持稳定的（某个阶恒差）的增长，这就体现了所谓的线性成长，而那小部分人，则可以调动起过去所有的资源（包括自己的基本能力和过去刚学习到的知识），全部用来转化吸收新的知识，类似于一种复利的计算，这种增长是可怕的，因为他每接收一分知识，就会在下一个瞬间加速（或者加大）下一份知识的吸收。]]></content>
      <categories>
        <category>行为金融学</category>
      </categories>
      <tags>
        <tag>行为金融学</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[数字图像处理——频率域滤波初步]]></title>
    <url>%2Fpost%2Fd5cc0f91.html</url>
    <content type="text"><![CDATA[频率域滤波基础傅里叶变换复习傅里叶级数、傅里叶变换（说实话这么久只知道个大概没有推过数学公式很丢人。。） 待补充 参考资料主要使用 OpenCV、Numpy 以及提供的对应方法。 图片来源为冈萨雷斯数字图像处理提供的图像。 OpenCV 关于 Fourier Transform 应用的示例 1234import numpy as npimport cv2import imageioimport matplotlib.pyplot as plt 1234567891011121314151617181920# 选取部分测试照片并显示img1 = cv2.imread('./DIP3E_CH07_Original_Images/Fig0723(a).tif',0)img2 = cv2.imread('./DIP3E_Original_Images_CH04/Fig0429(a)(blown_ic).tif',0)img3 = cv2.imread('./DIP3E_Original_Images_CH04/Fig0431(d)(blown_ic_crop).tif',0)img4 = cv2.imread('./DIP3E_Original_Images_CH04/Fig0438(a)(bld_600by600).tif',0)plt.figure(figsize=(8,8))ax1 = plt.subplot(221)ax1.set_title("Image1 Original Image")ax1.imshow(img1,cmap = "gray")ax2 = plt.subplot(222)ax2.set_title("Image2 Original Image")ax2.imshow(img2,cmap = "gray")ax3 = plt.subplot(223)ax3.set_title("Image3 Original Image")ax3.imshow(img3,cmap = "gray")ax4 = plt.subplot(224)ax4.set_title("Image4 Original Image")ax4.imshow(img4,cmap = "gray")plt.show() 原理概述 For a sinusoidal signal, $x(t) = A \sin(2 \pi ft)$, we can say $f$ is the frequency of signal, and if its frequency domain is taken, we can see a spike at $f$. If signal is sampled to form a discrete signal, we get the same frequency domain, but is periodic in the range $[- \pi, \pi]$ or $[0,2\pi]$ (or $[0,N]$ for N-point DFT). You can consider an image as a signal which is sampled in two directions. So taking fourier transform in both X and Y directions gives you the frequency representation of image 中文翻译：对于正弦信号$x(t) = A \sin(2 \pi ft)$，$f$是信号的频率，如果我们考虑它的频域，我们则可以再$f$处看到一个峰值，如果信号采样形成离散信号，我们得到了相同的频域，但是频域在 $[- \pi, \pi]$ 或者 $[0,2\pi]$ （又或者 $[0,N]$ 对于一个$N$点 DFT）。划重点！！你可以把一幅图像看作是在两个方向上采样的信号。在 X 和 Y 方向上进行傅里叶变换就得到了图像的频率表示。 使用 Numpy 实现 DFT首先使用 Numpy 提供的工具实现傅里叶变换，Numpy 提供了一个 FFT 包numpy.fft来做这些。 numpy.fft.fft2(a, s=None, axes=(-2, -1), norm=None) 提供了计算二维 DFT 的方法，参数描述： a : array_like 输入数组，可以为复数，灰度图。 s : sequence of ints, optional 决定输出数组的大小，如果输入图像的大小大于输入图像的大小，则在计算 FFT 之前用零填充输入图像。如果它小于输入图像，输入图像将被裁剪。 axes : sequence of ints, optional 没看懂，原始这么写的：Axes over which to compute the FFT. If not given, the last two axes are used. A repeated index in axes means the transform over that axis is performed multiple times. A one-element sequence means that a one-dimensional FFT is performed. norm : {None, &quot;ortho&quot;}, optional 1.10.0.新加入，归一化方式，默认为 None。 当获得了频域的结果，由于图像直流分量（DC component）在图片的左上角，如果要使其居中，则需要在两个方向上移动结果，Nuumpy 也提供了对应的函数。 numpy.fft.fftshift(x, axes=None) 提供了将零频率分量移到频谱的中心的方法，对于二维输入，交换第一和第三象限，第二和第四象限，参数描述： x : array_like 输入数组 axes : int or shape tuple, optional 要移动的轴。 默认值为 None 这样在频率变换后，我们也可找到幅度谱（magnitude spectrum） 使用 OpenCV 实现 DFTOpenCV 也提供的工具用于实现傅里叶变换，分别是cv2.dft()和cv2.idft()函数。返回有两个通道，第一个通道是结果的实部，第二个通道是结果的虚部。所以在计算其幅度的时候需要先手动转化一次。 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758## Magnitude spectrum## 使用Numpy实现DFT## 进行二维DFT变换f_img1 = np.fft.fft2(img1)## 对换象限fshift_img1 = np.fft.fftshift(f_img1)## 幅度谱 对数化？manitude_img1 = 20*np.log(np.abs(fshift_img1))## img2图像也做相同的处理f_img2 = np.fft.fft2(img2)fshift_img2 = np.fft.fftshift(f_img2)manitude_img2 = 20*np.log(np.abs(fshift_img2))## 使用OpenCV实现DFTf_img3 = cv2.dft(np.float32(img3), flags = cv2.DFT_COMPLEX_OUTPUT)fshift_img3 = np.fft.fftshift(f_img3)# manitude_img3 = 20*np.log(np.abs(fshift_img3))# 手动转化计算magnitudemanitude_img3 = 20*np.log(cv2.magnitude(fshift_img3[:,:,0],fshift_img3[:,:,1])+1e-15)## 使用OpenCV实现DFTf_img4 = cv2.dft(np.float32(img4), flags = cv2.DFT_COMPLEX_OUTPUT)fshift_img4 = np.fft.fftshift(f_img4)manitude_img4 = 20*np.log(cv2.magnitude(fshift_img4[:,:,0],fshift_img4[:,:,1]))print("显示各图像对应的频谱")print("其中图三的频谱有些奇怪")plt.figure(figsize=(16,16))ax1 = plt.subplot(421)ax1.set_title("Image1 Original Image")ax1.imshow(img1, cmap = "gray")ax2 = plt.subplot(422)ax2.set_title("Image1 Magnitude Spectrum")ax2.imshow(manitude_img1, cmap = "gray")ax3 = plt.subplot(423)ax3.set_title("Image2 Original Image")ax3.imshow(img2, cmap = "gray")ax4 = plt.subplot(424)ax4.set_title("Image2 Magnitude Spectrum")ax4.imshow(manitude_img2, cmap = "gray")ax5 = plt.subplot(425)ax5.set_title("Image3 Original Image")ax5.imshow(img3, cmap = "gray")ax6 = plt.subplot(426)ax6.set_title("Image3 Magnitude Spectrum")ax6.imshow(manitude_img3, cmap = "gray")ax7 = plt.subplot(427)ax7.set_title("Image4 Original Image")ax7.imshow(img4, cmap = "gray")ax8 = plt.subplot(428)ax8.set_title("Image4 Magnitude Spectrum")ax8.imshow(manitude_img4, cmap = "gray")plt.show() 显示各图像对应的频谱 1print(np.shape(fshift_img3)) 1(1026, 1026, 2) 根据运行结果不难验证 OpenCV 提供的 cv.dft()确实返回结果为表示实部和虚部的双通道，np 就没有这些顾虑，毕竟科学计算专门的库，复数支持很自然。 教程中也给了 Numpy 和 OpenCV 各自速度的解释，以及一些性能优化上的问题（比如 2 的整数此幂的时候速度会加快，自动填充等）： Note: As usual, OpenCV functions cv2.dft() and cv2.idft() are faster than Numpy counterparts. But Numpy functions are more user-friendly. For more details about performance issues, see below section. 这个 Note 就已经说明了 cv 的方法会更快一些，但是 numpy 的方法更加 friendly 性能测试针对前述的性能测试，以及教程上所给出的方法，可以利用 IPython 上的一个 magic command %timeit 用同一张图片 img2 来测试，下面是测试结果 测试使用 OpenCV 进行 DFT 变换 1%timeit cv2.dft(np.float32(img2), flags = cv2.DFT_COMPLEX_OUTPUT) 测试结果：10.3 ms ± 105 µs per loop (mean ± std. dev. of 7 runs, 100 loops each) 测试使用 Numpy 进行 DFT 变换 1%timeit np.fft.fft2(img2) 测试结果：100 ms ± 1.4 ms per loop (mean ± std. dev. of 7 runs, 10 loops each) 通过测试比较，竟然有 10x 的速度差距，还是很明显的。 频率域滤波高通滤波 HPF对于给定的图片对频域中心（低频部分）赋值为 0，通过这种掩膜方式（masking）过滤掉低频部分从而实现 HPF。这里实验的只是粗略的滤波，频率域中心为方形，并非理想高通滤波器（IHPF）。 低通滤波 LPF同理，给定图片保留频率中心部分（低频部分）赋值为 1，剩下的通过掩膜过滤掉，从而实现 LPF。同前述，这里实验也只是粗略的滤波，频率域中心为方形，并非理想低通滤波器（ILPF）。 频率域滤波高通滤波 HPF对于给定的图片对频域中心（低频部分）赋值为 0，通过这种掩膜方式（masking）过滤掉低频部分从而实现 HPF。 低通滤波 LPF同理，给定图片保留频率中心部分（低频部分）赋值为 1，剩下的通过掩膜过滤掉，从而实现 LPF。 123456789101112131415161718192021222324def getFilterPassImg(input_img : np.array, filter_type : str , filter_size = 20): assert filter_type in ("lpf","hpf") f_img = np.fft.fft2(input_img) shift_img = np.fft.fftshift(f_img) def getMask(input_shift_img : np.array , mask_type , mask_size): rows,cols = input_shift_img.shape crow,ccol = rows//2,cols//2 if(mask_type == "hpf"): mask = np.ones(input_shift_img.shape) mask[crow - mask_size:crow+mask_size, ccol-mask_size:ccol+mask_size] = 0.0 else : mask = np.zeros(input_shift_img.shape) mask[crow - mask_size:crow+mask_size, ccol-mask_size:ccol+mask_size] = 1.0 return mask mask_shift_img = getMask(shift_img, filter_type ,filter_size) new_shift_img = mask_shift_img*shift_img new_manitude_img = 20*np.log(np.abs(new_shift_img)+eps) new_f_img = np.fft.ifftshift(new_shift_img) new_img = np.fft.ifft2(new_f_img) new_img = np.abs(new_img) return new_img,new_manitude_img 123456789101112131415161718192021222324hpf_img2,hpf_manitude_img2 = getFilterPassImg(img2,"hpf",30)lpf_img2,lpf_manitude_img2 = getFilterPassImg(img2,"lpf",30)plt.figure(figsize=(8,12))ax1 = plt.subplot(321)ax1.set_title("Original Image")ax1.imshow(img2, cmap = "gray")ax2 = plt.subplot(322)ax2.set_title("Magnitude Spectrum")ax2.imshow(manitude_img2, cmap = "gray")ax3 = plt.subplot(323)ax3.set_title("With HPF(Size=30x30)")ax3.imshow(hpf_img2,cmap = "gray")ax4 = plt.subplot(324)ax4.set_title("With HPF(Size=30x30) Magnitude Spectrum")ax4.imshow(hpf_manitude_img2,cmap = "gray")ax5 = plt.subplot(325)ax5.set_title("With LPF(Size=30x30)")ax5.imshow(lpf_img2,cmap = "gray")ax6 = plt.subplot(326)ax6.set_title("With LPF(Size=30x30) Magnitude Spectrum")ax6.imshow(lpf_manitude_img2,cmap = "gray")plt.show()]]></content>
      <categories>
        <category>数字图像处理</category>
      </categories>
      <tags>
        <tag>待补充</tag>
        <tag>数字图像处理</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[行为金融学——博弈论一些经典实验]]></title>
    <url>%2Fpost%2F73209085.html</url>
    <content type="text"><![CDATA[实验类型 实验描述 现实举例 经济人模型的均衡解 实验结果 社会偏好 囚徒博弈实验 两个实验对象进行囚徒博弈分别有合作和不合作两个决策，双方博弈的收益支付矩阵为合作不合作合作 H，H S，T 不合作 T，S L，L 其中，H ＞ L，T ＞ H，L ＞ S 负外部性产品比如环境污染、噪音等的生产 双方均选择不合作 50%的人选择合作，而且互相交流机制能有效增强合作的频率 互惠偏好 最后通牒实验 双人或多人分别扮演提议者和响应者角色对一财富 S 进行分配方案的选择博弈，提议者分配 x 个筹码给对方，如果响应者拒绝则双方受益为 0，如果响应者接受，则提议者获得 S-x，响应者获得 x 易腐烂商品的垄断定价 提议者分配 x ＝ ε，其中 ε 为任意小的一个正数，响应者接受该分配额 平均分配额在 0.3S 和 0.5S 之间，当 x ＜ 0.2S 时大约一半的人会拒绝 互惠偏好、利他偏好、差异厌恶偏好 独裁者实验 在最后通牒博弈基础上取消了响应者的拒绝权利，即独裁者决定对 S 财富的分配，若独裁者分配 x 个筹码给对方，双方收益即决定为(S-x，x) 慈善的捐赠行为 独裁者分配给接收者 x ＝ 0 平均来看独裁者会分配给接收者 x ＝ 0.2S 利他偏好 第三方惩罚实验 在独裁者基础上加入了一个局外者即第三方，该第三方可以对独裁者的分配行为进行带有成本的惩罚 对不公现象的社会谴责和批评 独裁者照样分配给接受者 x ＝ 0，而第三方不会选择惩罚 当独裁者给接收者的分配额小于一定数目时，第三方会对独裁者进行惩罚而且分配数目越小惩罚越大 利他偏好 公共品博弈实验 拥有初始禀赋 y 的 n 个实验对象同时对一个公共项目进行投资，投资额为 gi(0≤gi≤y)，此时每人收益为 πi ＝ y－gi ＋ mG，其中 G 为各实验对象的投资总额，m 为公共品投资回报率 团队合作，小型社会中的公共产出，共有资源的过度使用等 每个实验对象投资额为 gi ＝ 0 在一次性匿名实验中人们会投资 50%的初始禀赋，如果实验次数增加，则投资额为越来越小，交流机制和惩罚机制可以有效提升合作水平 互惠偏好，利他偏好，差异厌恶偏好 信任博弈实验 双人分别扮演委托人和代理人角色并拥有初始禀赋 S，委托人可以从初始禀赋 S 中选择投资 y(0≤y≤S)给代理人，代理人自动获得 3y 后可以选择返还一个 x(0≤x≤3y)给委托人。此时委托人收益为 S－y+x，而代理人收益为 S+3y－x 没有法律合同的买卖行为 委托人选择投资 y ＝ 0；代理人选择返还 x ＝ 0. 平均上来看实验者会选择 y ＝ 0.5S 投资给代理人，而代理人会选择返还一个略小于 0.5S 的值给委托人，而且 x 与 y 成正比 互惠偏好，利他偏好 礼物交换实验 雇主提供给一个工资 w 给雇员，雇员选择一个工作努力程度 e(1≤e≤10)，并付出成本 c(e)，此时雇员工作产出效益为 10e，雇主收益为 10e-w，雇员收益为 w-c(e) 雇主和雇员的上下关系 雇员选择最小努力程度即 e ＝ 0，而雇主提供最小工资 雇员的努力程度和雇主的工资水平成正比。 互惠偏好，利他偏好]]></content>
      <categories>
        <category>行为金融学</category>
      </categories>
      <tags>
        <tag>行为金融学</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[计算机图形学——曲面表达]]></title>
    <url>%2Fpost%2Fe3de1605.html</url>
    <content type="text"><![CDATA[曲面造型发展背景插值与逼近使用参数曲面的优势 基于满足集合不变性（指他们不依赖于） 曲线曲面的一般参数样条表达位置矢量、切矢。。 我们如何有效、快速地设计、表达和绘制自由曲线？ 灵活的模型 Bezier 曲线 连续与光滑C1 连续、几何连续（只要求方向，不要求大小值相同） B 样条曲线 k 取值 2 到 n+1]]></content>
      <categories>
        <category>计算机图形学</category>
      </categories>
      <tags>
        <tag>计算机图形学</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[机器学习——决策树实现（Python版）]]></title>
    <url>%2Fpost%2Fefa709aa.html</url>
    <content type="text"><![CDATA[完成 ID3、C4.5、CART 决策树构建，阈值限制，连续属性划分，剪枝，缺省值处理。 什么是决策树直观理解：通过自顶向下的方式，构造一棵数据不断被纯化的树，可用来分类、回归，有监督学习的一种。 构造过程：递归构造 核心问题：划分的选择（决策依据） 来自SGUWOOM 的博客` 决策树学习采用的是自顶向下的递归方法，其基本思想是以信息熵为度量构造一颗熵值下降最快的树，到叶子节点处，熵值为 $0$。其具有可读性、分类速度快的优点，是一种有监督学习。最早提及决策树思想的是 Quinlan 在 1986 年提出的 ID3 算法和 1993 年提出的 C4.5 算法，以及 Breiman 等人在 1984 年提出的 CART 算法 随着划分不断进行，决策树的分支节点应趋向于属于同一类别，样本集合属于同一类别的程度用“纯度”（purity）表示。 基本概念信息熵“信息熵”（Information entropy），衡量样本集合纯度最常用的一种方法，公式： Ent(D) = - \sum_{k=1}^{ |y|} p_k \log_2 p_k其中$p_k$ 为第$k$ 类样本占该样本集的比例。 甚至可以联想热学熵，熵值越低应该越好（纯度越高），从公式易知熵值范围应是$[ 0 , \log_2 |D|]$。 信息增益对于该集合的一种划分（实践上我们尝试通过对某一列属性是否相同，即该属性上的等价关系，对集合进行划分），我们会产生一个商集。 如西瓜书上所假设，离散属性$a$有$V$个可能的取值$\{ a^1,a^2, \cdots , a^n \}$，用该属性对样本集进行划分，会产生$V$个分支节点，属性值与分支节点对应关系为$a^v \rightarrow D^v$，对这$V$个分支节点分别计算信息熵并赋予权重$\frac{ |D^v| }{ | D | }$，与原样本集合的信息熵作比较我们就可以得出信息增益，公式： Gain(D,a) = Ent(D) - \sum_{v=1}^{V} \frac{ |D^v| }{ | D | } Ent(D^v)ID3 决策树学习算法采用信息增益为准则决定划分属性。 信息增益率对于信息增益，我们很容易发现其偏好属性值可取值较多的属性有偏好（因为分后各分支节点样本都趋近于完全纯和），在一些数据集中会丧失泛化能力。 信息增益率在信息增益的基础上，增加了“固有值”（Intrinsic Value）的概念，可取值越多的属性，其固有值 IV 常常会越大，计算增益率的公式为： Gain\_radio(D,a) = \frac{Gain(D,a)}{IV(a)}IV(a) = - \sum_{v=1}^{V} \frac{ |D^v| }{ | D | } \log_2 \frac{ |D^v| }{ | D | }C4.5 决策树算法采用信息增益率来选择最优的划分属性，不过由于增益率准则对可取数目较少的属性有所偏好反过来了，因此，C4.5 算法并不是直接选择增益率最大的候选划分属性，而是使用了一个启发式算法，先从候选划分属性中找出信息增益高于平均水平的属性，再从中选择增益率最高的。 基尼指数CART 决策树使用“基尼指数”来选择划分属性，公式： Gini(D) = \sum_{ k=1 }^{ |y| } \sum_{ k' k } p_k p_{k'}概率公式，更常用的是下面： Gini(D) = 1- \sum_{k=1}^{|y|} p_k^2通过某一属性进行划分，则属性$a$的基尼指数定义为： Gini\_index(D,a) = \sum_{v=1}^{V} \frac{ |D^v| }{ | D | } Gini(D^v)我们选择所有属性中使得划分后基尼指数最小的属性作为最优划分属性。 需要说明的是 CART 决策树是从属性集中抽取两个相互对立的集合（即$V=2$），离散型属性应为等于和不等于，连续型属性应是小于和大于等于，利用上式计算$Gini_index$，对每个可能可能取得值均取一遍，选取最小得$Gini_index$值作为该属性的代表值。 程序流程图 整体代码123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147148149150151152153154155156157158159160161162163164165166167168169170171172173174175176177178179180181182183184185186187188189190191192193194195196197198199200201202203204205206207208209210211212213214215216217218219220221222223224225226227228229230231232233234235236237238239240241242243244245246247248249250251252253254255256257258259260261262263264265266267268269270271272273274275276277278279280281282283284285286287288289290291292293294295296297298299300301302303304305306307308309310311312313314315316317318319320321322323324325326327328329330331332333334335336337338339340341342343344345346347348349350351352353354355356357358359360361362363364365366367368369370371372373374375376377378379380381382383384385386387388389390391392393394395396397398399400401402403404405406407408409410411412413414415416417418419420421422423424425426427428429430431432433434435436437438439440441442443444445446447448449450451452453454455456457458459460461462463464465466467468469470471472473474475476477478479480481482483484485486487488489490491492493494495496497498499500501502503504505506507508509510511512513514515516517518519520521522523524525526527528529530531532533534535536537538539540541542543544545546547548549550551552553554555556557558559560561562563564565566567568569570571572573574575576577578579580581582583584585586587588589590591592593594595596597598599600601602603604605606607608609610611612613614615616617618619620621622623624625626627628#!/usr/bin/env python# coding: utf-8# In[1]:from math import logimport numpy as npimport pandas as pdimport matplotlib.pyplot as pltimport matplotlibfrom sklearn.datasets import load_irisfrom sklearn.model_selection import train_test_splitmatplotlib.rcParams['font.family'] = 'SimHei'# In[99]:class DecisionTree: """ DecisionTree 决策树类 详情见API文档 """ label_name = [] raw_data = [] raw_label = [] train_data = [] train_label = [] test_data = [] test_label = [] tree = [] def __init__(self, input_data, input_label, input_name): """ __init__ 构造函数初始化决策树对象 :param self: 类方法自带 :param input_data: 输入数据集 :param input_label: 输入标签集 :param input_name: 输入属性名称 """ self.raw_data = np.array(input_data, dtype=object) self.raw_label = np.array(input_label, dtype=object) self.label_name = np.array(input_name, dtype=object) def loadTrainData(self, type=0): """ loadTrainData 构建训练集 :param self: 类方法自带 :param type: 加载方法 """ if(type == 0): self.train_data = np.array(self.raw_data, dtype=object) self.train_label = np.array(self.raw_label, dtype=object) def calcGini(self, labels): """ calcGini 计算给定数据集的基尼指数Gini(D) :param self: 类方法自带 :param labels: 输入的标签集或属性集 :return: 计算的基尼指数 """ label_values = set(labels) ans = 1.0 for value in label_values: p = labels[labels == value].size / labels.size ans -= p**2 return ans def calcEntropy(self, labels): """ calcEntropy 计算给定数据集的经验熵Ent(D) :param self: 类方法自带 :param labels: 输入的标签集或属性集 :return: 计算的Ent熵 """ label_values = set(labels) ans = 0.0 for value in label_values: p = labels[labels == value].size / labels.size ans -= p*log(p, 2) return ans def calcSumEnt(self, data, labels): """ calcSumEnt 计算给定数据集的经验熵Ent(D) :param self: 类方法自带 :param data: 输入的数据集 :param labels: 输入的标签集 :return: sum_ent: 计算的Ent熵 :return: max_point: 对于连续型属性 最佳分割点 """ features = np.array(data, dtype=object) labels = np.array(labels, dtype=object) feature_values = list(set(features)) num = features.size max_point = -float('inf') sum_ent = 0.0 if type(features[0]) != float and type(features[0]) != int: # 对于离散值属性，分类方向确定，计算Gain即可 for value in feature_values: p = features[features == value].size/num sum_ent += p*self.calcEntropy(labels[features == value]) else: # 对于连续性属性，分类方向不确定，还需要多做一次分割点确认 sum_ent = float('inf') # 排序 feature_values.sort() cnt = len(feature_values) # 寻找最合适的划分中点 for j in range(cnt-1): point_ent = 0 point = float(feature_values[j] + feature_values[j+1])/2 # 划分成小于和大于等于两个子集 p1 = features[features &lt; point].size / num p2 = features[features &gt;= point].size / num point_ent += p1*self.calcEntropy(labels[features &lt; point]) point_ent += p2*self.calcEntropy(labels[features &gt;= point]) if point_ent &lt; sum_ent: sum_ent = point_ent max_point = point return sum_ent, max_point def calcInfoGain(self, data, labels): """ calcInfoGain 计算指定数据集选定属性的信息熵增益（ID3） :param self: 类方法自带 :param data: 输入的数据集（选定指定属性） :param labels: 输入的标签集或属性集 :return: 信息熵增益 """ sum_ent, max_point = self.calcSumEnt(data, labels) return self.calcEntropy(labels) - sum_ent, max_point def calcInfoGainRatio(self, data, labels): """ calcInfoGainRatio 计算指定数据集选定属性的信息熵增益率（C4.5） :param self: 类方法自带 :param data: 输入的数据集（选定指定属性） :param labels: 输入的标签集或属性集 :return: 信息熵增益率 """ iv = self.calcEntropy(data) if iv == 0: return 0, 0 else: info_gain, max_point = self.calcInfoGain(data, labels) return info_gain/iv, max_point def calcInfoGini(self, data, labels): """ calcInfoGini 计算指定数据集选定属性的基尼指数（CART） :param self: 类方法自带 :param data: 输入的数据集（选定指定属性） :param labels: 输入的标签集或属性集 :return: sum_gini: 指定属性的基尼指数和 :return: 最佳分割点 """ features = np.array(data, dtype=object) labels = np.array(labels, dtype=object) feature_values = list(set(features)) num = features.size max_point = -float('inf') best_gini = float('inf') best_value = "" if type(features[0]) != float and type(features[0]) != int: # 对于离散值属性，分类方向确定，计算Gain即可 for value in feature_values: p1 = features[features == value].size / num p2 = features[features != value].size / num tmp_gini = p1 * \ self.calcGini(labels[features == value]) + \ p2*self.calcGini(labels[features != value]) if tmp_gini &lt; best_gini: best_gini = tmp_gini best_value = value else: # 对于连续性属性，分类方向不确定，还需要多做一次分割点确认 best_gini = float('inf') # 排序 feature_values.sort() cnt = len(feature_values) # 寻找最合适的划分中点 for j in range(cnt-1): point_gini = 0 point = float(feature_values[j] + feature_values[j+1])/2 # 划分成小于和大于等于两个子集 p1 = features[features &lt; point].size / num p2 = features[features &gt;= point].size / num point_gini += p1*self.calcGini(labels[features &lt; point]) point_gini += p2*self.calcGini(labels[features &gt;= point]) if point_gini &lt; best_gini: best_gini = point_gini max_point = point return best_gini, best_value, max_point def chooseBest(self, data, labels, names, method='id3'): """ chooseBest 选择最佳分割属性 :param self: 类方法自带 :param data: 当前数据集 :param labels: 当前标签集合 :param names: 当前数据集的属性名集合 :param method: 信息增益计算方法（ID3/C4.5） :return: best_feature_index 最佳分割属性索引 :return: best_feature_name: 最佳分割属性名 :return: best_info_improve: 最佳分割后信息增益值 :return: best_point: 对于连续值最佳分割点 """ data = np.array(data, dtype=object) labels = np.array(labels, dtype=object) names = np.array(names, dtype=object) feature_num = data.shape[1] # 筛选最优特征 if method == 'id3' or method == 'c4.5': best_info_improve = -float('inf') elif method == 'cart': best_info_improve = float('inf') best_feature_index = -1 best_point = -float('inf') best_value = "" for feature_index in range(feature_num): if method == 'id3': now_info_improve, now_point = self.calcInfoGain( data[:, feature_index], labels) if now_info_improve &gt; best_info_improve: best_info_improve = now_info_improve best_point = now_point best_feature_index = feature_index elif method == 'c4.5': now_info_improve, now_point = self.calcInfoGainRatio( data[:, feature_index], labels) if now_info_improve &gt; best_info_improve: best_info_improve = now_info_improve best_point = now_point best_feature_index = feature_index elif method == 'cart': now_info_improve, now_value, now_point = self.calcInfoGini( data[:, feature_index], labels) if now_info_improve &lt; best_info_improve: best_info_improve = now_info_improve best_point = now_point best_feature_index = feature_index best_value = now_value best_feature_name = names[best_feature_index] return best_feature_index, best_feature_name, best_value, best_info_improve, best_point def splitData(self, data, labels, names, feature_index, feature_name, cart_value, point, method): """ splitData 根据最佳分割，讲数据集标签集划分为不同子集 :param self: 类方法自带 :param data: 当前数据集 :param labels: 当前标签集合 :param names: 当前数据集的属性名集合 :param feature_index: 分割属性索引 :param point: 对于连续属性的分割点 :return: data_set: 不同属性对应的子数据集的集合 :return: label_set: 不同属性对应的子标签集的集合 :return: name_set: 子集属性名集合 """ data = np.array(data, dtype=object) labels = np.array(labels, dtype=object) names = np.array(names, dtype=object) # 取特征列预备向量运算 features_col = data[:, feature_index] data_set = &#123;&#125; label_set = &#123;&#125; if method == 'id3' or method == 'c4.5': # 删除特征列 data = np.delete(data, feature_index, 1) name_set = np.delete(names, feature_index) if(type(features_col[0]) != float and type(features_col[0] != int)): # 统计所有出现的特征值 按特征名称为键值储存在 data_set中 features_values = set(features_col) for value in features_values: data_set[value] = data[features_col == value] label_set[value] = labels[features_col == value] else: data_set[('&lt;', point)] = data[features_col &lt; point] label_set[('&lt;', point)] = labels[features_col &lt; point] data_set[('&gt;=', point)] = data[features_col &gt;= point] label_set[('&gt;=', point)] = labels[features_col &gt;= point] elif method == 'cart': name_set = names if(type(features_col[0]) != float and type(features_col[0] != int)): # 离散值分等于与不等于 # 等于集合 data_set[('=', cart_value)] = data[features_col == cart_value] label_set[('=', cart_value) ] = labels[features_col == cart_value] # 不等于集合 data_set[('!=', cart_value)] = data[features_col != cart_value] label_set[('!=', cart_value) ] = labels[features_col != cart_value] else: # 小于指定点 data_set[('&lt;', point)] = data[features_col &lt; point] label_set[('&lt;', point)] = labels[features_col &lt; point] # 大于指定点 data_set[('&gt;=', point)] = data[features_col &gt;= point] label_set[('&gt;=', point)] = labels[features_col &gt;= point] return data_set, label_set, name_set def startCreateTree(self, method='id3', min_sample=1): """ startCreateTree 根据设定的信息增益标准以及阈值限制，构建决策树 :param self: 类方法自带 :param method: 选定方法，默认为ID3 :param min_sample: 最少样本数阈值，默认为1 """ self.tree = self.createTree( self.train_data, self.train_label, self.label_name, method, min_sample) def majLabel(self, labels): """ majLabel 当前标签集的选择主要类别 :param self: 类方法自带 :param labels: 输入标签集 :return: 主要类别名 """ labels = np.array(labels, dtype=object) label_values = set(labels) label_map = &#123;&#125; for value in label_values: label_map[value] = labels[labels == value].size return max(label_map, key=label_map.get) def createTree(self, data, labels, names, method, min_sample): """ createTree 构建当前树结点 :param self: 类方法自带 :param data: 输入数据集 :param labels: 输入标签集 :param names: 输入属性名集合 :param min_sample: 最小样本数量阈值 :return: 返回建立的节点 """ data = np.array(data, dtype=object) labels = np.array(labels, dtype=object) names = np.array(names, dtype=object) # 相同类别 if len(set(labels)) == 1: return labels[0] # 剩余样本量小于阈值 if data.size == 0 or labels.size &lt;= min_sample: return self.majLabel(labels) # 选取最优特征 best_feature_index, best_feature_name, best_value, best_ent, best_point = self.chooseBest( data, labels, names, method) # 建立节点 node = &#123;"feature_name": best_feature_name&#125; # 函数内删除不会影响外部情况，所以不会造成回溯时改变 child_data_set, child_label_set, child_name_set = self.splitData( data, labels, names, best_feature_index, best_feature_name, best_value, best_point, method)# print(child_data_set)# print(child_label_set) for feature_value in child_data_set.keys(): node[feature_value] = self.createTree( child_data_set[feature_value], child_label_set[feature_value], child_name_set, method, min_sample) return node# In[84]:def createDataSet(type=0): """ createTree 构建数据集 :param type: 选择数据集类型（默认为0） :return: data: 数据集 :return: label: 标签集 :return: label_names: 属性名集合 """ if type == 0: data = [ ['青绿', '蜷缩', '浊响', '清晰', '凹陷', '硬滑'], ['乌黑', '蜷缩', '沉闷', '清晰', '凹陷', '硬滑'], ['乌黑', '蜷缩', '浊响', '清晰', '凹陷', '硬滑'], ['青绿', '蜷缩', '沉闷', '清晰', '凹陷', '硬滑'], ['浅白', '蜷缩', '浊响', '清晰', '凹陷', '硬滑'], ['青绿', '稍蜷', '浊响', '清晰', '稍凹', '软粘'], ['乌黑', '稍蜷', '浊响', '稍糊', '稍凹', '软粘'], ['乌黑', '稍蜷', '浊响', '清晰', '稍凹', '硬滑'], ['乌黑', '稍蜷', '沉闷', '稍糊', '稍凹', '硬滑'], ['青绿', '硬挺', '清脆', '清晰', '平坦', '软粘'], ['浅白', '硬挺', '清脆', '模糊', '平坦', '硬滑'], ['浅白', '蜷缩', '浊响', '模糊', '平坦', '软粘'], ['青绿', '稍蜷', '浊响', '稍糊', '凹陷', '硬滑'], ['浅白', '稍蜷', '沉闷', '稍糊', '凹陷', '硬滑'], ['乌黑', '稍蜷', '浊响', '清晰', '稍凹', '软粘'], ['浅白', '蜷缩', '浊响', '模糊', '平坦', '硬滑'], ['青绿', '蜷缩', '沉闷', '稍糊', '稍凹', '硬滑'] ] # labels记录样本标签 labels = ['是', '是', '是', '是', '是', '是', '是', '是', '否', '否', '否', '否', '否', '否', '否', '否', '否'] # label_names中记录的是特征的名称 label_names = ['色泽', '根蒂', '敲声', '纹理', '脐部', '触感'] elif type == 1: data = np.array([[0.697, 0.46], [0.774, 0.376], [0.634, 0.264], [0.608, 0.318], [0.556, 0.215], [0.403, 0.237], [0.481, 0.149], [0.437, 0.211], [0.666, 0.091], [0.243, 0.267], [0.245, 0.057], [0.343, 0.099], [0.639, 0.161], [0.657, 0.198], [0.36, 0.37], [0.593, 0.042], [0.719, 0.103, ]], dtype=object) labels = np.array(['是', '是', '是', '是', '是', '是', '是', '是', '否', '否', '否', '否', '否', '否', '否', '否', '否'], dtype=object) label_names = np.array(["密度", "含糖率"], dtype=object) if type == 2: data = np.array([['1', '青绿', '蜷缩', '浊响', '清晰', '凹陷', '硬滑'], ['2', '乌黑', '蜷缩', '沉闷', '清晰', '凹陷', '硬滑'], ['3', '乌黑', '蜷缩', '浊响', '清晰', '凹陷', '硬滑'], ['4', '青绿', '蜷缩', '沉闷', '清晰', '凹陷', '硬滑'], ['5', '浅白', '蜷缩', '浊响', '清晰', '凹陷', '硬滑'], ['6', '青绿', '稍蜷', '浊响', '清晰', '稍凹', '软粘'], ['7', '乌黑', '稍蜷', '浊响', '稍糊', '稍凹', '软粘'], ['8', '乌黑', '稍蜷', '浊响', '清晰', '稍凹', '硬滑'], ['9', '乌黑', '稍蜷', '沉闷', '稍糊', '稍凹', '硬滑'], ['10', '青绿', '硬挺', '清脆', '清晰', '平坦', '软粘'], ['11', '浅白', '硬挺', '清脆', '模糊', '平坦', '硬滑'], ['12', '浅白', '蜷缩', '浊响', '模糊', '平坦', '软粘'], ['13', '青绿', '稍蜷', '浊响', '稍糊', '凹陷', '硬滑'], ['14', '浅白', '稍蜷', '沉闷', '稍糊', '凹陷', '硬滑'], ['15', '乌黑', '稍蜷', '浊响', '清晰', '稍凹', '软粘'], ['16', '浅白', '蜷缩', '浊响', '模糊', '平坦', '硬滑'], ['17', '青绿', '蜷缩', '沉闷', '稍糊', '稍凹', '硬滑']], dtype=object) labels = np.array(['是', '是', '是', '是', '是', '是', '是', '是', '否', '否', '否', '否', '否', '否', '否', '否', '否'], dtype=object) label_names = np.array( ['ID', '色泽', '根蒂', '敲声', '纹理', '脐部', '触感'], dtype=object) return data, labels, label_names# In[36]:# 定义判断结点形状,其中boxstyle表示文本框类型,fc指的是注释框颜色的深度decisionNode = dict(boxstyle="round4", color='r', fc='0.9')# 定义叶结点形状leafNode = dict(boxstyle="circle", color='m')# 定义父节点指向子节点或叶子的箭头形状arrow_args = dict(arrowstyle="&lt;-", color='g')def plot_node(node_txt, center_point, parent_point, node_style): """ plot_node 绘制父子节点，节点间的箭头，并填充箭头中间上的文本 :param node_txt: 文本内容 :param center_point: 文本中心点 :param parent_point: 指向文本中心的点 """ createPlot.ax1.annotate(node_txt, xy=parent_point, xycoords='axes fraction', xytext=center_point, textcoords='axes fraction', va="center", ha="center", bbox=node_style, arrowprops=arrow_args, weight='demi')def get_leafs_num(tree_dict): """ get_leafs_num 递归计算叶节点的个数 :param tree_dict: 决策树的字典形式 :return: tree_dict: 叶节点总个数 """ # tree_dict的叶节点总数 leafs_num = 0 for key, value in tree_dict.items(): if key == 'feature_name': continue # 检测子树是否字典型 elif type(value).__name__ == 'dict': # 子树是字典型，则当前树的叶节点数加上此子树的叶节点数 leafs_num += get_leafs_num(value) else: # 子树不是字典型，则当前树的叶节点数加1 leafs_num += 1 # 返回tree_dict的叶节点总数 return leafs_numdef get_tree_max_depth(tree_dict): """ get_tree_max_depth 求树的最深层数 :param tree_dict: 树的字典存储 :return: tree_dict: 最深层数 """ # tree_dict的最深层数 max_depth = 0 for key, value in tree_dict.items(): # 树的当前分支的层数 this_path_depth = 0 # 检测子树是否字典型 if type(value).__name__ == 'dict': # 如果子树是字典型，则当前分支的层数需要加上子树的最深层数 this_path_depth = 1 + get_tree_max_depth(value) else: # 如果子树不是字典型，则是叶节点，则当前分支的层数为1 this_path_depth = 1 if this_path_depth &gt; max_depth: max_depth = this_path_depth return max_depthdef plot_mid_text(center_point, parent_point, txt_str): """ plot_mid_text 计算父节点和子节点的中间位置，并在父子节点间填充文本信息 :param center_point: 文本中心点 :param parent_point: 指向文本中心点的点 """ x_mid = (parent_point[0] - center_point[0])/2.0 + center_point[0] y_mid = (parent_point[1] - center_point[1])/2.0 + center_point[1] createPlot.ax1.text(x_mid, y_mid, txt_str) returndef plotTree(tree_dict, parent_point, node_txt): """ plotTree 绘制树 :param tree_dict: 树 :param parent_point: 父节点位置 :param node_txt: 节点内容 """ leafs_num = get_leafs_num(tree_dict) # root = list(tree_dict.keys())[0] root = tree_dict['feature_name'] # plotTree.totalW表示树的深度 center_point = (plotTree.xOff+(1.0+float(leafs_num)) / 2.0/plotTree.totalW, plotTree.yOff) # 填充node_txt内容 plot_mid_text(center_point, parent_point, node_txt) # 绘制箭头上的内容 plot_node(root, center_point, parent_point, decisionNode) plotTree.yOff = plotTree.yOff-1.0/plotTree.totalD # 因从上往下画，所以需要依次递减y的坐标值，plotTree.totalD表示存储树的深度 for key, value in tree_dict.items(): if key == 'feature_name': continue elif type(value).__name__ == 'dict': plotTree(value, center_point, str(key)) else: plotTree.xOff = plotTree.xOff+1.0/plotTree.totalW plot_node(value, (plotTree.xOff, plotTree.yOff), center_point, leafNode) plot_mid_text((plotTree.xOff, plotTree.yOff), center_point, str(key)) # h绘制完所有子节点后，增加全局变量Y的偏移 plotTree.yOff = plotTree.yOff+1.0/plotTree.totalD returndef createPlot(tree_dict): """ createPlot 绘制决策树图形 :param tree_dict: 决策树的字典形式 """ # 设置绘图区域的背景色 fig = plt.figure(figsize=(8, 8), facecolor='white') # 清空绘图区域 fig.clf() # 定义横纵坐标轴,注意不要设置xticks和yticks的值!!! axprops = dict(xticks=[], yticks=[]) createPlot.ax1 = plt.subplot(111, frameon=False, **axprops) # 由全局变量createPlot.ax1定义一个绘图区，111表示一行一列的第一个，frameon表示边框,**axprops不显示刻度 plotTree.totalW = float(get_leafs_num(tree_dict)) plotTree.totalD = float(get_tree_max_depth(tree_dict)) plotTree.xOff = -0.5/plotTree.totalW plotTree.yOff = 1.0 plotTree(tree_dict, (0.5, 1.0), '') plt.show() 测试效果ID3、C4.5、CART 决策树显示使用课本 P76 西瓜数据集（不带序号） 测试代码1234567891011121314151617181920from DecisionTree import createDataSet, DecisionTree, createPlotdata, label, names = createDataSet(0)mtree = DecisionTree(data, label, names)mtree.loadTrainData()print("打印ID3决策树字典形式")mtree.startCreateTree(method='id3')print(mtree.tree)createPlot(mtree.tree)print("打印C4.5决策树字典形式")mtree.startCreateTree(method='c4.5')print(mtree.tree)createPlot(mtree.tree)print("打印CART决策树字典形式")mtree.startCreateTree(method='cart')print(mtree.tree)createPlot(mtree.tree) 测试结果12打印ID3决策树字典形式&#123;&apos;feature_name&apos;: &apos;纹理&apos;, &apos;清晰&apos;: &#123;&apos;feature_name&apos;: &apos;根蒂&apos;, &apos;蜷缩&apos;: &apos;是&apos;, &apos;硬挺&apos;: &apos;否&apos;, &apos;稍蜷&apos;: &#123;&apos;feature_name&apos;: &apos;色泽&apos;, &apos;乌黑&apos;: &#123;&apos;feature_name&apos;: &apos;触感&apos;, &apos;软粘&apos;: &apos;否&apos;, &apos;硬滑&apos;: &apos;是&apos;&#125;, &apos;青绿&apos;: &apos;是&apos;&#125;&#125;, &apos;模糊&apos;: &apos;否&apos;, &apos;稍糊&apos;: &#123;&apos;feature_name&apos;: &apos;触感&apos;, &apos;软粘&apos;: &apos;是&apos;, &apos;硬滑&apos;: &apos;否&apos;&#125;&#125; 12打印C4.5决策树字典形式&#123;&apos;feature_name&apos;: &apos;纹理&apos;, &apos;清晰&apos;: &#123;&apos;feature_name&apos;: &apos;触感&apos;, &apos;软粘&apos;: &#123;&apos;feature_name&apos;: &apos;色泽&apos;, &apos;乌黑&apos;: &apos;否&apos;, &apos;青绿&apos;: &#123;&apos;feature_name&apos;: &apos;根蒂&apos;, &apos;硬挺&apos;: &apos;否&apos;, &apos;稍蜷&apos;: &apos;是&apos;&#125;&#125;, &apos;硬滑&apos;: &apos;是&apos;&#125;, &apos;模糊&apos;: &apos;否&apos;, &apos;稍糊&apos;: &#123;&apos;feature_name&apos;: &apos;触感&apos;, &apos;软粘&apos;: &apos;是&apos;, &apos;硬滑&apos;: &apos;否&apos;&#125;&#125; 12打印CART决策树字典形式&#123;&apos;feature_name&apos;: &apos;纹理&apos;, (&apos;=&apos;, &apos;清晰&apos;): &#123;&apos;feature_name&apos;: &apos;触感&apos;, (&apos;=&apos;, &apos;软粘&apos;): &#123;&apos;feature_name&apos;: &apos;色泽&apos;, (&apos;=&apos;, &apos;乌黑&apos;): &apos;否&apos;, (&apos;!=&apos;, &apos;乌黑&apos;): &#123;&apos;feature_name&apos;: &apos;根蒂&apos;, (&apos;=&apos;, &apos;硬挺&apos;): &apos;否&apos;, (&apos;!=&apos;, &apos;硬挺&apos;): &apos;是&apos;&#125;&#125;, (&apos;!=&apos;, &apos;软粘&apos;): &apos;是&apos;&#125;, (&apos;!=&apos;, &apos;清晰&apos;): &#123;&apos;feature_name&apos;: &apos;色泽&apos;, (&apos;=&apos;, &apos;乌黑&apos;): &#123;&apos;feature_name&apos;: &apos;敲声&apos;, (&apos;=&apos;, &apos;浊响&apos;): &apos;是&apos;, (&apos;!=&apos;, &apos;浊响&apos;): &apos;否&apos;&#125;, (&apos;!=&apos;, &apos;乌黑&apos;): &apos;否&apos;&#125;&#125; 结果分析如图，均成功构建了不同的决策树。 ID3、C4.5 的属性偏好使用课本 P76 西瓜数据集（带序号），尝试反应 ID3 和 C4.5 使用信息增益对于属性值取值多少的偏好 测试代码1234567891011from DecisionTree import createDataSet, DecisionTree, createPlotdata, label, names = createDataSet(2)mtree = DecisionTree(data, label, names)mtree.loadTrainData()mtree.startCreateTree(method='id3')createPlot(mtree.tree)mtree.startCreateTree(method='c4.5')createPlot(mtree.tree) 测试结果 结果分析如预测，ID3 划分依据喜好多属性值的属性，在一些情况下会导致泛化性过差，C4.5 采用的信息增益率对属性值少的更偏好，我的代码并没有完整复现 C4.5 的思想，正如课本 P78 所说。 需注意的是，增益率准则对可取值数目较少的属性有所偏好，因此，C4.5 算法并不是直接选择增益率最大的候选划分属性，而是使用了一个启发式：先从候选划分属性中找到信息增益高于平均水平的属性，再从中选择增益率最高的。 阈值限制测试使用不带 id 的西瓜数据集，生成 ID3 决策树，代码中加入了 min_sample 的限制，当样本数量小于一定时选择里面的 major 类别代表该集合的类别，不再进一步划分。 测试代码1234567891011from DecisionTree import createDataSet, DecisionTree, createPlotdata, label, names = createDataSet(2)mtree = DecisionTree(data, label, names)mtree.loadTrainData()mtree.startCreateTree(method='id3', min_sample=2)createPlot(mtree.tree)mtree.startCreateTree(method='id3', min_sample=3)createPlot(mtree.tree) 测试结果 结果分析确实实现了一定程度上的简化 连续值处理实现对于现有集合的该连续值属性排序，然后枚举相邻两值的中点作为分界 point，属性值小于 point 的为一个集合，属性值大于 point 的为一个集合。然后计算两部分的信息增益（率），取该值最高的分界 point 作为该属性的分界 point 并返回。 数据集采用密度，含糖量集合，使用 ID3 决策树。 测试代码1234567from DecisionTree import createDataSet, DecisionTree, createPlotdata, label, names = createDataSet(1)mtree = DecisionTree(data, label, names)mtree.loadTrainData()mtree.startCreateTree(method='id3')createPlot(mtree.tree) 测试结果 结果分析可以看到对连续值属性也做了分割，通过间值选择了最佳的分割位置。 拓展预剪枝实现代码123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869def createPrecutTree(self, train_data, train_label, test_data, test_label, names, method, min_sample): """ createPrecutTree 构建当前预剪枝树结点 :param self: 类方法自带 :param train_data: 输入训练数据集 :param train_label: 输入训练标签集 :param test_data: 输入测试数据集 :param test_label: 输入测试标签集 :param names: 输入属性名集合 :param min_sample: 最小样本数量阈值 :return: 返回建立的节点 """ train_data = np.array(train_data, dtype=object) train_label = np.array(train_label, dtype=object) test_data = np.array(test_data, dtype=object) test_label = np.array(test_label, dtype=object) names = np.array(names, dtype=object) # 相同类别 if len(set(train_label)) == 1: return train_label[0] # 剩余样本量小于阈值 if train_data.size == 0 or train_label.size &lt;= min_sample: return self.majLabel(train_label) # 选取最优特征 best_feature_index, best_feature_name, best_value, best_ent, best_point = self.chooseBest( train_data, train_label, names, method) # 建立节点 node = &#123;"feature_name": best_feature_name&#125; child_train_data_set, child_train_label_set, child_name_set = self.splitData( train_data, train_label, names, best_feature_index, best_feature_name, best_value, best_point, method) main_train_label = self.majLabel(train_label) # 预剪枝衡量 if test_data is None: for feature_value in child_train_data_set.keys(): # 注意这里也要修改，不然后面节点都是无剪枝的 node[feature_value] = self.createPrecutTree( child_train_data_set[feature_value], child_train_label_set[feature_value], None, None, child_name_set, method, min_sample) else: child_test_data_set, child_test_label_set, child_name_set = self.splitData( test_data, test_label, names, best_feature_index, best_feature_name, best_value, best_point, method) # 划分前比率 pre_cut_ratio = test_label[test_label == main_train_label].size/test_label.size pos_cut_num = 0 for feature in child_train_label_set.keys(): if feature not in child_test_label_set.keys(): continue now_test_label = child_test_label_set[feature] now_majority_label = self.majLabel(now_test_label) pos_cut_num += now_test_label[now_test_label == now_majority_label].size pos_cut_ratio = pos_cut_num / test_label.size print("pre: "+str(pre_cut_ratio) + " post: "+str(pos_cut_ratio)) if(pre_cut_ratio &gt;= pos_cut_ratio): # 验证机精确度没有提升 return main_train_label for feature_value in child_train_data_set.keys(): # 注意这里也要修改，不然后面节点都是无剪枝的 node[feature_value] = self.createPrecutTree( child_train_data_set[feature_value], child_train_label_set[feature_value], child_test_data_set[feature_value], child_test_label_set[feature_value], child_name_set, method, min_sample) return node 测试代码1234567891011from DecisionTree import createDataSet, DecisionTree, createPlotdata, label, names = createDataSet(0)mtree = DecisionTree(data, label, names)mtree.loadTrainData(type=1, sz=0.4)mtree.startCreateTree(cut_type=0, method='id3')createPlot(mtree.tree)mtree.startCreateTree(cut_type=1, method='id3')createPlot(mtree.tree) 测试结果]]></content>
      <categories>
        <category>机器学习</category>
      </categories>
      <tags>
        <tag>机器学习</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[WordPress——Hexo导出xml并迁移]]></title>
    <url>%2Fpost%2F44da4894.html</url>
    <content type="text"><![CDATA[Hexo 导出 xml安装 feed 插件安装插件hexo-generator-feed。 1npm install hexo-generator-feed 使用插件在_config.yml文件添加以下内容 123456789101112plugins: hexo-generator-feed#Feed Atomfeed: #type: atom #path: atom.xml #limit: 20 #改为RSS2.0标准 type: rss2 path: rss2.xml limit: false hub: hexo g完成后从public文件夹中找对应的文件rss2.xml。这个 xml 就可以用来做订阅或者导入 WP 了。 WordPress 导入 xml登录到 WP 仪表盘（控制台），选择工具-&gt;导入-&gt;WordPress-&gt;现在安装-&gt;运行导入器 解决单次导入限制 2M 问题根据官方解释，可能是 php 和 nginx 两方面原因 php解除 wordpress 上传最大限制 访问 vps，找到 WP 根目录（很多 wp-xxx.php 的那个），编写文件.user.ini，写入如下内容： 1234567; Memory and file sizes memory_limit = 64M upload_max_filesize = 5M post_max_size = 5M file_uploads = On max_execution_time = 300 ; End Upload Restrictions nginx 打开 nginx 服务的配置文件nginx.conf,http 块中加入client_max_body_size xxm, xx根据需求改动。]]></content>
      <categories>
        <category>WordPress</category>
      </categories>
      <tags>
        <tag>WordPress</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[WordPress——网站搭建常见问题]]></title>
    <url>%2Fpost%2F785396af.html</url>
    <content type="text"><![CDATA[安装/删除主题或者插件时需要 FTP 用户名密码安装好 WP 后，无论是安装插件还是安装主题都会弹出框：权限缺失，需要 FTP 用户名和密码。实际上时服务器权限设置的问题。 解决方法 1：修改配置文件 修改wordpress目录下的wp-config.php，加上如下三行： 123define("FS_METHOD", "direct");define("FS_CHMOD_DIR", 0777);define("FS_CHMOD_FILE", 0777); 实际上是在上传时候修改权限。 解决方法 2：修改文件夹权限 如果你的 WP 按默认方式或者大多数教程方式，则/var/www/html/wordpress应是你的根目录，修改根目录权限 1sudo chmod -R 775 /var/www/html/wordpress 安装/删除主题或者插件时提示安装失败，无法创建目录源自解决 wordpress 下载插件，安装失败，无法创建目录问题 其实，出现无法创建目录的确是权限的问题，但是，不是目录读写的权限，而是用户组的问题。想要下载插件的用户组为 web 用户组，用户名组名为 www（大家可能不太一样，如果是按照我之前的方式装 lnmp 环境的同学，就是 www，可以在 ngnix.conf 中第一行查看，至于 nginx.conf 的位置就用 locate nginx.conf 搜索一下） ，而此时 wordpress 用户组为 root，这样就不能创建目录了，具体原因大家可以查阅 linux 相关知识。 查阅自己的nginx.conf文件确定用户，我的是www-data，所以在/var/www/html路径下修改wordpress文件夹的用户组就可以了。 1sudo chown -R www-data:www-data wordpress]]></content>
      <categories>
        <category>WordPress</category>
      </categories>
      <tags>
        <tag>WordPress</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[WordPress——ubuntu16建站指南]]></title>
    <url>%2Fpost%2F63282d5d.html</url>
    <content type="text"></content>
  </entry>
  <entry>
    <title><![CDATA[建国七十周年，我在思考什么]]></title>
    <url>%2Fpost%2F360c9b8d.html</url>
    <content type="text"><![CDATA[本文写于我的 UbuntuToGo 系统，VScode 编辑器。 建国七十周年，我在思考什么2019 年的夏天，注定是个不平凡的夏天。 退出校队，濒临失学，再度分手，或许多年以后再看此时遭遇的这些挫折，都算不了什么，但是后来人说今日事未免有了些时间对伤口的消毒处理，虽然缓慢，总是愈合了些的。 人不仅软弱，而且健忘，但是文字不同，日久弥新，越发坚实可靠。或许就是因为对文字这样的印象（或许是德池老师给的？），我才会扛着这从高中就不被人看好的文字功力，坚持经营着自己的博客吧。 仅以文字祭奠过去的种种。 意外相遇建国七十周年，我既没有选择和国旗和张影，也没有选择给头像一见生成一面国旗，相反，我的社交平台上对“国庆”二字丝毫没有提及，甚至对铺天盖地而来的“祖国万岁”等呼声有一些嗤之以鼻。 我开始质问自己： 为什么你对国庆看似无动于衷？ 为什么你对这些行为嗤之以鼻？ 以及由这些问题引出的一些深层次的问题 什么是爱国主义（Patriotism）？ 怎样算爱国行为？ 我爱国吗？ 无论我曾经有没有回答过自己，那些答案都没能给我留下足够深刻的印象以至我现在一九迷茫 我开始从自己反映的表象螺旋盘问自己，希望弄清点什么。 现在是 10 月 2 号晚上 8 点 42 分。 最后还是没能摆脱自己的拖延症，已经返程，目的与结果相差甚远的一场旅行，虽有收获，遗憾也留下很多。]]></content>
      <categories>
        <category>随笔</category>
      </categories>
      <tags>
        <tag>随笔</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[UbuntuToGo——Ubuntu系统配置与UI美化]]></title>
    <url>%2Fpost%2Ff9c435a6.html</url>
    <content type="text"><![CDATA[本文写于我的 UbuntuToGo 系统，VScode 编辑器。 系统配置如果想把手上做的这个 UbuntuToGo 做成随时随地插电脑就可以工作的 OS，首先不能忍的是软件包的下载速度。 我们需要把默认源更换为国内源。 更换源阿里源12345678910deb http://mirrors.aliyun.com/ubuntu/ bionic main restricted universe multiversedeb http://mirrors.aliyun.com/ubuntu/ bionic-security main restricted universe multiversedeb http://mirrors.aliyun.com/ubuntu/ bionic-updates main restricted universe multiversedeb http://mirrors.aliyun.com/ubuntu/ bionic-proposed main restricted universe multiversedeb http://mirrors.aliyun.com/ubuntu/ bionic-backports main restricted universe multiversedeb-src http://mirrors.aliyun.com/ubuntu/ bionic main restricted universe multiversedeb-src http://mirrors.aliyun.com/ubuntu/ bionic-security main restricted universe multiversedeb-src http://mirrors.aliyun.com/ubuntu/ bionic-updates main restricted universe multiversedeb-src http://mirrors.aliyun.com/ubuntu/ bionic-proposed main restricted universe multiversedeb-src http://mirrors.aliyun.com/ubuntu/ bionic-backports main restricted universe multiverse 清华源12345678910deb https://mirrors.tuna.tsinghua.edu.cn/ubuntu/ bionic main restricted universe multiversedeb-src https://mirrors.tuna.tsinghua.edu.cn/ubuntu/ bionic main restricted universe multiversedeb https://mirrors.tuna.tsinghua.edu.cn/ubuntu/ bionic-updates main restricted universe multiversedeb-src https://mirrors.tuna.tsinghua.edu.cn/ubuntu/ bionic-updates main restricted universe multiversedeb https://mirrors.tuna.tsinghua.edu.cn/ubuntu/ bionic-backports main restricted universe multiversedeb-src https://mirrors.tuna.tsinghua.edu.cn/ubuntu/ bionic-backports main restricted universe multiversedeb https://mirrors.tuna.tsinghua.edu.cn/ubuntu/ bionic-security main restricted universe multiversedeb-src https://mirrors.tuna.tsinghua.edu.cn/ubuntu/ bionic-security main restricted universe multiversedeb https://mirrors.tuna.tsinghua.edu.cn/ubuntu/ bionic-proposed main restricted universe multiversedeb-src https://mirrors.tuna.tsinghua.edu.cn/ubuntu/ bionic-proposed main restricted universe multiverse 更新 apt-get12sudo apt-get updatesudo apt-get upgrade 更换 shell 为 zsh其实我只是为了好看一些，网传 zsh 是最好用究极的 shell，顺手安了一波，而且配上 oh-my-zsh，简直不要太好看。 zsh 的下载与安装我使用的是apt-get install的方法，Ubuntu18.04 换源更新完以后安装 zsh 版本为 5.4.2，也不算很久，主要是安装起来方便一些。 1sudo apt-get install zsh 更换默认 Shell安装完成后，我们需要把默认 shell 改为 zsh。 1chsh -s /bin/zsh 注意：这里不要使用 sudo 这样 zsh 就安装完成了～，还没有深入研究 zsh，不过一个快捷的地方就是数字 1，2，3 可以使你访问到最近常去的目录，还是比较方便的。 美化 zsh当初吸引我去安装 zsh 就是因为它的美化可以显示 git 目录的分支、提交状态，真的炫到我了，就像下面这张图一样： 安装 oh-my-zsh使用命令 1sh -c "$(wget -O- https://raw.githubusercontent.com/robbyrussell/oh-my-zsh/master/tools/install.sh)" 主题配置_Note: many themes require installing the Powerline Fonts in order to render properly._ 注意：许多主题要求安装 Powerline Fonts，缺少字体而产生的乱码请安装字体后再做尝试。 我们需要编辑~/.zshrc文件： 修改其中的ZSH_THEME=&quot;robbyrussell&quot;为指定的样式 1sudo vim ~/.zshrc 当然，根据官网教程，你也可以来个随即 RP 主题： 然后source ~/.zshrc即可。 美化 Grub根据这篇文章：Grub2 主题修改和美化 学习了一下引导界面的美化。 下载 grub 主题包从gnome-look.org选择自己喜欢的主题下载。 发现了一个宝藏设计师：Vince 刘。他设计的几款我觉得都蛮好看的。 费话不多说，开始美化我们的 grub 界面。 创建 themes 文件夹ctrl+alt+T打开终端，输入以下命令： 1sudo mkdir /boot/grub/themes 解压主题包在主题包压缩文件所在位置（我的是~/Downloads）使用对应命令解压主题包： 1sudo tar -xf xxx.tar.gz 或者 1sudo unzip xxx.zip 移动主题包至指定目录执行命令 1sudo cp -rf 主题包名 /boot/grub/themes 注意： -rf 是递归强制强目录里所有文件也拷贝至目标位置，没有参数会报错。 执行脚本/配置文件 针对包内已经有 theme.txt 文件的主题 比如poly-light-master主题，cp 文件后，直接修改配置文件： 1sudo vim /etc/grub.d/00_header 在首页注释后添加 12GRUB_THEME="/boot/grub/themes/主题包名/theme.txt"GRUB_GFXMODE="1920x1080x32" 针对包内无 theme.txt 文件的主题 比如 Vince 设计的几款，需要在进入文件目录内执行脚本 1udo ./install-xxx.sh 具体看文件名，完成后会在 themes 出现一个新的目录，如下图： 再根据 1 修改配置文件即可。 效果展示示意图]]></content>
      <categories>
        <category>操作系统</category>
        <category>UbuntuToGo</category>
      </categories>
      <tags>
        <tag>Ubuntu</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[UbuntuToGo——打造属于自己的移动固态热插拔Liniux操作系统]]></title>
    <url>%2Fpost%2F8bb234ab.html</url>
    <content type="text"><![CDATA[本文写于我的 UbuntuToGo 系统，VScode 编辑器。 前言暑假末期给自己的戴尔游匣老本子换了西数固态，退役下来的一块 Toshiba 128G 的老固态成了闲置，拿来当移动硬盘总觉得有些浪费。恰好这时候一个室友做了个 WinToGo，“移动硬盘，移动系统，即插即用”，听起来很美妙的样子，便想着可否做个 Ubuntu 的移动版。 网上找了几篇资料给了我不小的启发，也算是顺着上面的教程加上自己的摸爬滚打完成的。 把 Ubuntu16.04 装进移动硬盘的惨痛实战 感谢先驱者的宝贵经验。 准备工作本文采用 U 盘引导 UEFI 安装的方式，希望虚拟机安装或者想用需要用 Legancy 启动的童鞋请参见这两篇文章：IT 之家学院：制作同时适用于 Legacy/UEFI 的 Ubuntu To Go 启动盘，Ubuntu To Go | 制作属于你的随身 Ubuntu 系统盘 启动 U 盘：一个 32G 的 Ubuntu 系统启动盘（需格式化） 移动 SSD：一个 128G 东芝的 SSD+硬盘盒（买壳子注意 M.2 接口类型以及支持协议，老的 SSD 并不是 NVMe 协议的，原理上只需要盘中有未分配空间即可，实操中建议先行备份以防杯具） Ubuntu 系统镜像文件：Ubuntu 桌面下载 18.04.3 LTS 启动盘制作软件 Rufus：官网下载Rufus3.8 你的脑子 制作启动盘下载好我们需要的镜像文件后，插入 U 盘，进行刻录（下图中是以硬盘为例，具体使用时无需点选显示外接硬盘，选择对应 U 盘即可） 安装 Ubuntu选择试用 Ubuntu 系统完成启动 U 盘制作后重启，进入 BIOS 界面（品牌机子 logo 处按对应键，一般为 F2，F9，F12 等，自行查手册），然后选择引导为 UEFI 并选择 Secure Off。 然后选择 U 盘启动项，grub 菜单选择 Try Ubuntu（试用 Ubuntu），进入试用的 Ubuntu 18.04 主界面。桌面上应该有一个 Install，这样操作的原因是为了避免直接安装 Ubuntu 过程中采用默认方案与原 Windows 整合 EFI 导致拔出硬盘后无法启动，且分区无法调整。 Gparted 分区调整确认建议使用试用系统上自带的分区调整工具：Gparted 进行分区的调整，如对 SSD 移动硬盘划分空闲区域与分区，确认设备名称等（sdx/nvmex）。 已经安装完成的系统好像并不能启动 Gparted（实际上是我不会），就不放图了。 自定义安装 Ubuntu双机桌面的 Install Ubuntu，进入安装，网速差的建议不联 Wifi 进行安装，后续换源后提速再安装其他必要包（比如语言包）。 建议选择英文，避免命令行、文件路径出现一些迷之错误。 记得选择其他方式安装，不与现有系统（Windows）整合或者格式化当前系统盘。 （后面几张图来源于网络） 挂载分区由于我们不需要通过 Legency 模式启动，无需考虑/boot，在安装过程中直接挂在分区即可。 在随后的这个界面中，假设/dev/sda 是你的想要安装系统的移动盘，选中其下的所有盘符，点击下面的“－”删去不需要的分区（相当于格式化），然后点击 free space，点击下面的“＋”，按下图挂载三个 partition： 交换分区（建议 8G 与内存大小相同） swap，主分区 操作系统里面讲的留在硬盘里换入换出的交换区。 根目录（“/”，建议 10-50GB） ext4，主分区 空间有充分盈余的话可以考虑多给一些，毕竟是 SSD 固态速度不会很慢，而且 10G 装软件真的不够用，如果后续还需要添加空间只能通过外置硬盘引导开机然后重新调整分区方式了 home（“/home”，建议 30-50GB） ext4 储存各种用户文件，建议分配较多空间。 由于介质是固态硬盘，除了交换分区外，格式均无需拘泥于 FAT32，建议选择 ext4，亲测可行。 注意点： 最下方“Device for boot loader installation”，选择你的移动硬盘（不要误选，且不要选择成后面的分区） 启动引导修复安装完后重启进入 BIOS，启动项多了 ubuntu 一项，点选后正常进入 ubuntu 系统，但是插在其他电脑上并不能像 U 盘一样被检测识别。 用 DiskGenuis 观察 U 盘启动盘与移动硬盘系统不同，发现移动硬盘并无 EFI 分区（如果分区时分了 EFI，应该会发现该分区为空）。 启动盘启动在本系统运行下无法修复引导，老样子通过 U 盘启动盘选择 Try Ubuntu 进入系统。 ctrl+alt+T打开终端，输入以下命令： 123sudo add-apt-repository 最上方ppa:yannubuntu/boot-repair最上方sudo apt-get update最上方sudo apt-get install boot-repair 安装 boot-repair 工具（由于源的问题下载可能会很慢） 安装后打开 boot-repair 选择 Recommended repair，修复完成即可。 这时候关机拔下硬盘就可以在其他机器的 BIOS 识别并运行了。返回 Windows 系统使用 DiskGenius 分析发现 EFI 分区填充部分内容。 其他常见问题显卡驱动问题在使用两次后发现插入现在用的 Dell 笔记本和部分笔记本，进入用户登陆密码界面输入密码正确后，鼠标卡住，短暂黑屏后自动关机，无法进入系统。 查阅部分资料后发现大概率为显卡驱动（主要是 Nvida 笔记本独显与原装的开源驱动不适配导致的）。 修复方法如下 Ubuntu高级模式启动这个模式貌似可以忽略显卡驱动的问题（怪不得分辨率小的可怜），BIOS选择ubuntu启动后，进入界面按ESC（或者默认情况）进入grub界面，选择Ubuntu高级模式（常为第二个）。 正常输入密码后进入系统，若此方法行不通请自行查找单用户模式等进入方法。 更换驱动软件和更新（Software &amp; Updates）-&gt;附加驱动（Additional Drivers） 改用nvidia-driver-390驱动。 更新后重启进入ubuntu系统，输入密码后正常进入系统 Terminal乱码问题常发生在换用zsh和oh-my-zsh后乱码。 安装必须字体，从设置（Setting）-&gt; 地区和语言（Region &amp; Language）更改一下language和formats然后改回来即可。 拔出硬盘后默认系统不能启动从BIOS修改启动顺序，将Windows（原系统）调整到最上方。]]></content>
      <categories>
        <category>操作系统</category>
        <category>UbuntuToGo</category>
      </categories>
      <tags>
        <tag>UbuntuToGo</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[数字图像处理——直方图匹配]]></title>
    <url>%2Fpost%2F973eccf1.html</url>
    <content type="text"><![CDATA[基本概念上一篇文章讲了直方图均衡相关内容，从实际应用中我们发现，只能对直方图做均衡操作并不能完全满足我们的需要，有时我们更希望调整概率分布（直方图）为指定形状，这就是直方图匹配。 比如下图图一猫咪的直方图较为集中在中间，我们希望它的分布贴近第二幅文字图的分布（集中在暗区域） 数学基础从上一篇文章的介绍中我们发现，对于任何图像（$r$的概率密度分布），我们都可以通过其累积分布函数将其函数变换到随机变量$s$，而$s$是均匀分布的。那我们反过来想，能否将均匀分布的随机变量逆变换到某个特定的分布呢？ 公式推导设$r$为随机变量值域为$[0,255]$，其概率密度函数为$p_r(r)$。一函数（变换为）： s = T(r) = (L-1) \int_{0}^{r} p_r(m) \mathrm{d}m由上一篇文章我们易知$s$服从均匀分布，我们寻找一个$z$随机变量符合另一特殊分布$p_z(z)$，易知存在一函数（变换）： s = G(z) = (L-1) \int_{0}^{z} p_z(m) \mathrm{d}m由于$G(z)$为累积分布函数，单调，故存在反函数$G^{-1}(z)$，则有新变换 $N = G^{-1} \cdot T$，使得$r$随机变量经$N$变换后符合$z$的分布特征。 z = G^{-1}(s) = G^{-1}(T(r)) = N(r)由此，我们找到了某值域内求从某一分布随机变量$r$变换到指定分布随机变量$z$的方法。 个人理解直方图均衡，均匀分布，实际上在中间做了桥接。 实验效果均衡化输出两幅图原图以及均衡化后的图片，直方图。 直观对比两图的累积分布函数与直方图 $T(r)$表示$r$的累积分布函数，本样例中为小猫图像的累积分布函数，图示为淡蓝色曲线。$G(z)$表示为$z$的累积分布函数，本样例中为文字图片的累积分布函数，图示为橙黄色曲线。 求反函数反函数的计算，并没有按照课本上所说，搜索找最近值，对于一张$m \times n$图像，对于每个搜索需要$O(log(L))$，总复杂度是相乘的关系$O(MNlog(L))$，而通过一个二重循环实现打表计算则可以优化到$O(MN)+O(L)$，对于实际图片$MN$远大于$L$，所以这种优化是值得的 123456cnt = 0for i in range(256): while cnt&lt;=raw_table[i]: new_table[cnt] = i cnt+=1return new_table 计算反函数表方便后面对图像进行变换。 123reverse_imtest1_table = GetReverseTable(imtest1_tabel)match_imtest0_table = reverse_imtest1_table[imtest0_tabel]match_imtest0 = match_imtest0_table[imtest0] 输出结果如下 直方图对比表示了 image0，image1，匹配后的 image0 三图，由图可以看出匹配后的 image0 直方图分布已经很贴近 image1 了。 图片效果（小猫被玩的有点可怜） 核心代码图像直方图展示12345678910111213141516# 展示直方图def DrawHist(input_img,pic_handle,histogram_handle): kwargs = dict(bins = 50, histtype='bar', edgecolor = "white",alpha=0.5, density = True) pic_handle.set_title("The image") pic_handle.imshow(input_img) histogram_handle.set_title("The histogram") histogram_handle.hist(input_img.flatten(),**kwargs)imtest0 = imageio.imread('imageio:chelsea.png')imtest1 = GetRGB('./3_3Photo/3.jpg')plt.figure(figsize=(20,10))DrawHist(imtest0,plt.subplot(221),plt.subplot(222))DrawHist(imtest1,plt.subplot(223),plt.subplot(224))plt.show() 直方图匹配12345678910# 获取目标图像累积分布函数的反函数lut表（离散）def GetReverseTable(raw_table): new_table = np.zeros(256,dtype = np.int64) cnt = 0 for i in range(256): while cnt&lt;=raw_table[i]: new_table[cnt] = i cnt+=1 return new_table 加入反函数输出12345678910111213141516171819202122# 加入反函数，再绘图plt.figure(figsize=(15,5))plotline = plt.subplot(121)plotline.set_title("The function")plotline.plot(np.arange(256),imtest0_tabel,label = "$T(r)$")plotline.plot(np.arange(256),np.arange(256),color = "black",label = "$r$")plotline.plot(np.arange(256),imtest1_tabel,label = "$G(z)$")plotline.plot(np.arange(256),reverse_imtest1_table, label = "$G^&#123;-1&#125;(z)$")plotline.plot(np.arange(256),match_imtest0_table, label= "$G^&#123;-1&#125;(T(r)), N(r)$")plotline.legend()# 设置直方图参数 分割块 叠加模式 边界颜色 透明度 正则化（映射到0~1）kwargs = dict(bins = 50, histtype='bar', edgecolor = "white",alpha=0.5, density = True)histogram1 = plt.subplot(122)histogram1.set_title("The histogram")histogram1.hist(imtest0.flatten(),color = "black",label = "imtest0 original",**kwargs )histogram1.hist(imtest1.flatten(),label = "imtest1 original",**kwargs)histogram1.hist(match_imtest0.flatten(),label = "imtest0 after match",**kwargs)histogram1.legend()plt.show() 完整代码123456import numpy as npimport imageioimport cv2import matplotlib.pyplot as pltim = imageio.imread('photo2.jpg') 12345# 获取RGB图像def GetRGB(path): im_BGR = cv2.imread(path,cv2.COLOR_GRAY2RGB) im = cv2.cvtColor(im_BGR,cv2.COLOR_BGR2RGB) return im 12345678910111213141516# 展示直方图def DrawHist(input_img,pic_handle,histogram_handle): kwargs = dict(bins = 50, histtype='bar', edgecolor = "white",alpha=0.5, density = True) pic_handle.set_title("The image") pic_handle.imshow(input_img) histogram_handle.set_title("The histogram") histogram_handle.hist(input_img.flatten(),**kwargs)imtest0 = imageio.imread('imageio:chelsea.png')imtest1 = GetRGB('./3_3Photo/3.jpg')plt.figure(figsize=(20,10))DrawHist(imtest0,plt.subplot(221),plt.subplot(222))DrawHist(imtest1,plt.subplot(223),plt.subplot(224))plt.show() 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172# 尝试直方图均衡化，def CaculateHistogram(input_image): # 参数1. 单通道8位灰度图像 # 输出1. 总像素值 # 输出2. 灰度值分布计数 # 输出3. 灰度值分布前缀和（用来做后续直方图平局奴化） # 区分通道 if len(np.shape(input_image)) == 3: height,width,level = np.shape(input_image) summ = height*width*level else : height,width = np.shape(input_image) summ = height*width# 第一种 通过访问指定位置像素 耗时executed in 7m 9s# 巨慢无比# for i in range(height):# for j in range(width):# caculate_num[input_image[i][j]] += 1# 第二种 直接拆分行，像素获取像素值 耗时executed in 14.4s# for line in input_image:# for px in line:# caculate_num[px] +=1# 第三种 调用np.histogram()方法 耗时executed in 644ms caculate_num,index_x = GetHistogramArray(input_image) caculate_num = np.append(caculate_num,1)# print(np.shape(caculate_num)) # 第四种 吕少推荐的方法(还没看懂)# caculate_num = cumsum(input_image,256)# print(np.shape(caculate_num)) sum_num = np.copy(caculate_num) for i in range(1,256):# print(sum_num[i-1],caculate_num[i]) sum_num[i] = sum_num[i-1] + sum_num[i] return summ,caculate_num,sum_numdef GetHistogramArray(image): return np.histogram(image,np.arange(0,256));def cumsum(img, bins): histogram = np.zeros(bins) for pixel in np.arange(0, bins, 1): histogram[pixel] += len(img[img==pixel]) return histogramdef HistogramEqualizationLUT(input_image): # 参数1, 单通道8位灰度图像 # 输出1. 单通道8位灰度图像（直方图均衡化后） size,data,data_sum = CaculateHistogram(input_image) fxy = lambda x: (255*data_sum[x])//size table = np.array([fxy(i) for i in range(256)])# print(table)# 不可以这样# image_new = table[input_image] lut = lambda x: table[x] return lut(input_image),tableimtest0_he,imtest0_tabel = HistogramEqualizationLUT(imtest0)imtest1_he,imtest1_tabel = HistogramEqualizationLUT(imtest1)plt.figure(figsize=(20,20))DrawHist(imtest0,plt.subplot(421),plt.subplot(422))DrawHist(imtest0_he,plt.subplot(423),plt.subplot(424))DrawHist(imtest1,plt.subplot(425),plt.subplot(426))DrawHist(imtest1_he,plt.subplot(427),plt.subplot(428)) 123456789101112131415plt.figure(figsize=(15,5))plotline = plt.subplot(121)plotline.set_title("The function")plotline.plot(np.arange(256),np.arange(256),color = 'black',label = "$r$")plotline.plot(np.arange(256),imtest0_tabel,label = "$T(r)$")plotline.plot(np.arange(256),imtest1_tabel,label = "$G(z)$")plotline.legend()kwargs = dict(bins = 50, histtype='bar', edgecolor = "white",alpha=0.6, density = True)histogram = plt.subplot(122)histogram.set_title("The histogram")histogram.hist(imtest0.flatten(),**kwargs, label = "imtest0 $p_r(r)$" )histogram.hist(imtest1.flatten(), **kwargs, label = "imtest1 $p_z(z)$")histogram.legend()plt.show() 1234567891011121314# 获取目标图像累积分布函数的反函数lut表（离散）def GetReverseTable(raw_table): new_table = np.zeros(256,dtype = np.int64) cnt = 0 for i in range(256): while cnt&lt;=raw_table[i]: new_table[cnt] = i cnt+=1 return new_tablereverse_imtest1_table = GetReverseTable(imtest1_tabel)match_imtest0_table = reverse_imtest1_table[imtest0_tabel]match_imtest0 = match_imtest0_table[imtest0] 12345678910111213141516171819202122# 加入反函数，再绘图plt.figure(figsize=(15,5))plotline = plt.subplot(121)plotline.set_title("The function")plotline.plot(np.arange(256),imtest0_tabel,label = "$T(r)$")plotline.plot(np.arange(256),np.arange(256),color = "black",label = "$r$")plotline.plot(np.arange(256),imtest1_tabel,label = "$G(z)$")plotline.plot(np.arange(256),reverse_imtest1_table, label = "$G^&#123;-1&#125;(z)$")plotline.plot(np.arange(256),match_imtest0_table, label= "$G^&#123;-1&#125;(T(r)), N(r)$")plotline.legend()# 设置直方图参数 分割块 叠加模式 边界颜色 透明度 正则化（映射到0~1）kwargs = dict(bins = 50, histtype='bar', edgecolor = "white",alpha=0.5, density = True)histogram1 = plt.subplot(122)histogram1.set_title("The histogram")histogram1.hist(imtest0.flatten(),color = "black",label = "imtest0 original",**kwargs )histogram1.hist(imtest1.flatten(),label = "imtest1 original",**kwargs)histogram1.hist(match_imtest0.flatten(),label = "imtest0 after match",**kwargs)histogram1.legend()plt.show() 123456# 输出三种图像plt.figure(figsize=(20,15))DrawHist(imtest0,plt.subplot(321),plt.subplot(322))DrawHist(imtest0_he,plt.subplot(323),plt.subplot(324))DrawHist(match_imtest0,plt.subplot(325),plt.subplot(326))plt.show()]]></content>
      <categories>
        <category>数字图像处理</category>
      </categories>
      <tags>
        <tag>数字图像处理</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[数字图像处理——直方图均衡]]></title>
    <url>%2Fpost%2Fb44049c5.html</url>
    <content type="text"><![CDATA[基本概念对于一张$8$位灰度图像，像素灰度值$r \in [0,256), r \in Z$，必然满足一特定的概率分布$p(x)$，直方图可理解为分块显示的概率密度函数。 以下面几图为例（彩色图取 R 通道） (代码见附录) 由图片可以看出来，图一小猫亮度高的地方更多，所以直方图上显示出在灰度级高端分布更密集，而图二的风景图相反，图三的阿童木则明显亮暗区分较为明显，所以在直方图上体现为两极化。 在某些情况下，我们希望通过某种函数变换$s = T(r)$，使变换后的函数概率分布均匀化（或贴近均匀），这就是直方图均衡 概率论基础根据课本 P74 页，$p_r(r)$和$p_s(s)$分别表示随机变量$r$和$s$的概率密度函数，概率论的一个基本结果是，如果$p_r(r)$和$T(r)$已知且$s = T(r)$具备单调性，在感兴趣的值域上是连续且可微的，则变换后的变量$s$的概率密度函数可由下面的简单公式得到： p_s(s) = p_r(r) \left| \frac{\mathrm{d}r}{\mathrm{d}s} \right|这个式子怎么推导的呢？实际上我们就是在求一个随机变量函数的概率分布，概率论是学过的，这里回忆一下给出推导。 设$r$为随机变量，其概率分布符合$p_r(r)$，另有一单调的函数（变换）$s = T(r)$，现在求$s$的概率分布，设$r$值域均为$[0,L-1]$。 由分布函数公式 F(x) = \int_{0}^{x} p(m) \mathrm{d}m得$r$得分布函数 F_r(r) = \int_{0}^{r} p_r(m) \mathrm{d}m又因为$s = T(r)$为单调函数，存在反函数$r = T^{-1}(s)$ F_s(s) = F_r(T^{-1}(s)) = \int_{0}^{ T^{-1}(s) } p_r(m) \mathrm{d}m概率密度函数为分布函数的导数 p_s(s) = \left| \frac{\mathrm{d} F_s(s)}{\mathrm{d}s} \right|应用链式求导法则 p_s(s) = \left| \frac{\mathrm{d}F_s(s)}{\mathrm{d}s} \right|p_s(s) = \frac{\mathrm{d}F_r(r)}{\mathrm{d}r} \left| \frac{ \mathrm{d} r}{ \mathrm{d}s} \right|p_s(s) = p_r(r) \left| \frac{ \mathrm{d} r}{ \mathrm{d}s} \right|则得到了书本上的公式。 均衡变换有了上述式子，我们会发现特殊的性质 若$T(r)$恰为$r$的分布函数，则 s = T(r) = \int_{0}^{r} p_r(m) \mathrm{d}m\frac{\mathrm{d}s}{\mathrm{d}r} = p_r(r)p_s(s) = p_r(r) \left| \frac{ \mathrm{d} r}{ \mathrm{d}s} \right| = p_r(r) \frac{1}{p_r(r)} = 1则$s$为均匀分布$s \in [0,1]$ 且$p_s(s)$值恒为$1$ 若$T(r)$为$r$分布函数映射到$[0,L-1]$，则 s = T(r) = (L-1) \int_{0}^{r} p_r(m) \mathrm{d}mp_s(s) = p_r(r) \frac{1}{(L-1) p_r(r)} = \frac{1}{L-1}则$s$为均匀分布，且$p_s(s)=\frac{1}{L-1}$ 这便是我们想要的函数变换，无论$p_r(r)$分布如何，经过这种类分布函数的函数变换，得到的$p_s(s)$就是一个均匀分布。 三通道混合均衡 vs. 分别均衡平台的讨论区里留下了一个有趣的问题：对于三通道 RGB 图像，对每个通道均衡后合并的图像有时会产生严重的色彩失真。 我的一点理解： 何为失真在我们的处理过程中，色彩失真（与实际偏差过大），我们可以简单理解为显色偏向与原图产生较大差异，产生新的偏色甚至反向偏色。 我的实验我将一张自己原来拍摄的风景图，R，G，B 三个通道分别进行了直方图均衡，但是没有一同合并，而是与当前未变换的剩下两通道叠加后的图片。 下图是原图，分离的红色通道均衡化图（灰度），均衡化红色通道与原剩余通道叠加图 结合原图与与直方图我们不难看出，由于是夜晚照的风景照，整体画面大部分偏暗，所以三个通道的直方图都集中在灰度较低的地方（分布略有偏差）。 当我只均衡一个通道时，该通道直方图中高灰度区域很明显会被提拉上来。 而相较于其他两通道的中高灰度，被均衡的通道明显概率分布更大。 所以整体画面会偏向均衡的通道的颜色，如最下面三张合并后的效果所示。 进一步思考这种均衡的变换同时也会牺牲掉原本通道高亮的部分，上图蓝色通道的变换最容易看出这种效果。 均衡化的蓝色通道和剩余两通道合并后的图像中，道路灯光周围较暗的区域更偏向红橙色，这是因为牺牲了原本蓝色在这一灰度范围分布密度的优势，均摊到其他灰度区域后，红绿通道便更加凸显。 进两步思考无论是从数学推导，还是上述直方图，函数曲线都可以看出来，不同通道颜色的概率密度函数还有累积分布函数都是不同的，则不同通道像素值的相对大小就可能发生改变。 举个例子，若红色通道$T_{red}(2) = 8$，而蓝色通道${T_{blue}(5) = 6}$，绿色通道假定不变，则原来像素点$a = (2,4,5)$ 变换后为$a’ = (8,4,6)$由偏向蓝色变为偏向红色。 不同通道值对变换后不保序（相同通道由于同一函数单调性确定，必然保序），导致了失真的可能性变大。 因而，若采用三通道合并计算灰度的概率分布然后计算累积分布函数的话，由于使用相同的函数变换，无论是相同通道还是不同通道的两个值$i$,$j$，经函数变换后保留其大小关系，如$i&lt;j \to T(i) &lt; T(j)$。 这样，虽然在一定程度上牺牲了逐个通道的均衡化效果，但整体上避免了颜色的失真。 进三步思考实验我使用了一些图片做验证，左中右分别对应原图、三通道分别均衡化、整体均衡化的函数曲线和图像。 结论基本符合预期，整体均衡可以最大程度保留颜色的保真度，三通道虽然在各颜色通道都可以达到均衡效果，但是会造成一定的颜色失真。 核心代码获取 RGB 三通道图像需要注意的是，cv2 读取图像为 BGR，需要转换成 RGB。 1234def GetRGB(path): im_BGR = cv2.imread(path,cv2.COLOR_GRAY2RGB) im = cv2.cvtColor(im_BGR,cv2.COLOR_BGR2RGB) return im 获取不同灰度值计数值 通过访问指定位置像素 相同测试环境，耗时 7m9s（最慢） 123for i in range(height): for j in range(width): caculate_num[input_image[i][j]] += 1 遍历元素 相同测试环境，耗时 14.4s（较慢） 123for line in input_image: for px in line: caculate_num[px] +=1 向量化比较 相同测试环境，耗时小于 10s（较快） 解释加速原理，img==pixel 得到一个 bool 数组，而 img[]则取出数组为真值的 index 数组，然后就可以用 len()计数了。比较产生 bool 数组是向量操作，底层优化，所以加速效果明显。 12345678def cumsum(img, bins): histogram = np.zeros(bins) for pixel in np.arange(0, bins, 1): histogram[pixel] += len(img[img==pixel])return histogramcaculate_num = cumsum(input_image,256)print(np.shape(caculate_num)) 调用 np.histogram()的方法 相同测试环境，耗时 644ms（最快） 快的原因不了解，有时间看看源码 12caculate_num,index_x = np.histogram(input_image,np.arange(0,256)) caculate_num = np.append(caculate_num,1) 直方图均衡化输入三通/单通道图像，返回均衡化后的图像和查找表 123456789101112131415161718192021222324252627282930313233def CaculateHistogram(input_image): # 参数1. 图像 # 输出1. 总像素值 # 输出2. 灰度值分布计数 # 输出3. 灰度值分布前缀和（用来做后续直方图平局奴化） # 区分单通道还是三通道图像 if len(np.shape(input_image)) == 3: height,width,level = np.shape(input_image) summ = height*width*level else : height,width = np.shape(input_image) summ = height*width caculate_num,index_x = np.histogram(input_image,np.arange(0,256)) caculate_num = np.append(caculate_num,1) sum_num = np.copy(caculate_num) for i in range(1,256): sum_num[i] = sum_num[i-1] + sum_num[i] return summ,caculate_num,sum_numdef cumsum(img, bins): histogram = np.zeros(bins) for pixel in np.arange(0, bins, 1): histogram[pixel] += len(img[img==pixel]) return histogramdef HistogramEqualizationLUT(input_image): size,data,data_sum = CaculateHistogram(input_image) fxy = lambda x: (255*data_sum[x])//size table = np.array([fxy(i) for i in range(256)]) lut = lambda x: table[x] return lut(input_image),table 注意要用 lambda，不可以直接 input_new = table[input_image] 绘图函数12345678910111213141516171819202122232425262728293031323334353637383940# OK, Do something interesting!# 写一个整合函数，对每个输入图像的三通道都画出其三通道的函数变换图像和def DrawPerChannel(input_img,split_channel : int, channel_color ,plotline = None, histogram = None, pic = None):# 该通道的均衡曲线（分布函数曲线）# 获取分离的通道 input_channel = input_img[:,:,split_channel] temp_he,temp_table = HistogramEqualizationLUT(input_channel) if plotline != None: plotline.set_title("The function of "+channel_color+" channel") plotline.plot(np.arange(256),np.arange(256),color = "black",label = "$r_&#123;" + channel_color +"&#125;$") plotline.plot(np.arange(256),temp_table,color = channel_color ,label = "$T(r_&#123;"+ channel_color +"&#125;)$") plotline.legend()# 该通道的灰度分布直方图 if histogram != None: kwargs = dict(bins = 25, histtype='bar', edgecolor = "white",alpha=0.5, density = True) histogram.set_title("The histogram of "+channel_color+" channel") histogram.hist(input_channel.flatten(), color = "black",**kwargs, label = channel_color +" original") histogram.hist(temp_he.flatten(), color = channel_color , **kwargs, label = channel_color +" after he") histogram.legend()# 该通道均匀后叠加到原图像的效果 if pic != None: show_img = input_img.copy() show_img[:,:,split_channel] = temp_he pic.imshow(show_img)def DrawChannelsEqualization(img_with_3channels): plt.figure(figsize=(30,30))# 调用库函数# r,g,b = cv2.split(im)# 直接分离# r,g,b = img_with_3channels[:,:,0],img_with_3channels[:,:,1],img_with_3channels[:,:,2] DrawPerChannel(img_with_3channels,0,"red",plt.subplot(331),plt.subplot(334),plt.subplot(337)) DrawPerChannel(img_with_3channels,1,"green",plt.subplot(332),plt.subplot(335),plt.subplot(338)) DrawPerChannel(img_with_3channels,2,"blue",plt.subplot(333),plt.subplot(336),plt.subplot(339)) plt.show() 12345678910111213141516171819202122232425262728293031# 测试三通道分别做均衡化后效果和采取统一函数做均衡化的效果def DrawCompareEqualization(im_with_3_channel): together_img,together_table = HistogramEqualizationLUT(im_with_3_channel) seperate_img = im_with_3_channel.copy() seperate_table = np.array([together_table,together_table,together_table]) for i in range(3): seperate_img[:,:,i],seperate_table[i] = HistogramEqualizationLUT(im_with_3_channel[:,:,i]) plt.figure(figsize=(15,10)) plotline0 = plt.subplot(231) plotline0.set_title("No Change") plotline0.plot(np.arange(256),np.arange(256),color = "black",label = "$r$") plotline1 = plt.subplot(232) plotline1.set_title("Seperate Change") plotline1.plot(np.arange(256),np.arange(256),color = "black",label = "$r$") plotline1.plot(np.arange(256),seperate_table[0],color = "red" ,label = "$T(r_&#123;red&#125;)$") plotline1.plot(np.arange(256),seperate_table[1],color = "green" ,label = "$T(r_&#123;green&#125;)$") plotline1.plot(np.arange(256),seperate_table[2],color = "blue" ,label = "$T(r_&#123;blue&#125;)$") plotline1.legend() plotline2 = plt.subplot(233) plotline2.set_title("Together Change") plotline2.plot(np.arange(256),np.arange(256),color = "black",label = "$r$") plotline2.plot(np.arange(256),together_table,color = "orange" ,label = "$T(r_&#123;together&#125;)$") plotline2.legend() pic0 = plt.subplot(234) pic0.imshow(im_with_3_channel) pic1 = plt.subplot(235) pic1.imshow(seperate_img) pic2 = plt.subplot(236) pic2.imshow(together_img) plt.show() 完整代码1234import numpy as npimport cv2import imageioimport matplotlib.pyplot as plt 123456def GetRGB(path): im_BGR = cv2.imread(path,cv2.COLOR_GRAY2RGB) im = cv2.cvtColor(im_BGR,cv2.COLOR_BGR2RGB) return imim = GetRGB('./3_2Photo/1.jpg') 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465666768697071727374757677787980818283848586878889909192939495969798# 尝试直方图均衡化，def CaculateHistogram(input_image): # 参数1. 单通道8位灰度图像 # 输出1. 总像素值 # 输出2. 灰度值分布计数 # 输出3. 灰度值分布前缀和（用来做后续直方图平局奴化） # 区分通道 if len(np.shape(input_image)) == 3: height,width,level = np.shape(input_image) summ = height*width*level else : height,width = np.shape(input_image) summ = height*width# 第一种 通过访问指定位置像素 耗时executed in 7m 9s# 巨慢无比# for i in range(height):# for j in range(width):# caculate_num[input_image[i][j]] += 1# 第二种 直接拆分行，像素获取像素值 耗时executed in 14.4s# for line in input_image:# for px in line:# caculate_num[px] +=1# 第三种 调用np.histogram()方法 耗时executed in 644ms caculate_num,index_x = GetHistogramArray(input_image) caculate_num = np.append(caculate_num,1)# print(np.shape(caculate_num)) # 第四种 吕少推荐的方法(还没看懂)# caculate_num = cumsum(input_image,256)# print(np.shape(caculate_num)) sum_num = np.copy(caculate_num) for i in range(1,256):# print(sum_num[i-1],caculate_num[i]) sum_num[i] = sum_num[i-1] + sum_num[i] return summ,caculate_num,sum_numdef GetHistogramArray(image): return np.histogram(image,np.arange(0,256));def cumsum(img, bins): histogram = np.zeros(bins) for pixel in np.arange(0, bins, 1): histogram[pixel] += len(img[img==pixel]) return histogramdef HistogramEqualizationLUT(input_image): # 参数1, 单通道8位灰度图像 # 输出1. 单通道8位灰度图像（直方图均衡化后） size,data,data_sum = CaculateHistogram(input_image) fxy = lambda x: (255*data_sum[x])//size table = np.array([fxy(i) for i in range(256)])# print(table)# 不可以这样# image_new = table[input_image] lut = lambda x: table[x] return lut(input_image),tablered_channel_he,red_lut_table = HistogramEqualizationLUT(im[:,:,0])all_he,lut_table = HistogramEqualizationLUT(im)plt.figure(figsize=(20,10))ax1 = plt.subplot(231)ax1.set_title("Original")ax1.imshow(im)ax2 = plt.subplot(232)ax2.set_title("Red Channel HE")ax2.imshow(red_channel_he, cmap = 'gray')new_im = np.copy(im)new_im[:,:,0] = red_channel_heax3 = plt.subplot(233)ax3.set_title("Image With Red Channel HE")ax3.imshow(new_im)ax4 = plt.subplot(234)ax4.set_title("Original")ax4.imshow(im)ax5 = plt.subplot(235)ax5.set_title("All Channel Together HE")ax5.imshow(all_he,cmap = "gray")ax6 = plt.subplot(236)ax6.set_title("All Channel Together HE")ax6.imshow(all_he)plt.show() 123456789101112131415161718192021222324252627282930313233343536373839404142# OK, Do something interesting!# 写一个整合函数，对每个输入图像的三通道都画出其三通道的函数变换图像和def DrawPerChannel(input_img,split_channel : int, channel_color ,plotline = None, histogram = None, pic = None):# 该通道的均衡曲线（分布函数曲线）# 获取分离的通道 input_channel = input_img[:,:,split_channel] temp_he,temp_table = HistogramEqualizationLUT(input_channel) if plotline != None: plotline.set_title("The function of "+channel_color+" channel") plotline.plot(np.arange(256),np.arange(256),color = "black",label = "$r_&#123;" + channel_color +"&#125;$") plotline.plot(np.arange(256),temp_table,color = channel_color ,label = "$T(r_&#123;"+ channel_color +"&#125;)$") plotline.legend()# 该通道的灰度分布直方图 if histogram != None: kwargs = dict(bins = 25, histtype='bar', edgecolor = "white",alpha=0.5, density = True) histogram.set_title("The histogram of "+channel_color+" channel") histogram.hist(input_channel.flatten(), color = "black",**kwargs, label = channel_color +" original") histogram.hist(temp_he.flatten(), color = channel_color , **kwargs, label = channel_color +" after he") histogram.legend()# 该通道均匀后叠加到原图像的效果 if pic != None: show_img = input_img.copy() show_img[:,:,split_channel] = temp_he pic.imshow(show_img)def DrawChannelsEqualization(img_with_3channels): plt.figure(figsize=(30,30))# 调用库函数# r,g,b = cv2.split(im)# 直接分离# r,g,b = img_with_3channels[:,:,0],img_with_3channels[:,:,1],img_with_3channels[:,:,2] DrawPerChannel(img_with_3channels,0,"red",plt.subplot(331),plt.subplot(334),plt.subplot(337)) DrawPerChannel(img_with_3channels,1,"green",plt.subplot(332),plt.subplot(335),plt.subplot(338)) DrawPerChannel(img_with_3channels,2,"blue",plt.subplot(333),plt.subplot(336),plt.subplot(339)) plt.show()DrawChannelsEqualization(im) 123456789101112131415161718192021222324252627282930313233# 测试三通道分别做均衡化后效果和采取统一函数做均衡化的效果def DrawCompareEqualization(im_with_3_channel): together_img,together_table = HistogramEqualizationLUT(im_with_3_channel) seperate_img = im_with_3_channel.copy() seperate_table = np.array([together_table,together_table,together_table]) for i in range(3): seperate_img[:,:,i],seperate_table[i] = HistogramEqualizationLUT(im_with_3_channel[:,:,i]) plt.figure(figsize=(15,10)) plotline0 = plt.subplot(231) plotline0.set_title("No Change") plotline0.plot(np.arange(256),np.arange(256),color = "black",label = "$r$") plotline1 = plt.subplot(232) plotline1.set_title("Seperate Change") plotline1.plot(np.arange(256),np.arange(256),color = "black",label = "$r$") plotline1.plot(np.arange(256),seperate_table[0],color = "red" ,label = "$T(r_&#123;red&#125;)$") plotline1.plot(np.arange(256),seperate_table[1],color = "green" ,label = "$T(r_&#123;green&#125;)$") plotline1.plot(np.arange(256),seperate_table[2],color = "blue" ,label = "$T(r_&#123;blue&#125;)$") plotline1.legend() plotline2 = plt.subplot(233) plotline2.set_title("Together Change") plotline2.plot(np.arange(256),np.arange(256),color = "black",label = "$r$") plotline2.plot(np.arange(256),together_table,color = "orange" ,label = "$T(r_&#123;together&#125;)$") plotline2.legend() pic0 = plt.subplot(234) pic0.imshow(im_with_3_channel) pic1 = plt.subplot(235) pic1.imshow(seperate_img) pic2 = plt.subplot(236) pic2.imshow(together_img) plt.show()DrawCompareEqualization(im) 1234567891011# 多来几组样例imtest1 = imageio.imread('imageio:chelsea.png')imtest2 = GetRGB('./3_2Photo/2.jpg')imtest3 = GetRGB('./3_2Photo/3.jpg')imtest4 = GetRGB('./3_2Photo/4.tif')DrawCompareEqualization(imtest1)# DrawCompareEqualization(imtest2)DrawCompareEqualization(imtest3)DrawCompareEqualization(imtest4) 1234567891011121314# 展示直方图def DrawHist(input_img,pic_handle,histogram_handle): kwargs = dict(bins = 25, histtype='bar', edgecolor = "white",alpha=0.5, density = True) pic_handle.set_title("The Image") pic_handle.imshow(input_img,cmap = "gray") histogram_handle.set_title("The histogram_handle") histogram_handle.hist(input_img.flatten(),**kwargs)plt.figure(figsize=(20,15))DrawHist(imtest1[:,:,0],plt.subplot(321),plt.subplot(322))DrawHist(imtest2[:,:,0],plt.subplot(323),plt.subplot(324))DrawHist(imtest3[:,:,0],plt.subplot(325),plt.subplot(326))plt.show()]]></content>
      <categories>
        <category>数字图像处理</category>
      </categories>
      <tags>
        <tag>数字图像处理</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[数论学习——黄金分割率]]></title>
    <url>%2Fpost%2F460fad29.html</url>
    <content type="text"><![CDATA[简介黄金分割是指将整体一分为二，较大部分与整体部分的比值等于较小部分与较大部分的比值，其比值约为 $0.618$。这个比例被公认为是最能引起美感的比例，因此被称为黄金分割。 传说在古希腊时期，有一天毕达哥拉斯走在街上，在经过铁匠铺前他听到铁匠打铁的声音非常好听，于是驻足倾听。他发现铁匠打铁节奏很有规律，这个声音的比例被毕达哥拉斯用数学的方式表达出来 数学公式直接解设$x$为黄金比，便有： \frac{1}{x} = \frac{x}{1-x}x^2 = 1-xx^2 + x - 1 = 0x_1 = \frac{-1-\sqrt{5}}{2}(舍),x_2 = \frac{-1+\sqrt{5}}{2}上述即为数值解，$0.618$只是一个近似，从数值表述易知该数为一个无理数，给出前 32 位是：$0.6180339887 4989484820458683436565$ 无穷连分数对刚才的数学公式做变形可以得到 x= \frac{1}{x+1}x = \frac{1}{ 1 + \frac{1}{x+1} }x = \frac{1}{ 1 + \frac{1}{ 1+ \frac{1}{x+1}}}数列逼近经计算发现相邻两个斐波那契数的比值是随序号的增加而逐渐逼近黄金分割比。由于斐波那契数都是整数，两个整数相除之商是有理数，而黄金分割是无理数，所以只是不断逼近黄金分割。 Python 验证:]]></content>
      <categories>
        <category>数学</category>
        <category>数论</category>
      </categories>
      <tags>
        <tag>数论</tag>
        <tag>数学</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[计算机图形学——OpenGL编程基础]]></title>
    <url>%2Fpost%2Fe5459685.html</url>
    <content type="text"><![CDATA[什么是 OpenGL一个图形学库，用来绘制，但是不负责 IO 输出，需要搭配 GLUT，GLUI，MFC，QT。 除了 OpenGL 外，业界常用还有 DirectX，微软专用的一个图形学库。 编程环境配置图形库 OpenGL 工业 GLUT GLUI 动态链接库/静态链接库的区别 查向量向量的代数表达 图形表示不方便 向量操作 标量乘法 点乘 叉乘 坐标系统 在二维平面上，给定两个基向量，可以表示整个空间（基向量，空间由这两个向量张成） 给定一个二维的多边形，判断它是否是凸多边形凸包算法，逆时针遍历点，计算新向量与原向量的叉积，方向一致的应为凸多边形，方向改变的是凹多边形。]]></content>
      <categories>
        <category>计算机图形学</category>
      </categories>
      <tags>
        <tag>计算机图形学</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[数论学习——Stirling数]]></title>
    <url>%2Fpost%2Fac8faa8e.html</url>
    <content type="text"><![CDATA[问题引出用矩阵来表示样本属于哪类划分类别的过程中，老师提出的一个问题：从$N$个样本中分出$C$类，不同的分法一共有多少种？ 抽象：$N$个数划分为$C$个集合，要求集合不能为空，方案数为？ 就是第二类斯特林数。 解答递推其实是个数学的问题，和组合数的公式有些类似，所以我们尝试求其递推式，从$N$个数划分为$C$个非空集合，如果前面各数都已经划分好到所属集合，剩下最后一个数未划分，考虑最后一个数，则有以下两种情况： 前面$N-1$个数划分的集合数为$C-1$，则最后一个数必须单独属于一个新集合。 前面$N-1$个数划分的集合数为$C$，则最后一个数可以属于先前$C$个集合中的任意一个。 用更数学的方式表达，$S(n,c)$表示我们所求，则有以下转移方程。 S(n,c) = S(n-1,c-1)+n*S(n-1,c)容斥原理（通项公式）考虑容斥的话思路尝尝是从一个大数减起，对于这个计算直觉应该是从这个大数：$c^n$（把$n$个球放进$c$个可空的不同集合的总方案数，另一个角度就是$n$位$c$进制数可表达的数的范围） 那我们应该如何计算得到我们想要的$S(n,c)$呢？（容斥思想） 考虑$c^n$中包含着可空的情况，又考虑到直接求恰有$x$个集合满的情况，我们采取曲线救国的方式（也是容斥原理中常用的），我们可以求出至少$x$个集合满的情况，实际上就是$(c-k)^{n}$。 那我们就可以容斥了，枚举空集的情况数然后求个 Sum 就行，给出公式： S(n,c) = \frac{1}{m!} \sum_{k=0}^{m} (-1)^kC(m,k)(m-k)^n再一言以蔽之：就是枚举空集合的数目，剩下的随意放置，容斥以下就可以得到最终的答案了。]]></content>
      <categories>
        <category>数学</category>
        <category>数论</category>
      </categories>
      <tags>
        <tag>数论</tag>
        <tag>数学</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[CCFADL105——智能计算系统课程]]></title>
    <url>%2Fpost%2F2fd84083.html</url>
    <content type="text"></content>
      <tags>
        <tag>编程</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[CCFADL105——面向下一代计算的开源芯片与敏捷开发方法]]></title>
    <url>%2Fpost%2Fe4eb9281.html</url>
    <content type="text"><![CDATA[面向下一代计算的开源芯片与敏捷开发方法主讲人：包云岗老师（中科院计算所， 先进计算机系统研究中心） Memory Wall提出背景：System Architecture1995 年提出，成为体系结构研究的最重要问题之一 多核处理器的流行 延迟与带宽显得更为重要 应对思路 工具模型：HMTT、C-MAT 预取技术：Memory Hierarchy 新型存储：3D Stack、HBM、NVM 新架构： Process-in-Memory、Domain-Specific Architecture HMTT 访存监控仪器包老师博士期间的工作，现在已经迭代了几个版本。 需求 安捷伦等逻辑分析仪：无法检测到云计算环境下多应用混合后的数据通路中的应用访存行为（不具备对应用进行带语义的监控） 提出软硬件协同监测新方法，研制HMTT 访存监控仪 工作流程 物理地址追踪（Physical Address Trace）：作为硬件，不影响其性能，直插在内存槽获取其物理地址 虚拟地址追踪（Virtual Address Trace）：转换成虚拟地址以了解进程相关的信息 访问对象（Object Access Pattern）：通过对虚拟地址的再分析，与变量关联起来 工作示意图如下 软件挑战虚拟地址到物理地址的重映射技术我们上课都学到过，可是如何从物理地址反过来获取虚拟地址呢？ 如何物理地址翻译为进程的虚拟地址（物理地址-&gt;软件语义信息） 解决：修改 Kernel 通过修改内核使得硬件可以获取到页表的 page table 在导出的页表中反查物理地址，获得进程产生的虚拟地址 问题： 扫描当前页表 缺页替换则对应不同进程信息 如何同步更新 HMTT 硬件信息 同步挑战当 OS 内核发生页表更新时，如何通知 HMTT 硬件 解决：高层事件编码机制：High-Level Event Encoding Mechanism（HLE2M） 保留一段物理内存地址空间 将高层事件映射到该空间 侦听对该地址空间的访存请求 将访存硬件转换为高层时间 理解：将高层事件多一个分支结果，访问这一小块内存空间（相对集中），就如同一段标记数组，用来记录访存情况（次数）。 图示: 以页表更新事件为例（举一反三，其他高层事件也可以比如 CPU/DMA 访问，加锁操作）： 模型分析系统结构的并发度没有被充分利用或优化利用 更多资料来源，刘宇航副研究员，中科院计算所 基于并发的存储层间性能匹配（LPM），漏斗状，如下图 数据预取何为数据预取？将未来所需要访问的数据提前取到更靠近处理器的 Cache 中，可以有效隐藏访存延迟 需求： 手机处理器对于敏捷反应，以及其他落地应用的需求 苹果是个黑洞（闭环自研） 华为与科研机构的合作使得需求更明晰 学术界的研究情况： 提出了多种预取策略，如顺序预取，Stride 预取，马尔科夫预取… 主要针对 Memory Hierarchy 的某个特定层次，如 L1 Cache 或者 L2 Cache 领域专用体系结构 DSADomain Specific Architecture（DSA，即针对应用领域做优化的处理器架构，区别于通用架构）。 从普通码农用 python，到算法工程师从数据结构算法上优化，如果懂得并行化算法的人，还可以在并行度上优化，在往上还可以做内存优化和指令级优化，整体性能提升是惊人的。 若将“人”的经验固化到芯片中去，是一件听起来很美妙的事情。 性能差异来源分析 并行度挖掘不够？ 数据移动开销太大？ DSA：是道，非术 DSA 是一种理念，尚未形成通用的技术方案 DSA 未来可能的形态 每个解决方案对应一颗 SoC 与适配软件 每颗 SoC 包括 一个通用的基础平台，如 RISC-V + AXI 若干个领域加速器，如 APU、BPU、NPU 芯片敏捷开发工具 Chisel + OpenEDA + … 低门槛开发平台与制造渠道 标签化体系结构研究历程，拆解核尝试（失败），MicroBlaze（非开源，受挫），开源指令集 RISC-V 基础上实现（成功） 背景介绍如之前 HMTT 的思想，希望实现新的接口，使得高层软件的信息可以传递到底层硬件中去，底层对上层有意识而采取更具针对性的解决，提高效率（而非像现在一样，底层对上层完全 unawareness）。 单任务稳定环境下性能波动与共享环境下的性能波动的两个实验： 需求场景航空航天等实时场景 机载计算机关闭多核以保证实时性 美国联邦航空管理局 FAA出台相关白皮书 用户体验敏感场景 手机芯片内部多部件竞争冲突，操作卡顿，影响用户体验 亟需体系结构的创新 控制与弱化控制回顾历史，重新审视冯·诺依曼结构： 体系结构中的控制 1953 年，图灵奖得主 Maurice Wikes 提出微程序来设计处理器的控制单元 控制被弱化 1980 年，RISC 成为主流，体系结构研究主要关注部件与数据通路的设计与优化，弱化了控制 但是弱化控制随着 CPU 核数，并行度要求的提高导致的问题越来越突出：性能不稳定。 共享环境下，多应用共享硬件，弱化控制会导致硬件出现无序竞争，进而引起严重的性能波动，Data Shuffling 犹如一条无序竞争的马路。 冯诺依曼瓶颈 尝试方法 存储层次+多核 多核结构存储层次分化：核内+核外 核内 L1/L2 复制多份，共享核外 L3/Mem/IO 存在问题 无序共享导致性能无法得到保障 性能不确定：三级缓存（L3）共享会造成高达 3 倍以上性能下降，引起云计算“吵闹的邻居”问题。 L3 无从判断应用的紧急程度 图示：单独可以，一同使用就出问题 硬件上存在大量无序竞争 CPU、内存、网络、磁盘都会因为无序共享，造成用户体验差。 图示 接口设计1973 年，Feustel 教授提出 Tagged Architecture 核心思想是将高层语言信息传递到底层硬件 替代冯诺伊曼结构 设计原理： 所有数据赋予一个类型标签 标签存于内存中 标签触发中断进行处理 问题： 设计太复杂，难以实现 SDN 到计算机2010-2012 在普林斯顿 PARSEC 研究内容：标签化网络、frenetic（一种网络编程语言）、P4 从 SDN 网络架构借鉴思路，计算机即网络（Computer as a Network），计算机本质上就是一个网络，内部的不同部件通过包进行通信——PCIe 包、QPI 包、NoC 包，…… SDN 核心原理 标签化冯·诺依曼体系结构 细粒度对象 每个网络包增加一个标签（Label） 每个内部请求（如访存请求）增加一个标签 关联语义 标签值与用户的网络需求关联 标签值与上层 VM/进程/线程/变量等关联（高层信息） 携带传播 网络包传播过程中携带标签 标签在计算机访问各个存储层次过程中全程携带 标签控制逻辑 网络设备基于标签控制网络包转发 基于标签的请求区分处理（底层高效） 从 SDN 到计算机，从标签化网络到标签化冯诺依曼体系结构 业界尝试：2016 年 Intel RDT 技术、PARD 最小污染原则 70 年代标签体系结构失败原因 LvNA 的三条“最小污染”规则： 所有数据赋予一个类型标签 标签应尽可能简单 标签存于内存中 标签存于请求中 标签触发中断进行处理 控制逻辑放置在数据通路上 增加标签寄存器，标签关联硬件虚拟机，传播标签，可编程控制逻辑 尝试与实现 尝试 1：基于 MCU（微控制单元）的控制逻辑，尝试 2：基于表的控制逻辑 尝试 2：基于表的控制逻辑 集中平台资源管理 连接所有控制逻辑形成控制平面 运行基于 Linux 的固件 将控制逻辑抽象为文件 实现 Full-system cycle-accurate simulator FPGA prototype on Xilinx VC709 evaluation board MicroBlaze version $\times$ RISC-V version $\checkmark$ 演示 硬件资源动态调整的共性问题本质问题：如何在混合环境下预测出应用单独运行时需要的资源？ 解决方法 1：离线分析建模，预测动态资源需求 解决方法 2：在线实时预测动态资源需求 Shadow X 机制：针对不同资源设计一套影子资源模型，模拟推断应用单独运行时所需资源 共享模型 Shadow X 机制 SMT 利用Shadow Table获得 PTA 资源（ICS2019） LLC 利用Shadow Tag来获得一条 hit rate 曲线 Mem Bandwidth 利用Shadow 感知机获得内存宽带 实现自动 LLC 管理和自动访存宽带管理 芯片验证：与 771 所合作，正在开展 8 核 Labeled RISC-V 流片 同行进展ARM 正在研究基于标签的MPAM技术：Memory Partitioning and Monitoring 学习教程作者提供的教程 Labled ISC-V: A Case for Software-Defined Architecture 开源代码 Open-Sourced Codes 开源芯片与敏捷开发主要讲了当前局势和芯片开发学习的未来。 中国高科技企业正面临美国技术“核打击” 优秀人才储备严重不足 如果认为 ISCA 论文第一作者是行业专业技术佼佼者 十年来 85%选择在美国就业，仅 4%在中国就业 芯片设计门槛高，大学无能力培养优秀人才 时间长 成本高 降低芯片门槛是人才危机一种破解之道 美国经验：MISIS 项目，为大学提供流片服务。 领域专用体系结构星期如何弥补软硬件性能鸿沟？ 硬件加速器 领域专用体系结构（DSA Domain Specific Architecture) 开源芯片，降低芯片设计门槛远景研讨会纪要：面向下一代计算的开源芯片与敏捷开发 RISC-V 国际开源实验室（RIOS）成立大卫·帕特森（David Patternson）在瑞士宣布依托清华-伯克利深圳学院建设 RIOS（RISC-V International Open Source Laboratory）实验室，全面提升 RISC-V 生态系统至最先进水平。]]></content>
      <categories>
        <category>讲座</category>
      </categories>
      <tags>
        <tag>讲座</tag>
        <tag>CCFADL</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[CCFADL105——大数据场景下的持久性内存存储系统构建探讨]]></title>
    <url>%2Fpost%2F7d8289ba.html</url>
    <content type="text"></content>
      <categories>
        <category>讲座</category>
      </categories>
      <tags>
        <tag>讲座</tag>
        <tag>CCFADL</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[CCFADL105——面向非易失性存储介质的文件系统设计、实现与形式化验证]]></title>
    <url>%2Fpost%2Ff82955ec.html</url>
    <content type="text"><![CDATA[面向非易失性存储介质的文件系统设计、实现与形式化验证主讲人：陈海波老师（上海交通大学教授， IPAD 小组导师，华为鸿蒙系统研发） Background：How to Climb Up the Memory HierarchyJim Gray 对于存储层次（Memory Hierarchy）演进的经典论断：Tape is Dead, Disk is Tape, Flash is Disk, RAM Locality is King. JG 论断提出的背景是 06 年 SSD 刚刚出来，那么随着硬件技术的发展，JG 的论断也该有新的诠释。 Non-volatile Memory(NVM) Revolution产品化元年非易失性存储硬件的出现，Non-volatile Memory（NVM），带来的数据可持久化是颠覆性的改变。从体系结构的角度，CPU 内部整合内存虽然还没有实际上发生，但是今年发生的一件事是，放了许多年鸽子的 NVM Memory 终于产品化了，今年三月份 Intel 开始对外出售，中文名傲腾系列。3D XPoint 维基百科 先前为了实现 Persistence（持久化），NVDIM 技术是附加电容，在断电时通过电容，将 RAM 的数据刷到硬盘中，从而达到持久化的效果。 抉择：Performance vs. Persistence，以传统结构来说，选择 Performance，我们减少写回磁盘的次数，而主要在 RAM 上操作，但是这就面临掉电丢失数据的风险，难以持久化，而若选择 Persistence，频繁写入磁盘，则在 IO 上就要耗费更多的时间，效率降低。 Intel Optane DC Persistent Memory 性能表现 在 NVM 产品化元年，真正的 Persistent Memory 到来时，如果针对其特性构建系统？ 改变 Memory Hierarchy改变了其中的易失/持久的边界 不成比例扩展效应 Incommensurate scaling如果计算机体系结构某个部分突然快 10 倍，便会使人们重新审视整个系统，调度、Storage 管理 As a system increases in size or speed, not all parts of it (&amp;human factors) follow the same scaling rules. — Saltzer &amp; Kaashoek 考虑 NVM 带来的影响，如下图，非易失性设备访问速度提升了 1000-10000 倍，不仅系统本身，评测系统的 Benchmark，思考问题的角度，都需要重新调整。 启发Tape is Dead, Disk is Tape, Flash is Disk, \sout{RAM Locality is King.}\par RAM is Flash, Cache Locality/Parallelism is King? 从硬件革新，重新审视系统的软件栈。 SoupFSAn NVM file system in Kernel(USENIX ATC’17) 为什么在乎文件系统 文件系统储存我们所有的数据 文件系统的表现是系统整体表现得关键 文件系统是解决 Performance 和 Persistence 矛盾得关键 现有得 NVMFS 使用日志（journaling）或者边复制边写（copy-on-write）的方式来实现崩溃时保持一致性（crash consistency），但由于 CPU cache 仍然是易失的，由此引发出明显的性能问题： 同步 cache 和 NVM 导致 cache flushes 是必要的 cache flushes 代价很大 思考：不适用这两种方式，其他方式实现 crash consistency？ 有的，前人也做过研究：1999 年 Marshall 和 Gregory R. Ganger 在 USENIX 上发表论文介绍的方法：Soft Updates Soft UpdatesWhat Is Soft Updates主要思想：在磁盘中维护一个元数据，不和 DRAM 实时同步，但保证与 DRAM 的元数据的依赖关系相同（两地元数据都需要增加依赖关系的标识，这是新的要求）。 带来的好处：异步操作、依赖关系保证一致性、无需磁盘检查。 Soft Updates is Complicated这一理念在学术界有所影响，但工业界影响微乎其微：依赖关系复杂，实现太过困难。 Soft updates are, simply put, too hard to understand, implement,and maintain to be part of the mainstream of file system development — Valerie Aurora, Linux Kernel Developer 海波老师的团队研究认为，这种复杂性的根本是：细粒度的 Cache 记录跟踪（Byte 级别）和粗粒度的磁盘读写（512K 或以上）接口之间的不匹配 Soft Updates Meets NVMSoft Updates 没有同步 cache flushes 的消耗 崩溃可即时恢复可用 NVM Byte 级别且快速，原有粒度不匹配问题改善 直写 NVM 没有延迟 没有伪共享（false sharing） =&gt; no rolling back/forward 简化了跟踪依赖的操作 新的挑战：由于 NVM 是 M，Memory，那就存在着用户未预料的 CPU 将 Cache 数据刷回 NVM 的过程（cache eviction），这就带来了不一致性。 SoupFSA simple and fast NVMFS derived from soft updates. 哈希表目录（解决 false sharing） 依赖指针的双视图（解决同步 cache flushes 开销） 语义感知以来跟踪 着重讲双视图一块的设计 Dual Views哪两个视图 Latest view in page cache（在 DRAM 中） Consistent view in disks 为了避免两个视图两份拷贝的额外开销，进一步提高效率，通过 Pointer 指向，来复用元数据的数据结构来避免不必要的重复和刷新。 具体的数据结构设计不再赘述，可以参考 SoupFS 论文 一个例子，从图示看很像 Data structure 中每个结点实现了一个双指针分别指向下一个 Consistent 节点（NVM View 中）和 Latest 节点（RAM View 中）。 Q&amp;AQ1. 使用 NVM 为什么还要使用 File System，数据库方式可以跳过直接操作底层的 metadata？A1. 当然对于 NVM 下还要不要做 File System 业界是有争论的，我的看法是系统发展要有演化路径，File System 是一个通用的“范型”，可以利用 File System 实现更多基于 File System 的上层技术。 Q2. NVMFS 有没有对垃圾回收机制带来新的要求和挑战？A2. 之前学术界有相关研究比如 NV Allocate，主要研究在 NVM 上如何分配和管理空间，这样必然会涉及垃圾回收这一问题。我们这边也有涉及 Garbage Collector 的相关工作，主要关心掉电后数据流有/没有被分配 Q3. 为什么考虑文件目录使用 HashTable 而非红黑树、B+树，这样的话范围查询效率不会很低吗？A3. 首先考虑到实现简单，而且对于 NVM 来说，相较于之前的 Disk 访问速度已经很快了，范围查询拆成单点查询可能都要比原有设备的范围查询快，就是拖到内存里扫一遍的过程。 ZoFSA truly user-space NVM file system (SOSP’19) User-space File Systems设计在用户空间（user space）活动的文件系统，一些优势 更易开发，移植和维护 由于在用户空间，bug 不会影响整个系统 可以利用更多的库和编程语言 灵活 可根据应用程序定制 由于内核旁路（kernel bypass），大多数都是高性能的 用户空间的库可以直接通过 NVM 早期的一些工作：Aerie， Strata，NOVA（有机会查阅文献自己了解一下） 采取内核/用户空间分离强化了权限（许可？）和保护，任何文件的更改都需要经由内核同意，但是由于存储介质的改变，NVM user-space 的文件系统与 kernel 远超过去的交互频率会使得 kernel 处理权限（许可？）成为瓶颈。 挑战：文件保护于隔离 思考：将相同权限（许可？）的文件分组并一同管理 再提及：抽象的重要性 新的抽象： Coffer具体没有搞明白。。后续读论文吧。 Protection and IsolationApp code 运行可能会导致某个 Coffer 出错，如何防止错误的蔓延，实现错误隔离？方式，内核将 VM pages 划分为 16 regions，非特权寄存器控制器每次最多接入一个 region，添加一些规则（guidelines）。 G1. 一个 coffer 是可访问的当且仅当 uFS 正在访问这个 coffer。 G2. 在任何时候，对于每个县城来说，用户空间中只有一个 coffer 是可访问的。 G3. 对于任何一个 cross-coffer 的 reference，uFSs 应在使 coffer 变为可用状态前检查其标记。 ZoFS 实现和一些实验验证。。。这里也不太懂。 AtomFSThe first verified concurrent file system (SOSP’19) 第一个验证的并行文件系统。 对于并行文件系统验证的需求 并发错误很难消除 应用程序需要并发执行的精确接口 应用程序代码推理（code reasoning）的基础 而最关键的是：形式化验证——证明系统没有错误的唯一方法。 到这真的是听不懂了。。。。记一些重点名词然后贴 pdf 日后慢慢研究吧 抽象化-&gt;形式化验证 Atomicity, Linearizability Helper Mechanism（辅助机制）: Ghost state, Linearize-before relation, CRL-H 耗费了相当大的精力，1.5 年的努力，包括学习理论，建立框架和形式化证明。 AtomFS：2k 行代码表达，60k 行证明。 Summary还是如之前所说，体系结构中某个部件的突发进步，会导致整个体系设计思路的改变。 NVM 为系统软件带来了极大的便利 我们需要重新思考系统软件的设计 找到对于现有软件来说真正的痛点（real pain points） 长远来看会改变整个软件栈，甚至存储层次也会被颠覆 Institute of Parallel and Distributed Systems(IPADS) IPADS 中文主页]]></content>
      <categories>
        <category>讲座</category>
      </categories>
      <tags>
        <tag>讲座</tag>
        <tag>CCFADL</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[CCFADL105——“智能在网计算”应用智能网卡技术加速数据中心]]></title>
    <url>%2Fpost%2Ff74c511d.html</url>
    <content type="text"><![CDATA[“智能在网计算”应用智能网卡技术加速数据中心主讲人：谭焜（Phd，华为） 总览network stackIP 层往上，栈（协议栈）更贴近软件，IP 层往下，更贴近硬件。从软硬件均实现了 Network 的服务需求。 Bottleneck 的改变 过去 现在 IP 层作为网络协议栈处在中心的位置，网络通讯速度相较于 CPU 和内存的速度来说要慢很多 网络速度以 200 倍到 2000 倍速度增长，而 CPU 计算增速却放缓，摩尔定律放缓 eg: at 1990, Intel 80486 32bit@33MHz vs. ETH 10Mbps eg: CPU 10~100GHz vs. ETN 400 Gbps 内存增长也遇到瓶颈 完全吃下 40G ETH， 8 TCP conns 网络数据至少需要 5 核。 问题Question: How to scale networking with ever growing speed? 如何应对加剧增速的网络？ Answer: making network smart! 让网络变得“聪明”： SmartNIC: intergrating general programmability into network interface card. SmartNIC 分类对于 SmartNIC 的分类，可以从架构和核类型两种角度进行分类： 按架构（Architecture）分类 on-path（SmartNIC 核在路径上，网络传输必须必然经过） off-path（SmartNIC 核在旁路上，网络传输可通过 Swith 不经由） 按核类型（core types）分类 FPGA-based 基于 FPGA NP-based 基于多核 NP GP-based 基于通用处理器核 业界多种选择 Microsoft FPGA-based SmartNIC Cavium/Marvel NP-based SmartNIC Huawei NP-based uNIC Mellanox ARM-based SmartNIC SmartNIC 编程硬件编程困难，需要考虑时序度、DMA 等等。 Make it easy. ClickNP 如同在多核处理器上编程 Element 单元作为单线程的 core 整个体系结构，通过 ClickNP compiler 把运行库和所写程序编译，生成对应 Host 宿主机 CPU 执行的 C 代码，和在 FPGA 上执行的代码。 iPipe Actor 模型，Actor 调度 最大化 SmartNIC 的利用 调度策略：混合调度（Hybrid Scheduler） SmartNIC，必要时调度到 CPU 动态 eg: 根据报文大小采取的动态 SmartNIC 的策略。 eVS offloading with Huawei uNIC云计算中的 Private Cloud，云计算 Deloy 很多的服务器，其生意模式是将机器租用给租户，如下图（蓝、绿、红），每个用户建立一个虚拟化的网络，客户角度看就是一个私有网络（像是真正的物理网络一样）。 通过虚拟交换机，发送时 vSwitch 在原来的报文上再打一个标签，再发送到实际的物理网络上，接收的时候对应不同的报文标签再分给不同的 VM。 对于一个完整交换的过程（流表），完全让智能网卡照搬解决，1.不显示，2.和让宿主机 CPU 处理器没差别。 解决：缓存固定的流数据的结果，first pkt 与 rest of pkts 区分开，通过缓存加速 rest of pkts。 实现：在智能网卡中做个 Cache，相同报文头的固定结果缓存到 Cache，后续网络包查表加速。 Multi-path RDMA Design kernal bypass and transport offloading（内核旁路以及无负载传输） 不为 CPU 增加负担，降低延迟并且提高吞吐量 existing RDMA has only a single path transport（现有 RMDA 单路径传输） fail to exploit multiple paths capability of modern DCN for reliability and load-balance（未能利用现代 DCN 的多路径能力来实现可靠性和负载平衡，协议缺失） 目标：为 RDMA 构建一个 multi-path 多路径传输 设计挑战Challenge 1. 如何在不知道每个路径状态的情况下实现拥塞感知流量分割 Solution 1. multipath ack-clocking Challenge 2. 如何跟踪具有微小和恒定内存的无序数据包 Solution 2. out-of-order aware path selection Challenge 3. 如何在保序的同时通过多路实现性能增益 Solution 3. explicit sychronise operation multipath ack-clocking设计内涵： 返回 ACK 隐含拥塞信息 算法： $N$条路径上发送$N$个包 为所有路径保留一个拥塞窗口（cwnd） 对于每个返回的 ACK，只有当 cwnd 允许的时候，将数据包输送到路径上 out-of-order aware path selection设计内涵： 选择具有相似 延迟的路径 算法： $snd_ooh$，人工设定一个参数$\Delta$，$snd_ool = snd_ooh - \Delta$，包落在这个时间区间内的，都是 Good Paths sychronise operation这个没太懂，加标签？ MPTCP vs. MPRDMA为什么选择构建新的 MPRDMA： 对于 MPTCP 来说，对于每一个 Single Path 都要去维护一组状态，实践中导致整体状态值很大，难以实现在硬件中，所以考虑从新设置一种适合的模式，减少 State 数，使其不随 Path 的增加而增加，便于硬件实现。 KV-Direct 后续都是基于 KV-Direct 论文，讲真，谭教授讲的有些快，后续有时间再补。 KV-Direct Paper]]></content>
      <categories>
        <category>讲座</category>
      </categories>
      <tags>
        <tag>讲座</tag>
        <tag>CCFADL</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[CCFADL105——大数据系统的演化：理论、实践和愿望]]></title>
    <url>%2Fpost%2F3f0572b0.html</url>
    <content type="text"><![CDATA[大数据系统的演化：理论、实践和展望主讲人：周礼栋老师（微软亚洲研究院副院长，MSRA 被称为系统方向的黄埔军校，肇国老师评价其为非常 Perspective 的一位老师） 前言作为第一个 Talker，先做一个比较宏观的演讲，整个分为两部分。除了必要的知识点以外，我们更需要以系统的视角，关注方法学（重新思考）。 回顾大数据系统的发展历程：Big Data Systems强调了抽象的重要性，一个好的抽象，可以将要进行的任务很好的表达出来，同时还要具备高效性，可以被高效的实现。 2010 年以前的工作：Foudation 对于 MapReduce 的横空出现，学界对于 MapReduce 存在一些争论，一些数据库的巨擘认为 MapReduce 是对数据库已经建立起来的一些规则也好，基石工作也好的破坏，技术上是一种倒退，而微软则在 Google MapReduce 的基础上尝试填补上述争论，微软认为数据库和 MapReduce 是存在结合点的，可以向上提供原有的 SQL relation algebra 谷歌： MapReduce -&gt; 并行/分布式/优化 -&gt; 高效执行 微软：数据流 -&gt; 原有数据库接口 -&gt; MapReduce -&gt; 并行/分布式/优化 -&gt; 高效执行 2011-2012 的工作：Holisitic Code Optimization 数据库里面的优化和编译器的优化可以结合起来，思路：最优执行，优化执行。（当然整体还是建立在数据库的思维上） PeriSCOPE 项目，出发点希望将 SQL-like code 进行编译优化。 代码段是在多机器并发执行 纯编译优化只是很小的局部 SQL 生命力旺盛的一个原因是其隐藏了很多优化的细节。将 SQLize 的特性深入到全局概念，全局优化。 全局优化关键是优化目标、关注点的改变：数据传输（Data Shuffling）消耗： Column Reduction：延迟产生列 Early Filtering 提前合并减少列 Smart Cut Research to Production从研究所的科研突破到是计划产品部署过程中还会存在着一些问题，不管是科研人员和业务部门人员思维上差异也好，工作环境也好，所以在转化过程中我们还需要做到以下几点： 新颖与保守兼顾（考虑到业务部门的保守性） 需要适应真正的工作（而非 Benchmark 或者模拟数据） 无错、无不良影响、无不可预测行为（相较于成熟的旧技术，新技术如果以出错为代价，性能提升再多都是徒劳） 必须是收敛且低开销的（泛用性强，经得起工作集的改变） 后期维护的代价要小、复杂性低（方便迭代） 2013-2014 的工作：Scheduling and Resource 从单一 Job 的优化到多 Jobs 的优化，引入调度优化的角度。 大规模集群的多任务调度优化已经不仅仅是一个算法上的问题，因为集群中机器状态未知是常态，而且各自完成任务的预期也是 Unpredictable 的。 2015-2016 的工作：Beyond Batch Processing 重新审视思考方式：图计算、机器学习、流等概念的推广。从先前的 Scope 发展衍生出 StreamScope：分布式大数据可靠流系统。 微软内部商用大规模流系统 从批处理大数据系统演化而来 源于实际应用增强实时性的需求 和批处理系统共存 系统设计理念和思路 抽象！抽象！！抽象！！！ 先保证正确，再优化 通过高层语言提高可用性 在流处理的过程中，由于是阶段-&gt;阶段的，考虑出错的常态化，如果某个节点出错，且采取 Rebuild State（重建状态）的策略，最坏情况可能需要 Ref 的节点也处于出错状态，这样数据就在 Data Shuffling 的过程中丢失了。为了消除数据前后的空间依赖性，有必要构建新的抽象。 抽象 1 可靠流管道抽象可靠流管道（rStream） 每个序列号码都有一个唯一值 对于相同序列号，必须成功写后才可以读 一个写操作$(seq,e)$完成后，后续对该位置读都会返回$(seq,e)$ 抽象 2 可恢复节点抽象可恢复节点（rVertex） 以快照形式作为状态记录，包含三个属性值： 输入流序列号 输出流序列号 当前计算状态 出错恢复：根据快照记录回到过去状态，对于输入流进行重询问，由于 rStream 抽象，先前成功得读再后续读会返回相同的值，从而使用此性质可以完成成功得重询问，实现出错恢复。 抽象，抽象，抽象抽象的要求：自身要简单、易于理解。 合理的抽象使复杂的数据流可靠性和容错问题变得简单 一目了然的正确性 但是简单的实现是抵消的：需要同步写到高可靠存储系统 保持抽象，但使用一个混合高效的实现 把费时的写操作移出关键路径（critical path） 但仍保持可靠管道的性质 统一的抽象，不同的恢复策略选择 Recomputaion using dependency tracking at runtime Checkpoint/log replay Persistent state/streams Hybrid 合理的抽象简化系统开发、维护、调试和部署，分布式流处理从此变得简单。在微软的实践中，在这两个抽象的帮助下，整体业务可以达到： 离线调试验证模式，无缝上线 支持在线对每个节点的单独调试 支持灵活的在线迁移和动态调整 对过去的执行片段的审计 系统维护过程中的无间断执行 审视人工智能系统的机会和挑战：From Big Data Systems to AI Systems系统的两大重器：编译，架构 AI 蓬勃发展带来了新的方法论，比如，深度学习+： Deep Learning Compiler Optimization 深度学习编译优化 Deep Learning Training Job Scheduing 深度学习训练任务调度 帮助上层应用更好的利用底层硬件技术革新的项目——卧龙计划（Project Wolong）。 Project Wolong: Distributed Optimizer基于 RDMA（Remote Direct Memory Access）的快速分布式训练 基于设备和服务器的自动化计算部署。 利用 RDMA 实现 Zero-copy 设备沟通以提高效率，应用在：RPC、GPU 加速 Project Wolong：Local Optimizer对比 CPU 和 GPU 的架构 CPU GPU 少量的复杂核心 大量的简单核心 单线程表现 成百上千的硬件线程 晶体管空间致力于复杂的指令级并行（ILP） 最大化浮点吞吐量 优化方向：Operator Batching and Kernel Fusion 运算符的抽象粒度较低，导致一个真实的训练模型的数据流图往往会包括数千个节点，这些节点在 GPU 上的执行就会变成数千次 GPU 上的内核执行。这些粒度较小的内核函数在提供了灵活性的同时，其频繁的调用也成为当前影响许多深度学习框架性能的一个重要因素，其带来的性能开销主要体现在：数据流图的调度开销，GPU 内核函数的启动开销，以及内核函数之间的数据传输开销。 解决这一问题的一个直接方法就是合并相同运算符操作和内核融合，以更好的利用 GPU 的并行特性。 关于内核融合的详细介绍：内核融合：GPU 深度学习的“加速神器”,薛继龙 但是 操作符 Batch 的自动化，以及核的融合并非想象中简单，存在一些技术上的难题： 最后整体的工作流： 图优化：硬件无关优化策略 检测融合子图：找到一些可被融合的图节点 代码生成：给定一个融合子图，生成相关内核函数代码 图修改：将融合后的内核所对应的 Operator 替换之前的子图，并插入原来的数据流图中 循环多次直至满足需求 实现产品NNFusion：一个多功能深度学习编译器。 Deep Learning Training vs. Big Data Processing不考虑现在处理的问题和原来的问题有哪些不同，而照搬过去的方法是系统改良过程中一种不负责任的行为。 对比目标，过程，表现三方面的不同，我们获得的启示： 更多的并行工作会更好（The More Parallel Jobs the Better） 使长期工作适应不断变化的环境（Adapt the long-running job to the changing environment） 使深度学习进行时的微批处理（mini-batches）更加高效 结语 系统创新和优化时大数据和人工智能的以打击时 以独特的视角去发现和定义新的研究问题 综合全面系统地解决方法 大系统研究和创新的黄金时代]]></content>
      <categories>
        <category>讲座</category>
      </categories>
      <tags>
        <tag>讲座</tag>
        <tag>CCFADL</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[CCFADL105——大数据系统实践：从MapReduce到融合计算]]></title>
    <url>%2Fpost%2Fb1db88f.html</url>
    <content type="text"><![CDATA[大数据系统实践：从 MapReduce 到融合计算主讲人：郭振宇（蚂蚁金服分布式计算总监） 融合计算模型观察/趋势举一个蚂蚁金融一个常见的应用场景：扫码支付 审视机器学习（或者大数据分析）产品三个层面的发展： 计算范畴：统计-&gt;规则（专家会议沉淀）-&gt;图-&gt;AI-&gt;复杂决策 计算复杂度：静态线性工作流-&gt;静态图工作流-&gt;动态工作流-&gt;多流-&gt;多流融合 质量：时效、安全/隐私、数据可靠性。 实际上真正的 Machine Learning Code 只是很小的一部分，图源：《Hidden Technology Google》 而应用要落地，关键的问题在： 学习/开发/调试的成本 对接很多独立的引擎/框架 Ad-hoc/碎片化的集成/联调（多机联调） 运行时质量 破碎的上下游衔接 形象点说，就是：上面跑数据不确定，下面就可能接受到不对的结果， 具体在：接口/时效性/一致性/故障恢复/中间状态管理 对于中间状态管理的解释：生产者（上游）通过 HDFS 存放中间状态（产品），消费者（下游）不知道什么时候可以删除而不产生危害，导致存储过载、溢出。 盲目调度，存在很多优化的空间 资源/数据/计算/服务 冗余/低效的数据传输/拷贝/计算等 安全隐私 … 运维效率 多引擎/平台异构运维 胶水平台化，将不同工作胶合在一起，常通过 GUIWorkFlow 的形式展示出来，一些公司已经有一些相关的工作。 e.g. Azure ML Workflow， Google Kubeflow 优点 包容性好 易用 局限性 组件质量/接口参差不齐-&gt;接口难做 组件对于胶水来说是黑盒-&gt;跨接口优化难做 想法：胶水-&gt;统一的分布式支撑 目标 融合计算：本地编程、自动云化、渐进融合 核心挑战 1：统一的通用编程抽象/执行模型是什么 前面的讲座中已经多次提到了抽象的重要性，抽象就意味着： 抽取面对不同分布式计算模式下的共同需求 甚至混合模式下的需求。 核心挑战 2：如何解决通用和特定之间的固有矛盾 通用性和领域专用性常看做是不可调和的矛盾。 一般情况下，越通用，解决特定场景能力越弱。 抽象是一种通用性的体现，而不同计算模式的不同需求/特定优化则体现了领域专用性 融合计算编程抽象为何需要分布式计算？以 MapReduce 中使用的字符计数问题为例： 对于单机：存储空间不够、计算能力不构、 分布式计算目标：提供远超的单机的存储、计算能力，包装成单机的假象使上层没有意识到改变 状态切分MapReduce 的启发，状态切分成 slice，两个子方案，一是不需要代码改动的方案：remote memory，file system。二是需要代码改动的：KV，database 避免数据共享冲突的方法？调整架构 控制流架构（冯·诺依曼） 数据流架构 执行由控制流驱动 执行由数据流驱动 控制流导致状态访问冲突 数据是无消息/无冲突问题 改写代码是必要的。 回到 MapReduceMapReduce 做的事情是将整个字符统计拆分成两个任务，Map 任务，Reduce 任务。 实际上各种计算范畴（computation paradigm）表达能力都可以通过数据流二部图（Task Object）表达出来，复现 PPT 展示的表格： 范畴（Computation paradigm） Task Object CPU Computation instruction instance register/memory operand MapReduce mapper, reducer instance input &amp; output (memory/HDFS) shards/buckets Graph Traversal graph shard worker traverse instance graph shard state snapshot, input/output messages Streaming streaming operator execution instance messages transmitted in channels among operators Tensor Computation tenser computation operator instance tensors Parameter sever based model training worker running for one iteration data,model parameters Actor based computation(object oriented computation) actor method execution instance actor method input/output, actor state snapshot 但是，Master 是个 exception，Master 是有状态的，相对于 Master 和 Reduce，对于有状态的 Master，MapReduce 论文中巧妙的忽略了这一点，对于单点故障，只需重启整个任务即可，数据流框架中不可采取这种“莽撞”的方法。 无状态任务 vs 有状态任务 无状态 大多数数据流计算（MapReduce，Dryad，Spark） 大多数 SOA 里面的 Method Call 随便哪里都能跑 有状态 某些有迭代的数据流计算（Tensorflow，Grap Computation2） 存储操作 带状态的服务操作（大多数 Job Master） 执行逻辑必须和状态绑在一起 编程抽象之 服务服务 vs Actor 服务 = [同构 Actor]*（一组同构 Actor 的集合），Actor 是单进程的。蚂蚁金服团队认为多线程一些地方还存在相似性和优化空间，更适合作为抽象单元，所以最终选择以服务作为自己的抽象单元。 尽量隐藏分布式计算带来的复杂度 Scale out Elasticity 弹性，日夜差别 Load balance Fail over 小结 静态数据流 vs 动态数据流业务的需求，动态越来越多，NLP/Reinforcement learning，Nested Graph。没办法一下子把图给全。 数据流图是一边跑一边长出来的。 核心编程抽象本地化编程-&gt;分布式编程 三元一一对应 eg 本地编程（On-Premise Programming）微内核架构 不仅仅是性能问题 多方面统一和特定之间的两难问题 最重要，执行统一的架构和合约，避免无序 团队合作 简化产品化/研发效能的问题（e.g.通过 AOP） 插件分类和实现eg：执行流调度、状态管理、服务部署策略、资源分配策略、进程故障恢复、状态故障恢复 优点： 模块可重用，不同场景需求选用不同组合 根据场景制作特定优化插件 功能级别相同插件可替换、方便排查问题 （基本）独立开发，无缝集成，方便团队合作 缺点： 模块繁杂，系统配置复杂（状态管理插件存放的位置，HBase，Redis，放哪里都有区别） 插件抽象要求高，还完全 stable 某些插件相互依赖、不独立（理论上是笛卡尔乘积组合情况，但耦合性降低现在仍然是努力的目标） 融合优化Level of indirection solves everything可以解决谁产生谁消费的问题，但是交互比较麻烦。 Problem： The indirection layer does enable flexibility but also brings cost 从静态数据流（static data flow）思考，并不会出现这种问题，图确定，必然有。 Back to the future，借鉴过去经验，想着能不能把动态往静态拉一把，我们还需要获取一些信息。 基于为微核架构的 Runtime optimization hybrid run-time Our WorkDistributed Gabbage Collection现在解决方案存在的问题：LRU（页面置换算法：最近最久未使用），删 object，但是可能还会用，删了可能会触发后面请求的 Failue，导致: 负担增大 无法找回 蚂蚁金服的解决方案： 融合计算的思考路径]]></content>
      <categories>
        <category>讲座</category>
      </categories>
      <tags>
        <tag>讲座</tag>
        <tag>CCFADL</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[分布式系统学习——阶段性总结2]]></title>
    <url>%2Fpost%2F72aa152d.html</url>
    <content type="text"><![CDATA[感受这篇阶段性总结写于乘高铁从长沙前往北京参加讲习会议的路途中，主要目的是回顾一下已经阅读完成的四篇分布式系统（Distributed System）相关论文的重点概念，相关实践（虽然很小），以及自我感受和后面的想法。 Paper3——The Google File System关键词：集群存储、分布式存储、高可用性、一致性原则 回忆梳理重点词：单 master、chunk 和 chunkserver、追加 append、 坦白讲这篇文章是四篇中读的时间最长的一篇文章，概念性比较强导致我不能通过代码或者公式的方式去直观的理解。 这篇总结主要写我印象深刻的点，更多的细节还要回去翻自己的翻译修改版本。 Design Motivation应用需求/系统发展带来的一些对应的设计模式观念上的转变。 对于计算机集群，故障是常态 存储超大量 追加（append）而非覆盖（overwrite） 尽可能并行化操作 带宽重要性大于时延，要考虑网络带宽和负载 ArchitectureGFS chunkserver在 GFS chunkserver 中，文件都是分成固定大小的 chunk（64MB）来存储的，每个 chunk 通过全局唯一的 64 位的 chunk handle 来标识。handle 由 master 分配。多台备份（GFS 中默认是 3 台）。 GFS masterGFS master 管理所有的元数据信息（metadata），包括 namespaces，访问控制信息，文件到 chunk 的映射信息，以及 chunk 的地址信息（即 chunk 存放在哪台 GFS chunkserver 上）。 GFS clientGFS client 是 GFS 应用端使用的 API 接口，client 和 GFS master 交互来获取元数据信息，但是所有和数据相关的信息都是直接和 GFS chunkserver 来交互的。 ApplicationApplication 为使用 gfs 的应用，应用通过 GFS client 与 GFS 系统打交道，系统有一些必要的性质（以适应在 GFS 上的高效利用）。 StrategiesSingle Master单 Master 很容易导致 Master 成为性能瓶颈和单点故障。对于前者，GFS 的解决策略是 client 对 master 返回的请求 chunk 位置具备短暂记忆性（60s），下放部分职能给 chunkserver（包括指派 private 来保证数据的一致性）。 对于后者，才有心跳线备份 Master 是可行的。 Consistency ModelGFS 论文介绍中写明了：采用了一种简化的一致性模型，可以高效服务于所需应用。 模型中的一致的（consistent）和定义的（defined）概念如下： consistent：所有的客户端都能看到一样的数据，不管它们从哪个副本读取。 defined：当一个文件区域发生操作后，client 可以看到刚刚操作和所有数据，那么说这次操作是 defined。 可以确定 defined 要求更强，在实际应用中会有不同情况出现，在原论文中用表格的形式直观化了。 我的感受：GFS 的保证是成功操作一次，由于所适应的应用以追加（append）为主。这样的策略和一致性模型保证操作会出现但是非幂等的冗余操作会导致结果错误，GFS 通过要求在应用层面上加过滤（filter）或者唯一话来解决这一问题。一言以蔽之：“宁滥勿缺”。 Master Operation-Namespace Management and Locking 快照对本层和对应的快照层都加写锁。 写操作对所写文件加写锁而对文件所在目录加读锁。 这样的分配策略既保证了一定程度上的并发许可（比如同一目录下的多个文件写），也保证了快照操作和写文件操作在相同目录下的串行化从而避免冲突。 Master Operation-Replica Placement对于 Creation , Rebalancing 策略都是相近的。 利用率低于平均水平的磁盘优先，平均化磁盘利用。 低频读写的 chunkserver 优先，平均化网络带宽利用，避免单点拥塞。 跨机架，防止整架挂掉。 对于 Re-replication，则要考虑对于备份更紧迫的情况： 丢失两个副本的 chunk 比丢失一个副本的 chunk 的复制认为优先级高 文件正在使用比文件已被删除的 chunk 的优先级高 阻塞了 client 进程的 chunk 的优先级高 但是实现中如何让 master 高效查询 client 阻塞进程，以及副本数量（涉及到计数），我觉得也是个算法上可以研究的地方。 读后感受GFS 的介绍应该是四篇文章中目前读的最慢的一篇了，太多概念都是通过文字方式讲述的，需要一点点在大脑里构建 GFS 中 Master，chunk，chunkserver 的关系。而且并列的概念关系我也没抓住重点（可能这也是我读论文的不足之处），所以这篇总结主要写了一些几个构成和我理解整理以后他们的工作策略，还请老师能指点我以后该怎样读这种文字多，新概念多的论文。 Paper4——MapReduce: Simplified Data Processing on Large Clusters关键词：Map 函数、Reduce 函数 啥是 MapReduce？——一种编程模型，适于处理大规模数据集 为啥叫 MapReduce？——核心就是两个函数，分别叫 Map、Reduce 如果前述 GFS 系统实现了文件，那 MapReduce 则是利用了这个文件系统和其他底层实现，规划出一种编程范型，提供了对外便捷的接口，可以让程序员忽略分布式算法/并行/容错/数据分发的细节，而达到分布式计算的目的。 下面回顾一下核心 Model： ModelMap，是由用户编写的，取一个输入对，并且产生一系列中间的键值对。MapReduce 库将那些具有相同的中间键 I 的中间值聚集在一起，然后将它们传递给 Reduce 函数。 Reduce，同样是由用户编写的，接收一个中间键 I 和该键对应的一系列的中间值。Reduce 函数通过将这些值合并来组成一个可能更小的集合（值的集合）。通常每个 Reduce 函数只产生 0 个或 1 个输出值。Reduce 函数一般通过一个迭代器（via an iterator）来获取中间值，从而在中间值的数目远远大于内存容量时，我们也能够处理。 Example Distributed Grep（分布式查找）：Map 函数获取匹配提供的模式的行，Reduce 函数只是简单地将这些中间数据拷贝到输出。 Count of URL Access Frequency（计算 URL 访问频率）：Map 函数处理 web 请求的日志，并且输出。Reduce 函数将拥有相同 URL 的 value 相加，得到对 Reverse Web-Link Graph：Map 函数输出对，其中 source 所在的 page 都有连向 target 这个 URL 的链接。Reduce 函数将给定 target 的所有的 source URL 连接起来，输出对 Term-Vector per Host：一个 term vector 表示一系列的键值对，word 表示一篇或者一系列文章中出现的比较重要的单词，frequency 表示它们出现的次数。Map 函数对于每篇输入的文章输出键值对（其中 hostname 是从文章所在的 URL 中抽取出来的）Reduce 函数获取给定 host 的 term vectors。它将这些 term vectors 累加起来，丢弃非频繁出现的 term，并产生一个最终的对。 Inverted Index：Map 函数对每篇文章进行处理，并输出一系列的对。Reduce 函数接收给定 word 的所有键值对，对相应的 document ID 进行排序并且输出对。所有输出对的集合构成了一个简单的倒排索引。用了 MapReduce 模型，对单词位置的追踪就变得非常简单了。 Distributed Sort：Map 函数从每个 record 中抽取出 key，产生键值对。Reduce 函数只是简单地将所有对输出。这个计算模型依赖于 Section 4.1 中描述的划分技巧以及 Section 4.2 中描述的排序特性。 Implement实现的细节不再赘述，在翻译文档中翻译过切理解了，M 份 Map 操作的 Worker 和 R 份 Reduce 操作的 Worker。 Fault Tolerance Worker Failure：不在响应 master 而被 master 标记为 failure 状态后，其任务会被分摊至其他 wordker。对于 M 任务，需要重做前面已经完成的（因为 Map 产生的中间结果本地存储，而此时“本地”是 failure 的），而对于 R 任务，继续完成即可。 Master Failure：我们可以很快地根据最新的快照来重新启动一个 master task。但是，因为我们只有一个 master，因此故障的概率比较低。所以，在我们的实现中如果 master 出现了故障就只是简单地停止 MapReduce 操作。用户可以检测到这种情况，并且如果他们需要的话可以重新开始一次 MapReduce 操作。 Semantics in the Presence of Failures：针对非确定性执行，是解集空间中的一个。 Refinements此外还有一些有用的扩展： Hash 之前的划分操作 划分产生文件的顺序性 Map 和 Reduce 之间加 Combiner 操作合并简化（C 和 R 操作很像，只是输出到哪有了差别） 跳过故障点 Status 动态显示 读后感受很神奇的一种编程范式，相当于做了一个介于应用和分布式环境中间的接口，按照这种编程范式去编程便可以充分利用下面的分布式资源而忽略其具体实现细节。 实现方案理解起来也是非常巧妙，给人的感觉更像是从大的集合中抽出键值相同的小集合，再做合并。 希望后续可以读到更多关于分布式有趣的想法！]]></content>
      <categories>
        <category>操作系统</category>
        <category>分布式系统</category>
      </categories>
      <tags>
        <tag>论文</tag>
        <tag>操作系统</tag>
        <tag>分布式系统</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[数论学习——欧拉函数与中国剩余定理]]></title>
    <url>%2Fpost%2F86266eca.html</url>
    <content type="text"><![CDATA[欧拉函数针对前面所学习的欧拉公式，如果我们无法快速有效的计算出来欧拉函数$\phi$的值的话，我们就不能充分发挥欧拉公式的作用，下面给出欧拉函数的计算方法。 定理 11.1 （$\phi$函数公式） (a) 如果$p$是素数且$k ≥ 1$，则 \phi(p^k) = p^k - p^{k-1}(b) 如果$\gcd (m,n) =1$，则$\phi(mn) = \phi(m) \phi(n)$ 证明过程证明 (a)素数情况的证明用全部数$p^k$减去与$p$不互素的$p,2p,3p, \cdots , (p^{k-1}-1)p, p^{k-1}p$，共$p^{k-1}$个。所以是$p^{k} - p^{k-1}$，余下要证明(b), 构造两个集合，集合 A，$\{ a: 1 \le a \le mn , \gcd (a, mn) = 1\}$，集合 B， $\{ (b,c): 1 \le b \le m, \gcd(b,m) =1 , 1 \le c \le n, \gcd(c,n) = 1 \}$，显然两个集合的大小分别为$\phi(mn)$和$\phi(m) \phi(n)$ 对于下面这种 A-&gt;B 的映射关系 $a \mod mn \to (a \mod m, a \mod n$)，我们可以证明它是一一映射的，由此也就得到了$\phi(mn) = \phi(m) \phi(n)$ 单射的证明（A 集合的不同数对应 B 集合的不同序对），假设原像为$a_1,a_2$，他们在 B 中有相同的映像，则有： a_1 \equiv a_2 \mod ma_1 \equiv a_2 \mod n可以推导得$a_1 - a_2 \equiv 0 \mod mn$，而又因为$m,n$互素，所以我们可以得到 a_1 \equiv a_2 \mod mn 满射的证明（B 集合的每个序对适合 A 集合的某个数），根据映射式以及对于任意$b,c$已知值： a \equiv b \mod ma \equiv c \mod n这个同余式组有解，这个用到了中国剩余定理的简化版（两个方程），给出证明。 因为$\gcd(m,n) = 1$，可计算（存在逆元）$m^{-1} ,n^{-1}$，满足$m^{-1}m \equiv 1 \mod n , n^{-1}n \equiv 1 \mod m$，则有 bn^{-1}n+cm^{-1}m \equiv b \mod mbn^{-1}n+cm^{-1}m \equiv c \mod n我们便找到了一个解$a = bn^{-1}n+cm^{-1}m$，实际上可证明在$\mod mn$条件下这个解是唯一的，见后面完整版中国剩余定理的证明。 中国剩余定理《数论概论》这本书上只介绍到了两方程的情况，查阅 Wiki 等资料拓展学习了一下。 定理 11.2 （中国剩余定理简化版）设$m_1,m_2, \cdots ,m_n$是整数，其中任意两数两两互质，则对任意整数：$a_1,a_2, \cdots , a_n$，下面的同余方程有解。 \begin{equation} \left\{ \begin{array}{lr} x \equiv a_1 , \mod m_1 & \\ x \equiv a_2 , \mod m_2 & \\ x \equiv a_3 , \mod m_3 & \\ \cdots \\ x \equiv a_n , \mod m_n & \\ \end{array} \right. \end{equation}设$M = m_1 \times m_2 \times \cdots \times m_n = \prod_{i=1}^{n}m_i$，并设$M_i = M/m_i, t_i \equiv M_i^{-1} \mod m_i$。方程的解表示为： x = a_1t_1M_1 + a_2t_2M_2 + \cdots + a_nt_nM_n + kM = kM + \sum_{i=1}^{n}a_it_iM_i , k \in Z在模$M$的意义下，方程组有唯一解，为： x = \sum_{i=1}^{n}a_it_iM_i 证明过程主要参考 Wiki 上的证明方法，中国剩余定理- 维基百科，自由的百科全书 证明 由于${\forall i,j ,i \ne j, \gcd(m_i,m_j) =1 }$，所以对于$\gcd(m_i,M_i) = 1$，所以均存在$t_i$使得$t_iM_i \equiv 1 \mod m_i$，即$M_i$模$m_i$的数论倒数，考察$a_it_iM_i$这个乘积： 对于${\forall j \in \{ 1, 2, \cdots , n\}}$，会出现两种情况： $j = i$时，$a_it_iM_i \equiv a_i \mod m_i$，后两项乘积是 1 $j \ne i$时，$a_it_iM_i \equiv 0 \mod m_j$，原因是$m_j \mid M_i$。 那么我们不难得出，$x = \sum_{i=1}^{n}a_it_iM_i$符合方程组。 下证在模$M$条件下解的唯一性。 假设存在$x_1,x_2$都是方程组的解且$1 \le x_1,x_2 \le M, x_1 \ne x_2$，那么我们可以得到方程组： \begin{equation} \left\{ \begin{array}{lr} x_1 - x_2 \equiv 0 , \mod m_1 & \\ x_1 - x_2 \equiv 0 , \mod m_2 & \\ x_1 - x_2 \equiv 0 , \mod m_3 & \\ \cdots \\ x_1 - x_2 \equiv 0 , \mod m_n & \end{array} \right. \end{equation}因而可以得到$(M = \prod_{i=1}^{n} m_i) \mid \vert x_1 -x_2 \vert$，而由条件$\vert x_1 - x_2 \vert \le M-1$显然矛盾，所以在模$M$下解是唯一的。]]></content>
      <categories>
        <category>数学</category>
        <category>数论</category>
      </categories>
      <tags>
        <tag>数论</tag>
        <tag>数学</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[分布式系统学习——阶段性总结1]]></title>
    <url>%2Fpost%2Feba34497.html</url>
    <content type="text"><![CDATA[感受主要回顾分布式学习前两篇 Paper 阅读感受。 Paper1——Time, Clocks, and the Ordering of Events in a Distributed System回忆梳理关键词：Happen Before 关系、偏序全序（局部序全局序）、逻辑时钟、物理时钟。 主体内容总结本文以分布式中系统中涉及时间概念的一个很困惑的问题作为引子——在分布式系统的架构中，当消息传输的时间不可忽略（如同广义相对论中时间的相对性），我们该如何定义分布式系统中时间发生的顺序，Lamport 向读者介绍了以下内容。 分布式系统中事件发生先后的概念（happen before）。 基于 happen before 的逻辑时钟（偏序/局部） 逻辑时钟在给定条件后的全局化（全局序），并给出了一个基于全局序的解决资源争夺问题方法。 物理时钟及其他相关问题 Happen Before这一段主要是用了离散数学里学到的关系，线序、偏序、全序的概念。 Lamport 不依赖物理时钟定义了事件 happen before（后面简写为 HB）的关系，基于以下的设想： 分布的各进程内的事件是线序，在先发生的对在后发生的具备 HB 关系 跨进程（进程间消息通信作为收/发两个事件）的事件，发出对接收有 HB 关系。 根据实际情况我们很容易总结出来，HB 关系应该是反自反、反对称、传递的。 整个分布式系统由于消息的通信构成一个从系统 start 开始的偏序集合。 Logical Clocks基于 HB 关系，Lamport 给出了一个给事件赋值的函数（逻辑时钟）及其计算方法，先后可通过函数值（逻辑时钟值）大小反映出来（但反过来不行）。 分布式算法概括： 每个 Process 对本进程的线序事件，计数值递增。 每个 Process 的事件发送消息时，附带时间戳。 每个 Process 接受到其他事件的消息时（HB 关系箭头的弧头），更新其计数器值为消息时间戳和本地计数器值 Max（+1）。 Order Totally将偏序全局化，需要人工定义一个 Process 的优先值（Process 顺序）。 人工定义的 Process 顺序不同会导致全序的不同，所以对于一个确定的（消息发送等确定）分布式系统，偏序集是确定的（唯一的），而全局序是不唯一的。 托这个全局序（全局的时间戳值）的福，Lamport 给出了一个解决单资源互斥问题的分布式算法。 算法细节及证明见翻译 doc，直观理解，没有这个全局序我们就不能依靠全局序的时间戳来比较从而进行对应操作。 Physical Clocks对于异常情况：存在外部的限制要求。Lamport 给出的解决方法。 外部要求内部化 引入实际物理时钟 对物理时钟的要求是：增速逼近单位 1，以及分布式物理时钟的一致性（数学证明还没有看懂）。 读完感受虽然是 1970+的文章了，但是分布式的核心问题（我以为的）已然提及，Lamport 对分布式中事件顺序的认识像极了相对论世界中事件/时间的观点，着实让我 get 了分布式不同于我现在所用所看所学的单机系统最大的不同。 对于问题解决的思路也是极为清晰，从关系的定义，到不依赖实际时间的逻辑大小、到全局化、再到实际时钟，结合实际问题的分布式算法，可以从最初的构想到最终的实现有一个流水线似的认识。 自己最喜欢的离散数学也在这里面发挥了很大的作用，见识到了数学——这种基础学科作为科学发展地基般的作用，我反复读了四到五遍文章，也看了 Lamport 本人对他自己这篇文章的评价和网络上其他人的评价，对于文章中可推的公式和可证明的地方都尝试自己推导了一下，着实让人着迷，作为自己尝试科研的启蒙文章，真的非常开心。 Paper2——Implementing Fault-Tolerant Services Using the State Machine Approach: A Tutorial回忆梳理关键词：状态机，容错（Fault Tolerance）、两种故障 主体内容总结看论文标题就知道，是一篇“Tutorial”，讲了用状态机模型来达到容错服务。 包括后面所看到的 GFS，自己学习的 LVM，都存在这样的问题：出错、出错、出错，由多台分布式机器构成的系统中难免会碰到这样那样的错误，防止出错此时显得太过较真，采用合适的策略（状态机、备份、心跳线热启动等）将出错导致的系统整体性能下降掩盖过去，达到高可用、用户层透明才是更“分布式”的思考方式。 State Machine接触了算法中涉及的自动机（AC 自动机、后缀自动机）以及编译原理中的自动机（DFA，PDA），对于状态机的概念已经比较熟悉了，这里用文章中的定义再从另一个角度强调一下：状态机的输出完全由它处理的请求序列决定。 Fault Tolerance两种计算机系统中常见错误： Byzantine Failures（拜占庭故障）：该组件可能表现出任意和恶意的行为，可能涉及与其他故障组件的勾结（个人理解是会反馈假结果，无法有效监测且可能影响周围组件） Fail-stop Failures. （异常终止错误）：允许其他组件检测到错误并停止。 考虑最坏情况下的 t tolerance 拜占庭故障所需组件数：2t+1（保证多数）异常终止所需组件数：t+1（保证存在一个返回正确结果即可） 某些特殊条件下还可以弱化条件。 实现的条件是保证备份（副本）的协调（Replica Coordination）：所有备份（副本）都可以接收到且接收到顺序相同的请求序列。 拆分成两个子要求： Agreement：每个非故障状态机都会接收到每个请求。 Order：每个非故障状态机都会以相同的顺序处理这些请求。 文章后续解释了个子要求的实现方式。 Agreement: 通过设置 transmitter 来使所有非故障状态机达到相同值。 OrderOrder 条件极其稳定性测试，稳定的请求可以传递给后面的状态机副本。个人对稳定的理解：具备相对优先顺序、不会改变、可被执行。 文章介绍了几种实现方法： 使用逻辑时钟（Lamport 的方法）赋值 同步的物理时钟方法 对应的稳定性检测在文章翻译部分分析过了，逻辑时钟是基于 FIFO 假设以及错误信息告知假设，使得当收到其他机器发来了更晚时间戳请求时，则先前的请求就是稳定的。而物理时钟是满足在$\tau - \delta$时间之前的即为稳定的。 读完感受应用了上一篇 Lamport 的时钟来解决 Order 的问题，感觉思路上是联通的。 状态机模型的应用有点感觉是执行状态的重复（但是说实话没有找到确切的状态描述，可能是论文看的还不够仔细）。 重新认识了两种类型，然后突然发现拜占庭问题还是 Lamport 等人最先提出来的，我想有机会去了解一下原论文，毕竟这个问题在网络/安全/系统中出现多次了。]]></content>
      <categories>
        <category>操作系统</category>
        <category>分布式系统</category>
      </categories>
      <tags>
        <tag>论文</tag>
        <tag>操作系统</tag>
        <tag>分布式系统</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[数论学习——同余式、幂与欧拉公式]]></title>
    <url>%2Fpost%2Fce543259.html</url>
    <content type="text"><![CDATA[定理 10.1（欧拉公式） 如果$\gcd(a,m) = 1$，则 a^{\phi(m)} \equiv 1 \mod m 证明过程至此，我们已经确定了考察的数的正确集合，所以欧拉公式的证明几乎和费马小定理完全一致。 先证明引理： 引理 10.2 如果$\gcd(a,m) = 1$，则数$b_{1}a,b_{2}a,b_{3}a, \cdots , b_{\phi(m)}a \mod m$与数$b_{1},b_{2},b_{3}, \cdots , b_{\phi(m)} \mod m$相同，尽管他们的次序并不相同。 证明：（极尽相似费马小定理的证明）实际上我们是证明了一个弱一些的结论，由于可以确定$\phi(m) \le m-1$，当$m$为素数时候取等，那么我们不妨假设有$b_j a \equiv b_k a \mod m$，做差，由于同余，而$m \nmid a$，$m \mid \vert b_j - b_k \vert$，而由于前述条件，只能有$0$符合条件，则得到$b_j \equiv b_k \mod m$，与假设矛盾（应该两两不同余）。引理得证。 后续，构造 (b_{1}a) \cdot (b_{2}a) \cdot (b_{3}a) \cdots (b_{\phi(m)}a) \equiv b_1 \cdot b_2 \cdot b_3 \cdots b_{\phi(m)} \mod m提公因式： a^{\phi(m)}B \equiv B \mod m由于每个$b_i$与$m$互素，所以我们可以两边整体消去$B$，得到： a^{\phi(m)} \equiv 1 \mod m]]></content>
      <categories>
        <category>数学</category>
        <category>数论</category>
      </categories>
      <tags>
        <tag>数论</tag>
        <tag>数学</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[数论学习——同余式、幂与费马小定理]]></title>
    <url>%2Fpost%2F799b8bb4.html</url>
    <content type="text"><![CDATA[费马小定理 设$p$是素数，$a$是任意整数且$a$，则 a^{p-1} \not\equiv 1 \mod p 证明过程尝试证明一般性的费马小定理。首先证明如下断言。 引理 9.2 设$p$是素数，$a$是任何整数且$a \not\equiv 0 \mod p$，则数$a,2a,3a, \cdots , (p-1)a \mod p$与数$1,2,3, \cdots ,(p-1)$相同，尽管他们的次序并不相同。 证明 反证法，假设存在两个模$p$同余的$ka,ja$，且两个数本身是不同的，做差后在这个假设下反推，若同余，而$p$为素数，素数整除乘积，必定整除乘积的一个因数，而我们从要求中已经得到$p \nmid a$，而又$\vert k-j \vert &lt; p-1$，得到$k-j = 0$，而这与我们假设两者本身不同相违背，得证。 利用该引理，容易完成费马小定理的证明，引理说明数列$a,2a,3a, \cdots , (p-1)a \mod p$与数列$1,2,3, \cdots ,(p-1) \mod p$相同，构造： a \cdot (2a) \cdot (3a) \cdots ((p-1)a) \equiv 1 \cdot 2 \cdot 3 \cdots (p-1) \mod p从左边提出$p-1$个$a$得： a^{p-1} \cdot (p-1)! \equiv (p-1)! \mod p根据同余式两边消的性质（参加另一篇《同余式、线性同余定理》拓展性质 2），我们便可以得到。 a^{p-1} \equiv 1 \mod p]]></content>
      <categories>
        <category>数学</category>
        <category>数论</category>
      </categories>
      <tags>
        <tag>数论</tag>
        <tag>数学</tag>
        <tag>同余式</tag>
        <tag>费马小定理</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[数论学习——同余式、线性同余定理]]></title>
    <url>%2Fpost%2Febe560d9.html</url>
    <content type="text"><![CDATA[今天写密码学实验报告放射密码一题的时候，看到线性同余式$c = ma+ b \mod n$，感觉到自己对于同余方程的掌握一点也不牢固，所以又拿出来《数论概论》重新回顾了一下，后续会写一个数论专题，本章主要讨论线性同余式定理。 同余式对于同余式我们已经很熟悉了，如果$m$整除$a-b$我们就说$a$与$b$模$m$同余。 记为 a \equiv b \mod m同余式满足一些我们熟悉的通常的等式的性质，例如：$a_1 \equiv b_1 \mod m$，且，$a_2 \equiv b_2 \mod m$，那么我们可以得到$a_1 \pm b_1 \equiv a_2 \pm b_2 \mod m$（类似等式两边相加），以及$a_1 a_2 \equiv b_1 b_2 \mod m$（类似等式两边相乘），但是需要指出的是，用数除同余式并不总是可能的，这个问题详见拓展性质 2。 数$m$叫做同余式的模，我们也很容易得知，每个整数必然与 0~m-1 的一个数模$m$同余。 一些同余式的拓展性质 同余式 $ab \equiv (a \mod m)(b \mod m) \mod m$ 恒成立。 证明：已知$a \equiv (a \mod m) \mod m$，$b \equiv (b \mod m) \mod m$，所以由相乘的性质德政。 当满足$\gcd (c,m) = 1$，则同余式$a c \equiv b c \mod m$可从同余式两边消去$c$。 证明：对于同余式$a c \equiv b c \mod m$成立，则有等式$ac-bc = km, k \in Z$，即$(a-b)c = km$成立，我们容易观察得等式左边为$c$的倍数，所以等式右侧也应为$c$的倍数，而我们又知道$\gcd (c,m) = 1$，也即$c \nmid m$，所以$c \mid k$，不妨设$k’c = k$，所以我们可以得到$a - b = k’ m$，故有，$a \equiv b \mod m$，得证。 同余方程我们的任务是解同余式$ax \equiv c \mod m$，包括判断其有没有解，有几个解，各个解是什么。 当然，可以应用同余式的性质解决一些简单的带未知数的同余式，如$4x \equiv 3 \mod 19$，我们两边乘以$5$得出，$20x \equiv 15 \mod 19$，应用性质 1，可得到$x \equiv 15 \mod 19$，代入可检测我们的答案。事实上，该式也只有这一个解。 我们接下来回归到一般形的求解过程中。对于同余式： ax \equiv c \mod m我们需要求整数$x$使得$m \mid ax-c$，如果可以求得整数$y$使得$ax-c = my$，则数$m$ 就整除数$ax-c$，移项后我们看到$ax \equiv c \mod m$有解当且仅当线性方程$ax-my =c$有解（等价推导），这个问题很像线性方程和最大公因数里讨论的问题（拓展欧几里得算法）。 设$g = \gcd(a,m)$，我们观察到，形如$ax-my$的每个数都是$g$的倍数。因此： $g \nmid c$，则$ax-my = c$无解，从而由等价性，原同余方程也没有解。 $g \mid c$，则由线性方程定理我们可以知道 au+mv = g总是有解的，不妨假设通过拓展欧几里得算法求得$u = u_0$，$v = v_0$，则有： a u_0 + m v_0 = g我们可以与原同余方程等价的线性方程的一个解。 a \frac{c u_0}{g} + m \frac{c v_0}{g} = c即我们得到了$x_0 \equiv \frac{c u_0}{g} \mod m$式原同余方程的一个解，那其他解呢？假设$x_1$是同余式的其他解，则$a x_1 \equiv a x_0 \mod m$，那么$m \mid a x_1 - a x_0$，这蕴含： \frac{m}{g} \mid \frac{a(x_1 -x_0)}{g}我们已知$\frac{m}{g}$与$\frac{a}{g}$没有大于 1 的公因数（除以最大公因数），从而$\frac{m}{g} \mid x_1 - x_0$。 x_1 = x_0 + k \bullet \frac{m}{g}但是相差为$m$的倍数的两个解在模数意义下被认为是相同的，所以原同余方程恰好有$g$个不同的解，即 x_i = x_0 + i \bullet \frac{m}{g}, i = 0,1,2 \cdots , g-1子证明，假设有$g+1$个不同解，则由鸽笼定理知，必存在$i_p \equiv i_q \mod g$，则$x_p - x_q = (p-q) \bullet \frac{m}{g} = k’g \bullet \frac{m}{g} = k’m$，那么这两个解是相同的，矛盾。 这就完成了对同余式$ax \equiv c \mod m$的分析，结果为如下定理 线性同余定理 设$a,c,m \in Z$,$m \geq 1$，且设$g = \gcd (a,m)$. (a)如果$g \nmid c$，则同余式$ax \equiv c \mod m$没有解。 (b)如果$g \mid c$，则同余式子$ax \equiv c \mod m$恰好有$g$个不同的解，先利用拓展欧几里得算法求得线性方程 au+mv = g的一个解$(u_0,v_0)$，则$x_0 = \frac{c u_0}{g}$是同余方程的一个解，完全集由 x = x_0 + k \bullet \frac{m}{g} \mod m , k = 0,1,2 \cdots , g-1 重要注记线性同余式定理的最重要的情形是$\gcd (a,m) = 1$，在这种情形下，同余式恰好有一个解。我们甚至可以把解写成分数 x \equiv \frac{c}{a} \mod m模$p$多项式根定理 设$p$为素数，$f(x) = a_0 x^{d} + a_1 x^{d-1} +\cdots +a_d$是次数为$d ≥ 1$的整系数多项式，且$p$不整除$a_0$，则同余式$f(x) \equiv 0 \mod p$最多有$d$个模$p$不同余的解。 反证法： 假设：存在一个首项系数不被$p$整除的整系数多项式$F(x)$，使得同余式$F(x) \equiv 0 \mod p$模$p$不同余的根的个数大于$F(x)$的次数。 在所有这样的多项式中选择一个次数最低的$F(x)$，为 d 次，则$r_1,r_2,\cdots,r_{d+1}$是同余式的$d+1$个模$p$不同余的解。对于任意值$x$，$r$，$F(x)-F(r)$都是可约的（利用$a^t - b^t = (a-b)(a^{t-1}+a^{t-2}b+ \cdots + b^{t-1})$），我们可以得到，$F(x) = F(r)+(x - r)G(x)$，而$G(x)$的次数为$d-1$次，我们已经假设原$F(x) \equiv 0$有$r+1$个互不同余的解，令$x=r_1$，$r$取剩下其中任意一个$r_k$，由于$p$为素数，我们可以得到$G(r_k) \equiv 0 \mod p$，我们发现$G(x)$也是一个符合要求的多项式，这就与我们的假设条件相互矛盾，$F(x)$不是最小次的。得证。]]></content>
      <categories>
        <category>数学</category>
        <category>数论</category>
      </categories>
      <tags>
        <tag>数论</tag>
        <tag>数学</tag>
        <tag>同余式</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[《Justice公正》桑德尔教授公共课观后感+读书摘录]]></title>
    <url>%2Fpost%2F9fb9be6e.html</url>
    <content type="text"><![CDATA[第一章 做正当的事对于灾患情况下一些物价被抬长，反价格欺诈法的出现在人群中出现了一些争论声，以“查理”飓风袭击美国为例，有的人反对，这样讲到，“根据市场所产生的价格索价，不是欺诈，也不是贪婪或无耻之举，而只是物品和服务在自由社会中分配的方式。尽管价格暴涨着实令人恼怒，但这些愤怒并不构成干涉自由市场的”正当理由。高价格才能促使更多的生产流入患灾地区。”而另一些人则维护反价格欺诈法，“在危急关头，比如当人们逃命时，或者在飓风后为家人寻求基本日用品时，在索要过高价格，政府不能袖手旁观。” 关于反价格欺诈的争论引发了一些道德和法律相关的棘手问题：物品和服务的销售商利用一场自然灾害，根据市场需求随意定价，这是否是不正当的？如果不正当，那么法律应当做些什么呢？政府是否应当禁止价格欺诈——即使这样做干涉了购买者和销售者的交易自由。 福利、自由与德性法律的出台，制定的问题，以及我们如何组织一个社会，这些都是关于公正（Justice）的问题，想要解答它们，我们必须探索公正的含义。 有些人对于反价格欺诈法的争论，背后的福利、自由的问题以及一些人们对于这些话题（尽管他们没有切身受到飓风影响）所表达出来的情绪波动，都表征着背后的一种我们潜意识里的道德论证。 我个人觉得尽管潜意识里已经进行过自我的道德论证，对于深入的讨论，对社会有贡献的讨论，我们有必要将这种论证明确化，以避免其仅出自一种本能的、直觉的反应。这种情绪常被看做是一种原始的、不应当干涉公共政策或法律的感情。 雅各比：“把商贩们看做魔鬼并不能加快弗罗里达重建的脚步。” 政治哲学中一个重要问题：一个公正的社会应当努力推进其公民的德性吗？或者，法律是否应当在各种德性观念中保持中立，以使公民们能够自由地为自己选择最佳的生活方式？ 传统观点认为，对于这一问题的不同解答区分了古代和现代的两种政治思考。在某种意义上是对的，亚里士多德教导我们公正意味着给予人们所应得，我们不得不决定哪些德性值得尊敬和奖赏，如果不首先反思哪种是人们最想要的生活方式，我们就不能弄明白什么是公正的宪法。对他而言，法律不可能中立于良善生活的各种问题。 与此相对，现代政治哲学家们——从 18 世纪的伊曼纽尔·康德（Immanuel Kant）到 20 世纪的约翰·罗尔斯（John Rawls）——认为，那界定我们各种权利的公正原则，应当不依赖于任何特殊的德性观念或最佳生活方式的观念，反过来讲，一个公正的社会应当尊重每个人选择它自己的关于良善生活观念的自由。 受什么样的伤才配得上紫心勋章关于紫心勋章的争论，并不只是一种如何界定上海之真实性的医学或临床上的争论。此争论的核心在于各种关于道德品格和勇士勇气的观念。坚持流血才能配得上紫心勋章的人们相信，创伤后应激障碍反映出的不是值得赞赏或鼓励的德性，而是一种不值得尊敬的性格上的软弱；而那些认为心理创伤也应当算数的人们则反驳说，那些受到长期性心灵创伤和严重抑郁症所折磨的老兵们，与那些失去一只胳膊的老兵们为他们的国家做出的牺牲同样确凿无疑，同样光荣。 如果不搞清楚军章所鼓励的德性是什么，我们就不能决定谁可以配得上紫心勋章，这与亚里士多德教导我们的相一致。 展开来讲，这一事件追溯回从荣誉和德性的古代伦理，其实今天有关经济安排的对与错的争论，经常会将我们带回到亚里士多德关于人们在道德上应得什么，以及为何如此的讨论。 对政府救助的愤慨经济危机时发给金融投机公司高管的奖金，点燃了公众的怒火。许多人批判其为贪婪，但是这种对于贪婪的批判的问题在于，它没有把这次经济崩溃后从救助款项中拿到的奖励，与经济繁荣时期从市场获得的奖励区分开来。事实上民怨的核心是：政府奖励了他们的失败，这才是他们真正愤怒的地方。 更深入的，成功人士应得市场所赋予他们的丰厚收入吗？这些丰厚收入是否取决于他们无法掌控的因素呢？在经济良好时期和经济低迷时期，公民之间的相互责任又意味着什么呢？ 失控的电车在不可停下只可转换轨道的电车上，原始轨道上有五个工人，右边轨道有一个工人。是撞向五个人还是撞向那一个人？ 牺牲一个人生命以挽救五个人的生命似乎是正当的事情，那如果更换情况，一个壮硕的人在桥上，推下去可以挽救五个人，这时候会坚持原有的道德判断吗？如果你觉得用自己的双手将一个人推向死亡确实比转动电车的方向盘更加残忍，那再做改变，你有一个可以转向的方向盘，连接那个壮硕的人脚下的一个活板门，不伸手推，这时候转动这个方向盘就会使之成为正当之举了吗？或者，者是否仍然比作为有轨电车司机的你拐向岔道在道德上更为恶劣呢？ 某些道德困境源于相互冲突的道德原则，另一些则源于我们不确定事情如何展开（阿富汗牧羊人困境，《孤独幸存者》）。重要的假想案例有助于我们剥离出重要的道德原则，并检验它们的力量。 第二章 最大幸福原则/功利主义“米尼奈特”沉没使得饥肠辘辘的四人不得不决定其中一个人作为其他三人的“食物”，我们该如何看待？ 如果拯救多数人而不是全部饿死是提升了人们的整体幸福感，那么我们的反驳又从何而来呢？是质疑实际利益（幸福感）的提升并非如我们想象的那样？（比如此事件的恶劣后果导致的社会影响，削弱对谋杀这一规范的权威性？）还是说尽管利大于弊，但我们仍感觉在道德上无法接受这一做法。 这引导我们去探索一些更重大的道德和政治哲学的问题：道德就是计算生命、权衡得失呢？还是某些道德责任和人权是根本的，以至于它们超越于这样的算计之上？如果某些权力在这方面是根本性的——假如它们是自然的、神圣的、不可剥夺和无条件的——我们该如何甄别它们呢？又是什么使得它们具有这样的根本性呢。 杰里米·边沁的功利主义边沁是英国道德哲学家和法律改革者，创立了功利主义（Utilitarianism）学说，其主要观点很简单，并对人具有直觉上的吸引力：道德的最高原则就是使幸福最大化，使快乐总体上超过痛苦，对边沁而言，正当的行为就是任何使功利最大化的行为。他所说的“功利”，意指任何能够产生快乐或幸福，并阻止痛苦或苦难的东西。 边沁将其哲学思想尝试作为政治改革的基础，他提出了很多计划来使刑法政策更有效、更人性化。诸如环形监狱（私人监狱）、乞丐的管理收容（为了促进整体社会福利而将他们行动上隔离）。 对于边沁的反对声音当然也存在，在考虑当代的功利主义思维方式的事例之前，我们有必要质问，边沁的哲学是否可以反驳呢？如果是的话，理由是什么？ 反驳1：个体权利如果坚持边沁所认为的功利主义的逻辑，就极有可能纵容无视人类基本尊严的行为，比如将基督徒扔给狮子来取悦古罗马人，严刑逼供来防止一场大规模恐怖袭击。那如果严刑逼供能达到的唯一目的是折磨恐怖分子年幼无知的女儿呢（她对事情一无所知）？ 批评者们认为有些时候为了整体利益而去侵犯一个人的一些基本权利（比如生命、自由）是在道德上不可接受的。这是对维护基本人权的考量。 反驳2：通用价值货币更Commercial的例子有烟草公司的伤害性帮助政府节省了很大的开支，是促进了整体福利吗？福特公司明知Pinto汽车油箱问题但为了收益的最大化（以死亡赔付衡量生命价值后）选择无视问题，是正确的吗？等等。 深究我们对于功利主义的批判，最终归根于一些道德重要的东西——亦即这样一种观念：我们不可能在一个尺度上衡量和比较所有的价值和物品。]]></content>
      <categories>
        <category>阅读</category>
      </categories>
      <tags>
        <tag>阅读</tag>
        <tag>公正</tag>
        <tag>Justice</tag>
        <tag>桑德尔</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[分布式系统学习——GFS谷歌文件系统Paper翻译]]></title>
    <url>%2Fpost%2F7c86d8e8.html</url>
    <content type="text"><![CDATA[读书笔记——The Google File System参考翻译版本：Google File System 翻译（转） 加粗和笔者注是重点关注的部分。 Abstract我们已经设计和实现了 Google File System，一个适用于大规模分布式数据处理相关应用的，可扩展的分布式文件系统。它基于普通的不算昂贵的硬件设备，实现了容错的设计，并且为大量客户端提供极高的整体处理性能。 Introduction我们已经为 Google 迅速增长的数据处理需求而设计和实现了 Google File System(GFS)。GFS 和上一个分布式文件系统有着很多相同的设计目的，比如性能，扩展性，可靠性，以及可用性。不过，包括现在和未来预期下，它的设计是基于我们应用的工作量和技术环境驱动的，因而 GFS 都有一些和上一个版本明显不同的地方。这就要求我们重新审视传统的设计选择，并探索完全不同的设计要点。 首先，节点失效将被看成是正常情况，而不再视为异常情况。整个文件系统包含了几百个或者几千个由廉价的普通机器组成的存储机器，而且这些机器是被与之匹配数量的客户端机器访问。这些节点的质量和数量都实际上都导致总会出现一些失效情况，并且某一部分机器并不会从当前失效中恢复回来。原因是多样的，比如程序的 bug，操作系统的 bug，人工操作 error，以及硬盘坏掉，内存，网络，插板的损坏，电源的坏掉等等。因此，持续监视，错误检测，容错处理，自动恢复必须集成到这个文件系统的设计中来。 第二，大型数据文件的规模出现导致文件观念的改变。当我们通常操作迅速增长的，由很多 TB 组成的，包含数十亿对象的数据集，我们可不希望管理数十亿个 KB 大小的文件（无论文件系统是否有如此能理）。所以，设计约定和设计参数比如 I/O 操作以及 blocksize（块大小），都需要重新审查。 第三，文件的改变常为追加（append）而非覆盖（overwrite），对一个文件的随机写操作（random write）实际上是几乎不存在的。当一旦写完，文件就是只读的，并且一般都是顺序读取。许多 data 都具备这样的特性：仅供应用扫描数据的超大数据库、应用不断产生的数据流、归档的数据、机器交互的中间数据生成和处理。对于这些巨型文件的访问模式来说，“追加（append）”是最重要的，所以我们首要在性能上优化并保证原子性操作的就是它，而缓存客户端中的数据块则失去吸引力（不是 GFS 重点关注的对象）。 第四，结合应用与文件系统 API 一同设计对于增加整个系统的弹性有很大的好处。例如我们放宽 GFS 一致性模型后可以在避免给应用增加负担的同时简化文件系统。我们也引入了原子的追加（append）操作，这样可以让多个客户端并发对同一文件进行追加操作，而不需要额外的同步。这些在本论文的后边章节有描述。 Design OverviewAssumptions在针对我们的需求设计文件系统时，由一些既是机会又是挑战的假设指导我们的操作。前述给出了一些关键信息，现在将更细致的阐述这些假设。 系统由许多廉价而易出错的商品组件构成，他必须持续监管自身并在此基础上及时监测、容纳组件故障。 系统存储了大量的超大文件。预期好几百万个文件，每一个超过 100MB。数 GB 的文件会经常出现并且应当受到有效的管理。系统必须同时支持小型文件，但不必为小型文件进行特别的优化。 一般的工作都是由两类读取操作组成：大规模流式读取和小规模随机读取。 在大规模流式读取中，每个独立操作通常要读取几百 KB 的数据，更常见的是每次读取 1MB 或者以上的数据。对于同一个客户端来说，往往会发起连续的读取操作顺序读取一个文件。 小规模的随机读取通常在文件的不同位置，读取几 KB 数据。对于性能有过特别考虑的应用通常会作批处理并且对他们读取的内容进行排序，这样可以使得他们的读取始终是单向顺序读取，而不需要往回读取数据。 工作同时包含大规模顺序的写操作，将数据不断追加之文件中，其规模与读取规模相当。一旦写入完成，文件几乎不会再做该懂。小的随机写入操作应被支持但无需在意其效率。 系统必须为同时追加到同一文件的多个客户端有效地实现明确定义的语义含义。我们的文件通常用于生产者 - 消费者队列情形或用于多路合并（many-way merging）。 数百个独立运作在机器上的生产者将并发地向某个文件追加数据。 具有最小同步开销的原子性保证是必不可少的。 高持续带宽比低延迟更重要。我们的大多数目标应用程序都在处理大量数据时以很高的速度预先完成任务，很少有对单个读或写有严格的响应时间要求的应用程序。 Interface虽然 GFS 没有实现像 POSIX 这样一些标准地 API，但是它提供了一套常见的文件系统接口。文件在目录中按层次结构组织，并由路径名标识。我们提供了对文件的一些常规的操作：_create_，_delete_，_open_，_close_，_read_，_write_。 此外 GFS 还提供了snapshot，record append操作。Snapshot 以较低耗费建立一个文件或者是目录树的拷贝。Record append 则允许多个客户端对相同一个文件并发进行追加（append）数据时保证每个追加操作的原子性。这个对于多路合并操作和多个客户端同时操作的生产者/消费者队列的实现非常有用，它不用额外的加锁处理。这种文件对于构造大型分布式应用来说，是不可或缺的。两者将在后面 3.4 和 3.3 节单独讲述。 Architecture一个 GFS 集群由一个 master 和多个 chunkserver 组成，可以被多个 client 访问，如图 1 所示。 它们都是一个运行着用户级服务进程（user-level process）的商品化 linux 机器。只要机器资源允许以及由于运行可能的片状应用程序代码带来的低可靠性是可以接受的，那么可以很容易的在同一台机器上运行一个 chunkserver 和 client。 文件被划分成固定大小的 chunk。每个 chunk 是由 chunk 创建时由 master 分配的一个不可变的全局唯一的 64bit 句柄来标识。Chunkserver 将 chunk 作为 linux 文件存储在本地，对于 chunk 数据的读写通过 chunk 的 handle 和字节边界来表示。为了可靠性，每个 chunk 存储在多个 chunkserver 上。尽管用户可以为不同文件名字空间区域指定不同的备份级别，默认地我们存储三个备份（与后续的 MapReduce 对于 GFS 输入文件常为三份备份习惯上是一回事）。 Master 维护所有的文件系统元数据。包括名字空间（namespace），访问控制信息（access control information），文件与 chunk 的映射信息，chunk 的当前位置（current locations 注意是 chunck 多个备份的位置）。它也控制系统范围内的一些活动，比如 chunk 租赁管理，僵死 chunk 的垃圾回收，chunkserver 间的 chunk 迁移。Master 与 chunkserver 通过心跳信息（_Heart Beat_ messages）进行周期性的通信，以发送指令和收集 chunkserver 的状态。 应用程序链接的 GFS 客户端代码，实现了文件系统 API 以及代表应用程序与 master 和 chunkserver 进行通信以读写数据。客户端如果需要操作元数据则需要与 master 通信，但是所有的纯数据通信直接与 chunksever 通信。我们没有提供 POSIX API，因此也就不需要与 linux vnode layer 关联。 客户端或者 chunkserver 都不会对文件数据进行缓存（cache）。客户端缓存只能得到很少的好处，因为大部分的应用需要直接读取整个大文件或者工作集合太大根本无法缓存。没有 cache 简化了客户端和整个系统，因为不需要考虑缓存一致性问题(实际上客户端会缓存元数据)。Chunkserver 不需要进行文件数据缓存，是因为 chunk 是作为本地文件存储，这样 Linux 自身会将那些经常访问的数据进行缓存（间接利用了操作系统？）。 Single Master只有一个 master 大大简化了我们的设计，而且使得 master 可以利用全局信息对 chunk 的放置和备份进行更好（sophisticated 老练的）的判断。然而，我们必须最小化其在读写过程中的参与，以防止其成为运行的瓶颈。Clients 永远不会通过 master 读取数据，它只向 master 询问它该与哪个 chunckserver 联系，并且 client 将这些信息在有限的时间段内进行缓存，直接与 chunksever 交互进行很多后续的操作。（注意，不缓存文件数据，但是会缓存和那个 chunkserver 交互的信息）。 我们简单解释一些一个读操作的交互过程：首先，通过固定大小的 chunk，客户端将应用程序中标识的文件名和 offset 转换为 chunk 的 index。然后给 master 发送一个包含文件名和 chunk index 的请求，master 返回相应的 chunk 的 handle 和所有备份的位置。客户端以文件名和 chunk index 为 key 将这条信息进行缓存。 然后客户端给其中一个备份发送一个请求，通常是最近的那个。请求标识了 chunk 的 handle 以及在那个 chunk 内的字节边界。直到缓存信息过期或者重新打开文件之前，对于相同 chunk 的后续读操作就不需要 client-master 的通信了。事实上，客户端通常在一个请求中查询多个 chunk 的信息，master 也可以将这些被请求的多个 chunk 的信息包裹在一块进行返回。这种特别的信息，并没有额外的花费就避免了未来的 client-master 的多次通信。 Chunk SizeChunk 大小是一个关键的设计参数。我们选择了 64mb，远远大于现有的文件系统块。每个 chunk 的副本作为普通的 linux 文件存储在 chunkserver 上，如果需要才会进行扩展。Lazy 空间分配避免了内部碎片造成的空间浪费，很可能最大的碎片有向一个 chunk 那么大。 大的 chunk size 提供了几个重要的优势。首先，降低了 client 与 sever 的交互需求，因为在相同 chunk 上的读写只需要一个初始化请求就可以从 master 得到 chunk 的位置信息。这个减少对于我们的应用负载是非常明显的，因为我们应用大部分需要顺序的读写整个大文件。即使对于小的随机读取，客户端也可以很容易的缓存一个几 TB 工作集的所有 chunk 的位置信息。其次，由于 chunk 很大，那么客户端就很有可能在一个给定的 chunk 上执行更多的操作，这样可以将一个与 chunkserver 的 TCP 连接保持更长的时间，这就减少了网络开销。再者，降低了存储在 master 上的元数据大小。这样就允许我们将元数据存放在内存中，反过来就带来了我们将在 2.6.1 中讨论的其他优势。 另一方面，大的 chunk size，即使采用了 lazy 空间分配，也有它的缺点。小的文件可能只有少数几个 chunk，或许只有一个。如果很多的 client 都需要访问这个文件，这样那些存储了这些 chunk 的 chunkserver 就会变成热点。实际中，热点还没有成为一个主要的考虑点因为我们的应用绝大部分都是在顺序读大的多 chunk 文件。 然而，当 GFS 第一次使用在一个批处理队列（Batch-queue）系统时，热点确实出现了：一个可执行文件作为一个 chunk 的文件写到 GFS，然后同时在数百台机器上开始执行。存储了该可执行文件的那些 chunkserver 被数百个并发请求瞬间变成超载。我们通过更高的备份级别存储这样的可执行文件以及减慢队列系统的应用程序启动时间解决了这个问题。一个潜在的长远的解决方案是在这种情况下，允许客户端从其他客户端读取数据。（单一申请频次高的文件容易导致热点问题。） MetadataMaster 存储了三个主要类型的元数据：文件和 chunk 名字空间，文件到 chunk 的映射信息，每个 chunk 的备份的位置。所有的元数据都保存在 master 的内存中。前两种类型还通过将更新操作的日志保存在本地硬盘和备份在远程机器来保持持久化。使用 log 允许我们简单可靠地更新 master 的状态，不用担心当 master crash 的时候的不一致性。Master 并没有永久保存 chunk 的位置信息，而是在 master 启动或者某个 chunkserver 加入集群时，它会向每个 chunkserver 询问它的 chunks 信息（动态询问保存）。 In-Memory Data Structures由于元数据存储在内存里，master 的操作是很快的。因此对于 master 来说，可以简单有效地对在后台整个状态进行周期性扫描。这个周期性的扫描是用来实现 chunk 垃圾回收，chunkserver 出现失败时进行的重备份（re-replication），以及为了平衡负载和磁盘空间在 chunkserver 间的 chunk 迁移。4.3 4.4 将进一步讨论这些活动。 这样全内存策略存在一个潜在的限制就是 chunk 的数目，因此整个系统的容量取决于 master 有多少可用内存。实际中这不是一个很严重的限制。Master 为每个 64MB 的 chunk 维护少于 64byte 的数据。大部分的 chunk 是满的，因为大部分的文件包含多个 chunk，只有最后一个 chunk 可能是未慢的。类似的，每个文件名字空间数据通常需要少于 64byte 因为文件名称存储时会使用前缀压缩算法进行压缩。 如果需要支持更大的文件系统，只需要往 master 里添加内存。这点开销与通过将元数据存储到内存所得到简单性，可靠性，性能和灵活性，将是很小的一笔花费。 Chunk LoactionsMaster 并没有提供一个永久性的存储保存对于一个给定的 chunk 都是那些 chunkserver 保存了它的副本。它只是在启动时，简单地从 chunkserver 那里把这些信息拉过来（见本小节开头）。Master 能够保证它自己是更新过的，因为是由它来控制 chunk 的放置，以及通过周期性的心跳信息来监控 chunkserver。 起初，我们尝试将 chunk 位置信息永久保存在 master，但是我们发现在启动时去 chunkserver 请求这些数据更简单。这样避免了当 chunkserver 在加入或者离开集群，改名，失败，重启等待时需要的 master 与 chunkserver 间的同步。在一个数百台机器的集群中，这样的事件太经常了。 理解这个设计决定的另一个方式是 chunkserver 对于自己有还是没有某个 chunk 具有最终的发言权。在 master 上维护一个这些信息一致性视图是没有意义的，因为发生在 chunkserver 上的错误可能使得一些 chunk 突然间不见了(比如硬盘可能会坏掉或者不可用)，一个操作可能将 chunkserver 重命名。 （读者注：server 具备自己有没有某个 chunck 的最终发言权，要联络，不要记忆。） Operation Log操作日志包含了关键元数据改变的历史记录。它是 GFS 的核心。它不仅是元数据的唯一一致性记录，而且它也定义了那些并发操作的逻辑上的时间表。文件和 chunk 的版本都是唯一且永远地由它们创建时的逻辑时间来标识的。 因此操作日志是很关键的，我们必须可靠地保存它，在任何元数据变更在被持久化之前不应当被客户端看到。否则，即便 chunckserver 自己保存了它们，我们将丢失整个文件系统或者最近的客户端操作。因此我们将它备份在多个远程机器上，对于一个客户端操作只有当该操作对应的日志记录被刷新到本地和远程的磁盘上时才会发出响应。Master 将几个操作日志捆在一块刷新，从而降低刷新和复制对于整个系统吞吐率的影响。 Master 通过重新执行操作日志来恢复它的文件系统。为了最小化启动时间，我们必须将日志保持在很小的规模。当日志增长超过一定的大小后，Master 给它的状态设置检查点，它可以通过从本地磁盘加载最新的检查点进行恢复，然后重新执行那些在该检查点之后的日志记录。检查点保存了一个压缩的类 B 树的结构，不需要额外的解析就可以直接映射到内存用于名字空间查找。这大大提高了恢复的速度和可用性。 因为建立一个检查点会花费一些时间，master 的内部状态的结构设计使得一个新的检查点可以不需要延时那些接受到的变化就可以被创建。Master 会启动一个新的线程切换到一个新的日志文件然后创建新的检查点。这个新的检查点包含在切换之前的所有变更。对于一个包含几百万文件的集群大概需要几分钟就可以完成。结束后，它将会被写回本地和远程的磁盘。 恢复只需要最新完全的检查点和后来的日志文件。更老的检查点和日志文件可以自由的删除，当然我们会保存了一些来应对某些突发情况。在创建检查点的时候发生的失败不会影响系统的正确性，因为恢复代码会检测和跳过不完全的检查点。 Consistency ModelGFS 使用一个放宽的一致性模型不但很好的支持了我们的高度分布式的应用，而且实现起来也相对简单和有效率。我们现在讨论 GFS 所提供的保证以及它们对应用程序的意味着什么。我们也会讲述 GFS 如何维护这些保证，但是会将具体的细节留到其他论文里讲述。 Guarantees by GFS文件名字空间的改变(比如文件创建)是原子性的。它们只由 master 进行处理：名字空间锁来保证原子性和正确性(4.1 节)。Master 的操作日志定义了这些操作的全局性的排序。 当数据变更后，文件区域的状态取决于变更的类型，变更是否成功以及是否是并发进行的。表 1 是对结果的一个概述。 一致的（Consistent）：：所有的客户端无论从哪个副本读取数据总是看到相同的数据。 定义良好的（defined）：一致的文件可以被客户端读取全部的变更。 操作影响： 变更成功，且没有受到其他并发写者的影响，那么被影响的区域就是定义良好的（肯定是一致性的）。 并发的成功变更，影响区域是一致的，但不是定义良好的，客户端可能无法看到所有的更改。(如果变更是针对相同的数据写这样有的变更就会被新的变更所覆盖，这样用户就无法看到最先的变更了，同时发生在跨 chunk 的操作会被拆分成两个操作，这样这个操作的一部分可能会被其他操作覆盖，而另一部分则保留下来，如 3.1 节末尾所述)，通常其看到的是多个变更组合以后的结果。 一个失败的变更，会使区域进入非一致的状态（因此也是未定义的状态）：不同的客户端在不同的访问中可能看到不同的数据。我们下面描述下我们的应用程序如何区分定义良好的区域和未定义的区域。应用程序不需要进一步区分未定义区域的各种不同的类型。 数据变更可能是写或者记录 append。写操作会使数据在应用程序指定的偏移位置写入。记录 append 操作会使数据原子性的 append，如果是并发性的话则至少会被 append 一次，但是偏移位置是由 GFS 决定的(见 3.3 节，通常的理解可能是在客户端想写入的那个文件的尾部)。偏移位置会被返回给客户端，同时标记包含这条记录的那个定义良好的文件区域的起始位置。另外 GFS 可能会在它们之间插入一些 padding 或者记录的副本。它们会占据那些被认为是不一致的区域，通常它们比用户数据小的多。 在一系列成功的变更之后，变更的文件区域被保证是定义良好的的，同时包含了最后一次变更的数据写入。GFS 通过两种方式来实现： 将这些变更以相同的操作顺序应用在该 chunk 的所有的副本上， 使用 chunk 的版本号来检测那些可能是由于它的 chunkserver 挂掉了而丢失了一些变更的陈旧副本。陈旧的副本永远都不会再参与变更或者返回给那些向 master 询问 chunk 位置的 client，它们会优先参与垃圾回收。 因为客户端会缓存 chunk 的位置，在信息更新之前它们可能会读到陈旧的副本。时间窗口由缓存值的超时时间以及文件的下一次打开（这种文件的打开会清除该文件相关的所有 chunk information）而限制。由于我们的大多数文件是 append-only 的，因此一个陈旧副本通常会返回一个过早结束信号（premature）的 chunk 而不是过时（outdated）的数据。当读取者（由 client 担当）重试并与 master 联系时，它会立即得到当前的 chunk 位置（更新相关的信息）。 成功的变更很久之后，组件失败仍有可能破坏或者污染数据。GFS 通过进行周期性的 master 和所有 chunkserver 的握手找到那些失败的 chunkserver，同时通过校验和(5.2 节)来检测数据的污染。一旦发现问题，会尽快的利用正确的副本恢复(4.3 节)。只有一个块的所有副本在 GFS 做出反应之前，全部丢失，这个块才会不可逆转的丢失，而通常 GFS 的反应是在几分钟内的。即使在这种情况下，块不可用，而不是被污染：应用程序会收到清晰的错误信息而不是被污染的数据。 Implications for ApplicationsGFS 应用程序可以通过使用简单的技术来适应这种放宽的一致性模型，这些技术已经为其他目的所需要：依赖于 append 操作而不是 overwrite，检查点保存，写入时自我验证，自我标识记录。 典型应用一：一个写操作者会从头至尾生成一个文件。当写完所有数据后它自动的将文件重命名为一个永久性的名称，或者通过周期性的检查点检查已经有多少数据被成功写入了。检查点可以通过校验和实现。 典型应用二：多个写者同时向一个文件 append，为了归并/生产者消费者队列，记录的 append 的 append-at-least-once 语义保证了每个写者的输出。读取者这样处理偶然的 padding 和重复数据。写者为每条记录准备一些额外信息比如校验和，这样它的合法性就可以验证。如果不能容忍重复的数据（比如他们可以触发非幂等的操作，幂等操作是指无论执行多少次结果都会改变、而非幂等是指结果会改变），可以通过在记录中使用唯一标识符来过滤它们，很多时候都需要这些标识符命名相应的应用程序实体，比如网页文档。这些用于 record 输入输出的功能函数是以库的形式被我们的应用程序共享的，同时应用于 gongle 其他的文件接口实现。所以，相同系列的记录，加上一些罕见的重复，总是直接被分发给记录读取者。 System Interactions我们是以尽量最小化 master 在所有操作中的参与度来设计系统的。在这个背景下，我们现在描述下 client，master 以及 chunkserver 如何交互来实现数据变更，原子性 append 记录以及快照的。 Leases and Mutation Order每个变更在所有的副本上执行，我们使用租约（leases）来保持多个副本间变更顺序的一致性。Master 授权给其中的一个副本一个该 chunk 的租约，我们把它叫做主副本（primary）。这个主副本为针对该 chunk 的所有变更的选择一个执行顺序，然后所有的副本根据这个顺序执行变更。因此，全局的变更顺序首先是由 master 选择的租约授权顺序来确定的（可能有多个 chunk 需要进行修改），而同一个租约内的变更顺序则是由那个主副本（primary）来定义的。 租约机制是为了最小化 master 的管理开销而设计的。一个租约有一个初始化为 60s 的超时时间设置。然而只要这个 chunk 正在变更，那个主副本就可以向 master 请求延长租约。这些请求和授权通常是与 master 和 chunkserver 间的心跳信息（帮助 master 确定 chunkserver 的状态）一起发送的。有时候 master 可能想在租约过期前撤销它(比如，master 可能想使对一个正在重命名的文件的变更无效)。即使 master 无法与主副本进行通信，它也可以在旧的租约过期后安全的将租约授权给另一个新的副本。 如图 2，我们将用如下的数字标识的步骤来表示一个写操作的控制流程。 client 向 master 询问那个 chunkserver 获取了当前 chunk 的租约以及其他副本所在的位置。如果没有人得到租约，master 将租约授权给它选择的一个副本。 master 返回该主副本的标识符以及其他副本的位置。Client 为未来的变更缓存这个数据。只有当主副本没有响应或者租约到期（60s 或者 master revoke）时它才需要与 master 联系。 client 将数据推送给所有的副本，client 可以以任意的顺序（针对副本的顺序）进行推送。每个 chunkserver 会将数据存放在内部的 LRU buffer cache 里，直到数据被使用或者过期（缓冲流）。通过将控制流与数据流分离，我们可以通过将昂贵的数据流基于网络拓扑进行调度来提高性能，而不用考虑哪个 chunkserver 是主副本。3.2 节更深入地讨论了这点。 一旦所有的副本接受到了数据，client 发送一个写请求给主副本，这个请求标识了先前推送给所有副本的数据。主副本会给它收到的所有变更(可能来自多个 client)安排一个连续的序列号来进行必需的串行化。它将这些变更根据序列号应用在本地副本上。 主副本将写请求发送给所有的次副本，每个次副本以与主副本相同的串行化顺序应用这些变更。 所有的次副本完成操作后向主副本返回应答 主副本向 client 返回应答。任何副本碰到的错误都会返回给 client。出现错误时，该写操作可能已经在主副本以及一部分次副本上执行成功。(如果主副本失败，那么它不会安排一个序列号并且发送给其他人)。客户端请求将会被认为是失败的，被修改的区域将会处在非一致状态下。我们的客户端代码会通过重试变更来处理这样的错误。它会首先在 3 到 7 步骤间进行一些尝试后在重新从头重试这个写操作。 如果应用程序的一个写操作很大或者跨越了 chunk 的边界，GFS client 代码会将它转化为多个写操作。它们都会遵循上面的控制流程，但是可能会被来自其他 client 的操作插入或者覆盖。因此共享的文件区域可能会包含来自不同 client 的片段，虽然这些副本是一致的，因为所有的操作都按照相同的顺序在所有副本上执行成功了。但是文件区域会处在一种一致但是未定义的状态，正如 2.7 节描述的那样（一致，但是由于并发 client 获取不到全部的操作信息，所以是未定义的）。 Data Flow为了更高效的使用网络，我们将数据流从控制流中分离出来。控制流从 client 到达主副本，然后到达其他的所有次副本，而数据则是线性地通过一个仔细选择的 chunkserver 链像流水线那样推送过去的。我们的目标是充分利用每个机器的网络带宽，避免网络瓶颈和高延时链路，最小化数据推送的延时。 为了充分利用每个机器的网络带宽，数据通过 chunkserver 链线性的推送过去而不是以其他的拓扑结构进行分布比如树型。因此每个机器的带宽可以全部用来发送数据而不是为多个接受者进行切分。 为了尽可能的避免网络瓶颈和高延时链路，每个机器向网络中还没有收到该数据的最近的那个机器推送数据。我们网络拓扑足够简单，以至于距离可以通过 IP 地址估计出来。 最后为了最小化延时，我们通过将 TCP 数据传输进行流水化。一旦一个 chunkserver 收到数据，它就开始立即往下发送数据。流水线对我们来说尤其有用，因为我们使用了一个全双工链路的交换网络。立即发送数据并不会降低数据接受速率。如果没有网络拥塞，向 $R$ 个副本传输 $B$ 字节的数据理想的时间耗费是 $B/T+RL$ ,$T$ 代表网络吞吐率，$L$ 是机器间的网络延时。我们的网络连接是 100Mbps($T$),$L$ 远远低于 1ms，因此 1MB 的数据理想情况下需要 80ms 就可以完成。 Atomic Record AppendsGFS 提供一个原子性的 append 操作叫做 record append(注意这与传统的 append 操作也是不同的)。在传统的写操作中，用户指定数据需要写的便宜位置。对于相同区域的并行写操作是不可串行的：该区域的末尾可能包含来自多个 client 的数据片段。但在一个 record append 操作中，client 唯一需要说明的只有数据。GFS 会将它至少原子性地 append 到文件中一次，append 的位置是由 GFS 选定的，同时会将这个位置返回给 client。这很类似于 unix 文件打开模式中的 O_APPEND，当多个写者并发操作时不会产生竞争条件。 Record append 在我们的分布式应用中被大量的使用。很多在不同机器的 client 并发地向同一个文件 append。如果使用传统的写操作，client 将需要进行复杂而又昂贵的同步化操作，比如通过一个分布式锁管理器。在我们的工作负载中，这样的文件通常作为一个多生产者/单消费者队列或者用来保存来自多个不同 client 的归并结果。 Record append 是一种类型的变更操作，除了一点点在主副本上的额外逻辑，其余依然遵循 3.1 节的控制流。Client 将所有的数据推送给所有副本后（3.1 第 4 步），它向主副本发送请求。主副本检查将该记录 append 到该 chunk 是否会导致该 chunk 超过它的最大值(64MB)。如果超过了，它就将该 chunk 填充到最大值，告诉次副本（scondaries）也填充到最大值，然后告诉客户端该操作应该在下一个 chunk 上重试。(append 的 Record 大小需要控制在最大 trunk 大小的四分之一以内，这样可以保证最坏情况下的碎片可以保持在一个可以接受的水平上 )。如果记录可以没有超过最大尺寸，就按照普通情况处理，主副本将数据 append 到它的副本上，告诉次副本将数据写在相同的偏移位置上，最后向 client 返回成功应答。 如果 record append 在任何一个副本上失败，client 就会重试这个操作。这样，相同 chunk 的多个副本就可能包含不同的数据，这些数据可能包含了相同记录的整个或者部分的重复值。GFS 并不保证所有的副本在位级别上的一致性，它只保证数据作为一个原子单元最少写入一次。这个属性是由如下的简单观察推导出来的，当操作报告成功时，数据肯定被写入到某个 trunk 的所有副本的相同偏移位置上。此后，所有的副本至少达到了记录尾部的大小，因此未来的记录将会被放置在更高的便宜位置，或者是另一个不同的 chunk，即使另一个副本变成了主副本。在我们的一致性保证里，record append 操作成功后写下的数据区域是已定义的(肯定是一致的)，然而介于其间的数据则是不一致的(因此也是未定义的)。我们的应用程序可以处理这样的不一致区域，正如我们在 2.7.2 里讨论的那样（对于少见的重复/应用应为记录添加一些额外的信息来保证其合法性，不能容忍的幂等操作，可以通过使用唯一标识符过滤）。 Snapshot快照操作可以非常快速的保存文件或者目录树的一个拷贝，同时可以最小化对于正在执行的变更操作的中断。用户经常用它来创建大数据集的分支拷贝，以及拷贝的拷贝。或者用来创建检查点，以实验接下来的提交或者回滚。 像 AFS，我们使用标准的 copy-on-write 技术来实现快照。当 master 收到一个快照请求时，它首先撤销将要进行快照的那些文件对应的 chunk 的所有已发出的租约。这就使得对于这些 chunk 的后续写操作需要与 master 交互来得到租约持有者。这就首先给 master 一个机会创建该 chunk 的新的拷贝（强迫与 master 交互以使新的租约生成）。 当这些租约被撤销或者过期后，master 将这些操作以日志形式写入磁盘。然后复制该文件或者目录树的元数据，然后将这些日志记录应用到内存中的复制后的状态上，新创建的快照文件与源文件一样指向相同的 chunk。 当 client 在快照生效后第一次对一个 chunk C 进行写入时，它会发送请求给 master 找到当前租约拥有者。Master 注意到对于 chunk C 的引用计数大于 1。它延迟回复客户端的请求，选择一个新的 chunk handle C’然后让每个拥有 C 的那些 chunkserver 创建一个新的叫做 C’的 chunk。通过在相同的 chunkserver 上根据原始的 chunk 创建新 chunk，就保证了数据拷贝是本地地，而不是通过网络(我们的硬盘比 100Mbps 网络快大概三倍)。这样，对于任何 chunk 的请求处理都没有什么不同：master 为新才 chunk C’的副本中的一个授权租约，然后返回给 client，这样它就可以正常的写这个 chunk 了，client 不需要知道该 chunk 实际上是从一个现有的 chunk 创建出来的。 Master OperationMaster 执行所有的名字空间操作。此外，它还管理整个系统的 chunk replicas：决定如何放置，创建新的 chunk 和相应的副本，协调整个系统范围内的活动保证 chunk 都是完整备份的，在 chunkserver 间进行负载平衡，回收没有使用的存储空间。我们现在讨论这些主题。 Namespace Management and Locking很多 master 操作都需要花费很长时间：比如，一个快照操作要撤销该快照所包含的 chunk 的所有租约。我们并不想耽误其他运行中的 master 操作，因此我们允许多个操作同时是活动的，通过在名字空间区域使用锁来保证正确的串行化。 不像传统的文件系统，GFS 的目录并没有一种数据结构用来列出该目录下所有文件，而且也不支持文件或者目录别名（像 unix 的硬链接或者软连接那样）。GFS 在逻辑上将命名空间作为一个通过路径全称到元数据映射的查找表。通过采用前缀压缩，这个表可以有效地在内存中表示。名字空间树中的每个节点（要么是文件的绝对路径名称要么是目录的）具有一个相关联的读写锁。 每个 master 操作在它运行前，需要获得一个锁的集合。比如如果它想操作/d1/d2…/dn/leaf，那么它需要获得/d1,/d1/d2……/d1/d2…/dn 这些目录的读锁，然后才能得到路径/d1/d2…/dn/leaf 的读锁或者写锁。Leaf 可能是个文件或者目录，这取决于具体的操作。 我们现在解释一下，当为/home/user 创建快照/save/user 时，锁机制如何防止文件/home/user/foo 被创建。快照操作需要获得在/home /save 上的读锁，以及/home/user 和/save/user 上的写锁。文件创建需要获得在/home 和/home/user 上的读锁，以及在/home/user/foo 上的写锁。这两个操作将会被正确的串行化，因为它们试图获取在/home/user 上的相冲突的锁。文件创建并不需要父目录的写锁，因为实际上这里并没有”目录”或者说是类似于 inode 的数据结构，需要防止被修改。读锁已经足够用来防止父目录被删除。 （这种加锁机制的好处是对于同一个目录下，可以并行的操作文件，例如，同一个目录下并行的创建文件。快照会对新旧本层进行写加锁因而防止了对原始文件目录增加文件的操作产生的冲突。） 因为名字空间有很多节点，所以读写锁对象只有在需要时才会被分配，一旦不再使用用就删除。为了避免死锁，锁是按照一个一致的全序关系进行获取的：首先根据所处的名字空间树的级别，相同级别的则根据字典序。 Replica Placement如何安置 replicas 的目标是： 最大化数据可靠性和可用性 最大化网络带宽的利用 这里的最大化不仅仅是机器间的问题，还要考虑机架间的问题 在以下 3 种情况下，Master 会进行创建 replicas 的操作： 创建了新的 chunk 需要重新备份 负载均衡 如何选择将 replicas 放置到哪台机器上呢？ 优先选择磁盘利用率低的 chunkserver，使得较长时间将会平均化 chunkserver 的利用。 GFS 会限制每个 chunkserver『最近』创建的次数。换句话说，如果一个 chunkserver 近期创建 replicas 的操作比较频繁，就不会优先选择它（因为创建就意味着以后会进行读取，为了防止突然间大量的读取出现在同一台机器上） 保证可用性，尽可能跨机架（racks）进行创建操作 当可用的备份低于要求时（GFS 要求为 3 份），master 会对 chunk 进行重新备份，在以下情况有可能需要重新备份： chunkserver 不可用了 备份损坏了 硬盘挂掉了 所要求的最低备份数量提高了 当有多个 chunk 需要备份时，GFS 如何决定先备份哪个呢？策略如下： 优先选择可用备份少的（仅有一份备份的更加迫切） 优先备份最近没有 delete 文件的（for live files） 优先备份阻塞了 client 操作的（这样可以最小化对运行中应用的影响） 当 master 决定了备份哪个之后，会把当前可用的 chunk 直接克隆到目标位置（遵循 replicas 放置的类似规则：平均磁盘利用率、防止单一机器高 IO、跨机架）。 周期性的检查副本分布以求重平衡，副本的移动过程中是新建一个新的，放置规则和前述讨论一致。放置了新的必须删除旧的（通常情况下倾向删除自身空白空间低于平均水平的）。 Garbage Collection文件删除后，GFS 并不立即释放可用的物理存储（进行物理删除，而是等对应的垃圾清理进行到文件和 chunk 级别时再真正删除（Lazy）。 Mechanism具体地，对于一个文件的删除操作，GFS 仅仅是写一条日志记录，然后把文件命名成一个对外部不可见的名称，这个名称会包含删除的时间戳。GFS master 会定期的扫描，当这些文件存在超过 3 天（可设定）后，这些文件会从 namespace 中删掉，并且内存的中 metadata 会被删除，切断了和 chunk 的联系。 在对 chunk namespace 的定期扫描时，master 找到那些孤儿块(无法从任何文件到达)，擦除这些块的元数据。在与 chunkserver 的 heartbeat 的交互过程中，GFS master 会把不在 metadata 中的 chunk 告诉 chunkserver，然后 chunkserver 对照后就可以删除这些 chunk 了。 Discussionmaster 在内存中储存那个查找表（前缀压缩过的），保存了所有文件-chunck 映射，因而很容易找到 chunck 的引用。chunck 只不过是放在特定目录下的 linux 文件，master 不知道的副本就是 garbage。 采用这种方式删除的好处： 利用心跳方式交互，在一次删除失败后，还可以通过下次心跳继续重试操作 删除操作和其他的全局扫描 metadata 的操作可以放到一起做为删除这种不可逆转操作提供了一定弹性恢复的保护网。坏处： 有可能有的应用需要频繁的创建和删除文件，这种延期删除方式会导致磁盘使用率偏高，GFS 提供的解决方案是，对一个文件调用删除操作两次，GFS 会马上做物理删除操作，释放空间。同时允许用户在不同名字空间内使用不同的重备份和回收策略（不执行副本和直接物理删除）]]></content>
      <categories>
        <category>操作系统</category>
        <category>分布式系统</category>
      </categories>
      <tags>
        <tag>论文</tag>
        <tag>操作系统</tag>
        <tag>分布式系统</tag>
        <tag>GFS</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[分布式系统学习——MapReduce方法Paper翻译]]></title>
    <url>%2Fpost%2Fcbabc18d.html</url>
    <content type="text"><![CDATA[读书笔记——MapReduce: Simplified Data Processing on Large Clusters大型集群上的简化处理：MapReduce（两个主要操作） 原始翻译版本网址：《MapReduce: Simplified Data Processing on Large Cluster 》翻译 AbstractMapReduce 是一种编程模型和一种用来处理和产生大数据集的相关实现。用户定义 map 函数（map function）来处理 key/value 键值对来产生一系列的中间的 key/value 键值对。还要定义一个 reduce 函数(reduce function)用来合并有着相同中间 key 值的中间 value。许多现实世界中的任务都可以用这种模型来表达，就像下文所展示的那样。 用这个风格（函数式）编写的程序可以自动并行地在大规模集群上工作。运行时系统会自动处理例如切割输入数据，在机器之间调度程序的执行，处理机器故障以及管理必要的机器间通信等细节问题。这可以让那些对于并行分布式系统没有任何经验的程序员也能很简单地利用起一个大的分布式系统的资源。 我们的 MapReduce 的实现运行在一个由大的商业机构成的集群当中并且是高度可扩展的：一个典型的 MapReduce 计算要在上千台机器中处理 TB 数量级的数据。程序员会觉得这个系统非常好用：已经有成千上万的 MapReduce 程序被实现出来并且每天有上千个 MapReduce 任务运行在 Google 的集群上。 Introduction在过去五年中，作者和许多 Google 的其他人已经实现了成百上千个用于特殊目的的计算程序用于处理大量的 raw data（如抓取文件，Web 请求日志等），用于计算产生各种各样的 derived data（如倒排索引、Web 文件结构的图片展示、每个 host 抓取的文件数量总结、指定日期最频繁的访问请求等）。许多这种计算程序在概念上都是非常直接的。然而输入的数据量往往很大，并且计算需要分布在成百上千台机器中为了在一个可接受的时间内完成任务。但是除了简单的计算模型以外，我们需要大量复杂的代码用来处理例如如何并行化计算、分发数据、处理故障等等问题。 为了解决这样的复杂性，我们设计了一种新的抽象，它让我们只需要表示出我们想要执行的计算模型，而将背后复杂的并行化，容错，数据分发，负载平衡等等技术的实现细节隐藏在了库中。我们这种新的抽象是受 Lisp 以及其他一些函数式编程语言中的 map 和 reduce 原语影响而来的。我们意识到为了计算出一系列的中间键值对，许多的计算都需要对于输入中的每个逻辑“记录”进行 map 操作。然后还需要对所有共享同一个 key 的 value 进行 reduce 操作，从而能够对派生的数据进行适当的组合。我们这种让用户自定义 map 和 reduce 操作的编程模型能够让我们简单地对大量数据实现并行化，并且使用重新执行（re-execution）作为主要的容错机制。 我们这项工作的主要共享是提供了一个简单并且强大的接口能够让我们实现自动的并行化并且分布处理大规模的计算，同时该接口的实现能在大型的商用 PC 集群上获得非常高的性能。 Section 2 描述了基本的编程模型以及一些简单的例子。Section 3 描述了为我们的基于集群的计算环境量身定做的 MapReduce 接口。Section 4 描述了一些我们认为有用的对于编程模型的改进。Section 5 是对我们的实现在不同任务下的性能测试。Section 6 包含了 MapReduce 在 Google 内的使用情况，包括我们以它为基础重写我们的产品索引系统的经验。Section 7 讨论了相关的工作以及未来的发展。 Programming Model计算模型以一系列的键值对作为输入并产生一系列的键值对作为输出。MapReduce 库的用户以“Map”和”Reduce”两个函数来表达计算。 Map，是由用户编写的，取一个输入对，并且产生一系列中间的键值对。MapReduce 库将那些具有相同的中间键$I$的中间值聚集在一起，然后将它们传递给 Reduce 函数。 Reduce，同样是由用户编写的，接收一个中间键$I$和该键对应的一系列的中间值。Reduce 函数通过将这些值合并来组成一个可能更小的集合（值的集合）。通常每个 Reduce 函数只产生 0 个或 1 个输出值。Reduce 函数一般通过一个迭代器（via an iterator）来获取中间值，从而在中间值的数目远远大于内存容量时，我们也能够处理。 Example下面来考虑这样一个问题：统计大量文档中每一个单词出现的次数。对此，用户需要编写类似于如下的伪代码： 12345678910111213 map(String key, String value): // key: document name // value: document contents for each word w in value: EmitIntermediate(w, &quot;1&quot;); reduce(String key, Iterator values): // key: a word // values: a list of counts int result = 0; for each v in values: result += ParseInt(v); Emit(AsString(result)); Map 函数为在每一个单词出现的时候，为它加上一个计数（在这个简单的例子中就是加 1）。Reduce 函数对每个单词（作为中间键值对的键）的所有计数进行叠加。 另外，用户需要用输入输出文件的名字，以及一个可选的 tuning paramete 去 fill in 一个叫 mapreduce specification 的对象。之后，用户调用 MapReduce 函数，将上述定义的对象传递进去。用户的代码将和 MapReduce 库相连（由 C++实现）。Appendix A 中有这个例子所有的代码文档。 12map (k1,v1) -&gt; list(k2,v2)reduce (k2,list(v2)) -&gt; list(v2) 需要注意的是，输入的 key 和 value 与输出的 key 和 value 是不同的类型，而中间的 key 和 value 与输出的 key 和 value 是相同的类型（用 k1 和 k2 表示）。我们的 C++实现都是以字符串的形式和用户代码进行交互的，至于将字符串类型转换成相应合适的类型的工作则由用户代码来完成了。 More Example接下来是一些能够简单地用 MapReduce 计算模型进行表达的例子 Distributed Grep（分布式查找）：Map 函数获取匹配提供的模式的行，Reduce 函数只是简单地将这些中间数据拷贝到输出。 Count of URL Access Frequency（计算 URL 访问频率）：Map 函数处理 web 请求的日志，并且输出。Reduce 函数将拥有相同 URL 的 value 相加，得到对 Reverse Web-Link Graph：Map 函数输出对，其中 source 所在的 page 都有连向 target 这个 URL 的链接。Reduce 函数将给定 target 的所有的 source URL 连接起来，输出对 Term-Vector per Host：一个 term vector 表示一系列的键值对，word 表示一篇或者一系列文章中出现的比较重要的单词，frequency 表示它们出现的次数。Map 函数对于每篇输入的文章输出键值对（其中 hostname 是从文章所在的 URL 中抽取出来的）Reduce 函数获取给定 host 的 term vectors。它将这些 term vectors 累加起来，丢弃非频繁出现的 term，并产生一个最终的对。 Inverted Index：Map 函数对每篇文章进行处理，并输出一系列的对。Reduce 函数接收给定 word 的所有键值对，对相应的 document ID 进行排序并且输出]]></content>
      <categories>
        <category>操作系统</category>
        <category>分布式系统</category>
      </categories>
      <tags>
        <tag>论文</tag>
        <tag>操作系统</tag>
        <tag>分布式系统</tag>
        <tag>MapReduce</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[分布式系统学习——状态机容错模型Paper翻译]]></title>
    <url>%2Fpost%2F86b562df.html</url>
    <content type="text"><![CDATA[学习笔记参考： 分布式系统基础-State Machine 读书笔记——Implementing Fault-Tolerant Services Using the State Machine Approach: A Tutorial利用状态机实现容错服务的一个教程 摘要部分状态机方法是在分布式系统中实现容错服务的一般方法。 本文回顾了该方法并描述了两种不同故障模型的协议 - 拜占庭和故障停止。 还讨论了用于移除故障组件和集成修复组件的系统重新配置技术。 Introduction分布式软件常由客户端（clients）和服务端（services）构成。 集中式的服务端虽然是最简单的架构方式，但也导致了其容错性只能与执行该服务的处理器相同，换言之，依旧是单机的容错性能。 如果这样级别的容错不可接受，那就应该在分布系统的独立容错的不同处理器上运行原始服务的副本，协议用于这些副本的交互。分布式系统的物理电气隔离确保了故障的独立性。 The state machine approcah is a general method for implementing a fault-tolerant service by replicating servers and coordinating client interactions with sever replicas. 状态机方法是同过复制服务器（设置代理/备份）并协调客户端与服务器代理交互的一种实现容错服务的通用方法。 该方法还为理解和设计（服务器 replica）管理协议提供了一个框架。许多涉及数据或软件复制的协议——无论是为了掩盖故障，还是为了在没有集中控制的情况下促进交互——都可以使用状态机方法派生出来。尽管实际上很少有协议是以这种方式获得的，但是从状态机的角度观察它们有助于理解它们是如何以及为什么工作的。 本文是状态机方法的一个教程，描述了两种典型环境下的方法和实现。 State Machine状态机由状态变量（编码描述状态），状态转移指令（描述状态变化）。每一条指令由确定性程序构成。命令的执行是原子的。一段客户端的请求可以看作是指定对应的状态机实施指定的 command（同时包含该 command 要求的全部信息） 请求的输出可以看作是一个 actuator（在程序控制系统中），或是其他的外围设备，或是等待先前请求响应的客户机（可以看作是编译原理中自动机理论的语义分析）。 请求由状态机每次执行一条，并且与潜在的因果关系一直。因此，状态机的客户端可以对要处理的请求的顺序做以下假设。 O1. 单个客户对给定的状态机 sm 发送的请求将被按照发送的顺序执行。 O2. 如果客户机 c 向状态机 sm 发出请求 r 可能导致客户机 c’向 sm 发出请求 r’，那么 sm 在 r’之前处理 r。 考虑到通信网络的延迟，尤其是在分布式网络中（可以联系上一篇论文），O1 和 O2 并不意味着状态机会根据制定/接收到的请求指令执行。 状态机的语义表征：状态机的输出完全由它处理的请求序列决定 Anything that can be structured in terms of proce- dures and procedure calls can also be structured using state machines and clients. a state machine implements the procedure requests implement the procedure calls. 事实上，状态机在系统结构上比过程调用通常提供的灵活性更大。使用状态机，在处理请求之前不会延迟发出请求的客户机，并且可以将请求的输出发送到发出请求的客户机之外的其他地方。我们没有理由怀疑根据状态机客户端构建的应用会更加简洁。 Fault Tolerance两种典型的错误行为 Byzantine Failures（拜占庭故障）： 该组件可能表现出任意和恶意的行为，可能涉及与其他故障组件的勾结 Fail-stop Failures. （异常终止错误） 允许其他组件检测到错误并停止。 t fault tollerant：指系统在一定范围的活动中最多不超过 t 个组件发生故障，传统的 MTBF（平均故障间隔时间）和其他的统计的故障评定方法固然有其可取之处，但是，去测定系统的最大容载故障组建个数潜意识中要求了系统具备一定的修正能力（当出现故障组件个数超出/即将超出限额时的补救措施）。 Fault-tolerance state machine步入正题，容错状态机。 由于备份（副本）运行在分布式系统的不同处理器上，在假定每个错误最多影响一个处理器，而在不出错的情况下，相同初始状态的状态机经相同的输入（request 序列）应该抵达相同状态并输出相同内容，那么结合该系统状态机副本的输出，得到容错状态机的输出。 若考虑满足最坏情况下，出现拜占庭故障，正常运行的组件仍占据大多数，要求一个 t fault-tollerant 状态机应之少包含 2t+1 个组件。 而如果考虑故障停止情况下，那么只要满足还有一个 non-fautlty 组件具备正常输出能力即可，所以应至少包含 t+1 个组件。 实现上述容错状态机的关键在于备份（副本）的协调（Replica Coordination）：所有备份（副本）都可以接收到且接收到顺序相同的请求序列。 拆分成两个子要求： Agreement：每个非故障状态机都会接收到每个请求。 Order：每个非故障状态机都会以相同的顺序处理这些请求。 Order 保证的是相对顺序（局部序）。 在某些情况下条件可以放宽，比如，如果我们假设只会发生 Fail-Stop Failure,并且只会收到读请求，那么 Agreement 可以被弱化成只要一台（而非每台）正常运行的状态机收到这个读请求就好啦．很容易理解。另外对于通信请求，若处理不同的请求 r 和 r’时，r-&gt;r’和 r’-&gt;r 的终状态和输出序列相同的话。文章举了一个投票的自动机例子，如果候选者每个人投票数最大为 1，且阈值（MAJ）的两倍要大于总值（Cno），换句话说，至多只有一人会被投出，那么无论怎样交换请求（投票顺序），自动机的输出和最终输出必然是相同的。但若允许每个人投票多次，或是阈值不满足上述要求，则交换请求会影响到自动机的输出和终状态。 Agreement我们可以通过引入一个新的组件，称为 transmitter，它负责向其他的组件发送一个值，只要满足以下条件，那么就能满足 Aggrement: IC1: All nonfaulty processors agree on the same value. 全部的正常运行的 processors 同意同一个值 IC2: If the transmitter is nonfaulty, then all nonfaulty processors use its value as the one on which they agree. 如果 transmitter 正常运行，那么其他的正常运行的 processors 均使用它的值作为它们同意的那个值 这种协议已经引起了学术界的关注．目前也已经有相应的协议产生了。我们可以将 client 作为 transmitter,也可以单独设置这样一个组件．但是如果单独设置这样一个组件的话，我们需要确保请求在发送到 trasmitter 的过程中，丢失或者被篡改．我们可以通过让 client 也接收 transmitter 发送的请求，来避免这种情况。难点是应对在执行过程中出错的处理器。 Order and Stability顺序要求可以通过为请求赋唯一标识符值来实现，且对于稳定的请求，将最小值传递给后面的状态机副本。（个人对稳定的理解：具备相对优先顺序、不会改变、可被执行） 要点：identifiers 的指定方法和“稳定”测试。 另外需要注意的是，identifiers 的分配还需要符合 Sec.1 里 O1 和 O2，这就要求祖先请求的 identifiers 值要更小，即若$r_j$是由于$r_i$而产生的，则$uid(r_i)&lt; uid(r_j)$。 文章介绍了三种方法 Using Logical Clocks利用上一篇文章所介绍的逻辑时钟，即给偏序请求集根据两条规则。 C1. 如果 a 和 b 是同一进程的两个事件且 a 发生在 b 之前，则$C_i \langle a \rangle &lt; C_i \langle b \rangle$。 C2. 如果 a 是 i 进程消息发送方，而 b 是 j 进程中该消息的接收方，则$C_i \langle a \rangle &lt; C_j \langle b \rangle$。 Condition）。 设计算法来为上述构建的时钟函数赋值，为满足 C1 和 C2，分别设定两条规则： IR1. 同一个 process 的相邻 event，其时钟值是递增的。 IR2. i 进程 a 活动发送的消息会携带一个时间戳$T_m = C_i \langle a \rangle$，则接收方 b 进程活动 b 设定其时钟值为$C_j \langle b \rangle = MAX(T_m,C_j \langle b \rangle)+1$。 C 值即我们希望得到的 identifier 值，接下来文章用来描述检查 stable 的方法，通过对处理器之间传递的消息附加序列号而已实现一些 communication channels： FIFO Channels. 一对处理器间的消息接收顺序即发送顺序。 而对于出现故障停止的处理器，我们也可以假定下列情况的存在。 Failure Detection Assumption. 一个处理器 p 可以检测到另一个处理器 q 发生故障仅能够在其收到最后一条 q 发给 p 的消息后。 两个假设是一致的，在该假设下，可以构建如下的检测方法： Logical Clock Stability Test Toleranting Fail-stop Failures. A request is stable at replica $sm_i$ if a request with larger timestamp has been received by $sm_i$ from every client running on a nonfaulty processor.当所有处理器（无论 faulty 还是 nonfaulty）都以更晚的时间戳发送给该状态机副本一条请求时，先前的请求就是稳定的。 接下来文章分类讨论解释了为什么上述成立，nonfaulty 的处理机一旦发送了更大的，由于递增性，下次发送的时间戳值会更大，而根据 FIFO 原则，receive order 和 deliver order 相同，也符合递增性。而对于认定为出错的处理机，根据 Failure Detection Assumption 原则，我们可以确定是在收到了最后一条消息后，所以之后也不会再收到故障处理器的消息，综上，测试条件成立。 Synchronized Real-Time Clocks第二种构建满足 O1 和 O2 条件的 identifiers 值得方法是应用近似同步的实时时钟。 定义$T_p(e)$为事件 e 发生时 p 处理器的实时时钟值。我们通过向$T_p(e)$尾部后缀一端定长二进制串来唯一标定“p 处理器上的客户机进行了事件 e”这一信息。 那么为了满足 O1 和 O2 条件做以下规定。 Satisfied O1. 在有效的时钟精度（clock ticks/resolution）中一个处理器不会进行多于一次的请求。 Satisfied O2. 时钟同步应优于最小消息传递时间。 满足规定后，可以有以下的检测方法。设定$\Delta$为消息发出后确保每一个正常处理器收到消息时间不晚于$uid(r) + \Delta$的阈值，这样的$\Delta$是一定存在的。 Real-Time Clock Stability Test Tolerating Byzantine Failures 1. A request $r$ is stable at a state machine replica $sm_i$ being executed by processor $p$ if the local clock at $p$ reads $\tau$ and $uid(r) &lt; \tau - \Delta$]]></content>
      <categories>
        <category>操作系统</category>
        <category>分布式系统</category>
      </categories>
      <tags>
        <tag>论文</tag>
        <tag>操作系统</tag>
        <tag>分布式系统</tag>
        <tag>状态机</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[分布式系统学习——分布式系统中的时间、时钟和事件顺序经典论文Paper翻译]]></title>
    <url>%2Fpost%2Fb6a38e07.html</url>
    <content type="text"><![CDATA[阅读笔记参考：小强zju的读书笔记 分布式系统基础－Lamport Clock Lamport本人评述 读书笔记——Time, Clocks, and the Ordering of Events in a Distributed System摘要部分本文研究了分布式系统中一个事件先于另一个事件发生的概念，并展示了如何定义事件的偏序，同时给出了一种可以对时间完全排序的分布式时钟同步算法。通过一种解决同步问题的方法来描述对全体事件的同步。 然后介绍专门用于同步物理时钟的情况，并推导出时钟不同步的界限。 Introduction时间概念是我们思维方式的基础，更基本的源于事件发生顺序，其贯穿我们对系统（system）的思考。然而在分布式系统中我们应重新审视这一基本概念。 A system is distributed if the message transmission delay is not negligible compared to the time between events in a single process. 如果与单个进程中的事件之间的时间相比，消息传输延迟不可忽略，那么该系统就是分布式的。（无论是在单机系统还是多机系统上，上述情况都要考虑） 本文重点关注空间分离的系统，但是单机多处理器系统涉及一些相类似的问题，因为某些事件可能以不可预测的顺序发生。“之前发生”只是系统中事件的部分排序。（事实上整体事件呈现一个偏序集合 No happen before）。 The Partial Ordering We will therefore define the “happened before” relation without using physical clocks. 我们将不依赖物理时钟定义“happen before”规则。 因应用的不同，我们可以将一个子程序（或是一条机器指令的执行）当作某个process里的一个event。 我们假定某个process的所有events构成一个序列，这个序列是线序（或许应该说不包含相等的情况），用文中的话说是具有先验总排序。我们根据process中event的发生顺序定义“happen before” 定义“happen before”关系，用（→表示） 如果a，b是相同进程的两个事件，且a出现在b之前，那么$a \rightarrow b$。 如果a是某进程消息发送的一方，b是另一进程接收该消息的一方，则$a \rightarrow b$。 该关系具备传递性，即$a \rightarrow b$ ，$b \rightarrow c$，则$a \rightarrow c$。如果$a \nrightarrow b$，$b \nrightarrow a$，那我们称a，b是并发（concurrent）的。 另外补充，该关系是反自反的，即，对任意a，$a \nrightarrow a$，（系统中一个时间可以在它自身之前发生没有实际意义）。 在图中$a \rightarrow b$即表示可以从a通过波浪线（消息传播途径），或者纵向的进程轴线（事件发生途径）走到b。 另一种方式解读该图像，我们也可以说，并发的进程是不会不经意间相互影响的。 Happened Before的理论和狭义相对论中的物理世界中的观念十分的类似，即event的先后是相对的，在实际世界中的不同惯性坐标系下，2个event的先后关系可能发生变化。不过Paper中没有深入的对比，我会在感想部分中深入讨论下 Logical Clocks现在考虑引入时钟，先以数学的方式为每个事件分配一个数字来代表其事件发生的时间。以时钟函数$C_i$表示$P_i$进程，其中$C_i \langle a \rangle$表示该进程a事件的值。$C$ 函数表示整个系统的时钟，如果b是进程$P_i$的事件之一，则$C \langle b \rangle = C_i \langle b \rangle$。 由于当前没有将函数值和物理事件关联起来，所以我们将其认为是逻辑时间。 考虑该逻辑时钟的合理性，我们无法根据物理时间验证（这会要求基于物理时间的时钟引入），考虑一个强合理性的条件，如果事件a发生在另一个事件b之前，则a应该在比b更早的时间发生。 我们更正式地陈述这种情况如下。 Clock Condition For any events a, b:if $a \rightarrow b$ then $C \langle a \rangle &lt; C \langle b \rangle$ 其逆命题不成立（否则会要求所有并发事件同时发生，易证否），即只具备充分性。 满足下面两条件时，时钟条件（Clock Condition）是满足的。 C1. 如果a和b是同一进程的两个事件且a发生在b之前，则$C_i \langle a \rangle &lt; C_i \langle b \rangle$。 C2. 如果a是i进程消息发送方，而b是j进程中该消息的接收方，则$C_i \langle a \rangle &lt; C_j \langle b \rangle$。 Condition）。 通过算法来为上述构建的时钟函数赋值，为满足C1和C2，分别设定两条规则： IR1. 同一个process的相邻event，其时钟值是递增的。 IR2. i进程a活动发送的消息会携带一个时间戳$T_m = C_i \langle a \rangle$，则接收方b进程活动b设定其时钟值为$C_j \langle b \rangle = MAX(T_m,C_j \langle b \rangle)+1$。 两条分别对应两条规则，所以时钟条件也得到满足，保证了具备逻辑时钟的合理系统。 Ordering the Events Totally在规定进程间一个顺序后，通过以下规则，我们从事件的偏序构建全序，我们便可得到新的“全序关系”（用$\Rightarrow$）来表示： 若对于a，b两事件，有$C_i \langle a \rangle &lt; C_j \langle b \rangle$，则$a \Rightarrow b$ 若$C_i \langle a \rangle = C_j \langle b \rangle$ 且 $P_i &lt; P_j$，则$a \Rightarrow b$ 可以说“$\Rightarrow$”是将“happen before”偏序关系“$\rightarrow$”拓展成的全序关系。 该全序依赖与系统时钟的确定，是不唯一的，相反，唯一确定的是事件发生的偏序关系。 对事件进行全排序的有用性将通过解决下列情况下的互斥问题来说明，考虑一个共享单个资源的固定过程集合的系统： Q1. 已被授予资源的进程必须先释放它，然后才能将其授予另一个进程。Q2. 必须按照它们的顺序授予对资源的不同请求。Q3. 如果授予资源的每个进程最终都会释放该资源，那么每一个请求都后被授权。 通过一个中心化的进程通过请求抵达的时刻来安排资源是不可行的（后抵达该进程的消息可能先需求了资源）。 为了解决该问题，我们实行一个满足了IR1和IR2的系统，并且通过其定义出所有事件的全序，具备全局序后，问题就变得相当简单了，只需要确保每个进程清楚其他进程得操作即可。 分布式算法细节每个进程维护自己的请求队列，规定请求队列初始包含单一的消息$T_0$：$P_0$请求资源，其中$P_0$是初始占据资源的进程（根据假设，所有资源初始归同一进程占据），且$T_0$小于任何时钟的初始值。 该算法由以下五条规则定义。为了方便起见，假定每个规则定义的操作构成一个单一事件。 为了请求资源，请求方进程$P_i$将消息“$T_m$：$P_i$请求资源”递送至所有其他进程，并把该消息加入自己的请求队列。$T_m$表示该消息的时间戳。 当$P_j$收到消息“$T_m$：$P_i$请求资源”，将其加入自己的请求队列并向$P_i$发送一个带时间戳的确认消息。 为了释放资源，进程$P_i$将所有“$T_m$：$P_i$请求资源”消息移出队列，并把一个带时间戳的释放消息递送给所有其他进程。 当$P_j$收到消息“$P_i$释放资源”，将所有“$T_m$：$P_i$请求资源”消息移出队列。 当满足下列两条件时，进程$P_i$占据该资源： 存在一个“$T_m$：$P_i$请求资源”消息在其请求队列中并且序优先于其他的所有请求。 $P_i$收到了所有其他进程发来的时间戳晚于$T_m$的消息。 易于说明该算法满足该系统的三个要求。 这是一个分布式算法，每个进程独立遵循这些规则，没有集中的同步进程或是中央存储。 根据算法1-&gt;5构建可以证明Q1，Q2，Q3是满足要求的。 对于Q1，反证法： 假设Q1不成立，则意味着在资源分配给某进程后，假设该进程为$P_j$，存在至少一个进程，假设为$P_i$，未释放该资源。但是根据3、4点，这意味着，$P_i$没有发出“释放”的消息，也就应导致着进程$P_j$维护的队列中，仍存在“$T_{m_1}$：$P_i$请求资源”这一消息并未移出（第四点），且$T_{m_1}$是最早的。现在我们审查第五点，上述未删除的消息存在队列，便不会使“$T_{m_2}$：$P_j$请求资源”这条满足最先（5.1点），那$P_j$维护队列中不满足其占有资源的条件，矛盾。 对于Q2，时间戳是一个全序，由于5.2点要求收到所有其他进程法来的更晚的消息，所以可以保证先前消息是完全的，可以确定是最早的，根据全序顺序，可保证。 对于Q3，反证法： 假设在均释放的情况下，存在至少一个请求没有被授权（批准），不妨设最早的是$P_j$的请求，则在其自身队列以及所有其他进程队列中都应在某一时间后都存在着这样一条“$T_{m_2}$：$P_j$请求资源”，由于始终未被授权，假设5.1不被满足，则应存在“$T_{m_1}$：$P_i$请求资源”始终存在，且$T_{m_1}&lt;T_{m_2}$但是我们设定$P_j$是最早的不被授权的，所以前者必定在某个时间释放，$P_i$请求资源的记录会随释放消息的到达被撤，不可能始终存在，不成立。若5.2始终不能被满足，在5.1成立后，由于没有fail的机器，必然会收到确认消息，不成立。所以5.1，5.2总会在一定时间后被满足，矛盾。 Anomalous Behavior异常情况，上面定义的Logical Clocks有一些反常的行为，例如我们定义的Total Ordering是$b&lt;a$，但事实上a事件的操作员执行之后通过电话告诉b事件的操作员开始执行，那么Logical Clocks给出的全序就明显违背了客观情况。 这种情况的出现是由于系统不知道“电联”这一要求，因为这种先后顺序是在系统外定义的。为避免这种反常，有2中解法： 将外部的happened before关系手动的引入到系统内（event b产生是强调依赖 event a） 引入实际物理时钟 Physical Clocks对物理始终两条限制， 实际上时限制增速尽可能贴近1，以及各时钟的同步性。 后面保证物理时钟一致性以及满足C1，C2的算法暂时没有看懂，所以后面再补吧，数学功底差一些。]]></content>
      <categories>
        <category>操作系统</category>
        <category>分布式系统</category>
      </categories>
      <tags>
        <tag>论文</tag>
        <tag>操作系统</tag>
        <tag>分布式系统</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[TOFEL写作]]></title>
    <url>%2Fpost%2F3d51fca5.html</url>
    <content type="text"><![CDATA[ExerciseConfronting some parents assertion that the elder children in the family should take care of the younger, while others hold the view that all the children should be treated equatily, regardless of the age. Problem: 意思发生改变 题目改写方法背景句观点句I reckon/assure/advocate/argue/contend that I assert the statement that From my perspective in my viewFrom where I stand,As far as I am concerned, 让步+转折Although 独立写作思路理由篇四大题型分类：利弊题、事实题、今昔对比、特殊词。 事实题和利弊题四六开（新手重点解决利弊题）。 利弊题主题句写法小 Trick：题目中所有的对象都可以分析利弊（老小孩、小小孩、大人）。 利弊题常用解法，万能理由：针对个人。 万能理由 英文表达 笔记（备注） 省钱（性价比高） save money/cost-effective Especially for the poor（极限论证） 省时间（便捷） save time/convenient portable 有效率 Improve efficiency/efficient study/work/ 安全（身心健康） safe/physical/mental health 安全类词汇：&lt;/br&gt;safe safety（个人安全） &lt;/br&gt;secure security（社会安全、安保）&lt;/br&gt;unexpended accidents(potential risks)（不可预知的风险）&lt;/br&gt;Tsunami（海啸）、tornado（龙卷风）、storm（风暴）&lt;/br&gt;健康类词汇（physical）：&lt;/br&gt;short-sight、lack of exercise、overweight、obesity、diabete、heart attack、influence/strengthen the immune system/ protect sb from infectious disease:flu build muscle/ chese muscle&lt;/br&gt;健康类词汇（mental）：&lt;/br&gt;干正事：(release/relieve/reduce) strsss/pressure/burden -&gt; mentail illness: depression&amp; anxiety&amp;insominia（失眠）-&gt; commit suicide （就自杀） : e.g. the hight suicide rate in Japan &lt;/br&gt; 不干正事： mass media -&gt; violent and pornographic information -&gt; mimick the bad behavior -&gt; go astray/ misguided 发掘兴趣爱好 discover one’s interest 扩展知识 broaden one’s horizons /expand one’s knowledge 交朋友（团队精神） make friends(cooperative/collaborative,teamwork spirits) 培养能力 improve skills and develop abilities acdemic（学术能力）&lt;/br&gt; practical skill（实践能力）&lt;/br&gt; step on the royal road of academics/ part-time/internship/voluntary activities/ time-management（时间管理能力） 增进家人感情 strengthen/reinforce family/relationship/ties/bonds 成就感（自我实现） obtain a sense of accomplishment/achievement(self-fulfillment)]]></content>
      <categories>
        <category>英语</category>
        <category>TOFEL</category>
      </categories>
      <tags>
        <tag>英语</tag>
        <tag>TOFEL</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[细数我去过的那些博物馆（院）]]></title>
    <url>%2Fpost%2F2810df46.html</url>
    <content type="text"><![CDATA[前言出了广东省博物馆的大门，感觉自己跑编了大半个中国的省级及以上的博物馆（博物院），随手发了个朋友圈，感慨之余，朋友圈下面的评论倒是提醒我，为何不给造访过的这些博物馆排个位序，比较一下其间的不同？我觉得颇有道理。今天由于出行方式的选择失误导致了我错过了最后一班去往深圳的高铁，目前返回广州东站搭乘城际列车，不过事情总有好的一面，我便多了几十分钟写这篇文章的时间。虽然一拖再拖，不过总算是写了大半部分。 接下来的部分，我将自己对各个博物馆印象最深刻的地方作为章节标题来逐个介绍他们，整篇文章完整阅读约耗费 8 分钟时间，若您无暇完整阅读，想留一个初步印象作为接下来规划旅行的“扫盲贴”的话，那我建议您花 1-2 分钟阅读以下各节标题。 我对各博物馆（院）的评价主要参考（但不限于）以下几个方面： 馆藏文物丰富程度 考古科研贡献程度 展示文物丰富程度 馆内安保情况以及展示文物保护措施 配套讲解以及辅助文字说明 博物馆布局以及展示的相关性 最推介——陕西历史博物馆 前述 如果让我从参观的众多博物馆中挑出一个 The Best One 的话，我个人觉得，陕历博当之无愧。我本人一直信奉将已拥有的全部发挥出来便是 The Best，博物馆（院）中，陕历博即是如此。 我是高三毕业的暑假参加西安交大自招的时候顺路参观的陕西历史博物馆，虽然那时距离写这篇文章已经有一段时间了，但我后续造访的很多博物馆（院）在许多方面依旧稍逊（甚至远逊于）当时的陕历博。如果您之前从未造访过任何一个博物馆（院），抑或是您想从新从头开启自己的“博物馆神奇之旅”，那我一定要推荐您去陕西西安看看。一个陕历博，是将半部中国古代史，毫无保留地铺开展现在你眼前。 陕历博位于陕西省西安市雁塔区，大雁塔西北侧，除去节假日里外里两圈等候参观的长队，其实看外观也颇具历史范，地铁抵达也比较方便。 推介理由 藏品数量质量及连贯性最佳，文字讲解我见过得博物馆中最为详尽，有语音导览配套，但不依赖（个别博物馆语音导览做过头了，文字少的可怜）。展厅装潢切合历史（石器的灰黄，秦朝的黑，特别是汉朝的赤红），国宝级文物丰富且配有重点介绍（兵符和独孤信的煤精印我至今还能清晰的回忆起来）。大唐遗宝的发觉过程也可以让参观者详尽的了解到国宝的发掘过程。 周边景点 大雁塔（大慈恩寺）、秦始皇陵地宫展览馆、秦始皇兵马俑博物馆（不知道玉甲那个分馆开了没有）。 其他 南方的同学可能吃不太习惯北方的面食，可以的话我还是非常推介羊肉泡馍+各式各样的肉夹馍的，PS 羊肉泡馍不要晚上吃。 最恢宏——北京故宫博物院 前述 作为一个河北人，我这个从小学就被拉去看天安门升旗仪式的娃，比其他省份抵达首都有着交通上的便利，三次参观北京故宫博物院，怎么说，故宫应该是我印象中展出/馆藏占比最小的一个博物院，但单单这展出部分，或许就已经足够体现中国古代后期封建王朝的历史了。 大众游客初访博物院一般走的是午门——神武门线路，节假日游客很多，而且需要提醒的是该线路以在外参观建筑为主，露天而且是没有树木给你遮挡烈日的（为何如此大家可以自己做做攻略）。PS 野导游经常会给你讲野史，关于故宫线路的网上讲解以及官方讲解都还不错，起码不是野史，或者说不带着奇怪民间迷信。 推介理由 理由这个有点难写，谈起博物馆（院）不谈故宫不谈紫禁城是很难的，这座独一无二的皇家园林建筑群本身就是一个无价的文物，首批五 A 级景区，内涵之丰富我想应该是我等不能想象的。但这客观上也造成了我们多是仰视高高在上的故宫，想要探寻其内在的种种则需要我们花费更多的精力和时间。此外，故宫在文物保护，流失文物找回，文物修缮（《我在故宫修文物》）等方面做出的巨大努力也让这里除去文物本身观赏价值外，更有些其他方面的韵味。据闻西区东区也在逐步开放了，我想讲解服务方面北京故宫也会继续走在路上。 周边景点 八达岭长城可以去看一下，不推荐鸟巢水立方（除非你想打卡照片）。可以再去一下天坛和中国国家博物馆（这个我没去过，惭愧）。 其他 游北京，千万别跟团，团体游水有些深，现在网络也发达了，自由行不仅可以自己把握时间，而且防止被骗被宰，京油子这个名字可不是没道理（抱歉，我真的没有贬义）。 最内涵——上海博物馆 前述 上海博物馆新馆与 96 年建成，馆址在人民广场附近，交通很便利。印象中东北部还有上海城市规划馆和一个小的商圈。我讲上海博物馆内涵是因为从外观上，尽管周围是公园平地，但是整体看上海博物馆并不是很大（或许仅仅是错觉，上博陈列面积约 12000 平方米，已经不小了），从正门进入以后也是以四方形正厅构造，略窄的楼梯缓步登上二楼三楼逐步参观，但同时，其馆藏之丰富，文物来源之广泛确实告诉我们，人不可貌相，博物馆也是这个道理。 推介理由 除了文物丰富程度，上博文物的配套文字介绍以及相关知识延拓是国内一流水平的，陕历博和上博在这方面我觉得做的真的很到位，我现在还能回想起来古代青铜馆内对各类青铜器上的装饰纹理的介绍（云纹，鱼纹，云雷纹，夔龙纹，饕餮纹，火纹等等），带图，带解释，详尽丰富，甚至你还可以学到辨析商周青铜器早晚期的一些方法。 Further More，上博和国外知名博物馆的交流也是国内博物馆中最为频繁的，这也为上博带来了更多的其他国家的藏品展览机会以及更好的国际视角，我当时参观的时候恰好碰上大英博物馆在上博设展，刘易斯棋子（还记得哈利波特与魔法石吗？），埃及藏品等等。除了更多的国际交流活动外，上博的公众号经营的也是最为优秀的，不仅有“硬”科普，还会向公众推送近期上博要举行的各类活动，将 2 周边景点 上海市城市规划馆（同在人民广场，步行不过五分钟，一睹上海发展史还是很不错的），外滩，思南路（北头的 Line Friend 店，文艺青年专属街道），十号线路线（上海市图书馆、宋庆龄故居），田子坊+日月光中心。 其他 节假日出行请提前安排好住宿，另外工作日上海的地铁真的很挤，我和朋友亲眼目睹了 2 号线挤停。 商海先行——广东省博物馆 前述 截至目前，广东省博物馆应该是我最晚参观的一个博物馆，它位于广州市新中轴线，珠江新城东南，花城大道东侧，与广州市图书馆、大剧院、第二青年宫共同构成了花城广场两侧的文教区。 广东省博物馆论体量，比不过超大型占地面积的一些博物馆，论文物丰富，广州城建城历史虽不短，但少作为政权的核心城邦来对待，因而也比不上六朝古都或是紫禁城，但广东省的独特地位（临海通商口岸，居民迁移）等，造就了广东省的独特文化，而广州省博物馆也市恰恰抓住了其最具特色的两点：“海”与“商”。 推介理由 “南海一号”发掘过程，发掘藏品给你充分展示了古代对外经贸的各方面情况，以及航海方面的知识（包括但不限于当时的造船技术、船舶载货的方式），通过对当时情景的复原，甚至可以从一些方面解释该船沉没的原因。 此外其他展区，诸如木雕、端砚也非常用心的讲解了潮州等地区的特别文化。 周边景点 粤式点心当然是要吃的啦~点都德、陶陶居、广州酒家，稻香。此外西关地区的文明路甜品店也不应错过，上下九地区，广州塔，双鸭山大学（手动狗头）。 其他 多点人来，组团吃早茶可以点更多样式（我就是吃了这个亏）。 燕赵齐鲁——河北博物院、山东博物馆 前述附近讲真对于这两博物馆（院），我并不能给出一个很明确的文物相关的特色，只能以历史地名作为本节标题，如果谈参观这两馆的最大好处，我想就是不用排队，参观不挤了，当然，每一座博物馆（院）都是有灵魂的，如果你想了解这两片土地孕育出的文化，那这两座博物馆自然是首选。 外观特征的话，印象中山东博物馆的台——阶——很——多，河北省博物院的北——门——不——开（其实是开了但不显眼，和南区广场的大门形成鲜明的反差）。两者的外观颜色蛮相近的，而且好像都可以刷身份证免票进（很环保，支持）。河北省博物院其实面积很大，但是由于建筑不高，且铺开形成南北两区，让人感觉不出来其五万多平方米的占地。 推介理由 山东博物馆：为济南这个文化之都增了一笔亮色，山博对文物考古的贡献也颇大，作为解放后第一批博物馆，接管了原来文物后开启了大片的田野调查，著作也是相当的，在北方地区为考古文物发掘的事业做出了巨大贡献。 值得一看的藏品：首推鲁国大玉璧+孙子兵法！其他的我印象真的不是很深刻 sry。 河北博物院：以中山靖王相关的文物以及满城汉墓出土文物最为出名，另外河北省博常设一些红色展览以及书画临展，有兴趣的同学可以关注一下。 值得一看的藏品：长信宫灯（如果你能了解烟道的原理这些古人智慧结晶就更棒了），中山王相关的铁足铜鼎和金缕玉衣（后来去了湖南省博我才知道金缕玉衣不止中山靖王有）但值得一说的是，刘胜的金缕玉衣是中国首次发现、规格最高、最完整的玉制葬衣。 周边景点 山博附近：去了济南为什么不去临近的泰安爬个泰山呢？还有曲阜的三孔景区。 河北博物院：北边正定县城（大佛寺、荣国府取景地）可以一去，石家庄东开发区天山海世界是个玩水的好去处。 其他 我自认为北方这两个地方民风都蛮朴实的，不过气候都偏干燥，尤其是春夏季节，南方的同学如果选择这个季节来的话记得带上各种保湿用品，PS 吃辣会很容易上火。河北我推荐尝尝保定或者河间的驴肉火烧，山东。。山东大煎饼我是不推荐的，其他鲁菜根据经济能力可以尝试一下，便宜坊是个不错的店家（印象中），锅贴好吃。 西南异域——四川省博物院、三星堆博物馆 前述 这两个博物馆都是我大一暑假个人游途中去的，参观西南一隅的博物馆是别样的文化体验。综合来讲两家的文物主要侧重本地发掘（这是自然），因而更注重地域性，历史时间的连贯性以及和历史事件的衔接就没有一些博物馆那么好了。 推介理由 两馆都对特色文物、国宝级文物的展览渲染让我印象深刻，川博丰富多彩的展示了蜀地地区文化以及和中原地区的联系变化，在众多博物馆中独树一帜。三星堆文化、古蜀国，拾其底蕴最丰富的历史片段做详尽的讲解。 特色文物：铜面具、金面具、太阳神鸟金箔（学材料和艺术的强烈推介去看一下）。 周边景点 宽窄巷、武侯祠和锦里。 其他 冰粉！冰粉一定要尝一尝！每当回想起我的成都之行我都后悔当时没有多吃几碗冰粉！ 旧馆新缮——湖北省博物馆、湖南省博物馆 前述 湖南省湖北省属于中部内陆省份，我自己在湖南长沙读书，虽然博物馆没有二刷，但是对于这两座城市还是熟悉一些，湖南省博物馆是 17 年左右刚刚修缮好的阔别五年再度向公众开放，外观好像有独特意义，我记不大清了。湖北省博物馆也是从旧馆迁移至新馆，外观高台基、大坡面屋顶莫名让我想起了其中的镇馆之宝曾侯乙编钟（随便乱想的）。 如果想了解湖南省博物馆“闭关五年”做了些什么以及新世纪以来湖南考古发现，新发现陈列也是一个值得参观学习的地方。 推介理由 两个博物馆都是颇有历史，经历迁移或者重新修缮焕然一新的新馆。对于长江中下游的文化，春秋战国时期楚/吴/越文化有着详尽的介绍，爱好这方面历史的同学不要错过了。不过可惜的是两馆对于文物的科普讲解并不是非常详尽，当然，对特色文物照顾还是非常到位的，湖北省博物馆对曾侯乙编钟编磬的介绍不可谓不详尽，音律知识、演奏方法甚至都有介绍，电子语音导览还可以听一首古编钟的曲子。而湖南省博物馆则是通过灯光把千年女尸以及素纱褝衣的材质特点展现到极致。 特色文物 湖北省博物馆：越王勾践剑、曾侯乙编钟编磬。 湖南省博物馆：（以马王堆出土文物为主）汉墓 T 形帛画，素纱褝衣。 周边景点 湖北省博：湖北省美术馆、汉阳造文化产业区、江汉关博物馆、湖北省图书馆湖南省博：三观一厅区域（长沙市博物馆、长沙市城市规划馆、长沙市图书馆、长沙市音乐厅）、简牍博物馆、太平老街、解放西（长沙酒吧文化一条街）]]></content>
      <categories>
        <category>旅行</category>
      </categories>
      <tags>
        <tag>旅行</tag>
        <tag>博物馆</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[2019-07-08广东省游记]]></title>
    <url>%2Fpost%2F8886f58d.html</url>
    <content type="text"><![CDATA[抵达出发前两天在长沙定了住宿火车票和机票，预计在广州市停留两天、深圳停留三天、香港一天之后返程。]]></content>
      <categories>
        <category>旅行</category>
      </categories>
      <tags>
        <tag>旅行</tag>
        <tag>游记</tag>
        <tag>广东</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[操作系统学习——Linux基础学习篇（第6章）]]></title>
    <url>%2Fpost%2F4309bc34.html</url>
    <content type="text"><![CDATA[第0章 Linux的文件权限和目录配置用户与用户组用户：由于Linux被设计为一个多用户、多任务的系统，用户概念在Linux中极为重要。 文件所有者：为了应对多人工作环境，分离不同用户的工作环境，设置了文件的归属权（文件所有者的角色）。 用户组：团队开发协作的需要，在用户概念之上设置了用户组的权限管理级别。每组成员相对而言更易互相修改对方的数据，但是其他组的组员则不能看到本组的文件内容。 Linux文件权限概念Linux文件属性执行命令 1ls -al 会得到下面的结果 第一列代表文件权限（permission） 第一个字符 [d]表示目录 [-]表示文件 [l]表示链接文件（linkfile） [b]表示可控存储的接口设备 [c]表示串行端口设备 后面字符三个一组 [r]表示可读 [w]表示可写 [x]表示可执行 第一组为文件所有者权限、第二组为同用户组权限、第三组为其他非本用户组的权限。 第二列表示有多少文件名连接到此节点（i-node） 第三列表示这个文件的所有者账号 第四列表示这个文件所属的用户组 第五列表示文件大小（默认为B） 第六列表示文件创建日期或者最近修改日期 第七列表示文件名 改变文件属性和权限三个命令 chgrp 改变文件所属的用户组 1chgrp [-R] 账号名称：组名 文件或目录 -R 参数表示是否要递归改变子目录下的所有文件 chown 改变文件所有者 1chown [-R] 账号名称：组名 文件或目录 -R参数同上 chmod 改变文件的权限 数字修改 1chmod xxx 文件目录 将三端权限二进制化（比如777就表示权限全开） 符号修改 | 命令 | 组对象 | 操作符 | 权限 | 文件名 | | :——-: | :——-: | :——-: | :——-: | :———-: | | chmod | u g o a | + - = | r w x | 文件或目录 | eg 1chmod u+r,o=rwx xxx 目录与文件的权限意义 对文件的意义 r(read)表示可以读此文件的具体内容 w(write)表示可以编辑、新增或是修改文件的内容（但不含删除） x(execute)表示可以被系统执行的权限 对目录的意义 r表示可以读取目录结构权限，可以查询到文件名数据，也可以利用ls命令来获取列表内容的显示 w表示可以新建文件/目录，删除已经存在的文件和目录（无视此文件/目录的），重命名，转移文件/目录的位置。（也即，删除一个文件的权限是跟是否具备此文件所在目录的写权限有关，而跟文件本身权限无关） x表示是否可以进入该目录成为工作目录（working directory）的权限。 Linux文件种类与扩展名文件种类普通文件、纯文本文件（cat的文件）、二进制文件、数据格式文件 目录（d） 连接文件（l）类似Windows下面的快捷方式 设备与设备文件（device）：通常在/dev这个目录，通常分为两种： 块（block）设备文件 一些存储数据供系统随机访问的接口设备，例如硬盘等。 字符（character）设备文件 一些串行端口接口设备，特征是一次性读取，不能够截断输出。 套接字（socket）：网络进程通信，通常在/var/run中 管道（FIFO，pipe）：解决多个程序同时访问一个文件造成的错误问题 文件扩展名只是以适当的扩展名来表示是什么种类，而实际能否运行依赖数据+execute执行权限（这一点和Windows判断可执行程序有很大的不同）。 *.sh：脚本或批处理文件，主要用shell写。 *Z、*.tar、*.tar.gz、*.zip等：压缩文件，由不同压缩软件使用决定。 *.html等：网页相关文件 长度限制：默认使用Ext2/Ext3文件系统，单一文件名/目录名限制长度为255字符、包含完整路径名称及目录的完整文件名为4096个字符。 Linux目录配置Linux目录配置标准：FHS / (root，根目录)，与开机系统有关 /usr （UNIX software resource）：与软件安装/执行有关 /var （variable）：与系统运作过程有关 其他详情可以自行百度，或者查看目录树（单独再找机会整理一下） 绝对路径与相对路径区别/var/log（绝对路径）和../var/log（相对路径） 网络文件常常提到类似“。/run.sh”的数据，这个命令的意义是什？ 答：由于命令执行需要变量（bash章节会提及）的支持，若执行文件放置在本目录并且本目录并非正规的执行文件目录（/bin、/usr/bin等为正规），此时要执行命令就要严格指定该执行文件。“./”代表“本目录”的意思，所以“./run.sh”代表执行本目录名下的run.sh文件 END]]></content>
      <categories>
        <category>操作系统</category>
        <category>Linux</category>
      </categories>
      <tags>
        <tag>操作系统</tag>
        <tag>Linux</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[密码技术学习——密码学课程PPT复习提纲]]></title>
    <url>%2Fpost%2Fb94eea64.html</url>
    <content type="text"><![CDATA[CSU密码学课程独门复习提纲易考点，并不是“真正意义上”密码学的重点（页数P是按4张PPT一页来的）。 第一部分 引言 P4 信息安全定义（Information Security） P4 密码学定义（Cryptography） 五类安全服务（认证鉴别服务、访问控制服务、数据保密性服务、数据完整性服务、抗否认服务）（又名：进不来、拿不走、看不懂、改不了、跑不了） P7 安全服务与密码技术的关系（表格）。 第二部分 密码学概述（古典密码） P9 理论安全与时间全（香农信息论，资源与运算力限制） P9 四种基本攻击类型 P10 对称密码与公钥密码各自的特点 P12 几个同余式的定理（运算性质） P16 仿射密码的攻击 P17 维吉尼亚密码特征（弱点、攻击方式） 第三部分 现代密码算法数学基础 P21 当$p$为素数时候，模$p$的简化剩余系是一个交换乘群。 P22 模、剩余系、完全/简化剩余系的概念 P23 欧拉函数、欧拉定理、费马小定理 P24 阶、原根定义（利用原根的阶简化计算） P24 原根是否存在的充要条件 $n=2,4,p^e,2p^e$ 其中$e≥1$，$p$为素数 P25 快速指数算法 P27 置换群、完美洗牌（从2开始交叉插入） $f(x) = 2x \% (2n+1)$ 对称密码算法 P33 DES和IDEA比较（分组位数、轮数、子密个数等） P34 P38 AES总结（分组位数、轮数、子密钥个数等） P39 序列密码与分组密码对比（加密方式） P47 Hash函数性质 P47 MD5与SHA函数对比 P48经典对称密码算法的特点 公钥密码算法 P49 公钥密码算法概述 P50 BSGS算法求离散对数问题，同余方程求解 P51 CRT P52 二次同余方程、二次符号定理、性质 P53 二次互反定理（$p,q$均为素数的时候判定二次同余方程是否有解加快速度） P55 P56 素数生成与素性检测算法 P57 RSA算法（算法描述、攻击方法、中间人、共模攻击） P60 EIGamal算法（选取k的好处、同密文、发送者多次发送不冲突，对比RSA） P61 ECC算法 P62 背包算法（超递增背包-&gt;普通背包 加密） P63 公钥密码算法各种比较 签名算法（这里分类有点迷） P65 RSA签名（密钥使用不当，攻击方式） P66 DSA算法 P67 左上签名算法小结 第四部分 基本密码协议 P68 密码协议分类（仲裁者裁决者分别对应） P70 保密通信协议（公钥密码的中间人攻击、改进方法） P73 密钥协商协议（对称+仲裁者、公钥、DH的中间人、EKE的优势看左半面、椭圆曲线DH、双线性对） P73 密钥协商协议总结 P78 数字签名协议形式化描述（对称、公钥） P79 阈下信道 P81 身份鉴别协议（SKEY协议单向链、双向鉴别） P83 秘密共享协议（门限分案、Shamir、Bloom） 第五部分 中级密码协议 P88 Shamir三次传输协议（异或的问题，不需要共享密钥） P88 不经意传输协议（利用上面的、选哪个不知道系列） P88 （不考）智力扑克协议 P89 安全多方计算举例子，理解，盲因子 P92 密钥分发协议（加入/不加入会话密钥） P93 基于CRT密钥分发协议+总结 第六部分 高级密码协议懂概念、小题 P94 零知识协议目的 P95 盲签名协议（理解） P95 同时签约协议（应用不经意传输，理解） P97 匿名投票协议图示（可能考）+匿名通信协议（不考） P99 数字现金协议图示（理解） 第七部分 分组密码加密模式融入其中了，要考可能只靠特点 P103 四种模式总结表格 第八部分 密钥管理 P105 P106 密钥生命周期内：生成与密钥更新（安全性、哈希生成新密钥） P106 P107 Kerberos最后一节课特别强调 P108 数字证书概述]]></content>
      <categories>
        <category>密码学</category>
      </categories>
      <tags>
        <tag>密码学</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[操作系统学习——Linux基础学习篇（第1章）]]></title>
    <url>%2Fpost%2F86ae82ba.html</url>
    <content type="text"><![CDATA[第1章 Linux是什么Linux就是一套操作系统，内核+系统调用。 Windos操作系统本来就是针对个人计算机x86架构的硬件设计的，所以只能在x86的个人计算机上运行，在不同平台上无法运行。而Linux是开源系统，也可以（事实上基本上已经）被修改成适合在各种机器上面运行的，也就是说，Linux是具有“可移植性”，是很重要的不同点。 UNIX历史 1973年：UNIX正式诞生 1977年：重要的UNIX分支——BSD诞生 1979年：重要的System V架构与版权声明 1984年之一：x86架构的Minix操作系统诞生 1984年之二：GNU项目与FSF基金会成立 GNU相关的一些产出：Emacs程序编辑器、GCC（GNU C Compiler）、GNU通用公共许可证（GPL）、bash shell基本接口 1988年：图形接口XFree86项目（非营利性，后被集成到Linux操作系统中） 1991年：芬兰大学生Linus Torvalds的一则消息 BBS上贴出宣称以bash，gcc等工具写了一个小小的内核程序，这个内核程序可以在Intel的386机器上面运行，然很多人感兴趣，从此开始了Linux不平凡的旅程。 关于GNU项目待补充 Linux的内核版本 主、次版本为奇数：开发中版本（development） 如2.5.xx，这种内核版本主要用在测试和开发新功能，所以通常这种版本仅有内核开发工程师会使用，如果有新增的内核程序代码，会加到这种版本中 主、次版本为偶数：稳定版本（stable） 如2.6.xx，等到内核功能开发成熟后会加到这类的版本，主要用在一般家庭计算机以及企业版本中。重点在于提供用户一个相对稳定的Linux作业环境平台。 区分内核版本（Linux版本多少）以及发行版本（Linux Ubuntu/CentOS distribution版本多少）。 Linux distribution“Kernel+Softwares+Tools”的可完全安装的系统，称为Linux distribution 各大Linux Distributions的主要异同：支持标准。 一些标准和规范：Linux Standard Base（LSB）以及目录架构File system Hierarchy Standard（FHS） Linux的优缺点 稳定的系统 基于UNIX概念开发出来的，有相似的程序接口和操作方式，也继承了稳定性效率高的特点。 免费或少许费用 基于GPL授权下的产物，因此任何人皆可自由取得Linux，不需要负担很大的版权费用。 安全性、漏洞的快速修补 由于有强大的社区、热心团体、个人参与其中开发，因此可以随时获得最新的安全信息，并随时更新，相对较安全。 多任务、多用户 不同于Windows系统的单人多任务，Linux可以在一部主机上划分不同等级的用户并且每个用户登录系统的时候工作环境都可以不同。 用户与用户组的规划 相对比较不耗资源 适合需要小内核程序的嵌入式系统 整合度佳且多样的图形用户界面（GUI） 关于授权待补充]]></content>
      <categories>
        <category>操作系统</category>
        <category>Linux</category>
      </categories>
      <tags>
        <tag>待补充</tag>
        <tag>操作系统</tag>
        <tag>Linux</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[操作系统学习——Linux基础学习篇（第0章）]]></title>
    <url>%2Fpost%2F20d9890e.html</url>
    <content type="text"><![CDATA[这个系列主要是依赖《鸟哥的Linux私房菜》一本书，记录自己的学习过程以及笔记。 第0章 计算机概论计算机计算机组成单元计算机硬件五大单元：输入单元，输出单元，控制单元，算术逻辑单元，存储单元，联系学过的计算机组成原理，实际上对应的就是计算机组成原理里的内容。输入、输出、控制器、运算器、存储器（主要指内存）。而控制器运算器构成CPU，CPU与存储器称为主机（实际上还包含输入输出的接口），在本书中称为系统单元，而与此相对的是外围设备（输入输出外存）。 CPU种类根据微指令集的划分 精简指令集 Reduced Instruction Set Computer RISC 这种CPU设计中，微指令集较为精简，每个指令的执行时间都很短，完成的操作也很单纯，指令的执行性能较佳，但要做复杂的事情就要多条来完成。常见：SPARC系列、Power Architecture系列、ARM系列。 应用方面，比如索尼的PS3应用的是PowerPC架构的Cell处理器，ARM更是常见 复杂指令集 Complex Instruction Set Computer CISC 每个小指令可以执行一些低阶的硬件操作，指令数目多、复杂、长度并不相同，因为复杂所以耗时长一些，但个别指令可以处理的工作较为丰富。常见：AMD、Intel、VIA等x86架构的CPU。 由于AMD、Intel、VIA所开发出来的x86架构CPU被大量用于PC机上，个人计算机常被称为x86架构计算机。来源就是因为最早的Intel开发出来的CPU代号为8086，后来又有80286，80386，就被称为x86了。 在2003年以前由Intel所开发的x86架构CPU由8位升级到16位、32位、后来AMD又依次架构修改新一代CPU位64位，为了区别两者的不同，因此64位的个人计算机CPU又被称为x86_64的架构。 不同的x86架构CPU的区别：整体结构（二层缓存、每次可执行的指令数）、微指令集（针对不同特性发展各异）。 多媒体微指令集：MMX，SSE，SSE2，SSE3，SSE4，AMD-3DNow! 虚拟化微指令集：Intel-VT，AMD-SVM 省电功能：Intel-SpeedStep，AMD-PowerNow! 64/32位兼容技术：AMD-AMD64，Intel-EM64T 个人计算机架构与接口设备Linux早期也根据个人计算机的架构发展来的，所以真的需要了解一下。 Intel主板架构，最重要的是芯片组，芯片组常被分为两个桥接器来控制各组件的通信，分别是： 北桥负责连接速度较快的CPU、内存与显卡组建。 南桥负责连接速度较慢的周边接口。 AMD主板架构，内存直接与CPU通信而不通过北桥，AMD为了加速两者的通信，将内存控制组件集成到CPU当中，这样可以加速两者的传输速度。 根据设计不同选择了不同的总线架构。 CPU主流的都是双核已上架够了，实际上是在一个CPU中封装了多个运算内核。 CPU频率是指CPU每秒钟可以进行的工作次数。 由于不同CPU微指令集不同，每次频率可以进行的指令数也不同，不能直接以频率论高低，严谨的说目前只能来比较同款CPU的速度。 外频：CPU与外部组件进行数据传输/运算时的速度。 倍频：CPU内部用来加速工作性能的一个倍数，相乘才是CPU的频率。 一般出厂固定倍频，超频玩家常通过超频外频达到提升CPU的频率。 主板上的BIOSCMOS主要功能为记录主板上的重要参数，包括系统时间、CPU电压与频率、各项设备的IO地址与IRQ，由于这些数据的记录要花费电力，因此主板上面才有电池。 BIOS为写入到主板某一块山村或EEPROM的程序，它可以在开机的时候执行，以加载CMOS当中的参数，并尝试调用存储设备中的开机程序，进一步进入到操作系统当中。 软件程序运行“我们知道没有插电的计算机是一堆废铁，那么插了电的计算机是什么？” “一堆会电人的废铁。” 计算机需要软件：系统软件+应用软件。 为了要克服硬件方面总是需要重复编写句柄的问题，所以就产生了操作系统（Operating System，OS），事实上，OS伴随计算机发展一直都存在，从提高CPU运算速率到资源管理到方便用户使用，一直是计算机必备的软件。 操作系统 操作系统内核（Kernel） Kernel主要在于管控硬件与提供相关的能力（如网络功能），避免用户直接操作，内核在内存中放置的区块是受保护的，并且开机后就一直常驻在内存当中 系统调用（System Call） 遵循内核的规定，从参考硬件变成了参考内核功能。操作软件通常会提供一整组开发接口（API）给工程师开发软件，这就是系统调用层。 一些点 操作系统内核直接参考硬件规格写成 操作系统只是在管理 应用程序都是参考对应的操作系统开发接口]]></content>
      <categories>
        <category>操作系统</category>
        <category>Linux</category>
      </categories>
      <tags>
        <tag>操作系统</tag>
        <tag>Linux</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[密码技术学习——基于RSA的不可否认签名方案]]></title>
    <url>%2Fpost%2F6028c50e.html</url>
    <content type="text"><![CDATA[本文主要内容主要来自Chaum van Antwerpen在89年发表的《Undeniable Signatures》一文以及Gennaro、Krawczyk和Rabin在97年发表的《RSA-Based Undeniable Signatures》一文，用来了解不可否认签名方案的相关知识。 介绍背景介绍数字签名的复制属性不同于我们现实生活中的签名文件，在不考虑时间戳的前提下，我们基本上可以认为复制签名和原始签名是相同的。这种极易复制的性质在很多场合下是有利的，比如带签名公告的分发，开源软件的认证，这种性质多要求带签名的副本对分发无抵抗要求（甚至是希望分发）。 但它不适合许多其他应用程序。对于在某种程度上对个人或商业敏感的所有书面或口头承诺的电子替代品。 在这种情况下，经核证的副本的扩散可能会导致勒索，或者工业间谍的非法利用。这种承诺的接受者当然应该能够确保发行人以后不能否认它，但未经发行人同意，接收方也不能向其他任何人展示承诺。 不可否认的签名非常适合这种应用程序。不可否认签名(如数字签名)是由签名者发出的数字，它取决于签名者的公钥和签名的消息。然而，与数字签名不同的是，不可否认的签名如果没有签名者的合作是无法验证的。 不可否认签名不可否认签名概念由Chaum和van Antwerpen在[1]（89年）首先提出。它拓展了普通签名的概念，使用强不可否认性，且对签名的验证要求在签署者（证明者）的参与下完成。这以性质有效的防止了带签名的有价值文件的多次拷贝分发的滥用情况，在一些特殊场合下起到了作用。下面具体说明不可否认性质的含义以及不可否认签名的应用。 不可否认性质不可否认性质包括两层含义： 签名的证实和否定必须与签名者合作完成，这一点可以有效地防止一些有价值文件被随意的复制或分发； 签名者不能抵赖它曾签过的签名，由于他曾签过的签名可以通过拒绝执行证实协议来否认他曾签过的签名，为了防止此类事件发生，不可否认签名增加了一个否认协议，签名者可以利用否认协议证明一个伪造的签名是假的；而如果签名者拒绝执行否认协议，就表明签名事实上是由他签署的。 论文中提出基于RSA的第一个不可否认的签名方案。 自1989年引入以来，大量工作一直致力于研究不可否认的签名。 到目前为止，这项工作一直基于离散对数系统。 相反，我们的方案使用常规RSA签名来生成不可否认的签名。 在这个新设置中，RSA的签名和验证指数都由签名者保密，而公钥由单个公共消息上的复合模数和样本RSA签名组成。 我们的方案具有一些吸引人的特性：首先是可证明的安全性，伪造不可否认的签名与伪造常规RSA签名一样困难。其次，确认和拒绝协议都是零知识（特别是，确认协议仅涉及两轮通信和少量取幂）。此外，我们的方案的基于RSA的结构提供了简单而优雅的解决方案，以提供最初引入不可否认签名的文献中发现的不可否认签名的几个更高级的属性，包括不可否认签名的可转换性（转换为可公开验证的签名），委托确认能力的可能性，拒绝签名给第三方而不放弃签署的权力，以及签名和确认操作的分布式（阈值）版本的存在。 由于上述属性以及我们的不可否认的签名与标准RSA签名相同的事实，我们提出的方案对于实际实现来说，它变得非常有吸引力。 预备知识 引理 1： 令 $n=pq$，且$p&lt;q$，$p=2p’+1$，$q=2q’+1$，$p$，$q$，$p’$，$q’$均为质数，则： $Z_n^{*}$中的任意元素的阶均在集合$\{1,2,p’,q’,2p’,2q’,p’q’,2p’q’\}$中。 对于给定的$w$满足$w \in Z_n^{*} \setminus \{ -1 , 1 \}$，且$ord(w)&lt;p’q’$，则$gcd(w-1,n)$或$gcd(w+1,n)$是n的一个素因子。 引理 2： 令$n$同引理1中规定，对于给定的$w$满足$ord(w) \in \{ p’q’, 2p’q’ \}$，则对于任意$m \in Z_n^{*}$ , $m^4 \in \langle w \rangle$ 新的不可否认签名方案在这一节，我们给出我们方案的细节，首先我们定义如下集合。 N= \{ n | n = pq, p]]></content>
      <categories>
        <category>密码学</category>
      </categories>
      <tags>
        <tag>密码学</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[【洛谷-P2756】解题报告（二分图最大匹配）]]></title>
    <url>%2Fpost%2Fd6212e2f.html</url>
    <content type="text"><![CDATA[原始题目P2756 飞行员配对方案问题 题目大意给定两个集合，存在一些连接两个集合的边表示配合，来自不同集合的一对元素构成一个配对，求最大的配对数量。 解题思路集合内无边，所以构成二分图，求二分图的最大匹配。 解题代码12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364656667686970717273747576#include &lt;bits/stdc++.h&gt;using namespace std;typedef long long ll;typedef unsigned long long ull;typedef vector&lt;int&gt; vi;typedef pair&lt;int, int&gt; pii;typedef pair&lt;string, string&gt; pss;#define rep(i, a, n) for (int i = a; i &lt; n; ++i)#define per(i, a, n) for (int i = n - 1; i &gt;= a; --i)#define fi first#define se second#define mp make_pair#define np next_permutation#define pb push_back#define INF 0x3f3f3f3fconst int maxn = 1e3 + 5;vi e[maxn];int n, m;bitset&lt;maxn&gt; v;int fa[maxn], ans;int dfs(int x)&#123; rep(i, 0, e[x].size()) &#123; int y = e[x][i]; if (v[y]) continue; v[y] = 1; if (!fa[y] || dfs(fa[y])) &#123; fa[y] = x; return 1; &#125; &#125; return 0;&#125;void init()&#123; rep(i, 0, maxn) e[i].clear(); memset(fa, 0, sizeof(fa)); v.reset(); ans = 0;&#125;int main()&#123; ios::sync_with_stdio(false); while (cin &gt;&gt; m &gt;&gt; n) &#123; init(); int a, b; while (cin &gt;&gt; a &gt;&gt; b &amp;&amp; a != -1) &#123; e[a].pb(n + b); e[n + b].pb(a); &#125; rep(i, 1, m + 1) &#123; v.reset(); ans += dfs(i); &#125; if (ans == 0) &#123; cout &lt;&lt; "No Solution!" &lt;&lt; endl; continue; &#125; cout &lt;&lt; ans &lt;&lt; endl; rep(i, n + 1, n + n + 1) &#123; if (fa[i] != 0) cout &lt;&lt; fa[i] &lt;&lt; " " &lt;&lt; i - n &lt;&lt; endl; &#125; &#125;&#125; 收获与反思搬运定义 图的匹配相关图的匹配：任意两条边都没有公共端点的边的集合被称为图的一组匹配。 二分图最大匹配：在二分图中，包含边数最多的一组匹配被称为二分图的最大匹配。 对于任意一组匹配 $S$ （边集），属于 $S$ 的边被称为匹配边，不属于 $S$ 的边被称为非匹配边。匹配边的端点被称为匹配点，其他节点被称为非匹配点。 如果二分图中存在一条连接两个非匹配点的路径 ，使得非匹配边与匹配边在路径上交替出现，那么称该路径是匹配 $S$ 的增广路（也称交错路）。 增广路的性质 长度为奇数 奇数边是非匹配边，偶数边是匹配边。 如果把路径上所有边的状态（是否为匹配边）取反，那么得到的新的边集 $S’$ 仍然是一组匹配，并且匹配的边数增加了 $1$ 。 匈牙利算法（增光路算法）主要过程： 设 $S$为空集，即所有边都是非匹配边。 寻找增广路 path ，把 path 上所有边的匹配状态取反，得到一个更大的匹配 $S’$。（利用增光路性质3） 重复第 2 步，直至图中不存在增广路。 寻找增广路依次尝试给每一个左部节点 xx 寻找一个匹配的右部节点 yy 。 dfs方法。 常有两种写法 单标记，邻接表写法 123456789101112131415int dfs(int x)&#123; rep(i, 0, e[x].size()) &#123; int y = e[x][i]; if (v[y]) continue; v[y] = 1; if (!fa[y] || dfs(fa[y])) &#123; fa[y] = x; return 1; &#125; &#125; return 0;&#125; 双标记，数组写法 123456789101112int dfs(int x)&#123; rep(i,0,n)&#123; if(!mmp[x][i] || v[i]) continue; v[i] =1; if(!fa[i] || dfs(fa[i]))&#123; fa[i] = x; fa[x] = i; //双标记 return 1; &#125; &#125; return 0;&#125; 双标记对于访问二分图里所有点得到的匹配是实际值，单标记访问所有点得到的匹配是2倍，如果访问一个集合点则是实际值，单标记更多用于两集和已被分隔开的情况。]]></content>
      <categories>
        <category>编程</category>
        <category>ACM</category>
      </categories>
      <tags>
        <tag>编程</tag>
        <tag>ACM</tag>
        <tag>2019春季训练</tag>
        <tag>二分图</tag>
        <tag>最大匹配</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[【洛谷-P2104】解题报告（模拟）]]></title>
    <url>%2Fpost%2F61642081.html</url>
    <content type="text"><![CDATA[原始题目P2104 二进制 题目大意模拟二进制运算，保证最高位不改变，输入初始与运算，输出结果。 解题思路vector模拟栈操作： ‘*’入栈0 ‘\’出栈 ‘+’则末尾++，然后更新 ‘-‘则末尾—，然后更新 解题代码12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364656667// 这个题用vector ++v.back() 比 ++v[v.size()-1] 跑的要慢 有些奇怪 值得探索一下#include &lt;bits/stdc++.h&gt;using namespace std;typedef long long ll;typedef unsigned long long ull;typedef vector&lt;int&gt; vi;typedef pair&lt;int, int&gt; pii;typedef pair&lt;string, string&gt; pss;#define rep(i, a, n) for (int i = a; i &lt; n; ++i)#define per(i, a, n) for (int i = n - 1; i &gt;= a; --i)#define fi first#define se second#define mp make_pair#define pb push_back#define all(x) x.begin(), x.end()#define endl '\n'vi v;int n, m;string op;int main()&#123; ios::sync_with_stdio(false); int temp; while (cin &gt;&gt; n &gt;&gt; m) &#123; cin &gt;&gt; op; rep(i, 0, n) v.pb(op[i] - '0'); cin &gt;&gt; op; rep(i, 0, m) &#123; if (op[i] == '*') &#123; v.pb(0); &#125; else if (op[i] == '/') &#123; v.pop_back(); &#125; else if (op[i] == '+') &#123; ++v.back(); per(i, 0, v.size()) &#123; if (v[i] == 2) &#123; v[i] = 0; ++v[i - 1]; &#125; else break; &#125; &#125; else if (op[i] == '-') &#123; --v.back(); per(i, 0, v.size()) &#123; if (v[i] &lt; 0) &#123; v[i] = 1; --v[i - 1]; &#125; else break; &#125; &#125; &#125; // cout &lt;&lt; v[0]; rep(i, 0, v.size()) &#123; cout &lt;&lt; v[i]; &#125; cout &lt;&lt; endl; &#125;&#125; 收获与反思vector的一些操作pop_back(),push_back().back()等熟悉一下，有时候很方便。]]></content>
      <categories>
        <category>编程</category>
        <category>ACM</category>
      </categories>
      <tags>
        <tag>编程</tag>
        <tag>ACM</tag>
        <tag>2019春季训练</tag>
        <tag>洛谷</tag>
        <tag>imitation</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[【洛谷-P1914】解题报告（字符串）]]></title>
    <url>%2Fpost%2F4c842940.html</url>
    <content type="text"><![CDATA[原始题目P1414 小书童——密码 题目大意移位密码还原 解题思路水题 解题代码12345678910111213141516171819202122232425262728#include &lt;bits/stdc++.h&gt;using namespace std;typedef long long ll;typedef unsigned long long ull;const int maxn = 1e5 + 5;#define rep(i, a, n) for (int i = a; i &lt; n; ++i)#define per(i, a, n) for (int i = n - 1; i &gt;= a; --i)#define fi first#define se second#define pb push_back#define np next_permutation#define mp make_pair#define endl '\n'string s;int n;int main()&#123; ios::sync_with_stdio(false); while (cin &gt;&gt; n &gt;&gt; s) &#123; rep(i, 0, s.length()) &#123; cout &lt;&lt; char('a' + ((s[i] - 'a') + n) % 26); &#125; cout &lt;&lt; endl; &#125;&#125; 收获与反思无]]></content>
      <categories>
        <category>编程</category>
        <category>ACM</category>
      </categories>
      <tags>
        <tag>编程</tag>
        <tag>ACM</tag>
        <tag>2019春季训练</tag>
        <tag>字符串</tag>
        <tag>洛谷</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[【洛谷-P1909】解题报告（水题）]]></title>
    <url>%2Fpost%2F7a1fb89c.html</url>
    <content type="text"><![CDATA[原始题目P1909 买铅笔 题目大意三种笔个数，单价不同，求买超过n支铅笔最少花费。 解题思路水题 解题代码123456789101112131415161718192021222324252627282930313233343536373839404142#include &lt;bits/stdc++.h&gt;using namespace std;typedef long long ll;typedef unsigned long long ull;typedef vector&lt;int&gt; vi;typedef pair&lt;int, int&gt; pii;typedef pair&lt;string, string&gt; pss;#define rep(i, a, n) for (int i = a; i &lt; n; ++i)#define per(i, a, n) for (int i = n - 1; i &gt;= a; --i)#define fi first#define se second#define all(x) x.begin(), x.end()#define mp make_pair#define pb push_back#define np next_permutation#define INF 0x3f3f3f3f#define EPS 1e-8#define endl '\n'int a[10], b[10], n, ans[3], cnt;int main()&#123; ios::sync_with_stdio(false); while (cin &gt;&gt; n) &#123; rep(i, 0, 3) &#123; cin &gt;&gt; a[i] &gt;&gt; b[i]; ans[i] = ceil(1.0 * n / a[i]) * b[i]; &#125; int minp = ans[0]; rep(i, 1, 3) &#123; if (ans[i] &lt; minp) &#123; minp = ans[i]; &#125; &#125; cout &lt;&lt; minp &lt;&lt; endl; &#125;&#125; 收获与反思无]]></content>
      <categories>
        <category>编程</category>
        <category>ACM</category>
      </categories>
      <tags>
        <tag>编程</tag>
        <tag>ACM</tag>
        <tag>2019春季训练</tag>
        <tag>洛谷</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[【洛谷-P1781】解题报告（排序）]]></title>
    <url>%2Fpost%2Fbeeeff10.html</url>
    <content type="text"><![CDATA[原始题目P1781 宇宙总统 题目大意输出出现次数最多的编号 解题思路排序 解题代码123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051#include &lt;bits/stdc++.h&gt;using namespace std;typedef long long ll;typedef unsigned long long ull;const int maxn = 1e5 + 5;#define rep(i, a, n) for (int i = a; i &lt; n; ++i)#define per(i, a, n) for (int i = n - 1; i &gt;= a; --i)#define fi first#define se second#define pb push_back#define np next_permutation#define mp make_pair#define endl '\n'struct node &#123; string s; int id;&#125;;node a[maxn];bool cmp(node a, node b)&#123; if (a.s.length() != b.s.length()) &#123; return a.s.length() &gt; b.s.length(); &#125; else &#123; int len = a.s.length(); rep(i, 0, len) &#123; if (a.s[i] != b.s[i]) return a.s[i] &gt; b.s[i]; &#125; &#125;&#125;int n;string ss;int main()&#123; ios::sync_with_stdio(false); while (cin &gt;&gt; n) &#123; rep(i, 1, n + 1) &#123; cin &gt;&gt; ss; a[i].s = ss; a[i].id = i; &#125; sort(a + 1, a + 1 + n, cmp); cout &lt;&lt; a[1].id &lt;&lt; endl &lt;&lt; a[1].s &lt;&lt; endl; &#125;&#125;]]></content>
      <categories>
        <category>编程</category>
        <category>ACM</category>
      </categories>
      <tags>
        <tag>编程</tag>
        <tag>ACM</tag>
        <tag>2019春季训练</tag>
        <tag>洛谷</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[【洛谷-P1716】解题报告（排序）]]></title>
    <url>%2Fpost%2F773c10c5.html</url>
    <content type="text"><![CDATA[原始题目P1716 双调序列 题目大意双调序列的第一个数是n个整数中的最大数，第二个数是n个整数中的最小数，第三个数是n个数中的第二大数，第四个数是n个数中的第二小数……取过的数不能再取，依次类推，直到结束。 给定序列，输出双调序列。 解题思路排序以后正反输出。 解题代码123456789101112131415161718192021222324252627282930313233343536#include &lt;bits/stdc++.h&gt;using namespace std;typedef long long ll;typedef unsigned long long ull;typedef pair&lt;int, int&gt; pii;typedef pair&lt;string, string&gt; pss;#define rep(i, a, n) for (int i = a; i &lt; n; ++i)#define per(i, a, n) for (int i = n - 1; i &gt;= a; --i)#define pb push_back#define np next_permutation#define mp make_pairconst int maxn = 1e5 + 5;ll a[maxn];int n;int main()&#123; ios::sync_with_stdio(false); while (cin &gt;&gt; n) &#123; rep(i, 0, n) cin &gt;&gt; a[i]; sort(a, a + n); for (int i = n - 1, j = 0;; i--, j++) &#123; if (i == j) &#123; cout &lt;&lt; a[i] &lt;&lt; endl; break; &#125; if (i &lt; j) break; cout &lt;&lt; a[i] &lt;&lt; endl &lt;&lt; a[j] &lt;&lt; endl; &#125; // cout &lt;&lt; endl; &#125;&#125; 收获与反思无]]></content>
      <categories>
        <category>编程</category>
        <category>ACM</category>
      </categories>
      <tags>
        <tag>编程</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[【洛谷-P1603】解题报告（排序）]]></title>
    <url>%2Fpost%2F2f392380.html</url>
    <content type="text"><![CDATA[原始题目P1603 斯诺登的密码 题目大意找出英文字母表示的数字平方后%100排成一排，输出排列中最小的（开头去0）。 解题思路排序后输出，头部的0。 解题代码123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293#include &lt;bits/stdc++.h&gt;using namespace std;typedef long long ll;typedef unsigned long long ull;typedef vector&lt;int&gt; vi;typedef pair&lt;int, int&gt; pii;#define rep(i, a, n) for (int i = a; i &lt; n; ++i)#define per(i, a, n) for (int i = n - 1; i &gt;= a; --i)#define pb push_back#define mp make_pair#define INF 0x3f3f3f3f#define EPS 1e-8#define all(x) x.begin(), x.end()const int maxn = 1e3 + 5;map&lt;string, int&gt; dic;void init()&#123; dic.clear(); dic.insert(mp("one", (1 * 1 % 100))); dic.insert(mp("two", (2 * 2 % 100))); dic.insert(mp("three", (3 * 3 % 100))); dic.insert(mp("four", (4 * 4 % 100))); dic.insert(mp("five", (5 * 5 % 100))); dic.insert(mp("six", (6 * 6 % 100))); dic.insert(mp("seven", (7 * 7 % 100))); dic.insert(mp("eight", (8 * 8 % 100))); dic.insert(mp("nine", (9 * 9 % 100))); dic.insert(mp("ten", (10 * 10 % 100))); dic.insert(mp("eleven", (11 * 11 % 100))); dic.insert(mp("twelve", (12 * 12 % 100))); dic.insert(mp("thirteen", (13 * 13 % 100))); dic.insert(mp("fourteen", (14 * 14 % 100))); dic.insert(mp("fifteen", (15 * 15 % 100))); dic.insert(mp("sixteen", (16 * 16 % 100))); dic.insert(mp("seventeen", (17 * 17 % 100))); dic.insert(mp("eighteen", (18 * 18 % 100))); dic.insert(mp("nineteen", (19 * 19 % 100))); dic.insert(mp("twenty", (20 * 20 % 100))); //a both another first second third dic.insert(mp("a", 1)); dic.insert(mp("both", 4)); dic.insert(mp("another", 1)); dic.insert(mp("first", 1)); dic.insert(mp("second", 4)); dic.insert(mp("third", 9));&#125;string ss;int a[maxn], cnt;int main()&#123; ios::sync_with_stdio(false); init(); while (getline(cin, ss)) &#123; cnt = 0; stringstream st(ss.substr(0, ss.length() - 1)); string temp; while (st &gt;&gt; temp) &#123; transform(all(temp), temp.begin(), ::tolower); if (dic.count(temp) != 0) &#123; a[cnt++] = dic[temp]; &#125; &#125; // cout &lt;&lt; "# cnt=" &lt;&lt; cnt &lt;&lt; endl; // rep(i, 0, cnt) cout &lt;&lt; a[i] &lt;&lt; " "; // cout &lt;&lt; endl; sort(a, a + cnt); int flag = 0; int i = 0; for (; i &lt; cnt; i++) &#123; if (a[i] == 0) continue; flag = 1; cout &lt;&lt; a[i]; i++; break; &#125; if (flag == 0) &#123; cout &lt;&lt; 0 &lt;&lt; endl; continue; &#125; for (i; i &lt; cnt; i++) &#123; cout &lt;&lt; setw(2) &lt;&lt; setfill('0') &lt;&lt; a[i]; &#125; cout &lt;&lt; endl; &#125;&#125; 收获与反思无]]></content>
      <categories>
        <category>编程</category>
        <category>ACM</category>
      </categories>
      <tags>
        <tag>编程</tag>
        <tag>ACM</tag>
        <tag>2019春季训练</tag>
        <tag>洛谷</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[【洛谷-P1598】解题报告（字符串）]]></title>
    <url>%2Fpost%2F541f3acd.html</url>
    <content type="text"><![CDATA[原始题目P1598 垂直柱状图 题目大意写一个程序从输入文件中去读取四行大写字母（全都是大写的，每行不超过100个字符），然后用柱状图输出每个字符在输入文件中出现的次数 解题思路统计各字母出现频次以及频次最大值（作为高），然后按层从高低扫描，层≤该字母出现频次的时候输出。 解题代码1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162#include &lt;bits/stdc++.h&gt;using namespace std;typedef long long ll;typedef unsigned long long ull;const int maxn = 1e5 + 5;#define rep(i, a, n) for (int i = a; i &lt; n; ++i)#define per(i, a, n) for (int i = n - 1; i &gt;= a; --i)#define fi first#define se second#define pb push_back#define np next_permutation#define mp make_pair#define endl '\n'int a[maxn];string s;int mmax;int main()&#123; ios::sync_with_stdio(false); mmax = -1; rep(i, 0, 4) &#123; getline(cin, s); rep(i, 0, s.length()) &#123; if (s[i] &gt;= 'A' &amp;&amp; s[i] &lt;= 'Z') &#123; a[s[i] - 'A']++; if (a[s[i] - 'A'] &gt; mmax) mmax = a[s[i] - 'A']; &#125; &#125; &#125; // rep(i, 0, 26) cout &lt;&lt; "#" &lt;&lt; a[i] &lt;&lt; endl; per(i, 1, mmax + 1) &#123; int target = 25; per(j, 0, 26) &#123; if (a[j] &gt;= i) &#123; target = j; break; &#125; &#125; if (a[0] &gt;= i) cout &lt;&lt; "*"; else cout &lt;&lt; " "; rep(j, 1, target + 1) &#123; if (a[j] &gt;= i) cout &lt;&lt; " *"; else cout &lt;&lt; " "; &#125; cout &lt;&lt; endl; &#125; cout &lt;&lt; 'A'; rep(i, 1, 26) cout &lt;&lt; " " &lt;&lt; char('A' + i); cout &lt;&lt; endl; cin &gt;&gt; mmax;&#125; 收获与反思主要输出格式]]></content>
      <categories>
        <category>编程</category>
        <category>ACM</category>
      </categories>
      <tags>
        <tag>编程</tag>
        <tag>ACM</tag>
        <tag>2019春季训练</tag>
        <tag>字符串</tag>
        <tag>洛谷</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[【洛谷-P1583】解题报告（排序）]]></title>
    <url>%2Fpost%2Fc544c33a.html</url>
    <content type="text"><![CDATA[原始题目P1603 斯诺登的密码 题目大意第一次根据初始权值分为10类（模10），第i类的人将会额外得到$E[i]$的权值，输出最终权值最大的k个人。 解题思路两次排序。 解题代码12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152#include &lt;bits/stdc++.h&gt;using namespace std;typedef long long ll;typedef unsigned long long ull;const int maxn = 1e5 + 5;#define rep(i, a, n) for (int i = a; i &lt; n; ++i)#define per(i, a, n) for (int i = n - 1; i &gt;= a; --i)#define fi first#define se second#define pb push_back#define np next_permutation#define mp make_pair#define endl '\n'int n, k;struct node &#123; int w, id;&#125;;node a[maxn];bool cmp(node a, node b)&#123; if (a.w != b.w) return a.w &gt; b.w; else return a.id &lt; b.id;&#125;int add[20];int main()&#123; ios::sync_with_stdio(false); while (cin &gt;&gt; n &gt;&gt; k) &#123; rep(i, 1, 10 + 1) cin &gt;&gt; add[i]; rep(i, 1, n + 1) &#123; cin &gt;&gt; a[i].w; a[i].id = i; &#125; sort(a + 1, a + n + 1, cmp); rep(i, 1, n + 1) &#123; a[i].w += add[(i - 1) % 10 + 1]; &#125; sort(a + 1, a + n + 1, cmp); cout &lt;&lt; a[1].id; rep(i, 2, k + 1) &#123; cout &lt;&lt; " " &lt;&lt; a[i].id; &#125; cout &lt;&lt; endl; &#125;&#125; 收获与反思无]]></content>
      <categories>
        <category>编程</category>
        <category>ACM</category>
      </categories>
      <tags>
        <tag>编程</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[【洛谷-P1553】解题报告（字符串）]]></title>
    <url>%2Fpost%2Fa2966b48.html</url>
    <content type="text"><![CDATA[原始题目P1553 数字反转（升级版） 题目大意小数，分数，百分数，整数按照对应的规则反转后输出。 解题思路按要求模拟操作就行 解题代码1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465666768697071#include &lt;bits/stdc++.h&gt;using namespace std;typedef long long ll;typedef unsigned long long ull;typedef vector&lt;int&gt; vi;typedef pair&lt;int, int&gt; pii;typedef pair&lt;string, string&gt; pss;#define rep(i, a, n) for (int i = a; i &lt; n; ++i)#define per(i, a, n) for (int i = n - 1; i &gt;= a; --i)#define fi first#define se second#define mp make_pair#define pb push_back#define all(x) x.begin(), x.end()const int maxn = 1e5 + 5;string s, s1, s2;//写成函数形式void checkprint(string sss)&#123; reverse(all(sss)); int flag = 1; rep(i, 0, sss.length()) &#123; if (sss[i] == '0' &amp;&amp; flag) continue; cout &lt;&lt; sss[i]; flag = 0; &#125; if (flag) cout &lt;&lt; 0;&#125;int main()&#123; ios::sync_with_stdio(false); while (cin &gt;&gt; s) &#123; int temp1 = s.find('/'); int temp2 = s.find('.'); int temp3 = s.find('%'); if (temp1 != -1) &#123; s1 = s.substr(0, temp1); s2 = s.substr(temp1 + 1, s.length() - s1.length() - 1); checkprint(s1); cout &lt;&lt; "/"; checkprint(s2); cout &lt;&lt; endl; &#125; else if (temp2 != -1) &#123; s1 = s.substr(0, temp2); checkprint(s1); cout &lt;&lt; "."; s2 = s.substr(temp2 + 1, s.length() - s1.length() - 1); int tempi = 0; while (tempi &lt; s2.length() &amp;&amp; s2[tempi] == '0') tempi++; if (tempi == s2.length()) cout &lt;&lt; 0 &lt;&lt; endl; else &#123; string s3 = s2.substr(tempi, s2.length() - tempi); reverse(all(s3)); cout &lt;&lt; s3 &lt;&lt; endl; &#125; &#125; else if (temp3 != -1) &#123; s1 = s.substr(0, temp3); checkprint(s1); cout &lt;&lt; "%" &lt;&lt; endl; &#125; else &#123; checkprint(s); cout &lt;&lt; endl; &#125; &#125;&#125; 收获与反思注意细节，印象中去0还有百分数开始写崩了。]]></content>
      <categories>
        <category>编程</category>
        <category>ACM</category>
      </categories>
      <tags>
        <tag>编程</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[【洛谷-P1540】解题报告（模拟）]]></title>
    <url>%2Fpost%2Fd2760377.html</url>
    <content type="text"><![CDATA[原始题目P1540 机器翻译 题目大意给出内存容量和查找数列，求访问外存数量 解题思路队列模拟（事后想想不需要，记录当前容量就行），vis数组记录状态。 解题代码12345678910111213141516171819202122232425262728293031323334353637383940414243#include &lt;bits/stdc++.h&gt;using namespace std;typedef long long ll;const int maxn = 1e5 + 5;#define rep(i, a, b) for (int i = a; i &lt; b; ++i)#define per(i, a, b) for (int i = b - 1; i &gt;= a; --i)int vis[maxn];queue&lt;int&gt; q;int n, m;int main()&#123; ios::sync_with_stdio(false); while (cin &gt;&gt; n &gt;&gt; m) &#123; // s.clear(); memset(vis, 0, sizeof(vis)); int ans = 0; rep(i, 0, m) &#123; int a; cin &gt;&gt; a; if (vis[a]) continue; else &#123; if (q.size() == n) &#123; int temp = q.front(); q.pop(); vis[temp] = 0; vis[a] = 1; q.push(a); ans++; &#125; else &#123; q.push(a); vis[a] = 1; ans++; &#125; &#125; &#125; cout &lt;&lt; ans &lt;&lt; endl; &#125; return 0;&#125; 收获与反思无]]></content>
      <categories>
        <category>编程</category>
        <category>ACM</category>
      </categories>
      <tags>
        <tag>编程</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[【洛谷-P1525】解题报告（二分图，二分）]]></title>
    <url>%2Fpost%2F749ff2bc.html</url>
    <content type="text"><![CDATA[原始题目P1525 关押罪犯 题目大意N个罪犯，M对矛盾关系，分成两个集合，同一集合的里有矛盾关系的会产生矛盾，冲突事件影响力为当前两个集合中矛盾关系值得最大值，求怎么分配使得冲突最小 解题思路 二分图+二分答案 博客中作为二分图的练习题，二分冲突影响（答案），判断在该条件下能否构成二分图（矛盾值小于判断答案的就忽略该条边）。 并查集+贪心 按值从大大小排序所有的冲突值，然后按序判断当前边连接两点是否已在一个集合中，若在则跳出判断输出当前冲突变得值，若在则秉持敌人的敌人当朋友进行Merge，可以证明，Merge到的集合内就算产生了新的冲突，由于我们是按冲突值从大到小访问的，矛盾（该变会在更靠前位置拆分，不会出现这种情况）。而且满足最优子结构，全局解必然包括当前的最优解。 解题代码二分图+二分答案 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465666768697071727374757677787980818283848586878889909192#include &lt;bits/stdc++.h&gt;using namespace std;typedef long long ll;typedef unsigned long long ull;typedef vector&lt;int&gt; vi;typedef pair&lt;int, int&gt; pii;#define rep(i, a, n) for (int i = a; i &lt; n; ++i)#define per(i, a, n) for (int i = n - 1; i &gt;= a; --i)#define fi first#define pb push_back#define mp make_pair#define EPS 1e-8#define INF 0x3f3f3f3f3f#define endl '\n'#define all(x) x.bgein(), x.end()const int maxn = 2e4 + 5;const int maxm = 2e5 + 5;struct Edge &#123; int u, v, w; Edge(int _u, int _v, int _w) : u(_u) , v(_v) , w(_w) &#123; &#125; Edge() &#123;&#125; bool operator&lt;(const Edge b) &#123; return w &gt; b.w; &#125;&#125; p[maxm];vector&lt;pii&gt; e[maxn];int n, m, k, t, vis[maxn];inline void init()&#123; rep(i, 0, n + 1) e[i].clear();&#125;bool dfs(int x, int co)&#123; vis[x] = co; rep(i, 0, e[x].size()) &#123; int y = e[x][i].first; if (vis[y] == co) return 0; else if (!vis[y] &amp;&amp; !dfs(y, 3 - co)) return 0; &#125; return 1;&#125;inline bool pd(int mid)&#123; init(); memset(vis, 0, sizeof(vis)); rep(i, 0, m) &#123; if (p[i].w &lt;= mid) break; e[p[i].u].pb(mp(p[i].v, p[i].w)); e[p[i].v].pb(mp(p[i].u, p[i].w)); &#125; rep(i, 1, n + 1) &#123; if (!vis[i] &amp;&amp; !dfs(i, 1)) return 0; &#125; return 1;&#125;int main()&#123; ios::sync_with_stdio(false); while (cin &gt;&gt; n &gt;&gt; m) &#123; rep(i, 0, m) &#123; cin &gt;&gt; p[i].u &gt;&gt; p[i].v &gt;&gt; p[i].w; &#125; sort(p, p + m); int l = 0, r = p[0].w, mid; while (l &lt; r) &#123; mid = (l + r) &gt;&gt; 1; if (pd(mid)) r = mid; else l = mid + 1; &#125; cout &lt;&lt; l &lt;&lt; endl; &#125;&#125; 并查集（待补充） 收获与反思二分图判定染色法（待补充）]]></content>
      <categories>
        <category>编程</category>
        <category>ACM</category>
      </categories>
      <tags>
        <tag>编程</tag>
        <tag>ACM</tag>
        <tag>2019春季训练</tag>
        <tag>二分</tag>
        <tag>并查集</tag>
        <tag>待补充</tag>
        <tag>洛谷</tag>
        <tag>二分图</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[【洛谷-P1243】解题报告（排序）]]></title>
    <url>%2Fpost%2F89d4cd71.html</url>
    <content type="text"><![CDATA[原始题目P1243 排序集合 题目大意对于集合 $N={1,2,⋯,n} $的子集，输出第k小的集合。小于关系为字典序。 解题思路这个题不是二进制位序，回溯根据第n+1-k大输出对应位置，可以提前预处理出后面元素数的前缀和（1,3,7,15…），然后用lower_bound确定位置。 解题代码1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465666768697071#include &lt;bits/stdc++.h&gt;using namespace std;typedef long long ll;typedef unsigned long long ull;typedef vector&lt;int&gt; vi;typedef pair&lt;int, int&gt; pii;typedef pair&lt;string, string&gt; pss;#define rep(i, a, n) for (int i = a; i &lt; n; ++i)#define per(i, a, n) for (int i = n - 1; i &gt;= a; --i)#define fi first#define se second#define pb push_back#define np next_permutation#define mp make_pair#define endl '\n'#define INF 0x3f3f3f3fconst int maxn = 1e5 + 5;ll a[maxn], presum[maxn];void init()&#123; a[0] = presum[0] = 1; rep(i, 1, 33) &#123; a[i] = a[i - 1] * 2; presum[i] = presum[i - 1] + a[i]; &#125;&#125;ll n, t;vi ans;void solve(ll start, ll len, ll cnt)&#123; // cout &lt;&lt; "(" &lt;&lt; start &lt;&lt; " " &lt;&lt; len &lt;&lt; " " &lt;&lt; cnt &lt;&lt; ")" &lt;&lt; endl; int index = lower_bound(presum, presum + len, cnt) - presum; // cout &lt;&lt; "len-index=" &lt;&lt; len - index &lt;&lt; endl; if (cnt == presum[index - 1]) &#123; ans.pb(start + len - index + 1); return; &#125; if (index == len) &#123; return; &#125; ans.pb(start + len - index); solve(start + len - index, index, cnt - presum[index - 1]);&#125;int main()&#123; // ios::sync_with_stdio(false); init(); while (cin &gt;&gt; n &gt;&gt; t) &#123; ans.clear(); ll temp = 2; rep(i, 1, n) temp *= 2; solve(0, n, temp + 1 - t); if (!ans.size()) &#123; cout &lt;&lt; "0" &lt;&lt; endl; continue; &#125; cout &lt;&lt; ans[0]; rep(i, 1, ans.size()) &#123; cout &lt;&lt; " " &lt;&lt; ans[i]; &#125; cout &lt;&lt; endl; &#125;&#125; 收获与反思这个题感觉应该有更好的做法]]></content>
      <categories>
        <category>编程</category>
        <category>ACM</category>
      </categories>
      <tags>
        <tag>编程</tag>
        <tag>ACM</tag>
        <tag>2019春季训练</tag>
        <tag>待补充</tag>
        <tag>洛谷</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[【洛谷-P1200】解题报告（字符串）]]></title>
    <url>%2Fpost%2Fb133bf62.html</url>
    <content type="text"><![CDATA[原始题目P1200 [USACO1.1]你的飞碟在这儿 题目大意字母’A’~’Z’对应1到26，字符串hash为对应值相乘mod47，若两字符串相等则输出”GO”,否则”STAY”. 解题思路字符串hash 解题代码123456789101112131415161718192021222324252627282930313233343536373839404142#include &lt;bits/stdc++.h&gt;#include &lt;sstream&gt;using namespace std;typedef long long ll;typedef unsigned long long ull;typedef vector&lt;int&gt; vi;typedef pair&lt;int, int&gt; pii;typedef pair&lt;string, string&gt; pss;#define rep(i, a, n) for (int i = a; i &lt; n; ++i)#define per(i, a, n) for (int i = n - 1; i &gt;= a; --i)#define fi first#define se second#define pb push_back#define mp make_pair#define np next_permutation#define INF 0x3f3f3f3f#define EPS 1e-8#define endl '\n'string a, b;const int mod = 47;const int maxn = 1e5 + 5;int main()&#123; ios::sync_with_stdio(false); while (cin &gt;&gt; a &gt;&gt; b) &#123; int ans = 1, ans2 = 1; rep(i, 0, a.length()) &#123; ans = (ans * (a[i] - 'A' + 1)) % mod; &#125; rep(i, 0, b.length()) &#123; ans2 = (ans2 * (b[i] - 'A' + 1)) % mod; &#125; if (ans == ans2) cout &lt;&lt; "GO" &lt;&lt; endl; else cout &lt;&lt; "STAY" &lt;&lt; endl; &#125;&#125; 收获与反思字符串hash入门]]></content>
      <categories>
        <category>编程</category>
        <category>ACM</category>
      </categories>
      <tags>
        <tag>编程</tag>
        <tag>ACM</tag>
        <tag>2019春季训练</tag>
        <tag>洛谷</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[【洛谷-P1177】解题报告（排序）]]></title>
    <url>%2Fpost%2F6eaa7771.html</url>
    <content type="text"><![CDATA[原始题目P1177 【模板】快速排序 题目大意快排模板不解释 解题思路快排模板不解释 解题代码1234567891011121314151617181920212223242526272829303132333435363738394041#include &lt;bits/stdc++.h&gt;using namespace std;typedef long long ll;typedef unsigned long long ull;const int maxn = 1e5 + 5;#define rep(i, a, n) for (int i = a; i &lt; n; ++i)#define per(i, a, n) for (int i = n - 1; i &gt;= a; --i)#define fi first#define se second#define pb push_back#define np next_permutation#define mp make_pairint a[maxn], n, vis[maxn];int main()&#123; ios::sync_with_stdio(false); while (cin &gt;&gt; n) &#123; memset(vis, 0, sizeof(vis)); int cnt = 0; rep(i, 0, n) &#123; int temp; cin &gt;&gt; temp; if (!vis[temp]) &#123; a[cnt++] = temp; vis[temp] = 1; &#125; &#125; sort(a, a + cnt); cout &lt;&lt; cnt &lt;&lt; "\n"; cout &lt;&lt; a[0]; rep(i, 1, cnt) &#123; cout &lt;&lt; " " &lt;&lt; a[i]; &#125; cout &lt;&lt; "\n"; &#125;&#125; 收获与反思无]]></content>
      <categories>
        <category>编程</category>
        <category>ACM</category>
      </categories>
      <tags>
        <tag>编程</tag>
        <tag>ACM</tag>
        <tag>2019春季训练</tag>
        <tag>洛谷</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[【Aizu-ITP2_11_C】解题报告（二进制枚举）]]></title>
    <url>%2Fpost%2F88a7282d.html</url>
    <content type="text"><![CDATA[原始题目Aizu-ITP2_11_C Aizu原始题面 Aizu-ITP2_11_C Vj题面 题目大意给定集合大小，同时给定一个子集k，要求输出子集是该子集k的子集。同时输出其在原集合所有子集中的二进制序编号，根据二进制编号从小到大依次输出符合的子集。 解题思路本题$n≤28$还可以枚举全部子集计数求其编号，一一枚举原集合子集计数然后判断会超时。 直接枚举给定子集k的子集，但是要根据其中元素计算在原集合所有子集中的二进制序编号。 实际上，编号就是该元素放在原集合子集中的二进制表示，由于题目本身就是原数字，所以直接二进制位运算可计算出其序号sum += (1 &lt;&lt; a[j])。 解题代码1234567891011121314151617181920212223242526272829303132333435363738394041424344#include &lt;bits/stdc++.h&gt;using namespace std;typedef long long ll;typedef unsigned long long ull;ll a[100], n, m;#define rep(i, a, n) for (ll i = a; i &lt; n; ++i)#define per(i, a, n) for (ll i = n - 1; i &gt;= a; --i)void print_subset(ll n, ll m)&#123; rep(i, 0, (1 &lt;&lt; m)) &#123; ll sum = 0; ll temp[100]; int ccnt = 0; rep(j, 0, m) &#123; //注意位运算的顺序 if (((1 &lt;&lt; j) &amp; i)) &#123; temp[ccnt++] = a[j]; sum += (1 &lt;&lt; a[j]); &#125; &#125; cout &lt;&lt; sum &lt;&lt; ":"; rep(j, 0, ccnt) &#123; cout &lt;&lt; " " &lt;&lt; temp[j]; &#125; cout &lt;&lt; endl; &#125;&#125;int main()&#123; ios::sync_with_stdio(false); while (cin &gt;&gt; n) &#123; cin &gt;&gt; m; rep(i, 0, m) cin &gt;&gt; a[i]; sort(a, a + m); print_subset(n, m); &#125;&#125; 收获与反思直接根据元素构成计算其在全部子集中的序号。]]></content>
      <categories>
        <category>编程</category>
        <category>ACM</category>
      </categories>
      <tags>
        <tag>编程</tag>
        <tag>ACM</tag>
        <tag>Aizu</tag>
        <tag>2019春季训练</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[【Aizu-ITP2_11_B】解题报告（二进制枚举）]]></title>
    <url>%2Fpost%2F8573f32.html</url>
    <content type="text"><![CDATA[原始题目Aizu-ITP2_11_B Aizu原始题面 Aizu-ITP2_11_B Vj题面 题目大意给定集合大小，同时给定一个子集k，要求输出子集包含该子集k。同时输出其在原集合所有子集中的二进制序编号，根据二进制编号从小到大依次输出符合的子集。 解题思路本题$n≤18$还可以枚举全部子集计数求其编号，对于每个子集判断是否包含所有要求包含元素（该位与运算），满足的话最后输出。 解题代码1234567891011121314151617181920212223242526272829303132333435363738394041424344454647#include &lt;bits/stdc++.h&gt;using namespace std;typedef long long ll;typedef unsigned long long ull;ll checknum[100], n, m;#define rep(i, a, n) for (ll i = a; i &lt; n; ++i)#define per(i, a, n) for (ll i = n - 1; i &gt;= a; --i)void print_subset(ll n, ll m)&#123; ll ans = 0; rep(i, 0, (1 &lt;&lt; n)) &#123; ans++; int flag = 1; rep(j, 0, m) &#123; //注意位运算的顺序 if (((1 &lt;&lt; checknum[j]) &amp; i) == 0) &#123; flag = 0; break; &#125; &#125; if (!flag) continue; cout &lt;&lt; ans - 1 &lt;&lt; ":"; rep(j, 0, n) &#123; if ((1 &lt;&lt; j) &amp; i) cout &lt;&lt; " " &lt;&lt; j; &#125; cout &lt;&lt; endl; &#125;&#125;int main()&#123; ios::sync_with_stdio(false); while (cin &gt;&gt; n) &#123; memset(checknum, 0, sizeof(checknum)); cin &gt;&gt; m; rep(i, 0, m) cin &gt;&gt; checknum[i]; print_subset(n, m); &#125;&#125; 收获与反思枚举子集常见的思路，参见。]]></content>
      <categories>
        <category>编程</category>
        <category>ACM</category>
      </categories>
      <tags>
        <tag>编程</tag>
        <tag>ACM</tag>
        <tag>Aizu</tag>
        <tag>2019春季训练</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[【Aizu-ITP2_11_A】解题报告（二进制枚举）]]></title>
    <url>%2Fpost%2F52360052.html</url>
    <content type="text"><![CDATA[原始题目Aizu-ITP2_11_A Aizu原始题面 Aizu-ITP2_11_A Vj题面 题目大意根据二进制序编号，从0开始输出子集。 解题思路枚举所有二进制可能，然后根据各位情况输出元素。 解题代码123456789101112131415161718192021222324252627282930313233343536#include &lt;bits/stdc++.h&gt;using namespace std;typedef long long ll;#define rep(i, a, n) for (ll i = a; i &lt; n; ++i)#define per(i, a, n) for (ll i = n - 1; i &gt;= a; --i)#define fi first#define se second#define mp mkae_pair#define pb push_back#define endl '\n'll n;void print_subset(ll n)&#123; ll cnt = 0; rep(i, 0, (1 &lt;&lt; n)) &#123; cout &lt;&lt; cnt++ &lt;&lt; ":"; rep(j, 0, n) &#123; if ((1 &lt;&lt; j) &amp; i) &#123; cout &lt;&lt; " " &lt;&lt; j; &#125; &#125; cout &lt;&lt; endl; &#125;&#125;int main()&#123; ios::sync_with_stdio(false); while (cin &gt;&gt; n) &#123; print_subset(n); &#125;&#125; 收获与反思枚举子集常见的思路 回溯法(根据排列好的子集字典序输出) 123456789101112131415void print_subset1(int N, int* A, int cnt)&#123; cout &lt;&lt; "&#123;"; rep(i, 0, cnt) &#123; cout &lt;&lt; A[i] &lt;&lt; " "; &#125; cout &lt;&lt; "&#125;" &lt;&lt; endl; int nxt = cnt ? A[cnt - 1] + 1 : 0; rep(i, nxt, N) &#123; A[cnt] = i; print_subset1(N, A, cnt + 1); &#125;&#125; 枚举二进制位 12345678910111213void print_subset2(int N, int* A)&#123; rep(i, 0, (1 &lt;&lt; N)) &#123; cout &lt;&lt; "&#123;"; rep(j, 0, N) &#123; if ((1 &lt;&lt; j) &amp; i) cout &lt;&lt; A[j] &lt;&lt; " "; &#125; cout &lt;&lt; "&#125;" &lt;&lt; endl; &#125;&#125;]]></content>
      <categories>
        <category>编程</category>
        <category>ACM</category>
      </categories>
      <tags>
        <tag>编程</tag>
        <tag>ACM</tag>
        <tag>Aizu</tag>
        <tag>2019春季训练</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[【洛谷-P1009】解题报告（高精度）]]></title>
    <url>%2Fpost%2Fea5d5d2f.html</url>
    <content type="text"><![CDATA[原始题目P1009 阶乘之和 题目大意阶乘之和 解题思路爆ll，需要高精度，上ACM大数模板或者 人生苦短，我用PY 解题代码123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147148149150151152153154155156157158159160161162163164165166167168169170171172173174175176177178179180181182183184185186187188189190191192193194195196197198199200201202203204205206207208209210211212213214215216217218219220221222223224225226227228229230231232233234235236237238239240241242243244245246247248249250251252253254255256257258259260261262263264265266267268269270271272273274275276277278279280281282283284285286287288289290291292293294295296297298299#include &lt;bits/stdc++.h&gt;using namespace std;typedef long long ll;typedef unsigned long long ull;typedef pair&lt;int, int&gt; pii;#define rep(i, a, n) for (int i = a; i &lt; n; ++i)#define per(i, a, n) for (int i = n - 1; i &gt;= a; --i)#define pb push_back#define MAXN 9999#define MAXSIZE 10#define DLEN 4class BigNum &#123;private: int a[500]; //可以控制大数的位数 int len; //大数长度public: BigNum() &#123; len = 1; memset(a, 0, sizeof(a)); &#125; //构造函数 BigNum(const int); //将一个int类型的变量转化为大数 BigNum(const char*); //将一个字符串类型的变量转化为大数 BigNum(const BigNum&amp;); //拷贝构造函数 BigNum&amp; operator=(const BigNum&amp;); //重载赋值运算符，大数之间进行赋值运算 friend istream&amp; operator&gt;&gt;(istream&amp;, BigNum&amp;); //重载输入运算符 friend ostream&amp; operator&lt;&lt;(ostream&amp;, BigNum&amp;); //重载输出运算符 BigNum operator+(const BigNum&amp;) const; //重载加法运算符，两个大数之间的相加运算 BigNum operator-(const BigNum&amp;) const; //重载减法运算符，两个大数之间的相减运算 BigNum operator*(const BigNum&amp;)const; //重载乘法运算符，两个大数之间的相乘运算 BigNum operator/(const int&amp;) const; //重载除法运算符，大数对一个整数进行相除运算 BigNum operator^(const int&amp;) const; //大数的n次方运算 int operator%(const int&amp;) const; //大数对一个int类型的变量进行取模运算 bool operator&gt;(const BigNum&amp; T) const; //大数和另一个大数的大小比较 bool operator&gt;(const int&amp; t) const; //大数和一个int类型的变量的大小比较 void print(); //输出大数&#125;;BigNum::BigNum(const int b) //将一个int类型的变量转化为大数&#123; int c, d = b; len = 0; memset(a, 0, sizeof(a)); while (d &gt; MAXN) &#123; c = d - (d / (MAXN + 1)) * (MAXN + 1); d = d / (MAXN + 1); a[len++] = c; &#125; a[len++] = d;&#125;BigNum::BigNum(const char* s) //将一个字符串类型的变量转化为大数&#123; int t, k, index, l, i; memset(a, 0, sizeof(a)); l = strlen(s); len = l / DLEN; if (l % DLEN) len++; index = 0; for (i = l - 1; i &gt;= 0; i -= DLEN) &#123; t = 0; k = i - DLEN + 1; if (k &lt; 0) k = 0; for (int j = k; j &lt;= i; j++) t = t * 10 + s[j] - '0'; a[index++] = t; &#125;&#125;BigNum::BigNum(const BigNum&amp; T) : len(T.len) //拷贝构造函数&#123; int i; memset(a, 0, sizeof(a)); for (i = 0; i &lt; len; i++) a[i] = T.a[i];&#125;BigNum&amp; BigNum::operator=(const BigNum&amp; n) //重载赋值运算符，大数之间进行赋值运算&#123; int i; len = n.len; memset(a, 0, sizeof(a)); for (i = 0; i &lt; len; i++) a[i] = n.a[i]; return *this;&#125;istream&amp; operator&gt;&gt;(istream&amp; in, BigNum&amp; b) //重载输入运算符&#123; char ch[MAXSIZE * 4]; int i = -1; in &gt;&gt; ch; int l = strlen(ch); int count = 0, sum = 0; for (i = l - 1; i &gt;= 0;) &#123; sum = 0; int t = 1; for (int j = 0; j &lt; 4 &amp;&amp; i &gt;= 0; j++, i--, t *= 10) &#123; sum += (ch[i] - '0') * t; &#125; b.a[count] = sum; count++; &#125; b.len = count++; return in;&#125;ostream&amp; operator&lt;&lt;(ostream&amp; out, BigNum&amp; b) //重载输出运算符&#123; int i; cout &lt;&lt; b.a[b.len - 1]; for (i = b.len - 2; i &gt;= 0; i--) &#123; cout.width(DLEN); cout.fill('0'); cout &lt;&lt; b.a[i]; &#125; return out;&#125;BigNum BigNum::operator+(const BigNum&amp; T) const //两个大数之间的相加运算&#123; BigNum t(*this); int i, big; //位数 big = T.len &gt; len ? T.len : len; for (i = 0; i &lt; big; i++) &#123; t.a[i] += T.a[i]; if (t.a[i] &gt; MAXN) &#123; t.a[i + 1]++; t.a[i] -= MAXN + 1; &#125; &#125; if (t.a[big] != 0) t.len = big + 1; else t.len = big; return t;&#125;BigNum BigNum::operator-(const BigNum&amp; T) const //两个大数之间的相减运算&#123; int i, j, big; bool flag; BigNum t1, t2; if (*this &gt; T) &#123; t1 = *this; t2 = T; flag = 0; &#125; else &#123; t1 = T; t2 = *this; flag = 1; &#125; big = t1.len; for (i = 0; i &lt; big; i++) &#123; if (t1.a[i] &lt; t2.a[i]) &#123; j = i + 1; while (t1.a[j] == 0) j++; t1.a[j--]--; while (j &gt; i) t1.a[j--] += MAXN; t1.a[i] += MAXN + 1 - t2.a[i]; &#125; else t1.a[i] -= t2.a[i]; &#125; t1.len = big; while (t1.a[t1.len - 1] == 0 &amp;&amp; t1.len &gt; 1) &#123; t1.len--; big--; &#125; if (flag) t1.a[big - 1] = 0 - t1.a[big - 1]; return t1;&#125;BigNum BigNum::operator*(const BigNum&amp; T) const //两个大数之间的相乘运算&#123; BigNum ret; int i, j, up; int temp, temp1; for (i = 0; i &lt; len; i++) &#123; up = 0; for (j = 0; j &lt; T.len; j++) &#123; temp = a[i] * T.a[j] + ret.a[i + j] + up; if (temp &gt; MAXN) &#123; temp1 = temp - temp / (MAXN + 1) * (MAXN + 1); up = temp / (MAXN + 1); ret.a[i + j] = temp1; &#125; else &#123; up = 0; ret.a[i + j] = temp; &#125; &#125; if (up != 0) ret.a[i + j] = up; &#125; ret.len = i + j; while (ret.a[ret.len - 1] == 0 &amp;&amp; ret.len &gt; 1) ret.len--; return ret;&#125;BigNum BigNum::operator/(const int&amp; b) const //大数对一个整数进行相除运算&#123; BigNum ret; int i, down = 0; for (i = len - 1; i &gt;= 0; i--) &#123; ret.a[i] = (a[i] + down * (MAXN + 1)) / b; down = a[i] + down * (MAXN + 1) - ret.a[i] * b; &#125; ret.len = len; while (ret.a[ret.len - 1] == 0 &amp;&amp; ret.len &gt; 1) ret.len--; return ret;&#125;int BigNum::operator%(const int&amp; b) const //大数对一个int类型的变量进行取模运算&#123; int i, d = 0; for (i = len - 1; i &gt;= 0; i--) &#123; d = ((d * (MAXN + 1)) % b + a[i]) % b; &#125; return d;&#125;BigNum BigNum::operator^(const int&amp; n) const //大数的n次方运算&#123; BigNum t, ret(1); int i; if (n &lt; 0) exit(-1); if (n == 0) return 1; if (n == 1) return *this; int m = n; while (m &gt; 1) &#123; t = *this; for (i = 1; i &lt;&lt; 1 &lt;= m; i &lt;&lt;= 1) &#123; t = t * t; &#125; m -= i; ret = ret * t; if (m == 1) ret = ret * (*this); &#125; return ret;&#125;bool BigNum::operator&gt;(const BigNum&amp; T) const //大数和另一个大数的大小比较&#123; int ln; if (len &gt; T.len) return true; else if (len == T.len) &#123; ln = len - 1; while (a[ln] == T.a[ln] &amp;&amp; ln &gt;= 0) ln--; if (ln &gt;= 0 &amp;&amp; a[ln] &gt; T.a[ln]) return true; else return false; &#125; else return false;&#125;bool BigNum::operator&gt;(const int&amp; t) const //大数和一个int类型的变量的大小比较&#123; BigNum b(t); return *this &gt; b;&#125;void BigNum::print() //输出大数&#123; int i; cout &lt;&lt; a[len - 1]; for (i = len - 2; i &gt;= 0; i--) &#123; cout.width(DLEN); cout.fill('0'); cout &lt;&lt; a[i]; &#125; cout &lt;&lt; endl;&#125;int n;int main()&#123; ios::sync_with_stdio(false); while (cin &gt;&gt; n) &#123; BigNum ans = 0; for (int i = 1; i &lt;= n; ++i) &#123; BigNum temp = 1; rep(j, 1, i + 1) &#123; temp = temp * j; &#125; ans = ans + temp; &#125; ans.print(); &#125;&#125; 12345678num = int(input())sum = 0for i in range(1,num+1): cnt = 1 for j in range(1,i+1): cnt*=j sum+=cntprint(sum) 收获与总结无]]></content>
      <categories>
        <category>编程</category>
        <category>ACM</category>
      </categories>
      <tags>
        <tag>编程</tag>
        <tag>ACM</tag>
        <tag>2019春季训练</tag>
        <tag>洛谷</tag>
        <tag>高精度</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[【洛谷-P1089】解题报告（水题）]]></title>
    <url>%2Fpost%2Fd0d58037.html</url>
    <content type="text"><![CDATA[原始题目P1089 津津的储蓄计划 题目大意月初估算，多余的存，如果某月得到零花钱不足预算，则输出-X，X位月份，否则输出最后金钱（存储的变1.2倍）。 解题思路水题 解题代码12345678910111213141516171819202122232425262728293031323334353637383940414243#include &lt;bits/stdc++.h&gt;using namespace std;typedef long long ll;typedef unsigned long long ull;typedef vector&lt;int&gt; vi;typedef pair&lt;int, int&gt; pii;typedef pair&lt;string, string&gt; pss;#define rep(i, a, n) for (int i = a; i &lt; n; ++i)#define per(i, a, n) for (int i = n - 1; i &gt;= a; --i)#define fi first#define se second#define all(x) x.begin(), x.end()#define mp make_pair#define pb push_back#define np next_permutation#define INF 0x3f3f3f3f#define EPS 1e-8#define endl '\n'const int maxn = 1e5 + 5;int ans, cnt, num, save;int a[maxn];int main()&#123; ios::sync_with_stdio(false); rep(i, 1, 12 + 1) cin &gt;&gt; a[i]; rep(i, 1, 12 + 1) &#123; cnt += 300; cnt -= a[i]; if (cnt &lt; 0) &#123; cout &lt;&lt; '-' &lt;&lt; i &lt;&lt; endl; break; &#125; save += (cnt / 100); cnt %= 100; &#125; if (cnt &gt;= 0) &#123; cnt += save * 120; cout &lt;&lt; cnt &lt;&lt; endl; &#125;&#125; 收获与反思无]]></content>
      <categories>
        <category>编程</category>
        <category>ACM</category>
      </categories>
      <tags>
        <tag>编程</tag>
        <tag>ACM</tag>
        <tag>2019春季训练</tag>
        <tag>洛谷</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[【洛谷-P1085】解题报告（水题）]]></title>
    <url>%2Fpost%2Fdbad9cab.html</url>
    <content type="text"><![CDATA[原始题目P1085 不高兴的津津 题目大意阈值排序，没有则0，有输出相同最大值最小的坐标。 解题思路水题 解题代码1234567891011121314151617181920212223242526272829303132333435363738394041424344454647#include &lt;bits/stdc++.h&gt;using namespace std;typedef long long ll;typedef unsigned long long ull;typedef pair&lt;int, int&gt; pii;typedef pair&lt;string, string&gt; pss;typedef vector&lt;int&gt; vi;#define rep(i, a, n) for (int i = a; i &lt; n; ++i)#define per(i, a, n) for (int i = n - 1; i &gt;= a; --i)#define fi first#define se second#define mp make_pair#define np next_permutation#define pb push_back#define all(x) x.begin(), x.end()#define INF 0x3f3f3f3fvector&lt;pii&gt; ans;int mmax = -INF;bool cmp(pii a, pii b)&#123; if (a.second != b.second) &#123; return a.second &gt; b.second; &#125; else return a.fi &lt; b.fi;&#125;int main()&#123; ios::sync_with_stdio(false); rep(i, 1, 7 + 1) &#123; int a, b; cin &gt;&gt; a &gt;&gt; b; if (a + b &gt; 8) &#123; ans.pb(mp(i, a + b)); &#125; &#125; if (ans.size() == 0) cout &lt;&lt; 0 &lt;&lt; endl; else &#123; sort(all(ans), cmp); cout &lt;&lt; ans[0].first &lt;&lt; endl; &#125;&#125; 收获与反思无]]></content>
      <categories>
        <category>编程</category>
        <category>ACM</category>
      </categories>
      <tags>
        <tag>编程</tag>
        <tag>ACM</tag>
        <tag>洛谷</tag>
        <tag>2019春季集训</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[【洛谷-P1071】解题报告（字符串）]]></title>
    <url>%2Fpost%2F6aa464c0.html</url>
    <content type="text"><![CDATA[原始题目P1071 潜伏者 题目大意仅大写字母的放射密码。 所有信息扫描完毕，‘AA’-‘ZZ’ 所有 26 26个字母在原信息中均出现过并获得了相应的“密字”。 所有信息扫描完毕，但发现存在某个（或某些）字母在原信息中没有出现。 扫描中发现掌握的信息里有明显的自相矛盾或错误（违反 SS 国密码的编码规则）。 解题思路map映射储存然后判断是否满足1条件即可。 解题代码123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263// 数组类型和 映射都尝试一下#include &lt;bits/stdc++.h&gt;using namespace std;typedef long long ll;typedef unsigned long long ull;typedef vector&lt;int&gt; vi;typedef pair&lt;int, int&gt; pii;#define rep(i, a, n) for (int i = a; i &lt; n; ++i)#define per(i, a, n) for (int i = n - 1; i &gt;= a; --i)#define fi first#define se second#define mp make_pair#define np next_permutation#define pb puss_back#define endl '\n'#define all(x) x.begin(), x.end()string a, b, c;map&lt;char, char&gt; dic, dic2;bool check()&#123; dic.clear(); dic2.clear(); if (a.length() != b.length()) return false; rep(i, 0, a.length()) &#123; if (dic.count(a[i])) &#123; if (dic[a[i]] != b[i]) return false; &#125; else &#123; if (dic2.count(b[i]) &amp;&amp; dic2[b[i]] != a[i]) return false; dic[a[i]] = b[i]; dic2[b[i]] = a[i]; &#125; &#125; // cout &lt;&lt; dic.size() &lt;&lt; endl; if (dic2.size() == 26) return true; else return false;&#125;int main()&#123; ios::sync_with_stdio(false); while (cin &gt;&gt; a &gt;&gt; b &gt;&gt; c) &#123; if (!check()) cout &lt;&lt; "Failed" &lt;&lt; endl; else &#123; rep(i, 0, c.length()) &#123; cout &lt;&lt; dic[c[i]]; &#125; cout &lt;&lt; endl; &#125; &#125;&#125; 收获与反思无]]></content>
      <categories>
        <category>编程</category>
        <category>ACM</category>
      </categories>
      <tags>
        <tag>编程</tag>
        <tag>ACM</tag>
        <tag>2019春季训练</tag>
        <tag>字符串</tag>
        <tag>洛谷</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[【洛谷-P1068】解题报告（排序）]]></title>
    <url>%2Fpost%2F386b56e6.html</url>
    <content type="text"><![CDATA[原始题目P1068 分数线划定 题目大意取前150%分数，然后按照分数从高到低（不低于录取分数）输出。 解题思路排序后直接判断分数即可。 解题代码1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950#include &lt;bits/stdc++.h&gt;using namespace std;typedef long long ll;typedef unsigned long long ull;const int maxn = 1e5 + 5;#define rep(i, a, n) for (int i = a; i &lt; n; ++i)#define per(i, a, n) for (int i = n - 1; i &gt;= a; --i)#define fi first#define se second#define pb push_back#define np next_permutation#define mp make_pair#define endl '\n'struct node &#123; int id, score;&#125;;node a[maxn], ans[maxn];bool cmp(node a, node b)&#123; if (a.score != b.score) return a.score &gt; b.score; else return a.id &lt; b.id;&#125;int n, m;int main()&#123; ios::sync_with_stdio(false); while (cin &gt;&gt; n &gt;&gt; m) &#123; m = (int)(m * 1.5); if (m &gt; n) m = n; rep(i, 1, n + 1) cin &gt;&gt; a[i].id &gt;&gt; a[i].score; sort(a + 1, a + n + 1, cmp); int cnt = 1; while (cnt &lt;= n &amp;&amp; a[cnt].score &gt;= a[m].score) &#123; ans[cnt].id = a[cnt].id; ans[cnt].score = a[cnt].score; cnt++; &#125; cnt--; cout &lt;&lt; a[m].score &lt;&lt; " " &lt;&lt; cnt &lt;&lt; endl; rep(i, 1, cnt + 1) &#123; cout &lt;&lt; ans[i].id &lt;&lt; " " &lt;&lt; ans[i].score &lt;&lt; endl; &#125; &#125;&#125; 收获与反思无]]></content>
      <categories>
        <category>编程</category>
        <category>ACM</category>
      </categories>
      <tags>
        <tag>编程</tag>
        <tag>ACM</tag>
        <tag>2019春季训练</tag>
        <tag>洛谷</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[【洛谷-P1055】解题报告（字符串）]]></title>
    <url>%2Fpost%2F69feca91.html</url>
    <content type="text"><![CDATA[原始题目P1055 ISBN号码 题目大意对于每一个ISBN编号，最后末位是各位乘对应数组模11的结果，对于每一个ISBN检测是否符合要求。 解题思路按字符串输入做判断即可 解题代码1234567891011121314151617181920212223242526272829303132333435363738394041424344454647#include &lt;bits/stdc++.h&gt;#include &lt;sstream&gt;using namespace std;typedef long long ll;typedef unsigned long long ull;typedef vector&lt;int&gt; vi;typedef pair&lt;int, int&gt; pii;typedef pair&lt;string, string&gt; pss;#define rep(i, a, n) for (int i = a; i &lt; n; ++i)#define per(i, a, n) for (int i = n - 1; i &gt;= a; --i)#define fi first#define se second#define pb push_back#define mp make_pair#define np next_permutation#define INF 0x3f3f3f3f#define EPS 1e-8#define endl '\n'int main()&#123; ios::sync_with_stdio(false); string s; while (cin &gt;&gt; s) &#123; stringstream ss(s); char checkstring[20], temp; int cnt = 1; while (ss &gt;&gt; temp) &#123; if (temp != '-') checkstring[cnt++] = temp; &#125; int ans = 0; rep(i, 1, 10) ans += (checkstring[i] - '0') * i; ans %= 11; if (ans == 10) ans = 'X'; else ans += '0'; if (ans != checkstring[10]) &#123; rep(i, 0, s.length() - 1) cout &lt;&lt; s[i]; cout &lt;&lt; (char)ans &lt;&lt; endl; &#125; else cout &lt;&lt; "Right" &lt;&lt; endl; &#125;&#125; 收获与反思无]]></content>
      <categories>
        <category>编程</category>
        <category>ACM</category>
      </categories>
      <tags>
        <tag>编程</tag>
        <tag>ACM</tag>
        <tag>2019春季训练</tag>
        <tag>字符串</tag>
        <tag>洛谷</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[【洛谷-P1051】解题报告（模拟）]]></title>
    <url>%2Fpost%2F7d274866.html</url>
    <content type="text"><![CDATA[原始题目text 题目大意解题思路解题代码]]></content>
      <categories>
        <category>编程</category>
        <category>ACM</category>
      </categories>
      <tags>
        <tag>编程</tag>
        <tag>ACM</tag>
        <tag>2019春季训练</tag>
        <tag>待补充</tag>
        <tag>洛谷</tag>
        <tag>imitation</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[【洛谷-P1035】解题报告（水题）]]></title>
    <url>%2Fpost%2Fd0793265.html</url>
    <content type="text"><![CDATA[原始题目P1035 题目大意对于调和级数，求最小的n使得调和级数求和大于给定的k。 解题思路水题 解题代码1234567891011121314151617181920212223242526272829303132333435363738#include &lt;bits/stdc++.h&gt;using namespace std;typedef long long ll;typedef unsigned long long ull;typedef vector&lt;int&gt; vi;typedef pair&lt;int, int&gt; pii;typedef pair&lt;string, string&gt; pss;#define rep(i, a, n) for (int i = a; i &lt; n; ++i)#define per(i, a, n) for (int i = n - 1; i &gt;= a; --i)#define fi first#define se second#define mp make_pair#define np next_permutation#define pb push_back#define tol(x, y) std::transform(x.begin(), x.end(), y.begin(), ::tolower)#define tou(x, y) std::transform(x.begin(), x.end(), y.begin(), ::toupper)#define all(x) x.begin(), x.end()#define INF 0x3f3f3f3f#define EPS 1e-8int m, t;ll n;double ans;int main()&#123; ios::sync_with_stdio(false); while (cin &gt;&gt; n) &#123; ans = 0; ll i; for (i = 1; ans + 1.0 / i &lt;= n + EPS; i++) &#123; ans += 1.0 / i; &#125; cout &lt;&lt; i &lt;&lt; endl; &#125;&#125; 收获与反思无]]></content>
      <categories>
        <category>编程</category>
        <category>ACM</category>
      </categories>
      <tags>
        <tag>编程</tag>
        <tag>ACM</tag>
        <tag>2019春季训练</tag>
        <tag>洛谷</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[【洛谷-P1010】解题报告（模拟）]]></title>
    <url>%2Fpost%2F2bfcd7aa.html</url>
    <content type="text"><![CDATA[原始题目P1010 幂次方 题目大意2表示2的1次方，2(0)表示2的0次方，所有的底数和指数都变为二进制表示形式，且仅有2和2(0)构成。 解题思路递归得到n的表示方法，输出字符串并记忆化存储到映射中。 注意: 开头部分处理+号 0,1作为边界不再继续递归 递归返回结果加入上一次调用构造的字符串。 解题代码123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869#include &lt;bits/stdc++.h&gt;using namespace std;typedef long long ll;typedef unsigned long long ull;typedef vector&lt;int&gt; vi;#define rep(i, a, n) for (int i = a; i &lt; n; ++i)#define per(i, a, n) for (int i = n - 1; i &gt;= a; --i)#define fi first#define se second#define mp make_pair#define np next_permutationint n;map&lt;int, string&gt; tostring;void init()&#123; tostring.clear(); tostring.insert(mp(0, "0")); tostring.insert(mp(1, "2(0)")); tostring.insert(mp(2, "2"));&#125;string solve(int n)&#123; if (tostring.count(n)) &#123; return tostring[n]; &#125; string temp = ""; int num = 1; while ((1 &lt;&lt; num) &lt;= n) num++; int flag = 1; per(i, 0, num) &#123; if ((1 &lt;&lt; i) &amp; n) &#123; if (flag) &#123; flag = 0; if (i == 1 || i == 0) &#123; temp += tostring[i + 1]; continue; &#125; temp += "2("; temp += solve(i); temp += ")"; &#125; else &#123; temp += "+"; if (i == 1 || i == 0) &#123; temp += tostring[i + 1]; continue; &#125; temp += "2("; temp += solve(i); temp += ")"; &#125; &#125; &#125; tostring.insert(mp(n, temp)); return temp;&#125;int main()&#123; ios::sync_with_stdio(false); init(); while (cin &gt;&gt; n) &#123; cout &lt;&lt; solve(n) &lt;&lt; endl; &#125;&#125; 收获与反思模拟+递归，注意处理的情况，记忆化。]]></content>
      <categories>
        <category>编程</category>
        <category>ACM</category>
      </categories>
      <tags>
        <tag>编程</tag>
        <tag>ACM</tag>
        <tag>2019春季训练</tag>
        <tag>洛谷</tag>
        <tag>imitation</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[【洛谷-P1008】解题报告（水题）]]></title>
    <url>%2Fpost%2F7fbcb888.html</url>
    <content type="text"><![CDATA[原始题目P1008 三连击 题目大意将$1,2, \cdots ,9$共$9$个数分成$3$组，分别组成$3$个三位数，且使这$3$个三位数构成$1:2:3$的比例，试求出所有满足条件的$3$个三位数。 解题思路注意无0的问题，暴力解。 解题代码123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384// 192 384 576// 219 438 657// 267 534 801 这个包含0去掉// 273 546 819// 327 654 981#include &lt;bits/stdc++.h&gt;using namespace std;const int maxn = 1e5 + 5;typedef long long ll;typedef unsigned long long ull;typedef vector&lt;int&gt; vi;#define rep(i, a, n) for (int i = a; i &lt; n; ++i)#define per(i, a, n) for (int i = n - 1; i &gt;= a; --i)#define fi first#define se second#define endl '\n'#define all(x) x.begin(), x.end()#define pb push_back#define np next_permutation#define mp make_pairint vis[maxn];bool check(int num)&#123; int a[6]; int num1 = 2 * num; int num2 = 3 * num; if (num2 &gt;= 999) return false; // if (num / 100 == 1) // cout &lt;&lt; num1 &lt;&lt; " " &lt;&lt; num2 &lt;&lt; endl; rep(i, 0, 3) &#123; a[i] = num1 % 10; num1 /= 10; &#125; rep(i, 3, 6) &#123; a[i] = num2 % 10; num2 /= 10; &#125; rep(i, 0, 6) &#123; if (vis[a[i]]) return false; vis[a[i]] = 1; &#125; return true;&#125;int main()&#123; ios::sync_with_stdio(false); rep(i, 1, 3 + 1) &#123; vis[i] = 1; rep(j, 1, 9 + 1) &#123; if (vis[j]) continue; vis[j] = 1; rep(k, 1, 9 + 1) &#123; vis[i] = vis[j] = 1; if (vis[k]) continue; vis[k] = 1; int temp = 100 * i + 10 * j + k; if (check(temp)) &#123; cout &lt;&lt; temp &lt;&lt; " " &lt;&lt; 2 * temp &lt;&lt; " " &lt;&lt; 3 * temp &lt;&lt; endl; &#125; memset(vis, 0, sizeof(vis)); &#125; vis[j] = 0; &#125; vis[i] = 0; &#125; int n; cin &gt;&gt; n;&#125; 收获与反思无]]></content>
      <categories>
        <category>编程</category>
        <category>ACM</category>
      </categories>
      <tags>
        <tag>编程</tag>
        <tag>ACM</tag>
        <tag>2019春季训练</tag>
        <tag>洛谷</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[【洛谷-P1940】解题报告（数学，大数）]]></title>
    <url>%2Fpost%2F81d45fa1.html</url>
    <content type="text"><![CDATA[原始题目P1940 Reversible Number 题目大意有些正整数n可能满足n + 回文(n)（回文(n)是把n倒过来写所得的数）得到的结果的各位都是奇数。那么，小于等于10^x的Reversible数有多少个？方便起见，x是大于等于3小于等于400的正整数。 解题思路很明显不可能是暴力的，题目范围给400位，所以暗示我们跟位数有关系。 暴力求前几位能得到下面数据 1-9 0 10-99 20 100-999 100 1000-9999 600 10000-99999 0 100000-999999 18000 1000000-9999999 50000 发现奇偶位是有规律的。 数学如下 偶数位数； 若要保证回文性质，要求全部位不能进位 可用反证法证明，推矛盾,所以有: even[2] = 20 , even[2n] = even[2(n-1)] * 30 奇数位数： 必然是 进位|不进位|进位 进位|不进位|进位|不进位|进位|不进位|进位 即模4余3位数时可以找到满足的reversible数。 odd[3] = [100], odd[4n+3] = odd[4(n-1)+3] * 500 暴力对拍代码 12345678910111213141516171819202122232425262728293031323334353637383940#include &lt;bits/stdc++.h&gt;using namespace std;typedef long long ll;#define rep(i, a, n) for (ll i = a; i &lt; n; ++i)#define per(i, a, n) for (ll i = n - 1; i &gt;= a; --i)ll n, m, N;int main()&#123; while (cin &gt;&gt; n &gt;&gt; m &gt;&gt; N) &#123; ll cnt = 0; rep(i, n, m + 1) &#123; ll flag = 1; if (i % 10 == 0) continue; ll temp = i; ll sum = temp; for (ll j = 0; j &lt; N; j++) &#123; ll addsum = temp % 10; for (ll k = 0; k &lt; N - j - 1; k++) sum += addsum; temp /= 10; &#125; temp = sum; while (temp) &#123; if ((temp &amp; 1) == 0) flag = 0; temp /= 10; &#125; // cout &lt;&lt; sum &lt;&lt; endl; if (flag) &#123; // cout &lt;&lt; "i=" &lt;&lt; i &lt;&lt; " sum=" &lt;&lt; sum &lt;&lt; endl; cnt++; &#125; &#125; cout &lt;&lt; cnt &lt;&lt; endl; &#125;&#125; 解题代码123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147148149150151152153154155156157158159160161162163164165166167168169170171172173174175176177178179180181182183184185186187188189190191192193194195196197198199200201202203204205206207208209210211212213214215216217218219220221222223224225226227228229230231232233234235236237238239240241242243244245246247248249250251252253254255256257258259260261262263264265266267268269270271272273274275276277278279280281282283284285286287288289290291292293294295296297298299300301302303304305306307308309310311312313314315316317318319320321322323324325326327328329330331332333334335336337// 1-9 0// 10-99 20// 100-999 100// 1000-9999 600// 10000-99999 0// 100000-999999 18000// 1000000-9999999 50000 ???//#include &lt;bits/stdc++.h&gt;using namespace std;#define rep(i, a, n) for (int i = a; i &lt; n; ++i)#define per(i, a, n) for (int i = n - 1; i &gt;= a; --i)#define fi first#define se second#define pb push_back#define np next_permutation#define INF 0x3f3f3f3f#define EPS 1e-8#define eps '\n'typedef long long ll;typedef unsigned long long ull;typedef pair&lt;int, int&gt; pii;typedef pair&lt;string, string&gt; pss;typedef vector&lt;int&gt; vi;#include &lt;algorithm&gt;#include &lt;iomanip&gt;#include &lt;iostream&gt;#include &lt;string&gt;using namespace std;#define MAXN 9999#define MAXSIZE 10#define DLEN 4class BigNum &#123;private: int a[500]; //可以控制大数的位数 int len; //大数长度public: BigNum() &#123; len = 1; memset(a, 0, sizeof(a)); &#125; //构造函数 BigNum(const int); //将一个int类型的变量转化为大数 BigNum(const char*); //将一个字符串类型的变量转化为大数 BigNum(const BigNum&amp;); //拷贝构造函数 BigNum&amp; operator=(const BigNum&amp;); //重载赋值运算符，大数之间进行赋值运算 friend istream&amp; operator&gt;&gt;(istream&amp;, BigNum&amp;); //重载输入运算符 friend ostream&amp; operator&lt;&lt;(ostream&amp;, BigNum&amp;); //重载输出运算符 BigNum operator+(const BigNum&amp;) const; //重载加法运算符，两个大数之间的相加运算 BigNum operator-(const BigNum&amp;) const; //重载减法运算符，两个大数之间的相减运算 BigNum operator*(const BigNum&amp;)const; //重载乘法运算符，两个大数之间的相乘运算 BigNum operator/(const int&amp;) const; //重载除法运算符，大数对一个整数进行相除运算 BigNum operator^(const int&amp;) const; //大数的n次方运算 int operator%(const int&amp;) const; //大数对一个int类型的变量进行取模运算 bool operator&gt;(const BigNum&amp; T) const; //大数和另一个大数的大小比较 bool operator&gt;(const int&amp; t) const; //大数和一个int类型的变量的大小比较 void print(); //输出大数&#125;;BigNum::BigNum(const int b) //将一个int类型的变量转化为大数&#123; int c, d = b; len = 0; memset(a, 0, sizeof(a)); while (d &gt; MAXN) &#123; c = d - (d / (MAXN + 1)) * (MAXN + 1); d = d / (MAXN + 1); a[len++] = c; &#125; a[len++] = d;&#125;BigNum::BigNum(const char* s) //将一个字符串类型的变量转化为大数&#123; int t, k, index, l, i; memset(a, 0, sizeof(a)); l = strlen(s); len = l / DLEN; if (l % DLEN) len++; index = 0; for (i = l - 1; i &gt;= 0; i -= DLEN) &#123; t = 0; k = i - DLEN + 1; if (k &lt; 0) k = 0; for (int j = k; j &lt;= i; j++) t = t * 10 + s[j] - '0'; a[index++] = t; &#125;&#125;BigNum::BigNum(const BigNum&amp; T) : len(T.len) //拷贝构造函数&#123; int i; memset(a, 0, sizeof(a)); for (i = 0; i &lt; len; i++) a[i] = T.a[i];&#125;BigNum&amp; BigNum::operator=(const BigNum&amp; n) //重载赋值运算符，大数之间进行赋值运算&#123; int i; len = n.len; memset(a, 0, sizeof(a)); for (i = 0; i &lt; len; i++) a[i] = n.a[i]; return *this;&#125;istream&amp; operator&gt;&gt;(istream&amp; in, BigNum&amp; b) //重载输入运算符&#123; char ch[MAXSIZE * 4]; int i = -1; in &gt;&gt; ch; int l = strlen(ch); int count = 0, sum = 0; for (i = l - 1; i &gt;= 0;) &#123; sum = 0; int t = 1; for (int j = 0; j &lt; 4 &amp;&amp; i &gt;= 0; j++, i--, t *= 10) &#123; sum += (ch[i] - '0') * t; &#125; b.a[count] = sum; count++; &#125; b.len = count++; return in;&#125;ostream&amp; operator&lt;&lt;(ostream&amp; out, BigNum&amp; b) //重载输出运算符&#123; int i; cout &lt;&lt; b.a[b.len - 1]; for (i = b.len - 2; i &gt;= 0; i--) &#123; cout.width(DLEN); cout.fill('0'); cout &lt;&lt; b.a[i]; &#125; return out;&#125;BigNum BigNum::operator+(const BigNum&amp; T) const //两个大数之间的相加运算&#123; BigNum t(*this); int i, big; //位数 big = T.len &gt; len ? T.len : len; for (i = 0; i &lt; big; i++) &#123; t.a[i] += T.a[i]; if (t.a[i] &gt; MAXN) &#123; t.a[i + 1]++; t.a[i] -= MAXN + 1; &#125; &#125; if (t.a[big] != 0) t.len = big + 1; else t.len = big; return t;&#125;BigNum BigNum::operator-(const BigNum&amp; T) const //两个大数之间的相减运算&#123; int i, j, big; bool flag; BigNum t1, t2; if (*this &gt; T) &#123; t1 = *this; t2 = T; flag = 0; &#125; else &#123; t1 = T; t2 = *this; flag = 1; &#125; big = t1.len; for (i = 0; i &lt; big; i++) &#123; if (t1.a[i] &lt; t2.a[i]) &#123; j = i + 1; while (t1.a[j] == 0) j++; t1.a[j--]--; while (j &gt; i) t1.a[j--] += MAXN; t1.a[i] += MAXN + 1 - t2.a[i]; &#125; else t1.a[i] -= t2.a[i]; &#125; t1.len = big; while (t1.a[t1.len - 1] == 0 &amp;&amp; t1.len &gt; 1) &#123; t1.len--; big--; &#125; if (flag) t1.a[big - 1] = 0 - t1.a[big - 1]; return t1;&#125;BigNum BigNum::operator*(const BigNum&amp; T) const //两个大数之间的相乘运算&#123; BigNum ret; int i, j, up; int temp, temp1; for (i = 0; i &lt; len; i++) &#123; up = 0; for (j = 0; j &lt; T.len; j++) &#123; temp = a[i] * T.a[j] + ret.a[i + j] + up; if (temp &gt; MAXN) &#123; temp1 = temp - temp / (MAXN + 1) * (MAXN + 1); up = temp / (MAXN + 1); ret.a[i + j] = temp1; &#125; else &#123; up = 0; ret.a[i + j] = temp; &#125; &#125; if (up != 0) ret.a[i + j] = up; &#125; ret.len = i + j; while (ret.a[ret.len - 1] == 0 &amp;&amp; ret.len &gt; 1) ret.len--; return ret;&#125;BigNum BigNum::operator/(const int&amp; b) const //大数对一个整数进行相除运算&#123; BigNum ret; int i, down = 0; for (i = len - 1; i &gt;= 0; i--) &#123; ret.a[i] = (a[i] + down * (MAXN + 1)) / b; down = a[i] + down * (MAXN + 1) - ret.a[i] * b; &#125; ret.len = len; while (ret.a[ret.len - 1] == 0 &amp;&amp; ret.len &gt; 1) ret.len--; return ret;&#125;int BigNum::operator%(const int&amp; b) const //大数对一个int类型的变量进行取模运算&#123; int i, d = 0; for (i = len - 1; i &gt;= 0; i--) &#123; d = ((d * (MAXN + 1)) % b + a[i]) % b; &#125; return d;&#125;BigNum BigNum::operator^(const int&amp; n) const //大数的n次方运算&#123; BigNum t, ret(1); int i; if (n &lt; 0) exit(-1); if (n == 0) return 1; if (n == 1) return *this; int m = n; while (m &gt; 1) &#123; t = *this; for (i = 1; i &lt;&lt; 1 &lt;= m; i &lt;&lt;= 1) &#123; t = t * t; &#125; m -= i; ret = ret * t; if (m == 1) ret = ret * (*this); &#125; return ret;&#125;bool BigNum::operator&gt;(const BigNum&amp; T) const //大数和另一个大数的大小比较&#123; int ln; if (len &gt; T.len) return true; else if (len == T.len) &#123; ln = len - 1; while (a[ln] == T.a[ln] &amp;&amp; ln &gt;= 0) ln--; if (ln &gt;= 0 &amp;&amp; a[ln] &gt; T.a[ln]) return true; else return false; &#125; else return false;&#125;bool BigNum::operator&gt;(const int&amp; t) const //大数和一个int类型的变量的大小比较&#123; BigNum b(t); return *this &gt; b;&#125;void BigNum::print() //输出大数&#123; int i; cout &lt;&lt; a[len - 1]; for (i = len - 2; i &gt;= 0; i--) &#123; cout.width(DLEN); cout.fill('0'); cout &lt;&lt; a[i]; &#125; cout &lt;&lt; endl;&#125;int n, m;int main()&#123; while (~scanf("%d", &amp;n)) &#123; BigNum ans; if (n == 1) printf("0\n"); else if (n == 2) printf("20\n"); else if (n == 3) &#123; printf("120\n"); &#125; // continue; else &#123; ans = 120; BigNum tempeven = 20; BigNum tempodd = 100; for (int i = 4; i &lt;= n; i++) &#123; if (i % 4 == 3) &#123; ans = ans + (tempodd = tempodd * 500); &#125; if ((i &amp; 1) == 0) &#123; ans = ans + (tempeven = tempeven * 30); &#125; &#125; ans.print(); &#125; &#125;&#125; 收获与反思奇偶位发现规律并且找出可能数情况的本质，而不是单纯对数据找规律。]]></content>
      <categories>
        <category>编程</category>
        <category>ACM</category>
      </categories>
      <tags>
        <tag>编程</tag>
        <tag>ACM</tag>
        <tag>2019春季训练</tag>
        <tag>洛谷</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[【洛谷-P1396】解题报告（二分，BFS）]]></title>
    <url>%2Fpost%2F3156b4f3.html</url>
    <content type="text"><![CDATA[原始题目P1396 营救 题目大意给定一张图，求s到t的路径使得路径上的边权值最大值最小 解题思路最大值最小问题 二分答案，左界为0有界，有界为所有边权的Max。 解题代码1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465666768697071727374757677787980818283848586878889909192939495//bfs+二分#include &lt;bits/stdc++.h&gt;using namespace std;#define rep(i, a, n) for (int i = a; i &lt; n; ++i)#define per(i, a, n) for (int i = n - 1; i &gt;= a; --i)#define fi first#define se second#define pb push_back#define np next_permutation#define INF 0x3f3f3f3f#define EPS 1e-8#define eps '\n'typedef long long ll;typedef unsigned long long ull;typedef pair&lt;int, int&gt; pii;typedef pair&lt;string, string&gt; pss;typedef vector&lt;int&gt; vi;const int maxn = 1e5 + 5;struct edge &#123; int u, v, w; edge(int _u, int _v, int _w) : u(_u) , v(_v) , w(_w) &#123; &#125; edge() &#123;&#125;&#125;;vector&lt;edge&gt; e[maxn];int vis[maxn];int n, m, ans, ss, tt;inline void addEdge(int u, int v, int w)&#123; e[u].push_back(edge(u, v, w));&#125;bool check(int mid)&#123; queue&lt;int&gt; q; memset(vis, 0, sizeof(int) * (n + 1)); q.push(ss); vis[ss] = 1; int now, nxt; while (!q.empty()) &#123; now = q.front(); q.pop(); rep(i, 0, e[now].size()) &#123; int tempv = e[now][i].v; int tempw = e[now][i].w; if (vis[tempv] || tempw &gt; mid) continue; else &#123; vis[tempv] = 1; if (tempv == tt) return true; q.push(tempv); &#125; &#125; &#125; return false;&#125;int main()&#123; ios::sync_with_stdio(false); while (cin &gt;&gt; n &gt;&gt; m &gt;&gt; ss &gt;&gt; tt) &#123; ans = 1e4 + 5; int tu, tv, tw; rep(i, 0, n + 1) e[i].clear(); rep(i, 1, m + 1) &#123; cin &gt;&gt; tu &gt;&gt; tv &gt;&gt; tw; addEdge(tu, tv, tw); addEdge(tv, tu, tw); &#125; int l = 0; int r = 1e4 + 5; int mid; while (l &lt; r) &#123; mid = (l + r) &gt;&gt; 1; if (check(mid)) r = mid; else l = mid + 1; &#125; cout &lt;&lt; l &lt;&lt; endl; &#125;&#125; 收获与反思最大值最小问题，最小值最大问题，可尝试二分答案。]]></content>
      <categories>
        <category>编程</category>
        <category>ACM</category>
      </categories>
      <tags>
        <tag>编程</tag>
        <tag>ACM</tag>
        <tag>洛谷</tag>
        <tag>二分，BFS</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[【洛谷-P1056】解题报告（模拟）]]></title>
    <url>%2Fpost%2F792ebb35.html</url>
    <content type="text"><![CDATA[原始题目P1056 排座椅 题目大意给出一个$M$行$N$列的矩形，某些相邻的同学交头接耳，设置$K$条横向通道，$L$条纵向通道给出最好的划分方案，能避免最多组同学交头接耳。 解题思路对每一行/列交头接耳的同学对数计数，分别对行列排序后排序输出前k或l个。（注意输出的时候按照字典序，所以要将前k或l个做二次排序，这里有些小坑）。 解题代码```C++ include using namespace std;typedef long long ll;const int maxn = 1e5 + 5; define rep(i, a, b) for (int i = a; i &lt; b; ++i)define per(i, a, b) for (int i = b - 1; i &gt;= a; —i)define fi firstdefine se secondint m, n, a, b, d;int xx1, yy1, xx2, yy2; struct node { int id; int cnt;};node xx[maxn], yy[maxn]; bool cmp(node a, node b){ return a.cnt &gt; b.cnt;} bool cmp1(node a, node b){ return a.id &lt; b.id;} int main(){ ios::sync_with_stdio(false); while (cin &gt;&gt; m &gt;&gt; n &gt;&gt; a &gt;&gt; b &gt;&gt; d) { rep(i, 1, m + 1) xx[i].id = i, xx[i].cnt = 0; rep(i, 1, n + 1) yy[i].id = i, yy[i].cnt = 0; rep(i, 0, d) { cin &gt;&gt; xx1 &gt;&gt; yy1 &gt;&gt; xx2 &gt;&gt; yy2; if (xx1 == xx2) { yy[min(yy1, yy2)].cnt++; } else { xx[min(xx1, xx2)].cnt++; } } sort(xx + 1, xx + m + 1, cmp); sort(yy + 1, yy + n + 1, cmp); sort(xx + 1, xx + a + 1, cmp1); sort(yy + 1, yy + b + 1, cmp1); cout &lt;&lt; xx[1].id; rep(i, 2, a + 1) cout &lt;&lt; “ “ &lt;&lt; xx[i].id; cout &lt;&lt; endl; cout &lt;&lt; yy[1].id; rep(i, 2, b + 1) cout &lt;&lt; “ “ &lt;&lt; yy[i].id; cout &lt;&lt; endl; }}··· 收获与反思因为需要二次排序那里一直Wa，注意审题啊，题目输出格式里明确指出了。]]></content>
      <categories>
        <category>编程</category>
        <category>ACM</category>
      </categories>
      <tags>
        <tag>编程</tag>
        <tag>ACM</tag>
        <tag>2019春季训练</tag>
        <tag>洛谷</tag>
        <tag>imitation</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[【洛谷-P1067】解题报告（模拟）]]></title>
    <url>%2Fpost%2Fdd932d44.html</url>
    <content type="text"><![CDATA[原始题目P1067 多项式输出 题目大意给出n次多项式的各项系数，输出符合规范的多项式表达形式。 解题思路模拟注意点： 最大项为正不需要加正号，其余各项需要 x^1改为x 为0的时候跳过 解题代码123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354//没考虑常数项，过了#include &lt;bits/stdc++.h&gt;using namespace std;typedef long long ll;const int maxn = 1e5 + 5;#define rep(i, a, b) for (int i = a; i &lt; b; ++i)#define per(i, a, b) for (int i = b - 1; i &gt;= a; --i)// int x[maxn], y[maxn];int a[maxn], b[maxn];int n;int main()&#123; ios::sync_with_stdio(false); while (cin &gt;&gt; n) &#123; per(i, 0, n + 1) &#123; cin &gt;&gt; a[i]; if (i == 0) &#123; if (a[i] == 0) cout &lt;&lt; endl; else &#123; if (a[i] &gt; 0) cout &lt;&lt; "+"; cout &lt;&lt; a[i] &lt;&lt; endl; &#125; break; &#125; else &#123; if (a[i] == 0) continue; if (i != n &amp;&amp; a[i] &gt; 0) cout &lt;&lt; "+"; if (abs(a[i]) == 1) &#123; if (a[i] &lt; 0) cout &lt;&lt; "-"; if (i != 1) cout &lt;&lt; "x^" &lt;&lt; i; else cout &lt;&lt; "x"; &#125; else &#123; cout &lt;&lt; a[i]; if (i != 1) cout &lt;&lt; "x^" &lt;&lt; i; else cout &lt;&lt; "x"; &#125; &#125; &#125; cout &lt;&lt; endl; &#125; return 0;&#125; 收获与反思模拟注意细节。]]></content>
      <categories>
        <category>编程</category>
        <category>ACM</category>
      </categories>
      <tags>
        <tag>编程</tag>
        <tag>ACM</tag>
        <tag>2019春季训练</tag>
        <tag>洛谷</tag>
        <tag>imitation</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[【洛谷-P1003】解题报告（模拟）]]></title>
    <url>%2Fpost%2F4a2509a9.html</url>
    <content type="text"><![CDATA[原始题目P1003 铺地毯 题目描述为了准备一个独特的颁奖典礼，组织者在会场的一片矩形区域（可看做是平面直角坐标系的第一象限）铺上一些矩形地毯。一共有 $n$ 张地毯，编号从 $1$ 到 $n$。现在将这些地毯按照编号从小到大的顺序平行于坐标轴先后铺设，后铺的地毯覆盖在前面已经铺好的地毯之上。 地毯铺设完成后，组织者想知道覆盖地面某个点的最上面的那张地毯的编号。注意：在矩形地毯边界和四个顶点上的点也算被地毯覆盖。 输入输出格式输入格式：输入共$n+2$行 第一行，一个整数$n$，表示总共有$n$张地毯 接下来的$n$行中，第 $i+1$ 行表示编号$i$的地毯的信息，包含四个正整数$a ,b ,g ,k$，每两个整数之间用一个空格隔开，分别表示铺设地毯的左下角的坐标$(a,b)$以及地毯在$x$轴和$y$轴方向的长度 第$n+2$行包含两个正整数$x$和$y$，表示所求的地面的点的坐标$(x,y)$ 输出格式：输出共$1$行，一个整数，表示所求的地毯的编号；若此处没有被地毯覆盖则输出$-1$ 输入输出样例输入样例#1：31 0 2 30 2 3 32 1 3 32 2 输出样例#1：3 输入样例#2：31 0 2 30 2 3 32 1 3 34 5 输出样例#2：-1 说明【样例解释1】 如下图，1 号地毯用实线表示，2 号地毯用虚线表示，3 号用双实线表示，覆盖点$(2,2)$的最上面一张地毯是 $3$ 号地毯。 【数据范围】 对于30% 的数据，有 $n ≤2$ ；对于50% 的数据，$0 ≤a, b, g, k≤100$；对于100%的数据，有 $0 ≤n ≤10,000$ ，$0≤a, b, g, k ≤100,000$ 。 noip2011提高组day1第1题 题目大意如题 解题思路根据查询点的多少选择，查询点少的时候考虑保存操作根据然后对每个查询看最终点的覆盖值。 解题代码123456789101112131415161718192021222324252627282930313233#include &lt;bits/stdc++.h&gt;using namespace std;typedef long long ll;const int maxn = 1e5 + 5;#define rep(i, a, b) for (int i = a; i &lt; b; ++i)#define per(i, a, b) for (int i = b - 1; i &gt;= a; --i)int x[maxn], y[maxn];int a[maxn], b[maxn];int n;int main()&#123; ios::sync_with_stdio(false); while (cin &gt;&gt; n) &#123; int ans = -1; rep(i, 1, n + 1) &#123; cin &gt;&gt; x[i] &gt;&gt; y[i] &gt;&gt; a[i] &gt;&gt; b[i]; &#125; int xx, yy; cin &gt;&gt; xx &gt;&gt; yy; rep(i, 1, n + 1) &#123; if (xx &gt;= x[i] &amp;&amp; xx &lt;= x[i] + a[i] &amp;&amp; yy &gt;= y[i] &amp;&amp; yy &lt;= y[i] + b[i]) &#123; ans = i; &#125; &#125; cout &lt;&lt; ans &lt;&lt; endl; &#125; return 0;&#125; 收获与反思简单模拟即可。]]></content>
      <categories>
        <category>编程</category>
        <category>ACM</category>
      </categories>
      <tags>
        <tag>编程</tag>
        <tag>ACM</tag>
        <tag>2019春季训练</tag>
        <tag>洛谷</tag>
        <tag>imitation</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[【洛谷-P1001】解题报告（水题）]]></title>
    <url>%2Fpost%2Fb04c1acf.html</url>
    <content type="text"><![CDATA[原始题目P1001 A+B Problem 题目描述输入两个整数a,b，输出它们的和(|a|,|b|&lt;=10^9)。 注意 pascal使用integer会爆掉哦！ 有负数哦！ c/c++的main函数必须是int类型，而且最后要return 0。这不仅对洛谷其他题目有效，而且也是noip/noi比赛的要求！ 好吧，同志们，我们就从这一题开始，向着大牛的路进发。 任何一个伟大的思想，都有一个微不足道的开始。 输入输出格式输入格式：两个整数以空格分开 输出格式：一个数 输入输出样例输入样例#1：20 30 输出样例#1：50 题目大意如题 解题思路水题 解题代码1234567891011121314#include &lt;bits/stdc++.h&gt;using namespace std;typedef long long ll;ll a, b, c, d;int main()&#123; ios::sync_with_stdio(false); while (cin &gt;&gt; a &gt;&gt; b &gt;&gt; c &gt;&gt; d) &#123; ll sum = (c - a) * 60 + d - b; cout &lt;&lt; sum / 60ll &lt;&lt; " " &lt;&lt; sum % 60 &lt;&lt; endl; &#125; return 0;&#125; 收获与反思无]]></content>
      <categories>
        <category>编程</category>
        <category>ACM</category>
      </categories>
      <tags>
        <tag>编程</tag>
        <tag>ACM</tag>
        <tag>2019春季训练</tag>
        <tag>洛谷</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Javascript学习——《精通Javascript》读书笔记]]></title>
    <url>%2Fpost%2F859584ac.html</url>
    <content type="text"><![CDATA[第2章 特性、函数和对象语言特性引用与值，js中采用值，引用两种方式来保存数据。原始值复制到变量中，而其余部分都依赖引用，从而表征上看的是多个不同名的对象维护相同的数据。 作用域不同于块作用域的语言，js中只有两种作用域：函数作用域与全局作用域。 举个栗子 123456789101112131415161718var foo = 'test';if(true)&#123; //其实修改的是全局作用域 var foo = 'new test';&#125;// 我们会发现这个是true，js中if块语句修改的是全局作用域console.log(foo === 'new test');function test() &#123; var foo = 'old test'; // 函数作用域中我们这里看到的是ture console.log(foo === 'old test');&#125;//退出函数作用域我们看到的依旧是new testconsole.log(foo === 'new test'); 另外还需要注意隐式的全局变量声明，专业的js程序猿都应该使用var来初始化变量。这样变量才会拥有你所期望的作用域，避免出乎意料的产生全局变量（比如在函数中不加var）。 上下文你的代码总是拥有某种形式的上下文（代码执行的环境）。上下文是一件强有力的工具，也是面向对象代码必不可少的组成部分。 太秀了，直接给函数然后就可以调用函数的方法了。 123456789101112131415function setFoo(fooInput)&#123; this.foo = fooInput;&#125;var foo = 10; //这里定义全局变量foovar obj = &#123;foo:10&#125;; //定义一个对象，一个成员foo//此时foo的值为10setFoo(30);//全局调用，this实际上是window，所以全局变量foo值为30//骚操作来了obj.setFoo = setFoo;obj.setFoo(30);//这样一来将setFoo()与obj绑定在一起，通过this访问obj的上下文，修改了对应的值。 Javascript中有两种方法可以在指定的上下文中运行函数。]]></content>
      <categories>
        <category>编程</category>
        <category>Javascript</category>
      </categories>
      <tags>
        <tag>编程</tag>
        <tag>Javascript</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[《电子产业兴衰史》读书笔记]]></title>
    <url>%2Fpost%2Fa3770b00.html</url>
    <content type="text"><![CDATA[第1章 一个大产业正在从消失ICT产业得贸易赤字额与天然气增加得进口额持平 2000年之前作为令战后新兴经济体骄傲得两大出口商品是电子产品和汽车，然而当来到21世纪，两个产业的发展却是南辕北辙。 1991年，处于泡沫经济下的，当时媒体还给出如下的评述： P002 “继汽车之后，电子产品成为了赚取外汇的又一大得力干将。” 关注两产业的贸易收支也可以明显观察到，2000年之前二者可谓势均力敌，但在之后汽车的贸易顺差虽然出现了大幅波动（受一定经济危机的影响），但总体趋势还是上升的，在2013年仍然保证了12万亿元的顺差，而电子产业确实逐渐走低，2013年彻底转变为贸易赤字。 这里需要区分书中几个常见缩写 ICT：（Information and Communication Technology，信息技术与通信技术）。 电子产业：在国民经济计算中主要用来衡量电子产品制造业的发展情况。 信息通信产业：在总务省以及其他机构的统计中，主要用来表现整个信息通信产业的附加值（主要以邮政、报纸、出版、广告等），与电子产业关系密切。 虽然根据总务省的相关调查统计结果，信息通信产业和电子产业对名义GDP的贡献以及产值、进出口等都是下跌趋势，但明显信息通信产业没有电子产业下滑的那么明显。 电子产业发展的三个时期 电子产业发展的黄金时期——1970~1985年 1970年前，整体经济形式良好，但经济的主角是钢铁和造船业等。 P010 “1970~1985年，的产业结构发生了很大的变化。从1973年开始，钢铁的生产量和原原油的进口量开始减少。与之相对，国内对硅（半导体集成电路的材料）的需求与日俱增。以钢铁产业为代表的‘厚重长大’产业陷入成长低迷，半导体等‘轻薄短小’产业则高速成长”。 20世纪70年代之后，电子产业在世界范围内开始具有举足轻重的作用。实际上，这一时期电子产业的发展主要靠出口。内需上升三倍，而出口则增加了11倍之多（数据来源经济产业省资源能源统计）。 1985年之后贸易顺差开始减少 贸易顺差一路看涨的情景在85年发生了转折，出口不再强劲。 P012 进入1985年之后，出口的增长速度变慢，反之进口则开始稳步增加，直接导致了贸易顺差的减少。 同时，硅需求增长也同步放缓，变相反映出国内电子产业增幅速度变缓。 2000年之前，内需增长拉动电子产业的发展 内需拉动（主导）阶段，当时经济形势，1985-2000年，经济在泡沫经济的狂潮中崩溃，陷入了人们说的“异常事态”。整体经济增速放缓。失去的二十年 不过或许，内需主导是健全的结构转变？否则电子产业的低迷期会来的更加早一些? 2000年以后电子产业总体衰退 国内产值在2000年之后急剧下降。 P014 “GDP几乎没有增长，而电子产业产值却是‘10年减半’，从生产的角度来看，电子产业是急速衰退的”。 然而电子零部件出口的持续增长（整体表现强劲），勉强维持了电子产业整体的贸易顺差，但是2008年之后（也是受经济危机的受害者）零部件出口减少，电子产业整体最终转为了贸易赤字。 后续章节着重关注在各个领域，电视、通信、计算机、半导体等究竟发生了什么，以及为什么会发生这些问题。]]></content>
      <categories>
        <category>阅读</category>
      </categories>
      <tags>
        <tag>阅读</tag>
        <tag>社科</tag>
        <tag>西村吉雄</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[《迦陵说词讲稿》读书笔记]]></title>
    <url>%2Fpost%2F4123b063.html</url>
    <content type="text"><![CDATA[依旧主要为内容摘录 第一章 词与文化第一讲 从西方文论看花间词的美感特质。传统文学批评是模糊的、泛泛的，叶先生的学生们常常提出，希望她做些更详细、更有逻辑条理性的分析。我们的课堂上，学生缺乏这种主导课堂的能力以及向授课教师提出要求的勇气。 先提出困惑 P3 “词作为一种很重要的韵文形式，虽然再中国文学史上占有一席地位，但词学本身却一直是在困惑、矛盾和争议之中发展下来的。” 花间词里写什么？美女。还有什么？爱情。所有的作者都是男性，而他们都要用女性的口吻、女性的语言，写女性的情思。然而中国的传统文学观念是“诗言志，文载道”，而且诗不但要言志，其中最好还要有寄托，如果以传统文学观念去衡量五代以来发展出的词学，那结论是显然的，词学从一开始就不符合传统的文学标准。 然而词所配合的乐曲在当时是一种新兴的音乐，曲调非常悦耳，有很强的吸引力，广泛在民间流行，这种市井中的快速传播大量丰富了词的创作。 P8 “你现在看任二北先生他们整理的敦煌的曲子，你就会发现它里面有错字、别字及文法不通的现象。因此那个时候这些民间曲子不被人重视，从隋唐以来，这些曲子没有人整理，没有人印刷，一直埋没无传。直到晚清，我们才发现我们竟有如此之多的民间的瑰宝长眠于窟穴之中。” 文人雅士们喜欢填词，一方面是真的感慨这种流行曲子之美，另一方面，可能更重要的，是因为表达的天性一直受着“诗言志，文载道”观念的制约。对于美女与爱情这种形式难以找到合适的形式表达。 然而这种发展是纠结和妥协的，文人们一方面希望用这种新的形式表达真情实感，一方面又顾及他人（甚至自己叩问自己）这种小词是不是传统观念的叛逆。因而他们也寻找理由与解释为自己开脱、辩解。如黄庭坚所讲“空中语耳”，解释所写都不是作者本人的真感受、真性情，亦或是如晏几道以多义性诡辩之。 P11 “其实，宋人为小词所作的辩解还不止于此。有的时候，他们还把词的好坏与作者本人品格的优劣也联系起来，认为品格高雅的人，他所写的美女与爱情的品格也是高雅的；品格低劣的人，他所写的美女与爱情的品格也一定是低俗的。”]]></content>
      <categories>
        <category>阅读</category>
      </categories>
      <tags>
        <tag>阅读</tag>
        <tag>社科</tag>
        <tag>叶嘉莹</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[编译原理学习——下推自动机PDA与有限自动机DFA]]></title>
    <url>%2Fpost%2F3f9eff25.html</url>
    <content type="text"><![CDATA[为何说丢失了信息从需求的角度，如果DFA与上下文无关文法（2型文法）等价，我们仅通过DFA就可以完成全部的语法分析，不必引入堆栈等等，但实际上我们需要用到堆栈，也可以直观感受到DFA相较于上下文无关文法，信息不足，而缺少的那部分，就和这个“堆栈”密切相关。 从词法、语法分析的角度，我们在先前第二章已经接触了词法分析，使用的利器就是DFA或者NFA，那既然词法分析用的是这个工具，到了语法分析仍然使用相同的工具就可以完成，岂不是倒退语法分析需求（难度）与词法分析需求（难度）相等吗？显然这是不可能的，所以对于DFA对于语法分析并不是全部，还缺少着信息。 从等价性的角度（这个更科学一些吧），我们了解到DFA与NFA两者的识别能力相同，且和RE（正规表达式）可以相互转化，又与正规文法（3型文法）等价，而上下文无关文法（2型文法）与PDA（下推自动机）是等价的。所以我们可以确定由上下文无关文法构造分析表（DFA）时，缺少的信息实际上就是PDA和DFA的差别。 丢了什么]]></content>
      <categories>
        <category>编译原理</category>
      </categories>
      <tags>
        <tag>编程</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[《枪炮、病菌与钢铁》读书笔记]]></title>
    <url>%2Fpost%2F74a4286c.html</url>
    <content type="text"><![CDATA[内容摘录与笔记前言 耶利的问题 P2“耶利的问题：‘为什么你们白人制造了那么多的货物并将它们运到新几内亚来，而我们黑人却几乎没有属于我们自己的货物呢？’” P3 “在普通新几内亚人的生活方式和普通欧洲人或普通美国人的生活方式之间仍然存在着巨大的差异。类似的差异同样把世界上其他民族的生活方式区别了开来。这些巨大的差异必定具有人们可能认为显而易见的重要原因。” P3 “关于这个问题的解决办法，专业的历史学家们仍然意见不一：大多数人甚至不再问这样的问题了。” P3 “在25年后撰写的本书就是试图对耶利的问题作出回答。” P10 “在传统的新几内亚社会中，聪明人比不那么聪明的人更有可能逃脱导致高死亡率的死因。然而，在传统的欧洲社会中，流行性疾病造成的死亡率的差异与智力几乎没有任何关系，而是与取决于人体化学细节的遗传抵抗力有关。例如，血型为B或O的人比血型为A的人对天花有更强的抵抗力。就是说，促进智力基因的自然选择，在新几内亚比在人口稠密、政治上复杂的社会可能要无情得多，因为在这样的社会里，对人体化学组成得自然选择反而更有效力。” 如果说之前读到得历史著作对历史进程必然性的分析是基于分布在各大陆的民族在政治、军事、文化等等方面的差异而来的，那么本书想要探究的则是这些差异的来源和产生模式。相较于讨论为什么欧洲人能够屠杀或者正如其他民族的直接原因，这本书着眼于分析，为什么是欧洲人而不是非洲人、亚洲人能够屠杀或者征服其他民族，这种差异是如何从零慢慢演变出来的。是对历史进程终极原因的探索。 P15 “新闻记者总使要求作者用一句话把篇幅很长的书加以概括。对本书来说，这样的一句话就是：‘不同民族的历史遵循不同的道路前进，其原因是民族环境的差异，而不是民族自身在生物学上的差异。’” 我更倾向于理解成，更主要的原因是…而不是…（阅读前） P19 “造成粮食生产传播速度差异的一个重大因素原来竟是大陆的轴线方向：欧亚大陆主要是东西向，而美洲和非洲则主要是南北向（第十章）。” P19 “第三部分（《从粮食到枪炮、病菌与钢铁》，第十一章到第十四章）从密籍人口所特有的病菌的演化开始，对从终极原因到近似原因的联系进行了考察（第十一章）。欧亚大陆的病菌杀死的印第安人和其他非欧亚大陆民族，比欧亚大陆的枪炮或钢铁武器所杀死的要多得多。相反，在新大陆，很少有或根本没有任何危险的病菌在等待未来的欧洲征服者。为什么病菌的交流这样不相等？在这里，近来分子生物学的研究成果在把病菌和粮食生产的出现相联系方面是富于启发性的，而这两者的联系在欧亚大陆要远远超过美洲。” P22 “然而，我希望我已经使读者相信，历史并不‘就是一个又一个讨厌的事实’，就像一个愤世嫉俗者说的那样。的确存在着始用于历史的广泛模式，而寻找这些模式的解释不但令人陶醉，也是大有裨益的。” 第一部分 从伊甸园到卡哈马卡第一章 走上起跑线——公元前11000年前各个大陆发生了些什么 P3 “用以比较不同大陆的历史发展的合适起点是公元前11000年左右。这个年代大致相当于世界上一些地区村社生活的开始。这时，美洲毫无疑问已经出现了首批定居者，更新世和上一次冰期已经结束，地质学家所说的全新世已经开始。在那个年代的几千年内，动植物的训话至少在世界上的一个地方开始了。从那时起，某些大陆上的族群是否已经比其他大陆上的族群领先一步或处于明显优势呢？” 本章想要探索的问题，快速浏览人类的初期历史，是否在很早期就在不同大陆上的人类演化产生了优劣之分，从而影响之后的历史进程。 P8 “我曾在《第三种黑猩猩》一书中主张，是喉的完善为现代语言提供了解剖学的基础，而发挥人的创造力是要大大依靠语言的。而另外一些人则提出，在当时脑容量不变的情况下脑组织发生的变化，使现代语言成为可能。” 大约10万年至5万年前，人类种族祖先能力发生巨大变化原因的两种解释。 在之后，4万年前，克罗马努人用他们现代人的体格，先进的文化，语言技能和智慧，或者变相利用他们身上的细菌，取代了欧洲的尼安德特人，没有证据证明两个早期人类种族的混合，更多的证据指向克罗马努人让尼安德特人不复存在。 这种种族本身的跃进和人类生存区域的重大扩张在时间上不谋而合。由非洲、亚欧大陆拓展到澳大利亚/新几内亚，以及在大陆板块快速扩散。 P9 “那时候，要从亚洲大陆到达澳大利亚/新几内亚，仍然需要渡过8个海峡，其中最宽的一个海峡至少有50英里宽。被大多数这样的海峡分隔开的岛屿彼此隔海相望，但从澳大利亚看不见印度尼西亚……因此，对澳大利亚/新几内亚的占有使一个重大事件，因为那需要有水运工具，因此这一点显然提供了关于历史上使用水运工具的最早证据” 还有人类的早期祖先们在各个大陆拓张过程中可能对一些大型哺乳动物带来的影响。 P11 “如此众多的大型动物几乎同时消失这一点引出了一个显而易见的问题：是什么造成了这种情况？一个显而易见的可能答案是：它们被首批到达的人类杀光或间接消灭了。” 由于这种大型哺乳动物灭绝不单单出现在澳大利亚/新几内亚地区，其他大陆包括后来的美洲，也同样出现了这样的灭绝现象，时间也与人类的首次到达和拓殖相差不多，更增添了这一假说的可能性。 也有一些人持气候变化印象，不过作者认为历经历史上的多次气候变化都没灭绝的一众物种都在人类足迹到达之后灭亡，难说是巧合。 P11 “我们知道，加拉帕戈斯群岛喝南极的鸟类喝哺乳动物同样也是在没有人类的情况下演化的，并且直到现代才看见了人，所以今天仍温顺得不可救药。如果不是环境保护主义者采取了保护性措施，它们可能已经很快灭绝了。在其他一些最近才发现的岛上，由于保护措施没有很快实施，消灭动物的事的确发生了：一个这样的受害者就是毛里求斯岛的渡渡鸟，渡渡鸟实际上已成了一种绝种的象征。” 很难不让人思考过去新西兰的恐鸟、马达加斯加的大狐猴喝夏威夷的巨型野鹅是不是也是由于相同原因在更早的时间灭绝。 P13 “从解剖学看，确实掌握了这种技术的现代民族（缝制衣服等抵御寒冷的技术），在大约2万年前进入西伯利亚（对此通常都有一些认为时间还要早得多的说法）。这一扩张可能就是欧亚大陆长毛象和长毛犀绝种的原因。” P19 “随着人类在美洲的定居，各个大陆和陆边岛屿以及从印度尼西亚到新几内亚东面的洋中岛，凡是可居住的大多数地区都有人类在生活。在世界上其余岛屿的定居直到现代才完成：地中海诸岛如克里特岛、塞浦路斯岛、科西嘉岛和撒丁岛约在公元前8500年到4000年之间；加勒比海诸岛从公元前4000年左右开始；波里尼西亚群岛和密克罗尼西亚群岛在公元前1200年到公元1000年之间；马达加斯加岛在公元300年到800年之间；冰岛在公元9世纪。美洲印第安人可能是现代伊努伊特人的祖先，他们大约在公元前2000年遍布北极附近地区。这样，在过去的700年中，唯一的无人居住、等待欧洲探险者光顾的地区就只剩下大西洋和印度洋中那些最偏远的岛屿（如亚速尔群岛和塞舌尔群岛）和南极大陆了。” P22 “因此，一个被送回到公元前11000年的观察者可能不会预测到哪个大陆上的人类社会会发展最快，但他可以提出充分的理由说明任何一个大陆都有这样的机会……欧亚大陆社会发展较快的真实原因根本不是我们所虚构的公元前11000年时的考古学家所猜测的那种直截了当的原因。本书以下篇幅所要研究的就是去发现那些真正的原因。” 去探索导致不同大陆发展差异，历史特殊性的真正原因。 第二章 历史的自然实验——地理因素是怎样塑造波利尼西亚群岛的社会的如果说达尔文在加拉帕戈斯群岛所观察到的“自然实验”是物种起源假说的有力证据，那本书作者对于人类社会在波利尼西亚群岛演化的“自然实验”则是为解决人类发展历史为何如此，是什么造成了历史，给出了可以分析的模式。 莫里奥里人与毛利人的冲突，虽是由相同祖先分化而来，环境的不同使两个地区的人类走上不同的演化道路，莫里奥里人回归狩猎采集的生活，坚持和平避免冲突的政策，而毛利人则走上集约农业的道路，信奉征服与掠夺。 P24 “这种相反的演化道路注定了他们最后冲突的结果。如果我们能够了解这两个岛屿社会向截然不同的方向发展的原因，我们也许就有了一个模式，用以了解各个大陆不同发展的更广泛的问题。” 这两个人类社会间的冲突又是波利尼西亚群岛这个中等规模“自然实验”下一个更微观的实验。 P28 “在波利尼西亚群岛之间，至少有6种环境可变因素促成了波利尼西亚社会之间的这些差异：岛屿气候、地址类型、海洋资源、面积、地形的破碎和隔离程度……” 第三章 卡哈马卡的冲突——为什么印加帝国皇帝阿塔瓦尔帕没有俘虏西班牙国王查理一世 P54 “因此，皮萨罗俘虏阿塔瓦尔帕这件事，表明了导致欧洲人向新大陆移民而不是美洲土著向欧洲移民的那组近似的因素。皮萨罗成功的直接原因包括：以枪炮、钢铁武器和马匹为基础的军事技术；欧亚大陆的传染性流行病；欧洲的航海技术；欧洲国家集中统一的行政组织和文字。本书的书名是这些近似因素的简略的表达，这些因素也使现代欧洲人能够去征服其他大陆的民族。” 划重点，本书的书名是这些近似因素的简略的表达。 第二部分 粮食生产的出现和传播第四章 农民的力量——枪炮、病菌与钢铁的根源 P58 “粮食生产是枪炮、病菌和钢铁发展的一个先决条件。因此，在不同大陆的族群是否或何时变成农民和牧人方面的地理差异，在很大程度上说明了他们以后截然不同的命运。” P64 “总之，动植物的驯化意味着人类的粮食越来越多，因而也就意味着人口越来越稠密。因此而带来的粮食和（在某些地区）利用畜力运输剩余量是，成了定居的、行政上集中统一的、社会等级分明额、经济上复杂的、技术上富有革新精神的社会的发展的先决条件。因此，能否利用驯化的动植物，最终说明了为什么帝国、知书写字和钢铁武器在欧亚大陆最早发展起来，而在其他大陆则发展较晚，或根本没有发展起来。” 第五章 历史上的穷与富——粮食生产开始时的地理差异 P67 “为什么粮食生产首先在看似相当贫瘠的土地上形成，只是到后来才在今天最肥沃的农田和牧场发展起来？” 确定古代遗存和年代以后，人们怎样确定这个动物或者植物是在附近驯化的，而不是在别处驯化，后来才传到这个遗址来的？ P70 “一个方法是研究这个作物或动物的野生祖先的地理分布图，并推断出驯化势必发生在野生祖先出现的地方。” P87 “确定某个作物或动物的驯化地点的第二个方法，是在地图上标出每个地区驯化物种首次出现的年代。出现年代最早的地点也许就是驯化最早的地点——而如果野生物种的祖先也在那里出现，且如果它们在其他地点首先出现的年代随着与推定的最早驯化地点距离的增加而渐次推后，从而表明驯化物种在向其他那些地点传播，情况就尤为如此。” P87 “一个极端情况是：有些地区的粮食生产完全是独立出现的……目前能够举出详细又令人信服的证据的这样的地区只有5个：西南亚，亦称近东或新月沃地；中国；中美洲（该词用来指墨西哥的中部和南部以及中美洲的毗连地区）；那美洲的安第斯山脉地区，可能还有亚马孙河流域的毗连地区；以及美国东部。在这些粮食生产中心中，有些中心或所有中心可能实际上包含了附近的几个或多或少独立出现的粮食生产的中心，如中国北方的黄河流域和中国南部的长江流域。” P92 “另一个极端情况是：有些地区的粮食生产毫无疑问不但是从外来作物和动物的引进开始的，而且也是从外来人的突然到来开始的。” 第六章 种田还是不种田——粮食生产传播的原因一个常见的错误观念：从到处流浪流浪的狩猎采集族群与定居的粮食生产者之间必定是界限分明。 P97 “粮食生产制度的渐次形成乃是许多关于时间和劳力分配的不同决定积累的结果。” P98 “觅食的人和觅食的动物一样，都在不断地按优先顺序来做出分配劳力的决定，哪怕是无意识地也是一样。他们首先集中注意力于最喜欢的食物，或者能够产生最高报偿的食物……在做出这些决定时要考虑许多问题。人们寻找食物是为了充饥果腹。他们也渴望得到一些特别的食物。如果所有其他情况相同，人们就用一种以最少的时间、最小的努力和最大的回报的方法去寻找食物。” P100 “我们必须把粮食生产同狩猎采集看作是相互竞争的供选择的方法。” 第七章 怎样识别杏仁——古代作物的无意识的发展 P110 “迄今为止，我们对野生植物演化为作物的描述的种种变化，与早期农民实际上可能已注意到的一些特征直接有关——如果实的大小、苦味、多肉、含油和纤维的长度。通过收获这些具有特别可取的品质的野生植物，古代人在无意识中传播了这些植物，使他们走上了驯化的道路。” 部分奇怪的突变本不利于植物在无人的环境下竞争，不过恰巧是这些突变利于人类对其驯化而保留了下来。 P111 “一个明显的例子就是豌豆。豌豆的种子（我们吃的豌豆）封闭在豆荚里。野豌豆要发芽生长，就必须破荚而出。为了做到这一点，豌豆就演化出一种基因，能使豆荚突然破裂，把豌豆弹射到地上。偶然产生突变的豌豆的豆荚不会爆裂。在野外，这种产生突变的豌豆一直到死都是包裹在亲株上的豆荚里面，而只有这种能爆裂的豆荚才能把它们的基因传递给后代。但与此相反的是，人类能够收获到的唯一豆荚可能就是留在植株上那些不爆裂的豆荚。因此，一旦人类开始把野豌豆带回家去吃，立刻就产生了对这种单基因突变的选择。对同样不爆裂突变进行选择的例子还有兵豆、亚麻和罂粟。” 与之相似的还有后文介绍的大麦和小麦，野生型麦秆可以自动脱落使得种子落到能够发芽生长的地面上，而突变型却保留在麦秆顶端，给人类的采集带来了方便，其后代同样保持了这样的性状，对这种突变品种的无意识选择，显然是人类对植物的第一个重大的“改良”，标志着新月沃地农业的开始。 第八章 问题在苹果还是印第安人——为什么有些地区的族群未能驯化植物 P127 “人类历史的主要事实之一，是西南亚的那个叫做新月沃地的地区在人类发展早期的重要性。那个地区似乎是包括城市、文字、帝国以及我们所说的文明（不论是福是祸）在内的一连串新情况发生的地方。而所有这些情况之所以发生，都是由于有了稠密的人口，有了剩余粮食的贮存，以及可以养活不从事农业的专门人材，凡此种种之所以可能又都是由于出现了以作物栽培和牲口饲养为形式的粮食生产。” 气候的原因——也影响了早期粮食生产基地的“选址” P146 “对美国东部驯化植物最了解的农民，就是这个地区的印第安人自己。他们在墨西哥三位一体的作物体系引进后宣判了当地驯化植物的命运：或者把它们完全抛弃，或者把它们的重要性降低。这个结果也表明了印第安人没有受到文化保守主义的束缚，而是在看到一种优良的植物时完全能够认识到它的价值。因此，同在新几内亚一样，美国东部土生土长的粮食生产所受到的限制，不是由于印第安人本身，而是完全决定于美洲的生物区系和环境。” 那么总结性的讲，限制粮食生产或者粮食生产发展水平的主要原因可以归结为下面一段话。 P147 “所有这些不存在本地粮食生产或只有有限的本地粮食生产的地区，都缺少可驯化的牲畜和谷物的野生祖先。” 关于第八章章节首部提出的问题的答案 P150 “因此，在欧洲人到达时，印第安人仍未能驯化北美的苹果，其原因不是印第安人，也不在苹果……印第安人未能驯化苹果的原因却是在于印第安人所能得到的整个野生动植物组合。这个组合的微弱的驯化潜力，就是北美粮食生产很晚才开始的主要原因。 第九章 斑马、不行的婚姻和安娜·卡列尼娜原则——为什么大多数大型野生哺乳动物没有得到驯化 P151 “可驯化的动物都是可以驯化的；不可驯化的动物各有各的不可驯化之处。” 即可以驯化的大型哺乳动物是要求符合多种条件的，这些条件都是“被驯化”这一结果的必要条件，而缺少其中任一（甚至被干扰）都会影响到大型哺乳动物的驯化。 P170 “人类同大多数动物缔结了一种不幸的婚姻，这是由于许多可能的原因中的一个或多个原因造成的：动物的日常食物、生长速度、交配习惯、性情、容易受惊的倾向以及群居组织的几个不同的特点。只有很少一部分野生哺乳动物由于在上述所有这些方面都能协调一致而最终得以和人类结成美满的婚姻” 第十章 辽阔的天空与偏斜的轴线——为什么在不同的大陆粮食生产传播的速度不同 P173 “轴线走向影响了作物和牲口的传播速度，可能还影响文字、车轮和其他发明的传播速度。这种基本的地理特征在过去500年中队印第安人、非洲人和欧亚大陆人十分不同的经验的形成起了巨大的促进作用。” 关于“抢先驯化现象”： 可以反应作物在大陆上的传播速度可以利用“抢先驯化现象”，即如果某一未驯化可利用作物的地方，当面临该作物的野生祖先和传播而来的变种（驯化）作物，可以推断出当地人类会选择后者，因而不会再进行一次其野生祖先的驯化。 因而，通过遗传分析，可以得到的结果是：欧亚大陆驯化的古代作物多数显示出只有一个不同的野生变种或不同的转化突变体，即反应出一次可利用的驯化。但新大陆的驯化作物则常常出现至少两个，即在不同场合独立的出现了驯化现象。这说明，新大陆对比欧亚大陆，前期驯化成果并没有迅速传播开来，侧面反映了粮食传播的速度差异。 进一步的 P176 “某种作物的迅速传播可能不但抢先阻止了同一植物的野生祖先在其他地方的驯化，而且也阻止了有亲缘关系的野生植物的驯化。” P180 “为什么作物从新月沃地向外传播的速度如此之快？回答部分地取决于我在本章开始时谈到的欧亚大陆的东西向周线。位于同一纬度地东西两地，白天的长度和季节的变化完全相同。在较小程度上，它们也往往具有类似的疾病、温度和雨量情势以及动植物生境或生物群落区（植被类型）。” 第三部分 从粮食到枪炮、病菌与钢铁第十一章 牲畜的致命礼物——病菌的演化 P203 “因此，当人口的数量和集中达到一定程度时，我们也就达到了这样的一个历史阶段，在这个阶段我们至少能够形成并保持只有我们人类才会有的人群病。但这个结论也有其矛盾之处：在那时以前这些病是不可能存在的！相反，它们必须演化成新的疾病。那么，这些新的疾病又是从哪里来的呢？” P203 “最近，由于对致病病菌所进行的分子研究，证据正在不断出现。就引起我们独有的疾病的许多病菌来说，分子生物学家现在能够确定一些亲缘关系最为接近的病菌。这些病菌同样证明是人群传染病的媒介——不过只在我们的各种家畜和宠物中流行罢了！” 人类疾病携带亲缘关系最为接近的抗原体的动物 麻疹牛（牛瘟） 肺结核牛 天花牛（牛痘）或携带亲缘痘病毒的其他牲畜 流行性感冒猪和鸭 百日咳猪、狗 恶性疟疾禽鸟（鸡和鸭？） 动物原病转化为人类疾病一般可以分为四个阶段。 回到开头耶利的问题。 P212 “如果没有欧洲送给其他大陆的不详礼物——从欧亚大陆人与家畜的长期密切关系中演化出来的病菌，这一切也许是不会发生的。” 第十二章 蓝图和借用字母文字的力量显而易见，能够指导重大行动下达指令，能够记录前人经验（包括但不限于航海）从而给后人以经验和指导。 几个问题： 为什么只有某些民族产生了文字？ 文字在人类历史上分别产生过几次？ 为什么有些民族发明文字早得多？ 为什么有些民族发明文字但之后却利用的很少？ 苏美尔人表示抽象名词的神奇创新： P218 “也许整个文字史上最重要的一步是苏美尔人采用了语音符号，开始时是借助代表发音 相同而又可以画出来的名词的符号来书写抽象名词。例如，要为弓画出一个可以识别的图形是容易的，但要为生命画出一个可以识别的图形就困难了，但这两者的发音在苏美尔语里都是ti，因此一张弓的图形的意思或者是弓，或者是生命。解决由此而产生的歧义是加上一个叫做义符的无声符号，以表示拟议中的对象所属的名词类别。语言学家把这种决定性的创新称之为画迷原则，也是今天构成双关语的基础。” 传播形式的两端：“蓝图复制”和“思想传播”。 P225 “罗马字母本身就是长长的一系列蓝图复制的终端产品。在人类历史上，字母只产生过一次：是在公元前第二个千年中从现代叙利亚到西奈半岛这个地区内说闪语的人当中产生的。历史上的和现行的几百种字母，追本溯源全都来自闪语字母这个老祖宗，有些（如爱尔兰的欧甘字母）是思想传播的结果，但大多数则是通过字母形式的实际复制和修改而产生的。 ” 关于文子传播的困惑（为什么有些地方产生了文字却没有传播出去呢？） P234 “一个相关的限制是很少有人学会书写这些早期的文字。只有国王或寺庙雇佣的专职文字记录者，才掌握关于文字的知识。” 人数少到以至于科学家们可以根据B类线性文字的笔迹确定抄写人员（文字记录人员）的大致数量。而早期这种现象可以说是蓄意为之的，因为统治者可不想文字称为底层民众反抗的有效工具，早期文字仅服务于统治者，是控制奴役他人的工具。指导后来这种文字传向民间才有了口口相传的诗歌、史诗落实在笔头上的可能。 而且文字的产生最初是足够复杂而集中统一的政治机构的需要，没有发展到这一层及的小型部落，即便收到了思想传播的而影响，也很有可能不会发展出文字。 P237 “狩猎采集社会没有发明出文字，甚至也没有采用过任何文字，因为它们既没有需要使用早期文字的机构，也没有生产力为养活文字专家所必需的剩余粮食的社会机制和农业机制。” 第十三章 需要之母 P243 “我们最终将要涉及本书的一个中心问题：为什么在不同的大陆上技术以不同的速度演进的问题” P247 “我的两个主要结论是：技术的发展是插个旗积累的，而不是靠孤立的英雄行为；技术在发明出来后 大部分都得到了使用，而不是发明出来去满足某种预见到的需要。” 一种技术产生后传播受到多种因素的影响。 P263 “中世纪欧洲从3000年的字母发展中继承的字母文字适合于用活字印刷，因为只需浇铸几十个字母就行了， 不像中国文字那样需用几千个语言符号。” P265 “现在，让我们来总结一下，粮食生产开始的时间、技术传播的障碍和人口的多寡这三大因素的变化，是怎样直接导致我们所看到的各大陆之间在技术发展方面的差异的。欧亚大陆（实际上也包括北非在内）是世界上最大的陆块，包含有数量最多的互相竞争的社会。它也是最早开始拥有粮食生产的两个中心的陆块，这两个中心就是新月沃迪和中国。它的东西向的主轴线，使欧亚大陆一个地区采用的许多发明得以较快地传播到欧亚大陆具有想同纬度和气候的其他地区的社会。它的沿次轴线（南北轴线）的宽度，同美洲巴拿马地峡的狭窄形成了对照。它没有把美洲和非洲的主轴线切断的那种严峻的生态障碍。因此，对技术传播的地理和生态障碍，在欧亚大陆没有在其他大陆那样严峻。由于所有这些因素，后更新世技术的加速发展，在欧亚大陆没有在其他大陆那样严峻。由于所有这些因素，后更新世技术的加速发展，在欧亚大陆开始得最早，从而导致了本地最大的技术积累。” 第十四章 从平等主义到盗贼统治 P281 “盗贼统治者和英明政治家得区别，强盗贵族和公益赞助人的区别，只是程度不同而已：这只是一个从生产者那里榨取来的财物有多少被上层人物留下来的问题。” 获取群众的支持，从古至今的盗贼统治者混合使用了4种办法： 接触平民的武装，同时武装上层掌权人物。 用通行的办法把得到的财务的很大一部分再分配给群众来博取欢心。 利用对武力的绝对控制来维持公共秩序和制止暴力以促进社会幸福。 制造一种为盗贼统治辩护的意识形态或宗教。 早期国家相较于酋长管辖地，直观的差别是规模更大，亲属关系更平淡，最高世袭领袖对信息、决策和权力实行更大的垄断。 P285 “许多早期国家，也是大多数早期国家，都层经历过奴隶制，其规模比酋长管辖地大得多。这不是因为酋长管辖地在处理被打败的敌人时更加宽大为怀，而是因为国家经济专门化的发展，更多的大规模胜场和更多的公共工程需要使用更多的奴隶劳动。此外，更大规模的国家战争能够得到更多的俘虏。” 当然，相较于酋长管辖地，还有一些潜在优势，比如国家对意识形态的统一更能激发一些个人的奉献精神，心甘情愿为国捐躯，现代国家中这已经成为一条基本思想通过我们从小受到的教育灌输进我们的大脑，使我们忘记了它标志着同以往人类历史的彻底决裂。 不再顾及自己感情和生命，取而代之的，“为了国王和国家”，“为了上帝和西班牙”，“战死沙场最光荣，给我们以生命的神最看重这种光荣的死：我远远看见了它，我的内心充满了对它的渴望！” 第五部分 在五章中环游世界第十五章 耶利的族人——澳大利亚和新几内亚的历史 P321 “‘他们是世界上最悲惨的人，是和没有理性的野兽差不多的人。’” P334 “澳大利亚发展粮食生产的另一个主要障碍是缺乏可以驯化的野生植物。甚至现代欧洲的植物遗传学家除了从澳大利亚当地的野生植物中培育出澳洲坚果外，其他就再也没有培育出什么作物来。” 仅有的籽粒最重的56种禾本科植物的名单中，只有两种出产在澳大利亚，而且这两种又位列名单末尾，恶劣的干旱环境与不适宜的粮食种植，加之大型有袋类动物的灭绝（与人类共生同步时间短），澳大利亚土著始终都没有突破石器的界限，发展成为有组织的政治实体。 第十六章 中国是怎样成为中国人的中国的——东亚的历史在世界上人口最多的6个国家中，除一国歪，其余都是不久前实现政治统一的民族大熔炉。而这一个特殊的国家就是中国。 P349 “近代民族大熔炉这一普遍现象的重大例外是世界上人口最多的国家——中国。今天的中国无论在政治上，文化上或是语言上似乎都是一个大一统的国家，至少再外行人看来是这样。它在公元前221年就已经在政治上同意了，并从那时起在大多数世纪中一直保持着统一的局面” 中国这种表面上的统一，并不是理所当然的，本不应该指望有这种统一，而是应该像早期的欧洲（甚至到近代）还有非洲，美洲，由多个早期的聚居中心。华南华北的气候差异，包括语言文字上的差异，本应是多样性的，但我们最终看到的却是相同或者十分相似的语言和文化。 通过语言敲开中国史也是东亚历史（包括印尼地区）的大门。 P354 “我们可以作这样的推理：如果现代的某些地区只有一种语言或有亲属关系的语族，而这一语言或语族又占有一个广大的连续的区域，那么这些地区就证明了这一语族在地理上的扩张，知识由于时间还不够长，它还没有来得及分化成许多语言。最后，我们还可以作反向的推理：如果在现代的某些地区内存在着属于某一特定语系的语言高度多样性现象，那么这些地区差不多就是该语系的早期分布中心。” 作者根据上述的推理，可以得到中国境内各语系语族发展的经过：华北原先被说汉藏语的人占据，华南不同地区不同时间被说苗瑶语、南亚语和傣-加岱语的人所占据；汉藏语的人经几次南迁（各种缘由的），取代了大部分华南说其他语言的人。而留下的少数发展到今天则形成了差异明显但根源相同的原华南各语系语言。 较短的南北距离没有相当程度上阻挡各早期聚集地的交流，文化多样性地区之间的交流丰富了中国的文化和技术，而交战的酋长管辖地的竞争，兼并则演化乘了规模更大、权力更集中的国家的形成（建立在早期粮食发展中心、足够人数、与并不明显的地理分割的基础上）。 P358 “中国则不同（于欧亚大陆西部的语言产生），它在华北得到完善，并流传各地，预先制止了任何其他不成熟的书写系统的发展或取而代之，最后演化为今天仍在中国使用的文字。” 中国的这种发展同时也辐射到周边地区，包括原华南地区人的迁移，带去了中国先进的早期文明。 P359 “中国的这种影响就像蒸汽压路机一样势不可挡，先前的热带东南亚民族在这一地区的现代居民中几乎没有留下任何痕迹。只剩下狩猎采集族群的三个孑遗群体——马来半岛的塞芒族小黑人、安达曼群岛岛民和斯里兰卡维多依族矮小黑人——使我们想到热带东南亚的原先居民可能是黑肤、鬈发，就像现代的新几内亚人，而不像肤色较浅、直发的中国华南人及其旁系属现代的热带东南亚人。” 第十七章 驶向波利尼西亚的快艇——南岛人扩张的历史由上一章所提到的肤色上的一致、体貌特征、遗传相似性、语言语系都有力表明了，说南岛语的中国华南人，他们在不久前扩散到整个菲律宾和印度尼西亚，更替了原来的居民（很有可能是与新几内亚特征更为相似的原住民）。 南岛语的故乡很有可能就是古代台湾。 P369 “考古学证据和语言学证据之间两个引人注目的一致证实了这样的推断：几千年前把一种新石器文化带到台湾、菲律宾和印度尼西亚的民族说的是南岛语，并且是今天仍然居住在这些岛屿上的说南岛语的人的祖先。” 反映时间纵深的现代南岛语系的差异性最深刻的在台湾，而马来半岛和苏门答腊的语言全都属于一个亚语支。台湾为南岛语系源头向东南亚和印尼扩张的过程显然更加合理。 一种有趣的证明方法：根据现代语言词汇来重构古代语言的词汇，对比起差异性结合该词可能产生的年代就可以分析出不同语言的亲属关系（或者相似程度）。 但是这种迁移的前提条件是说南岛语的人们具备更加先进的粮食种植技术和其他的技术条件，面对狩猎采集种族的时候这种领先优势很自然便会侵占其原住民的生存空间，但面临相同的粮食种植族群，就不一样了（或者是到达其自然环境改变，自身粮食种植和相关技能无法发挥的地方） P372 “然而，说南岛语的农民未能再向前进入东南亚大陆，因为说南亚语和加岱语的农民已经更替了那些原有的狩猎采集族群，同时也因为说南岛语的农民并不拥有对说南亚语和傣——加岱语的农民的任何优势。” 相类似的，向新几内亚地区发展时，由于该区域有高原地区的最初的粮食产地，新几内亚人从事粮食生产也有数千年之久，南岛人并不具备优势，所以被挡在了外围。 东亚和太平洋人类社会是颇有教益的，提供了很多环境塑造历史的生动例子。 P380 “东亚和太平洋族群凭借他们地理上的家园，无论在利用可驯化的动植物方面，或是再与其他族群的联系方面，都显得与众不同。一次又一次地，是具有发展粮食生产的先决条件并处在有利于传播来自别处的技术的地理位置上的族群，取代了缺乏这些优势的族群。一次又一次地，当一次移民浪潮在不同的环境中展开时，环境的不同决定了移民的后代以各自的不同方式发展。” 第十八章 两个半球的碰撞——欧亚大陆与美洲历史的比较根本问题：为什么是欧洲人到达了印第安人地国家并征服了它，而不是相反。 综合运用前几章地内容加以解释。 从粮食生产地角度，由于更新世晚期美洲大陆的哺乳动物大量灭绝（至少比欧亚要惨重一些），而可供驯养的就更少了，只有羊驼。 P383 “如果不是由于这些动物灭绝了，现代史的进程可能会有所不同。当科尔特斯率领他的满身泥污的雇佣军于1519年再墨西哥海岸登陆时，他们可能会被几千个骑着本地驯化的美洲马的阿兹特克骑兵赶进大海。那么，结果就不是阿兹特克人死于天花，而是那些西班牙人可能会被对疾病有抵抗力的阿兹特克人所传染的美洲病菌消灭光。依靠畜力的美洲文明国家可能会派遣自己的征服者区蹂躏欧洲。” 除了丢失了提供蛋白质、或者供军事、粮食耕作的大型哺乳动物，美洲的原始农业，相较欧亚大陆也有不少不利条件，比如以下五条。 依赖蛋白质含量低的玉米，而不是欧亚大陆种类繁多、蛋白质吩咐的谷物。 点种、不能撒播 缺乏畜力（可驯化的大型哺乳动物的缺失）耕作 缺乏可以增加土壤肥力的动物粪便 缺乏畜力进行脱粒、碾磨和灌溉之类的农活 由粮食生产差异带来的，是其他各个方面的差异。不能养活足够的人，人口不够稠密所以不足以演化出致命疾病、以及更先进的技术等等。 技术领域：金属器具、战争用具与骑兵、能源运转（这里我们要重视蒸汽动力出现前畜力、风力、水力的差异）、轮子（轮子和仅有的羊驼始终都没有机会碰面）以及海上运输。 人员不够稠密实际上使美洲大陆空间上更像一个个孤立分裂的小大陆，难以像欧亚大陆一样形成权力集中的政治实体，政治合法化以及调动大量资源进行对其他民族的战争。 书中关于欧亚大陆的领先优势结果的细致论述在此就不再过多分析了，有机会可以再回顾一下。 尾声 人类史作为一门科学的未来各大陆民族长期历史之间的显著差异，不是源自这些民族本身的天生差异，而是源自他们环境的差异。 各大陆不同的特点中，有4组差异是最重要的： 第一组差异是各大陆在可以用作驯化的起始物种的野生动植物品种方面的差异。粮食生产是基础性的差异是关键的，而且有运气的成分在里面，有如安娜卡列尼娜原则，不是人类想驯化就可以驯化。 第二组差异是那些影响传播和迁移速度的因素，比如轴线，地理障碍等。欧亚大陆在这一组上具有得天独厚的优势。 第三组是影响大陆之间传播的因素，更为孤立的澳大利亚就受到了相当的影响。抢先驯化现象还有驯化成果的传播，有时恰恰依赖大陆之间的联系程度。 第四组是最后一组各大陆之间在面积和人口总数方面的差异。更大面积或更多人口意味着更多的潜在发明者，更多的互相竞争的社会，更多的可以采用的发明创造——以及更大的采用和保有发明创造的压力。竞争的作用太大了。 特别的，关注一下中国的情况可以说明，前期的优势并不能决定后期的后期，中国恰恰是因为过早形成了单一集权的国家，统一形式虽然加快了前期技术的传播，但是在单一决策失误上付出的代价却让我们丧失了优势，地理上的四通八达对技术的发展既有积极的影响也有消极的影响。 历史不再是一个又一个令人讨厌的事实。]]></content>
      <categories>
        <category>阅读</category>
      </categories>
      <tags>
        <tag>阅读</tag>
        <tag>历史</tag>
        <tag>贾雷德·戴蒙德</tag>
        <tag>枪炮、病菌与钢铁</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[算法与数据结构学习——分块莫队]]></title>
    <url>%2Fpost%2Fd632e628.html</url>
    <content type="text"><![CDATA[区间最大值 RMQ 问题 ST 表 线段树 分块做法，多一个根号。 n/t+t 不等式的话一般取根 n 合适 静态区间和 f[i][j] = i ~ i+2^j-1 区间加法支持 区间剑法就要用线段树 sf’””””””fdSd]]></content>
      <categories>
        <category>编程</category>
        <category>数据结构与算法</category>
      </categories>
      <tags>
        <tag>编程</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[操作系统学习——集群技术初识]]></title>
    <url>%2Fpost%2F2024a703.html</url>
    <content type="text"><![CDATA[（可以关注一下 Future Generation Computer Systems） 集群技术初识——以Linux负载均衡集群学习为例 写在前面本文主要参考：章文嵩博士所写的Linux服务器集群系统介绍，集群技术（原理篇），高俊峰所著《高性能Linux服务器构建实战》，魔软运维社所著《大规模Linux集群架构最佳实践》。 由于查阅资料的时候不懂得地方太多，所以多数只能从概念上简单理解，如想自己深入理解其中的奥妙，还需要完成本门课程，将基础打好，同时熟悉Linux系统的一些基本情况后再做深入且仔细的学习。 第一部分 什么是集群背景我们在计算机网络中已经学习了吞吐量的概念，即单位时间内成功地传送数据的数量（以比特、字节、分组等测量），我们这里着重考量接收端的吞吐能力（以带宽衡量）。 Internet的飞速发展给网络带宽和服务器带来巨大的挑战。从网络技术的发展来看，网络带宽的增长远高于处理器速度和内存访问速度的增长，这是什么意思。数据出了小区门（计算机）在路途中已经可以上高速公路了，但是在小区内的行驶速度却成了难题，越来越多的瓶颈会出现在服务器端。互联网的海洋中对性能的不断提高，高可伸缩性、高可用性、可管理性、价格有效性的网络服务技术将成为网络服务技术的主导。各种平台下的技术方案应运而生。 对称多处理系统 对称多处理（Symmetric Multi-Processor，简称SMP）是由多个对称的处理器、和通过总线共享的内存和I/O部件所组成的计算机系统。SMP是一种低并行度的结构，是我们通常所说的”紧耦合多处理系统”， SMP的可扩展能力有限，但也有相应的优点： 单一系统映像（Single System Image） 有共享的内存和I/O， 易编程。 由于SMP的可扩展能力有限，SMP服务器显然不能满足高可伸缩、高可用网络服务中的负载处理能力不断增长需求。随着负载不断增长，会导致服务器不断地升 级。这种服务器升级有下列不足： 升级过程繁琐，机器切换会使服务暂时中断，并造成原有计算资源的浪费 越往高端的服务器，所花费的代价越大； 三是 SMP服务器是单一故障点（Single Point of Failure），一旦该服务器或应用软件失效，会导致整个服务的中断。 集群的起源集群并不是一个全新的概念，其实早在七十年代计算机厂商和研究机构就开始了对集群系统的研究和开发。由于主要用于科学工程计算，所以这些系统并不为大家所熟知。直到Linux集群的出现，集群的概念才得以广为传播。对集群的研究起源于集群系统的良好的性能可扩展性(scalability)。提高CPU主频和总线带宽是最初提供计算机性能的主要手段。但是这一手段对系统性能的提供是有限的。接着人们通过增加CPU个数和内存容量来提高性能，于是出现了向量机，对称多处理机(SMP)等。但是当CPU的个数超过某一阈值，象SMP这些多处理机系统的可扩展性就变的极差。主要瓶颈在于CPU访问内存的带宽并不能随着CPU个数的增加而有效增长。与SMP相反，集群系统的性能随着CPU个数的增加几乎是线性变化的 集群恰恰是通过高性能网络或局域网互联的服务器集群正成为实现高可伸缩的、高可用网络服务的有效结构（而非基于单机CPU数量的增长）。这种松耦合结构的服务器集群系统有下列优点： 性能 网络服务的工作负载通常是大量相互独立的任务，通过一组服务器分而治之，可以获得很高的整体性能。 性能/价格比 组成集群系统的PC服务器或RISC服务器和标准网络设备因为大规模生产降低成本，价格低，具有最高的性能/价格比。若整体性能随着结点数的增长而接近线性增加，该系统的性能/价格比接近于PC服务器。所以，这种松耦合结构比紧耦合的多处理器系统具有更好的性能/价格比。 可伸缩性 集群系统中的结点数目可以增长到几千个，乃至上万个，其伸缩性远超过单台超级计算机。 高可用性在硬件和软件上都有冗余，通过检测软硬件的故障，将故障屏蔽，由存活结点提供服务，可实现高可用性。 当然，用服务器集群系统实现可伸缩网络服务也存在很多挑战性的工作： 透明性（Transparency）对用户透明，如何高效地使得由多个独立计算机组成的松藕合的集群系统构成一个虚拟服务器；客户端应用程序与集群系统交互时，就像与一台高性能、高可用的服务器交互一样，客户端无须作任何修改。部分服务器的切入和切出不会中断服务，这对用户也是透明的。 性能（Performance） 性能要接近线性加速，这需要设计很好的软硬件的体系结构，消除系统可能存在的瓶颈。将负载较均衡地调度到各台服务器上。 高可用性（Availability） 需要设计和实现很好的系统资源和故障的监测和处理系统。当发现一个模块失败时，要这模块上提供的服务迁移到其他模块上。在理想状况下，这种迁移是即时的、自动的。 可管理性（Manageability） 要使集群系统变得易管理，就像管理一个单一映像系统一样。在理想状况下，软硬件模块的插入能做到即插即用（Plug &amp; Play）。 可编程性（Programmability） 在集群系统上，容易开发应用程序。 集群类型通常我们根据需求将集群分为三类：负载均衡集群（Load Balancing LB）,高可用性集群（High Availability HA）,高性能也叫科学集群（High Performance HP。 下面做一下详细的介绍（来源自博客），笔者本人学习中只听闻过负载均衡集群。 负载均衡集群（Load Balancing LB） 负载均衡集群为企业需求提供了更实用的系统。如名称所暗示的，该系统使负载可以在计算机集群中尽可能平均地分摊处理。该负载可能是需要均衡的应用程序处理负载或网络流量负载。这样的系统非常适合于运行同一组应用程序的大量用户。每个节点都可以处理一部分负载，并且可以在节点之间动态分配负载，以实现平衡。对于网络流量也是如此。通常，网络服务器应用程序接受了太多入网流量，以致无法迅速处理，这就需要将流量发送给在其它节点上运行的网络服务器应用。还可以根据每个节点上不同的可用资源或网络的特殊环境来进行优化。 高可用性集群（High Availability HA） 高可用性集群的出现是为了使集群的整体服务尽可能可用，以便考虑计算硬件和软件的易错性。如果高可用性集群中的主节点发生了故障，那么这段时间内将由次节点代替它。次节点通常是主节点的镜像，所以当它代替主节点时，它可以完全接管其身份，并且因此使系统环境对于用户是一致的。 高性能也叫科学集群（High Performance HP） 为集群开发并行编程应用程序，以解决复杂的科学问题。这是并行计算的基础，尽管它不使用专门的并行超级计算机，这种超级计算机内部由十至上万个独立处理器组成。但它却使用商业系统，如通过高速连接来链接的一组单处理器或双处理器 PC，并且在公共消息传递层上进行通信以运行并行应用程序。因此，您会常常听说又有一种便宜的 Linux 超级计算机问世了。但它实际是一个计算机集群，其处理能力与真的超级计算机相等，通常一套象样的集群配置开销要超过 $100,000。这对一般人来说似乎是太贵了，但与价值上百万美元的专用超级计算机相比还算是便宜的。 集群的实现根据网络资料，已知的负载均衡集群可以通过硬件和软件两种方式实现，其他两种集群的实现方式不太清楚。 硬件方式：即通过专用的硬件（处理机）进行内容的分发调度，一般而言，硬件负载均衡在功能、性能上优于软件方式，不过成本昂贵。而且最重要的是该专用硬件是单点配置，即具有发生单点故障导致整个集群瘫痪的风险。 软件方式：软件负载均衡解决方案是指在一台或多台服务器相应的操作系统上安装一个或多个附加软件来实现负载均衡，它的优点是基于特定环境，配置简单，使用灵活，成本低廉，可以满足一般的负载均衡需求。 后面着重以LVS（著名的开源项目）为例来说明LVS集群系统的实现。 第二部分 LVS集群系统项目诞生 针对高可伸缩、高可用网络服务的需求，我们给出了基于IP层和基于内容请求分发的负载平衡调度解决方法，并在Linux内核中实现了这些方法，将一组服务器构成一个实现可伸缩的、高可用网络服务的虚拟服务器。 虚拟服务器的体系结构如图2所示，一组服务器通过高速的局域网或者地理分布的广域网相互连接，在它们的前端有一个负载调度器（Load Balancer）。负载调度器能无缝地将网络请求调度到真实服务器上，从而使得服务器集群的结构对客户是透明的，客户访问集群系统提供的网络服务就像访 问一台高性能、高可用的服务器一样。客户程序不受服务器集群的影响不需作任何修改。系统的伸缩性通过在服务机群中透明地加入和删除一个节点来达到，通过检 测节点或服务进程故障和正确地重置系统达到高可用性。由于我们的负载调度技术是在Linux内核中实现的，我们称之为Linux虚拟服务器（Linux Virtual Server）。 LVS集群的组成与特点Linux虚拟服务器（Linux Virtual Server，LVS）是一个由章文嵩开发的一款自由软件，利用LVS可以实现高可用的、可伸缩的Web、Mail、Cache和Media等网络服务。并在此基础上开发支持庞大用户数的、可伸缩的、高可用的电子商务应用。LVS自1998年发展到现在，已经变得比较成熟，目前广泛应用在各种网络服务和电子商务应用中。 LVS具有很好的可伸缩性、可靠性和可管理性，通过LVS要实现的最终目标是：利用Linux操作系统和LVS集群软件实现一个高可用、高性能、低成本的服务器应用集群。 LVS 集群的组成利用LVS架设的服务器集群由3个部分组成：最前端的是负载均衡层（用Load Balancer表示），中间是服务器群组层（用Server Array表示），底端是数据共享存储层（用Shared Storage表示，这里应该还涉及一些分布式存储？的知识）。在用户看来，整个LVS集群系统的所有内部应用结构都是透明的，最终用户只是在使用一个虚拟服务器提供的高性能服务。 下面对LVS三个组成部分进行详细的介绍： 负载均衡层：位于整个集群系统的最前端，由一台或多台负载均衡调度器（Director Server），只有一台调度器的时候我们也将其成为Load Balancer，LVS核心模块IPVS就安装在Director Server上，而Director的主要作用类似于一个路由器，它含有为完成LVS功能所设定的路由表，通过这些路由表把用户的请求分发给服务器群组层的应用服务器（Real Server），整个过程对访问集群的用户是透明的。同时，在Director Server上还要安装对Real Server的监控模块Ldirectord，此模块用于监测各个Real Server服务的健康状况。在Real Server不可用时将其从LVS路由表中剔除，在恢复时重新加入（伸缩性的体现）。 服务器群组层：由一组实际运行应用服务的机器组成，Real Server可以是Web服务器、Mail服务器、FTP服务器、DNS服务器、视频服务器中的一个或多个，每个Real Server之间通过高速的LAN或分布在各地的WAN相连接。在实际的应用中，Director Server也可以同时兼任Real Server的角色。 共享存储层：是为所有Real Server提供共享存储空间和内容一致性的存储区域，一般由磁盘阵列设备组成。为了提供内容的一致性，一般可以通过NFS网络文件系统共享数据，但是NFS在繁忙的业务系统中，性能并不是很好，此时可以采用集群文件系统，例如Red Hat的GFS文件系统，Oracle提供的OCFS2文件系统等。 从整个LVS结构可以看出，Dirctor Server是整个LVS的核心。目前，用于Director Server的操作系统只有Linux和FreeBSD，Linux 2.6内核完全内置了LVS的各个模块，不用任何设置就可以支持LVS功能。 LVS集群的特点 IP负载均衡与负载调度算法 IP负载均衡技术 负载均衡技术有很多实现方案，有基于DNS域名轮流解析的方法，有基于客户端调度访问的方法，有基于应用层系统负载的调度方法，还有基于IP地址的调度方法。在这些负载调度算法中，执行效率最高的是IP负载均衡技术。 LVS的IP负载均衡技术是通过IPVS模块来实现的。IPVS是LVS集群系统的核心软件，它的主要作用是：安装在Director Server上，同时在Director Server上虚拟出一个IP地址，用户必须通过这个虚拟的IP地址访问服务器。这个虚拟IP一般称为LVS的VIP，即Virtual IP。访问的请求首先经过VIP到达负载调度器，然后由负载调度器从Real Server列表中选择一个服务器节点相应用户的请求。 在用户的请求到达负载调度器后，调度器如何请求发送到提供服务的Real Server节点，而Real Server节点如何返回数据给用户，是IPVS实现的重点技术。IPVS实现负载均衡地方式有3种，分别是NAT、TUN和DR。（原书后面有详细介绍，这里就不多写了，有兴趣之后再了解）。 负载均衡调度算法 动态选择的实现，就是负载调度算法。IPVS实现了8种负载调度算法。分别是，轮叫调度（Round Robin）、加权轮叫调度（Weighted Round Robin）、最少连接调度（Least Connections）、加权最少连接调度（Weighted Least Connections）、基于局部性的最少连接（Locality-Based Least Connections）、带复制的基于局部性最少连接（Locality-Based Least Connections with Replication）、目标地址散列（Destination Hashing）和源地址散列（Source Hashing）。 如果想要进一步了解，请登录LVS中文站点，查阅更详细的信息。 高可用性 LVS是一个基于内核级别的应用软件，因此具有很高的处理性能。由LVS构建的负载均衡集群系统具有优秀的处理能力，每个服务节点的故障不会影响整个系统的正常使用，又能够实现负载的合理均衡，使应用具有超高负荷的服务能力，可支持上百万个并发连接请求。 高可靠性 LVS负载均衡集群软件已经在企业和学校中得到了很好的普及，国内外很多大型的、关键性的Web站点也都采用了LVS集群软件，所以它的可靠性在实践中得到了很好印证。有很多由LVS构成的负载均衡系统，运行很长时间，从未进行过重新启动。这些都说明了LVS的高稳定性和高可靠性。 使用环境 目前仅支持Linux和FreeBSD系统作为前端Director Server，但是支持大多数的TCP和UDP协议。支持TCP协议的应用有：HTTP、HTTPS、FTP、SMTP、POP3、IMAP4等等；支持UDP协议的应用有：DNS、NTP、ICP、视频和音频流播放协议等。 LVS对Real Server的操作系统没有任何限制，Real Server可运行在任何支持TCP/IP的操作系统上，包括Linux，各种UNIX（如FreeBSD、Sun Solaris、HP Unix等），Mac OS和Windows等。 开源软件 LVS集群软件是按GPL（GNU Public License许可证发行的自由软件，因此，使用者可以得到软件的源代码，并且可以根据自己的需要进行各种修改，但是修改必须以GPL方式发行。 第三部分 集群系统的配套应用Heartbeat如果负载均衡层（Load Balancer）仅由一台Director Server来实现VIP与集群资源的调度，就会面临单点故障后整个集群系统瘫痪的危险。为了实现LVS负载均衡系统下的高可用性，我们可以使用一些常用的HA软件，实现“双机互备”。 heartbeat使Linux-HA项目中的一个组件，也是目前开源HA项目中最成功的一个例子，它提供了所有HA软件需要的基本功能，检测集群中的系统服务，在集群的节点间转移共享IP地址的所有者等。自1999年开始到现在，heartbeat在行业内得到了广泛应用，也发行了很多版本，最核心的包括两个部分，其最核心包括心跳监测部分和资源接管部分，心跳监测可以通过网络链路和串口进行，而且支持冗余链路，它们之间相互发送报文来告诉对方自己当前的状态，如果在指定的时间内未受到对方发送的报文，那么就认为对方失效，这时需启动资源接管模块来接管运 行在对方主机上的资源或者服务。 IP网络存储iSCSI主要介绍基于IP SAN的网络存储iSCSI。iSCSI技术以其低廉的构建成本和优秀的存储性能，博得了很多CIO和存储管理员的喜爱，目前陆续进入企业应用领域，推动了企业的存储环境向集中式转变。虽然，目前对于iSCSI应该在什么样的环境中使用还存在着诸多争议，但是iSCSI的前途使光明的，在未来的存储世界中，iSCSI一定会占据重要的席位。 存储概念的术语在存储的世界里，有各种各样的名词和术语，常见的有SCSI、FC、DAS、NAS、SAN等。本节重点介绍与存储相关的术语和知识。 SCSI介绍 SCSI是小型计算机系统接口（Small Computer System Interface）的简称，SCSI作为输入/输出接口，主要用于硬盘、光盘、磁带机、扫描仪、打印机等设备。 FC介绍 FC是光纤通道（Fiber Channel）的简称，是一种适合于千兆数据传输的、成熟而安全的解决方案，与传统的SCSI技术相比，FC提供更高的数据传输速率，更远的传输距离，更多的设备连接支持，更稳定的性能，更简易的安装。 DAS介绍 DAS是直联式存储（Directed-Attached Storage）的简称，是指将存储设备通过SCSI接口或光纤通道直接连接到一台计算机上，当服务器在地理上比较分散，很暗通过远程进行互连时，DAS是比较好的解决方案。但是这种存储方式只能通过与之连接的主机进行访问，不能实现数据与其他主机的共享，同时，DAS会占用服务器操作系统资源，例如CPU资源、IO资源等，并且数据量越大，占用操作系统资源就越严重。 NAS介绍 网络接入存储（Network-Attached Storage）简称NAS，它通过网络交换机连接存储系统和服务器，建立专门用于数据存储的私有网络，用户通过TCP/IP协议访问数据，采用业界标准文件共享协议如NFS、HTTP、CIFS来实现基于文件级的数据共享。NAS存储使文件共享访问变得更方便和快捷，并且能很容易地增加存储容量。通过企业化的文件服务器和存储技术相结合，NAS为那些需要共享大量文件数据的企业提供了一个高效的、可靠的、高性价比的解决方案。但是NAS也有一定的局限性，它会受到网络带宽和网络拥堵的影响，在一定程度上限制了NAS的网络传输能力。 SAN介绍 存储区域网络（Storage Area Network）简称SAN，它是一种通过光纤交换机、光线路由器、光纤集线器等设备将磁盘阵列、磁带等存储设备与相关服务器连接起来的高速专用子网。 SAN由三个部分组成，分别是连接设备（如路由器、光纤交换机和Hub）、接口（如SCSI、FC）、通信协议（如IP和SCSI）。这三部分再加上存储设备和服务器就构成了一个SAN系统。SAN提供了一个灵活的、高性能的和高扩展性的存储网络环境，它可以更加有效地传输海量地数据块。由于采用了光纤接口，因此SAN还具有更高的带宽，同时，SAN也使统一管理和集中控制实现简化。现在SAN已经广泛应用于ISP和银行等，随着用户业务量增大，SAN的应用前景将越来越光明。 iSCSI的概念iSCSI，即internet SCSI，是IETF制定的一项标准，用于将SCSI数据块映射为以太网数据包。从根本上说，它是一种基于IP Storage理论的新型存储技术，该技术将存储行业广泛应用的SCSI接口技术IP网络技术相结合，可以在IP网络上构建SAN。简单地说，iSCSI就是在IP网络上运行SCSI协议的一种网络存储技术。iSCSI最初由Cisco和IBM两家开发，并且得到了广大IP存储技术爱好者的大力支持，这几年迅速的发展壮大。 FC SAN与IP SAN在iSCSI技术出现后，通过IP技术搭建的存储网络也应运而生，SAN技术也就出现了两种不同的实现方式，即FC SAN与IP SAN。简单来说，以光纤搭建的存储网络就是FC SAN，以SCSI技术搭建的存储网络叫做IP SAN。 作为SAN的两种实现方式，他们各有优劣，下面从几个方面分别阐述。 在数据传输方式上，FC SAN与IP SAN都采用块协议方式来完成，这是他们的相同点。 在传输速度上，就目前传输速率而言，FC SAN（2Gbit/s）最快，iSCSI（1Gbit/s）次之。 在传输距离上，FC SAN理论上可以达到100公里，而事实上，传输50公里过后，会出现瓶颈。而通过IP网络的iSCSI技术在理论上没有距离的限制，即iSCSI可以进行没有距离限制的数据传输。 在管理及维护成本上，架设FC SAN网络需要投入很多硬件成本吗，并且需要特定的工具软件进行操作管理，而IP SAN构建成本低廉，由于iSCSI是通过IP网络来传输数据和分配存储资源的，因此只要在现有的网络上进行管理和使用即可，这样就可以省下大笔的管理费用及培训成本。 当然，iSCSI的推广还存在着安全性、软硬件适配问题等，但是相信在未来的网络存储世界里，IP SAN绝对会拥有一席之地。 iSCSI的组成一个简单的iSCSI系统大致有以下部分组成： iSCSI Initiator或者iSCSI HBA iSCSI Target 以太网交换机 一台或者多台服务器 详细的软硬件设备介绍（Initiator和Target）以及iSCSI工作原理有兴趣再做进一步研究，在此不再叙述。]]></content>
      <categories>
        <category>操作系统</category>
        <category>集群</category>
      </categories>
      <tags>
        <tag>操作系统</tag>
        <tag>集群</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[PHP学习——Laravel框架入门]]></title>
    <url>%2Fpost%2Fd7435d20.html</url>
    <content type="text"><![CDATA[环境搭建此处省略，后面补充 Laravel教程微博实例构建页面样式美化12yarn install --no-bin-linksyarn add cross-env 使用Boostrap组件进行前端样式美化 Bootstrap再入门上面代码将引入public/css/app.css样式文件。 header, nav 是 HTML5 提供的一种语义化标签，其实际作用与 div 一致，语义化的标签能帮助机器更方便理解代码，使代码更简洁，有助于网站的 SEO 优化。我们在上面代码使用到一些如 navbar, container 等类名在 Bootstrap 中都拥有特殊含义。 Laravel 前端工作流介绍Sass,NPM,Yarn,Laravel Mix来构成一套完整的前端工作流。 SASS语法基础 样式文件导入 Sass使用@import 来导入其它的样式文件从而实现样式嵌套。 变量 Sass允许加入自己的变量，所有的变量以$开头 1234$navbar-color: #3c3e42;.navbar-inverse &#123; background-color: $navbar-color;&#125; 在编译成功后，变量会被替代为对应的值 嵌套 Sass允许选择器中相互嵌套以减少代码量 引用父选择器 在Sass嵌套中使用&amp;对父选择器进行引用： 123456a &#123; color: white; &amp;:hover &#123; color: blue; &#125;&#125; NPMNPM 是Node.js 的包管理和任务管理工具，其强大的功能也是Node.js能够如此成功的因素之一。在使用NPM安装第三方模块（也可理解为扩展包）时，你需要在 package.json 中队需要安装的模块指定好名称和版本号。然后运行下面的命令进行安装： 1$ npm install 在学习教程中，出于安装速度考虑，我们使用更加现代化的 Yarn 来替代 NPM 的包管理功能。然而我们仍然会使用到 NPM 的任务管理功能，如命令 npm run watch-poll。 YarnYarn 是 Facebook 在 2016 年 10 月开源的一个新的包管理器，用于替代现有的 NPM 客户端或者其他兼容 NPM 仓库的包管理工具。Yarn 在保留 NPM 原有工作流特性的基础上，使之变得更快、更安全、更可靠。在后面的项目开发中，我们统一使用 Yarn 来代替 NPM 进行安装包的管理。 我们可通过下面命令来安装当前项目的所有包： 1$ yarn install Laravel MixLaravel Mix 一款前端任务自动化管理工具，使用了工作流的模式对制定好的任务依次执行。Mix 提供了简洁流畅的 API，让你能够为你的 Laravel 应用定义 Webpack 编译任务。Mix 支持许多常见的 CSS 与 JavaScript 预处理器，通过简单的调用，你可以轻松地管理前端资源。我们可以在 webpack.mix.js 文件中制定一些如资源文件的编译、压缩等任务。Laravel 已默认为我们生成了 webpack.mix.js 文件，并集成了 laravel-mix 模块。 浏览器缓存问题问题描述 现代化的浏览器，会对静态文件进行缓存，静态文件在本课程的范畴内，指的是 .css 、.js 后缀的文件。这是一个浏览器的优化功能，极大地加快了网页的加载速度，但是在我们日常开发和维护中，有时候会造成混淆。 开发时，你明明修改了样式，但是刷新浏览器却看不见变化，然后你就来回不断地修改你的样式文件，做各种测试，浏览器页面仍然一成不变。直到你重新刷新好多次，或者修改样式文件名称时，才恍然大悟，原来是浏览器缓存了。 解决方法Laravel Mix，增加哈希值，只要修改，哈希值改变，则客户端浏览器就需要重新加载文件。 对 webpack.mix.js 稍作修改 1234const mix = require('laravel-mix');mix.js('resources/js/app.js', 'public/js') .sass('resources/sass/app.scss', 'public/css').version(); 局部视图随着代码量增加，都存在默认视图中会变得太过臃肿，难以维护，所以最好将部分视图分离出来，成为单独得局部视图。 头部和底部视图首先，我们需要新建一个头部视图文件。 resources/views/layouts/_header.blade.php 123456789&lt;nav class="navbar navbar-expand-lg navbar-dark bg-dark"&gt; &lt;div class="container "&gt; &lt;a class="navbar-brand" href="/"&gt;Weibo App&lt;/a&gt; &lt;ul class="navbar-nav justify-content-end"&gt; &lt;li class="nav-item"&gt;&lt;a class="nav-link" href="/help"&gt;帮助&lt;/a&gt;&lt;/li&gt; &lt;li class="nav-item" &gt;&lt;a class="nav-link" href="#"&gt;登录&lt;/a&gt;&lt;/li&gt; &lt;/ul&gt; &lt;/div&gt;&lt;/nav&gt; 可以看到，我们在头部视图的文件名前面加了下划线 _，这样做是为了指定该视图文件为局部视图，为局部视图增加前缀下划线是『约定俗成』的做法，方便了其它人快速地理解该文件的实际作用。从这里开始，我们都会为局部文件添加下划线前缀。 现在让我们再来为应用创建一个底部视图，用于置放网站的一些基础信息。 resources/views/layouts/_footer.blade.php 12345678910&lt;footer class="footer"&gt; &lt;img class="brand-icon" src="https://iocaffcdn.phphub.org/uploads/sites/KDiyAbV0hj1ytHpRTOlVpucbLebonxeX.png"&gt; &lt;a href="https://learnku.com/laravel/courses" target=_blank&gt; 刻意练习，每日精进 &lt;/a&gt; &lt;div class="float-right"&gt; &lt;a href="/about" &gt;关于&lt;/a&gt; &lt;/div&gt;&lt;/footer&gt; 布局中的链接Laravel中链接地址的写法较为常见的链接地址的写法 1&lt;li&gt;&lt;a href="/help"&gt;帮助&lt;/a&gt;&lt;/li&gt; 在Laravel中，我们可以这么写 1&lt;li&gt;&lt;a href=" route('help') "&gt;帮助&lt;/a&gt;&lt;/li&gt; 大括号括起来的部分是在HTML中内嵌PHP的Blade语法标识符，表示包含在该区块内的代码都将用PHP来编译运行。route()方法由Laravel提供，传递一个具体的路由名称来生成完整的URL。 在 Laravel 中，我们可以通过在路由后面链式调用 name 方法来为路由指定名称： 1Route::get('/help', 'StaticPagesController@help')-&gt;name('help'); 可以看到 route(&#39;help&#39;)为我们生成了完整的 URL 地址，这样当我们需要对生成的 URL 进行更改时，我们只需要改动路由文件即可，由此可见在实际开发中养成对路由的命名是一个好习惯，可以帮助我们节省很多工作量，另外也是 Laravel 项目开发的最佳实践。 均改为href=&quot;route()&quot;的形式 静态页面在我们后面的教程中，将会为应用添加注册登录的功能，本节让我们先来完成用户注册功能的第一步：为用户注册功能创建基本的静态页面。 注册路由当用户访问注册url时，进入我们的注册页面 修改（添加）路由 12345Route::get('/', 'StaticPagesController@home')-&gt;name('home');Route::get('/help', 'StaticPagesController@help')-&gt;name('help');Route::get('/about', 'StaticPagesController@about')-&gt;name('about');Route::get('signup', 'UsersController@create')-&gt;name('signup'); 注册路由时，URI signup 和 /signup 从使用上来看，并无区别，Laravel 框架兼容这两种写法。 注意这里不在注册到StaticPagesController控制器上，因为不单是静态页面，会涉及和数据库的交互，所以围绕用户使用用户控制器来处理此逻辑。 用户模型MVC框架的MM-Model（模型），构建一个基本的用户模型来实现用户数据的存储，并了解Laravel如何对模型对象进行增删查改等操作。后面我们还会在此用户模型上添加用户注册和登录的功能，并对用户进行权限认证，管理员具备用户的删除操作。再构建一套用户账号激活和密码找回系统。 用户认证系统Laravel集成了一整套用户登录注册功能，并提供了一些方便的API，但是出于学习目的，我们会借助一些简单的API来独自开发一个完整的用户认证系统。 如果定制性不高，还是建议使用Laravel的默认提供的用户认证系统。 Eloquent ORM在接下来几章要实现的用户注册功能需要用到数据库来进行数据存储，用于放置用户的基本信息。在这期间，还需要用到数据模型- Model，利用 Laravel 提供的 Eloquent ORM 跟数据库进行交互，实现用户数据的增删改查操作。Eloquent 提供了简洁优雅的 ActiveRecord 实现来跟数据库进行交互。Active Record 是一种领域模型模式，该模式由 Martin Fowler 在 2003 年出版的《企业应用架构模式》一书中进行了详细叙述并命名。其特点是一个模型类对应关系型数据库中的一个表，模型类的一个实例对应表中的一行记录。Active Record 最大优点是允许我们简单, 直观地操作数据层。 数据库迁移Laravel中通过数据库迁移来管理数据库表结构，迁移就像数据库中的版本控制。 好处 多人并行开发 代码版本管理 数据库版本控制：如：回滚重置更新 兼容多种数据库系统 部署方便 默认迁移文件所有迁移文件统一放置在 database/migrations 文件夹里 我们看到Laravel已经默认创建好了两个迁移文件。 database/migrations/2014_10_12_000000_create_users_table.php database/migrations/2014_10_12_100000_create_password_resets_table.php 加入时间戳避免多人开发时候的命名冲突。 创建数据库表up方法里，通过调用 Schema 类的create方法来创建users表： 123Schema::create('users', function (Blueprint $table) &#123; ...&#125;); 两个参数 参数1：表名称 参数2：Blueprint实例的必报（函数依赖关系必报） 定义数据表字段CreateUsersTable 类中通过 Blueprint 的实例 $table 为 users 表创建所需的数据库字段。接下来让我们来详细讲解 Blueprint 实例 $table 的基本用法： 1$table-&gt;increments('id'); 由 increments 方法创建了一个 integer 类型的自增长 id。 1$table-&gt;string('name'); 由 string 方法创建了一个 name 字段，用于保存用户名称。 1$table-&gt;string('email')-&gt;unique(); 由 string 方法创建了一个 email 字段，且在最后指定该字段的值为唯一值，用于保存用户邮箱。 1$table-&gt;timestamp('email_verified_at')-&gt;nullable(); Email 验证时间，空的话意味着用户还未验证邮箱。nullable()方法表示字段可空。 1$table-&gt;string('password', 60); 由 string 方法创建了一个 password 字段，且在 string 方法中指定保存的值最大长度为 60，用于保存用户密码。 1$table-&gt;rememberToken(); 由 rememberToken 方法为用户创建一个 remember_token 字段，用于保存『记住我』的相关信息。 1$table-&gt;timestamps(); 由 timestamps 方法创建了一个 created_at 和一个 updated_at 字段，分别用于保存用户的创建时间和更新时间。注意和前面email的timestap字段区分开。 回滚迁移down 方法会在回滚命令发起时被调用，是 up 方法的逆向操作。在上面的代码中，up 创建了 users 表，那么这里将会通过调用 Schema 的 drop 方法来删除 users 表。 1Schema::dropIfExists('users'); 用户注册本章节为注册页添加一个注册表单 隐式绑定由于我们使用了 view(&#39;users.show&#39;, compact(&#39;user&#39;)) 将用户数据与视图进行绑定，因此在视图中可以直接使用 $user 来访问用户实例。 会话管理由于 HTTP 协议是无状态的，所以 Laravel 提供了一种用于临时保存用户数据的方法 - 会话（Session），并附带支持多种会话后端驱动，可通过统一的 API 进行使用。 我们可以使用 session() 方法来访问会话实例。而当我们想存入一条缓存的数据，让它只在下一次的请求内有效时，则可以使用 flash 方法。flash 方法接收两个参数，第一个为会话的键，第二个为会话的值，我们可以通过下面这行代码的为会话赋值。 接下来的消息提示我们会用会话进行闪存，并分别为其设定好指定的键。danger, warning, success, info 这四个键名在 Bootstrap 分别具有不同样式展现效果，因此后面我们将使用这几个键名作为消息提示的专有设定。 用户CRUD新增的 edit 动作主要做了以下几个操作： 利用了 Laravel 的『隐性路由模型绑定』功能，直接读取对应 ID 的用户实例 $user，未找到则报错；将查找到的用户实例 $user 与编辑视图进行绑定；在将用户数据与视图进行绑定之后，便可以在视图上通过 $user 来访问用户对象。接下来让我们接着完成用户编辑页面的构建。 编辑成功现在的用户编辑功能还有两个地方需要优化： 在每次更改个人资料的时候都输入完整的密码，才能更新其它信息，对于不想对密码进行更新的用户，这个过程会比较繁琐； 更新成功之后在页面上没有进行任何提示，而是直接跳转到用户的个人页面，用户体验非常不好；]]></content>
      <categories>
        <category>编程</category>
        <category>PHP</category>
      </categories>
      <tags>
        <tag>PHP</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[数据挖掘学习——数据驱动比赛笔记]]></title>
    <url>%2Fpost%2F53729461.html</url>
    <content type="text"><![CDATA[数据挖掘比赛简介主要任务对中国青少年科技创新比赛做统计分析 分析目标 各省历年一、二等奖获奖情况比较 东、中、西部地区获奖情况比较 各省获奖最多的学校（集中度） 各省获奖最多的学校获学科类别比较 历年选题相似度比较 工程学项目选题变化趋势 获奖项目水平与学生知识匹配度 2009-2012（有保送）、2013-2014（高考加分）、2015-2018（自主招生（选题和获奖情况比较 三等奖与一等奖在选题上的差别 初步想法编程使用语言：python 使用外部库： jieba用于中文分词 numpy,matplotlib用于科学计算与绘图 wordcloud用于制作词云 利用 python 相关外部库，通过 jieba 中文分词对限定范围内的中文文本进行分词，然后统计词频， 统计词频以后绘制词云图]]></content>
      <categories>
        <category>编程</category>
        <category>数据挖掘</category>
      </categories>
      <tags>
        <tag>编程</tag>
        <tag>数据挖掘</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[数据挖掘学习——TF-IDF算法原理学习]]></title>
    <url>%2Fpost%2F2ee4d523.html</url>
    <content type="text"></content>
      <categories>
        <category>编程</category>
        <category>数据挖掘</category>
      </categories>
      <tags>
        <tag>编程</tag>
        <tag>待补充</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[编译原理学习——《编译原理》龙书读书笔记（一）]]></title>
    <url>%2Fpost%2Ff8e4bc7f.html</url>
    <content type="text"><![CDATA[第 1 章 引论目标语言翻译成一种能被计算机执行的形式，完成这一过程的软件系统称为编译器（compiler）。 本书介绍的是设计和实现编译器的方法。 本章内容 介绍语言翻译器的不同形式 在高层次（概念层次）概述一个典型编译器的结构 讨论程序设计语言和硬件体系结构的发展趋势 编译器理论和计算机科学理论的关系的一些事实 给出一些在编译器设计领域以外的应用 语言处理器编译器，和解释器（Interpreter）是常见的两种形式。 主要区别：解释器并不同编译器一样将源程序编译成目标程序，而是对源语句（结合用户的输入）逐条解释执行。 预处理器，除了编译器之外，创建一个可执行的目标程序还需要一些其他程序，比如将程序员写程序时划分的多个模块聚合在一起的任务，以及将称为宏（micro）展开成源语言格式的任务，有时就由预处理器完成。 一个编译器的结构通过编译器，源程序映射到目标语言程序（语义上等价），映射过程大致分为分析和综合两部分。 分析（analysis） 把源程序分解为多个组成要素，加上语法结构，创建中间表示。 检测是否符合源程序语言语义并给出用户相应提示，同时收集源程序的一些信息，存放在一个称为符号表（symbol table）的数据结构中，然后一并传送给综合部分。 综合（synthesis） 根据分析得到的中间表示和符号表中的信息来构造用户期待的目标程序。 常称分析部分为编译器的前端（front end），而综合部份为编译器的后端（back end）。 编译过程可以拆成一组过程（phase） 词法分析词法分析（lexical analysis）或称为扫描（scanning）。读入源程序字符流，拆成词素序列，词法单元和一个符号表。 语法分析语法分析（syntax analysis）或称为解析（parsing）根据词法单元的第一个分量创造一个树形的中间表示，一种常用的表示方法时语法树（syntax tree）。 语义分析语义分析器（sermantic analyzer）使用语法树和符号表中的信息来检查源程序是否和语言定义的语义一致。同时收集类型信息，在随后的中间代码生成过程中使用。 一个重要部分时类型检查（type checking），同时实现（如果允许的话）自动类型转换。 中间代码生成]]></content>
      <categories>
        <category>编译原理</category>
      </categories>
      <tags>
        <tag>编译原理</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[编译原理学习——基本概念梳理]]></title>
    <url>%2Fpost%2Fe8bc7157.html</url>
    <content type="text"><![CDATA[正式上课前注意点梳理关于编译原理学习编译本身是一个超级算法，其中分成两大部分：理论和技术。 编译原理的学习不同于离散数学，离散数学的各个部分是相对而言分离的，各部分没有直接的前后因果关系，但是编译原理作为一个“算法”，是一个整体，前后贯通和呼应，因此，在学习编译原理的过程中，必须把前面的基础学懂了才能应对后面的内容。 根据教材，《编译原理》第一章到第五章侧重于理论，第六章和第七章是理论与技术结合，再后面的章节主要是计数方法介绍。 《编译原理》学习的要点在形式语言和自动机，所有的一切最终都是归结到自动机的理论和应用。 巩固好前驱课程，如数据结构、高级语言程序设计、汇编语言等专业课程有助于编译原理课程的学习。 关于数学的客观来源与表现形式编译原理学习中提到的形式语言与自动机。 形式语言和自动机，是从两个角度、使用两种建模方式对相同客观对象描述的两个“等价”的数学模型，各有其在不同的环境下的用途。 数学的形式是主观的，但来源是客观的，都是对客观世界的抽象。主观性表现在抽象的形态是“随心所欲”的，同一个对象可被抽象为不同的数学表示方式和运算方式，但其根本性是客观的，离开了物化的或具体化意义的数学是不存在的，如果存在，也是毫无价值的。 初识“自动机”话放在前面，不是严格意义上的自动机，而是为了方便初学者理解的“简化版自动机” 为了方便理解，先行介绍“简化”的自动机，我们当下可以认为自动机是由$n$个状态组成的状态集合，$S= \{ s_1,s_2, \cdots ,s_n \}$和$m$个字符组成的输入字符集合，$\Sigma = \{ a_1,a_2, \cdots , a_m \}$构成的二元组，即$自动机 = $ 但是真正的自动机不是二元组，而是五元组。作为初学者，可以先从理解这个二元组形式的来入门，更容易从本质上理解什么是自动机。 核查正确性，很容易联想到构造一个“字典”一样的存在，但是不可能用一个标准的字典来穷尽所有正确的单词（单词可能是无穷的）。那么自动机就起到了这个包含了无穷个单词的字典的作用（核查）。 要完整地弄懂自动机概念，需要四个方面的基础知识：集合，笛卡尔乘积，关系，函数。 当然，掌握了自动机理论，离使用这套理论构造程序语言的编译程序还有一段距离，即理论到应用的距离。应用辨识能力，需要慢慢学习。 所谓“语言”科学和数学的定义，一是要普世、二是要精确。 回顾“关系”，关系的数学定义是：A 集合到 B 集合的笛卡尔乘积的子集。 那么，语言的数学定义是什么？ 语言的数学定义：语言就是字符串的集合。 广义的“语言”，科学和数学方式定义的语言意义重大。最大直接好处是：这些概念所表的东西可以被以数学方式进行处理，比如，列出方程并求解方程，列出逻辑公式并推理，等等。 既然语言是字符串的集合，我们可以进一步用一个公式产生某些字符串的集合，遗憾的是，有些字符串的集合是找不到公式来产生的。言下之意，有些肯定是可以用公式产生的。我们编译原理关心的是这些可以由数学公式产生的字符串的集合（即语言） 形式语言的数学定义：可以由数学公式产生的语言就叫做形式语言。 人类的自然语言是不可以用数学公式表达出来的，否则，自然语言识别就是 100%准确并且 100%听懂人类语言的机器人也能被制造出来。 尽管人类语言无法用数学公式统一表达，但是程学设计语言是可以的。实际上，是先数学公式做好，再产生出对应的程序设计语言。 这个“数学公式”叫做文法或语法。 例：G 文法形式是：$S \rightarrow aS|b$ ,其中$S$叫做非终止符，在这里也做开始符号，整个公式叫做产生式集合。 其推出的语言 $L = \{ ab,aab,aaab, \cdots \}$。 用数学公式（文法）表示的语言可以很方便的被处理，因为这个语言的特征都通过文法集中体现了，我们只要针对文法进行处理，就等价于对整个语言进行了处理。通过掌控有线而驾驭了无限。 《编译原理》可以告诉你如何分析程序设计语言的文法来驾驭这个语言。 人类语言的变化多端和本身造句的模糊性以及其本身不断地发展变化（包括规则本身的变化），使不可能被一个或一组数学公式（形式语法）完全表达。 程序设计语言不是实践的结果，而是先规定了数学公式，然后再要求用数学公式的法则来写程序。 语言是字符串的集合，所以语言就会有子集的概念，其实，我们也可以将人类语言中的一些子集用形式语法表达出来，从而实现自动化。比如语音售票机等等。 经典名句：“买一张济南到长沙的火车票”，和“我要独自一人乘着钢铁巨龙回到梦开始的地方、湘江之滨的湖南省会”，人类能理解意思相同，不过呢，售票机恐怕就不行了。 再谈“形式语言的文法”和“自动机”的关系任何一个语言的文法都有一个等价的自动机，反之亦然。也就是说：文法和自动机本质上就是同一个东西，或者说是同一个东西的不同数学形式（在前面已经提到过对同一客观存在的不同刻画）。 而刻画的事物，实际上就是形式语言。 形式语言和自动机本质上是一个东西的不同数学表示，因此，再很多需要区别的情况下，无论是使用“文法”、“语法”、还是“自动机”，都没有区别，其混合使用的时候我们更应理解它们指的是同一事物（形式语言）。 文法分类问题文法的分类是个需要专门花大量时间来讲述的事情，《计算理论》中由四分之一到三分之一的内容实际上实在讲述文法的分类，可见，这不是一个几句话就能说清楚的问题（文法分类的专业深度很深）。 词法是关于单词的构成方法，单词是程序语言中最简单的字符串，比如，用户取得变量名称，但是要将一个个单词连成更长的字符串，法则就会难度大很多，显然不单单是检查单词那么简单，这个时候得文法就叫做“句法”（在我们学习的课程中，习惯句法叫做语法） 教材的编写也符合从易到难的原则，第三章是词法，第四第五章是句法。 词法，难度低 句法，难度高 它们都是文法 但是，需要提醒的是：从形式语言的角度看，单词和句子本质上是一个东西，毫无区别（都是字符串），只是相对长短不同而已。 专门针对单词的自动机（文法）肯定是文法中最简单的一种，或者说是一个完整语言中的一部分，我们把这部分专门描述单词组成规则的部分叫做“词法”。 For example，C 语言的单词拼写是否正确就是靠 C 语言的词法（自动机）来判定的，把源程序输入自动机，自动机将逐一检查单词，如果有错误就会报警，指出错误。如果全部正确，那就输入这些单词，以备后面使用。 当然，只检查单词拼写规范是远远不够的，所以 C 语言词法（自动机）仅仅是其中的一部分，还得有检测句法的（人为分类）如 if else 这样的结构是否合法。 再说语言再次强调核心概念：语言是字符串的集合。 关于问题及其求解的思考，其实也跟“语言”有密切关系。 （下面基本上原封不动搬运徐老师的讲解） 首先给你一个论断：凡是能用字符串表达出来的问题就都是一个语言。很吃惊是吧？按照这个说法，世界上的问题就没有不是语言了（因为你总要用字符串的集合，即语言，把问题表述出来）。 确实是这样，有了“语言是字符串的集合”这个定义后，世界上的任何问题都是一种语言，对于任何问题的解决，本质上就是看这个问题（即语言）是否能够用数学公式（文法）表达出来，更专业的说法是，世界上所有的问题都是语言，问题是否可解等价于该语言是否可计算，“可计算”的基础就是这个问题（即语言）是否可以用形式文法表示出来，如果能用形式语法表示出来，也就等价于存在一个自动机，它可以接受这个问题，即解决这个问题。 比如，我要你计算一个题目，题目是这样出的：“请计算 2+3=”，这个问题不就是个字符串吗，答案就是自动机（假设存在）输入问题字符串后的最终状态。 总结：世界上所有的问题都是语言 那么，把世界上所有的问题都归结为语言，这有什么意义呢？ 意义很大，要理解这个问题一定要系统学习《计算理论》才能知道。 举一个语言被广义化后的意义，这是我们计算机学科特别关心的意义。计算机学科的基本问题之一：什么问题是计算机可以解决的，大致等价的问题是：什么问题是计算机不能解决的 答案是：凡是能够用形式语法（自动机）表达的问题都是可以用计算机解决的，否则就是不可解的。 计算机不是万能的，有些问题（即语言）已经被证明是不能用形式文法表达的，对这些语言（即问题 ），你就不要试图用计算机去解决它们了。 如果理论上不可解，那就彻底不可解。理论上可解，现实中也不一定可解。用逻辑术语来表达，理论上可解是现实可解的必要条件，但不是充分条件。 语义分析和中间代码生成为什么需要语义分析诸如类型匹配等检查仅通过词法和语法是难以实现的，类型不匹配这种语义分析要扫描前后文字，这就是“语义分析”也叫作“上下文相关分析”的原因。 按照分治的思想，设计出中间代码，介于源代码和目标代码（汇编语言代码或者机器码）的一种代码方式。 中间代码形式举例逆波兰式 逆波兰表达式也叫做后缀表达式 要是中缀表达式复杂了，可能就不容易凭经验和概念很快写成等价的后缀式，中缀表达式转换为逆波兰式是可以用程序来完成的，这样，无论多么复杂的中缀表达式，机器都能迅速地转换为后缀式。具体的算法微信上很难写，你们先记住有这么个算法，上课时就有准备了。 三地址码形式 三地址码形式的主要特点是：一个等式中只能出现三个地址（变量）。 三地址码的具体写法又可以有三元式、四元式等等，这些形式中，一个表达式中只会出现三个地址。]]></content>
      <categories>
        <category>编译原理</category>
      </categories>
      <tags>
        <tag>编译原理</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[数学建模——美赛2019E题]]></title>
    <url>%2Fpost%2F4c60a529.html</url>
    <content type="text"><![CDATA[第一天上午定题目E题，环境相关 关键词：环境退化，环境成本，生态经济，适应性模型 下午开始着手搜集相关论文资料，包括但不限于，生态服务功能价值评估模型，水源森林生态资源衡量标准 建模思路，层次分析法，搜集大量数据获可能影响生态成本指标体系的层次结构 预想的指标： 评估指标 1 8 24 60 112层次分析法AHP 113 第二天整理下思路，层次分析法（照着ppt又回顾了下） 搜集数据？不需要细致工程的数据，但是要能衡量大中小型项目的污染标准。]]></content>
      <categories>
        <category>数学</category>
        <category>数学建模</category>
      </categories>
      <tags>
        <tag>数学</tag>
        <tag>数学建模</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[《無印良品的改革》读书笔记]]></title>
    <url>%2Fpost%2F4ab96b49.html</url>
    <content type="text"><![CDATA[序言 新“無印神话”的开端無印良品在日本的三大直营店：有乐盯店、京都的Platz店与打扮的难波店，其中有乐盯店是一家主要负责向社会大众宣传無印良品的店铺，几乎汇聚了全部经营的商品。 笔者采访一位职场女性，问是否经常来，得到的答复是这样的。 P005 “是的。这些日杂物品只是看看就令人心情愉快，平时换季的时候我也会来这里买衣服。实际上我也买优衣库的衣服，但是由于细节设计上没有特点，所以只是作为内搭穿在里面。与此相比，無印的没一件服装都很有风格，所以我很喜欢。在我还上高中的时候就经常来购物了，但不知从何时起，無印的商品和店铺失去了特色，觉得失望之后有段时间就没有来过了。但是，从三四年前無印又变的非常吸引人，因此我很高兴又来购物” 诞生既是荣耀，不知为何跌落，却又重回巅峰。这本书大概讲述的，就是讲这样一个世界品牌的故事。 理念、感性与科学的有机结合。在生活理念中看到科学量化的务实，却绝不会倒向向性价比等纯粹科学量化的指标，而是站立在理念这感性的一方。 第1章 無印良品的诞生及其迅速发展西友创立無印良品，本就是走在“品牌热的对立面”，一句“因为合理，所以便宜”广告，打破了人们购物的思维定势，从而引导人们重新审视品牌、价格、品质三者之间的关系。好称无品牌（No Brand）的無印良品，恰恰是宣传的这样一种不愿拘泥于民族品牌而诞生的New Brand。 广告海报上写着如下内容 P010 “不依赖品牌和包装来选择商品。这不仅与热情的生活方式相结合，也是一种重要的态度。” 無印良品品牌诞生的原动力：做质量不低于民族品牌但不为品牌做无用功（无谓支出）的优质产品。 無印良品的商品开发及生产的基本理念：选择优质原材料、不断改良生产工序、商品采用简约包装。 生活习气与生活美学的艰难选择二者实现的途径都要求回归生活本质，但是内涵却大不相同。 P027 “但是，要正确划分‘生活习气’和‘生活美学’之间的界线是极其苦难的。所以，商品上架前的最后检查都交给了富于感性的设计师团队。正是装也判断商品合适与否的顾问团队，在無印良品的发展过程中发挥了巨大的作用。” 無印良品从西友集团的独立木内任负责人时期，对無印良品不能掌握自己商品的众多核心信息（诸如完整的销售记录，开发成本等）而对品牌深感忧虑，在他的眼里，無印良品错过了成为子公司的最佳时节，现在却成为了西友的门面工程，这与品牌的初衷越走越远。 P013 “也就是说，‘西武集团式特色’一直将品牌形象摆在前面，这样一来，無印良品的经营就变成了‘看不见的经营’，这正是木内先生深感危机的原因。” 第2章 从一帆风顺到遭遇挫折从無印从西武集团独立出来，便掀起了一股“無印热”，开店邀请纷至沓来。1993年，無印良品首次开设了拥有大型卖场的直营店——無印良品LaLaPort（位于千叶县船桥市），1995年，無印良品在店铺正式公开售股，在获得充足资金后，無印良品又快马加鞭地开设了更多店铺，从100坪，300坪，500坪最后到1000坪。 然而新开店铺收益不及预期，往往是开设与关闭同时进行，而且随着店铺体量的扩张，为了填满店铺的货架商品种类数，不得不加快新产品的企划。这种“赶工”式的做法为后来的品牌危机埋下了伏笔。 扩大战略背后暗藏的“失控”以及顾客是否也远离了無印良品，两朵阴霾让这个品牌的发展道路的头上。 第3章 致使無印良品走向凋零的八大原因高层人事调整，由松井忠三接任有贺馨担任良品计划的社长。 一家家店铺的走访，一点点打开店长们的心结让他们敢于张口说话，在不懈的努力下，新社长总算对品牌危机的原因有了一个更清晰的认识。 P059 “对于良品计划业绩突然下滑的原因，一共可以总结出八条。当然，这些原因之间都是相互关联、相互影响的，正因为各个要素相互重叠，才给無印良品的业绩带来了严重的问题。” 原因1 成功带来的自满情绪 P059 “全体职工在经历無印良品的成功之后，在不知不觉中变得自满起来。” 前期发展一帆风顺，在泡沫经济中逆势增长，售股募集资金，上市过程也是顺风顺水，加之不断增开的大型直营店，无论怎样说都取得了一定的瞩目成果。上述的种种，居安思危精神的懈怠，笔者这么描述的。 P059 “此时，無印良品的员工认为不需要向其他公司学习，只要维持现状即可，由此，大家便失去了谦逊的态度和用心做事的优秀品质。与此相对，在这期间，埋头研究和学习的竞争对手，在不久之后便开始崭露头角。” 原因2 大企业通病的腐蚀内部结构过于僵化，纵向延申过长，不够扁平化带来的最直接的影响就是运行速度的相对迟缓，对市场的讯息反应不够快。 过去很多优秀的传统变成了“例行公事”，在無印良品里，最典型的就是对于开店事宜的讨论和决议。 P060 “在决定开设门店之时，公司应该重视对该场地条件最为熟知的开发部长的意见，随后才是经营的最高责任人社长做判断。但此时無印良品的实际情况是，几乎每个项目都采取董事会举手表决制，根据少数服从多数的原则决定是否开店。回忆当时的光景，松井说道：‘那时的状态就好比众愚政治一样。’” 原因3 忘记根本，只顾眼前采取的诸多应急措施，有违品牌设立之初的形象，为了应急而应急，却忽视了长远利益的考量。丢失了原则。比如服饰方面一改商品原本只有黑白和自然色的基调，加入其他颜色，这些无视“原则”的商品也被摆上了無印良品的货架。 原因4 品牌自身的弱化没有专攻品牌的建设，初期品牌优势很大，但随着市场竞争的增强，不再进行品牌理念的打磨最终结果将是被竞争对手淘汰。 P062 “但是时代在进步，消费者的信息收集能力也在飞速提高。同时，其他竞争对手的商品生产也提高到了可以与無印良品相抗衡的水准。在这种情况下，自己十多年前便再未打造锤炼的品牌也必然无法应对市场的巨大变化。” 品牌理念过于强烈对于继续锤炼品牌价值也提高了难度，负责打造品牌的组织结构变得很弱，無印良品内部根本就不存在这样的部门，同时拥有的个人理念都停留在大脑中，不能实现理念的广泛传播，或者作为企业资产实现共享。 P063 “总而言之，个人所拥有的知识和技术无法作为部门及企业的资产共享 ，更无法累积。因此，打造品牌的部门缺失为以后业绩下滑埋下了重大的祸根。” 原因5 店铺开发战略的失败店铺规模逐步增长最终过于庞大，而且太过急于开店。在扩充商品生产和完善供给体制之前，無印良品优先做的是扩大店铺面积。 这种模式在中小型规模（低于300坪）的店铺还未见问题，但是到达500坪、1000坪，涉及到产品的企划开发，就显得很吃力了。 开店规模不合适，新产品的企划开发难以跟随开店速度，新店开设“众愚政治”状态导致的开店不够谨慎，都划归为店铺开发战略的失败。 原因6 社长新旧更替良品计划的“创始人”，或者为这家公司注入灵魂的关键人物木内政雄社长回到西友总部工作，也时無印良品走下坡路不得不考虑的一个因素。 P066 “因为在创业阶段，由社长决定应该采取何种战略来经营公司是最为重要的。但是，过了创业期转入下一发展阶段时，领导者身上所必须具备的是能切实地实行经营战略地调动能力及使公司内部抱成一团地能力” 领导者需要有不同于常人地能力，无论公司出于什么时期。 P066 “从创始人手里接过管理权地领导行事必须谨慎，并且一定要有组织能力。为了使企业能够不断发展，建立完备的组织体系和创造相应的公司氛围是非常重要的。而無印良品在以上条件都未具备的时候，公司就脱离了创始人的指导和运作。” 原因7 对专于创造的初衷产生了摇摆“优秀的平均化”策略本是無印良品立足的根本，但是店面扩增，销售压力的增大，“卖掉就好了”思维也逐渐侵蚀了产品本身。而且，时代在变，年轻一代对著名设计者如数家珍的时候，無印良品的商品开始走向腐朽。 原因8 优衣库及大创等劲敌的出现外部原因——竞争对手的强势崛起。百元店对小物品市场的攻占，优衣库连续三个季度畅销夸张一点说是将所有同行企业（服装部门）推进了水深火热中，以及似鸟公司（NITORI）以家具为中心与無印良品相抗衡。 第4章 改革从服饰开始先是一扫堆积如山的存货，改变过量生产模式，提升整体企划更新的速度，维持上架货品的新鲜度以及正价销售率，同时海外店铺也进行存货清扫、“止血”。 “可视化、计算、行动”生产过程的信息不够公开透明，基本上仅存在少数人脑海中（营销总监）。 P085 “于是，在2002年，以三零商社的三位负责人为中心，無印良品开始实施经营改革工程。首先公司推行的是改善业务流程，以求能够让公司员工清晰地看到商品生产的过程。其次，召集良品计划女士服装、男士服装等各个领域地经理和营销总监以及总代理，为这些人创造探讨如何改善业务地机会。到了现在，这种习惯也被延续了下来，服饰杂货部每周都召开项目会议。” 单品的原价销售率、折扣销售以及剩余货品的相关数据都被一一记录下来，以这些数据为基础，無印良品提高了计划生产的精确度，从而进行了业务改善。 在销售情况可视化基础上，掌握商品畅销和滞销情况（無印良品SABC等级分析），结合订单业务，降低错失机会以及库存损失的风险。 改良后的商品周期，分类如图 名称 销售时间 备注 YF（全年使用款） 全年 在20世纪90年代占全部商品的一半 SB（季度基本款） 26周 每半年更新一次 ST（季节流行款） 10周左右 目前女装占80%以上 由过去無印良品认为的“一直摆放在卖场里就能获得安心”，颇为重视YF款到现在结合顾客对“卖场变得无趣”等建议做出的种种改变，质朴与安心中也要透露出改变、心意与诚意。 P092 “生活用品还可以因为顾客的喜好保持不变，但服装与此不同，如果一成不变就难免让人感到厌倦。另外，即使不改变基本款的服装，也应该在服装的方向感上做出一些变化以适应潮流。于是無印良品决定先设计出基本款服装，然后组织一个能够把握方向感的团队。” 与山本耀司公司合作，山本耀司公司发挥其创造力，把握产品方向感，而無印良品则将其理念注入其中，并负责其全程的销售。 P98 “以‘文化’和‘感性’为主题发展起来的良品计划，转而以数据及标准值，即‘数值’为基础构筑起最合适的生产、销售组织。” 第5章 商品生产方式的进步观察法的革新，从造方消费者的住宅来捕捉新的需求。全球·無印，与世界顶级设计师联合，匿名设计，将个人设计的概念融入企业的理念。从世界各地获取新的灵感，创造新产品。 重建总部与店铺的信赖关系，关注过去忽略的企划速率，以及开发效率的问题，整体提升店铺商品的质量。 第6章 实施新的开店暂略从岛村那里学来的，整理出规范化的“开店标准手册”。这样，经验的可视化、标准化，让新手也能按照“無印”式要求去勘察一块商圈是否适合开店。 开店空间的计算 P122 “统计出每个商圈的零售业销售额后，乘以無印良品的市场占有率，如此便可以算出無印良品在各都市商圈能够确保的市场占有额。然后用上述结果减去现有店铺的销售额。然后，用上述结果减去店铺现有销售额，就饿能够推算出来尚未确保的占有率，即开店空间。” 销售额空间 = \sum_i 店铺i销售额 \times 市场占有率 - 现有店铺销售额通过SABCD准则对开店水平进行评估，评估参数包括：市场、商业设施、店铺环境三大方面以及和周围竞争环境的综合考量。每一个大方面又细分成几个细致的指标，甚至人口的收入差距，标准楼梯高低都考虑在内。 無印良品从过去的实际成绩中，渐渐积累了这些选择开店地点的智慧。 开店讨论会与日后的主要战略以及对于新店开设的讨论会，听取了岛村集团时任社长的建议，不是喋喋不休的说明，而是针对开店手册（规范标准）进行必要的说明，然后销售总部部长和开发部长负责提出更加具体和更具实质性的问题。 公司进行了整体调整后，德江先生列举了三个今后开店的重点策略： 扩大店铺的面积。 但不是无限扩张，将200坪定义为标准型店铺，为了强化生活用品部，逐步发展250到300坪的卖场。 推进500坪店铺的开发 目的是增加家电、自行车等生活用品的摆放空间，用来和似鸟等品牌竞争。 挑战地方的小商业圈市场 建立起能够在小商业圈内运营的成本构造，定位可行的开店环境。 海外情况欧洲市场则是通过雇佣当地设计师重新设计符合当地需求的服装样式，几番更改后，海外服装设计步入正轨，扭曲为盈。通过加盟许可（Licenced Store）的方式扩大市场占有率。 中国市场，在与冒牌無印店的官司中获胜（MUJI当时出书时还未），已经说明了其在东亚这个广大市场的热度。 美国市场 P143 “2004年10月，無印良品在纽约现代艺术博物馆（The Museum of Mordern Art 简称 MOMA）的零售业部门——“设计门店”的53街开设了店铺。由于顾客的反映良好，無印良品的卖场面积也比当初开业时变得更宽敞了。” 第7章 大幅度压缩成本的“30%委员会” P147 “为了进一步提高竞争力，松井忠三社长确定下一步的改革重点就是削减销售管理费（销售费用和一般管理费用）2005年2月，松井在公司内设置了直属社长的‘30%委员会’（升级后的‘30%项目’）。” 30%委员会设定了多个改善项目，包含： 店铺内作业 物流 总部业务 直接贸易 店铺租金 保安与菜场管理 人工费 监察室对于不必要的重复流程进行简化，同时对同一监察人执行的监察项目进行复用，并重新审视检查项目的覆盖范围。 P150 “还有，顾客的预付款、返还款以及遗失的财务等，無印良品都会对此进行一一登记后存放在保险箱里。但是，把这些现金的进出归入检查项目、本身既不自然，也成了一种浪费。如果有顾客把财务遗失在店里，只需要立即送到附近的警察局就可以了。” 此外，还有重新合理规划店铺内店员的工作流程，减少不必要的行动浪费，减少标签等等措施。 無印良品的经费结构目标 P155 “各综合超市的销售管理费比例一般在27%左右（2006年度），连锁超市也有不少企业在24%左右。被良品计划视为加盟店运营榜样的岛村集团只有21.5%（2007年2月决算期期末实际数据），与之相比，良品计划的31.5%与其相差了10个百分点。” 这些百分比都是销售额的百分比，嗯这个是常识。 第8章 改变卖场员工的工作一份“店铺工作指南”只有16页，浓缩了开店中种种问题，给店长合理分配员工工作提供了可靠依据。 P172 “如此制定出来的‘店铺工作指南’，其内容网罗了员工从开始上班到关闭店铺、离开店铺为止的所有业务项目。为了便于临时工理解，指南内海使用了彩色图解，为了使员工更容易把握住要点，标题一般都使用简介、易于理解的表达方式，如某一章节的标题为‘什么是实现商品上架的高效化？’” 考虑到了临时工，而且都是通过简介、直观的方式展现出来，可以说整个店铺工作指南也是無印良品理念一脉相承的产出，即避免一切不必要的浪费。 比如，指南中规定收银台的工作主要由两类员工负责：一是主要负责收银的员工，二是辅助收银的员工。这两类员工分别为‘100%收银负责人’和‘50%收银负责人’。另外，指南中还配有插图解释员工如何根据顾客流动数量来应对收银工作。 根据SABCD等级划分的商品，也在指南中给~出了不同的整理拜访策略：S级和A级商品一天上架三次，整理两次，而C级和D级商品则各一次。 地方诞生的“畅销商品搜索队”精确到检查店长们是不是精确了解自己家店面的情况，销售量排名前五的商品，以及对畅销商品摆放位置的检查，摆放方式是否恰当等细节。这就是精确到每一个销售单位的最细致的监督。 P177 “另外，对于业绩特别低迷的店铺，田中等三人则每天早晚一次进行训练，并且训练时间长达半年之久。早上三人对店长作出指示后，当天晚上则再次来到此店确认其执行情况。由于三人每天都去视察，因此不仅对店长，而且对员工的工作状况都能细致地把握，最后还是看到了店铺的小小进步。每当发现进步的时候，田中等人就会表达出来，以此激发员工的工作积极性。” 也正是因为这种“简单粗暴”方式的有效（其有效性很大程度和日本地区人们的工作态度有关），所以总部发现这一方法后将其推向全国。 “一品入魂”、“天下一品”、“幸运单品”都属于营销手段，设定某一目标商品，然后设定能力上可以达到但是之前都为达到的，根据其覆盖范围可以分为店铺型、区域型的。 带着自信去推销，并依照成绩对其嘉奖，这种方法很有效果。 P184 “系统和人心之间有很多相反的地方，但如果将这些词置换成‘数值’和‘感性’的话，就能与良品计划所开创的平衡经营息息相关。只要公司具备完善的组织结构继续支持销售员工的积极性，那么相信卖场的意识改革就会不断顺利向前推进。” 尾章 良品计划的未来与今后的课题無印便利店的可能性根据市场分析，通过大型卖场销售無印的产品早晚会达到开店以及销售额的天花板，所以良品计划将目标瞄准了日客流量更大，分布小但覆盖更为全面的便利店。 P188 “而通过与便利店合作，無印良品便多了一个向消费者传达商品信息的据点。便利店和专卖店的顾客之间还是有很大区别的，特别是无印良品的顾客有‘执着’的一面，商品能够进入更多消费者的视野中是具有重大意义的。” 重启食品部门無印良品创业之初，食品部门曾作为基础部门之一，但是随后的发展却不及其他部门，一大原因是顾客构成的固化。 P195 “可能是由于过度锤炼商品的品质和感性，反而导致粉丝层受到限制。” 所以放低顾客的受众面，从而增大無印理念影响的消费者的范围，是进后無印良品的主要计划之一。 P196 “無印良品所应该追求的是商品所具有的吸引力，维持品牌形象，或者更高的目标。” 利用电视广告从过去基本不采用外媒的态度转化为每年举行一次企业主题的发布会，無印良品的转变是明显的，同时也是必须的（扩大顾客层）。 03年的“無印良品的未来”，04年的“無印良品之家”，05年的主题则是“茶室和無印良品”，具有强烈主题感的发布会也是迈入新发展时期后，無印良品不停向外界传递的信息：無印良品已经不只是简洁朴素。 收购家居公司IDEE作为無印良品分支业务的拓展，仍然贯彻“坚实的外表，可变化的内部，并且能够根据生活方式自由地改变房间地布置”的理念，但与之前無印良品自己的家具产品不同的是，IDEE风格更加现代一些， 无印良品官方也是这样定义的： IDÉE：为空间增光添彩、赋予趣味。 无印良品：以极度简约为魅力。 IDÉE+无印良品：二者相得益彰，为生活的各个场景提供令人喜悦的组合。]]></content>
      <categories>
        <category>阅读</category>
      </categories>
      <tags>
        <tag>阅读</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[请你振作下去]]></title>
    <url>%2Fpost%2F703409c5.html</url>
    <content type="text"><![CDATA[不要再这样下去了 请你自己振作起来]]></content>
      <categories>
        <category>随笔</category>
      </categories>
      <tags>
        <tag>随笔</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[算法与数据结构学习——数论专题]]></title>
    <url>%2Fpost%2F22b5b237.html</url>
    <content type="text"><![CDATA[数论专题复习前一部分来源于网络Wannafly Winter Camp冬令营 Day1 数论专题 Tangjz 整除理论约数（因数）和倍数的定义。 以及：整除关系的传递性，约数的倍数的线性组合仍为倍数，整除关系为偏序关系反对称推出相等。 模意义下容易忽略0的问题。 质数和合数的定义：对于$\forall n \in Z$，如果$\exists_{k \in Z, k \neq1, k \neq n} k \mid n$ 则$n$ 为合数，否则为质数 一些性质 若 $n \in Z^{+}$，则$min_{k \mid n} k \le \sqrt{n}$ 对于$\forall n \in Z^{+}$，存在唯一的指数分解$n = \prod_{i=1}^{n}p_i^{e_i}$，这里$p_i$互不相同 令$\pi(n)$表示不超过$n$的质数个数，有$\pi(n)=\Theta(\frac{n}{\ln{n}})$ 给出n可以知道比n小质数个数的渐近界 例：2017CCPC合肥网络赛人从S,S+1,S+2,S+3…S+n-作为1,2,3,4,5,6….n 贪心结论：n&gt;S的部分 都会按j=i座（这时候最优）。然后根据质数密度判断是否有两个质数，然后暴力匹配?? 继续整除理论 公约数对于 $x_1 , x_2 , \cdots , x_n \in Z$ ，且 $\forall_{i=1,2,\cdots,n} d\mid X_i$，则称 $d$ 为它们的公约数 当$x_1,x_2,\cdots,x_n$不全为零，存在最大的公约数，称为$\gcd(x_1,x_2,\cdots,x_n)$ 当$\gcd(x_1,x_2,\cdots,x_n) = 1$，称$x_1,x_2,\cdots,x_n$互质（互素），注意这里说是整体互质而不是说两两互质。是个大坑。 $\gcd(a,b) = \gcd(a,b-a) = \gcd(a,b \mod a)$ 欧几里得算法：辗转相除 时间复杂度分析：$O(\log a+ \log b)$ 公倍数同余理论不定方程之前有课件 有理逼近数论是整数方面的研究，有些地方将无理数用无穷级数+有理数表示。 数论函数使用迪利克雷卷积（暑假课程）进行推导]]></content>
      <categories>
        <category>编程</category>
        <category>数据结构与算法</category>
      </categories>
      <tags>
        <tag>编程</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[算法与数据结构学习——深入学习基础篇]]></title>
    <url>%2Fpost%2F7169c4ed.html</url>
    <content type="text"><![CDATA[关于数据的一些易混淆概念 数据：信息的载体，能够被计算机识别、存储、加工，包括整数、实数、字符串、图像、声音等 数据元素：数据的基本单位，也称结点、元素、顶点、记录。一个数据元素可由若干个数据项组成 数据项：是具有独立寒意的最小标识单元，也称字段、域、属性等 数据结构：指数据之间的相互关系，即组织形式，有逻辑结构（一般程序中出现的形式）和物理结构之分（内存中的连续存储形式）；逻辑结构又有线性（非空，仅由一个开始结点和一个终端结点，除首尾结点之外，所有节点均只有一个直接前区和一个直接后继，如一维数组、栈、队列、链表、串等）和非线性之分（一个结点可以有多个直接前区和多个直接后继，如多维数组、广义表、树、图等）]]></content>
      <categories>
        <category>编程</category>
        <category>数据结构与算法</category>
      </categories>
      <tags>
        <tag>编程</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[校园导航系统CampusNavigation（C++实现）]]></title>
    <url>%2Fpost%2Ff7b33ddd.html</url>
    <content type="text"><![CDATA[课程设计选题及要求选题 6：校园导航系统设计一个校园导航系统，为学校来访者提供各种信息查询服务，方便查找学校主要单位、校园景点之间最短距离，并能及时对该图进行更新，地点信息包括名称、代号、相关介绍等，及两个地点之间有直接路径的距离 基本功能与技术要求 数据文件管理功能：创建新文件、打开文件、保存文件。 计算与统计功能，完成记录中相关数据的统计； 能够打开已存在的数据表文件，计算任意两个地点之间的最短路径的长度及途经地点。 提供来访者从出发地到目的地的路线统计，以图示界面输出。 记录管理功能：记录的管理采用链表、数组等实现。 输入／添加/插入记录，并保存到数据文件中。 查询、显示记录，根据用户要求按所给地点查询单位或景点信息，以及到地点的问路情况等。 修改记录：能够打开已存在的数据表文件，并对确定的任意记录进行修改，在修改过程中，应显示记录信息，给出确认提示，并对更新的记录信息进行文件保存。 删除记录：能够打开已存在的数据表文件，可以删除数据表中的任一记录，要求具备逻辑删除（具有恢复功能）和物理删除功能，并对新的数据表信息进行文件保存。 设计思路 整体模式以及主要涉及的模块整体设计采用 MVC 模式，及数据的储存处理与表现分离。使用 QT 框架提供基础的图形界面操作，整体分为三个模块，CNView前端部分负责数据的显示，CNModel数据的储存预处理。 模块功能的划分以及类的初步设计 CNView 前端部分主要结合 QT 框架，界面展示，地点展示，路径展示，以及提供对应的 GUI 工具实现文本的录入 CNModel 后端部分 功能设计和模块划分本次课程设计额 C++父类指针操作子类新函数的方式父类指针无法直接调用子类的新函数，需要转换为子类的指针后方可调用。 C++编译器在编译的时候是做静态类型分析。也就是说，你的父类指针是否真的指向一个子类类型，编译器并不会做这个假设。所以你用父类指针去调用子类的函数是无法被识别的。这里提供一种不安全和一种安全的转换方式可以实现该功能： 假设我们有父类和子类的定义如下： 12345678910111213141516171819202122class Base&#123;public: void virtual Func() &#123; cout &lt;&lt; "Base\n"; &#125;&#125;;class Derived : public Base&#123;public: void Func() &#123; cout &lt;&lt; "Derived\n"; &#125; void NewFunc() &#123; cout &lt;&lt; "New func\n"; &#125;&#125;; 强制转换（不安全） 12345Base* b = new Derived();b-&gt;Func();// 不安全的转换Derived* d = (Derived*)b;d-&gt;NewFunc(); 这里之所以说不安全是因为转换的时候无法得知是否转换成功。编译器强制把 d 当成 Derived 类型去使用。比如说 b 本来是真的指向 Base 而不是 Derived 类型那么强制转换后调用 Derived 的 NewFunc 可能会导致程序崩溃。 2.动态转换，dynamic_cast（安全） 12345678Base* b = new Derived();b-&gt;Func(); // 安全转换 Derived* d = dynamic_cast&lt;Derived*&gt;(b); if (d != NULL)&#123; d-&gt;NewFunc();&#125; dynamic_cast 是在运行时去做转换而非编译时，所以它可以给出是否转换成功的信息。如果转换不成功则返回 NULL。所以可以判断转换结果是否为 NULL 来决定是否能使用该指针不会导致程序崩溃 第一天进度记录 完成后端 1/2（除去文件读写） string index 放着先不实现，所有都先按照鼠标事件和 xy 坐标来写 明早补充边的增加和删减 注意边增添的时候算直线距离 普通点的增加和删减 第 X 天进度记录就是说如果槽的命名是这样的话： 1void on_&lt;widget name&gt;_&lt;signal name&gt;(&lt;signal parameters&gt;); 就会自动将widget name中的信号signal name和这个槽void on_&lt;widget name&gt;_&lt;signal name&gt;(&lt;signal parameters&gt;)链接起来。 这是 QT 不需要 connect 语句就可以自动链接信号和槽的机制！ 绘图相关当发生一下情况时会产生绘制事件并调用 paintEvent()函数: 在窗口部件第一次显示时，系统会自动产生一个绘图事件，从而强制绘制这个窗口部件。 当重新调整窗口部件的大小时，系统也会产生一个绘制事件。 当窗口部件被其他窗口部件遮挡，然后又再次显示出来的时候，就会对那些隐藏的区域产生一个绘制事件。 同时可以调用 QWidget::update()或者 QWidget::repaint()来强制产生一个绘制事件。二者的区别是: repaint()函数会强制产生一个即时的重绘事件,而 update()函数只是在 Qt 下一次处理事件时才调用一次绘制事件。 如果多次调用 update(),Qt 会把连续多次的绘制事件压缩成一个单一的绘制事件，这样可避免闪烁现象。 使用 repaint()]]></content>
      <categories>
        <category>编程</category>
        <category>C++</category>
      </categories>
      <tags>
        <tag>C++</tag>
        <tag>编程</tag>
        <tag>课程设计</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Git学习——《精通Git》笔记（一）]]></title>
    <url>%2Fpost%2Fb8ca3dfa.html</url>
    <content type="text"><![CDATA[第1章 入门关于版本控制理解版本控制：我们需要他的原因就是我们希望能够记录对一系列文档操作的历史，便于查看修改记录，历史版本，甚至是在出错或者其他情况回滚到过去版本。 P1 “使用版本控制系统，你可以将文件或者整个项目恢复到先前的状态，还可以比对掌握文件随时间的吧ing呢个，查看什么人最后做出的更改。” 大型项目需要多人共同完成时，版本控制又提供了很可靠的多人协作的方式，每个人对项目的操作都可以作为一个版本记录其中，而且不同版本的提交留下的历史也为日后出现问题的时候找到对应负责人提供了可信途径（笑）。 本地版本控制系统上古时代的VCS(Version Control System 学点英文)，开始计算机通信还没像现在互联网这种程度时候，本低版本控制也是一个必备需求。RCS，一个常用VCS工具，Mac OS X操作系统中，rcs命令会使RCS在磁盘上以一种特殊的格式保存补丁集（patch set ， 即记录文件之间的差异）通过叠加补丁来恢复到某个状态。 集中式版本控制系统当多人开发协作流行起来，本低版本控制不能满足需求，集中式版本控制系统（Centralized Version Control System, CVCS）应运而生 特点：依赖网络、依赖中心仓库、集中管理、单点故障难以处理 分布式版本控制系统为了解决集中式的依赖在线和中心仓库交互、单点故障等问题，分布式版本控制系统（Distributed Version Control System, DVCS）被开发出来。 特点：无严格意义上的中心仓库，完整镜像（完整备份）， Git简史Git产生于Linux内核这个超大规模开源软件项目的维护过程中，开始Linux内核开发者社区使用的是BitKeeper专有分布式版本控制系统，后来关系破裂B收回软件的使用权，所以Linux开发社区（尤其是Linux之父林纳斯）汲取了原软件的经验和不足，开发出了自己的控制系统，最初目标是实现： 速度快 设计简洁 对于非线性开发有力支持（大数量分支） 完全的分布式设计 能够有效处理像Linux内核这种超大型项目（速度及数据量） Git特性介绍介绍Git对比其他版本控制系统的差异，以及一些Git独特的地方。 快照而非差异Git最大不同在于对待数据的方式，很多版本控制系统（CVS、Subversion、Perforce）记录的是一些文件和在文件上随时间做的改动（记录变化量）。Git记录的是快照，抓取快照后存储一个指向该快照的引用，变动的记录变动后的文件信息，不变动不记录，留下原先的链接，整体宏观上是非线性的，数据变动在快照到快照这个快照流中体现。 几乎所有操作都在本地执行在本地有本地仓库，自己对文件修改并记录版本时，一般无需从网络和其他计算机获取信息，无需考虑网络延时的开销。只有需要通过Web交互信息（比如上传至代码托管平台，对比与远程仓库差异）或者和他人写作的时候，在修改完成后再进行网络传输（这时本地已经完成了文件的修改，本地仓已经为最新版本） Git的完整性关于完整性，Git存储前会进行校验和计算，校验使用SHA-1散列（嗯密码学相关），改一点散列值都会产生很大变化~。 P6 “因为用途及广，你在Git中到处都会看到这种散列值。实际上，Git并不是通过文件名在数据库中存储信息，而是通过信息的散列值。” 第2章 Git基础获取Git仓库1git clone 支持HTTP协议，ssh传输协议等。 一些常见操作如git status查看当前状态，添加文件git add会直接让新文件变为暂存文件，同时，也可以暂存文件，是个多功能指令。编辑文件会由未修改状态变为已修改状态，已修改状态经过暂存变为已暂存状态。git commit会进行提交，执行的是上次git add的暂存文件版本，即在上次暂存后又做修改，这些修改是不会被提交的。 忽略文件.gitignore文件种列出匹配模式，这些匹配的文件不会被纳入Git仓库的文件提交。 查看变更git diff命令可以查看哪些变更没有被暂存，哪些已暂存的变更正待提交？输出的是补丁（patch）。带--staged或者是--cached参数，表示查看暂存区对比提交的变更，不带参数表示的是当前未暂存的与暂存区的比较，即一后一前。 提交变更git commit会打开指定的文本编辑器（可以是Vim,Emacs,VSCode）添加message后提交暂存区内容。git commit -a命令传入-a选项会跳过暂存区，直接将所有跟踪文件加入暂存区后提交。 移除文件先从暂存区移除，然后再提交，同时也会从工作目录中删除。直接rm移除的时候不会有记录，git rm才可以。 移动文件Git不会显式跟踪文件的移动，不过Git很聪明，能明白。 git mv xx xxx实际上完成了下面这些命令 123mv xx xxxgit rm xxgit add xxx 无论改名还是git mv,Git都能推断出来这是重命名操作。 查看提交历史git log可用参数有很多，比如-p按补丁格式显示每个提交引入的更改,--start显示每个提交中被更改的文件的统计信息,--graph用于显示图表展示分支和合并的信息。--pretty用一种可选格式显示提交，选项有oneline、short、full、fuller和format（用于指定自定义格式）。 撤销操作修改，覆盖上一次提交的信息 git commit --amend上述命令会提交暂存区内容，如果你在上次提交之后并没做任何该懂，那么提交快照就不会有变化。 撤销已暂存文件 git reset命令会恢复到已经修改但未暂存的状态（如果是直接添加文件则会回到未添加的状态）。 撤销对文件的修改 git checkout --&lt;file&gt;会撤销修改并把文件恢复到上次提交时的状态（或是刚克隆仓库后的状态，或是一开始再工作目录时的状态）。 需要注意的是，git checkout — 是一条危险的指令。执行该命令后，任何对该文件的修改都会丢失，因为上述命令用之前的版本文件做了覆盖，除非你确信不需要这些文件，否则不要使用该条命令。 远程仓库的使用git clone ... &lt;repo&gt; [&lt;dir&gt;] dir可以理解成别名，git remote查看远程分支，使用-v参数，会显示Git存储的每个远程仓库对应的URL。 添加远程仓库拉取与推送git remote add &lt;name&gt; &lt;url&gt;显示添加一个远程仓库并起名字，根据官方文档，名字是必要的。git fetch &lt;remote-name&gt;从远程仓库拉取数据，项目进行到某个阶段，需要与他人分享你的工作成果时，需要把变更推送到远程仓库，git push [remote-name] [branch-name]将本地分支推送到远程分支，推送push的要求详见第三章。 检查远程仓库git remote show [remote-name]会给出URL地址和分支的跟踪信息，一些差异性信息（分支的增删）等。 删除和重命名远程仓库git remote rename &lt;oldname&gt; &lt;newname&gt;将远程仓库的名称修改，git remote rm &lt;remote-name&gt;迁移地址、删除某个镜像或者协作者退出时的情况，用于删除某个远程仓库。 标签git tag列举标签。加-l参数可以模式匹配。 创建标签轻量级（lightweight）标签儿话注释（annotated），一般推荐创建注释因为包含了全部的信息。 注释标签：git tag -a v1.4 -m &quot;my version 1.4&quot; 轻量标签：git tag v1.4-lw 即不需要-a、-m参数。 Git别名git config --global alias.ci commit 这样以后就可以用git ci代替git commit了。 第3章 Git分支机制分支机制简述当你发起提交时，Git存储的是提交对象（commit object），其中包含了指向暂存区快照的指针。 暂存操作会对加入暂存区提交的每个文件计算校验和（SHA-1散列值）并把文件的当前版本保存到Git仓库中（blob对象）。而进行commit提交时，Git会先为每个子目录计算校验和，然后再把这些树对象保存到Git仓库中。Git随后会创建提交对象，其中包括元数据以及指向项目根目录的树对象的指针，以便有需要的时候重新创建这次快照。 个人理解：一次提交内容是一个树模型而不同提交又有父提交的指针也形成一个树模型？ HEAD指针指向当前所在的本地分支，checkout实际上就是切换HEAD指向的位置，这样的好处是一个checkout实际上可能是不同次提交的不同分支，能使我们关注分支而非提交。 分支切换会更改工作目录文件切换分支时。工作目录的文件会被改变。如果你切换到较旧的分支，工作目录会被恢复到该分支上最后一次提交的状态。如果Git再当前状态下无法干净地完成恢复操作，就不会允许你切换分支。 基本的分支与合并操作基本分支操作git checkout -b iss53 -b参数表示新建分支同时移动当前分支到该分支，实际上相当于两条命令执行git branch iss53，git checkout iss53。 当继续修补bug但是手头分支还没有完成地时候，利用git我们可以先checkout到问题分支（假设这里是master分支），新建hotfix分支修补问题。 修补问题完成后checkout到master分支使用git merge合并hotfix到master，由于在master分支是分化出来的hotfix分支的直接上游，合并不会存在冲突，合并时出现”fast-forward”提示。这时候分支master和hotfix在一个提交版本上（指向位置相同），我们现在不需要hotfix分支了，git branch -d删除这个分支。 修补问题完成后，我们就可以继续回到原先开发分支继续工作啦！ 基本合并操作在早先有分叉历史的合并过程中，采用三方合并（被并入的提交快照，要合并的提交快照和共同祖先），合并完成后会新建一个提交指向新建的快照（而非像之间fast-forward一样只是移动快照的指针）。合并提交的特殊性在于它拥有不止一个父提交。提示为”Merge made by the ‘recursive’ strategy”。 值得注意的是，Git会自己判断最优的公共祖先并将其作为合并的基础。 分支管理git branch，不带参数列出分支列表，带参数-v可查看每个分支上的最新提交信息。 git branch --merged会显示哪些分支并入了当前分支，相应的—no-merged参数则显示未并入的分支。 与分支有关的工作流长期分支方便的三方合并机制，使得分支合并是个容易的操作。多个开放的分支分别用于开发周期的不同阶段很合适。 比如一些开发者所采用的master分支只存放稳定版代码，即已经发布版本或即将发布版本的代码，develop和next的平行分支用于开发或是用于测试代码的稳定性，达到稳定性则合并到master分支中去。这种工作流很明显稳定分支会在提交历史中较为靠后，而前沿的开发分支较为靠前。筒仓（work silo）既视感，几经迭代就放到更稳定的筒仓中。 主题分支适用于短期实现某一特定功能相关工作的分支。短期的外延，然后再合并到主干分支。每个分支的更改都与它的目标特性相关，使得代码审查等活动中俄能够更容易读懂所做的更改。 无需考虑先后顺序，并行开发无负担且同时易于选择。 远程分支指针存在本地但无法移动，网络通信时自动更新，有些像书签，其表示形式是(remote)/(branch) git fetch命令会更新远程分支指针（就理解成更新另一个人对分支路径的修改），origin只是默认命名，我们还可以有很多个远程remote。 推送当需要同别人共享某个分支上的工作成果时，就要把它推送到一个具有写权限的远程仓库。本地分支不会自动同步到远程仓库，必须要显式地推送那些你想要与他人共享的分支。这样一来，你可以使用私有分支做一些不想与他人共享的工作，而仅仅推送那些需要与别人协作的主题分支。 跟踪分支基于远程分支创建的本地分支会自动称为跟踪分支（tracking branch）。或者有时候也叫作上游分（upstream branch）。 跟踪分支与远程分支直接关联。如果你正处在一个跟踪分支上并键入git pushGit会知道要将数据推送到哪个服务器上的哪个分支（pull同理），这实际上是我们经常看到的操作。 checkout到某个远程分支名相同但是本地还没有的分支时候，Git会帮你创建跟踪分支。 拉取git fetch命令会拉取本地没有的远程然后最新更新数据。只是读数据，并不会影响本地的工作目录。 变基在Git中，要把更改一个分支整合到另一个分支，有两种主要方式：合并（merge）和变基（rebase）。 工作原理首先找到两个要整合的分支（你当前所在的分支和要整合到的分支）的共同祖先，然后取得当前所在分支的每次提交引入的更改（diff），并把这些更改保存为临时文件，这之后将当前分支重置为要整合到的分支，最后在该分支上依次引入之前保存的更改。 潜在危害总结成一句话：不要对已经存在于本地仓库之外的提交操作执行变基操作。否则会带来不同分支上相同时间相同内容的混乱。（因为远程仓库并不会跟着进行变基操作）。 第4章协议本地协议、HTTP（智能与非智能）、SSH协议等。不再做详细介绍。 在服务器上搭建Git以Linux为例 开始配置时，先把已有的仓库导出成一个新的裸仓库git clone --bare my_project my_project.git， 将裸仓库放置在服务器上，假定想要放置在远程服务器/srv/git目录下（前提时具备SSH访问权限）。scp -r my_project.git user@git.example.com:/srv/git，把裸仓库复制到该目录。 其他用户具有读权限的时候，可以clone，具有写权限的时候可以推送数据。 赋予写权限 123ssh user@git.example.comcd /srv/git/my_project.gitgit init --bare --shared 就完成了运行一台Git简单服务器的全部操作。 第6章 GitHubSSH访问使用SSH远程连接，则需要配置一个公钥，在设置里面SSH keys部分配置。 为项目做贡献Fork操作，派生项目，推送修改，然后创建拉取请求，将改动写回原始仓库。想要创建拉取请求，点击Fork按钮即可。 GitHub流程 从master分支中创建一个主题分支。 提交一些修改来改进项目。 将该分支推送到GitHub上的项目中 在GitHub上创建一个拉取请求 进行讨论，根据情况继续提交修改 项目拥有者合并或关闭拉取请求 项目维护项目管理一般对于单个项目而言，没有太多的管理事务可做，不过其中有几点值得一提。 更改默认分支 在Options标签下的个人仓库设置页面中修改，之后所有主要操作都会使用你所选择的分支作为默认分支，包括进行仓库克隆操作时默认检出的分支。 移交项目 个人仓库设置中Transfer ownership选项可以完成这项操作。（放弃或交由组织管理） 组织管理这一节暂且不管了，多了一些组织团队管理以及审计的功能 GitHub脚本化第10章 Git内幕本章早读晚读都可以，展示Git内部工作细节以及实现。 底层命令和高层命令git init会初始化一个.git目录，几乎包含了Git存储和操作的所有内容。备份或者克隆，把这个目录复制到别处就可以了。本章讨论的内容基本上都在该目录下。 Git对象Git按照内容寻址，那，意味着核心是“键-值”数据存储。插入内容-返回键值，键值检索-返回相应内容。 objects目录下有一个文件，这是Git最初存储内容的方式：一份内容一份文件，以内容的头部的SHA-1校验和作为文件名。子目录采用SHA-1的前两个字符为名，文件名用剩余38个字符命名。 可以调用底层git cat-file将内容取回，-p参数会将内容打印，-t会给出类型（目前已知有commit还有blob还有tree对象）。 树对象Git存储内容的方式类似Unix文件系统，但有一些简化，所有内容被存储为树对象和blob对象。树对相对应Unix目录项，blob对象基本上对应i节点或文件内容。单个树对象包含一个或多个树条目，每个条目包含一个指向blob对象或子树的指针以及相关的模式、类型和文件名。 （有机会学习一遍Unix和Linux的文件系统的表述，记住树对象目录是储存的指针。） 提交对象git commit-tree命令指定单个树对象的SHA-1以及父提交对象（如果有），创建提交对象。 对树对象的一系列操作（底层操作），我们实际上可以创建了一个Git仓库，这实际上也正是当我们执行git add和git commit命令时，Git所执行的操作（底层的）。 blabla剩下的以后慢慢填坑吧。]]></content>
      <categories>
        <category>编程</category>
        <category>Git</category>
      </categories>
      <tags>
        <tag>Git</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[VSCode——Git配置及终端替换]]></title>
    <url>%2Fpost%2Feae0b80e.html</url>
    <content type="text"><![CDATA[Git安装如果本机还没有安装过Git，那么首先从官网上下载合适的版本（Mac OS/Windows/Linux） 官方地址为：https://git-scm.com/download/win 下载完以后双击进行安装，勾选使用Git Bash以及使用VSCode作为默认编辑器（这个看个人喜好）。 安装成功界面 检查Git命令行输入 git --version 得到结果 git version 2.20.1.windows.1 证明Git安装正常，若出现异常，无对应函数，确定一下环境变量是否配置正常 VSCode中Git配置 Git 路径 Ctrl+,打开Setting界面，搜索Git.path，编辑到User Setting中（本机都使用所以可以不必每次都添加到Workspace Setting处设计），值为本机安装的Git文件目录里git.exe的路径。（注意Windows修改’\\’为’\\\\’） Git Bash替换原有终端 鉴于不少人习惯通过Git Bash命令行进行操作，我们利用VSCode提供的内置终端功能，将终端替换为Git Bash，再也不用担心一堆Git窗口来回切了，还可以配合Ctrl+\等快捷键充分发挥终端小窗口并行工作的潜力。 Ctrl+,打开Setting界面，搜索git.integrated.shell.window,编辑对应框，路径改为对应的Bash.exe路径（我的机器中是D:\Program Files\Git\bin\bash.exe） Thanks to微软爸爸，现在我们就可以在VSCode里优雅的使用Git啦。 关于Git的教程，后续读完《精通Git》会补一篇。链接在这里。]]></content>
      <categories>
        <category>编程</category>
        <category>生产力工具</category>
      </categories>
      <tags>
        <tag>VSCode,Git,生产力工具,,</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[VSCode——通用插件推荐与介绍]]></title>
    <url>%2Fpost%2Facf6b02e.html</url>
    <content type="text"><![CDATA[VSCode常用插件一览这篇文章写了一些目前我已经下载并且使用体验良好的插件，欢迎大家联系我推荐其他插件吼。 插件主要从通用工具与编写支持、界面/美化、语言支持及相关工具三个类别来进行介绍。 通用工具与编写支持 Chinese (Simplified) Language Pack for Visual Studio Code 功能：此中文（简体）语言包为 VS Code 提供本地化界面。 使用方法：安装后，在 locale.json 中添加 “locale”: “zh-cn”，即可载入中文（简体）语言包。要修改 locale.json，你可以同时按下 Ctrl+Shift+P 打开命令面板，之后输入 “config” 筛选可用命令列表，最后选择配置语言命令。请参阅文档并获取更多信息。 vscode-faker 功能：提供编造数据 使用方法：安装后，Ctrl+Shift+P然后输入Faker选择对应的数据进行构造 VS Live Share 功能：与他人实时同步编辑代码 使用方法：安装后根据说明文档来吧，博主目前还用不到，自己稍微尝试了一下，很有趣。 Docker 功能：语法高亮，命令以及拼写检查 使用方法：参见说明文档，博主目前还未接触Docker，只听闻这个东西 界面/图标美化 vscode-icons 功能：提供多彩图标 使用方法：安装后，Ctrl+Shift+P然后输入Icons选择对应的命令。（博主觉得太花哨，还是选择Seti的VScode图标） Studio Icons 功能：提供Visual Studio风格图标 使用方法：安装后，在左下角小齿轮选择Icon Theme找到Visual Studio Code风格的两个Icon配色方案。 Markdown相关 markdownlint 功能：提供Markdown规范以及风格的检查 使用方法：安装后，在md文件编写的时候会生效产生markdownlint的warning信息，可以在Setting里面选择错误信息的显示的设置。 Markdown All in One 功能：提供Markdown书写习惯的快捷键。 使用方法：安装后，md文件编写的时候生效，比如Ctrl+B加粗，以及自动对标号顺延。 语言支持及相关工具 C++相关 功能：提供了C++编译测试的支持，以及C++书写检查，代码高亮，和联想输入。 使用方法：安装后参照说明文档。 Java相关 功能：提供了Java编译测试的支持，以及Java书写规范检查，代码高亮，联想输入 使用方法：安装后参照说明文档。 Maven 功能：提供了Maven Projects的管理，编译支持。 使用方法：安装后关联Maven，Ctrl+Shift+P 然后输入Maven可以使用相关指令。 Python 功能：提供了Python编译测试的支持 使用方法：参考说明文档]]></content>
      <categories>
        <category>编程</category>
        <category>生产力工具</category>
      </categories>
      <tags>
        <tag>VScode</tag>
        <tag>test</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[VSCode——基础配置]]></title>
    <url>%2Fpost%2F9305c5f5.html</url>
    <content type="text"><![CDATA[微软良心之作，高颜值加可拓展性。目前学生党一枚，一边学习着算法一遍又要写写前端以及blog的md，所以就入了VSCode的坑。 对于我本人，最舒服的莫过于继承了Terminal，以后再也不用跑到编辑器或者IDE外面鼠标右键或者Win+R开终端了。嗯看好微软（买Surface的动力++），另外可以配置好Python，Java和C++环境可以完成一个编辑器上写代码+调试+写博客总结的一系列操作，日后有望成为主要生产力工具。 后面会着手写一系列关于VSCode基本配置操作以及在各种语言环境，以及插件所实现的VSCode+操作。 VSCode下载与安装首先从官网下载 安装就不断下一步就行 VSCode界面顺利安装完成，打开VScode以后会出现下图类似的界面（左边side bar上有一些图标是插件提供的，插件功能一会儿会提及）。大体上应该是这个Welcome界面 VSCode用户设置 进入Setting界面进行设置 Ctrl+, 打开Setting界面出现如下 用户设置界面可以根据自己的需要搜索祥光的配置项并修改。后续很多插件的DIY配置都需要在这里搜索到匹配的项然后进行Edit in setting.json后编辑。 需要说明的是，左边是默认的用户设置，从左边选择条目加入右边。右边有两个Setting，分别为用户的使用Setting（公用），和当前工作环境的Setting。当编辑当前工作环境Setting的时候VSCode会自动在工作区文件夹建立一个名为.vscode的文件夹内部包含setting.json。 改变编辑器外观（Color Theme） Ctrl+K,Ctrl+T 组合按键，或者Ctrl+Shift+P 后输入Color Theme进入选择菜单，VS还很贴心的分出了浅色Theme和深色Theme。博主自己比较喜欢深色就选择了一款深色主题，大家用自己习惯的就好咯。 VSCode操作命令博主常用的快捷键下面列了一些（我）常用的快捷键，应付基本需求基本上是没问题了 Ctrl+N 新建一个文件（上面会显示Untitle.txt） Ctrl+Shift+N 新建一个VSCode编辑器窗口 Ctrl+\ 右侧切出一个新的VScode编辑器 Ctrl+Tab 切换打开的文件 Ctrl+P 快速打开 Quick Open Ctrl+Shift+P 显示命令面板 Ctrl+Shift+Y 显示Debug结果 Ctrl+(ESC下面那个) 显示终端Terminal Ctrl+Shift+(ESC下面那个) 新增一个Terminal Terminal+Ctrl+\ 右侧切出一个Terminal终端 Ctrl+, 打开Setting界面 Ctrl+Shift+M 打开PROBLEMS出错信息界面（调试或者格式化的时候常用） Alt+Shif+F 很多插件提供的全页面按对应语言格式化 快捷键中英文对照表思否上有前辈贴出了基本上全部的VSCode快捷键中英文对照表 原文链接 常用 General 按 Press 功能 Function Ctrl + Shift + P，F1 显示命令面板 Show Command Palette Ctrl + P 快速打开 Quick Open Ctrl + Shift + N 新窗口/实例 New window/instance Ctrl + Shift + W 关闭窗口/实例 Close window/instance 基础编辑 Basic editing 按 Press 功能 Function Ctrl+X 剪切行（空选定） Cut line (empty selection) Ctrl+C 复制行（空选定）Copy line (empty selection) Alt+ ↑ / ↓ 向上/向下移动行 Move line up/down Shift+Alt + ↓ / ↑ 向上/向下复制行 Copy line up/down Ctrl+Shift+K 删除行 Delete line Ctrl+Enter 在下面插入行 Insert line below Ctrl+Shift+Enter 在上面插入行 Insert line above Ctrl+Shift+\ 跳到匹配的括号 Jump to matching bracket Ctrl+] / [ 缩进/缩进行 Indent/outdent line Home 转到行首 Go to beginning of line End 转到行尾 Go to end of line Ctrl+Home 转到文件开头 Go to beginning of file Ctrl+End 转到文件末尾 Go to end of file Ctrl+↑ / ↓ 向上/向下滚动行 Scroll line up/down Alt+PgUp / PgDown 向上/向下滚动页面 Scroll page up/down Ctrl+Shift+[ 折叠（折叠）区域 Fold (collapse) region Ctrl+Shift+] 展开（未折叠）区域 Unfold (uncollapse) region Ctrl+K Ctrl+[ 折叠（未折叠）所有子区域 Fold (collapse) all subregions Ctrl+K Ctrl+] 展开（未折叠）所有子区域 Unfold (uncollapse) all subregions Ctrl+K Ctrl+0 折叠（折叠）所有区域 Fold (collapse) all regions Ctrl+K Ctrl+J 展开（未折叠）所有区域 Unfold (uncollapse) all regions Ctrl+K Ctrl+C 添加行注释 Add line comment Ctrl+K Ctrl+U 删除行注释 Remove line comment Ctrl+/ 切换行注释 Toggle line comment Shift+Alt+A 切换块注释 Toggle block comment Alt+Z 切换换行 Toggle word wrap 导航 Navigation 按 Press 功能 Function Ctrl + T 显示所有符号 Show all Symbols Ctrl + G 转到行… Go to Line… Ctrl + P 转到文件… Go to File… Ctrl + Shift + O 转到符号… Go to Symbol… Ctrl + Shift + M 显示问题面板 Show Problems panel F8 转到下一个错误或警告 Go to next error or warning Shift + F8 转到上一个错误或警告 Go to previous error or warning Ctrl + Shift + Tab 导航编辑器组历史记录 Navigate editor group history Alt + ←/→ 返回/前进 Go back / forward Ctrl + M 切换选项卡移动焦点 Toggle Tab moves focus 搜索和替换 Search and replace 按 Press 功能 Function Ctrl + F 查找 Find Ctrl + H 替换 Replace F3 / Shift + F3 查找下一个/上一个 Find next/previous Alt + Enter 选择查找匹配的所有出现 Select all occurences of Find match Ctrl + D 将选择添加到下一个查找匹配 Add selection to next Find match Ctrl + K Ctrl + D 将最后一个选择移至下一个查找匹配项 Move last selection to next Find match Alt + C / R / W 切换区分大小写/正则表达式/整个词 Toggle case-sensitive / regex / whole word 多光标和选择 Multi-cursor and selection 按 Press 功能 Function Alt +单击 插入光标 Insert cursor Ctrl + Alt +↑/↓ 在上/下插入光标 Insert cursor above / below Ctrl + U 撤消上一个光标操作 Undo last cursor operation Shift + Alt + I 在选定的每一行的末尾插入光标 Insert cursor at end of each line selected Ctrl + I 选择当前行 Select current line Ctrl + Shift + L 选择当前选择的所有出现 Select all occurrences of current selection Ctrl + F2 选择当前字的所有出现 Select all occurrences of current word Shift + Alt + → 展开选择 Expand selection Shift + Alt + ← 缩小选择 Shrink selection Shift + Alt + （拖动鼠标） 列（框）选择 Column (box) selection Ctrl + Shift + Alt +（箭头键） 列（框）选择 Column (box) selection Ctrl + Shift + Alt + PgUp / PgDown 列（框）选择页上/下 Column (box) selection page up/down 丰富的语言编辑 Rich languages editing 按 Press 功能 Function Ctrl + 空格 触发建议 Trigger suggestion Ctrl + Shift + Space 触发器参数提示 Trigger parameter hints Tab Emmet 展开缩写 Emmet expand abbreviation Shift + Alt + F 格式化文档 Format document Ctrl + K Ctrl + F 格式选定区域 Format selection F12 转到定义 Go to Definition Alt + F12 Peek定义 Peek Definition Ctrl + K F12 打开定义到边 Open Definition to the side Ctrl + . 快速解决 Quick Fix Shift + F12 显示引用 Show References F2 重命名符号 Rename Symbol Ctrl + K Ctrl + X 修剪尾随空格 Trim trailing whitespace Ctrl + K M 更改文件语言 Change file language 编辑器管理 Editor management 按 Press 功能 Function Ctrl+F4, Ctrl+W 关闭编辑器 Close editor Ctrl+K F 关闭文件夹 Close folder Ctrl+\ 拆分编辑器 Split editor Ctrl+ 1 / 2 / 3 聚焦到第1，第2或第3编辑器组 Focus into 1st, 2nd or 3rd editor group Ctrl+K Ctrl+ ←/→ 聚焦到上一个/下一个编辑器组 Focus into previous/next editor group Ctrl+Shift+PgUp / PgDown 向左/向右移动编辑器 Move editor left/right Ctrl+K ← / → 移动活动编辑器组 Move active editor group 文件管理 File management 按 Press 功能 Function Ctrl+N 新文件 New File Ctrl+O 打开文件… Open File… Ctrl+S 保存 Save Ctrl+Shift+S 另存为… Save As… Ctrl+K S 全部保存 Save All Ctrl+F4 关闭 Close Ctrl+K Ctrl+W 关闭所有 Close All Ctrl+Shift+T 重新打开关闭的编辑器 Reopen closed editor Ctrl+K 输入保持打开 Enter Keep Open Ctrl+Tab 打开下一个 Open next Ctrl+Shift+Tab 打开上一个 Open previous Ctrl+K P 复制活动文件的路径 Copy path of active file Ctrl+K R 显示资源管理器中的活动文件 Reveal active file in Explorer Ctrl+K O 显示新窗口/实例中的活动文件 Show active file in new window/instance 显示 Display 按 Press 功能 Function F11 切换全屏 Toggle full screen Shift+Alt+1 切换编辑器布局 Toggle editor layout Ctrl+ = / - 放大/缩小 Zoom in/out Ctrl+B 切换侧栏可见性 Toggle Sidebar visibility Ctrl+Shift+E 显示浏览器/切换焦点 Show Explorer / Toggle focus Ctrl+Shift+F 显示搜索 Show Search Ctrl+Shift+G 显示Git Show Git Ctrl+Shift+D 显示调试 Show Debug Ctrl+Shift+X 显示扩展 Show Extensions Ctrl+Shift+H 替换文件 Replace in files Ctrl+Shift+J 切换搜索详细信息 Toggle Search details Ctrl+Shift+C 打开新命令提示符/终端 Open new command prompt/terminal Ctrl+Shift+U 显示输出面板 Show Output panel Ctrl+Shift+V 切换Markdown预览 Toggle Markdown preview Ctrl+K V 从旁边打开Markdown预览 Open Markdown preview to the side 调试 Debug 按 Press 功能 Function F9 切换断点 Toggle breakpoint F5 开始/继续 Start/Continue Shift+F5 停止 Stop F11 / Shift+F11 下一步/上一步 Step into/out F10 跳过 Step over Ctrl+K Ctrl+I 显示悬停 Show hover 集成终端 Integrated terminal 按 Press 功能 Function Ctrl+` 显示集成终端 Show integrated terminal Ctrl+Shift+` 创建新终端 Create new terminal Ctrl+Shift+C 复制选定 Copy selection Ctrl+Shift+V 粘贴到活动端子 Paste into active terminal Ctrl+↑ / ↓ 向上/向下滚动 Scroll up/down Shift+PgUp / PgDown 向上/向下滚动页面 Scroll page up/down Ctrl+Home / End 滚动到顶部/底部 Scroll to top/bottom]]></content>
      <categories>
        <category>编程</category>
        <category>生产力工具</category>
      </categories>
      <tags>
        <tag>VScode</tag>
        <tag>test</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[金融学辅修——金融学笔记（十）]]></title>
    <url>%2Fpost%2F380486cb.html</url>
    <content type="text"><![CDATA[老师提供的习题册，15-16 版本。 考试时间，19 周周末，问一下课代表确定时间 债券种类国内债券 国际债券氛围外国债券和欧洲债券 欧洲债券分为公墓债券和私募债券 债券发行与交易 三种方式：溢价发行、平价发行、折价发行 直接债券和无息债券 几种特殊债券：武士债券、扬基债券、熊猫债券 政府债券、金融债券、企业债券 可转换公司债券 是一种可以在特定时间，按特定条件转换为普通股股票的特殊公司债券，它兼有债券和股票的特征。 具有以下条件 债券性，有规定的利率和期限。 股权性，可转换债券为股票后，债权人变为公司的股东， 可转换性， 可转换性， 可氛围进内和境外可抓换债券。 债券的发行与流通 债券发行市场发行合同书说明 shn 证券投资基金的基本特征基本特征基金作为一种现代投资工具，三个特征 集合投资，基金是这样一种投资方式；零散基金汇集， 谋取资产的增值。 分散风险。科学的投资组合降低风险，一定的资金实力，基金帮助中小投资者解决了资金实力不足的问题。 专业理财，基金实行专家管理制度，运用先进的技术手段分析，尽可能地避免投资决策的失误，提高投资的正确率。 证券投资基金的类型按组织形式分：公司型投资基金（股份制投资公司），契约型投资基金（信托型投资基金） 主要区别 按基金可否赎回分：不可赎回（封闭式基金），可赎回（开放式基金） 按投资对象分为]]></content>
      <categories>
        <category>金融</category>
        <category>金融学</category>
      </categories>
      <tags>
        <tag>课堂笔记</tag>
        <tag>辅修</tag>
        <tag>金融学</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[金融学辅修——微观经济学笔记（六）]]></title>
    <url>%2Fpost%2F62cb42be.html</url>
    <content type="text"><![CDATA[第八章 垄断竞争市场垄断竞争市场的特点完全竞争和完全垄断的市场模式是两个极端的市场类型，它们在现实经济活动中都极其罕见。 垄断竞争的性质和特这个 市场上买卖双方人数较多； 一个生产集团企业数量非常多，每个厂商都认为自己的行为不会引起竞争队首的注意和反应，因而也不会受到 竞争对手的任何影响。 各厂商生产的产品有差别 这些产品都是非常接近的替代品，较强替代性但不可完全替代。 差别越大，垄断越 厂商进出比较容易； 厂商是市场价格的影响者 垄断竞争厂商的需求曲线 基本假设 生产集团内所有厂商都具有i昂同的成本曲线和需求曲线，可以以代表性厂商进行分析。 特征：需求曲线向右下方倾斜并且比较平坦（弹性比较大） 特征：两种需求曲线d和D 关于需求曲线d 在垄断竞争生产集团某个厂商改变产品价格，而其他厂商的产品价格都保持不变时。 该厂商的产品价格和销售量之间的关系 厂商主观摄像的需求曲线——自需求曲线 关于需求曲线D 在垄断竞争生产集团某个厂商改变产品价格，而其他厂商的产品价格发生相同变化时。 该厂商的产品价格和销售量之间的关系 符合客观规律的市场上需求曲线——比例需求曲线 d和D的关系 垄断竞争厂商的短期均衡 顺势均衡 垄断竞争厂商利润最大化行为 垄断竞争厂商面临向右下倾斜但比较完全垄断厂商平坦的需求曲线。 按MR=MC确定产量（比例需求曲线D） 垄断竞争厂商短期可能获得超额利润，无超额利润或亏损 但在长期无嫦娥利润（超额利润引入新厂商，总供给增加，右下方移动），且产量水平在AC最低点左边。 P 不同市场的比较 斯威齐模型 两个基本假设： 一个寡头价格提升的时候，生于寡头不变化，提价寡头销售量减少 一个寡头价格降低的时候，其他寡头为了防止自己的市场份额缩水，所以跟着降低价格。 贝特朗模型 概述 由法国数学家、经济学家贝特朗1883年提出，又称价格竞争的古诺模型 价格竞争：厂商之间竞争围绕价格展开，以价格为决策变化量 假设: 厂商定价时候， 推理： 每个厂商都有动力降价直至边际成本（为了防止自己的销售量下降） 价格等于边际成本时，每个厂商都零利润 会不会所有厂商都将价格设定为高于边际成本？不会，不稳定，不符合最优决策。 均衡含义： 价格战必定使每家企业按p=边际成本的原则来经营，长期看低成本挤走高成本 同质产品竞争必然导致价格降低至边际成本。 价格领导模型 概述： 行业中一个或极少数几个大厂商变动价格，其他厂商随之跟进。 晴雨表型：价格领导者反映整个行业成本和需求的变化 支配型： 支配型领导模型：主导厂商考虑其他厂商的产量怎样取决于它定的价格，次要厂商像完全竞争市场那样行为，价格当作给定的，根据此安排生产。 价格接收者优先考虑，供给曲线和成本曲线的关系。 卡特尔卡特尔的一般表达式： 卡特尔的主要任务 规定统一价格: 运用MR=MC的原则确定整个卡特尔组织的产量 比较：等边际原理 卡特尔的不稳定性： 卡特尔成员有违背协议或背离默契的动机 监督上的困难与惩罚手段的缺乏 卡特尔成员违约是因为其需求曲线 博弈论的概念和不同类型的博弈推理过程 博弈论：又称对策论，是描述、分析多人对策行为的理论。经济学中应用广泛主要用来解释寡头之间的。 支付矩阵与占优策略均衡 占优策略 无论其他参与者采取什么策略，某参与者都存在唯一的最优策略选择，这一最优策略就是他的占优策略。 纳什均衡 相对不变占优策略一定是纳什均衡，但纳什均衡不一定是占优策略 囚徒困境 算是一种纳什均衡，也是占优策略。 囚徒困境说明了维持合作的困难。 重复博弈 重复博弈——动态博弈的一种特殊情况 动态博弈是一种反复进行的博弈 在重复博弈中，同一个博弈被重复多次 不同市场经济效率的比较（容易出论述题） 经济效率是指利用经济资源的有效性 高的经济效率表示对资源的充分利用 不同市场的价格和产量 表格 长期和短期超额利润的问题，切线 不同市场的经济效率判断标准 判断标准：P=MC 边际社会价值=边际社会成本 垄断市场与技术进步两种观点 阻碍技术进步：利润的长期性导致缺乏动力 促进技术进部：有足够的资金进行大规模的技术研发，技术研发有利于继续保持垄断地位。]]></content>
      <categories>
        <category>金融</category>
        <category>微观经济学</category>
      </categories>
      <tags>
        <tag>课堂笔记</tag>
        <tag>辅修</tag>
        <tag>微观经济学</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[金融学辅修——微观经济学笔记（五）]]></title>
    <url>%2Fpost%2F7c50967.html</url>
    <content type="text"><![CDATA[价格歧视不是所有的价格差别？都是价格歧视 价格歧视行之有效的条件 必须在完全垄断的市场条件下，才能实现价格歧视，卖者可以控制价格 不同的消费群体或不同的销售市场是互相隔离的 这样就避免了中间商 价格歧视的类型 一级价格歧视 一级价格歧视也叫完全价格歧视，是指厂商对每一单位产品都按消费者愿意支付的最高价格出售，每一单位产品的销售价格都不一样，不同消费者所获得的价格是不同的。 结论：价格歧视源于对消费者剩余的掠夺 问题：为什么难以实行 回答： 消费者很多 难以估计不同消费者的保留价格或者最高原支付价格。 二级价格歧视 二级价格歧视指不同单元的产品以不同的价格出售，而购买同一数量的不同消费者都付统一价格。消费优惠，对于 相同消费的消费者其购买数量相同。 三级价格歧视 三级价格歧视同一产品和服务在不同购买对象或不同时间不同市场上收取不同加个。 三级价格歧视是价格歧视最常见的形式 eg：富人区和穷人区，国内市场和国外市场，给学生和老年人的折扣。 实现市场分割的条件： 垄断者能够把不同市场或市场的各个部分有效分割 均衡条件：利润函数对Q1，Q2求偏导数，一阶导数等于0，可得边际成本MC=MR1=MR2 三级价格歧视与需求弹性：需求弹性较大的定较低价格，需求弹性较小的定高价格。弹性相同，收取的加个就是一致的。 针对不同市场应该如何定价。 其他形式的加个策略 二部定价 垄断厂商要求消费者先付费以获得商品的购买权，然后再要求为每一单位该商品支付额外的费用。 捆绑销售 捆绑销售：捆绑销售是指厂商要求客户购买某种商品的同时也不许购买他的另一种产品。 ？捆绑系数 自然垄断和政府管制 由来： FC大但是VC小的行业，一个厂商的生产能力即可满足全部市场的需求，若有多个企业经营，造成资源浪费 特点： 存在规模报酬递增，所以AC曲线呈现下降状态 高价格Pm，高利润、低产出Qm、低效率 低效率的解决：政府管制 管制定价： 垄断厂商的产量决定和效率评价]]></content>
      <categories>
        <category>金融</category>
        <category>微观经济学</category>
      </categories>
      <tags>
        <tag>课堂笔记</tag>
        <tag>辅修</tag>
        <tag>微观经济学</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[金融学辅修——金融学笔记（九）]]></title>
    <url>%2Fpost%2Fbd36a30f.html</url>
    <content type="text"><![CDATA[第七章 金融市场体系第一节 金融市场概述概念引出：生产单位、消费单位、产品市场、要素四场四元组。支付的流动、收入的流动，所有的货币资金的流动金融资产的交换都在金融市场中进行 金融市场的定义 定义：指经济主体之间为实现一定的目的，通过一定的交易方式进行各种金融叫资产交易的场所、机制和行为的综合。 最直接的理解——“进行金融资产或金融工具交易的市场” “金融资产”——能够为持有者带来预期收益且具有特定权利归属关系的金融工具 “市场”——有形和无形之分 市场的真正含义——不在于场所，而在于机制 交易方式+场所+机制：既包括有组织的有形场所也包括分散在不同地点、主要采用现代通讯手段进行的、没有统一组织、依据共同约定的惯例和规则、以协议方式进行的金融交易。 各种金融资产交易： 狭义的金融市场 定义： 指货币资金借贷和金融工具交易的场所、机制与行为的总和。 最狭义的理解主要是进行有价证券交易的场所、机制与行为的综合。更一般的情况下特指证券市场（股票市场和债券市场）。 金融市场交易主体 指为实现一定的目的而进行金融交易的经济主体，包括参与交易的家庭、非金融企业、政府和各类金融机构 分为专门 金融市场的 4) 金融市场的交易媒体 金融市场媒体：是指在金融市场上充当交易媒介、从事交易或促使交易完成的组织、机构或个人。金融市场媒体 同金融市场主体一样，都是金融市场的参与者。 佣金支付，促进交易 5) 金融市场的交易价格 6) 金融市场的交易方式 主要类型： 交易所方式：固定场所、有组织、有制度，集中进行公开竞价的交易方式，主要表现为“多对多”。 柜台交易方式：在各金融机构柜台上买卖双方进行面议、分散交易的方式。表现为“一对一”。 场外交易方式：既没有固定的交易场所，也不直接接触，而主要是借助电讯手段来完成交易的方式。表现为“一对多”。 7) 金融市场的监管主体 金融监管体制：指金融监管当局对金融机构和金融市场施加影响的机制]]></content>
      <categories>
        <category>金融</category>
        <category>金融学</category>
      </categories>
      <tags>
        <tag>课堂笔记</tag>
        <tag>辅修</tag>
        <tag>金融学</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[【HDU-1829】解题报告（带权并查集）]]></title>
    <url>%2Fpost%2F792e36ed.html</url>
    <content type="text"><![CDATA[原始题目A Bug’s Life Time Limit: 15000/5000 MS (Java/Others) Memory Limit: 32768/32768 K (Java/Others) Total Submission(s): 20239 Accepted Submission(s): 6472 Problem Description Background Professor Hopper is researching the sexual behavior of a rare species of bugs. He assumes that they feature two different genders and that they only interact with bugs of the opposite gender. In his experiment, individual bugs and their interactions were easy to identify, because numbers were printed on their backs. Problem Given a list of bug interactions, decide whether the experiment supports his assumption of two genders with no homosexual bugs or if it contains some bug interactions that falsify it. InputThe first line of the input contains the number of scenarios. Each scenario starts with one line giving the number of bugs (at least one, and up to 2000) and the number of interactions (up to 1000000) separated by a single space. In the following lines, each interaction is given in the form of two distinct bug numbers separated by a single space. Bugs are numbered consecutively starting from one. OutputThe output for every scenario is a line containing “Scenario #i:”, where i is the number of the scenario starting at 1, followed by one line saying either “No suspicious bugs found!” if the experiment is consistent with his assumption about the bugs’ sexual behavior, or “Suspicious bugs found!” if Professor Hopper’s assumption is definitely wrong. Sample Input2 3 3 1 2 2 3 1 3 4 2 1 2 3 4 Sample OutputScenario #1: Suspicious bugs found! Scenario #2: No suspicious bugs found! HintHuge input,scanf is recommended. SourceTUD Programming Contest 2005, Darmstadt, Germany Recommendlinle 题目大意一种虫子具有两种性别，如果假定虫子只跟异性交配，给出交配的虫子号码，判断是否符合假设（即是否存在同性交配的虫子）。 解题思路 二元关系的带权并查集（或者称之为二元种类并查集） 解题代码12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364656667686970717273747576777879808182838485868788#include&lt;cstdio&gt;#include&lt;cstring&gt;#include&lt;cmath&gt;#include&lt;iostream&gt;#include&lt;iomanip&gt;#include&lt;set&gt;#include&lt;queue&gt;#include&lt;unordered_map&gt;#include&lt;string&gt;#include&lt;sstream&gt;using namespace std;const int maxn=1e5+5;const int maxm=1e5+5;const int maxl=26;typedef long long ll;typedef unsigned long long ull;typedef vector&lt;int&gt; vi;typedef pair&lt;int, int&gt; pii;typedef pair&lt;string,string&gt; pss;#define rep(i,a,n) for(int i=a;i&lt;n;++i)#define per(i,a,n) for(int i=n-1;i&gt;=a;--i)#define fi first#define se second#define pb push_back#define np next_permutation#define pb push_back#define INF 0x3f3f3f3f#define EPS 1e-8int fa[maxn],cnt[maxn],relate[maxn];int n,t,m;void init()&#123; rep(i,0,maxn)&#123; fa[i]=i; cnt[i]=1; relate[i]=0; &#125;&#125;int find(int x)&#123; if(x==fa[x]) return x; else&#123; int temp=fa[x]; fa[x]=find(fa[x]); relate[x]=(relate[x]+relate[temp])%2; return fa[x]; &#125;&#125;int flag;bool merge(int x,int y)&#123; int fx=find(x); int fy=find(y); if(fx==fy)&#123; //已有关系 return relate[x]==relate[y]; &#125; else&#123; fa[fx]=fy; int temp=(1+relate[y])%2; relate[fx]=(temp+2-relate[x])%2; return false; &#125;&#125;int main()&#123; scanf("%d",&amp;t); rep(j,1,t+1)&#123; init(); scanf("%d%d",&amp;n,&amp;m); flag=false; int a,b; rep(i,0,m)&#123; scanf("%d%d",&amp;a,&amp;b); if(flag) continue; flag = merge(a,b); &#125; printf("Scenario #%d:\n",j); if(flag) printf("Suspicious bugs found!\n"); else printf("No suspicious bugs found!\n"); printf("\n"); &#125;&#125; 收获与反思 手敲并查集和带权并查集，注意输出格式，PE了两次。]]></content>
      <categories>
        <category>编程</category>
        <category>ACM</category>
      </categories>
      <tags>
        <tag>ACM</tag>
        <tag>算法</tag>
        <tag>2018秋季训练</tag>
        <tag>HDU</tag>
        <tag>并查集</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[【POJ-1182】解题报告（带权并查集）]]></title>
    <url>%2Fpost%2Fcd41dfb7.html</url>
    <content type="text"><![CDATA[原始题目食物链 Time Limit: 1000MS Memory Limit: 10000K Total Submissions: 95522 Accepted: 28832 Description动物王国中有三类动物A,B,C，这三类动物的食物链构成了有趣的环形。A吃B， B吃C，C吃A。现有N个动物，以1－N编号。每个动物都是A,B,C中的一种，但是我们并不知道它到底是哪一种。有人用两种说法对这N个动物所构成的食物链关系进行描述：第一种说法是”1 X Y”，表示X和Y是同类。第二种说法是”2 X Y”，表示X吃Y。此人对N个动物，用上述两种说法，一句接一句地说出K句话，这K句话有的是真的，有的是假的。当一句话满足下列三条之一时，这句话就是假话，否则就是真话。 当前的话与前面的某些真的话冲突，就是假话； 当前的话中X或Y比N大，就是假话； 当前的话表示X吃X，就是假话。 你的任务是根据给定的N（1 &lt;= N &lt;= 50,000）和K句话（0 &lt;= K &lt;= 100,000），输出假话的总数。 Input第一行是两个整数N和K，以一个空格分隔。 以下K行每行是三个正整数 D，X，Y，两数之间用一个空格隔开，其中D表示说法的种类。 若D=1，则表示X和Y是同类。 若D=2，则表示X吃Y。 Output只有一个整数，表示假话的数目。 Sample Input100 7 1 101 1 2 1 2 2 2 3 2 3 3 1 1 3 2 3 1 1 5 5 Sample Output3 SourceNoi 01 题目大意如题 解题思路 不仅要储存集合的关系，且要表示集合间相互元素的关系，关系可合并（推导），考虑带权并查集 维护一个relate数组，$relate[i]$表示i对根结点的关系。 0：与根同类 1：吃根 2：被根吃 推导规则（由于循环食物链，考虑模数关系）： A对B的关系为x，B对C的关系为y，则A对C的关系为$(x+y)%3$ A对B的关系为x，A对C的关系为y，则B对C的关系为$(y-x+3)%3$ 解题代码12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364656667686970717273747576777879808182838485868788899091929394#include &lt;cstdio&gt;#include &lt;cstring&gt;#include &lt;iostream&gt;#include &lt;iomanip&gt;#include &lt;string&gt;#include &lt;stack&gt;#include &lt;queue&gt;#include &lt;vector&gt;#include &lt;set&gt;#include &lt;cmath&gt;#include &lt;list&gt;using namespace std;const int maxn=1e5+5;const int maxm=1e5+5;typedef long long ll;typedef unsigned long long ull;typedef vector&lt;int&gt; vi;typedef pair&lt;int,int&gt; pii;typedef pair&lt;string,string&gt; pss;#define rep(i,a,n) for(int i=a;i&lt;n;++i)#define per(i,a,n) for(int i=n-1;i&gt;=a;--i)#define fi first#define se second#define mp make_pair#define np next_permutation#define pb push_back#define INF 0x3f3f3f3f#define EPS 1e-8#define cl(x,a) memset(x,a,sizeof(x))#define all(x) x.bein(),x.end()const int maxl=26;int n,k,d,x,y;int fa[maxn],relate[maxn];void init()&#123; rep(i,0,maxn)&#123; fa[i]=i; relate[i]=0; &#125;&#125;int find(int x)&#123; if(fa[x]==x)&#123; return x; &#125; else &#123; int temp=fa[x]; fa[x]=find(fa[x]); relate[x]=(relate[x]+relate[temp])%3; return fa[x]; &#125;&#125;bool merge(int r, int x, int y)&#123; int fx= find(x); int fy=find(y); if(fx==fy)&#123; if((relate[x]-relate[y]+3)%3==d) return true; else return false; &#125; else&#123; fa[fx]=fy; relate[fx]=(r+relate[y]-relate[x]+3)%3; return true; &#125;&#125;int main()&#123; scanf("%d%d",&amp;n,&amp;k); init(); int a,b,c,ccnt=0; rep(i,0,k)&#123; scanf("%d%d%d",&amp;d,&amp;x,&amp;y); d--; if(x&gt;n || y&gt;n )&#123; ccnt++; continue; &#125; if(d &amp;&amp; x==y)&#123; ccnt++; continue; &#125; if(merge(d,x,y)==false) ccnt++; &#125; printf("%d\n",ccnt);&#125; 收获与反思 并查集知识待补充。]]></content>
      <categories>
        <category>编程</category>
        <category>ACM</category>
      </categories>
      <tags>
        <tag>ACM</tag>
        <tag>算法</tag>
        <tag>2018秋季训练</tag>
        <tag>并查集</tag>
        <tag>待补充</tag>
        <tag>POJ</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[【HDU-1272】解题报告（并查集，集合数量）]]></title>
    <url>%2Fpost%2F4dc7502.html</url>
    <content type="text"><![CDATA[原始题目小希的迷宫 Time Limit: 2000/1000 MS (Java/Others) Memory Limit: 65536/32768 K (Java/Others) Total Submission(s): 67235 Accepted Submission(s): 21092 Problem Description上次Gardon的迷宫城堡小希玩了很久（见Problem B），现在她也想设计一个迷宫让Gardon来走。但是她设计迷宫的思路不一样，首先她认为所有的通道都应该是双向连通的，就是说如果有一个通道连通了房间A和B，那么既可以通过它从房间A走到房间B，也可以通过它从房间B走到房间A，为了提高难度，小希希望任意两个房间有且仅有一条路径可以相通（除非走了回头路）。小希现在把她的设计图给你，让你帮忙判断她的设计图是否符合她的设计思路。比如下面的例子，前两个是符合条件的，但是最后一个却有两种方法从5到达8。 Input输入包含多组数据，每组数据是一个以0 0结尾的整数对列表，表示了一条通道连接的两个房间的编号。房间的编号至少为1，且不超过100000。每两组数据之间有一个空行。整个文件以两个-1结尾。 Output对于输入的每一组数据，输出仅包括一行。如果该迷宫符合小希的思路，那么输出”Yes”，否则输出”No”。 Sample Input6 8 5 3 5 2 6 4 5 6 0 0 8 1 7 3 6 2 8 9 7 5 7 4 7 8 7 6 0 0 3 8 6 8 6 4 5 3 5 6 5 2 0 0 -1 -1 Sample OutputYes Yes No AuthorGardon SourceHDU 2006-4 Programming Contest Recommendlxj 题目大意如题 解题思路判定条件： 是否为一棵树，即两点之间是否只有一条途径。 是否包含全部点（即并查集森林大小为1） 条件1判断：用标准并查集对于每次合并检查是否已在一个集合中，若在，说明已有路径，则不满足题意。 条件2判断：set储存出现的点，$fa[x]==x$来判断是否为根节点。 解题代码123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899#include &lt;cstdio&gt;#include &lt;cstring&gt;#include &lt;iostream&gt;#include &lt;set&gt;#include &lt;queue&gt;#include &lt;vector&gt;#include &lt;stack&gt;#include &lt;vector&gt;#include &lt;algorithm&gt;#include &lt;string&gt;#include &lt;iostream&gt;#include &lt;iomanip&gt;#include &lt;map&gt;#include &lt;unordered_map&gt;using namespace std;const int maxn=1e5+5;const int maxm=1e5+5;typedef long long ll;typedef unsigned long long ull;typedef vector&lt;int&gt; vi;typedef pair&lt;int,int&gt; pii;typedef pair&lt;string,string&gt; pss;#define rep(i,a,n) for(int i=a;i&lt;n;++i)#define per(i,a,n) for(int i=n-1;i&gt;=a;--i)#define cl(x,a) memset(x,a,sizeof(x))#define pb push_back#define np next_permutation#define mp make_pair#define INF 0x3f3f3f3f#define EPS 1e-8int fa[maxn],cnt[maxn];set &lt;int&gt; s;int n,m,k,t;void init()&#123; rep(i,0,maxn)&#123; fa[i]=i; cnt[i]=1; &#125; s.clear();&#125;int find(int x)&#123; if(fa[x]==x) return x; else &#123; fa[x]=find(fa[x]); return fa[x]; &#125;&#125;bool merge(int x,int y)&#123; int fx=find(x),fy=find(y); if(fx==fy) return false; else &#123; fa[fy]=fx; cnt[fx]+=cnt[fy]; return true; &#125;&#125;int check(int x)&#123; return cnt[find(x)];&#125;int u,v;int main()&#123; ios::sync_with_stdio(false); init(); bool flag= true; while(cin&gt;&gt;u&gt;&gt;v &amp;&amp; u!=-1 &amp;&amp; v!=-1)&#123; if(!u &amp;&amp; !v)&#123; if(flag)&#123; if(s.empty()) cout&lt;&lt;"Yes"&lt;&lt;endl; else&#123; //检查 set &lt;int&gt;::iterator it; int ccnt=0; for(it=s.begin();it!=s.end();it++)&#123; if(fa[*it]==*it) ccnt++; &#125; if(ccnt==1) cout&lt;&lt;"Yes"&lt;&lt;endl; else cout&lt;&lt;"No"&lt;&lt;endl; &#125; &#125; else cout&lt;&lt;"No"&lt;&lt;endl; init(); flag = true; &#125; else &#123; s.insert(u);s.insert(v); if(merge(u,v)==false) flag=false; &#125; &#125;&#125; 收获与反思 记录森林大小]]></content>
      <categories>
        <category>编程</category>
        <category>ACM</category>
      </categories>
      <tags>
        <tag>ACM</tag>
        <tag>算法</tag>
        <tag>2018秋季训练</tag>
        <tag>HDU</tag>
        <tag>并查集</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[【HDU-3172】解题报告（并查集）]]></title>
    <url>%2Fpost%2Fe78ad34c.html</url>
    <content type="text"><![CDATA[原始题目Virtual Friends Time Limit: 4000/2000 MS (Java/Others) Memory Limit: 32768/32768 K (Java/Others) Total Submission(s): 11465 Accepted Submission(s): 3345 Problem DescriptionThese days, you can do all sorts of things online. For example, you can use various websites to make virtual friends. For some people, growing their social network (their friends, their friends’ friends, their friends’ friends’ friends, and so on), has become an addictive hobby. Just as some people collect stamps, other people collect virtual friends. Your task is to observe the interactions on such a website and keep track of the size of each person’s network. Assume that every friendship is mutual. If Fred is Barney’s friend, then Barney is also Fred’s friend. InputInput file contains multiple test cases. The first line of each case indicates the number of test friendship nest. Each friendship nest begins with a line containing an integer F, the number of friendships formed in this frindship nest, which is no more than 100 000. Each of the following F lines contains the names of two people who have just become friends, separated by a space. A name is a string of 1 to 20 letters (uppercase or lowercase). OutputWhenever a friendship is formed, print a line containing one integer, the number of people in the social network of the two people who have just become friends. Sample Input1 3 Fred Barney Barney Betty Betty Wilma Sample Output2 3 4 SourceUniversity of Waterloo Local Contest 2008.09 Recommendchenrui 题目大意朋友圈，给出$n$组朋友，每次输入两个人名，表示两个人成为朋友，同时输出当下两个人朋友圈的总大小。 解题思路 利用map(unordered_map)存储string-&gt;int的映射。 标准并查集，维护集合的大小。 每次merge两人所代表的集合，输出大小即可。 解题代码123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990#include &lt;cstdio&gt;#include &lt;cstring&gt;#include &lt;iostream&gt;#include &lt;set&gt;#include &lt;queue&gt;#include &lt;vector&gt;#include &lt;stack&gt;#include &lt;vector&gt;#include &lt;algorithm&gt;#include &lt;string&gt;#include &lt;iostream&gt;#include &lt;iomanip&gt;#include &lt;map&gt;#include &lt;unordered_map&gt;using namespace std;const int maxn=1e5+5;const int maxm=1e5+5;typedef long long ll;typedef unsigned long long ull;typedef vector&lt;int&gt; vi;typedef pair&lt;int,int&gt; pii;typedef pair&lt;string,string&gt; pss;#define rep(i,a,n) for(int i=a;i&lt;n;++i)#define per(i,a,n) for(int i=n-1;i&gt;=a;--i)#define cl(x,a) memset(x,a,sizeof(x))#define pb push_back#define np next_permutation#define mp make_pair#define INF 0x3f3f3f3f#define EPS 1e-8unordered_map &lt;string,int&gt; mmp;int fa[maxn],cnt[maxn];int n,m,k,t;void init()&#123; rep(i,0,maxn)&#123; fa[i]=i; cnt[i]=1; &#125; mmp.clear();&#125;int find(int x)&#123; if(fa[x]==x) return x; else &#123; fa[x]=find(fa[x]); return fa[x]; &#125;&#125;bool merge(int x,int y)&#123; int fx=find(x),fy=find(y); if(fx==fy) return false; else &#123; fa[fy]=fx;// cout&lt;&lt;"fx="&lt;&lt;fx&lt;&lt;" fy="&lt;&lt;fy&lt;&lt;endl; cnt[fx]+=cnt[fy]; return true; &#125;&#125;int check(int x)&#123;// cout&lt;&lt;"fa="&lt;&lt;find(x)&lt;&lt;endl; return cnt[find(x)];&#125;int main()&#123; ios::sync_with_stdio(false); while(cin&gt;&gt;t) while(t--)&#123; cin&gt;&gt;n; init(); string a,b; int ccnt=0; rep(i,0,n)&#123; cin&gt;&gt;a&gt;&gt;b; if(!mmp.count(a)) mmp.insert(mp(a,++ccnt)); if(!mmp.count(b)) mmp.insert(mp(b,++ccnt)); merge(mmp[a],mmp[b]); cout&lt;&lt;check(mmp[b])&lt;&lt;endl; &#125; &#125;&#125; 收获与反思 可利用unordered_map加速 并查集知识🔗待补充。]]></content>
      <categories>
        <category>编程</category>
        <category>ACM</category>
      </categories>
      <tags>
        <tag>ACM</tag>
        <tag>算法</tag>
        <tag>HDU</tag>
        <tag>并查集</tag>
        <tag>待补充</tag>
        <tag>2018球季训练</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[【POJ-1611】解题报告（并查集）]]></title>
    <url>%2Fpost%2F3d71c64b.html</url>
    <content type="text"><![CDATA[原始题目The Suspects Time Limit: 1000MS Memory Limit: 20000K Total Submissions: 51885 Accepted: 24803 DescriptionSevere acute respiratory syndrome (SARS), an atypical pneumonia of unknown aetiology, was recognized as a global threat in mid-March 2003. To minimize transmission to others, the best strategy is to separate the suspects from others.In the Not-Spreading-Your-Sickness University (NSYSU), there are many student groups. Students in the same group intercommunicate with each other frequently, and a student may join several groups. To prevent the possible transmissions of SARS, the NSYSU collects the member lists of all student groups, and makes the following rule in their standard operation procedure (SOP).Once a member in a group is a suspect, all members in the group are suspects.However, they find that it is not easy to identify all the suspects when a student is recognized as a suspect. Your job is to write a program which finds all the suspects. InputThe input file contains several cases. Each test case begins with two integers n and m in a line, where n is the number of students, and m is the number of groups. You may assume that 0 &lt; n &lt;= 30000 and 0 &lt;= m &lt;= 500. Every student is numbered by a unique integer between 0 and n−1, and initially student 0 is recognized as a suspect in all the cases. This line is followed by m member lists of the groups, one line per group. Each line begins with an integer k by itself representing the number of members in the group. Following the number of members, there are k integers representing the students in this group. All the integers in a line are separated by at least one space.A case with n = 0 and m = 0 indicates the end of the input, and need not be processed. OutputFor each case, output the number of suspects in one line. Sample Input100 4 2 1 2 5 10 13 11 12 14 2 0 1 2 99 2 200 2 1 5 5 1 2 3 4 5 1 0 0 0 Sample Output4 1 1 SourceAsia Kaohsiung 2003 题目大意为了减少SARS传播，最好的方法是将这些疑似患者区分开。现在给定一个学校里有$n$个人，$m$个学生团体，同一学生团体中只要有一个疑似患者，即都被认定为疑似患者。现在统计所有的疑似患者的数量。 解题思路标准并查集，维护一个数组cnt记录集合的大小，根节点的cnt值为集合大小。 初始化 fa[i]=i; cnt[i]=1; find函数路径压缩 fa[x]=find(fa[x]); //加速下一次询问 merge函数增加维护cnt cnt[fx] += cnt[fy] 解题代码12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364656667686970717273747576777879808182838485#include &lt;cstdio&gt;#include &lt;cstring&gt;#include &lt;iostream&gt;#include &lt;set&gt;#include &lt;queue&gt;#include &lt;vector&gt;#include &lt;stack&gt;#include &lt;vector&gt;#include &lt;algorithm&gt;#include &lt;string&gt;#include &lt;iostream&gt;#include &lt;iomanip&gt;using namespace std;const int maxn=1e5+5;const int maxm=1e5+5;typedef long long ll;typedef unsigned long long ull;typedef vector&lt;int&gt; vi;typedef pair&lt;int,int&gt; pii;typedef pair&lt;string,string&gt; pss;#define rep(i,a,n) for(int i=a;i&lt;n;++i)#define per(i,a,n) for(int i=n-1;i&gt;=a;--i)#define cl(x,a) memset(x,a,sizeof(x))#define pb push_back#define np next_permutation#define mp make_pair#define INF 0x3f3f3f3f#define EPS 1e-8 int fa[maxn],cnt[maxn];int n,m,k;void init(int n)&#123; rep(i,0,n)&#123; fa[i]=i; cnt[i]=1; &#125;&#125;int find(int x)&#123; if(fa[x]==x) return x; else &#123; fa[x]=find(fa[x]); return fa[x]; &#125;&#125;bool merge(int x,int y)&#123; int fx=find(x),fy=find(y); if(fx==fy) return false; else &#123; fa[fy]=fx; cnt[fx]+=cnt[fy]; return true; &#125;&#125;int check(int x)&#123; return cnt[find(x)];&#125;int main()&#123; ios::sync_with_stdio(false); while(cin&gt;&gt;n&gt;&gt;m &amp;&amp; n+m)&#123; init(n); rep(i,0,m)&#123; cin&gt;&gt;k; int first,temp; cin&gt;&gt;first; rep(t,1,k)&#123; cin&gt;&gt;temp; merge(first,temp); &#125; &#125;// cout&lt;&lt;"#"; cout&lt;&lt;check(0)&lt;&lt;endl; &#125; &#125; 收获与反思待补充]]></content>
      <categories>
        <category>编程</category>
        <category>ACM</category>
      </categories>
      <tags>
        <tag>ACM</tag>
        <tag>算法</tag>
        <tag>2018秋季训练</tag>
        <tag>并查集</tag>
        <tag>待补充</tag>
        <tag>POJ</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[2018-12-01武汉游记]]></title>
    <url>%2Fpost%2Fa8759852.html</url>
    <content type="text"></content>
      <categories>
        <category>编程</category>
        <category>ACM</category>
      </categories>
  </entry>
  <entry>
    <title><![CDATA[【CSU-2187】解题报告（维护顺序极差）]]></title>
    <url>%2Fpost%2F7410a832.html</url>
    <content type="text"><![CDATA[原始题目2187: 翻转游戏加强版 Time Limit: 1 Sec Memory Limit: 128 Mb Submitted: 101 Solved: 23 Description给当一个01串，最多可以对一段区间里的01取反一次，求最多能取得的1的个数 Input多组数据，第一行为数组组数$T(T≤10)$ 每组数据第一行一个整数$N(1≤N≤{10}^{6})$ 第二行一个长度为$N$的01字符串 Output每组数据输出一行代表答案 Sample Input2 4 1001 4 1111 Sample Output4 4 HintSource题目大意如题 解题思路 小规模数据采取枚举分界点的方法，时间复杂度$O(n^{2})$ 仔细想一下，我们要找的是一个区间，里面0的数量与1的数量差最大。如果直接寻找区间有点难理解的话，我们可以换一个角度，记录出现0和出现1的差值，求差值在翻转以后的最小值。 如图 那么如何求翻转以后的最小值？如果对每个区间下限进行计数，遇1减减，遇0加加，我们的答案就是不同起点的所有cnt值得最大值。 实际上我们就是找图中一个极小值（包括头点）与一个极大值（包括末尾）极差得最大值，而且需要注意得是我们求的是1的翻转次数最大，所以要求是一个极小值在左，极大值在右，左低右高。 再如图 线性从头扫一遍，维护最小值，同时重新计数cnt，最后求cnt的最大值。 解题代码12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364#include &lt;cstdio&gt;#include &lt;cstring&gt;#include &lt;queue&gt;#include &lt;stack&gt;#include &lt;cstring&gt;#include &lt;algorithm&gt;#include &lt;vector&gt;#include &lt;string&gt;#include &lt;bits/stdc++.h&gt;using namespace std;const int maxn=1e6+5;const int maxm=1e6+5;#define INF 0x3f3f3f3f#define EPS 1e-8#define rep(i,a,n) for(int i=a;i&lt;n;++i)#define per(i,a,n) for(int i=n-1;i&gt;=a;--i)#define fi first#define se second#define pb push_back#define np next_permutation#define mp make_pairtypedef long long ll;typedef unsigned long long ull;typedef vector &lt;int&gt; vi;typedef pair&lt;string,string&gt; pss;typedef pair&lt;int, int&gt; pii;int main()&#123; ios::sync_with_stdio(false);// freopen("in.txt","r",stdin); int t; cin&gt;&gt;t; while(t--)&#123; int n; cin&gt;&gt;n; string s; cin&gt;&gt;s; int ans=0,cnt=0,ccnt=0; int mmin=0; rep(i,0,n)&#123; if(s[i]=='0') ans++,cnt++; else ans--,cnt--; if(i==n-1 &amp;&amp; s[i]=='0') ccnt=max(ccnt,cnt); if(i!=n-1)&#123; if(s[i]=='1' &amp;&amp; s[i+1]=='0' &amp;&amp; ans&lt;mmin) mmin=ans,cnt=0; if(s[i]=='0' &amp;&amp; s[i+1]=='1') ccnt=max(ccnt,cnt); &#125; &#125; if(ccnt==0) cout&lt;&lt;n&lt;&lt;endl; else&#123;// cout&lt;&lt;"min="&lt;&lt;mmin&lt;&lt;" max="&lt;&lt;mmax&lt;&lt;endl; ans= ans-2*(ccnt); cout&lt;&lt;(n-ans)/2&lt;&lt;endl; &#125; &#125;&#125; 收获与反思考虑单调性，维护记录值，最大/最小值。]]></content>
      <categories>
        <category>编程</category>
        <category>ACM</category>
      </categories>
      <tags>
        <tag>ACM</tag>
        <tag>算法</tag>
        <tag>CSU</tag>
        <tag>2018秋季训练</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[【CSU-2179】解题报告（水题）]]></title>
    <url>%2Fpost%2F6db0d89d.html</url>
    <content type="text"><![CDATA[原始题目2179: 找众数 Time Limit: 1 Sec Memory Limit: 128 Mb Submitted: 86 Solved: 32 Description由文件给出$N$个$1$到$30000$间无序数正整数，其中$1≤N≤10000$，同一个正整数可能会出现多次，出现次数最多的整数称为众数。求出它的众数及它出现的次数。 Input输入文件第一行是正整数的个数$N$，第二行开始为$N$个正整数。 Output输出文件有若干行，每行两个数，第一个是众数，第二个是众数出现的次数。 Sample Input12 2 4 2 3 2 5 3 7 2 3 4 3 Sample Output2 4 3 4 HintSource题目大意如题 解题思路记录出现次数，加入动态数组中按次数大小快速排序，最后输出（众数多个注意排序的时候按字典序）。 解题代码1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859#include &lt;cstdio&gt;#include&lt;cstring&gt;#include&lt;iostream&gt;#include&lt;set&gt;#include &lt;queue&gt;#include&lt;vector&gt;#include &lt;bits/stdc++.h&gt;using namespace std;const int maxn=1e5+5;const int maxm=1e5+5;typedef long long ll;typedef unsigned long long ull;typedef vector&lt;int&gt; vi;typedef pair&lt;int,int &gt; pii;typedef pair&lt;string,string&gt; pss;#define rep(i,a,n) for(int i=a;i&lt;n;++i)#define per(i,a,n) for(int i=n-1;i&gt;=a;--i)#define fi first#define se second#define pb push_back#define np next_permutation#define mp make_pair#define all(x) x.begin(),x.end()int n;int a[maxn];int ans1=0,ans2=0;vi ans;bool cmp(int c,int d)&#123; if(a[c]==a[d]) return c&lt;d; else return a[c]&gt;a[d];&#125;int main()&#123; ios::sync_with_stdio(false); while(cin&gt;&gt;n)&#123; memset(a,0,sizeof(a)); ans.clear(); rep(i,0,n)&#123; int temp; cin&gt;&gt;temp; if(!a[temp]) ans.pb(temp); a[temp]++; &#125; sort(all(ans),cmp); int len=ans.size(); cout&lt;&lt;ans[0]&lt;&lt;" "&lt;&lt;a[ans[0]]&lt;&lt;endl; for(int i=1;i&lt;len;i++)&#123; if(a[ans[i]]&lt;a[ans[0]]) break; cout&lt;&lt;ans[i]&lt;&lt;" "&lt;&lt;a[ans[0]]&lt;&lt;endl; &#125; &#125;&#125; 收获与反思出题者没说清楚，应该加个特判的，所以注意排序以字典序为第二关键字。]]></content>
      <categories>
        <category>编程</category>
        <category>ACM</category>
      </categories>
      <tags>
        <tag>ACM</tag>
        <tag>算法</tag>
        <tag>CSU</tag>
        <tag>2018秋季训练</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[【CSU-2185】解题报告（水题）]]></title>
    <url>%2Fpost%2F3a72081e.html</url>
    <content type="text"><![CDATA[原始题目2185: a simple problem Time Limit: 1 Sec Memory Limit: 128 Mb Submitted: 78 Solved: 46 DescriptionMy girlfriend loves 7 very much, she thinks it is lucky! If an integer contains one or more 7, she will think it is lucky too! InputThere are multiple test files and each contains one case.The number of cases is at most 100. For each test case, there is only one line with an integer $X ( 1 ≤ X ≤ {10}^{9} )$. OutputFor each test case, if $X$ contains one or more 7, output “Lucky”(without quotation marks),otherwise output “Unlucky”(without quotation marks). Sample Input17171 Sample OutputLucky HintSource题目大意输入一串字符，字符中有7则输出“Lucky”，否则输出“Unlucky” 解题思路逐位判断 解题代码12345678910111213141516171819202122232425262728293031323334353637383940414243444546#include &lt;cstdio&gt;#include&lt;cstring&gt;#include&lt;cmath&gt;#include&lt;iostream&gt;#include&lt;set&gt;#include&lt;queue&gt;#include&lt;map&gt;#include &lt;algorithm&gt;#include &lt;stack&gt;#include &lt;bits/stdc++.h&gt;#define INF 0x3f3f3f3f#define EPS 1e-8#define fi first#define se second#define mp make_pair#define pb push_back#define np next_permutation#define cl(x,a) memeset(x,a,sizeof(x))#define rep(i,a,n) for(int i=a;i&lt;n;++i)#define per(i,a,n) for(int i=n-1;i&gt;=a;--i)using namespace std;const int maxn=1e5+5;const int maxm=1e5+5;typedef long long ll;typedef unsigned long long ull;typedef vector&lt;int&gt; vi;typedef pair&lt;int,int&gt; pii;typedef pair&lt;string,string&gt; pss;int n,t;int main()&#123; while(~scanf("%d",&amp;n))&#123; int flag=0; while(n)&#123; if(n%10==7)&#123; flag=1; break; &#125; n/=10; &#125; if(flag) printf("Lucky\n"); else printf("Unlucky\n"); &#125;&#125; 收获与反思无]]></content>
      <categories>
        <category>编程</category>
        <category>ACM</category>
      </categories>
      <tags>
        <tag>ACM</tag>
        <tag>算法</tag>
        <tag>CSU</tag>
        <tag>2018秋季训练</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[【CSU-2163】解题报告（水题）]]></title>
    <url>%2Fpost%2F73136b.html</url>
    <content type="text"><![CDATA[原始题目2163: 字符画 Time Limit: 1 Sec Memory Limit: 128 Mb Submitted: 221 Solved: 139 Description读入 $w$，请输出 2018 的字符画，两个数字之间有 $w$ 个空格。具体格式请参考样例输出。$(1 ≤ w ≤ 2018)$ Input输入文件只包含 1 个整数 $w$. Output输出 5 行，每行 $12 + 3w$ 个字符（只包含 o 和 . 两种，字符画的部分用 o，空格的部分用 .），以换行符结尾。 Sample Input2 Sample Outputooo..ooo..ooo..ooo ..o..o.o...o...o.o ooo..o.o...o...ooo o....o.o...o...o.o ooo..ooo..ooo..ooo HintSource2018湖南省第14届大学生计算机程序设计竞赛 Authorftiasch 题目大意如题 解题思路打输出 解题代码1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465666768697071727374757677787980#include &lt;iostream&gt;#include &lt;cstdio&gt;#include &lt;cstring&gt;#include &lt;sstream&gt;#include &lt;set&gt;#include &lt;queue&gt;#include &lt;cmath&gt;#include &lt;stack&gt;#include &lt;map&gt;#include &lt;set&gt;#include &lt;algorithm&gt;using namespace std;const int maxn=1e5+5;const int maxm=1e5+5;#define rep(i,a,n) for(int i=a;i&lt;n;++i)#define per(i,a,n) for(int i=n-1;i&gt;=a;--i)#define fi first#define se second#define pb push_back#define np next_permutation#define mp make_pair#define INF 0x3f3f3f3f#define EPS 1e-8int n;int main()&#123; ios::sync_with_stdio(false); while(cin&gt;&gt;n)&#123; &#123; cout&lt;&lt;"ooo"; rep(i,0,n) cout&lt;&lt;"."; cout&lt;&lt;"ooo"; rep(i,0,n) cout&lt;&lt;"."; cout&lt;&lt;"ooo"; rep(i,0,n) cout&lt;&lt;"."; cout&lt;&lt;"ooo"&lt;&lt;endl; &#125; &#123; cout&lt;&lt;"..o"; rep(i,0,n) cout&lt;&lt;"."; cout&lt;&lt;"o.o"; rep(i,0,n) cout&lt;&lt;"."; cout&lt;&lt;".o."; rep(i,0,n) cout&lt;&lt;"."; cout&lt;&lt;"o.o"&lt;&lt;endl; &#125; &#123; cout&lt;&lt;"ooo"; rep(i,0,n) cout&lt;&lt;"."; cout&lt;&lt;"o.o"; rep(i,0,n) cout&lt;&lt;"."; cout&lt;&lt;".o."; rep(i,0,n) cout&lt;&lt;"."; cout&lt;&lt;"ooo"&lt;&lt;endl; &#125; &#123; cout&lt;&lt;"o.."; rep(i,0,n) cout&lt;&lt;"."; cout&lt;&lt;"o.o"; rep(i,0,n) cout&lt;&lt;"."; cout&lt;&lt;".o."; rep(i,0,n) cout&lt;&lt;"."; cout&lt;&lt;"o.o"&lt;&lt;endl; &#125; &#123; cout&lt;&lt;"ooo"; rep(i,0,n) cout&lt;&lt;"."; cout&lt;&lt;"ooo"; rep(i,0,n) cout&lt;&lt;"."; cout&lt;&lt;"ooo"; rep(i,0,n) cout&lt;&lt;"."; cout&lt;&lt;"ooo"&lt;&lt;endl; &#125; &#125;&#125; 收获与反思无]]></content>
      <categories>
        <category>编程</category>
        <category>ACM</category>
      </categories>
      <tags>
        <tag>ACM</tag>
        <tag>算法</tag>
        <tag>CSU</tag>
        <tag>2018秋季训练</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[【CSU-2184】解题报告（水题）]]></title>
    <url>%2Fpost%2F3bc7f503.html</url>
    <content type="text"><![CDATA[原始题目2184: 解密简单版 Time Limit: 1 Sec Memory Limit: 128 Mb Submitted: 101 Solved: 39 Description小F居住在铁道校区，他想和湘雅校区的同学小L聊天，为了保证沟通安全，他发明了一种加密方式，这种加密方式是这样的：对于一个01串，小F会将其从左到右每8位分成一组，最后一组可能不足8位，对每组进行逆序操作，即如果原来是$ b_{L}b_{L+1}b_{L+2}b_{R-1}b_{R} $,逆序之后变成 $ b_{R}b_{R-1}b_{R-2}b_{L-1}b_{L} $。现在小F已经加密好了一个串，并且将其发给了小L，你能帮助小L得到这串密文对应的原始信息吗？ Input单组数据。 一行一个 01 串，代表加密后的字符串，串长度大于0,小于等于 100。 Output一行字符串，代表加密后的字符串所对应的原始信息。 Sample Input100010110011101 Sample Output110100011011100 HintSource题目大意如题 解题思路模8反转输出 解题代码1234567891011121314151617181920212223242526272829303132333435#include &lt;iostream&gt;#include &lt;string&gt;#include &lt;sstream&gt;#include &lt;bits/stdc++.h&gt;using namespace std;const int maxn=1e5+5;const int maxm=1e5+5;#define rep(i,a,n) for(int i=a;i&lt;n;++i)#define per(i,a,n) for(int i=n-1;i&gt;=a;--i)typedef long long ll;typedef unsigned long long ull;typedef vector&lt;int&gt; vi;typedef pair&lt;string,string&gt; pss;int main()&#123; ios::sync_with_stdio(false); string ss; while(cin&gt;&gt;ss)&#123; int len= ss.length(); int t=len/8; rep(i,0,t)&#123; per(j,0,8)&#123; cout&lt;&lt;ss[i*8+j]; &#125; &#125; for(int i=len-1;i&gt;=t*8;i--) cout&lt;&lt;ss[i]; cout&lt;&lt;endl; &#125;&#125; 收获与反思暂无]]></content>
      <categories>
        <category>编程</category>
        <category>ACM</category>
      </categories>
      <tags>
        <tag>ACM</tag>
        <tag>算法</tag>
        <tag>CSU</tag>
        <tag>2018秋季训练</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[【CSU-2183】解题报告（水题）]]></title>
    <url>%2Fpost%2F3fce0650.html</url>
    <content type="text"><![CDATA[原始题目2183: 击鼓传花简单版 Time Limit: 1 Sec Memory Limit: 128 Mb Submitted: 165 Solved: 41 Description岳麓山下旌旗卷，CSU运动会隆重开幕了，小Q所在的班级参加了“击鼓传花”趣味比赛。 比赛规则如下，$n$个队员(不包括小Q)围成一个圈，每个人手里拿着一些花束(数量也可能为0)，小Q站在圆圈的中间，队员需要传递花束给小Q，每个鼓点只允许一个人传送一束花，最终要求圆圈上所有人的花束都传递给小Q。请问需要花多少鼓点呢？ Input多组数据。 第一行$n$，代表队员数量。 第2行到第$n+1$行，每行一个整数$a_i$，代表每个队员最开始拿的花束数量。$(0 ≤ a_i ≤ {10}^{6})$所有组的n之和不超过 $ {10}^{3} $ Output一个整数，代表需要的鼓点数。 Sample Input4 1 2 5 4 Sample Output12 HintSource题目大意如题 解题思路求和，注意long long。 解题代码123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051#include &lt;cstdio&gt;#include &lt;cstring&gt;#include &lt;iostream&gt;#include &lt;set&gt;#include &lt;queue&gt;#include &lt;stack&gt;#include &lt;vector&gt;#include &lt;bits/stdc++.h&gt;using namespace std;const int maxn=1e5+5;const int maxm=1e5+5;#define rep(i,a,n) for(int i=a;i&lt;n;++i)#define per(i,a,n) for(int i=n-1;i&gt;=a;--i)#define fi first#define se second#define pb push_back#define np next_permutation#define mp make_pair#define INF 0x3f3f3f3f#define EPS 1e-8typedef long long ll;typedef unsigned long long ull;typedef vector&lt;int&gt; vi;typedef pair&lt;int, int&gt; pii;typedef pair&lt;string,string&gt; pss;int main()&#123; ios::sync_with_stdio(false); ll sum=0; int n; while(cin&gt;&gt;n)&#123; int temp; sum=0; rep(i,0,n)&#123; cin&gt;&gt;temp; sum+=temp; &#125; cout&lt;&lt; sum&lt;&lt;endl; &#125;&#125; 收获与反思注意long long。]]></content>
      <categories>
        <category>编程</category>
        <category>ACM</category>
      </categories>
      <tags>
        <tag>ACM</tag>
        <tag>算法</tag>
        <tag>CSU</tag>
        <tag>2018秋季训练</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[【CSU-2181】解题报告（枚举分界点）]]></title>
    <url>%2Fpost%2Fc938bbd1.html</url>
    <content type="text"><![CDATA[强化题目和线性做法在这里【CSU-2187】解题报告（维护顺序极差） 原始题目2181: 翻转游戏 Time Limit: 1 Sec Memory Limit: 128 Mb Submitted: 115 Solved: 34 Description给当一个01串，最多可以对一段区间里的01取反一次，求最多能取得的1的个数 Input多组数据，第一行为数组组数$T(T ≤ 10)$ 每组数据第一行一个整数 $N(1 ≤ N ≤ 100)$ 第二行一个长度为$N$的01字符串 Output每组数据输出一行代表答案 Sample Input2 4 1001 4 1111 Sample Output4 4 HintSourceAuthorWells 题目大意如题 解题思路枚举分界点，暴力更新最大值 解题代码12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364656667686970717273747576777879808182#include &lt;cstdio&gt;#include &lt;cstring&gt;#include &lt;iostream&gt;#include &lt;string&gt;#include &lt;set&gt;#include &lt;queue&gt;#include &lt;vector&gt;#include &lt;bits/stdc++.h&gt;using namespace std;const int maxn=1e5+5;const int maxm=1e5+5;#define rep(i,a,n) for(int i=a;i&lt;n;++i)#define per(i,a,n) for(int i=n-1;i&gt;=a;--i)#define fi first#define se second#define INF 0x3f3f3f3f#define EPS 1e-8#define mp make_pair#define np next_permutation#define pb push_backtypedef long long ll;typedef unsigned long long ull;typedef vector&lt;int&gt; vi;typedef pair&lt;int,int&gt; pii;typedef pair&lt;string,string&gt; pss;int t,n;vi le,ri;int a[maxn];int b[maxn];int main()&#123; ios::sync_with_stdio(false); cin&gt;&gt;t; while(t--)&#123; cin&gt;&gt;n; string s; cin&gt;&gt;s; int len=s.length(); le.clear(); ri.clear(); memset(a,0,sizeof(a)); memset(b,0,sizeof(b)); rep(i,0,n)&#123; if(s[i]=='1')&#123; a[i+1]=a[i]+1; b[i+1]=b[i]; &#125; else &#123; a[i+1]=a[i]; b[i+1]=b[i]+1; &#125; if(s[i]=='0' &amp;&amp; i==0 || s[i]=='0' &amp;&amp; s[i-1]=='1') le.push_back(i+1); if(s[i]=='0' &amp;&amp; i==n-1 || s[i]=='0' &amp;&amp; s[i+1]=='1') ri.push_back(i+1); &#125;// rep(i,1,n+1)&#123; cout&lt;&lt;"#"&lt;&lt;a[i]&lt;&lt;" "&lt;&lt;b[i]&lt;&lt;endl;&#125; if(le.empty() &amp;&amp; ri.empty())&#123; cout&lt;&lt;n&lt;&lt;endl; continue; &#125; int all=a[n]; int ans=-INF; for(int i=0;i&lt;le.size();i++)&#123; for(int j=0;j&lt;ri.size();j++)&#123; if(le[i]&gt;ri[j]) continue;// cout&lt;&lt;"left="&lt;&lt;le[i]&lt;&lt;" right="&lt;&lt;ri[j]&lt;&lt;endl; int temp1=a[ri[j]]-a[le[i]-1]; int temp0=b[ri[j]]-b[le[i]-1];// cout&lt;&lt;temp1&lt;&lt;" "&lt;&lt;temp0&lt;&lt;endl; ans=max(all-temp1+temp0,ans);// cout&lt;&lt;"tempans="&lt;&lt;ans&lt;&lt;endl; &#125; &#125; cout&lt;&lt;ans&lt;&lt;endl; &#125;&#125; 收获与反思合理枚举]]></content>
      <categories>
        <category>编程</category>
        <category>ACM</category>
      </categories>
      <tags>
        <tag>ACM</tag>
        <tag>算法</tag>
        <tag>CSU</tag>
        <tag>2018秋季训练</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[金融学辅修——金融学笔记（八）]]></title>
    <url>%2Fpost%2Fc7fb8250.html</url>
    <content type="text"><![CDATA[汇率汇率制度的类型 固定汇率类型（金本位和纸本位） 共通点： 各国对本国货币都规定有金平价，中心汇率是按两国货币各自的金平价之比来确定的。 外汇市场上的汇率水平相对稳定，围绕中心汇率在很小的限度内浮动。不同点： 金本位制下的固定汇率制时自发形成的，纸币流通条件下，固定汇率时国际协议（布雷顿森林体系）认为建立起来的。 金本位制度下，各国货币的金平价不会变动，而在纸币流通条件下，各国货币的金平价则是可以调整的。 浮动汇率制度 自由浮动： 情节浮动 管理浮动： 肮脏浮动 联合浮动：（原欧洲货币体系各成员国之间保持固定汇率，对体系外，即非成员国货币则采取共同浮动做法，洞中小蛇）（相关，1992年GBP危机） 单独浮动：（本国货币不与外国任何货币发生固定联系，根据外汇市场的供求状况单独浮动） 1999年IMF新的汇率制度分类 无独立法定货币的汇率安排 货币局制度（新加坡，香港） 其他传统固定汇率制 水平（上下1%）调整的钉住制 爬行钉住 爬行带内浮动（目标区） 不事先公布干预方式的管理浮动 单独浮动 专栏6-1 我国的金融机构体系——政策性金融机构 政策性金融机构，政策性金融机构由 商业金融机构 我国典当行业概况 典当实际上是一种融资渠道，典当业作为现代金融业的鼻祖，国外称之为“第二银行”。 第四节 金融机构的脆弱性 金融机构的内在脆弱性 功能有效发挥的两个前提条件 投资者不能同时提现 银行能够效率原则，选择效益最好的项目 然而这两个前提条件并不是 挤兑的案例：海南发展银行案例。塞浦路斯银行破产危机案例。 第五节 对金融机构体系的管理国外对金融体系的管理（以美国为例） 证券交易委员会：交易所和金融市场 商品期货交易委员会：期货市场 通货监理官办公室：联邦注册的商业银行 全国信用社管理局：联邦注册的信用社 联邦存款保险公司（罗斯福时期建立）：商业银行、互助储蓄银行、储蓄贷款协会为10万美元以下的存款账户提供保险 联邦储备体系：所有存款机构 管理不慎案例：巴黎银行误操作导致破产。]]></content>
      <categories>
        <category>金融</category>
        <category>金融学</category>
      </categories>
      <tags>
        <tag>课堂笔记</tag>
        <tag>辅修</tag>
        <tag>金融学</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[金融学辅修——微观经济学笔记（四）]]></title>
    <url>%2Fpost%2F685bcc20.html</url>
    <content type="text"><![CDATA[长期成本曲线LTC，LMC，LMC 分别表示长期总成本，长期平均成本和长期边际成本。 曲线间的推导 成本理论的应用-1 产量分配 等边际效应解释，等边际成本时总生产成本最少。（导数证明） 成本理论的应用-2 污染控制]]></content>
      <categories>
        <category>金融</category>
        <category>微观经济学</category>
      </categories>
      <tags>
        <tag>课堂笔记</tag>
        <tag>辅修</tag>
        <tag>微观经济学</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[《不得贪胜》读书笔记]]></title>
    <url>%2Fpost%2Fab720150.html</url>
    <content type="text"><![CDATA[引言 人生如棋，不得贪胜《围棋十绝》 不得贪胜：越是对胜利存有贪念，越得不到胜利。 入界宜缓：穿越警戒线时要缓慢。 功彼顾我：向外攻击对方的时候要回首自身形势。 弃子争先：即使丢掉部分棋子也要抢到先手。 舍小取大：放弃小的利益追求大的收获。 逢危需弃：遇到危及情况要弃子。 慎勿轻速：不要轻率快速行棋。 动须相应：每步行棋需相互配合。 彼强自保：如果对方势力强大则需先谋求自身安全。 势孤取和：形势危孤则首选平和。 《围棋九品》 九品守拙：方式笨拙愚蠢，但是懂得这种守卫的方法。 八品若愚：笨拙但是懂得下围棋的方法。 七品斗力：拥有可以争战的力量，围棋下得有力。 六品小巧：懂得用小的技巧。 五品用智：下围棋时略表现出智慧。 四品通幽：下围棋时仿佛已经进入深奥的围棋世界。 三品具体：博采众长，了解围棋得远近。 二品坐照：坐着能够洞察整个围棋世界。 一品入神：下围棋到达神的境界。 “您认为围棋是什么？”当时我是这样回答的：“我认为围棋就是不断向远方前进。”现在我仍然是这么认为的。 第一章 成长 P010 “所以，直到现在，我还是个左撇子。我也记不清是从什么时候开始，我在下围棋的时候刻意用右手了，因为我得知用右手是‘对对方的尊重’，所以，没有经过痛苦的改正和纠结，我很自然地成为了两只手使用起来都很灵活的人。”P011 “能够这样快快乐乐、无忧无虑度过一个阳光的童年，真是我的幸运。因为在这样的环境下，我养成了看待整个世界和人生的积极态度，学会了用肯定的眼光审视周围的一切，乐观地看到事情充满可能的一面，并且从头到脚饱含着走向完美人生的力量。” 怎样的童年才是适合自己的？肆意增长？还是修剪枝叶？我个人认为李昌镐生来有着一份稚童不改的心，又很幸运的得到了适合他这种心境的教育。 P016 “进入了围棋这个成年人的世界，幼小的我内心充满着惶惑。在我眼里，围棋就是魔法的世界，围棋就是宇宙的中心。世界的所有秘密都被呈现在围棋中，而只要稍微开拓一下视野，那无穷无尽的变化就会滚滚涌现。在那如同迷宫般交错的横线和竖线上思索，然后每次解决困局找到新的棋路的欣喜，就如同发现天下至宝。” P038 “但是在第二次来全州与我对局时，老师改变了对我的看法。在第二次对局的时候，让子数和第一次一样，老师让我三子，但是内容却跟上次很不一样。在短短不过一个月的时间里，我好像从上次的对局中悟出了什么。我的这种样子让周围的人们感觉到了一种‘深入骨髓的力量’。老师也被那种不知道是什么东西的力量所吸引，最终接收我为弟子。” 虽然昌镐拜师后，总显得下棋迟钝、笨拙，复盘也不会。但是曹薰铉老师从未试图改变他的下棋方式，即便不甚满意，这就是大师识人、做事的不同吧。 P043 “你的围棋是由你自己的气质构成的。” 第二章 拼搏减少失误即为成功 P060 “这期间，我通过研究和老师的对局不断反推对局，推出了这样的结论：‘围棋竞技的胜利属于失误少的一方’。这便是我尽量回避对杀的本质原因。回避对杀并不是因为害怕对杀，而是害怕对杀过程中的诸多变化会导致不能预见的失误。” 温故而知新——复盘的力量 P070 “围棋有‘复盘’这样一位‘好老师’，如果你获胜了，那么复盘可以让你养成‘胜利的习惯’；如果你失败了，那么复盘可以让你做好‘胜利的准备’。” P070 “我虽然没有天才般的才能，但是我有持久力。我不断将失败的对弈重新复盘，找出失败的原因，类似于这样的努力我自认为比任何人付出得都多。持久力和努力是任何人都可以做到的。只要能不懈地努力，就再也没有必要害怕那些天生具有某些才能的人了。” 强迫观念，是李昌镐的特点，而对他在棋局上的发挥而言，则是一把双刃剑。 P073 “如果细究起来，从入段时开始，那支配我的心理，让我不知不觉开始‘认生’，开始寡言的根源，就是‘强迫观念’。在由成年人围成的藩篱中，我需要不停地辗转在心里给自己定下种种规矩，我就这样不知不觉变成一个‘老人般的孩子’。” P073 “强迫观念可以说是一把双刃剑。这里说的强迫观念并不同于医学上的那种精神疾病‘强迫症’，因为强迫观念并不是单纯地类似于疾病的坏东西。它包含着两个层面：一方面是不能控制强迫的症状而转变为精神疾病的危险；另一方面则是通过正确的方式和坚强的意志塑造出道德观念和责任感。” 并非单纯的授棋之师，更接近一种为人之师。石佛对老师的态度后来也体现在，婚礼上并没有邀请除老师和师母以外其他围棋界的同僚，其实老师出席本身就已经体现，他对于李昌镐，早已经不单单是围棋上的老师了。 P078 “在我的老师的思想中，老师的精神世界和一般人的层次应是不同的。它应该更接近于道人的世界。在我成为职业棋手之前，他就不断教导我要先学做人。而成为职业棋手继续围棋事业的过程中，他也不断向我强调做人的重要性。通过他的这些教诲，我隐隐感受到了他的为师之道。而他老人家也十分明白地向我展示了什么才是一个老师应有的作为。他曾说过：‘老师就是给弟子打开前行的道路。’回到韩国，收李昌镐为徒后，我便暗下决心：‘一定要按照老师的教会，践行他的为师之道’” 站在巨人的肩膀上，也应给予巨人足够的尊重，因为他原意将肩膀借给你，作为你腾飞的奠基。 P092 “这个世界上充斥着那些没有得到社会承认的天才。这就是世事的原则。而我这个无比犯上不敬的弟子，如果不是拥有了从老师那里借来的巨人的肩膀，飞向更高、飞向更远的这种动力又从何而来呢？” 第三章 腾飞不断地反复咀嚼过去，围棋是零和博弈，失败一方本什么都得不到，唯一的慰藉和不幸中的万幸就是可以在失败中探索，去研究，去向自己索取。 P099 “不断地回想自己的胜利是件开心地事情，但是将失败翻来覆去地研究，是给人巨大精神压力地工作。” “围棋不过如此，但我也只有围棋” P104 “围棋是全部。能够把并不轻松人生意义通过‘围棋不过如此，但我也只有围棋’这种轻松的言语表达出来，其中的哲学高度并不是每个人都能达到的。” P141 “自信真是一种奇妙的东西，有的时候它会带来足以压倒对方的气势，而有的时候，它便回越过应有的位置，成为向对方暴露要害的漫不经心。而在为其中，当必要的精密轰然倒塌时，自己的棋便无法再由自己掌控了。” 日本的经营学者中郁次郎在《战略的本质》一书中对战略这样分析：战略并不单纯指的是桌面上的作战计划，而是与对手的一种相互作用。 P144 “围棋是以战争为模型，双方较量战略的游戏。施行战略的最高指挥官必须对和战争相关的所有因素以及敌人所可能采取的行动进行细致精密的分析，全面分析过后才能确定最终行动方针。这个过程在围棋中便以布局、定式、中盘、终盘、封盘的过程一一展现。” 红皇后效应是指一个人在发生变化的同时，周围环境和竞争对手同样在变化，甚至变化的更快，自身的相对位置不升甚至有可能反而下降。 红皇后这样呼喊道：“就算是想保持原位不动也要拼命地奔跑才行！” P155 “变化是必然的。没有进步，保持原位不动就是退步。就算是苟然无目的地向前以动，也有可能出现发展的道路。拜托停滞不前的那第一部路，说不定就会成为前进的道路。” 第四章 危机 P184 “明知道有危险也要不顾一切冲上去并不能算是有勇气。能够克制住自己的冲动，拒绝外界的诱惑，默默地走自己的道路，这种选择才是勇气的表现。这时决胜点在于丧失忍耐力。” P184 “危机二字如同其字面的意思，危险和机遇是相伴相生的。” 让一个人安静独处，有时候是最好的关怀方式。 第五章 不得贪胜 P210 “赵治勋九段不顾人们含着泪的阻止，强行参加棋圣战的迫切意志，原来并不是源自于‘英雄的斗魂’，而是由于急于确认迷茫未来的这种人之常情。” 英雄往往是被媒体塑造的，但是英雄精神的内核往往就是被我们忽略的每个平常人都具有的特质，李敏镐眼里的赵九段，只是用最人性的方法来确认不安中摇摆的自己的存在，外人看来疯狂而决绝，其实这是事中人必然的做法。 5岁到日本学棋，并且就像前文提到的一样，对于赵九段，围棋就意味着全部，他只有围棋，如果被突然告知不能再下围棋了，无异于天降死刑，所以他不甘。 P211 “赵九段的这个故事，生动而又深刻地向我展示了一个事实，那就是迫切感也会成为一个人再面临胜负时的强大力量。” 迫切感可以化做力量，的确如此。]]></content>
      <categories>
        <category>阅读</category>
      </categories>
      <tags>
        <tag>阅读</tag>
        <tag>自传</tag>
        <tag>不得贪胜</tag>
        <tag>李昌镐</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[金融学辅修——金融学笔记（七）]]></title>
    <url>%2Fpost%2F3090aa13.html</url>
    <content type="text"><![CDATA[第四章 金融市场的利率继续之前课堂的内容 第三节 我国利率的市场化改革利率市场化进程 1996.6年放开银行间同业拆借市场利率 1997.6 利率机制：央行利率——银行利率——市场利率 阶段目标：“存款利率管上限，贷款利率管下限” 二元化的利率调控模式： 调整存贷款基准利率（上下限）影响金融机构存贷款利率水平 通过公开市场操作及各类中央银行利率引导市场利率 问题： 利率市场化步骤（利率市场化，交易品种丰富化；存贷款利率市场化；法律明确） 中国特点：政府推进型；渐进型；可控型；谨慎型 今后突破：贷款下限，存款上限。 古典学派的储蓄投资理论 利率是由储蓄函数和投资函数共同决定的，取决于]]></content>
      <categories>
        <category>金融</category>
        <category>金融学</category>
      </categories>
      <tags>
        <tag>课堂笔记</tag>
        <tag>辅修</tag>
        <tag>金融学</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[算法与数据结构学习——最小生成树]]></title>
    <url>%2Fpost%2F9d402b32.html</url>
    <content type="text"><![CDATA[引入在之前的学习中，我们已经介绍了图的储存方式等相关内容。 （这里待补坑） 数据结构课本上引入： “假设要在n个城市之间建立通信联络网，则连通n个城市只需要n-1条线路。这时，自然会考虑这样一个问题，如何在最节省经费的前提下建立这个通信网” 在含有n个结点的连通网中挑选n-1条边构造一颗边权和最小（耗费最小），这个问题就是最小代价生成树（Minimum Cost Spanning Tree）（简称最小生成树）构造问题。 定义补充关于图的几个概念定义： 连通图：在无向图中，若任意两个顶点vivi与vjvj都有路径相通，则称该无向图为连通图。 强连通图：在有向图中，若任意两个顶点vivi与vjvj都有路径相通，则称该有向图为强连通图。 连通网：在连通图中，若图的边具有一定的意义，每一条边都对应着一个数，称为权；权代表着连接连个顶点的代价，称这种连通图叫做连通网。 生成树：一个连通图的生成树是指一个连通子图，它含有图中全部n个顶点，但只有足以构成一棵树的n-1条边。一颗有n个顶点的生成树有且仅有n-1条边，如果生成树中再添加一条边，则必定成环。 最小生成树：在连通网的所有生成树中，所有边的代价和最小的生成树，称为最小生成树。 算法构造最小生成树有很多算法，但是他们都是利用了最小生成树的同一种性质： MST性质：假设N=(V,{E})是一个连通网，U是顶点集V的一个非空子集，如果（u，v）是一条具有最小权值的边，其中u属于U，v属于V-U，则必定存在一颗包含边（u，v）的最小生成树 性质证明： 反证法：假设网N的任何一棵最小生成树都不包含（u，v）。设T是连通网上的一棵最小生成树，当将边（u，v）加入到T中时，由生成树的定义，T中必存在一条包含（u，v)的回路。另一方面，由于T是生成树，则在T上必存在另一条边（u’，v’），其中u’∈U，v’∈V - U，且u和u’之间，v和v’之间均有路径相通。删去边（u’，v’），便可消除上述回路，同时得到另一棵生成树T’。因为（u，v）的代价不高于（u’，v’），则T’的代价亦不高于T，T’是包含（u，v）的一棵最小生成树，和假设矛盾。 下面就介绍两种使用MST性质生成最小生成树的算法：普里姆算法（Prim）和克鲁斯卡尔（Kruskal）算法。 2、普里姆算法—Prim算法 首先就是从图中的一个起点a开始，把a加入U集合，然后，寻找从与a有关联的边中，权重最小的那条边并且该边的终点b在顶点集合：（V-U）中，我们也把b加入到集合U中，并且输出边（a，b）的信息，这样我们的集合U就有：{a,b}，然后，我们寻找与a关联和b关联的边中，权重最小的那条边并且该边的终点在集合：（V-U）中，我们把c加入到集合U中，并且输出对应的那条边的信息，这样我们的集合U就有：{a,b,c}这三个元素了，一次类推，直到所有顶点都加入到了集合U。]]></content>
      <categories>
        <category>编程</category>
        <category>数据结构与算法</category>
      </categories>
      <tags>
        <tag>最小生成树</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[算法与数据结构学习——线索二叉树]]></title>
    <url>%2Fpost%2F4db7e28a.html</url>
    <content type="text"><![CDATA[引入在之前的学习中，我们能够感觉到，二叉树的非递归遍历需要用到栈结构的原因是需要之前遍历的信息。 以二叉链表作为存储结构时，只能找到结点的左、右孩子信息，而不能直接得到结点在任一序列中的前驱和后继信息，这种信息只能在动态过程中才能得到。 我们想保存这个信息，该怎么办？ 通过考察各种二叉链表，不管形态如何，空链域的个数总是多过非空链域的个数。准确的说，n 个结点的二叉链表共有 2n 个链域，非空链域为 n-1 个，其中的空链域必定有 n+1 个。如下图所示。 实际上，我们可以利用好这些空链域来存放结点的前驱和后继信息。 线索二叉树1234567891011// 二叉树的二叉线索存储表示typedef enum PointerTag&#123; Link, Thread&#125;; //0 为孩子指针 1为线索指针typedef struct BiThrNode&#123; TElemType data; struct BiThrNode *lchild, *rchild; //左右孩子/线索指针 PointerTag LTag, RTag; //左右标识 线索化的实质就是将二叉链表中的空指针改为指向前驱或后继的线索。由于前驱和后继信息只有在遍历该二叉树时才能得到，所以，线索化的过程就是在遍历的过程中修改空指针的过程。遍历即线索化过程。 1234567891011121314151617181920BiThrTree pre; //表示遍历的上一点void InThreading(BiThrTree p)&#123; if (p) &#123; InThreading(p-&gt;lchild); //遍历左子树 if (!p-&gt;lchild) //当前点没有左孩子 &#123; p-&gt;LTag = Thread; //前驱线索标记 p-&gt;lchild = pre; //左孩子指针指向前驱 &#125; if (!pre-&gt;rchild) //前驱点没有右孩子 &#123; pre-&gt;RTag = Thread; //后继线索标记 pre-&gt;rchild = p; //右孩子指针指向后继 &#125; pre = p; InThreading(p-&gt;rchild); //遍历右子树 &#125;&#125; 中间代码做的事情： 对中间结点的左孩子判断（是否存在直接前驱），如果不存在的话左孩子的指针并不是空，而是指向保存的前驱结点。同时对前驱结点的右孩子判断（是否存在直接后继），如果不存在的话指向当前的结点。 如图： 完成前驱和后继以后，线索二叉树的遍历，实际上等于操作一个双向链表结构。 如图： 参考博客彻底理解线索二叉树]]></content>
      <categories>
        <category>编程</category>
        <category>数据结构与算法</category>
      </categories>
      <tags>
        <tag>线索二叉树</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[金融学辅修——金融学笔记（六）]]></title>
    <url>%2Fpost%2Fe290dd8c.html</url>
    <content type="text"><![CDATA[课前小组分享资本市场和衍生品市场我国资本市场的发展历程探索阶段——成长阶段——协调发展阶段——深化改革依法治市阶段 股票市场股票发行和流通的场所，可以分为一级和二级：一级发行，二级流通。 职能：积聚 转让 转化 基本性质：不可偿还行 参与性 收益性（可以参与流通） 流通性（可以二次流通） 波动性和风险性 股票的分类： 股东权利分类：普通股，优先股，后配股 上市地区分类：A股，B股，H股（香港），N股（纽约），S股 按业绩分类：绩优股，垃圾股，蓝筹股 债券市场政府、企业、银行，到期还本付息的？？ 基本性质：偿还性，流通性，安全性， 企业破产时，债权人索取资产优先于股东 债券融资的优点和缺点： 优点：资本成本低，具有财务杠杆作用，所筹集资金属于长期资金，债券投资范围广 缺点：限制条件多， 衍生品市场远期、期货、互换、期权 是一种金融合约。XXX 远期合约 远期利率协议、远期外汇合约、远期股票合约。 相关风险：时间跨度大，不确定因素多，规模和持仓量都不如现期。 期货 期货交易分类：商品期货和金融期货。 最大的区别就是双向交易，可以买多也可以卖空。价格上涨时可以低买高卖。 互换 互换交易 非现金支付非现金支付分类票据，银行卡（信用卡，借记卡），网上支付。 非现金支付的前世今生 银联诞生，信用卡开启五现金支付第一步 交易场景变革。改革开放，难以满足线下大额交易。 支付产业变革 02年银联建立 创立了银联卡，提供线下清算服务。 电商时代来临，第三方支付问世 交易场景变革。互联网发展带动线上交易场景出现，电子商务时代来临。 支付产业变革。第三方支付，“支付宝”提出担保支付模式，虚拟账户概念，推动清算。 移动时代来临，再次变革进行中 移动端入口加入。 扫码支付迈向渗透线下场景的第一步 微信红包13年除夕开始发力，推动微信支付打破支付宝一方独霸的场面。 支付产业变革总结非现金支付的衍生价值 消费金融：推动消费金融向长尾客户的渗透。 财富管理：基于互联网的财富管理新模式，具有无限商机。 政府监管：互联网信息监管，可以减少洗钱等问题。 废县及支付的发展现状 我国： 1362.14亿笔，金额规模4024.56万亿元。70%支付比例。 国外 欧洲地区： 美国：信用卡支付比较发达，但是移动支付发展比较缓慢。 亚洲地区：新加坡提出“无现金”支付，日本看齐美国。印度发展过8%。 非洲地区：非洲肯尼亚，M-pesa。 中外非现金支付现状差异 具体方式不同：中国以移动支付为主，美国等以信用卡消费。 原因，中国没有信用卡消费的习惯和粘性。 现金 or 非现金 如果拒收现金，损害了人民币的法定地位。 垄断问题，政府参与系统问题。 P2P小额信贷 人人贷P2P平台，有钱需要理财和缺钱需要贷款，联络双方的一个平台。 投标，散标。 平台概况：8年，700多亿。 三倍于常规借贷，但是审核，到款快。 三条红线：资金池模式，非法集资，庞氏骗局模式。 第四章 金融市场的利率继续之前课堂内容 关于中国的Shibor（2007年1月4日对外公布） Shibor的定义 中国货币市场基准利率，是根据信用等级较高的银行报出的人民币同业拆除利率计算确定的算术平均利率。 由上海同业拆借中心进行计算和发布，因而命名为“上海银行间同业拆放利率”（Shanghai Interbank Offered Rate） Shibor报价行名单 中工农建交，Shibor报价行的职责：Shibor的报价每日提供基于市场情况的拆入、拆出的双边报价，并且 在当日货币市场的交易中，以其报价利率为基准。报价行的报价行为应是独立的，当日的报价不得在银行间相互参照。 如何得到Shibor 相关网站链接 http://www.shibor.org http://www.chinamoney.com.cn 利率掉期 第二节 利率的计算 单利和复利 单利：存贷期的各期只以本金乘以利率计算的利息 S=P+r*n 复利：指数 终值和终值洗漱 终值是用复利计算的一笔投资在某个时间获得的本利和。 S=P {(1+r)} ^ }n 与厨师本金P相乘的系数成为终值系数。 关于计息次数 常以年度百分率和一定的计息次数（如按月按天计息）表示，在哦同样的时间内。通常使用实际年率l 现值与贴现 现值（present value）与终值是相对应的概念。现值就是未来收益按照一定的贴现率贴现后的当前价值。 银行贴现：$PV=P-P \dot r \dot n$ 现金 = 本金（期满应还）-本金 × 利率 × 时间 扣除利息 = 本金 × 利率 × 时间]]></content>
      <categories>
        <category>金融</category>
        <category>金融学</category>
      </categories>
      <tags>
        <tag>课堂笔记</tag>
        <tag>辅修</tag>
        <tag>金融学</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[亚马逊AWS云计算讲座笔记]]></title>
    <url>%2Fpost%2F1dc46f40.html</url>
    <content type="text"><![CDATA[亚马逊历史1994年发展起来，除大中华区，电商巨头 云计算 AWS， Amazon Web Service 2006年成立 Gartner IT行业咨询公司 市场占有率：AWS 44.1%，2016数据， 正式演讲云计算的由来工业革命：两次对动力系统的革新 动力轴对比电网供电：稳定性，可调节性，初始投资，动力成本，可拓展性。 ？？So how about 云计算 第三次工业革命 企业IT系统：办公系统/CRM/ERP/生产销售管理招标建设运维模式：需求-&gt;招标-&gt;厂家选择-&gt;工程建设-&gt;系统运行维护-&gt;再需求 互联网产业带来新需求 新需求 超大规模 敏捷（Agile） Emmm该补功课了（新需求到新产品的滞后期） 互联网企业先有流量，再有变现。 变现途径：广告，增值服务，游戏，出租服务。 先有： 新需求-&gt;新技术-&gt;新思想-&gt;新组织模式 以变现作为驱动力： 技术扩散-&gt;云计算 案例分析云计算价值前例：AWS+JPL NASA卫星图像的分析，2小时 案例1：降低创新门槛 产品创新一套测试环境：6服务器+1交换机 传统模式需要2到6周时间 AWS云环境？（虚拟服务器配置） 案例2：弹性扩展 某电信行业软件巨头新功能交付：2~3月 需求分析与系统设计：4周 代码编写与单元测试：2~3周 系统回归测试：4周 测试结果是否和预期一致 确保软件稳定性：数十万测试用例 缩短交付周期：自动化测试；集中所有可用硬件设备并行测试 瓶颈：可用硬件设备有限，继续扩充利用率和成本有问题。 云计算的六个优势 Trade capital expense for variable expensive Benefit from massive economies of scale Stop guessing about capacity Increase speed and agility Stop spending money running and maintaining data centers Go global in minutes AWS的大数据和AI平台Amazon 平台可用的开源工具 数据价值递减曲线 《《待补充 最近的数据 非常有价值 如果你及时采取行动 旧的数据+新的数据 更有价值 如果你能找到联系他们的方法 Amazon 机器学习平台堆栈：应用服务API基础设施框架，平台服务，应用服务。 平台：Amazon SageMaker大规模构架，直接调优模型，调优算法 AWS Academy ProgramAWS Academy计划学期课程为一个一个学期，AWS Cloud Practitioner AWS Educate教育优惠 AWS 认证路径job market不错 开发者，系统管理员，架构师。 Dockers 容器 AWS Training andQ&amp;A 对于Amazon的认证 课程本身应该不是免费的。 Amazon本身需求在AWS的占比 可见比例，但是具体并不知道，另外还有Netflix在里面占有比较大的比例（全托管) 服务器征用，有可见选项 折扣比较低 对于中国云市场的整体看法 Amazon对于云计算在以后的拓展方向 最开始只有S3，对象存储。 云平台，信息安全问题 观念问题落后于实际问题]]></content>
      <categories>
        <category>讲座</category>
      </categories>
      <tags>
        <tag>讲座笔记</tag>
        <tag>AWS</tag>
        <tag>亚马逊</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Python学习——《FlaskWeb开发》笔记（一）]]></title>
    <url>%2Fpost%2F6cb7680e.html</url>
    <content type="text"><![CDATA[第一部分 Flask简介第1章 安装Flask有3个主要依赖： 路由、调试和Web服务器网关接口子系统由Werkzeug提供； 模板系统由Jinja2提供； 命令行集成由Click提供。 这些依赖都是Flask的开发者Armin Ronacher开发的。 原生不支持数据库访问、Web表单验证和用户身份验证，但是可通过拓展形式实现。 虚拟环境安装 pip install virtualenv Windows 注意修改PATH环境变量 第2章 应用的基本架构 初始化应用实例 所有来自客户端的请求都交由应用实例（Flask类对象）处理。 路由和视图函数 客户端（Web）浏览器把请求发送给Web服务器，Web服务器再把请求发送给Flask应用实例。 应用实例保存URL请求到Python函数的映射关系，处理URL和函数之间关系的程序称之为路由。 最简单的方法（app.route）装饰器： 123@app.route('/')def index() return '&lt;h1&gt;Hello World!&lt;/h1&gt;' index()这样处理入站请求的函数称之为视图函数，函数的返回值称之为响应，是客户端接收到的内容。 路由URL中放在尖括号里面的内容是动态部分，任何能匹配到静态部分的URL会映射到这个路由上，调用视图函数时， Flask会将动态部分作为参数传入函数 123@app.route('/user/&lt;name&gt;') # 任何匹配静态部分的URL都走这个路由def user(name): # 尖括号里的name作为参数传递进视图函数 return '&lt;h1&gt;Hello, &#123;&#125;!&lt;/h1&gt;'.format(name) 请求-相应循环 应用和请求上下文 请求对象封装了客户端发送的HTTP请求。方便使用，会通过上下文变为全局可访问。 上下文全局变量：current_app, g, request, session 请求分派 URL映射，路由。Flask为每个路由都制定了请求方法，这样即使不同的请求方法发送到相同URL上，也会 使用不同的视图函数来处理 请求对象 上下文变量request对外开放请求对象，包含全部信息。 请求钩子 请求钩子通过装饰器实现，四种钩子：before_request, before_first_request, after_request, teardown_request 响应 多数情况下，视图函数返回值作为响应内容。字符串，状态。response对象。URL重定向。 Flask扩展 第3章 模板模板是包含响应文本的文件，其中包含用占位变量表示的动态部分，其具体值只在请求的上下文中才能知道。使用真实值替换变量，再返回最终得到的响应字符串，这一过程称为渲染。Jinja2 变量 大括号两层括起来的部分就是变量，可以识别复杂类型，加过滤器（渲染时事变变换），如|capitalize, |lower ,|upper, |title, |trim, |striptags:. {{ name }} 表示name是等待视图函数传递的变量 eg &lt;p&gt; A value from a dictionary : {{ mydict['key'] }}, &lt;/p&gt; &lt;p&gt; A value from a list : {{ mylist[-1] }}, &lt;/p&gt; &lt;p&gt; A value from a dictionary with 过滤器: {{ mydict['key']|striptags: }}, &lt;/p&gt; 控制结构 条件判断 {% if user %} Hello, {{ user }} {% else %} Hello. Stranger {% endif %} 初步尝试 123456789101112131415161718192021222324252627282930313233343536&#123;% extends "bootstrap/base.html" %&#125;&#123;% block title %&#125;Flasky&#123;% endblock %&#125;&#123;% block navbar %&#125;&lt;div class="navbar navbar-inverse" role="navigation"&gt; &lt;div class="container"&gt; &lt;div class="navbar-header"&gt; &lt;button type="button" class="navbar-toggle" data-toggle="collapse" data-target=".navbar-collapse"&gt; &lt;span class="sr-only"&gt;Toggle navigation&lt;/span&gt; &lt;span class="icon-bar"&gt;&lt;/span&gt; &lt;span class="icon-bar"&gt;&lt;/span&gt; &lt;span class="icon-bar"&gt;&lt;/span&gt; &lt;/button&gt; &lt;a class="navbar-brand" href="/"&gt;Flasky&lt;/a&gt; &lt;/div&gt; &lt;div class="navbar-collapse collapse"&gt; &lt;ul class="nav navbar-nav"&gt; &lt;li&gt;&lt;a href="/"&gt;Home&lt;/a&gt;&lt;/li&gt; &lt;/ul&gt; &lt;/div&gt; &lt;/div&gt;&lt;/div&gt;&#123;% endblock %&#125;&#123;% block content %&#125;&lt;div class="container"&gt; &lt;div class="page-header"&gt; &#123;% if name == "ryx" %&#125; &#123;# 注意==符号还有 双引号 #&#125; &lt;h1&gt;Hello, 大哥 &#123;&#123; name|striptags: &#125;&#125;!&lt;/h1&gt; &#123;% else %&#125; &lt;h1&gt;Hello, 小老弟 &#123;&#123; name|striptags:&#125;&#125;! &lt;/h1&gt; &#123;% endif %&#125; &lt;/div&gt;&lt;/div&gt;&#123;% endblock %&#125;]]></content>
      <categories>
        <category>编程</category>
        <category>Python</category>
      </categories>
      <tags>
        <tag>Python</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[金融学辅修——金融学笔记（五）]]></title>
    <url>%2Fpost%2F879e9655.html</url>
    <content type="text"><![CDATA[课前同学分享银监会和保监会 混业经营，灰色地带。 2018年3月人大表决通过，设立中国银行保险监督管理委员会，即银监会和保监会合并。4月正式挂牌。 小微企业的重要性 企业规模小，生命周期不长，缺乏质押品，信用记录不够完善。 阶段性成就： 银保监会措施: 更好的借贷：降低对小微企业的贷款抵押以来，缩短周期，满足小微企业的资金需求。 更好的考核：疏通货币政策的传导机制 银保监会的建议： 偏离主业，过度融资，高杠杆 去也自身的问题。 课堂知识信用与中小微企业融资普惠金融（额外内容）普惠金融的背景、意义、界定、现状等等 章前引言：十九大报告之——建设现代化经济体系 六大任务 深化供给侧结构性改革 加快建设创新型国家 实施乡村振兴战略 实施区域协调发展战略 加快完善社会主义市场经济体制 推动形成全面开放格局 根据乡村振兴战略的目标发展而来 章前引例实施乡村振兴战略的四大经济手段： 发展多种习惯是适度规模经营 培育新型农业经营主体 促进农产品一二三产业融合发展 支持和鼓励农民就业创业 三农市场潜在金融产品和服务需求： 农业季节性生产特征。（农忙时节） 发展的困难，供给不足的障碍： 缺乏盈利记录和交易信息，难以纳入评估体系 缺乏可靠的抵押物品，难以得到传统信贷业务覆盖。 征信问题 地理分散，增大负担 小微、三农 联合国定义： 能有效、全方位为社会所有阶层和群体，提供服务的金融体系。 第四章 金融市场的利率金融市场的利率 利率与利率的含义/利率的计算/利率市场化/利率理论/利率期限结构 第一节 利率与利率的含义基准利率——金融市场体系中的中枢神经 美国联邦准备金率——同业拆借利率 基准利率必须是市场化体制下产生的利率： 原则：相关性、可测性、可控性、灵敏性。 伦敦同业拆借利率（Libor） 利率-利息率 指借贷期间所形成的利息率额与本金的比率。反映利息水平的高低，一种重要的经济杠杆。 利率体系：（利率的种类） 市场利率与基准利率。名义利率与实际利率 r=i+p r=(1+i)(1+p)-1 固定利率与浮动利率（浮动利率提前签好，3%；LIBOR+-0.3%） 市场利率与官定利率 一般利率与优惠利率 平均利率、基准利率和到期收益率 Shibor ？？？？？？ 利率掉期 利率掉期示意图 兴业银行和花旗银行 最明显的问题 327国债期货]]></content>
      <categories>
        <category>金融</category>
        <category>金融学</category>
      </categories>
      <tags>
        <tag>课堂笔记</tag>
        <tag>辅修</tag>
        <tag>金融学</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[金融学辅修——微观经济学笔记（三）]]></title>
    <url>%2Fpost%2Fdf76d545.html</url>
    <content type="text"><![CDATA[承接上一篇 第二章 需求、价格与供求关系第六节 需求弹性和供给弹性待补充 影响需求的价格弹性的因素 eg：禁毒增加还是减少了与毒品相关的犯罪 需求弹性小，供给弹性大。 禁毒是控制供给。 控制需求更为重要，反毒品教育是控制需求。 互补、替代 需求量：互补商品反向变化，替代商品同向变化。 需求的收入弹性 Em&gt;1，Em=1，Em&lt;1，Em=0，Em&lt;0（劣质物品，吉芬品） 恩格尔系数的弹性概念解释 第七节 运用供求曲线的事例 价格政策 Price controls 价格调节有其不完善性，需要价格政策来支持。短期性和无序性 支持价格【最低限价】（Price Floor） ：政府为了保护或者扶持某个行业而出台的产品最低价格。 支持农产品的作用：稳定农产品，调整农业结构。 （属于宏观调控，防止市场调节的滞后性） 最高限价总是高于市场的均衡价格。目的往往是抑制某些产品的价格上涨，尤其是为了应对通货膨胀。 最低限价总是低于市场的均衡价格。目的往往是扶持某些行业的发展。 价格上限的弊端 价格水平低不利于刺激生产。 限制价格的弊端 一般在战争或者自然灾害时期使用。 政府税收对均衡价格的影响 从量税与从价税：从量税根据商品销售数量征税；从价税根据商品销售收入征税。 对消费者征税，需求曲线左移。对生产者征税，供给曲线左移。]]></content>
      <categories>
        <category>金融</category>
        <category>微观经济学</category>
      </categories>
      <tags>
        <tag>课堂笔记</tag>
        <tag>辅修</tag>
        <tag>微观经济学</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Python学习——《笨方法学Python3》笔记（一）]]></title>
    <url>%2Fpost%2F6e80eb1e.html</url>
    <content type="text"><![CDATA[习题1~习题22学了什么 格式化字符串: 12w = f"What I want is &#123;you&#125;."# 此处you为变量名，格式化字符串会用变量替换对应的位置 字符串填充： 1234w = "What I want is &#123;&#125;."w.format("R") # 或者其他变量# 通过字符串的format方法填充对应位置# '+'可以用来拼接 print() 1# 缺省最后一个参数 end='\n' ，默认是换行 引入模块（库） 1234from sys import argvscript, file_name = argv# 解包# argv[0]为程序运行的名称，后面变量在命令行中输入，个数需要匹配，否则报错 文件操作 1234567891011# oepn()第一个参数为字符串，是文件名，第二个参数操作方式，缺省为"r"只读# open()的返回值为一个文件对象file_name = "eddy.txt"target = open(file_name, "r")in_data = target.read() # 读取内容target.close() # 最后要关闭file_name = "eddy.txt"in_data = open(file_name, "w").write("Well, Allright")# 'w'写入# 这种操作写入完成后会自动关闭文件，无需再写close（而且也不知道咋写，没名字） 习题23~习题39循环、列表与字典循环 123456# 少用while多用for，尤其是已知循环次数的时候for i in range(3,5)# range 左闭右开for i in change# change为列表，后面会介绍# for虚幻的时候i就被定义了，每次碰到则赋值为当前循环的元素值 列表，有的地方叫做数组，这里按照python的习惯说法称之为列表。列表支持按照角标随机访问。 12345678_count = [1,2,3,4,5]fruits = ['apples','oranges','pears','apricots']change = [1,'pennies',2,'dimes',3,'quarters']# 列表添加末尾（类似push_back）new_word = 'new'change.append(new_word)# 列表中的列表，二维列表[[1,2,3],[4,5,6]] 字典（类比C++STL里的map）实际上就是映射，不过这里不用在乎类型。 123456789# 注意大括号states = &#123; 'Oregon': 'OR', 'Florida': 'FL', 'New York': 'NY'&#125;# 对于字典的循环for i,j in list(states.items()): print(i,j) 字典的get方法（尤其注意第二个参数的缺省值） 123456789101112# 描述# Python 字典 get() 函数返回指定键的值，如果值不在字典中返回默认值。# 语法# get()方法语法：dict.get(key, default=None)# 参数# key -- 字典中要查找的键。# default -- 如果指定键的值不存在时，返回该默认值值city = cities.get('TX', 'Does Not Exist')# 所以书目中cities字典中虽然没有键值为'TX'的映射，但是设置了未查到的返回值。 此时city的值为'Does Not Exist' 关于切片 多说点如此，我们会得到从starting_index对应元素开始，到ending_index对应元素结束，但是不包括ending_index对应元素，所组成的子序列的内容。起止索引都是可选的选项，如果没有提供或者为None，那么开始索引默认为0，结束索引默认为序列最末尾的索引。切片的访问模式，有第三个值，类似于步长，其访问类似下面代码 12345&gt;&gt;&gt; ('a','b','c','d')[0:3:2]('a', 'c')food='appale pie'print(food[-3:7]) 后面，-3其实是6的位置 12345678910111213141516171819202122232425262728293031323334353637383940414243import numpy as npa = np.array([[-1,2],[2,3]])b = np.array([[3,4],[4,5]])print '\n a:\n',aprint '\n b:\n',b##转置print '\n a transpose:\n',a.T##共扼矩阵#print '\n a H:\n',a.I##逆矩阵print '\n a inv:\n',np.linalg.inv(a) # 求逆##转置print '\n a transpose:\n',a.T# a + b，矩阵相加print "\n a+b: \n",a+b# a - b，矩阵相减print "\n a-b: \n",a-b#2x2 矩阵，矩阵相乘print "\n a mul b:\n",a.dot(b.T)#2x3矩阵，矩阵点乘print "\n a dot b: \n",a*b#2x3矩阵，矩阵点除print "\n a/b \n:",a/np.linalg.inv(b)#求迹print "\n a trace",np.trace(a) #特征，特征向量eigval,eigvec = np.linalg.eig(a) #eigval = np.linalg.eigvals(a) #直接求解特征值print "\n a eig value:\n",eigval,print'\n a eig vector:\n',eigvec]]></content>
      <categories>
        <category>编程</category>
        <category>Python</category>
      </categories>
      <tags>
        <tag>Python</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[《金融的本质：伯南克四讲美联储》读书笔记]]></title>
    <url>%2Fpost%2Fbea42f1e.html</url>
    <content type="text"><![CDATA[第一讲 美联储的起源与使命本讲先说说中央银行的定一、职能、以及他是符合在美国出现的，我还会介绍美联储如何应对其第一次重大挑战，即20世纪30年代的经济大萧条。 第二讲中，回顾二战后美联储的发展状况、80年代如何战胜通胀，格林斯潘任期内的“大缓和”时期，以及1945年后发生的其它一些变化。危机如何形成，以及导致08~009年经济危机的部分原因。 第三讲中，近期发生的事件，此轮金融危机最严重的阶段，危机发生的原因和后果，还有美联储褐其他政策制定者对危机的应对等。 第四讲中，危机的后果，危机后的经济衰退和美联储的应对措施（包括货币政策），以及金融监管方面的变革。此外，还会对金融危机如何改变央行的运作方式，以及美联储未来会如何运作，进行一些前瞻性的讨论。 央行是什么中央银行的职能，第一个是维持宏观经济稳定，即追求经济稳定增长，避免大幅度波动（如衰退等），并维持低通胀，经济稳定只能。另一个职能，也是这一系列讲座重点探讨的一个功能，就是金融稳定职能，中央银行要尽可能保证金融系统的正常运作，尤其要尽可能防止金融恐慌，避免发生金融危机。 稳定经济方面的工具主要是货币政策：公开市场买卖证券来降低或提高短期利率，调整隔夜拆借利率。 应对金融恐慌的工具主要是流动性供给：短期信贷平息市场情绪，维持金融机构稳定性，“最后贷款人”工具。 第三个工具是金融监管：评估，非中央银行独有。系列讲座不予以详谈。 什么是金融恐慌 P007 “总体来说，金融恐慌是由大家对金融机构失去信心而引起的。” P009 “如果金融机构持有期限较长的非流动性资产——非流动性意味着出售这些资产（如贷款）需要花费相当多的时间和精力，而支持这些资产的资金（如发放贷款的资金）却主要来自资产负债表另一侧的短期负债（如储蓄），那么金融恐慌随时都有可能发生。” 关于央行职能和相应政策，白芝浩。 P010 “在恐慌时期，中央银行应大量放款，只要找上门来的人有抵押物，就可以放宽给他，中央银行需要持有安全的抵押物，以确保能收回贷款，因此这些抵押必须是优质安全的，否则贷款时就必须带着计算。当然中央银行还应征收惩罚税率，这样人们才不会利用这种恐慌局势来占便宜。人们愿意支付较高水平的利率，这表明他们确实急需现金。” 金本位的利与弊南北战争结束到20世纪30年代，美国实行的一直是金本位制。 P013 “真正的金本位制会创造出一个自我管理的货币体系，而这样的货币体系至少能部分替代央行的职能。” P013 “不幸的是，金本位制还远非完善的货币体系。比如，金本位制造成了极大的资源浪费，从一处地下（开采处）转移到另一处地下（美联储），除此以外，实际表明金本位制还会导致许多更严重的金融及经济问题。” 金本位带来的还有：央行货币政策工具受到限制，国家间固定汇率体系，投机冲击。 美联储的起源 P017 “1913年，在所有研究全部完成以后，国会终于通过了《联邦储备法案》，奠定了美联储成立的基础，威尔逊总统把签署《联邦储备法案》看作自己执政期间最重要的国内政治成就。” 之前有过两次尝试，但是由于以商业街为代表的普通民众和以华尔街为代表的资本家之间存在重大分歧，即美联储是否能代表整个国家的利益，前两次尝试均以失败告终。 威尔逊总统通过在各城市分散建立12个联邦储备银行，而非在华盛顿建立一家中央银行，解决了两大群体的主要纠纷。12个联邦储备区，其中每一个区都有一家联邦储备银行。华盛顿的联邦储备委员会监管着整个系统。 P019 “当美联储制定货币政策时，它会考虑整个国家所有联邦储备银行的意见，再在国家层面上制定相关政策。” 美联储的第一次大挑战面对“大萧条”，美联储在这个时期做了什么呢？不幸的是，当首次面临此类重大挑战时，美联储无论是在货币政策还是在金融稳定方面都表现得不尽如人意。原因有很多，防止股市投机，信奉清算主义，维护金本位。 最后贷款人方面，也对银行业挤兑现象反映不足，致使大量银行破产，这种反应迟钝很大程度上还是因为对清算注意的认同。 P027 “尽管罗斯福采取的许多措施并没有奏效，但在我看来，他有两项工作确实有效解决了那些由美联储造成的问题。第一项就是于1934年建立了联邦存款保险公司。从那以后，即便银行倒闭，普通储户仍然可以拿回自己的钱，这样他们就没有动机再去银行挤兑了……罗斯福做的另一件事就是废除了金本位制。废除金本位制后，他允许放松货币政策，扩张货币供给，这就结束了通货紧缩，使经济在1933到1934年间经历了一个短期的有力反弹。” 罗斯福的上述两件措施，根本上解决美联储未尽责而造成或者加重的问题。 应对首次挑战时两大职能未尽其力，当后来的危机以及2008到2009年的金融危机到来时，我们应该牢牢记住这些曾经的教训。 对话 紧缩货币政策防止股票投机的探讨，如何正确应对泡沫？ P028 “我们当然知道资产价格泡沫十分危险，也想尽可能地化解这些泡沫。但若要通过金融监管途径来解决， 那就应该采用更具针对性的解决办法，而不仅仅是提高利率水平这种带有普遍杀伤力的方法。调整保证金要求的方法 就好得多，因为至少还可以根据业务的不同制定不同的标准。” 回归金本位制有可能吗？ 金本位制从长期看可以保持价格稳定，解决通胀问题，但是短期的金矿开采等各种事情都会导致波动，逐年看就不正确了。 P029 “我认为无论从实践还是政策角度来看，金本位制都不可行。在实践方面，一个很简单的事实就是，黄金总量不足以 支持整个国际金本位体系……如今，经济史学家们认为，工人运动在‘一战’后更加强大，使得政府 对失业开始有了更多的担忧，19世纪之前，人们甚至都不会去衡量失业率，但是‘一战’后，人们开始 更多地关注失业和经济周期。” 承诺金本位制就等于承诺无论失业情况多糟糕，央行都不会采取货币政策干预。不现实也是不可能的，而且民众会因 怀疑而拿现金换黄金，从而引起冲击。 关于“大萧条”期间的二次衰退，和我们该注意的问题？ 未被普遍认可的说法，“大萧条期间”有过两次经济衰退：分别是1929至1933年和1937年至1938年。第二次衰退是由于 政策转向过早，收紧财政和货币政策导致的，当然同期还有其他事情的影响。 “大萧条”期间为什么没有更多的全球性合作？ “一战”留下的不良情绪，德国正面临不得不支付战争赔款的处境，英法在战争债务上一直有政治，国际政治环境糟糕， 并没有理想的合作空间。 P034 “同时，对于实施固定汇率的国家来说，国家间的央行合作更为重要，20世纪20年代，各国因为金本位制形成了 固定汇率体系，这就意味着一国货币政策将影响到其他国家。这是个关于央行非常有必要进行国际合作的很好的例子，但 这种合作并没有出现。” 当然在今天的灵活汇率制度下，作者认为这种合作是非常必要的。 第二讲 “二战”后的美联储货币政策与通货膨胀 P038 “‘二战期间’，美联储与财政部‘合作’，利用自身管利率的职能，使利率保持在低位，从而帮助美国政府以较低成本为“二战”筹资。这就是美联储在二战中扮演的决策。” 如果一国利率长期维持在低水平，尤其是经济增长和复苏时仍是如此，就可能造成经济过热和通货膨胀。 1951年美国财政部与美联储签署《美联储——财政部协议》，这一协议的重大意义在于使美国政府第一次承认央行（美联储）的独立运行。 P039 “特别是，一个独立运行的央行可以不去理会短期的政治压力，例如为了选举而被迫刺激经济。这样一来，独立的央行就可以采取一些立足长远的举措并且能取得更好的效果。这方面的证据是相当充分的。所以，独立运行是世界各主要央行的典型特征，这意味着它们所做的决定不会受短期政治压力影响。” 20世纪60年代后期和70年代初期，美国财政政策总体上过于宽松。越南战争和其他政府计划增加了政府支出和赤字，使得美国经济雪上加霜。 P042 “我要讲的另一个问题是工资——物价管制政策。在20世纪70年代初期，当通货膨胀率上升到约5%时，理查德·尼克松总统引入了工资——物价管制政策，通过颁布一系列法律，禁止企业提高它们的产品价格。” 实际上即是通过行政手段，破坏了需求对价格的影响（微观），人为限制。 价格是经济的温控器，是经济赖以运行的机制。所以，管制物资和物价意味着整个经济体系存在短缺及其他各种问题。 P043 “除此之外，正如弗里德曼所说，这项政策就像通过破坏温控器来调节一个过热的炉子。事实上，最根本的问题是需求总量太大推高了价格，简单地通过一项法律来禁止涨价并没有解决货币政策过度宽松和需求过大的根本问题。” 沃尔克的铁腕政策虽然带来了短期（80年代初期）的副作用，即高失业率，但是把通货膨胀水平大幅度压低，经济增长恢复到正常水平，经济形势稳定，国民对政府更加信任，奠定了格林斯潘上任后“大缓和”时代的基础。 金融危机的前奏信贷门槛降低，抵押贷款质量降低，房价大幅上涨，住房抵押贷款清偿率上升。 房地产泡沫的破灭 P056 “房价崩盘造成了一系列严重的后果。其中之一就是，很多人因为他们的房子价格上涨、手上有很多股票而觉得自己非常富有，但突然发现房价和股票都缩水了，这意味着他们抵押贷款欠的钱已经大大超过房屋的价值。情况颠倒过来了，借款人的房产实际上已经是负责产。07年开始房屋抵押贷款的数字呈现负资产的状况变得越来越明显。” 导致房价暴涨暴跌并演变成严重的经济危机德原因，既存在于私人部门，也存在与公共部门。 私人部门： 借债过多，杠杆过度，人们过于自信，风险保护措施不够。 短期融资方式受到偏爱，但这些负债容易遭受挤兑。 投入到风险管理的信息技术和资源不足以帮助人们意识到风险存在和严重程度。 公共部门： 监管未能与时俱进，具体以美联储为关注点来说，一是在监管银行和银行持股公司时，对风险的计量做得不够。二是消费者保护上做得不够好，没有向住房抵押贷款人提供必要的保护。 缺少对整个系统的监管，多数只是关注经济系统的某个部分。 争议性话题——货币政策的作用： 通过低利率刺激房地产需求？说法的合理性待定，几个驳斥的理由： 其他国家/地区的房价降低与飙升和利率的高低并没有太大关系，对于拥有相同中央银行的德国和西班牙，德国危机期间，房价维持的很好，西班牙房价的激增却远超美国。 泡沫大小，并没有表现出与利率变化有较大的关系。 泡沫的时机，一些经济学家的研究认为，泡沫开始于利率调低之前，而且房价激增的一部分原因还来自于国外对于安全美元资产的需求。 对话 上一讲中提到“大萧条”时期政策收紧的太早，那么如何判恰当时机？是只有一个恰当的时机还是时机一直在变？ 预测时机很难，这也是美联储要拥有如此之多的经济学家和模型的原因。预测并不是非常准确，尤其是20世纪70年代，预期 不受任何限制，归功于沃尔克和格林斯潘，在通胀率保持较低水平的情况下，美联储有更大余地，即使一段时间内政策宽松， 也不会陷入工资和物价交替上涨的恶性循环，预期会变得明朗一些。 如果01年时您是美联储主席，您会让利率保持在那样低的水平上吗？您认为当时那样做是正确的吗？ P069 “总之，适当的运用货币政策是能实现宏观经济整体稳定的，但也不能忽视金融失衡。 我认为美联储本可以在监管上表现得更为激进，以确保发起的贷款具有更高的质量。” 低利率会导致私人投资者和银行面临更大的风险，您认为这会不会触发危机？ P071 “这个问题很好。我认为低利率对投资风险加大有一定的影响，但是这有涉及经济平衡的问题，在经济衰退阶段，总的来说， 大多数投资者变得非常谨慎，过去一段时间当然也是如此。人们想要让风险大小合理，不多不少，这需要金融监管 发挥作用，尤其是对大型机构（例如银行）直接监管以确保其风险管理得当。这又回到了‘用合适的政策工具来达成目的 ’上来。” 21世纪初，您在关注经济走势时认为在房价泡沫积累之后会发生什么？您是否认为这将最终导致一次经济衰退。 曾在白宫任经济顾问委员会主席时，分析了房价下跌的后果，当时的结论：虽然会导致衰退，但没有预料到 会对金融体系的稳定性产生如此深远的影响。 主要原因还是在于房价下跌于01年股票市场下跌表现得并不一致，房价下跌影响抵押贷款彻底暴露出金融体系 的一些漏洞，以影响住房抵押贷款的方式破坏了金融体系的稳健性，造成恐慌，而恐慌情绪又会加剧金融体系的不稳定性。 所以整个事件链条至关重要，并不仅仅时房价下跌，而是整个链条。 体系的崩塌，而非单一泡沫的破裂。 第三讲 美联储应对金融危机的政策应对金融体系的漏洞 政府支持型企业——房利美和房地美的漏洞。自身资本充足率不够，持有缺乏担保或者不受保护的住房抵押贷款。 金融衍生品的泛滥一些奇特的住房抵押贷款，通常是为哪些信用水平较差的人提供的，共同特征就是建立在房价保持上升态势之上。例如： 只付利息的浮动利率住房抵押贷款； 含权浮动利率住房抵押贷款（允许借款人改变其每期的还款额）； 超长期的住房抵押贷款（贷款期限超30年） 负摊销浮动利率住房抵押贷款（首付甚至可以低于当期利息）； 无信用证明的住房抵押贷款。 应对危机的举措08年经济危机后，七国集团例行峰会在华盛顿举行，这次会议没有按照以往的惯例来进行，与会人员一直在讨论该如何应对金融危机。 这次会议拟定了一份原则声明，根据这些原则，各国将会共同采取措施来避免那些具有系统重要性的金融机构破产。 P095 “根据‘白芝浩原则’，缓解2金融恐慌的最佳方式就是为那些缺乏资金的机构提供流动性。但是，美联储发放的所有贷款都是需要抵押担保的，不能拿纳税人的钱当儿戏。最后，资金不仅流向了银行部门，而且更为广泛地流向了整个金融体系。这些政策和措施的目的是增加金融体系的稳定性，使信用再次流动起来。需要强调的是，中央银行作为最后贷款人的这一职能已存在了数百年，只是与传统的银行环境相比，它现在面临的体制环境发生了变化。” 金融危机期间，从最后贷款人理论的视角来看，尽管金融产品公司令美国国际集团严重亏损，但作为世界上最大的保险集团，后者还拥有大量的优质资产。因此，它可以通过将其优质资产抵押给美联储而获得贷款，以补充流动性，维持日常运营。 以优质资产作为抵押，美联储发挥最后贷款人的功能，为其提供了850亿美元的贷款。 一些企业大以致于不能倒。 对话 奇异住房抵押贷款等衍生品数量持续增长，为什么会给信用状况很差的人放贷？如果预见了房价下跌，还会发放吗？ 对房价上涨的背景下，这种抵押贷款算不上劣质品，人们对于“房价会持续上涨”太过乐观。这是原因之一。 另一个原因是，对资产证券化产品的需求在此期间大幅增长。国际客户大量需求，“精明”的金融机构把 资产捆绑装饰打包后，创设AAA评级证券，出售。 P110 “金融市场上出现的种种倾向：金融机构对自身风险管理能力过度自信，人们坚信房价会迟旭上涨， 银行认为抵押贷款可以轻易转售出去，国际客户对‘安全性’资产存在大量需求。出于上述这些原因，如果 房价确实能持续上涨，那么提供次级住房抵押贷款就是一项利润可观的金融业务。只有当房价下跌时，这项 业务才可能会出现亏损。” “大而不倒”，那么对银行施以援助或任其倒闭的界线在哪里？美联储的这种决策是随机的，还是有一套明晰的行事规则？ P115 “这些机构是在全球金融危机背景下才呈现出‘大而不倒’特性的。我们做出‘大而不倒’的判断 是基于这些机构的规模、复杂性和相互关联性等因素。我们从来不认为这是件好事。金融改革的主要目标之一 就是破除‘大而不倒’的怪圈，因为它的存在对整个金融体系不利，对这些机构本身也不利。从许多方面来讲 ‘大而不倒’现象都是不公平的。但在当时的情形下，我们不得不做出如此选择，因为在众多可选方案中， 这是危害性最小的一个方案。” 对一些系统重要性金融机构逐步要求具备额外资本，以及对于影响金融体系稳定性，可能会产生一家系统重要性 银行的并购，也很可能不会被批准。 第四讲 危机的后遗症扑灭金融危机之火关于“大规模资产购买计划”，即所谓的“量化宽松”。 P128 “为什么美联储要购买这些资产呢？戍边插一句，这是米尔顿·弗里德曼和其他货币学派学者所提到的，他们的基本观点是，当你购买国债或者政府支持型企业证券并把它们写进资产负债表时，市场中可供应的同类证券就减少了。如果投资者想要持有这些证券，就必须接受较低的收益率。换句话说，如果市场中可供应的同类证券减少了，投资者就会原意为这些证券支付更高的价格，这与收益率是相反的。” P129 “因而，通过购买国债、写入资产负债表、减少这些国债的有效供给，我们有效地降低了长期国债和政府支持型企业证券的利率。而且，当投资者的投资组合中不再有国债和政府支持型企业证券时，他们就不得不转向其他类型的证券，比如公司债券，而这将提高其他证券的价格，降低其收益率。所以，这些行为的净效应是降低大范围内证券的收益率。通常，较低的利率对经济增长具有有益的刺激效应。” 实际上可以看作另一种货币政策：我们聚焦在长期利率，而不是短期利率上。但是，这里的基本逻辑是一致的，都是降低利率，刺激经济增长。 政策的指引者大规模资产计划并非真正意义上的花钱，算不上政府开支。资产，在未来的某个时间点会出售给市场，所以这些花销会赚回来（在资产负债表上存在一段时间）。事实上，不花钱，不增加赤字，这个项目还可以从持有的证券上获取利息，这些利润直接减少了财政赤字。 财政政策：联邦政府支出和税收的工具。 货币政策：美联储对利率的管控相关。 美联储已经开始为投资者和公众提供指引，告诉市场认为的利率走向，期望市场更好的理解美联储的计划，从而减少景荣市场的不确定性。 缓慢复苏现在看来，保持金融稳定与保持货币政策和经济稳定显得同等重要。诚然，美联储回到了最初的起点。要知道，美联储的创建就是为了试着减少金融恐慌的影响范围；金融稳定是建立美联储的初衷。因此，现在我们兜了一圈又回到了原地。 对话 对金融稳定的重要性理解不深的美国人来说，花钱救助银行的行为非常不受欢迎，您是否看到了美国公众和华尔街在对问题的认识上也无法达成一致？ 美联储正在通过更多的推官活动，比如新闻发布会以及其他途径，试图解释其所作所为。让外界能更好的 理解美联储的政策用意，这个任务是必要而且艰巨的。 对于逐步退出大规模则产购买计划，如何确保投资者未来原意重新买入这些资产？ 还没有理解，待后续填坑。 您在讲座中提到了在“大萧条”以及日本通货紧缩的危害，以及将目标通货膨胀率设定在零以上的论据之一就是给通货紧缩的可能性提供缓冲。您认为2%是防止通货紧缩的一个足够缓冲吗？您是否考虑过更高的通胀目标 P154 “这个问题太棒了！对此已有很多学术研究，似乎国际共识是2%。几乎所有设定了通胀目标的 中央银行不是将之设定为2%，就是1%~3%或类似水平。而且这里有个权衡的问题。原因是，一方面正如你所言， 是为了避免或者减少通货紧缩的风险而将之设定为大于零。然而另一方面，如果通货膨胀率太高，市场 就会出问题，经济体的效率会下降。总之，权衡之处在于合适的通货膨胀水平既给了你对抗通货紧缩的合理 缓冲，又不至于太高而导致市场运转不灵。因此如前所述，国际共识是2%左右，这也是长期以来美联储的 非正式目标。这就是我们所公布的目标，在可见的未来我们也计划保持现状。但显然研究者们仍然会 探究这个议题，试图准确定位最优的平衡点。”]]></content>
      <categories>
        <category>阅读</category>
      </categories>
      <tags>
        <tag>阅读</tag>
        <tag>演讲</tag>
        <tag>本·伯南克</tag>
        <tag>金融的本质</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[金融学辅修——微观经济学笔记（二）]]></title>
    <url>%2Fpost%2F92687617.html</url>
    <content type="text"><![CDATA[第二章 需求、价格与供求关系需求曲线 需求 Demand：在一定时期内，各种可能的价格水平，人们愿意并且能够购买的商品量。 需求表，函数关系，来表示价格与需求量的关系 需求曲线 绘制：横轴需求量，纵轴价格 一条向右下方的曲线。 需求分类 个人需求曲线与市场需求曲线：市场需求曲线由个人叠加，个人的较为陡直，市场的较平坦（对价格变化更加敏感） 需求定理 需求需求的因素 商品本身的价格 相关商品的价格 消费者的收入及社会分配的公平程度 消费者爱好（嗜好） 消费者对未来的预期 需求定理的特例 吉芬物品 Giffen’s Goods：需求量于价格成同向变动的特殊商品。 饥荒时期的土豆 炫耀性物品 Consipicuous Goods： 特例总结 曲线上端回归：稀有物品（古书，名画），预期紧俏的商品。 曲线下端回归：吉芬物品，吃紧时，随价格上升需求量增加。 S曲线：原本不值钱物品值钱了，原本不值钱的值钱了。 横线，价格一定，需求无限大： 竖线，需求一定，价格无限：军需物品。 供给曲线 供给 ：在一定时间内各种可能的价格原意而且能够提供出售的该种商品的数量。 需求曲线 绘制：横轴供给量，纵轴价格。 一条向右上方的曲线 单个厂商的供给曲线对比市场供给曲线：市场供给曲线更加平滑（纵轴价格不变，横轴供给量叠加）供给定理 影响供给的因素 厂商的目标 厂商对未来的预期 商品本身的价格 相关商品的价格（替代品，互补品？） 生产要素的价格（商品本身价格不变，成本上升会使利润减小，供给量下降） 生产技术的变动（一般情况下，生产技术水平的提高可以提高劳动生产率，从而降低成本，增大产量） 需求函数与供给函数数学表达 D=f(a1,b1,c1,d1...n1) a1,b1,c1,d1...n1代表影响需求的因素 理想情况 Qd=f(P) 关于价格的一元函数 S=f(a2,b2,c2,d2...n2) a2,b2,c2,d2...n2代表影响供给的因素 理想情况 Qs=f(P) 关于价格的一元函数 价格的变化体现在沿曲线的滑动，除商品自身价格以外的这些其他因素变化所导致的市场需求（供给）数量的变化通常称为需求（供给）的变动。几何图形中，表示为曲线的平移 消费者剩余和生产者剩余？？ 均衡价格供给曲线和需求曲线的交点，此时达到市场出清的状态。 供求定理：在其他条件不变的情况下，需求变动分别引起均衡价格和均衡数量的同方向的变动，供给变动引起均衡价格的反方向的变动，引起均衡数量的同方向的变动。]]></content>
      <categories>
        <category>金融</category>
        <category>微观经济学</category>
      </categories>
      <tags>
        <tag>课堂笔记</tag>
        <tag>辅修</tag>
        <tag>微观经济学</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[【UVA-679】解题报告（二叉树）]]></title>
    <url>%2Fpost%2Fe6364ca4.html</url>
    <content type="text"><![CDATA[原始题目 题目大意一颗完全二叉树（FBT）初始所有结点标记为false，根结点标号1，对于一个小球从根结点释放，遇到false标记向左下，true标记向右下，直至到达叶子结点。每次经过标记后标记翻转。 给出完全二叉树（FBT）的深度$D$，和小球的次序$I$，求其最终下落的叶子节点标号。 解题思路 考虑根节点，发现奇数次序小球向左下，偶数小球向右。 同理，若为$I$奇数，则其是到达左子树的第$ \frac {I+1}{2}$个小球，序号为$ 2 \times index $。 若位偶数，则其是到达右子树的第$ \frac {I}{2} $个小球，序号为 $ 2 \times index + 1 $。 递推n-1次解题代码12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849#include &lt;cstdio&gt;#include &lt;iostream&gt;#include &lt;iomanip&gt;#include &lt;vector&gt;#include &lt;string&gt;#include &lt;cstring&gt;#define rep(i,a,n) for(int i=a;i&lt;n;++i)#define per(i,a,n) for(int i=n-1;i&gt;=a;--i)#define clint(x,a) memset(x,a,sizeof(int)*n)#define clll(x,a) memset(x,a,sizeof(ll)*n)#define pb push_back#define np next_permutation#define mp make_pair#define fi first#define se second#define INF 0x3f3f3f3f#define EPS 1e-8#define PI acos(-1.0)using namespace std;const int maxn=1e5+5;const int maxm=1e5+5;const int maxl=26;typedef long long ll;typedef unsigned long long ull;typedef vector&lt;int&gt; vi;typedef pair&lt;int,int&gt; pii;typedef pair&lt;string,string&gt; pss;ll t,d,ii;int main()&#123; ios::sync_with_stdio(false); cin&gt;&gt;t; rep(tt,1,t+1)&#123; cin&gt;&gt;d&gt;&gt;ii; ll ans=1; for(int i=1;i&lt;d;i++)&#123; if(ii&amp;1)&#123; ans*=2; ii=(ii+1)/2; &#125; else&#123; ans=ans*2+1; ii=ii/2; &#125; &#125; cout&lt;&lt;ans&lt;&lt;endl; &#125; cin&gt;&gt;t;&#125; 收获与反思 注意奇偶性规律]]></content>
      <categories>
        <category>编程</category>
        <category>ACM</category>
      </categories>
      <tags>
        <tag>ACM</tag>
        <tag>算法</tag>
        <tag>数据结构</tag>
        <tag>2018秋季训练</tag>
        <tag>UVA</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[【UVA-12657】解题报告（双端链表）]]></title>
    <url>%2Fpost%2F6c71e418.html</url>
    <content type="text"><![CDATA[原始题目 题目大意有$n$个箱子，初始标号从左到右由$1$到$n$，有以下四种操作 把X移动到Y左边 把X移动到Y右边 交换X和Y的位置 全体翻转颠倒 其中1，2若已经符合状态则不操作 给出$n$和所有的操作，输出从左到右奇数位的和。 解题思路 数组形式双端链表 $left[i],right[i]$，模拟实现 简化实现：3不受4影响，4的翻转可以记录状态，且翻转状态下2-&gt;1，1-&gt;2。 交换需要分类，相邻时特判 解题代码123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113#include &lt;cstdio&gt;#include &lt;iostream&gt;#include &lt;iomanip&gt;#include &lt;vector&gt;#include &lt;string&gt;#include &lt;cstring&gt;#define rep(i,a,n) for(int i=a;i&lt;n;++i)#define per(i,a,n) for(int i=n-1;i&gt;=a;--i)#define clint(x,a) memset(x,a,sizeof(int)*n)#define clll(x,a) memset(x,a,sizeof(ll)*n)#define pb push_back#define np next_permutation#define mp make_pair#define fi first#define se second#define INF 0x3f3f3f3f#define EPS 1e-8#define PI acos(-1.0)using namespace std;const int maxn=1e5+5;const int maxm=1e5+5;const int maxl=26;typedef long long ll;typedef unsigned long long ull;typedef vector&lt;int&gt; vi;typedef pair&lt;int,int&gt; pii;typedef pair&lt;string,string&gt; pss;int a[maxn],lleft[maxn],rright[maxn];int n,m;void init()&#123; rep(i,1,n+1)&#123; lleft[i]=i-1; rright[i]=(i+1); &#125; rright[0]=1; lleft[n+1]=n;&#125;void link(int l,int r)&#123; rright[l]=r;lleft[r]=l;&#125;int main()&#123; ios::sync_with_stdio(false); int kase=0; while(cin&gt;&gt;n&gt;&gt;m)&#123; init(); int op,aa,bb,status=0; rep(i,0,m)&#123; cin&gt;&gt;op; if(op==4)&#123; status=!status; &#125; else&#123; cin&gt;&gt;aa&gt;&gt;bb; if(status &amp;&amp; op!=3) op=3-op; //改变操作 if(op==3 &amp;&amp; rright[bb]==aa) swap(aa,bb); int laa=lleft[aa],raa=rright[aa],lbb=lleft[bb],rbb=rright[bb]; if(op==1)&#123; if(aa==lbb) continue; else &#123; link(laa,raa); link(lbb,aa); link(aa,bb); &#125; &#125; else if(op==2)&#123; if(aa==rbb) continue; else &#123; link(laa,raa); link(bb,aa); link(aa,rbb); &#125; &#125; else if(op==3)&#123; if(raa==bb)&#123; link(laa,bb); link(bb,aa); link(aa,rbb); &#125; else&#123; link(laa,bb); link(bb,raa); link(lbb,aa); link(aa,rbb); &#125; &#125; &#125; &#125; ll sum=0; int b; if(status) b=n+1; else b=0; for(int i=1;i&lt;=n;++i)&#123; if(status)&#123; b=lleft[b]; &#125; else b=rright[b]; if(i&amp;1) sum+=b; &#125; cout&lt;&lt;"Case "&lt;&lt;++kase&lt;&lt;": "&lt;&lt;sum&lt;&lt;endl;// int c=0;// for(int i=1;i&lt;=n;++i)&#123;// c=rright[c];// cout&lt;&lt;c&lt;&lt;" ";// &#125;// cout&lt;&lt;endl; &#125;&#125; 收获与反思 数组形式双端链表$left[i],right[i]$，分别表示前驱结点和后继结点的指针。 //link操作，将两结点连接在一起。 void link(int l,int r){ rright[l]=r;lleft[r]=l; } 对于1，2操作，需要考虑连接顺序，记录原始的lx，ly，rx，ry，然后从左到右一一link就好。 注意记录原始的lx，ly，rx，ry，后面会改变]]></content>
      <categories>
        <category>编程</category>
        <category>ACM</category>
      </categories>
      <tags>
        <tag>ACM</tag>
        <tag>算法</tag>
        <tag>Imitation</tag>
        <tag>2018秋季训练</tag>
        <tag>UVA</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[【UVA-11988】解题报告（链表）]]></title>
    <url>%2Fpost%2F75f986a1.html</url>
    <content type="text"><![CDATA[原始题目 题目大意给出一段输入，‘[’表示“Home”键，即输入跳转到开头，‘]’表示“End”键，即输入跳至结尾。输出最终实际文字。 解题思路数组形式链表模拟。加空开头和尾。 解题代码12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849#include &lt;cstdio&gt;#include &lt;bits/stdc++.h&gt;#define rep(i,a,n) for(int i=a;i&lt;n;++i)#define per(i,a,n) for(int i=n-1;i&gt;=a;--i)#define clint(x,a) memset(x,a,sizeof(int)*n)#define clll(x,a) memset(x,a,sizeof(ll)*n)#define pb push_back#define np next_permutation#define mp make_pair#define fi first#define se second#define INF 0x3f3f3f3f#define EPS 1e-8#define PI acos(-1.0)using namespace std;const int maxn=1e5+5;const int maxm=1e5+5;const int maxl=26;char ss[maxn];int nextt[maxn];int main()&#123; ios::sync_with_stdio(false); while(cin&gt;&gt;ss+1)&#123; int last=0,cur=0; memset(nextt,0,sizeof(nextt)); int len=strlen(ss+1); rep(i,1,len+1)&#123; if(ss[i]=='[')&#123; cur=0; &#125; else if(ss[i]==']') &#123; cur=last; &#125; else &#123; nextt[i]=nextt[cur]; nextt[cur]=i; if(cur==last) last=i; cur=i; &#125; &#125; for(int i=nextt[0];i!=0;i=nextt[i])&#123; cout&lt;&lt;ss[i]; &#125; cout&lt;&lt;endl; &#125;&#125; 收获与反思 数组形式链表，数组标号0作为空头结点，next[0]作为头节点的指针。 添加结点的操作为 next[i]=next[cur] //加入结点的指针与前一结点的指针相同 next[cur]=i; //前一结点指针指向新结点 //由于本题还需要记录尾结点的序号所以有 //if(cur==last) last=i; cur=i; //指针移向当前结点]]></content>
      <categories>
        <category>编程</category>
        <category>ACM</category>
      </categories>
      <tags>
        <tag>ACM</tag>
        <tag>算法</tag>
        <tag>Imitation</tag>
        <tag>2018秋季训练</tag>
        <tag>UVA</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[【UVA-442】解题报告（STL，栈）]]></title>
    <url>%2Fpost%2Fca14c5df.html</url>
    <content type="text"><![CDATA[原始题目 题目大意给出$n$个矩阵的行数和列数（矩阵名为A到Z），再给出一些表达式，根据表达式的运算规则计算是否合法，若合法计算出乘法次数。 解题思路简单的表达式解析可以通过栈实现，输入右括号时计算，输入字母时压入栈。 解题代码12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364656667686970717273#include &lt;cstdio&gt;#include &lt;bits/stdc++.h&gt;#define rep(i,a,n) for(int i=a;i&lt;n;++i)#define per(i,a,n) for(int i=n-1;i&gt;=a;--i)#define clint(x,a) memset(x,a,sizeof(int)*n)#define clll(x,a) memset(x,a,sizeof(ll)*n)#define pb push_back#define np next_permutation#define mp make_pair#define fi first#define se second#define INF 0x3f3f3f3f#define EPS 1e-8#define PI acos(-1.0)using namespace std;const int maxn=1e5+5;const int maxm=1e5+5;const int maxl=26;typedef long long ll;typedef unsigned long long ull;typedef vector&lt;int&gt; vi;typedef pair&lt;int,int&gt; pii;typedef pair&lt;string,string&gt; pss;int t,n;struct Matrix&#123; int a,b; Matrix(int a=0,int b=0):a(a),b(b)&#123;&#125;&#125;m[26];int main()&#123; ios::sync_with_stdio(false); cin&gt;&gt;n; rep(i,0,n)&#123; char c; cin&gt;&gt;c; cin&gt;&gt;m[c-'A'].a&gt;&gt;m[c-'A'].b; &#125; string str; while(cin&gt;&gt;str)&#123; stack &lt;Matrix&gt; s; bool flag=0; int ans=0; int len=str.length(); rep(i,0,len)&#123; if(isalpha(str[i]))&#123; if(flag) break; s.push(m[str[i]-'A']); &#125; else if(str[i]==')')&#123; Matrix m1,m2; if(flag) break; m1=s.top();s.pop(); m2=s.top();s.pop(); if(m1.a!=m2.b)&#123; flag=1; break; &#125; else&#123; ans+=m2.a*m1.b*m1.a; s.push(Matrix(m2.a,m1.b)); &#125; &#125; &#125; if(flag) cout&lt;&lt;"error"&lt;&lt;endl; else cout&lt;&lt;ans&lt;&lt;endl; &#125;&#125; 收获与反思注意读题，表达式的范式。]]></content>
      <categories>
        <category>编程</category>
        <category>ACM</category>
      </categories>
      <tags>
        <tag>ACM</tag>
        <tag>算法</tag>
        <tag>2018秋季训练</tag>
        <tag>STL</tag>
        <tag>UVA</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[【UVA-10474】解题报告（STL，排序，二分）]]></title>
    <url>%2Fpost%2Fbcb02c2b.html</url>
    <content type="text"><![CDATA[原始题目 题目大意有许多$N$个标有不同数字的大理石，每次按1，2，3这样从小到大的次序数。有$Q$个询问，对于每个询问，是否能数到指定数，若能输出数的次数，若不能输出not found. 解题思路排序以后利用二分查找，输出位置+1即可。 解题代码12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455#include &lt;bits/stdc++.h&gt;#define rep(i,a,n) for(int i=a;i&lt;n;++i)#define per(i,a,n) for(int i=n-1;i&gt;=a;--i)#define fi first#define se second#define mp make_pair#define pb push_back#define np next_permutation#define cl(x,a,n) memset(x,a,sizeof(int)*n)using namespace std;typedef long long ll;typedef unsigned long long ull;typedef long double ld;typedef vector&lt;int&gt; vi;typedef pair&lt;int,int&gt; pii;typedef pair&lt;string,string&gt; pss;const int maxn=1e5+5;int n,q;int cnt,a[maxn];vector&lt; pii &gt; v;bool cmp( pii a, pii b)&#123; if(a.se!=b.se) return a.se&lt;b.se; else return a.fi&lt;b.fi;&#125;int main()&#123; ios::sync_with_stdio(false); while(cin&gt;&gt;n&gt;&gt;q &amp;&amp; n+q)&#123; rep(i,0,n)&#123; cin&gt;&gt;a[i]; &#125; cout&lt;&lt;"CASE# "&lt;&lt;++cnt&lt;&lt;":"&lt;&lt;endl; sort(a,a+n); rep(i,0,q)&#123; int x; cin&gt;&gt;x; int index=lower_bound(a,a+n,x)-a; if(a[index]==x) cout&lt;&lt;x&lt;&lt;" found at "&lt;&lt;index+1&lt;&lt;endl; else cout&lt;&lt;x&lt;&lt;" not found"&lt;&lt;endl; &#125; &#125;&#125; 收获与反思排序，二分]]></content>
      <categories>
        <category>编程</category>
        <category>ACM</category>
      </categories>
      <tags>
        <tag>ACM</tag>
        <tag>算法</tag>
        <tag>2018秋季训练</tag>
        <tag>STL</tag>
        <tag>UVA</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[金融学辅修——金融学笔记（四）]]></title>
    <url>%2Fpost%2Fe8005312.html</url>
    <content type="text"><![CDATA[课前同学分享 金融衍生品 期权 八大特点 零和博弈：金融衍生品交易净损益之和等于零跨期性：未来交易联动性高风险性高杠杆性交易的保值性 金融衍生品在我国的发展情况 过去——1992年——国债期货 1994年——1998年——金融衍生品市场 发展现况市场经济的推进 对外开放和国际经济接轨 金融衍生品的功能1.风险转移2.价格发现：可以预测未来现货价格的变化3.增强流动4. 存在的问题]]></content>
      <categories>
        <category>金融</category>
        <category>金融学</category>
      </categories>
      <tags>
        <tag>课堂笔记</tag>
        <tag>辅修</tag>
        <tag>金融学</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[金融学辅修——微观经济学笔记（一）]]></title>
    <url>%2Fpost%2Fa27e9acf.html</url>
    <content type="text"><![CDATA[第一章 导论第一节 什么是西方经济学第四节 西方经济学的主要分析方法任何一门学科都有一定的研究和分析方法。 边际分析法边际分析法的特点 其一，边际分析是一种数量分析，尤其是变量分析，运用这一方法研究数量的变动和相互关系。 边际分析法研究微增量的变化及变量之间的关系，可使经济理论精细化（差分，微分）。 边际分析法的意义 经济学研究重心发生改变，由社会性、历史性的政治学经济学转为纯粹研究如何抉择稀缺资源分配给无限而又有竞争性的用途上，以有效利用。 开创了经济学“数量化”的时代。 导致了微观经济学的形成，“个量分析”的微观经济学的诞生。 奠定了最优化理论的基础。 使实证经济学得到发展。 经济模型与抽象分析经济模型： 实证分析和规范分析 规范经济学 Normative economics 以一定的主观价值判断为基础，提出某些标准作为分析处理经济问题的根据，作为建立经济理论的前提和制定经济政策的依据，并研究如何才能符合这些标准。回答“应该是什么”的问题。（标准，应有的样子） 实证经济学 Positive economics 对经济现象进行客观描述，企图超脱或排斥一切主观价值判断。回答“是什么”的问题。 均衡分析均衡即平衡，本是物理学的一个概念 博弈论：纳什均衡 经济学中的均衡状态：各个经济决策者（消费者、生产者等等）所做出的决策正好相容，并且在外界条件不变的情况下，每个人都不愿意再调整自己的决策，从而不再改变其经济行为。（环境不改变，博弈均衡） 均衡分析就是假定经济变量达到均衡状态时所出现的情况以及实现均衡的条件。局部/一般均衡分析。 局部均衡分析：假定其他条件不变，只考虑本身的各相关变量的作用（部分忽略，考虑局部），研究该种变量如何实现均衡。局限在一个局部范围。 一般均衡分析：考虑在各种因素和变量的作用下，如何实现均衡。 静态分析、比较静态分析与动态分析 静态分析：分析均衡状态和所需要的条件，不考虑实现的过程。 比较静态分析：分析在已知条件发生后，均衡状态如何变化。（方向） 动态分析：论述均衡调整变化的实际过程，通常把经济运动过程划分为连续的分析期间，考察有关经济变量在连续时间段的变化。（加时间变量的分析） 外生变量与内生变量 内生变量（Endogenous Variables）经济模型内部结构决定的变量 外生变量（Exogenous Variable）经济模型外部的因素决定的变量 存量（Stock）一定时间存在的量 流量（Flow）一定时间内变化的量 第五节 为关于宏观经济学的基本框架微观经济学微观经济学（Micro-Economics）：研究市场经济中单个经济主体——居民与企业的经济行为以及相应的经济变量的决定。 应有内容：个量分析/单个经济单位/目标最大化/资源配置/价格理论为核心 微观经济学的假设：理性经济人假设/充分就业假设/市场出清假设/完全信息假设 微观经济学的基本内容： 价格的决定：需求和供给决定价格 需求分析：消费者行为理论 攻击分析： 生产与成本理论 市场理论：市场类型对价格和产量决定的影响 要素价格的决定：分配理论 信息经济学 一般均衡与福利经济学 市场失灵与政府失灵 理性人假设基本动力：利益最大化。基本准则：既定目标的最优化。（非理性因素：目标队员，限制性，习惯，社会政治道德等方面呢约束） 第六节 学习经济学容易犯的错误基本研究方法：给定假设，简化关系，放松假设，逼近现实 容易犯的错误：经验主义，合成谬误]]></content>
      <categories>
        <category>金融</category>
        <category>微观经济学</category>
      </categories>
      <tags>
        <tag>课堂笔记</tag>
        <tag>辅修</tag>
        <tag>微观经济学</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[【HDU-6222】解题报告（大数，打表）]]></title>
    <url>%2Fpost%2Fd120bd8e.html</url>
    <content type="text"><![CDATA[原始题目Heron and His Triangle Time Limit: 2000/1000 MS (Java/Others) Memory Limit: 262144/262144 K (Java/Others) Total Submission(s): 2123 Accepted Submission(s): 892 Problem DescriptionA triangle is a Heron’s triangle if it satisfies that the side lengths of it are consecutive integers $ t-1, t, t+1 $ and that its area is an integer. Now, for given n you need to find a Heron’s triangle associated with the smallest $t$ biggerthan or equal to $n$. InputThe input contains multiple test cases. The first line of a multiple input is an integer $T (1 ≤ T ≤ 30000)$ followedby T lines. Each line contains an integer $N (1 ≤ N ≤ {10}^{30}) $. OutputFor each test case, output the smallest $t$ in a line. If the Heron’s triangle required does not exist, output $-1$. Sample Input4 1 2 3 4 Sample Output4 4 4 4 Source2017ACM/ICPC亚洲区沈阳站-重现赛（感谢东北大学） Recommendjiangzijing2015 题目大意输入$n$，求大于等于$n$的最小$t$满足由$t-1,t,t+1$构成的三角形面积为整数。 解题思路打表发现$t$构成数列 t[i]=4 \times t[i-1] -t[i-2]大数板子打表输出。 标程证明还没有想，待补充。 解题代码123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147148149150151152153154155156157158159160161162163164165166167168169170171172173174175176177178179180181182183184185186187188189190191192193194195196197198199200201202203204205206207208209210211212213214215216217218219220221222223224225226227228229230231232233234235236237238239240241242243244245246247248249250251252253254255256257258259260261262263264265266267268269270271272273274275276277278279280281282283284285286287288289290291292293294295296297298299300301302303304305306307308309310311312313314315316317318319320321322323324325326327328329330331332333334335336337338339340341342343344345346347348349350351352353354355356357358359360361362363364365366367368369370371372373374375376377378379380381382383384385386387388389390391392393394395396397398399400401402403404405406407408409410411412413414415416417418419420421422423424425426427428429430431432433434435436437438439440441442443444445446447448449450451452453454455456457458459460461462463464465466467468469470471472473474475476477478#include &lt;bits/stdc++.h&gt;#define rep(i,a,n) for(int i=a;i&lt;n;++i)#define per(i,a,n) for(int i=n-1;i&gt;=a;--i)#define fi first#define se secondusing namespace std;// base and base_digits must be consistentconstexpr int base = 1000000000;constexpr int base_digits = 9;struct bigint&#123; vector&lt;int&gt; z; int sign; bigint() : sign(1) &#123;&#125; bigint(long long v) &#123; *this = v; &#125; bigint&amp; operator=(long long v) &#123; sign = v &lt; 0 ? -1 : 1; v*=sign; z.clear(); for(; v &gt; 0; v = v / base) z.push_back((int)(v % base)); return *this; &#125; bigint(const string&amp; s) &#123; read(s); &#125; bigint&amp; operator+=(const bigint&amp; other) &#123; if (sign == other.sign) &#123; for (int i = 0, carry = 0; i &lt; other.z.size() || carry; ++i) &#123; if(i==z.size()) z.push_back(0); z[i] += carry + (i &lt; other.z.size() ? other.z[i] : 0); carry = z[i] &gt;= base; if(carry) z[i] -= base; &#125; &#125; else if (other != 0 /* prevent infinite loop */) &#123; *this -= -other; &#125; return *this; &#125; friend bigint operator+(bigint a, const bigint&amp; b) &#123; return a += b; &#125; bigint&amp; operator-=(const bigint&amp; other) &#123; if (sign == other.sign) &#123; if (sign == 1 &amp;&amp; *this &gt;= other || sign == -1 &amp;&amp; *this &lt;= other) &#123; for (int i = 0, carry = 0; i &lt; other.z.size() || carry; ++i) &#123; z[i] -= carry + (i &lt; other.z.size() ? other.z[i] : 0); carry = z[i] &lt; 0; if(carry) z[i] += base; &#125; trim(); &#125; else &#123; *this = other - *this; this-&gt;sign = -this-&gt;sign; &#125; &#125; else *this += -other; return *this; &#125; friend bigint operator - (bigint a,const bigint&amp; b) &#123; return a -= b; &#125; bigint&amp; operator*=(int v) &#123; if(v&lt;0) sign=-sign,v=-v; for(int i=0,carry=0;i&lt;z.size() || carry;++i) &#123; if(i==z.size()) z.push_back(0); long long cur = (long long)z[i] * v + carry; carry = (int)(cur / base); z[i] = (int)(cur % base); &#125; trim(); return *this; &#125; bigint operator*(int v) const &#123; return bigint(*this) *= v; &#125; friend pair&lt;bigint, bigint&gt; divmod(const bigint&amp; a1, const bigint&amp; b1) &#123; int norm = base / (b1.z.back() + 1); bigint a = a1.abs() * norm; bigint b = b1.abs() * norm; bigint q, r; q.z.resize(a.z.size()); for (int i = (int)a.z.size() - 1; i &gt;= 0; i--) &#123; r*=base; r+=a.z[i]; int s1 = b.z.size() &lt; r.z.size() ? r.z[b.z.size()] : 0; int s2 = b.z.size() - 1 &lt; r.z.size() ? r.z[b.z.size() - 1] : 0; int d = (int)(((long long)s1 * base + s2) / b.z.back()); r -= b * d; while(r &lt; 0) r+=b,--d; q.z[i] = d; &#125; q.sign = a1.sign * b1.sign; r.sign = a1.sign; q.trim(); r.trim(); return &#123;q, r / norm&#125;; &#125; friend bigint sqrt(const bigint&amp; a1) &#123; bigint a=a1; while(a.z.empty()||a.z.size()%2==1) a.z.push_back(0); int n = a.z.size(); int firstDigit = (int)::sqrt((double)a.z[n - 1] * base + a.z[n - 2]); int norm = base / (firstDigit + 1); a *= norm; a *= norm; while(a.z.empty()||a.z.size()%2==1) a.z.push_back(0); bigint r = (long long)a.z[n - 1] * base + a.z[n - 2]; firstDigit = (int)::sqrt((double)a.z[n - 1] * base + a.z[n - 2]); int q = firstDigit; bigint res; for (int j = n / 2 - 1; j &gt;= 0; j--) &#123; for(;;--q) &#123; bigint r1=(r-(res*2*base+q)*q)*base*base+(j&gt;0?(long long)a.z[2*j-1]*base+a.z[2*j-2]:0); if(r1&gt;=0) &#123; r=r1; break; &#125; &#125; res*=base;res+=q; if(j&gt;0) &#123; int d1 = res.z.size() + 2 &lt; r.z.size() ? r.z[res.z.size() + 2] : 0; int d2 = res.z.size() + 1 &lt; r.z.size() ? r.z[res.z.size() + 1] : 0; int d3 = res.z.size() &lt; r.z.size() ? r.z[res.z.size()]:0; q = (int)(((long long)d1*base*base+(long long)d2*base+d3)/(firstDigit*2)); &#125; &#125; res.trim(); return res / norm; &#125; bigint operator/(const bigint&amp; v) const &#123; return divmod(*this, v).first; &#125; bigint operator%(const bigint&amp; v) const &#123; return divmod(*this, v).second; &#125; bigint&amp; operator/=(int v) &#123; if(v&lt;0) sign=-sign,v=-v; for (int i = (int)z.size() - 1, rem = 0; i &gt;= 0; --i) &#123; long long cur = z[i] + rem * (long long)base; z[i] = (int)(cur / v); rem = (int)(cur % v); &#125; trim(); return *this; &#125; bigint operator/(int v) const &#123; return bigint(*this) /= v; &#125; int operator%(int v) const &#123; if(v&lt;0) v=-v; int m=0; for(int i=(int)z.size()-1;i&gt;=0;--i) m=(int)((z[i]+m*(long long)base)%v); return m * sign; &#125; bigint&amp; operator*=(const bigint&amp; v) &#123; *this = *this * v; return *this; &#125; bigint&amp; operator/=(const bigint&amp; v) &#123; *this = *this / v; return *this; &#125; bool operator&lt;(const bigint&amp; v) const &#123; if(sign!=v.sign) return sign &lt; v.sign; if(z.size()!=v.z.size()) return z.size()*sign&lt;v.z.size()*v.sign; for(int i = (int)z.size() - 1; i &gt;= 0; i--) if(z[i] != v.z[i]) return z[i] * sign &lt; v.z[i] * sign; return false; &#125; bool operator&gt;(const bigint&amp; v) const &#123; return v &lt; *this; &#125; bool operator&lt;=(const bigint&amp; v) const &#123; return !(v &lt; *this); &#125; bool operator&gt;=(const bigint&amp; v) const &#123; return !(*this &lt; v); &#125; bool operator==(const bigint&amp; v) const &#123; return !(*this &lt; v) &amp;&amp; !(v &lt; *this); &#125; bool operator!=(const bigint&amp; v) const &#123; return *this &lt; v || v &lt; *this; &#125; void trim() &#123; while(!z.empty() &amp;&amp; z.back() == 0) z.pop_back(); if(z.empty()) sign = 1; &#125; bool isZero() const &#123; return z.empty(); &#125; friend bigint operator-(bigint v) &#123; if(!v.z.empty()) v.sign = -v.sign; return v; &#125; bigint abs() const &#123; return sign == 1 ? *this : -*this; &#125; long long longValue() const &#123; long long res = 0; for(int i = (int)z.size() - 1; i &gt;= 0; i--) res = res * base + z[i]; return res * sign; &#125; friend bigint gcd(const bigint&amp; a, const bigint&amp; b) &#123; return b.isZero() ? a : gcd(b, a % b); &#125; friend bigint lcm(const bigint&amp; a, const bigint&amp; b) &#123; return a / gcd(a, b) * b; &#125; void read(const string&amp; s) &#123; sign = 1; z.clear(); int pos = 0; while(pos &lt; s.size() &amp;&amp; (s[pos] == '-' || s[pos] == '+')) &#123; if(s[pos] == '-') sign = -sign; ++pos; &#125; for(int i=(int)s.size()-1;i&gt;=pos;i-=base_digits) &#123; int x=0; for(int j=max(pos,i-base_digits+1);j&lt;=i;j++) x=x*10+s[j]-'0'; z.push_back(x); &#125; trim(); &#125; friend istream&amp; operator&gt;&gt;(istream&amp; stream, bigint&amp; v) &#123; string s; stream &gt;&gt; s; v.read(s); return stream; &#125; friend ostream&amp; operator&lt;&lt;(ostream&amp; stream, const bigint&amp; v) &#123; if(v.sign == -1) stream &lt;&lt; '-'; stream &lt;&lt; (v.z.empty() ? 0 : v.z.back()); for(int i = (int)v.z.size() - 2; i &gt;= 0; --i) stream &lt;&lt; setw(base_digits) &lt;&lt; setfill('0') &lt;&lt; v.z[i]; return stream; &#125; static vector&lt;int&gt; convert_base(const vector&lt;int&gt;&amp; a, int old_digits, int new_digits) &#123; vector&lt;long long&gt; p(max(old_digits, new_digits) + 1); p[0] = 1; for(int i=1;i&lt;p.size();i++) p[i]=p[i-1]*10; vector&lt;int&gt; res; long long cur = 0; int cur_digits = 0; for(int v : a) &#123; cur += v * p[cur_digits]; cur_digits += old_digits; while (cur_digits &gt;= new_digits) &#123; res.push_back(int(cur % p[new_digits])); cur /= p[new_digits]; cur_digits -= new_digits; &#125; &#125; res.push_back((int)cur); while(!res.empty() &amp;&amp; res.back()==0) res.pop_back(); return res; &#125; typedef vector&lt;long long&gt; vll; static vll karatsubaMultiply(const vll&amp; a, const vll&amp; b) &#123; int n=a.size(); vll res(n + n); if(n &lt;= 32) &#123; for (int i = 0; i &lt; n; i++) for (int j = 0; j &lt; n; j++) res[i + j] += a[i] * b[j]; return res; &#125; int k = n &gt;&gt; 1; vll a1(a.begin(), a.begin() + k); vll a2(a.begin() + k, a.end()); vll b1(b.begin(), b.begin() + k); vll b2(b.begin() + k, b.end()); vll a1b1 = karatsubaMultiply(a1, b1); vll a2b2 = karatsubaMultiply(a2, b2); for(int i=0;i&lt;k;i++) a2[i]+=a1[i]; for(int i=0;i&lt;k;i++) b2[i]+=b1[i]; vll r = karatsubaMultiply(a2, b2); for(int i=0;i&lt;a1b1.size();i++) r[i]-=a1b1[i]; for(int i=0;i&lt;a2b2.size();i++) r[i]-=a2b2[i]; for(int i=0;i&lt;r.size();i++) res[i+k]+=r[i]; for(int i=0;i&lt;a1b1.size();i++) res[i]+=a1b1[i]; for(int i = 0;i&lt;a2b2.size();i++) res[i+n]+=a2b2[i]; return res; &#125; bigint operator*(const bigint&amp; v) const &#123; vector&lt;int&gt; a6=convert_base(this-&gt;z,base_digits,6); vector&lt;int&gt; b6=convert_base(v.z,base_digits,6); vll a(a6.begin(),a6.end()); vll b(b6.begin(),b6.end()); while(a.size()&lt;b.size()) a.push_back(0); while(b.size()&lt;a.size()) b.push_back(0); while(a.size()&amp;(a.size()-1)) a.push_back(0),b.push_back(0); vll c=karatsubaMultiply(a, b); bigint res; res.sign = sign * v.sign; for (int i = 0, carry = 0; i &lt; c.size(); i++) &#123; long long cur = c[i] + carry; res.z.push_back((int)(cur % 1000000)); carry = (int)(cur / 1000000); &#125; res.z = convert_base(res.z, 6, base_digits); res.trim(); return res; &#125;&#125;;bigint qpow(bigint a,bigint b)&#123; bigint ans=1; while(b!=0)&#123; if(b%2)&#123; ans= ans*a; &#125; b/=2; a= a*a; &#125; return ans;&#125;struct Matrix&#123; bigint a[2][2]; Matrix() &#123; rep(i,0,2)&#123; rep(j,0,2)&#123; a[i][j]=0; &#125; &#125; &#125; Matrix operator * (const Matrix y) &#123; Matrix ans; for(int i = 0; i &lt; 2; i++) for(int j = 0; j &lt; 2; j++) for(int k = 0; k &lt; 2; k++) ans.a[i][j] = ans.a[i][j] + (a[i][k]*y.a[k][j]); return ans; &#125; Matrix operator = (const Matrix y) &#123; for(int i=0;i&lt;2;i++) for(int j=0;j&lt;2;j++) a[i][j]=y.a[i][j]; &#125; Matrix operator *= (const Matrix y) &#123; Matrix ans; for(int i=0;i&lt;2;i++) for(int j=0;j&lt;2;j++) for(int k=0;k&lt;2;k++) ans.a[i][j] = ans.a[i][j] + (a[i][k]*y.a[k][j]); for(int i=0;i&lt;2;i++) for(int j=0;j&lt;2;j++) a[i][j]=ans.a[i][j]; &#125;&#125;;Matrix qpow(bigint x)&#123; Matrix ans; ans.a[0][0]=ans.a[1][1]=1; //单位矩阵 Matrix mul; mul.a[0][0]=4; mul.a[0][1]=-1; mul.a[1][0]=1; mul.a[1][1]=0; while(x!=0) &#123; if(x%2!=0) ans = ans*mul; mul = mul* mul; x/=2; &#125; return ans;&#125;bigint ans[1005];void solve()&#123; ans[0]=(bigint)4; ans[1]=(bigint)14; ans[2]=(bigint)52; rep(i,2,200)&#123; ans[i]=(bigint)4*ans[i-1]-ans[i-2];// cout&lt;&lt;ans[i]&lt;&lt;endl; &#125;&#125;int main()&#123; solve(); int t;cin&gt;&gt;t; while(t--)&#123; bigint n; cin&gt;&gt;n; rep(i,0,200)&#123; if(ans[i]&gt;=n)&#123; cout&lt;&lt;ans[i]&lt;&lt;endl; break; &#125; &#125; &#125;&#125; 收获与反思证明待补充]]></content>
      <categories>
        <category>编程</category>
        <category>ACM</category>
      </categories>
      <tags>
        <tag>ACM</tag>
        <tag>算法</tag>
        <tag>2018秋季训练</tag>
        <tag>HDU</tag>
        <tag>大数</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[金融学辅修——金融学笔记（三）]]></title>
    <url>%2Fpost%2F5f2d4a77.html</url>
    <content type="text"><![CDATA[课前同学分享 庞氏骗局 新用户的资金补贴旧用户，没有新用户加入进来的时候，资金链断裂 江小白发展困境与银行的最后贷款人功能 白芝浩 资管行业三十年蝶变 资产管理：管理资产和风险 基金崛起：公募基金2000年以前以封闭式基金为主，01年-07年黄金发展期，迅速发展，08年-13年股票型和股票型发展势头迅猛。 信托行业转向主动管理。07年至今规范化。 定位与发展 基金：银行理财：信托： 第三章 信用与信用工具什么是信用，信用形式，信用工具，信用与经济（普惠金融）。 第一节 什么是信用信用的含义 Credit，就是相信，信托和声誉。 日常生活中的信用是诚实、守信。 经济学含义是借贷活动的总称，就是债。 指不同所有者之间以偿还本金和支付利息为条件的借贷行为。是市场经济运行规则、市场经济交易方式、一种经济关系。 “信用经济”： 信用与借贷信用与债权债务时同时发生的，时借贷活动的两个方面：在借贷活动中，当事人一方为债权人，他将商品或货币贷出，称为授信；另一方面为债务人，他接受债权人的商品或货币，称为受信；债务人遵守承诺按期偿还商品或货币并支付利息，称为守信。任何时期的债务总额等于信用总量。 社会信用体系：政府信用，企业信用，个人信用。 信用的特点 以所有权与使用权相分离的资金为信用的标的 以还本付息为条件 以相互信任为基础 以收益最大化为目标 借贷双方利益最大化 信用的构成要素 信用的主体：债权人（creditor）与债务人（debtor） 信用标的物：货币资金与实物资金 信用条件：期限与利息 信用工具：（金融工具：记载信用标的，保护债权人权利，具备法律效力的书面凭证） 以口头承诺，账面信用为依据。（没有工具化） 以正式的书面凭证为依据，如借贷契约。（没有流动化） 可在流通市场上转让的信用，如债券（流动化） 信用的基本功能与基本形式 基本功能 资金配置 信用创造 信息传播 宏观调控 信用形式 以期限为标准——长期信用与短期信用 以低于为标准——国内信用与国际信用 以信用主体为标准——商业信用/银行信用/消费信用/国家信用/合作信用/高利贷信用/国际信用等调控 关于高利贷信用，并非政治经济学里面贬义的意思。 官方界定上有正规、非正规、非法。高利贷信用处于非正规和非法的灰色地带。评价注意客观性。 一个企业可能取得的融资方式 企业通过签发商业票据赊账——商业信用 企业以土地等抵押给银行取得商业性贷款，或者政府取得政策性贷款——银行信用 捆包优质资产上市，以固定资产为抵押，企业债券——证券信用 股东同意，减少红利获得更多公积金——内源融资 其他国家发行外国，国际市场发行欧洲债券，背对背协议——国际融资 第二节 信用的形式商业信用 含义 工商企业之间相互提供的，与商品交易直接向联系的信用形式。 方式 赊销，赊购，分期付款。 银行信用 含义 银行信用是指各种金融机构，特别是银行，以存、放款等多种业务形式向工商企业和个人提供的货币形态 的信用，它是在商业信用基础上发展起来的一种更高层次的信用。 地位 克服了资金力量、资信程度、提供方向方面的局限性，能通过对商业票据贴现为商业信用的进一步发展提供了条件， 从而能使它成为整个经济社会信用体系中占据核心地位，成为一国信用关系中的主体。 主要作用 国家信用 国家信用 是国家（包括各级政府）作为债务人，以发行政府债券或借款的方式向国内外企事业单位、团体、居民个人等筹集资金的借贷行为。 基本方式 发行债券（国内债务和国际债务）借款 国债的主要作用 筹措战争费用（战争时期） 平衡财政赤字，缓解货币流通，保持物价稳定（赤字国债） 筹措国家建设资金，举借内债影响经济增长（建设国债） 偿还到期国债（借换国债） 财政支出=财政收入+]]></content>
      <categories>
        <category>金融</category>
        <category>金融学</category>
      </categories>
      <tags>
        <tag>课堂笔记</tag>
        <tag>辅修</tag>
        <tag>金融学</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[金融学辅修——金融学笔记（二）]]></title>
    <url>%2Fpost%2F1233e925.html</url>
    <content type="text"><![CDATA[课前同学分享 离岸人民币市场离岸市场：目标货币发行国境外的货币交易中心 课后补充，美元本位？马歇尔计划？欧洲美元市场。伦敦拆借市场-&gt;欧洲货币市场。 租房贷房东，中介，用户，传统三元模式随着互联网的发展，中介的传统职能被互联网有所替代。不过新的房东，用户二元模式，又存在一些问题。 新三元模式中介面临资金链紧张的问题，故金融机构逐渐引入。租房贷的实质：中介公司 解决方式： 加强监管：透明化和规范化 风险主要分为信用风险和流动风险，信用风险一方面涉及 第四节 货币制度我国的货币制度 我国的法定货币是人民币。 人民币是我国唯一合法流通货币。 人民币的发行实行高度集中统一于中国人民银行。 人民币的发行保证是国家拥有的商品物资，黄金外汇储备主要是作为国际支付的准备金。 纸币发行准备制度的方式： 以黄金或外汇储备准备的发行 无准备发行 第二钟以港币发行为例。香港地方三家银行汇丰， 央行可以通过行政命令，直接宣布汇率变化，来影响 金属本位金银复本位 平行本位：即金银币平等，同事都是本位币，都可以自由铸造和融化自由地输出入国境，金银币的交易比率由市场决定，国家没有法律规定。 问题：由于任一商品都拥有两个价格，比例随金银比价波动，造成价格混乱，给交易带来了很多麻烦。 双本位：格雷欣法则，劣币驱逐良币 劣币驱逐良币律Gresham’s Law：金银复本位制下，两种实际价值不同而含义相同的金属铸币流通时，实际价值高的会通过熔化， 储藏或者到国外而退出流通。 跛行本位 金币可以自由铸造，但是银币不能自由铸造，只可以无限偿还。 金本位制的三种形式 金币本位：纯粹的金币本为： 自由铸造，自由兑换，自由输出入国境 金块本位：金币不再流通，黄金纸币不可自由兑换，一定限额。 两次世界大战期间英法实行，黄金储备不够不足以支持自由兑换（富人本位）。 金汇兑本位：不铸造金币，市场上不流通，本币不可兑换黄金，但本币可以以固定汇率兑换成某一实行金币或金块本位的国家的货币，并在该国兑换黄金。（无法兑换，提供其他两种本位的一个固定汇率关系） 纸币与黄金的关系进一步弱化。 第五节 国际货币体系“黄金——美元”本位制的布雷顿森立体系，美元本位制牙买加体系。 国际货币制度的研边国际金本位制度（1880-1913） =&gt; 浮动汇率制度（1914-1944） =&gt; 布雷顿森林体系（1945-1973） =&gt; 牙买加体系（1978） 国际金本位制特点： 原因 黄金产量不足，长期通货紧缩 黄金产品分布不均 第一次世界大战爆发的刺激 布雷顿森林体系的建立“双挂钩一固定” 美元同黄金挂钩，其他货币与美元挂钩。美元与黄金兑换固定（35美元1盎司）。]]></content>
      <categories>
        <category>金融</category>
        <category>金融学</category>
      </categories>
      <tags>
        <tag>课堂笔记</tag>
        <tag>辅修</tag>
        <tag>金融学</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[【UVALive-7734】解题报告（水题）]]></title>
    <url>%2Fpost%2F47b391f2.html</url>
    <content type="text"><![CDATA[原始题目 题目大意给出$n$种物品每种的个数和价值，求价值总和。 解题思路求和 解题代码1234567891011121314151617181920212223242526272829303132333435363738394041#include&lt;bits/stdc++.h&gt;#include&lt;algorithm&gt;#define rep(i,a,n) for(int i=a;i&lt;n;++i)#define per(i,a,n) for(int i=n-a;i&gt;=a;--i)#define fi first#define se second#define cl(x,a) memset(x,a,sizeof(x))#define all(x) x.begin(),x.end()#define INF 0x3f3f3f3f#define EPS 1e-9#define mod 1000000007using namespace std;const int maxn=1e5+5;const int maxm=1e5+5;typedef long long ll;typedef unsigned long long ull;typedef vector&lt;int&gt; vi;typedef pair&lt;int,int&gt; pii;int t,n,m;int main()&#123; ios::sync_with_stdio(false); cin&gt;&gt;t; while(t--)&#123; cin&gt;&gt;n; ll ans=0; rep(i,0,n)&#123; int a,b; cin&gt;&gt;a&gt;&gt;b; ans+=a*b; &#125; cout&lt;&lt;ans&lt;&lt;endl; &#125;&#125; 收获与反思暂无]]></content>
      <categories>
        <category>编程</category>
        <category>ACM</category>
      </categories>
      <tags>
        <tag>ACM</tag>
        <tag>算法</tag>
        <tag>2018秋季训练</tag>
        <tag>UVALive</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[【UVALive-7737】解题报告（概率，时间独立性，暴力）]]></title>
    <url>%2Fpost%2F273ced06.html</url>
    <content type="text"><![CDATA[原始题目 题目大意Bob想从$n$种硬币中选出一种幸运硬币。选择策略如下： 如果当前没有剩下的硬币或者只剩下一种硬币，则该硬币为幸运硬币。 否则，将现有硬币抛出后，保留所有正面朝上的硬币。 给出每种硬币抛出后正面朝上的概率，计算各种硬币成为幸运硬币的概率。 解题思路由于题目中更说明：每种硬币抛出后正面朝上的概率在0.4和0.6之间 易分析知抛得次数可能是无限的，但连续一百次正面朝上的概率已经很小（精度要求内可忽略不计），想到打表。 $alive[i][j]$ 表示第i种硬币能存留到第j次抛出之前。 $dead[i][j]$ 表示第i种硬币不能存留到第j次抛出之前。 则最终答案为 $ans[i]= \sum (alive[i][j]-alive[i][j+1])*( \sum dead[k][j]) $ 解题代码123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384#include&lt;bits/stdc++.h&gt;#include&lt;algorithm&gt;#define rep(i,a,n) for(int i=a;i&lt;n;++i)#define per(i,a,n) for(int i=n-a;i&gt;=a;--i)#define fi first#define se second#define cl(x,a) memset(x,a,sizeof(x))#define all(x) x.begin(),x.end()#define INF 0x3f3f3f3f#define EPS 1e-9#define mod 1000000007#define FF 150using namespace std;const int maxn=1e3+5;const int maxm=1e5+5;typedef long long ll;typedef unsigned long long ull;typedef vector&lt;int&gt; vi;typedef pair&lt;int,int&gt; pii;int t,n,m;int num[maxn];double p[maxn];double dead[maxn][FF];double alive[maxn][FF];double ans[maxn];double qpow(double a,int x)&#123; double ans=1.0; while(x)&#123; if(x&amp;1) ans *=a; a*=a; x&gt;&gt;=1; &#125; return ans;&#125;void solve()&#123; rep(i,1,n+1)&#123; rep(j,1,FF)&#123; double temp=qpow(p[i],j); dead[i][j]=qpow((1.0-temp),num[i]); alive[i][j]=1.0-dead[i][j]; &#125; &#125;&#125;int main()&#123; ios::sync_with_stdio(false); cin&gt;&gt;t; while(t--)&#123; cin&gt;&gt;n; rep(i,1,n+1)&#123; cin&gt;&gt;num[i]&gt;&gt;p[i]; &#125; if(n==1)&#123; cout&lt;&lt;fixed&lt;&lt;setprecision(6)&lt;&lt;1.0&lt;&lt;endl; continue; &#125; memset(alive,0,sizeof(alive)); memset(dead,0,sizeof(dead)); solve(); rep(i,1,n+1)&#123; ans[i]=0; rep(j,1,FF)&#123; double temp=1.0; rep(k,1,n+1)&#123; if(i==k) continue; else&#123; temp*=dead[k][j]; &#125; &#125; ans[i]+=temp*(alive[i][j]-alive[i][j+1]); &#125; &#125; cout&lt;&lt;fixed&lt;&lt;setprecision(6)&lt;&lt;ans[1]; rep(i,2,n+1)&#123; cout&lt;&lt;" "&lt;&lt;fixed&lt;&lt;setprecision(6)&lt;&lt;ans[i]; &#125; cout&lt;&lt;endl; &#125;&#125; 收获与反思注意分析概率的公式。]]></content>
      <categories>
        <category>编程</category>
        <category>ACM</category>
      </categories>
      <tags>
        <tag>ACM</tag>
        <tag>算法</tag>
        <tag>2018秋季训练</tag>
        <tag>UVALive</tag>
        <tag>概率</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[【CSU-1112】解题报告（模拟，水题）]]></title>
    <url>%2Fpost%2F1c52564f.html</url>
    <content type="text"><![CDATA[原始题目1112: 机器人的指令 Time Limit: 1 Sec Memory Limit: 128 Mb Submitted: 3392 Solved: 1245 Description数轴原点有一个机器人。该机器人将执行一系列指令，你的任务是预测所有指令执行完毕之后它的位置。 LEFT：往左移动一个单位 RIGHT: 往右移动一个单位 SAME AS i: 和第i 条执行相同的动作。输入保证i 是一个正整数，且不超过之前执行指令数 Input输入第一行为数据组数$T (T≤100)$。每组数据第一行为整数 $n (1≤n≤100) $，即指令条数。以下每行一条指令。指令按照输入顺序编号为$1 \cdots n$。 Output对于每组数据，输出机器人的最终位置。每处理完一组数据，机器人应复位到数轴原点。 Sample Input2 3 LEFT RIGHT SAME AS 2 5 LEFT SAME AS 1 SAME AS 2 SAME AS 1 SAME AS 4 Sample Output1 -5 HintSource湖南省第八届大学生计算机程序设计竞赛 题目大意如题 解题思路储存每一操作，线性扫。 解题代码12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455#include &lt;cstdio&gt;#include&lt;cstring&gt;#include &lt;set&gt;#include &lt;string&gt;#include &lt;iostream&gt;#include &lt;iomanip&gt;#include &lt;queue&gt;#include &lt;vector&gt;#include &lt;map&gt;#include &lt;algorithm&gt;#define rep(i,a,n) for(int i=a;i&lt;n;++i)#define per(i,a,n) for(int i=n-1;i&gt;=a;--i)#define cl(x,a) memset(x,a,sizeof(x))#define all(x) x.begin(),x.end()#define INF 0x3f3f3f3f#define EPS 1e-9#define mod 1000000007#define fi first#define se secondusing namespace std;const int maxn=1e5+5;typedef long long ll;typedef unsigned long long ull;typedef vector&lt;int&gt; vi;typedef pair&lt;int,int&gt; pii;int t,n,m,a;int num[maxn];string ctl;int main()&#123; ios::sync_with_stdio(false); cin&gt;&gt;t; while(t--)&#123; int temp=0; cin&gt;&gt;n; rep(i,1,n+1)&#123; cin&gt;&gt;ctl; if(ctl[0]=='S')&#123; cin&gt;&gt;ctl&gt;&gt;a; num[i]=num[a]; &#125; else if(ctl[0]=='L')&#123; num[i]=-1; &#125; else num[i]=1; &#125; rep(i,1,n+1)&#123; temp+=num[i]; &#125; cout&lt;&lt;temp&lt;&lt;endl; &#125;&#125; 收获与反思暂无]]></content>
      <categories>
        <category>编程</category>
        <category>ACM</category>
      </categories>
      <tags>
        <tag>ACM</tag>
        <tag>算法</tag>
        <tag>CSU</tag>
        <tag>Imitation</tag>
        <tag>2018秋季训练</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[【CSU-1104】解题报告（博弈游戏，找规律）]]></title>
    <url>%2Fpost%2Ffeaebfb5.html</url>
    <content type="text"><![CDATA[原始题目]]></content>
      <categories>
        <category>编程</category>
        <category>ACM</category>
      </categories>
      <tags>
        <tag>ACM</tag>
        <tag>算法</tag>
        <tag>CSU</tag>
        <tag>博弈</tag>
        <tag>2018秋季培训</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[金融学辅修——金融学笔记（一）]]></title>
    <url>%2Fpost%2F222505fd.html</url>
    <content type="text"><![CDATA[第一节 什么是货币金融学的起点，也是金融学的终点。所有金融现象、金融行为都是某种程度的或大或小的货币事件。 货币就是金钱，信用就是金钱，金钱可生金钱。货币决定未来世界格局。 IMF，国际货币基金组织，成员国，运行“份子”根据本国对外贸易占世界贸易中的比重，以及GDP水平等来衡量。投票权重与“份子”相关，百分之十五决议通过，而目前美元比重占比17%，所以几乎等于断言。IMF也是随着布雷顿森林体系的建立而崛起的。 货币的产生中国古代货币起源说（解决民间秒换困难，沟通产品交换的手段）。 西方货币起源说（创造发明说，便于交换说，保存财富说）。 马克思货币起源说（货币是商品生产和商品交换发展的必然产物，是商品经济内在矛盾发展的必然结果）。 进一步解释马克思的解释： 简单的物物交换=&gt;复杂的物物交换=&gt;（规模逐渐发展，信用，复杂程度等多方面影响）=&gt;货币的产生 货币的本质货币金属说，货币名目说，劳动价值说。 货币的定义经济学中成为货币的东西，就是人们日常生活中的钱的东西。由于时代背景，观察角度、观察深度不同以及侧重于理论剖析与侧重于解决实际问题需要不同，定义表述不同。 本质定义：从商品交换中分离出来固定地充当一般等价物的特殊商品。 经济学定义：在商品或劳务支付中或债务偿还中被普遍接受的任何东西。 法定货币（法律定义）：通过立法授予某种物品具有清偿债务的合法权利。 层次定义（计量定义）： M0=流通中现金（通货） M1=M0+企业活期存款+农业存款+]]></content>
      <categories>
        <category>金融</category>
        <category>金融学</category>
      </categories>
      <tags>
        <tag>课堂笔记</tag>
        <tag>辅修</tag>
        <tag>金融学</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[【CSU-1111】解题报告（水题）]]></title>
    <url>%2Fpost%2Fe256d99f.html</url>
    <content type="text"><![CDATA[原始题目1111: 三家人 Time Limit: 1 Sec Memory Limit: 128 Mb Submitted: 4053 Solved: 1606 Description有三户人家共拥有一座花园，每户人家的太太均需帮忙整理花园。A 太太工作了5 天，B 太太则工作了4 天，才将花园整理完毕。C 太太因为正身怀六甲无法加入她们的行列，便出了90元。请问这笔钱如何分给A、B 二位太太较为恰当？A 应得多少元？$ 5 \times \frac {90} {5+4}= 50 $？如果这么想你就上当了！正确答案是60 元。如果没想通的话再想想吧。 下面回答一个一般性的问题：假定A 太太工作了x 天，B 太太工作了y 天，C 太太出了90元，则A 太太应得多少元？输入保证二位太太均应得到非负整数元钱。三个太太工作效率相同。 友情提示：本题有个小小的陷阱哦。如果答案错的话，认真检查一下代码吧。 Input输入第一行为数据组数$T (T ≤ 20) $。每组数据仅一行，包含三个整数 $x, y, z (1 ≤ x, y ≤10,1 ≤ z ≤1000) $。 Output对于每组数据，输出一个整数，即A 太太应得的金额（单位：元）。 Sample Input2 5 4 90 8 4 123 Sample Output60 123 Hint如果使用浮点数，请小心误差，输出时尽量用四舍五入。 Source湖南省第八届大学生计算机程序设计竞赛 题目大意如题 解题思路考虑每个人都应该完成$ \frac {1}{3} $ 的工作量。再按多余完成量分配钱，注意考虑工作量不够自己应该完成的情况。 解题代码123456789101112131415161718192021222324252627282930313233#include &lt;cstdio&gt;#include &lt;cstring&gt;#include &lt;iostream&gt;#include &lt;iomanip&gt;#include &lt;cstdlib&gt;#include &lt;set&gt;#include &lt;string&gt;#include &lt;cstring&gt;#include &lt;stack&gt;#define rep(i,a,n) for(int i=a;i&lt;n;++i)#define per(i,a,n) for(int i=n-1;i&gt;=a;--i)using namespace std;const int maxn=1e5+5;const int maxl=26;int t,n;double x,y,z; int main()&#123; ios::sync_with_stdio(false); cin&gt;&gt;t; while(t--)&#123; cin&gt;&gt;x&gt;&gt;y&gt;&gt;z; double ans=(x+y)/3.0; if(ans&gt;(double)x) cout&lt;&lt;0&lt;&lt;endl; else if(ans&gt;(double)y) cout&lt;&lt;fixed&lt;&lt;setprecision(0)&lt;&lt;z&lt;&lt;endl; else &#123; x-=ans; y-=ans; cout&lt;&lt;fixed&lt;&lt;setprecision(0)&lt;&lt;z*x/(x+y)&lt;&lt;endl; &#125; &#125;&#125; 收获与反思水题]]></content>
      <categories>
        <category>编程</category>
        <category>ACM</category>
      </categories>
      <tags>
        <tag>ACM</tag>
        <tag>算法</tag>
        <tag>CSU</tag>
        <tag>2018暑假集训</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[【CSU-1115】解题报告（字典树）]]></title>
    <url>%2Fpost%2Fe5d75450.html</url>
    <content type="text"><![CDATA[原始题目1115: 最短的名字 Time Limit: 5 Sec Memory Limit: 64 Mb Submitted: 2057 Solved: 801 Description在一个奇怪的村子中，很多人的名字都很长，比如aaaaa, bbb and abababab。 名字这么长，叫全名显然起来很不方便。所以村民之间一般只叫名字的前缀。比如叫’aaaaa’的时候可以只叫’aaa’，因为没有第二个人名字的前三个字母是’aaa’。不过你不能叫’a’，因为有两个人的名字都以’a’开头。村里的人都很聪明，他们总是用最短的称呼叫人。输入保证村里不会有一个人的名字是另外一个人名字的前缀（作为推论，任意两个人的名字都不会相同）。 如果村里的某个人要叫所有人的名字（包括他自己），他一共会说多少个字母？ Input输入第一行为数据组数$T (T≤10)$。每组数据第一行为一个整数n$(1≤n≤1000)$ ，即村里的人数。以下$n$行每行为一个人的名字（仅有小写字母组成）。输入保证一个村里所有人名字的长度之和不超过 $10^{6}$。 Output对于每组数据，输出所有人名字的字母总数。 Sample Input1 3 aaaaa bbb abababab Sample Output5 HintSource湖南省第八届大学生计算机程序设计竞赛 题目大意如题 解题思路建立字典树，每个结点的value值储存单词字母的出现次数。 对于每个单词，统计第一个出现value值为1的位置（表示到这里后面没有相同单词前缀） 求和，完成任务 解题代码123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109#include &lt;cstdio&gt;#include &lt;cstring&gt;#include &lt;iostream&gt;#include &lt;cstdlib&gt;#include &lt;set&gt;#include &lt;string&gt;#include &lt;cstring&gt;#include &lt;stack&gt;#define rep(i,a,n) for(int i=a;i&lt;n;++i)#define per(i,a,n) for(int i=n-1;i&gt;=a;--i)using namespace std;const int maxn=1e5+5;const int maxl=26;typedef long long ll;typedef struct Trie&#123; int v; Trie* next[maxl];&#125;Trie; Trie *root;void iniTrie()&#123; root=(Trie*)malloc(sizeof(Trie)); for(int i=0;i&lt;maxl;i++) root-&gt;next[i]=NULL; root-&gt;v=-1;&#125;bool creTrie(string a)&#123; int l=a.length(); Trie *p=root,*q; for(int i=0;i&lt;l;i++) &#123; int id=a[i]-&apos;a&apos;; //并非前缀不能有相同，而是不能在相同的分支上。 // if(i==l-1)&#123;// if(p-&gt;next[id]!=NULL) return 0;// &#125; if(p-&gt;next[id]==NULL)&#123; q=(Trie*) malloc(sizeof(Trie)); q-&gt;v=1; for(int j=0;j&lt;maxl;j++) q-&gt;next[j]=NULL; // //结点连接到树上 p-&gt;next[id]=q; p=p-&gt;next[id]; &#125; else&#123; p=p-&gt;next[id]; p-&gt;v++; &#125; &#125; return 1;&#125;int cntTrie(string ss)&#123; int l=ss.length(); Trie *p=root,*q; for(int i=0;i&lt;l;i++) &#123; int id=ss[i]-&apos;a&apos;; p=p-&gt;next[id]; if(p-&gt;v==1) return i+1; &#125;&#125;void delTrie(Trie *p) &#123; int i; for(i=0;i&lt;maxl;i++) &#123; if(p-&gt;next[i] != NULL) delTrie(p-&gt;next[i]); &#125; free(p);// printf(&quot;1&quot;); p==NULL; return ;&#125; string s[maxn];int t,ccount,n;int main()&#123; ios::sync_with_stdio(false); cin&gt;&gt;t; while(t--)&#123; iniTrie(); cin&gt;&gt;n; rep(i,0,n)&#123; cin&gt;&gt;s[i]; creTrie(s[i]); &#125; int aans=0; rep(i,0,n)&#123; aans+=cntTrie(s[i]); &#125; cout&lt;&lt;aans&lt;&lt;endl; delTrie(root); &#125;&#125; 收获与反思灵活运用字典树的染色和统计功能]]></content>
      <categories>
        <category>编程</category>
        <category>ACM</category>
      </categories>
      <tags>
        <tag>ACM</tag>
        <tag>算法</tag>
        <tag>CSU</tag>
        <tag>2018暑假集训</tag>
        <tag>字典树</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[【CSU-1101】解题报告（水题，模拟）]]></title>
    <url>%2Fpost%2Fd6a5bd15.html</url>
    <content type="text"><![CDATA[原始题目1101: 报数游戏 Time Limit: 1 Sec Memory Limit: 128 Mb Submitted: 1400 Solved: 474 Descriptionn个人站成一行玩一个报数游戏。所有人从左到右编号为1到n。游戏开始时，最左边的人报1，他右边的人报2，编号为3的人报3，等等。当编号为n的人（即最右边的人）报完n之后，轮到他左边的人（即编号为n-1的人）报n+1，然后编号为n-2的人报n+2，以此类推。当最左边的人再次报数之后，报数方向又变成从左到右，依次类推。为了防止游戏太无聊，报数时有一个特例：如果应该报的数包含数字7或者是7的倍数，他应当用拍手代替报数。下表是n=4的报数情况（X表示拍手）。当编号为3的人第4次拍手的时候，他实际上数到了35。 给定$n,m,k$，你的任务是计算当编号为 $m$ 的人第 $k$ 次拍手时，他实际上数到了几。 Input输入包含不超过10组数据。每组数据占一行，包含三个整数 $n,m$ 和 $k$ $( 2 ≤ n ≤ 100, 1 ≤ m ≤n, 1 ≤ k ≤ 100)$。输入结束标志为 $n=m=k=0$。 Output对于每组数据，输出一行，即编号为 $m$ 的人第 $k$ 次拍手时，他实际上数到的那个整数。 Sample Input4 3 1 4 3 2 4 3 3 4 3 4 0 0 0 Sample Output17 21 27 35 HintSource湖南省第七届大学生计算机程序设计竞赛 题目大意如题 解题思路直接模拟 解题代码12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364656667686970#include &lt;cstdio&gt;#include &lt;cstring&gt;#include &lt;cstdlib&gt;#include &lt;string&gt;#include &lt;iostream&gt;#include &lt;iomanip&gt;#include &lt;queue&gt;#include &lt;stack&gt;#include &lt;vector&gt;#include &lt;set&gt;#include &lt;map&gt;#include &lt;algorithm&gt;#include &lt;bits/stdc++.h&gt;#define fi first#define se second#define rep(i,a,n) for(int i=a;i&lt;n;++i)#define per(i,a,n) for(int i=n-1;i&gt;=a;--i)#define cl(x,a) memset(x,a,sizeof(x)) #define all(x) x.begin,x.end()#define INF 0x3f3f3f3f#define eps 1e-8using namespace std;typedef long long ll;typedef unsigned long long ull;typedef vector&lt;int&gt; vi;typedef pair&lt;int,int&gt; pii;typedef pair&lt;string,string&gt; pss;const int maxn=1e5+5;const int maxm=1e5+5;const int maxl=26;int vis[maxn];bool check(ll num)&#123; while(num)&#123; int temp=num%10; if(temp==7) return 1; num/=10; &#125; return 0;&#125;int main()&#123; ll n,m,k,cnt=0; int flag=0; while(~scanf("%lld%lld%lld",&amp;n,&amp;m,&amp;k) &amp;&amp; n+m+k)&#123; memset(vis,0,sizeof(vis)); flag=0,cnt=0; while(vis[m]&lt;k)&#123; rep(i,1,n)&#123; if((++cnt )%7==0 || check(cnt)) &#123;// cout&lt;&lt;"i="&lt;&lt;i&lt;&lt;" cnt="&lt;&lt;cnt&lt;&lt;endl; vis[i]++; &#125; if(vis[m]==k) break; &#125; if(vis[m]==k) break; per(i,2,n+1)&#123; if((++cnt)%7==0 || check(cnt)) &#123;// cout&lt;&lt;"i="&lt;&lt;i&lt;&lt;" cnt="&lt;&lt;cnt&lt;&lt;endl; vis[i]++; &#125; if(vis[m]==k) break; &#125; &#125; cout&lt;&lt;cnt&lt;&lt;endl; &#125; &#125; 收获与反思直接模拟即可]]></content>
      <categories>
        <category>编程</category>
        <category>ACM</category>
      </categories>
      <tags>
        <tag>ACM</tag>
        <tag>算法</tag>
        <tag>CSU</tag>
        <tag>Imitation</tag>
        <tag>2018暑假集训</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[【CSU-1315】解题报告（排序，前缀和）]]></title>
    <url>%2Fpost%2Fe7058b47.html</url>
    <content type="text"><![CDATA[原始题目1315: 全场最水题之陈兴老师与比赛 Time Limit: 1 Sec Memory Limit: 128 Mb Submitted: 841 Solved: 280 Description大家都知道ACM比赛罚时很重要。比如说你做A题要10分钟，B题要15分钟，如果先做A题再做B题，那么在ranking上的时间就是10 + （10）+ 15 = 35。如果先做B题再做A题总罚时就是15+(15)+10=40.现在陈兴老师要做一场比赛，比赛有$n$道题， 总时间是$300$分钟。我们的陈兴老师仅仅看题目就可以知道他做每道题需要的时间，所以他想在比赛刚开始时就计算出自己的最大总做题数，以及对应的总罚时和做题顺序（当然，做题数相等时当然希望总罚时最少咯）。比如一般的比赛，陈兴老师做第一题需要1分钟，第二题2分钟，依此类推，陈兴老师只需要66分钟就可以AK一场11道题的比赛。PS: 陈兴老师做题都是1Y，膜拜陈兴老师Orz！ Input第一行是一个数字 $n (0&lt;n ≤25)$ 。 第二行是$n$个数字，第$i$个数字代表陈兴老师出编号为$i$的题所需要的时间 $t_i( 0 &lt; t_i ≤ 80)$。 Output第一行输出陈兴老师的出题数和Penalty（总时间） 以下按照顺序输出陈兴老师出题的顺序,每行一个编号。（详见输出样例）PS：时间一样的按编号升序输出。 Sample Input3 1 2 3 4 1 2 3 4 6 60 60 60 60 60 60 Sample Output3 10 1 2 3 4 20 1 2 3 4 5 900 1 2 3 4 5 HintSource题目大意原题说的不大清楚，实际上对于每到AC题目罚时累加上从开始到完成该题目的时间，比赛一共300分钟，求解题数，罚时，并输出接替顺序。（感觉整理CSU题面的时候应该再完善一下题目意思） 解题思路排序以后求前缀和，当前缀和超过300时输出 解题代码12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364656667686970717273747576#include &lt;cstdio&gt;#include &lt;cstring&gt;#include &lt;iostream&gt;#include &lt;iomanip&gt;#include &lt;set&gt;#include &lt;queue&gt;#include &lt;map&gt;#include &lt;sstream&gt;#include &lt;algorithm&gt;#include &lt;vector&gt;#include &lt;stack&gt;#include &lt;cmath&gt;#define rep(i,a,n) for(int i=a;i&lt;n;++i)#define per(i,a,n) for(int i=n-1;i&gt;=a;--i)#define fi first#define se second#define mp make_pair#define pb push_back#define np next_permutation#define all(x) x.begin(),x.end()#define insert(x) x,x.begin()#define cl(x,a) memset(x,a,sizeof(x))using namespace std;const int maxn=1e5+5;const int maxm=1e5+5;const int maxl=26;typedef long long ll;typedef unsigned long long ull;typedef vector&lt;int&gt; vi;typedef pair&lt;int,int&gt; pii;typedef pair&lt;string,string&gt; pss;bool cmp(pii a,pii b)&#123; if(a.second!=b.second) return a.second&lt;b.second; else return a.first&lt;b.first;&#125;int n,t,a[maxn];int main()&#123;// ios::sync_with_stdio(false); while(~scanf("%d",&amp;n))&#123; vector&lt;pii&gt; v; rep(i,1,n+1)&#123; int temp; scanf("%d",&amp;temp); v.pb(mp(i,temp)); &#125; sort(all(v),cmp); a[0]=v[0].second; rep(i,1,n) &#123; a[i]=a[i-1]+v[i].second;// cout&lt;&lt;"a["&lt;&lt;i&lt;&lt;"] = "&lt;&lt;a[i]&lt;&lt;endl; &#125; int panality=0,i=0,caltime=0; for(;i&lt;n&amp;&amp;caltime&lt;=300;i++)&#123; panality+=a[i]; caltime+=v[i].second; &#125; if(caltime&lt;=300) &#123;// cout&lt;&lt;n&lt;&lt;" "&lt;&lt;panality&lt;&lt;endl; printf("%d %d\n",n,panality);// rep(i,0,n) cout&lt;&lt;v[i].fi&lt;&lt;endl; rep(i,0,n) printf("%d\n",v[i].fi); &#125; else &#123; panality-=a[--i];// cout&lt;&lt;i&lt;&lt;" "&lt;&lt;panality&lt;&lt;endl; printf("%d %d\n",i,panality);// rep(i,0,n) cout&lt;&lt;v[i].fi&lt;&lt;endl; rep(j,0,i) printf("%d\n",v[j].fi); &#125; &#125;&#125; 收获与反思排序一下]]></content>
      <categories>
        <category>编程</category>
        <category>ACM</category>
      </categories>
      <tags>
        <tag>ACM</tag>
        <tag>算法</tag>
        <tag>CSU</tag>
        <tag>2018暑假集训</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[【CSU-1321】解题报告（最短路，dij）]]></title>
    <url>%2Fpost%2F4773b69c.html</url>
    <content type="text"><![CDATA[原始题目1321: CX and girls Time Limit: 1 Sec Memory Limit: 128 Mb Submitted: 597 Solved: 181 DescriptionCX是要赶去上课，为了不迟到必须要以最短的路径到达教室，同时CX希望经过的路上能看到的学妹越多越好。现在把地图抽象成一个无向图，CX从$1$点出发，教室在$N$号点，告诉每个点上学妹的数量，每条边的长度。 请你求出CX以最短路径赶到教室最多能看到多少学妹。 Input多组输入数据(最多20组)，输入到文件结束。 每组数据第一行两个正整数$N,M$其中$N$代表点的个数$( 2 ≤ N ≤ 1000)$，$M$代表边的个数$(1 ≤ M ≤ 10000)$。 接下来一行$N$个数，代表着$1 \cdots N$每个点上学妹的个数，$(0 ≤ N_i \le 50)$。 接下来$M$行，每行三个数$A,B,C (1 \le A , B \le N , 0 &lt; C \le 100 )$ 代表$A,B$两点间有边，长度为$C$。(可能存在重边) Output输出CX以最短距离从$1$到$n$的情况下能看到的最多学妹数量，若从点$1$无法到达点$N$输出$-1$。 Sample Input4 4 1 2 3 4 1 2 1 1 3 1 2 4 2 3 4 2 Sample Output8 AuthorCSU_ZZY SourceCSU Monthly 2013 Oct. 题目大意如题 解题思路最短路加上对结点值的判断 解题代码123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103#include &lt;cstdio&gt;#include &lt;cstring&gt;#include &lt;string&gt;#include &lt;algorithm&gt;#include &lt;iostream&gt;#include &lt;stack&gt;#include &lt;set&gt;#include &lt;vector&gt;#include &lt;queue&gt;#include &lt;cmath&gt;#include &lt;cstdlib&gt;#include &lt;bits/stdc++.h&gt; using namespace std;#define eps 1e-8#define INF 0x3f3f3f3f#define rep(i,a,n) for(int i=a;i&lt;n;i++)#define per(i,a,n) for(int i=n-1;i&gt;=a;i--)#define all(x) x.begin(),x.end()#define pb push_back#define np next_permutation#define ms(x,a) memset((x),(a),sizeof(x))//优先队列迪杰斯特拉 const int maxn=1e5+5;struct Edge&#123; int u,v,w; Edge(int _u,int _v,int _w):u(_u),v(_v),w(_w)&#123; &#125;;&#125;;vector &lt;Edge&gt; edges[maxn];int dis[maxn],meizi[maxn],mei[maxn];bool vis[maxn];int n,m,uu,vv,ww;void init(int n)&#123; //n个结点的边集都清空 rep(i,0,maxn)&#123; edges[i].clear(); &#125;&#125;void addEdge(int u,int v,int w)&#123; edges[u].pb(Edge(u,v,w));&#125;struct Node&#123; int Id,W; Node(int _Id,int _W):Id(_Id),W(_W)&#123; &#125;; bool operator &lt; (const Node &amp;b) const &#123; return W&gt;b.W;// else return Id&lt;b.Id; &#125;&#125;;void Dijkstra(int s)&#123; ms(vis,0); ms(meizi,0); ms(dis,INF); priority_queue &lt;Node&gt; q; q.push(Node(s,0)) ; dis[s]=0;meizi[s]=mei[s]; while(!q.empty())&#123; Node now=q.top(); q.pop(); int index=now.Id; if(vis[index]) continue;// if(index==end) return; vis[index]=1; rep(i,0,edges[index].size())&#123; Edge temp=edges[index][i]; if(dis[temp.v]&gt;dis[index]+temp.w)&#123; dis[temp.v]=dis[index]+temp.w; meizi[temp.v]=meizi[index]+mei[temp.v]; q.push(Node(temp.v,dis[temp.v])); &#125; else if(dis[temp.v]==dis[index]+temp.w)&#123; if(meizi[temp.v]&lt;meizi[index]+mei[temp.v])&#123; meizi[temp.v]=meizi[index]+mei[temp.v]; q.push(Node(temp.v,dis[temp.v])); &#125; &#125; &#125; &#125;&#125;int main()&#123; ios::sync_with_stdio(false); while(cin&gt;&gt;n&gt;&gt;m)&#123; init(n); rep(i,1,n+1)&#123; cin&gt;&gt;mei[i]; &#125; rep(i,1,m+1)&#123; cin&gt;&gt;uu&gt;&gt;vv&gt;&gt;ww; addEdge(uu,vv,ww); addEdge(vv,uu,ww); &#125; Dijkstra(1); if(dis[n]&gt;100000000) cout&lt;&lt;"-1"&lt;&lt;endl; else cout&lt;&lt;meizi[n]&lt;&lt;endl; &#125; &#125; 收获与反思 模板开始错了，少了return，WA了一晚上。]]></content>
      <categories>
        <category>编程</category>
        <category>ACM</category>
      </categories>
      <tags>
        <tag>ACM</tag>
        <tag>算法</tag>
        <tag>CSU</tag>
        <tag>2018暑假集训</tag>
        <tag>Dijkstra</tag>
        <tag>最短路</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[【CSU-1323】解题报告（字典树）]]></title>
    <url>%2Fpost%2F677d0fef.html</url>
    <content type="text"><![CDATA[原始题目1323: ZZY and his little friends Time Limit: 5 Sec Memory Limit: 256 Mb Submitted: 708 Solved: 258 Descriptionzzy养了一只小怪兽和N只凹凸曼，单挑的话每只凹凸曼都不是小怪兽的对手，所以必须由两只凹凸曼合作来和小怪兽战斗。凹凸曼A和凹凸曼B合作的战斗力为他们战斗力的异或值。现在由zzy从N只凹凸曼中选出两只来和小怪兽战斗。 请问zzy能否选出两只凹凸曼使他们能够战胜小怪兽(他们的战斗力比小怪兽大)。 Input输入有多个例子，直到文件结束。 每个例子的第一行含两个数N和M，表示有 $ N ( 2 \le N \le 10^5 )$只凹凸曼，小怪兽的战斗力为$ M (0 &lt; M \le 10^9 )$。接着有一行N个数，每个数 $ A_i ( 0 &lt; A_i &lt; M )$表示每只凹凸曼的战斗力。 Output对于每个例子输出一行，如果能选出两只凹凸曼使他们战胜小怪兽输出”YES”, 否则输出”NO”(不含引号) Sample Input2 5 1 1 2 6 5 2 Sample OutputNO YES Author CSU_CX SourceCSU Monthly 2013 Oct. 题目大意如题 解题思路01字典树，将数字转换为32位的01数字串（高位在前）储存到树中。然后扫一遍求异最大值，与题目给定的$M$比较。 接替代码123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131#include &lt;cstdio&gt;#include &lt;cstring&gt;#include &lt;cmath&gt;#include &lt;set&gt;#include &lt;queue&gt;#include &lt;map&gt;#include &lt;set&gt;#include &lt;string&gt;#include &lt;iostream&gt;#include &lt;iomanip&gt;#include &lt;stack&gt;#define rep(i,a,n) for(int i=a ; i&lt;n;++i)#define per(i,a,n) for(int i=n-1;i&gt;=a;--i)#define fi first#define se second#define cl(x,a) memset(x,a,sizeof(x)) #define all(x) x.begin(),x.end()#define insert(x) x,x.begin()#define debug printf("======================\n");#define mp make_pair#define np next_permutation#define pb push_back#define INF 0x3f3f3f3f#define eps 1e-8using namespace std;const int maxn=1e5+5;const int maxm=1e5+5;const int maxl=2;const int K=32;typedef long long ll;typedef struct Trie&#123; int v; Trie* next[maxl];&#125;Trie;Trie *root;void iniTrie()&#123; root=(Trie*) malloc(sizeof(Trie)); rep(i,0,maxl) root-&gt;next[i]=NULL; root-&gt;v=-1; &#125;bool creTrie(int a)&#123; //预处理整数为01数组 int temp[35]; int id=K-1; while(a)&#123; temp[id--]=(a&amp;1); a&gt;&gt;=1; &#125; rep(i,0,id+1) temp[i]=0; int l=K; Trie *p=root,*q; rep(i,0,l)&#123; int id=temp[i]; if(p-&gt;next[id]!=NULL)&#123; p=p-&gt;next[id]; &#125; else &#123; q=(Trie*) malloc(sizeof(Trie)); q-&gt;v=1; //新建节点染色 for(int j=0;j&lt;maxl;j++) q-&gt;next[j]=NULL; p-&gt;next[id]=q; p=p-&gt;next[id]; &#125; &#125; &#125;int findTrie(int a)&#123; int aa=a; int temp[35]; int id=K-1; while(a)&#123; temp[id--]=(a&amp;1); a&gt;&gt;=1; &#125; rep(i,0,id+1) temp[i]=0; //前面位置补0 int aans=0; Trie *p=root; int l=K; for(int i=0;i&lt;l;i++)&#123; int index= !temp[i]; if(p-&gt;next[index] !=NULL )&#123; aans=(aans&lt;&lt;1)+index; p=p-&gt;next[index]; &#125; else &#123; aans=(aans&lt;&lt;1)+temp[i]; p=p-&gt;next[temp[i]]; &#125; &#125; return aans^aa; &#125;void delTrie(Trie *p)&#123; int i; for(int i=0;i&lt;maxl;i++)&#123; if(p-&gt;next[i]!= NULL) delTrie(p-&gt;next[i]); &#125; free(p); p=NULL; return ;&#125;int a[maxn],n,m;int main()&#123; ios::sync_with_stdio(false); while(cin&gt;&gt;n&gt;&gt;m)&#123; iniTrie(); rep(i,0,n)&#123; cin&gt;&gt;a[i]; creTrie(a[i]); &#125; int fans=0; rep(i,0,n)&#123; fans=max(fans,findTrie(a[i])); &#125; if(fans&gt;m) cout&lt;&lt;"YES"&lt;&lt;endl; else cout&lt;&lt;"NO"&lt;&lt;endl; &#125; &#125; 收获与反思熟悉求异或最大值01字典树的操作。]]></content>
      <categories>
        <category>编程</category>
        <category>ACM</category>
      </categories>
      <tags>
        <tag>ACM</tag>
        <tag>算法</tag>
        <tag>CSU</tag>
        <tag>2018暑假集训</tag>
        <tag>字典树</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[【CSU-1330】解题报告（水题，字符串）]]></title>
    <url>%2Fpost%2Fbba462fb.html</url>
    <content type="text"><![CDATA[原始题目1330: 字符识别？ Time Limit: 1 Sec Memory Limit: 128 Mb Submitted: 885 Solved: 595 Description你的任务是写一个程序进行字符识别。别担心，你只需要识别1, 2, 3，如下： .*. *** *** .*. ..* ..* .*. *** *** .*. *.. ..* .*. *** *** Input输入仅包含一组数据，由$6$行组成。第一行为字符的个数 $n ( 1 \le n \le 10)$。以下$5$行每行包含$4n$个字符。每个字符恰好占$5$行$3$列，然后是一个空列（用”.”填充）。 Output输出应包含一行，即识别出的各个字符。 Sample Input3 .*..***.***. .*....*...*. .*..***.***. .*..*.....*. .*..***.***. Sample Output123 HintSource湖南省第九届大学生计算机程序设计竞赛 题目大意将一个五行宽的字符串替换成所代表的1，2，3。 解题思路水题，字符串判断一下特征字符区间即可。 解题代码1234567891011121314151617181920212223242526272829303132333435363738394041424344#include &lt;cstdio&gt;#include &lt;cstring&gt;#include &lt;cmath&gt;#include &lt;set&gt;#include &lt;queue&gt;#include &lt;map&gt;#include &lt;set&gt;#include &lt;string&gt;#include &lt;iostream&gt;#include &lt;iomanip&gt;#include &lt;stack&gt;#define rep(i,a,n) for(int i=a ; i&lt;n;++i)#define per(i,a,n) for(int i=n-1;i&gt;=a;--i)#define fi first#define se second#define cl(x,a) memset(x,a,sizeof(x)) #define all(x) x.begin(),x.end()#define insert(x) x,x.begin()#define debug printf("======================\n");#define mp make_pair#define np next_permutation#define pb push_back#define INF 0x3f3f3f3f#define eps 1e-8using namespace std;const int maxn=1e5+5;const int maxm=1e5+5;const int maxl=2;const int K=32;string word[5]; int main()&#123; ios::sync_with_stdio(false); int n; while(cin&gt;&gt;n)&#123; rep(i,0,5) cin&gt;&gt;word[i]; rep(i,0,n)&#123; int ii=i*4; if(word[2][ii]=='.' &amp;&amp; word[2][ii+1]=='*' &amp;&amp; word[2][ii+2]=='.') cout&lt;&lt;1; else if(word[3][ii]=='*' &amp;&amp; word[3][ii+1]=='.' &amp;&amp; word[3][ii+2]=='.') cout&lt;&lt;2; else if(word[3][ii]=='.' &amp;&amp; word[3][ii+1]=='.' &amp;&amp; word[3][ii+2]=='*') cout&lt;&lt;3; &#125; cout&lt;&lt;endl; &#125;&#125; 收获与反思无]]></content>
      <categories>
        <category>编程</category>
        <category>ACM</category>
      </categories>
      <tags>
        <tag>ACM</tag>
        <tag>算法</tag>
        <tag>CSU</tag>
        <tag>2018暑假集训</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[【CSU-1340】结题报告（水题）]]></title>
    <url>%2Fpost%2F6ca1eed5.html</url>
    <content type="text"><![CDATA[原始题目1340: A Sample Problem Time Limit: 1 Sec Memory Limit: 128 Mb Submitted: 706 Solved: 322 DescriptionMy girlfriend loves 7 very much, she thinks it is lucky! If an integer contains one or more 7, she will think it is lucky too! InputThe first line has one integer $T (1 \le T \le 100)$, means there are T test cases. For each test case, there is only one line with an integer $X (1 \le X \le 10^{9} )$. OutputFor each test case, if X contains one or more 7, output “Lucky” (without quotation marks), otherwise output “Unlucky” (without quotation marks). Sample Input4 7 11 568 17171 Sample OutputLucky Unlucky Unlucky Lucky Hint我们主要通过这个题目来感受一下一个完整的ACM竞赛的题目应当是什么样的。 ACM竞赛题目本身的“格式” 很明显： 第一部分是对题目的描述，会交待题目的背景，以及你需要编程完成哪些任务等等。 第二部分是对输入的约定，会告诉你题目是否有多组测试数据，每组测试数据的格式，每个参数的类型（整数，浮点数，字符串等）以及取值范围等等。 第三部分是对输出的约定，也就是你的程序应当输出哪些内容以及具体的格式是什么。 第四部分是一些样例，这些例子只是向你展示一部分测试数据以及对应的答案，目的是更好地帮助你理解题意，以及了解对输出格式的要求等。 大家也许会和我当初刚接触ACM时一样心中充满了疑问，在这里我就为大家列举几个常见的问题： 如果题目有多组数据，我们是不是也要像样例那样把所有的结果先都计算出来，然后再一起输出？ 这个是没必要的，你完全可以每处理完一组数据之后就立刻将这组数据对应的结果输出出来。 但如果你是手动去敲这些样例的话，你会发现在屏幕上输入和输出是混在一起的，并不像样例那样输入和输出是分离的，这样会不会不符合要求呢？那么请看，相信你的疑问就会被解答了。 OJ (Online Judge)怎么知道我的程序是不是写对了？ OJ并不会去智能化地分析你的代码正确与否，而是用另一种巧妙的思路来判断你的程序是否符合要求：“喂”给你的程序一些输入数据（就像你在键盘上敲一些东西后敲回车一样），之后再将你的程序“产出”的东西（就像你在屏幕上看到的你的程序输出的东西一样）和标准的答案进行对比，如果你的程序得到的答案和标准的答案一模一样，那么就算你通过了这个题目。 因此，即使你手动输入样例时屏幕上的输入和输出是混在一起也没关系，只要你的程序“产出”的东西和标准答案一模一样就可以了。 也正是这种评判机制的关系，你不应当让程序打印一些提示语句，如“Please input two integers”等等，因为凡是你的程序输出的内容都会被拿来和标准答案进行对比，一旦输出了类似这样的题目没有要求输出的语句，就会和标准答案大相径庭了，自然就会认为你的程序是不正确的了。 值得一提的是，尽管这样的评判机制似乎并不能完美地知道你的程序究竟是不是对的（想想看为什么？），不过如果测试数据足够强大的话，“你的程序是对的”的概率就会很高很高了。 为什么我的程序通过了所有的样例，但是最后还是过不了这个题目？ 题目的样例只是一小部分测试数据，目的是为了更好地帮助你理解题意，以及了解对输出格式的要求等，因此通过了样例并不能够代表能通过所有的测试数据。只有通过了所有的测试数据才能得到“Accept”，也就是通过了这个题目。 每组测试数据的答案输出完之后，是否都要换行？ 是的，即使题目里面没有明确说明，我们也应该在每组测试数据的答案输出完之后再输出一个“换行”（也就是“\n”），就像样例示意的那样。 接下来我们谈谈这个题目的思路吧，相信大家应该都想到算法了：只要依次判断读入的整数的每一位是否是7就可以了。如果觉得代码写起来会有困难的话，可以参考一下我在下面给出的示例代码，不过最后一定要按自己的思路写一个完整的代码（编写自己的代码时就不要再参考示例代码了，要一气呵成~）并获得“Accept”哟！O(∩_∩)O~ SourceACM入门示例（第一季） 题目大意如题 解题思路水题 解题代码12345678910111213141516171819202122232425262728293031#include &lt;cstdio&gt;#include &lt;cstring&gt;#include &lt;iostream&gt;#include &lt;set&gt;#include &lt;queue&gt;#include &lt;algorithm&gt;#define INF 0x3f3f3f3f#define rep(i,a,n) for(int i=a;i&lt;n;++i)#define per(i,a,n) for(int i=n-1;i&gt;=a;--i)using namespace std;const int maxn=1e5+5;typedef long long ll;ll t,n,m;int main()&#123; scanf("%lld",&amp;t); while(t--)&#123; scanf("%lld",&amp;n); int flag=0; while(n)&#123; if(n%10==7)&#123;// printf("now=%d\n",n); flag=1; break; &#125; n/=10; &#125; if(flag) printf("Lucky\n"); else printf("Unlucky\n"); &#125;&#125; 收获与反思无]]></content>
      <categories>
        <category>编程</category>
        <category>ACM</category>
      </categories>
      <tags>
        <tag>ACM</tag>
        <tag>算法</tag>
        <tag>CSU</tag>
        <tag>2018暑假集训</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[【CSU-2158】解题报告（水题）]]></title>
    <url>%2Fpost%2Faa0a97c8.html</url>
    <content type="text"><![CDATA[原始题目2158: 长门的运动会 Time Limit: 1 Sec Memory Limit: 128 Mb Submitted: 2 Solved: 2 SpecialJudge Description运动会，好开心~ CSU (California State University) 正在举行一场特殊的接力跑比赛，比赛在环形跑道上进行，同一支队伍的所有人从同一个位置向相同的方向出发，当需要接力的两个人再次相遇时，他们就要交接棒。最后总成绩是以队伍跑的总路程计算的 现在接力的第一棒在Nagato手中，需要把它交给Kyon。在长度为C的环形跑道上，他们出发了！Nagato以速度A匀速跑动，Kyon以速度B匀速跑动。他们在经过多长时间后可以再次相遇？ Input多组数据，第一行为一个整数T (1 ≤ T ≤ 106)，表示数据组数。 之后每行是一组数据，有三个整数C, A, B (1 ≤ C, A, B ≤ 109, A ≠ B)，分别表示环形跑道的长度，Nagato的速度和Kyon的速度。 Output每行输出一个数，表示再次相遇所需的时间。绝对误差或相对误差小于10−5则认为是正确的。 Sample Input2 3 1 2 5 10 7 Sample Output3.00000000 1.66666667 HintSourceAuthorYuki Nagato 题目大意如题 解题思路水题，追击运动一圈 解题代码1234567891011121314151617181920212223242526272829303132333435363738394041#include &lt;cstdio&gt;#include &lt;cstring&gt;#include &lt;iostream&gt;#include &lt;iomanip&gt;#include &lt;cmath&gt;#include &lt;sstream&gt;#include &lt;set&gt;#include &lt;vector&gt;#include &lt;stack&gt;#include &lt;queue&gt;#include &lt;map&gt;#include &lt;algorithm&gt;#define rep(i,a,n) for(int i=a;i&lt;n;++i) #define per(i,a,n) for(int i=n-1;i&gt;=a;--i)#define ms(x,a) memset((x),a,sizeof(x))#define pb push_back#define np next_permutation#define mp make_pair#define INF 0x3f3f3f3f#define eps 1e-8#define all(x) x.begin(),x.end()#define ins(x) inserter(x,x.begin())#define mod 1000000005#define K 20using namespace std;const int maxn=1e2+5;const int maxl=26;const int maxm=1e5+5;typedef long long ll;ll t,n,a;int c[K];int main()&#123; scanf("%lld",&amp;t); while(t--)&#123; int a,b,c; scanf("%d%d%d",&amp;a,&amp;b,&amp;c); if(b&lt;c) swap(b,c); double ans=double(a)/(b-c); printf("%f\n",ans); &#125;&#125; 收获与反思水题]]></content>
      <categories>
        <category>编程</category>
        <category>ACM</category>
      </categories>
      <tags>
        <tag>ACM</tag>
        <tag>算法</tag>
        <tag>CSU</tag>
        <tag>2018暑假集训</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[【UVA-12100】解题报告（STL，queue）]]></title>
    <url>%2Fpost%2Fc1864474.html</url>
    <content type="text"><![CDATA[原始题目 题目大意学生会里的打印机打印量巨大。现在给打印任务分配一个1到9的优先级，优先级越高表示任务越着急。 打印机的工作方式如下：首先从打印队列里取出一个任务J，如果队列里有比J更急的任务，则直接把J放到打印队列尾部，否则打印任务J（此时不会把它放到打印队列） 输入打印队列中各个任务的优先级，给定你的任务的序号，假定只有打印每个任务的时候耗时1分钟，问完成你的任务时总耗时是多少。 解题思路 利用set模拟，维护一下当前最大优先级和各优先级的任务数即可。 解题代码1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859#include &lt;cstdio&gt;#include &lt;cstring&gt;#include &lt;cmath&gt;#include &lt;iostream&gt;#include &lt;iomanip&gt;#include &lt;set&gt;#include &lt;queue&gt;#include &lt;map&gt;#include &lt;algorithm&gt;#include &lt;vector&gt;#define rep(i,a,n) for(int i=a;i&lt;n;++i)#define per(i,a,n) for(int i=n-1;i&gt;=a;--i)#define cl(x,a) memset(x,a,sizeof(x))#define all(x) x.begin(),x.end()#define pb push_back#define np next_permutation#define mp make_pair#define fi first#define se second#define INF 0x3f3f3f3f#define eps 1e-8using namespace std;const int maxn=1e5+5;const int maxl=26;const int maxm=1e5+5;typedef long long ll;typedef vector&lt;int&gt; vi;typedef pair&lt;int,int&gt; pii;int num[100];int main()&#123; ios::sync_with_stdio(false); int t,n,m,l,mmax=0; cin&gt;&gt;t; while(t--)&#123; cin&gt;&gt;n&gt;&gt;m;//自己得任务是m号 queue&lt;pii&gt; q; cl(num,0); rep(i,0,n)&#123; cin&gt;&gt;l; mmax=max(mmax,l); q.push(mp(i,l)); num[l]++; &#125; int ans=0; while(!q.empty())&#123; pii temp=q.front();q.pop(); if(temp.second&lt;mmax)&#123; q.push(temp); &#125; else&#123; ans++; if(!(--num[mmax])) while(!(num[mmax]) &amp;&amp; mmax)&#123;mmax--;&#125; if(temp.first==m) &#123;cout&lt;&lt;ans&lt;&lt;endl;break;&#125; &#125; &#125; &#125; &#125; 收获与反思 加快码速，秒之s]]></content>
      <categories>
        <category>编程</category>
        <category>ACM</category>
      </categories>
      <tags>
        <tag>ACM</tag>
        <tag>算法</tag>
        <tag>2018暑假集训</tag>
        <tag>STL</tag>
        <tag>UVA</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[【UVA-1595】解题报告（STL,Vector）]]></title>
    <url>%2Fpost%2Fa7528411.html</url>
    <content type="text"><![CDATA[原始题目 题目大意给出平面上N个点，问是否可以找到一条竖线，使得所有点左右对称。 解题思路纵坐标离散化后求每行得平均数，判断一下 解题代码1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465666768697071727374757677787980#include &lt;cstdio&gt;#include &lt;cstring&gt;#include &lt;cmath&gt;#include &lt;iostream&gt;#include &lt;iomanip&gt;#include &lt;set&gt;#include &lt;queue&gt;#include &lt;map&gt;#include &lt;algorithm&gt;#include &lt;vector&gt;#define rep(i,a,n) for(int i=a;i&lt;n;++i)#define per(i,a,n) for(int i=n-1;i&gt;=a;--i)#define cl(x,a) memset(x,a,sizeof(x))#define all(x) x.begin(),x.end()#define pb push_back#define np next_permutation#define mp make_pair#define fi first#define se second#define INF 0x3f3f3f3f#define eps 1e-8using namespace std;const int maxn=1e5+5;const int maxl=26;typedef long long ll;typedef vector&lt;int&gt; vi;typedef pair&lt;int,int&gt; pii;vector&lt;pii&gt; v0;vi v[1005];double ans[1005];bool cmp(pii a,pii b)&#123; if(a.first!=b.first) return a.first&lt;b.first; else return a.second&lt;b.second;&#125;int t,n,a,b;int main()&#123; ios::sync_with_stdio(false); cin&gt;&gt;t; while(t--)&#123; rep(i,0,1005) v[i].clear(); v0.clear(); cin&gt;&gt;n; rep(i,0,n) &#123;cin&gt;&gt;b&gt;&gt;a; v0.pb(mp(a,b));&#125; sort(all(v0),cmp);// rep(i,0,n) // &#123;// cout&lt;&lt;v0[i].fi&lt;&lt;" "&lt;&lt;v0[i].se&lt;&lt;endl;// &#125; int temp=INF,cnt=-1,sum=0; rep(i,0,n)&#123; if(temp!=v0[i].first)&#123; if(cnt!=-1)&#123; ans[cnt]=(double)sum/v[cnt].size();// cout&lt;&lt;"ave["&lt;&lt;cnt&lt;&lt;"]="&lt;&lt;ans[cnt]&lt;&lt;endl; &#125; temp=v0[i].first; cnt++; v[cnt].pb(v0[i].second); sum=v0[i].second; &#125; else &#123;v[cnt].pb(v0[i].second);sum+=v0[i].second;&#125; &#125; ans[cnt]=(double)sum/v[cnt].size(); cnt++; int flag=1; rep(i,1,cnt)&#123;// cout&lt;&lt;"ave["&lt;&lt;i&lt;&lt;"]="&lt;&lt;ans[i]&lt;&lt;endl; if(abs(ans[i]-ans[i-1])&gt;eps)&#123; flag=0; cout&lt;&lt;"NO"&lt;&lt;endl; break; &#125; &#125; if(flag) cout&lt;&lt;"YES"&lt;&lt;endl; &#125;&#125; 收获与反思 加快码速，秒之]]></content>
      <categories>
        <category>编程</category>
        <category>ACM</category>
      </categories>
      <tags>
        <tag>ACM</tag>
        <tag>算法</tag>
        <tag>2018暑假集训</tag>
        <tag>STL</tag>
        <tag>UVA</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[【UVA-10391】解题报告（STL）]]></title>
    <url>%2Fpost%2F4d6a6b27.html</url>
    <content type="text"><![CDATA[原始题目 题目大意给出一个字典，找出所有的复合单词，即恰好有两个单词连接而成的单词。输入已按照字典序从小到大排序，且不超过120000个单词，输出所有复合词，按照字典序从小到大排序。 解题思路substring秒过 解题代码1234567891011121314151617181920212223242526272829303132333435363738#include &lt;cstdio&gt;#include &lt;cstring&gt;#include &lt;string&gt;#include &lt;iostream&gt;#include &lt;set&gt;#include &lt;queue&gt;#include &lt;algorithm&gt;#include &lt;map&gt;#include &lt;vector&gt;#include &lt;iomanip&gt;#include &lt;cmath&gt;using namespace std;const int maxn=2e5+5;set &lt;string&gt; s;vector &lt;string&gt; all;string a;int n; int main()&#123; while(cin&gt;&gt;a)&#123; s.insert(a); &#125; set &lt;string&gt; ::iterator it; for(it=s.begin();it!=s.end();it++)&#123; int len=(*it).size(); for(int i=1;i&lt;len;i++)&#123; //遍历每个单词从头到尾 string pre=(*it).substr(0,i); string sub=(*it).substr(i,len-i); if(s.count(pre) &amp;&amp; s.count(sub))&#123; cout&lt;&lt;*it&lt;&lt;endl; break; &#125; &#125; &#125; &#125; 收获与反思 熟悉函数 string::substr() 第一个参数为起始位置，第二个参数为长度。]]></content>
      <categories>
        <category>编程</category>
        <category>ACM</category>
      </categories>
      <tags>
        <tag>ACM</tag>
        <tag>算法</tag>
        <tag>2018暑假集训</tag>
        <tag>STL</tag>
        <tag>UVA</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[【UVA-10763】解题报告（STL）]]></title>
    <url>%2Fpost%2F31a770a5.html</url>
    <content type="text"><![CDATA[原始题目 题目大意有n个学生想交换到其他学校学习。为了简单起见，规定每个象从A学校换到B学校的学生必须找一个想从B学校换到A的“搭档”。如果每个人都能找到搭档（一个人不能找多个搭档），学校就会同意他们交换。每个学生用两个整数A、B表示，你的任务是判断交换是否可以进行。 解题思路 利用multimap（多重映射）对于一组键、值对，查找有没有对应值为键，键为值得的映射，有则删除，没有的话把当前的键、值对加入multimap。最后检查是否为空 网上还有一种虽然简单优雅但是有漏洞的解法，初始赋值$ans[i]=i$输入一组$a,b$，$swap(ans[a],ans[b])$，最后检查是否复合原状态（一一匹配的话两次反转复原），不过这个解法没有考虑到三方交换的情况（即$swap(a,b),swap(b,c),swap(c,a)$）其实这是不满足题意的，但也会判YES。所以说有漏洞。 解题代码 multimap 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354#include &lt;cstdio&gt;#include &lt;cstring&gt;#include &lt;iostream&gt;#include &lt;iomanip&gt;#include &lt;cmath&gt; #include &lt;set&gt;#include &lt;vector&gt;#include &lt;string&gt;#include &lt;algorithm&gt;#include &lt;map&gt;#include &lt;sstream&gt;#include &lt;bits/stdc++.h&gt;#define rep(i,a,n) for(int i=a;i&lt;n;++i)#define per(i,a,n) for(int i=n-a;i&gt;=a;--i)#define cl(x,a) memset(x,a,sizeof(x))#define all(x) x.begin(),x.end()#define pb push_back#define np next_permutation#define mp make_pair#define INF 0x3f3f3f3f#define eps 1e-8#define K 1001#define fi first#define se secondusing namespace std;const int maxn=1e5+5;typedef vector&lt;int&gt; vi;typedef multimap &lt;int,int&gt;::const_iterator cit;int main()&#123; ios::sync_with_stdio(false); int n,a,b; while(cin&gt;&gt;n &amp;&amp; n)&#123; multimap &lt;int,int&gt; mmp; rep(i,0,n)&#123; cin&gt;&gt;a&gt;&gt;b; typedef pair&lt;cit,cit&gt; Range; Range range=mmp.equal_range(b); int flag=0; cit j=range.first; for(;j!=range.second;++j)&#123; if(j-&gt;second==a)&#123; flag=1; break; &#125; &#125; if(flag) mmp.erase(j); else mmp.insert(mp(a,b)); &#125; if(mmp.size()==0) cout&lt;&lt;"YES"&lt;&lt;endl; else cout&lt;&lt;"NO"&lt;&lt;endl; &#125;&#125; 朴素法（有漏洞） 123456789101112131415161718192021222324252627282930313233343536373839#include &lt;cstdio&gt;#include &lt;cstring&gt;#include &lt;iostream&gt;#include &lt;iomanip&gt;#include &lt;cmath&gt; #include &lt;set&gt;#include &lt;vector&gt;#include &lt;string&gt;#include &lt;algorithm&gt;#include &lt;map&gt;#include &lt;sstream&gt;#include &lt;bits/stdc++.h&gt;#define rep(i,a,n) for(int i=a;i&lt;n;++i)#define per(i,a,n) for(int i=n-a;i&gt;=a;--i)#define cl(x,a) memset(x,a,sizeof(x))#define all(x) x.begin(),x.end()#define pb push_back#define np next_permutation#define mp make_pair#define INF 0x3f3f3f3f#define eps 1e-8#define K 1001#define fi first#define se secondusing namespace std;const int maxn=5e5+5;int ans[maxn];int main()&#123; ios::sync_with_stdio(false); int n; while(cin&gt;&gt;n &amp;&amp; n)&#123; int flag=0; rep(i,1,n+1) ans[i]=i; rep(i,1,n+1) &#123;int a,b; cin&gt;&gt;a&gt;&gt;b; swap(ans[a],ans[b]);&#125; rep(i,1,n+1) &#123;if(ans[i]!=i) &#123;flag=1;break;&#125;&#125; if(flag) cout&lt;&lt;"NO"&lt;&lt;endl; else cout&lt;&lt;"YES"&lt;&lt;endl; &#125;&#125; 收获与反思 交换复原思想值得学习]]></content>
      <categories>
        <category>编程</category>
        <category>ACM</category>
      </categories>
      <tags>
        <tag>ACM</tag>
        <tag>算法</tag>
        <tag>2018暑假集训</tag>
        <tag>STL</tag>
        <tag>UVA</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[【UVA-10935】解题报告（STL，模拟）]]></title>
    <url>%2Fpost%2F26fa4dfc.html</url>
    <content type="text"><![CDATA[原始题目 题目大意桌上有n(n≤50) 张牌，从顶面开始，从上往下编号1到n。当至少剩下两张牌时进行以下操作： 把第一张牌扔掉，然后把新的第一张牌放到整叠牌的最后。 输入每行一个n，输出每次扔掉的牌以及最后剩下的牌。 解题思路 利用queue模拟操作，注意只有1张牌的时候特判。 解题代码1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950#include &lt;cstdio&gt;#include &lt;cstring&gt;#include &lt;iostream&gt;#include &lt;iomanip&gt;#include &lt;cmath&gt; #include &lt;set&gt;#include &lt;vector&gt;#include &lt;string&gt;#include &lt;algorithm&gt;#include &lt;map&gt;#include &lt;sstream&gt;#include &lt;bits/stdc++.h&gt;#define rep(i,a,n) for(int i=a;i&lt;n;++i)#define per(i,a,n) for(int i=n-a;i&gt;=a;--i)#define cl(x,a) memset(x,a,sizeof(x))#define all(x) x.begin(),x.end()#define pb push_back#define np next_permutation#define mp make_pair#define INF 0x3f3f3f3f#define eps 1e-8#define K 1001#define fi first#define se secondusing namespace std;const int maxn=1e5+5;int n;int main()&#123; ios::sync_with_stdio(false); while(cin&gt;&gt;n &amp;&amp;n)&#123; if(n==1)&#123; //1的时候特判 cout&lt;&lt;"Discarded cards:"&lt;&lt;endl; cout&lt;&lt;"Remaining card: 1"&lt;&lt;endl; continue; &#125; cout&lt;&lt;"Discarded cards: "; queue &lt;int&gt; q; rep(i,1,n+1) q.push(i); while(q.size()&gt;2)&#123; int top=q.front(); q.pop(); cout&lt;&lt;top&lt;&lt;", "; top=q.front();q.pop(); q.push(top); &#125; int top=q.front();q.pop(); cout&lt;&lt;top&lt;&lt;endl&lt;&lt;"Remaining card: "&lt;&lt;q.front()&lt;&lt;endl; &#125;&#125;]]></content>
      <categories>
        <category>编程</category>
        <category>ACM</category>
      </categories>
      <tags>
        <tag>ACM</tag>
        <tag>算法</tag>
        <tag>Imitation</tag>
        <tag>STL</tag>
        <tag>UVA</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[【UVA-11401】解题报告（数学，求和公式）]]></title>
    <url>%2Fpost%2F23f72a93.html</url>
    <content type="text"><![CDATA[原始题目 题目大意有长度分别为$1,2,3,4 \cdots n$ 的木杆各一根，问共可以组成多少个三角形。 解题思路 设$f[x]$ 表示以$x$为最长边的三角形的个数。 设另两条边为$y,z$，易知$y+z&gt;x$，所以$x-z]]></content>
      <categories>
        <category>编程</category>
        <category>ACM</category>
      </categories>
      <tags>
        <tag>ACM</tag>
        <tag>算法</tag>
        <tag>2018暑假集训</tag>
        <tag>补图</tag>
        <tag>UVA</tag>
        <tag>数学</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[【UVA-11538】解题报告（数学，组合数）]]></title>
    <url>%2Fpost%2F89873dd3.html</url>
    <content type="text"><![CDATA[原始题目 题目大意在$n \times m$的棋盘上放置$2$个皇后（一黑一白），问相互攻击的情况共有多少种。 解题思路 根据加法原理，总情况由下面三种子情况构成（覆盖全部切不重复）（n&lt;m) 两个皇后在同一行，情况数为$nm(m-1)$ 两个皇后在同一列，情况数为$mn(n-1)$ 两个皇后在同一斜行，情况数为$2 \times (2 \sum_{i=1}^{n-1}{i(i-1)} + (m+1-n)n(n-1)) = 2 \times( (2 \frac {n(n-1)(2n-4)}{6} )+(m-n+1)n(n-1))$ 相加即可 解题代码123456789101112131415161718192021222324252627282930313233343536373839#include &lt;cstdio&gt;#include &lt;cstring&gt;#include &lt;cmath&gt;#include &lt;iostream&gt;#include &lt;iomanip&gt;#include &lt;set&gt;#include &lt;queue&gt;#include &lt;map&gt;#include &lt;stack&gt;#include &lt;algorithm&gt;#include &lt;vector&gt;#include &lt;string&gt;#include &lt;sstream&gt;#define rep(i,a,n) for(int i=a;i&lt;n;++i)#define per(i,a,n) for(int i=n-a;i&gt;=a;--i)#define se second#define fi first#define eps 1e-8#define INF 0x3f3f3f3fusing namespace std;const int maxn=1e5+5;const int maxl=26;const int maxm=1e5+5;typedef long long ll;typedef unsigned long long ull;typedef vector&lt;int&gt; vi;typedef pair&lt;int,int&gt; pii;ll n,m;int main()&#123; ios::sync_with_stdio(false); while(cin&gt;&gt;n&gt;&gt;m&amp;&amp;n+m)&#123; if(n&gt;m) swap(n,m); ll ans=(n*m*(m-1) ); ans+=(m*n*(n-1)); ans+=(2*(n*(n-1)*(2*n-4)/6)+(m-n+1)*n*(n-1))*2; cout&lt;&lt;ans&lt;&lt;endl; &#125;&#125; 收获与反思 熟悉排列组合的加法原理与乘法原理 两个求和公式以及简单叠加 \sum {i=1}^n i = \frac {n(n+1)}{2}\sum {i=1}^n {i^2} = \frac {n(n+1)(2n+1)}{6}推导出 \sum {i=1}^n {i(i-1)} = \frac {n(n+1)(n-1)}{3}]]></content>
      <categories>
        <category>编程</category>
        <category>ACM</category>
      </categories>
      <tags>
        <tag>ACM</tag>
        <tag>算法</tag>
        <tag>2018暑假集训</tag>
        <tag>补图</tag>
        <tag>UVA</tag>
        <tag>数学</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[【HDU-1808】解题报告（数论，鸽巢定理）]]></title>
    <url>%2Fpost%2Fe583ed8d.html</url>
    <content type="text"><![CDATA[原始题目Halloween treats Time Limit: 1000/1000 MS (Java/Others) Memory Limit: 32768/32768 K (Java/Others) Total Submission(s): 1366 Accepted Submission(s): 560 Special Judge Problem DescriptionEvery year there is the same problem at Halloween: Each neighbour is only willing to give a certain total number of sweets on that day, no matter how many children call on him, so it may happen that a child will get nothing if it is too late. To avoid conflicts, the children have decided they will put all sweets together and then divide them evenly among themselves. From last year’s experience of Halloween they know how many sweets they get from each neighbour. Since they care more about justice than about the number of sweets they get, they want to select a subset of the neighbours to visit, so that in sharing every child receives the same number of sweets. They will not be satisfied if they have any sweets left which cannot be divided. Your job is to help the children and present a solution. InputThe input contains several test cases. The first line of each test case contains two integers c and n (1 ≤ c ≤ n ≤ 100000), the number of children and the number of neighbours, respectively. The next line contains n space separated integers a1 , … , an (1 ≤ ai ≤ 100000 ), where ai represents the number of sweets the children get if they visit neighbour i. The last test case is followed by two zeros. OutputFor each test case output one line with the indices of the neighbours the children should select (here, index i corresponds to neighbour i who gives a total number of ai sweets). If there is no solution where each child gets at least one sweet, print “no sweets” instead. Note that if there are several solutions where each child gets at least one sweet, you may print any of them. Sample Input4 5 1 2 3 7 5 3 6 7 11 2 5 13 17 0 0 Sample Output3 5 2 3 4 SourceHDOJ 2007 Summer Exercise（1） Recommendlinle 题目大意题目大意，万圣节孩子们去要糖果。给定孩子数$c$，和邻居数$n$，且$n&gt;c$。每个邻居家里有糖果$a_i$，孩子们希望能找到一些家庭他们的糖果数恰好时能被$c$整除，问是否存在，不存在输出“no sweets”，存在的话输出邻居的编号。 解题思路由于$n&gt;c$，求前缀和数组sum，对于严格单调增的n个前缀和，由于鸽巢原理，必然存在至少两个模c同余。 解题代码]]></content>
      <categories>
        <category>编程</category>
        <category>ACM</category>
      </categories>
      <tags>
        <tag>ACM</tag>
        <tag>算法</tag>
        <tag>2018暑假集训</tag>
        <tag>数论</tag>
        <tag>HDU</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[【UVA-12096】解题报告（STL，stack，模拟）]]></title>
    <url>%2Fpost%2Fa1cef007.html</url>
    <content type="text"><![CDATA[原始题目 题目大意有一个储存集合的栈，有五种操作。 压入空集合 将栈顶集合复制再加入栈 出栈栈顶两个集合，取交集后入栈 出栈栈顶两个集合，取并集后入栈 出栈栈顶两个集合，将最顶端的集合加入到次顶的集合中 给出操作，最后输出栈顶集合的元素个数。 解题思路利用set的数据结构+模拟 集合储存内部集合的编号，空集合就没有编号。 利用map把集合映射成ID，对于每个ADD操作后的新集合查找映射，没有就赋值。 模拟操作最后输出栈顶的size即可。 解题代码12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364656667686970717273747576777879808182#include &lt;cstdio&gt;#include &lt;cstring&gt;#include &lt;cmath&gt;#include &lt;iostream&gt;#include &lt;iomanip&gt;#include &lt;set&gt;#include &lt;queue&gt;#include &lt;stack&gt;#include &lt;vector&gt;#include &lt;map&gt;#include &lt;string&gt;#include &lt;sstream&gt;#include &lt;bits/stdc++.h&gt;#define rep(i,a,n) for(int i=a;i&lt;n;++i)#define per(i,a,n) for(int i=n-1;i&gt;=a;--i);#define ms(x,a) memset((x),a,sizeof((x))) #define all(x) x.begin(),x.end()#define ins(x) inserter(x,x.begin()) #define INF 0x3f3f3f3f#define eps 1e-8#define fi first#define e 2.718281828459045235360287471352662497757247093699959574966967627724076630353 #define se second#define mp make_pair#define pb push_back#define np next_permutation#define gapline cout&lt;&lt;"##======================##"&lt;&lt;endlusing namespace std;const int maxn=1e5+5;const int maxl=26;const int maxm=1e5+5;typedef long long ll;typedef unsigned long long ull;typedef set&lt;int&gt; si;map &lt;si,int&gt; IDcache; //把集合映射成IDvector &lt;si&gt; sicache; int t,n;// 查找给定集合x的ID。如果找不到，分配一个新的IDint ID(si x)&#123; if(IDcache.count(x)) return IDcache[x]; sicache.pb(x); //添加新的集合// cout&lt;&lt;"new="&lt;&lt;sicache.size()-1&lt;&lt;endl; return IDcache[x]=sicache.size()-1; //返回新的id // id 都是从 0 开始的 &#125; stack &lt;int&gt; s;//建立栈s， 里面储存不同集合的idint main()&#123; ios::sync_with_stdio(false); cin&gt;&gt;t; while(t--)&#123; while(!s.empty()) s.pop(); sicache.clear(); IDcache.clear(); cin&gt;&gt;n; string op; rep(i,0,n)&#123; cin&gt;&gt;op; if(op[0]=='P') s.push(ID(si())); //调用默认构造函数构造空集合，作为参数传给ID，判断有没有该集合，然后返回id else if(op[0]=='D') s.push(s.top()); //复制一个添加到栈顶 else&#123; si x1=sicache[s.top()];s.pop(); si x2=sicache[s.top()];s.pop(); si x;// cout&lt;&lt;"x1="&lt;&lt;ID(x1)&lt;&lt;" x2="&lt;&lt;ID(x2)&lt;&lt;endl; if(op[0]=='U') set_union(all(x1),all(x2),ins(x)); if(op[0]=='I') set_intersection(all(x1),all(x2),ins(x)); if(op[0]=='A') &#123; x=x2; x.insert(ID(x1)); &#125; s.push(ID(x)); &#125; cout&lt;&lt;sicache[s.top()].size()&lt;&lt;endl; &#125; cout&lt;&lt;"***"&lt;&lt;endl; &#125; &#125; 收获与反思 紫书说思想很重要]]></content>
      <categories>
        <category>编程</category>
        <category>ACM</category>
      </categories>
      <tags>
        <tag>ACM</tag>
        <tag>算法</tag>
        <tag>Imitation</tag>
        <tag>2018暑假集训</tag>
        <tag>补图</tag>
        <tag>STL</tag>
        <tag>UVA</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[【UVA-540】解题报告（STL，queue，模拟）]]></title>
    <url>%2Fpost%2F686dc27c.html</url>
    <content type="text"><![CDATA[原始题目 题目大意团队队列，给定n个团队每个团队的人员，对于一个整体队列，有入队出队两种操作。 入队：如果长队列中有将要入队成员的同团队成员，则该成员插入到同团队成员的最后方，如果没有，则插入整个队伍最后方。 出队：整体队列的队首人员出列。 解题思路 先map到自己的团队号。 建立不同团队的人员队列和团队队列（储存团队号），入队操作时检查本团队的人员队列是否为空，如果为空。那么就在团队队列插入该成员的团队号，然后本队队列入队该成员。不为空的话只在本队队列入队即可。出队操作检查出队成员所在本队队列是否为空，为空就在团队队列中也出队队伍号。 解题代码1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465666768697071727374#include &lt;cstdio&gt;#include &lt;cstring&gt;#include &lt;cmath&gt;#include &lt;iostream&gt;#include &lt;iomanip&gt;#include &lt;set&gt;#include &lt;queue&gt;#include &lt;stack&gt;#include &lt;vector&gt;#include &lt;map&gt;#include &lt;string&gt;#include &lt;sstream&gt;#include &lt;bits/stdc++.h&gt;#define rep(i,a,n) for(int i=a;i&lt;n;++i)#define per(i,a,n) for(int i=n-1;i&gt;=a;--i);#define ms(x,a) memset((x),a,sizeof((x))) #define all(x) x.begin(),x.end()#define ins(x) inserter(x,x.begin()) #define INF 0x3f3f3f3f#define eps 1e-8#define fi first#define e 2.718281828459045235360287471352662497757247093699959574966967627724076630353 #define se second#define mp make_pair#define pb push_back#define np next_permutation#define gapline cout&lt;&lt;"##======================##"&lt;&lt;endlusing namespace std;const int maxn=1e3+5;const int maxl=26;const int maxm=1e5+5;typedef long long ll;typedef unsigned long long ull;//团体队列 一个q储存团体序号， q2[i]表示i团体内的队列 // 出队时 q2[q[front]] 为空时 q.pop();// 入队时 q2[mp[number]]非空时直接插队尾， 空时 插队尾同时q.push(mp[number]) int t,n,kase;map&lt;int,int&gt; mmp;int main()&#123; ios::sync_with_stdio(false); while(cin&gt;&gt;t&amp;&amp;t)&#123; cout&lt;&lt;"Scenario #"&lt;&lt;++kase&lt;&lt;endl; mmp.clear(); int x; rep(i,0,t)&#123; cin&gt;&gt;n; rep(j,0,n)&#123; cin&gt;&gt;x; mmp[x]=i; &#125; &#125; queue&lt;int&gt; q,q2[maxn]; //q为团队队列 q2[i] 为i团队队内队列 string c; while(cin&gt;&gt;c &amp;&amp; c[0]!='S')&#123; if(c[0]=='E')&#123; cin&gt;&gt;x; int id=mmp[x]; if(q2[id].empty())&#123; q.push(id); &#125; q2[id].push(x); &#125; else&#123; int num=q2[q.front()].front(); cout&lt;&lt;num&lt;&lt;endl; q2[q.front()].pop(); if(q2[q.front()].empty()) q.pop(); &#125; &#125; cout&lt;&lt;endl; &#125;&#125; 收获与反思合理利用已有的数据结构]]></content>
      <categories>
        <category>编程</category>
        <category>ACM</category>
      </categories>
      <tags>
        <tag>ACM</tag>
        <tag>算法</tag>
        <tag>2018暑假集训</tag>
        <tag>补图</tag>
        <tag>STL</tag>
        <tag>UVA</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[【UVA-136】解题报告（STL，set，优先队列）]]></title>
    <url>%2Fpost%2F1b7db6f0.html</url>
    <content type="text"><![CDATA[原始题目 题目大意因子只包含2，3，5的称为丑数，打印第1500个丑数。 解题思路 优先队列维护，每次拓展2，3，5添加到优先队列中。 解题代码123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051#include &lt;cstdio&gt;#include &lt;cstring&gt;#include &lt;cmath&gt;#include &lt;iostream&gt;#include &lt;iomanip&gt;#include &lt;set&gt;#include &lt;queue&gt;#include &lt;stack&gt;#include &lt;vector&gt;#include &lt;map&gt;#include &lt;string&gt;#include &lt;sstream&gt;#include &lt;bits/stdc++.h&gt;#define rep(i,a,n) for(int i=a;i&lt;n;++i)#define per(i,a,n) for(int i=n-1;i&gt;=a;--i);#define ms(x,a) memset((x),a,sizeof((x))) #define all(x) x.begin(),x.end()#define ins(x) inserter(x,x.begin()) #define INF 0x3f3f3f3f#define eps 1e-8#define fi first#define e 2.718281828459045235360287471352662497757247093699959574966967627724076630353 #define se second#define mp make_pair#define pb push_back#define np next_permutation#define gapline cout&lt;&lt;"##======================##"&lt;&lt;endlusing namespace std;const int maxn=1e5+5;typedef long long ll;const int coeff[3]=&#123;2,3,5&#125;;int main()&#123; priority_queue&lt;ll,vector&lt;ll&gt;, greater&lt;ll&gt; &gt; pq; set&lt;ll&gt;s; pq.push(1); s.insert(1); for(int i=1;;i++)&#123; ll x=pq.top();pq.pop(); if(i==1500)&#123; cout&lt;&lt;"The 1500'th ugly number is "&lt;&lt;x&lt;&lt;".\n"; break; &#125; rep(j,0,3)&#123; ll x2=coeff[j]*x; if(!s.count(x2)) &#123;pq.push(x2);s.insert(x2);&#125; &#125; &#125;&#125; 收获与反思 水题]]></content>
      <categories>
        <category>编程</category>
        <category>ACM</category>
      </categories>
      <tags>
        <tag>ACM</tag>
        <tag>算法</tag>
        <tag>2018暑假集训</tag>
        <tag>补图</tag>
        <tag>STL</tag>
        <tag>UVA</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[【UVA-156】解题报告（STL，map）]]></title>
    <url>%2Fpost%2Feb9ab36.html</url>
    <content type="text"><![CDATA[原始题目 题目大意输入一些单词，找出所有满足下列条件的单词：不区分大小写后不能通过重排得到文本中另一个单词。，按字典序输出复合条件的原单词。 解题思路 利用set储存每个输入单词（自动按字典序排序），将每个单词标准化后其映射值+1。 遍历set输出标准化后映射值为1（只出现过一次）的单词。 解题代码12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455#include &lt;cstdio&gt;#include &lt;cstring&gt;#include &lt;cmath&gt;#include &lt;iostream&gt;#include &lt;iomanip&gt;#include &lt;set&gt;#include &lt;queue&gt;#include &lt;stack&gt;#include &lt;vector&gt;#include &lt;string&gt;#include &lt;sstream&gt;#include &lt;bits/stdc++.h&gt;#define rep(i,a,n) for(int i=a;i&lt;n;++i)#define per(i,a,n) for(int i=n-1;i&gt;=a;--i);#define ms(x,a) memset((x),a,sizeof((x))) #define INF 0x3f3f3f3f#define eps 1e-8#define fi first#define e 2.718281828459045235360287471352662497757247093699959574966967627724076630353 #define se second#define mp make_pair#define pb push_back#define np next_permutation#define gapline cout&lt;&lt;"##======================##"&lt;&lt;endlusing namespace std;const int maxn=1e5+5;const int maxl=26;const int maxm=1e5+5;string s;set&lt;string&gt; ans;map&lt;string,int&gt; mmp;int main()&#123; ios::sync_with_stdio(false); while(cin&gt;&gt;s&amp;&amp;s[0]!='#')&#123; ans.insert(s); string temp=s; rep(i,0,temp.length())&#123; if(isupper(temp[i])) temp[i]=temp[i]-'A'+'a'; &#125; sort(temp.begin(),temp.end()); mmp[temp]++; &#125; set&lt;string&gt;::iterator it; for(it=ans.begin();it!=ans.end();it++)&#123; string temp=*it; rep(i,0,temp.length())&#123; if(isupper(temp[i])) temp[i]=temp[i]-'A'+'a'; &#125; sort(temp.begin(),temp.end()); if(mmp[temp]==1) cout&lt;&lt;*it&lt;&lt;endl; &#125; &#125; 收获与反思 寒假入门的时候做过，现在回来再快速秒之]]></content>
      <categories>
        <category>编程</category>
        <category>ACM</category>
      </categories>
      <tags>
        <tag>ACM</tag>
        <tag>算法</tag>
        <tag>2018暑假集训</tag>
        <tag>补图</tag>
        <tag>STL</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[【HDU-2048】解题报告（递推，DP，数论，错排）]]></title>
    <url>%2Fpost%2F184fc5c7.html</url>
    <content type="text"><![CDATA[原始题目神、上帝以及老天爷 Time Limit: 2000/1000 MS (Java/Others) Memory Limit: 65536/32768 K (Java/Others) Total Submission(s): 50425 Accepted Submission(s): 20379 Problem DescriptionHDU 2006’10 ACM contest的颁奖晚会隆重开始了！为了活跃气氛，组织者举行了一个别开生面、奖品丰厚的抽奖活动，这个活动的具体要求是这样的： 首先，所有参加晚会的人员都将一张写有自己名字的字条放入抽奖箱中；然后，待所有字条加入完毕，每人从箱中取一个字条；最后，如果取得的字条上写的就是自己的名字，那么“恭喜你，中奖了！”大家可以想象一下当时的气氛之热烈，毕竟中奖者的奖品是大家梦寐以求的Twins签名照呀！不过，正如所有试图设计的喜剧往往以悲剧结尾，这次抽奖活动最后竟然没有一个人中奖！ 我的神、上帝以及老天爷呀，怎么会这样呢？ 不过，先不要激动，现在问题来了，你能计算一下发生这种情况的概率吗？ 不会算？难道你也想以悲剧结尾？！ Input输入数据的第一行是一个整数C,表示测试实例的个数，然后是C 行数据，每行包含一个整数$n(1&lt;n≤20)$,表示参加抽奖的人数。 Output对于每个测试实例，请输出发生这种情况的百分比，每个实例的输出占一行, 结果保留两位小数(四舍五入)，具体格式请参照sample output。 Sample Input1 2 Sample Output50.00% Authorlcy Source递推求解专题练习（For Beginner） Recommendlcy 题目大意如题 解题思路 DP 手动写一下如何安排参加人员都不中奖就可以发现规律。$D[i]$表示i个人符合要求的方案数目 比如计算dp[4]时，将1的纸条分给2或3或4，这三种情况下，可以变为解决子问题，比如将1的纸条分给2，之后将2、3、4的纸条分给1、3、4，与dp[3]接近，但是1位置不受限制，即1位置可以放2的纸条，这样又变为dp[2]。 故得到状态转移方程。 D[n]=(n-1)(D[n-1]+D[n-2]) 最后除以总情况数（排列），计算百分数即可。 错排公式 其实本题是一个错排公式题目，我们上面推导出来的$ D[i]=(i-1)(D[i-1]+D[i-2]) $，实际上就是错排公式的一个递推关系。 又因为$D[1]=0,D[2]=1$ 继续推导 \begin{align} D[n] & =(n-1)(D[n-1]+D[n-2]) \\ D[n] - n D[n-1] & = (-1) (D[n-1] - (n-1) D[n-2])\\ D[n] - n D[n-1] & = (-1)^{n-2} (D[2] - 2 D[1]) \\ D[n] & = n D[n-1] + (-1)^{n} \end{align} 如此我们得到了递推关系式，那么求通项公式可以用下面几种方法： 可以用母函数方法求出通项公式（还不会，待学了母函数填坑） 可以用容斥原理 最后得到错排公式为 D[n] = n!( \frac{1}{0!} - \frac{1}{1!} + \frac{1}{2!} - \cdots (-1)^{n} \frac{1}{n!} ) 再补充 简化公式 D(n) = [ \frac{n!}{e} + 0.5 ] 证明相见百度，e是自然对数的底，[x]为x的整数部分。 解题代码 DP 12345678910111213141516171819202122232425262728293031323334353637383940414243#include &lt;cstdio&gt;#include &lt;cstring&gt;#include &lt;iostream&gt;#include &lt;set&gt;#include &lt;algorithm&gt;#include &lt;queue&gt;#include &lt;map&gt;#include &lt;string&gt;#define eps 1e-8#define INF 0x3f3f3f3f#define rep(i,a,n) for(int i=a;i&lt;n;i++)#define per(i,a,n) for(int i=n-1;i&gt;=a;i--)using namespace std;const int maxn=1e5+5;typedef long long ll;ll dp[maxn],A[maxn];void solve()&#123; memset(dp,0,sizeof(dp)); dp[1]=0; dp[2]=1; A[1]=1; A[2]=2; for(ll i=3;i&lt;=20;i++)&#123; dp[i]=(i-1)*(dp[i-1]+dp[i-2]); A[i]=A[i-1]*i; // cout&lt;&lt;dp[i]&lt;&lt;" "&lt;&lt;A[i]&lt;&lt;endl; &#125;&#125;using namespace std;int main()&#123; int t; solve(); while(cin&gt;&gt;t)&#123; rep(i,0,t)&#123; ll a; cin&gt;&gt;a; double ans=(double)dp[a]/(double)A[a];// cout&lt;&lt;"dp[i]"&lt;&lt;dp[a]&lt;&lt;" "&lt;&lt;"A[i]"&lt;&lt;A[a]&lt;&lt;endl; printf("%.2lf%%\n",ans*100); &#125; &#125;&#125; 错排简化公式 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152#include &lt;cstdio&gt;#include &lt;cstring&gt;#include &lt;cmath&gt;#include &lt;iostream&gt;#include &lt;iomanip&gt;#include &lt;set&gt;#include &lt;queue&gt;#include &lt;stack&gt;#include &lt;vector&gt;#include &lt;string&gt;#include &lt;sstream&gt;#include &lt;bits/stdc++.h&gt;#define rep(i,a,n) for(int i=a;i&lt;n;++i)#define per(i,a,n) for(int i=n-1;i&gt;=a;--i);#define ms(x,a) memset((x),a,sizeof((x))) #define INF 0x3f3f3f3f#define eps 1e-8#define fi first#define e 2.718281828459045235360287471352662497757247093699959574966967627724076630353 #define se second#define mp make_pair#define pb push_back#define np next_permutation#define gapline cout&lt;&lt;"##======================##"&lt;&lt;endlusing namespace std;const int maxn=1e5+5;const int maxl=26;const int maxm=1e5+5;typedef long long ll;typedef unsigned long long ull;typedef vector&lt;int&gt; vi;typedef pair&lt;int,int&gt; pii;ll A[maxl];void solve()&#123; A[0]=1; A[1]=1; rep(i,2,maxl) A[i]=A[i-1]*i;&#125;int n; int main()&#123; ios::sync_with_stdio(false); solve(); ll t; cin&gt;&gt;t; while(t--)&#123; cin&gt;&gt;n; double ans=floor((double)A[n]/e+0.5); cout&lt;&lt;fixed&lt;&lt;setprecision(2)&lt;&lt;ans*100/A[n]&lt;&lt;"%"&lt;&lt;endl; &#125; &#125; 收获与反思 注意分析递推公式。手写前几项找规律也可以。 错排公式推导学习 挖坑母函数]]></content>
      <categories>
        <category>编程</category>
        <category>ACM</category>
      </categories>
      <tags>
        <tag>ACM</tag>
        <tag>算法</tag>
        <tag>DP</tag>
        <tag>2018暑假集训</tag>
        <tag>递推</tag>
        <tag>HDU</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[【CSU-1828】解题报告（数论，康托展开逆展开）]]></title>
    <url>%2Fpost%2F3e6878ac.html</url>
    <content type="text"><![CDATA[原始题目1828: Dictionary Time Limit: 2 Sec Memory Limit: 128 Mb Submitted: 202 Solved: 146 DescriptionThe isolated people of MacGuffin Island have a unique culture, and one of the most interesting things about them is their language. Their alphabet consists of the first 9 letters of the Roman alphabet (a, b, c, d, e, f, g, h, i). All of their words are exactly 9 letters long and use each of these 9 letters exactly once. They have a word for every possible permutation of these letters. In the library of their most sacred temple is a dictionary, and each word in their language has its own page. By coincidence they order their words exactly as they would be in ordered in English, so the word ‘abcdefghi’ is on the first page, and the word ‘ihgfedcba’ is on the last. The question is, given a list of random words from the MacGuffin language, can you say on which page of the MacGuffin dictionary each appears? InputThe first line of the input file is a positive integer. This integer tells you how many words will follow. The upper limit for this number is 6000. Every subsequent line contains a single word from the MacGuffin language, so if the first number is 1000 there will be 1000 lines after it, each containing a single word. OutputEach line of output will contain an integer. This integer should be the page number for the corresponding word. Sample Input4 abcdefgih abcdefghi abcdefgih ihgfedcba Sample Output2 1 2 362880 HintSourceACM-ICPC Asia Thailand National On-Site Programming Contest 2015 题目大意输入一个由(a, b, c, d, e, f, g, h, i)各出现一次构成的八位字符串，求其在按字典序排列中的序号。 解题思路看作1-8的排列，利用康托展开输出序号，模板题。 解题代码1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465666768697071727374757677787980818283848586#include &lt;cstdio&gt;#include &lt;cstring&gt;#include &lt;cmath&gt;#include &lt;string&gt;#include &lt;iostream&gt;#include &lt;iomanip&gt;#include &lt;sstream&gt;#include &lt;set&gt;#include &lt;map&gt;#include &lt;queue&gt;#include &lt;vector&gt;#include &lt;bits/stdc++.h&gt;#define INF 0x3f3f3f3f#define eps 1e-8#define mp make_pair#define np next_permutation#define pb push_back#define all(x) x.begin(),x.end()#define rep(i,a,n) for(int i=a;i&lt;n;++i)#define per(i,a,n) for(int i=n-1;i&gt;=a;--i)#define ms(x,a) memset((x),a,sizeof((x))) #define mod 998244353 using namespace std;typedef long long ll;typedef unsigned long long ull;typedef vector&lt;int&gt; vi;typedef pair&lt;int,int&gt; pii;const int maxl=10;const int maxn=1e5+5;int A[maxl];//阶乘； int ans_cantor[maxl];//康托展开数组 bool vis_cantor[maxl];//康托标记数组 string ss;void init()&#123; A[0]=A[1]=1; A[2]=2; rep(i,3,maxl+1) A[i]=A[i-1]*i;&#125;//contar展开，逆展开，数组标号都是从0开始 void cantor(int contar_s[], ll num, int contar_k)&#123;//康托展开，把一个数字num展开成一个数组contar_s，contar_k是数组长度 int t; memset(vis_cantor, 0, sizeof(vis_cantor)); for(int i = 0; i &lt; contar_k; i ++)&#123; t = num / A[contar_k-i-1]; num%=A[contar_k-i-1]; int cnt_cantor=0; rep(j,0,contar_k)&#123; //计算每位的逆序数 cout&lt;&lt;"cnt="&lt;&lt;cnt_cantor&lt;&lt;"t="&lt;&lt;t&lt;&lt;"vis="&lt;&lt;vis_cantor[j]&lt;&lt;endl; if(vis_cantor[j]) continue; if(cnt_cantor==t)&#123; contar_s[i]=j+1,vis_cantor[j]=1;break; &#125; ++cnt_cantor; &#125; &#125; rep(i,0,contar_k) cout&lt;&lt;contar_s[i]&lt;&lt;endl; //输出康拖展开的结果 &#125;ll inv_cantor(int contar_s[], int contar_k)&#123;//康托逆展开，把一个数组contar_s换算成一个数字num int cnt;ll num=0; num = 0; for(int i = 0; i &lt; contar_k; i ++)&#123; cnt = 0; for(int j = i + 1; j &lt; contar_k; j ++)&#123; if(contar_s[i] &gt; contar_s[j]) cnt ++;//判断几个数小于它,即求逆序数。 &#125; num += A[contar_k-i-1] * cnt; &#125; return num;&#125; int main()&#123; ios::sync_with_stdio(false); int t; cin&gt;&gt;t; init(); while(t--)&#123; cin&gt;&gt;ss; rep(i,0,ss.length())&#123; ans_cantor[i]=ss[i]-'a'+1; //这里加不加1都行 &#125; ll num=inv_cantor(ans_cantor,ss.length()); cout&lt;&lt;num+1&lt;&lt;endl; &#125; &#125; 收获与反思 感受模板的力量= =]]></content>
      <categories>
        <category>编程</category>
        <category>ACM</category>
      </categories>
      <tags>
        <tag>ACM</tag>
        <tag>算法</tag>
        <tag>CSU</tag>
        <tag>2018暑假集训</tag>
        <tag>数论</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[【UVA-815】解题报告（贪心，二分）]]></title>
    <url>%2Fpost%2F9eb065c8.html</url>
    <content type="text"><![CDATA[原始题目 题目大意给出$n \times m$个$10 \times 10$底面积柱子的海拔，以及洪水的总体积，计算洪水覆盖后的海拔高度以及覆盖柱子的百分比。 解题思路 首先$n*m$个柱子可以排序后看作一排。 思路一（自己的）：二分猜答案 先判断洪水是否会淹没所有柱子，如果不是的话那么二分下界为最低海拔，上界为最高海拔。二分答案判断 当前海拔下淹没体积是否达到总洪水体积（计算当前淹没体积的时候也需要二分查找，比较繁琐），这个思路 并没有很好的利用海拔随覆盖柱子数增多而增大的性质。 思路二（网络大神）：简化后贪心 先预处理成$1 \times 1$（或者说直接考虑高度），对柱子高度排序后，我们考虑洪水一定是从低到高填充，那么贪心的 让洪水只填充到当前的柱子，直至平均高度不高于下个柱子，这时候就是最终答案。（tql） 解题代码 二分： 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465666768697071727374757677787980818283848586878889#include &lt;cstdio&gt;#include &lt;cstring&gt;#include &lt;cmath&gt;#include &lt;algorithm&gt;#include &lt;set&gt;#include &lt;queue&gt;#include &lt;map&gt;#include &lt;vector&gt;#include &lt;stack&gt;#include &lt;iostream&gt;#include &lt;iomanip&gt;#include &lt;bits/stdc++.h&gt;#define rep(i,a,n) for(int i=a;i&lt;n;++i)#define per(i,a,n) for(int i=n-a;i&gt;=a;--i)#define se second#define fi first#define pb push_back#define mp make_pair#define np next_permutation#define ms(x,a) memset((x),a,sizeof((x)))#define all(x) x.begin(),x.end()#define eps 1e-9#define INF 0x3f3f3f3fusing namespace std;const int maxn=1e5+5;const int maxl=26;typedef long long ll;typedef unsigned long long ull;typedef vector&lt;int&gt; vi;typedef pair&lt;int,int&gt; pii;double a[maxn];double sum[maxn]; double allflood,maxa;int n,m;double check(double nowl, double allcubic)&#123; int index=lower_bound(a,a+m*n,nowl)-a;// cout&lt;&lt;"index="&lt;&lt;index&lt;&lt;" "; if(index==0) return allcubic; double temp=index*nowl-sum[index-1];// cout&lt;&lt;"temp="&lt;&lt;temp&lt;&lt;endl; return allcubic-(10.0*10.0*temp);&#125;int main()&#123; ios::sync_with_stdio(false); int kase=1; while(cin&gt;&gt;m&gt;&gt;n&amp;&amp;m+n)&#123; maxa=-100000; rep(i,0,m)&#123; rep(j,0,n)&#123; cin&gt;&gt;a[i*n+j]; &#125; &#125; sort(a,a+m*n); sum[0]=a[0]; rep(i,1,n*m) sum[i]=sum[i-1]+a[i]; cin&gt;&gt;allflood;// cout&lt;&lt;"mmin="&lt;&lt;a[0]&lt;&lt;" mmax="&lt;&lt;a[n*m-1]&lt;&lt;endl; //一共n*m个区域； cout&lt;&lt;"Region "&lt;&lt;kase++&lt;&lt;endl; //先判断填满是不是够 double temp=10.0*10.0*(n*m*a[n*m-1]-sum[n*m-1]); if(temp&lt;allflood)&#123; double ans=(allflood-temp)/(100.0*n*m)+a[n*m-1]; cout&lt;&lt;"Water level is "&lt;&lt;fixed&lt;&lt;setprecision(2)&lt;&lt;ans&lt;&lt;" meters."&lt;&lt;endl; cout&lt;&lt;"100.00 percent of the region is under water."&lt;&lt;endl; cout&lt;&lt;endl; continue; &#125; //不够 double l=a[0],r=a[n*m-1],mid=(l+r)/2.0; double ans=check(mid,allflood); while(abs(ans)&gt;eps)&#123; if(ans&gt;0) l=mid; else r=mid; mid=(r+l)/2.0;// cout&lt;&lt;"mid="&lt;&lt;mid&lt;&lt;" "; ans=check(mid,allflood); &#125; int index=lower_bound(a,a+m*n,mid)-a; cout&lt;&lt;"Water level is "&lt;&lt;fixed&lt;&lt;setprecision(2)&lt;&lt;mid&lt;&lt;" meters."&lt;&lt;endl; cout&lt;&lt;fixed&lt;&lt;setprecision(2)&lt;&lt;(double)index*100/(n*m)&lt;&lt;" percent of the region is under water."&lt;&lt;endl; cout&lt;&lt;endl; &#125;&#125; 贪心： 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859#include &lt;cstdio&gt;#include &lt;cstring&gt;#include &lt;cmath&gt;#include &lt;algorithm&gt;#include &lt;set&gt;#include &lt;queue&gt;#include &lt;map&gt;#include &lt;vector&gt;#include &lt;stack&gt;#include &lt;iostream&gt;#include &lt;iomanip&gt;#include &lt;bits/stdc++.h&gt;#define rep(i,a,n) for(int i=a;i&lt;n;++i)#define per(i,a,n) for(int i=n-a;i&gt;=a;--i)#define se second#define fi first#define pb push_back#define mp make_pair#define np next_permutation#define ms(x,a) memset((x),a,sizeof((x)))#define all(x) x.begin(),x.end()#define eps 1e-9#define INF 0x3f3f3f3fusing namespace std;const int maxn=1e5+5;const int maxl=26;typedef long long ll;typedef unsigned long long ull;typedef vector&lt;int&gt; vi;typedef pair&lt;int,int&gt; pii;int n,m;int a[maxn];int main()&#123; ios::sync_with_stdio(false); int kase=0; while(cin&gt;&gt;n&gt;&gt;m&amp;&amp;n+m)&#123; n*=m; rep(i,0,n) cin&gt;&gt;a[i]; sort(a,a+n); double ans; cin&gt;&gt;ans; ans/=100; a[n]=INF; int index=0; rep(i,0,n)&#123; ans+=a[i]; if(ans/(i+1)&lt;=a[i+1])&#123; ans=ans/(i+1); index=i+1; break; &#125; &#125; cout&lt;&lt;"Region "&lt;&lt;++kase&lt;&lt;endl; cout&lt;&lt;"Water level is "&lt;&lt;fixed&lt;&lt;setprecision(2)&lt;&lt;ans&lt;&lt;" meters."&lt;&lt;endl; cout&lt;&lt;fixed&lt;&lt;setprecision(2)&lt;&lt;(double)(index*100)/n&lt;&lt;" percent of the region is under water."&lt;&lt;endl; cout&lt;&lt;endl; &#125;&#125; 收获与反思 代码长度和速度高下立判啊。合理尝试贪心、二分，选择合适方法]]></content>
      <categories>
        <category>编程</category>
        <category>ACM</category>
      </categories>
      <tags>
        <tag>ACM</tag>
        <tag>算法</tag>
        <tag>二分</tag>
        <tag>Greedy</tag>
        <tag>UVA</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[【UVA-101】解题报告（模拟）]]></title>
    <url>%2Fpost%2Fd50b784.html</url>
    <content type="text"><![CDATA[原始题目 题目大意有$n$个积木，初始放在$0,1,2 \cdots n-1$位置上，有四种搭积木操作 move a onto b where a and b are block numbers, puts block a onto block b after returning any blocks that arestacked on top of blocks a and b to their initial positions. 把a和b上的积木放回原来位置，再将a放置到b上。 move a over b where a and b are block numbers, puts block a onto the top of the stack containing block b, afterreturning any blocks that are stacked on top of block a to their initial positions. 把a上的积木放回原来位置，再将a放置在b所在的积木堆上。 pile a onto b where a and b are block numbers, moves the pile of blocks consisting of block a, and any blocksthat are stacked above block a, onto block b. All blocks on top of block b are moved to theirinitial positions prior to the pile taking place. The blocks stacked above block a retain their orderwhen moved. 把b上的积木放回原来位置，再将a和a之上的积木块一起放在b上（保持相对顺序）。 pile a over b where a and b are block numbers, puts the pile of blocks consisting of block a, and any blocksthat are stacked above block a, onto the top of the stack containing block b. The blocks stackedabove block a retain their original order when moved. 把a和a之上的积木块一起放在b所在的积木堆上（保持相对顺序）。 直至遇到quit停止操作，输出最后每个位置上的积木状态。 解题思路 由于不涉及积木块放置在指定位置的操作，还原必定到原有位置且原有位置为空（易证），不用考虑木块放回的特殊情况。 注意判断是否在同一堆上，违法命令不进行任何实际操作 模拟四种操作即可 解题代码 数组模拟四种操作 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147148149150151152153154155156157#include &lt;cstdio&gt;#include &lt;cstring&gt;#include &lt;cmath&gt;#include &lt;algorithm&gt;#include &lt;set&gt;#include &lt;queue&gt;#include &lt;map&gt;#include &lt;vector&gt;#include &lt;stack&gt;#include &lt;iostream&gt;#include &lt;iomanip&gt;#include &lt;bits/stdc++.h&gt;#define rep(i,a,n) for(int i=a;i&lt;n;++i)#define per(i,a,n) for(int i=n-a;i&gt;=a;--i)#define se second#define fi first#define pb push_back#define mp make_pair#define np next_permutation#define ms(x,a) memset((x),a,sizeof((x)))#define all(x) x.begin(),x.end()#define eps 1e-9#define INF 0x3f3f3f3fusing namespace std;const int maxn=1e5+5;const int maxl=26;typedef long long ll;typedef unsigned long long ull;typedef vector&lt;int&gt; vi;typedef pair&lt;int,int&gt; pii;int n,m,a,b;string s1,s2;int top[maxn],bottom[maxn],place[maxn],mmp[maxn];void initial()&#123; rep(i,0,n) top[i]=bottom[i]=place[i]=i; rep(i,0,n) mmp[i]=-1;&#125;void solve(int aa,int bb,int index)&#123; switch(index)&#123; case 1: &#123; while(mmp[aa]!=-1)&#123; int next=mmp[aa]; mmp[aa]=mmp[next]; mmp[next]=-1; top[next]=bottom[next]=place[next]=next; &#125; while(mmp[bb]!=-1)&#123; int next=mmp[bb]; mmp[bb]=mmp[next]; mmp[next]=-1; top[next]=bottom[next]=place[next]=next; &#125; mmp[bb]=aa; int start=top[place[aa]]; if(start==aa) top[aa]=-1; else&#123; while(mmp[start]!=aa) start=mmp[start]; mmp[start]=-1; &#125; place[aa]=place[bb]; &#125; break; case 2: &#123; while(mmp[aa]!=-1)&#123; int next=mmp[aa]; mmp[aa]=mmp[next]; mmp[next]=-1; top[next]=bottom[next]=place[next]=next; &#125; while(mmp[bb]!=-1) bb=mmp[bb]; mmp[bb]=aa; int start=top[place[aa]]; if(start==aa) top[aa]=-1; else&#123; while(mmp[start]!=aa) start=mmp[start]; mmp[start]=-1; &#125; place[aa]=place[bb]; &#125; break; case 3: &#123; while(mmp[bb]!=-1)&#123; int next=mmp[bb]; mmp[bb]=mmp[next]; mmp[next]=-1; top[next]=bottom[next]=place[next]=next; &#125; mmp[bb]=aa; int start=top[place[aa]]; if(start==aa) top[aa]=-1; else&#123; while(mmp[start]!=aa) start=mmp[start]; mmp[start]=-1; &#125; while(mmp[bb]!=-1)&#123; place[mmp[bb]]=place[bb]; bb=mmp[bb]; &#125; &#125; break; case 4: &#123; while(mmp[bb]!=-1) bb=mmp[bb]; mmp[bb]=aa; int start=top[place[aa]]; if(start==aa) top[aa]=-1; else&#123; while(mmp[start]!=aa) start=mmp[start]; mmp[start]=-1; &#125; while(mmp[bb]!=-1)&#123; place[mmp[bb]]=place[bb]; bb=mmp[bb]; &#125; &#125; break; &#125;&#125;int main()&#123; while(cin&gt;&gt;n)&#123; initial(); while(cin&gt;&gt;s1&amp;&amp; s1[0]!='q')&#123; cin&gt;&gt;a&gt;&gt;s2&gt;&gt;b; if(place[a]==place[b]) continue; if(s1[0]=='m' &amp;&amp; s2[1]=='n') solve(a,b,1); if(s1[0]=='m' &amp;&amp; s2[1]=='v') solve(a,b,2); if(s1[0]=='p' &amp;&amp; s2[1]=='n') solve(a,b,3); if(s1[0]=='p' &amp;&amp; s2[1]=='v') solve(a,b,4); &#125; rep(i,0,n)&#123; cout&lt;&lt;i&lt;&lt;":"; if(top[i]==-1) cout&lt;&lt;endl; else &#123; int start=top[i]; cout&lt;&lt;" "&lt;&lt;start; while(mmp[start]!=-1)&#123; start=mmp[start]; cout&lt;&lt;" "&lt;&lt;start; &#125; cout&lt;&lt;endl; &#125; &#125;// cout&lt;&lt;endl; &#125;&#125; vector模拟两种操作 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778#include &lt;bits/stdc++.h&gt;#define rep(i,a,n) for(int i=a;i&lt;n;++i)#define per(i,a,n) for(int i=n-1;i&gt;=a;--i)#define fi first#define se second#define mp make_pair#define pb push_back#define np next_permutation#define cl(x,a,n) memset(x,a,sizeof(int)*n)using namespace std;typedef long long ll;typedef unsigned long long ull;typedef long double ld;typedef vector&lt;int&gt; vi;typedef pair&lt;int,int&gt; pii;typedef pair&lt;string,string&gt; pss;const int maxn=30;int n;vector&lt;int&gt; pile[maxn];void find_block(int a,int &amp;p, int &amp; h) &#123;// 引用形式返回ouke和高度 for( p=0;p&lt;n;p++)&#123; for(h=0;h&lt;pile[p].size();h++)&#123; if(pile[p][h]==a ) return; &#125; &#125;&#125;void clear_above(int p,int h)&#123; for(int i=h+1;i&lt;pile[p].size();i++)&#123; int b=pile[p][i]; pile[b].pb(b); &#125; pile[p].resize(h+1);&#125;void pile_onto(int p,int h,int p2)&#123; for(int i=h; i&lt;pile[p].size();i++)&#123; pile[p2].pb(pile[p][i]); &#125; pile[p].resize(h);&#125;void print()&#123; for(int i=0;i&lt;n;++i)&#123; printf("%d:",i); for(int j=0;j&lt;pile[i].size();j++) printf(" %d",pile[i][j]); printf("\n"); &#125;&#125;int main()&#123; int a,b; cin&gt;&gt;n; string s1,s2; rep(i,0,n) pile[i].pb(i); while(cin&gt;&gt;s1&gt;&gt;a&gt;&gt;s2&gt;&gt;b)&#123; int pa,pb,ha,hb; find_block(a,pa,ha); find_block(b,pb,hb); if(pa==pb) continue; //feifa if(s2=="onto") clear_above(pb,hb); if(s1=="move") clear_above(pa,ha); pile_onto(pa,ha,pb); &#125; print(); return 0;&#125; 收获与反思 大模拟，输出注意PE。]]></content>
      <categories>
        <category>编程</category>
        <category>ACM</category>
      </categories>
      <tags>
        <tag>ACM</tag>
        <tag>算法</tag>
        <tag>Imitation</tag>
        <tag>2018暑假集训</tag>
        <tag>UVA</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[【UVA-10815】解题报告（STL，set）]]></title>
    <url>%2Fpost%2F9282aeca.html</url>
    <content type="text"><![CDATA[原始题目 题目大意给定一段含标点的文章，将其中的单词全部按小写的字典序输出。 解题思路 去年做过这个题，当时入门 现在利用strig类和stringstream类可以轻松完成任务 解题代码12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849//set ssteam #include &lt;cstdio&gt;#include &lt;cstring&gt;#include &lt;cmath&gt;#include &lt;algorithm&gt;#include &lt;set&gt;#include &lt;queue&gt;#include &lt;map&gt;#include &lt;vector&gt;#include &lt;stack&gt;#include &lt;iostream&gt;#include &lt;iomanip&gt;#include &lt;sstream&gt;#include &lt;bits/stdc++.h&gt;#define rep(i,a,n) for(int i=a;i&lt;n;++i)#define per(i,a,n) for(int i=n-a;i&gt;=a;--i)#define se second#define fi first#define pb push_back#define mp make_pair#define np next_permutation#define ms(x,a) memset((x),a,sizeof((x)))#define all(x) x.begin(),x.end()#define eps 1e-9#define INF 0x3f3f3f3fusing namespace std;string s,ans;int main()&#123; ios::sync_with_stdio(false);// freopen("in.txt","r",stdin); set &lt;string&gt; sset; while(cin&gt;&gt;s)&#123; //处理一下 rep(i,0,s.length())&#123; if(!isalpha(s[i])) s[i]=' '; else s[i]=tolower(s[i]); &#125;// cout&lt;&lt;s&lt;&lt;endl; stringstream ss(s); while(ss&gt;&gt;ans)&#123; sset.insert(ans); &#125; &#125; for(set&lt;string&gt;::iterator it=sset.begin();it!=sset.end();it++)&#123; cout&lt;&lt;*it&lt;&lt;endl; &#125;&#125; 收获与反思 再多熟练运用一下stringstream]]></content>
      <categories>
        <category>编程</category>
        <category>ACM</category>
      </categories>
      <tags>
        <tag>ACM</tag>
        <tag>算法</tag>
        <tag>2018暑假集训</tag>
        <tag>STL</tag>
        <tag>UVA</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[《我辈孤雏》读书笔记]]></title>
    <url>%2Fpost%2F66258384.html</url>
    <content type="text"><![CDATA[内容摘录与笔记第一部 P29 “我一时之间竟说不上话，后来总算把话吐出来：‘您真是太仁慈了，先生，您的协助，我感激不尽，而且我也不希望您以为我不懂事。不过有一点请您谅解，我觉得我不该在这个时候返回英国。’上校一时之间并没有反应……” 第二部 P68 “接下来是针针见血的猛烈抨击，她对督察所用的这一招，我早已熟悉，而日后也还要听她陈述其中概要好多次；她先泛泛地批评英国政府，再把火力集中到私人企业，特别是摩根洋行身上，说他们不该从印度，输入这么庞大数量地鸦片到中国，然后冷眼旁观这整个民族陷入悲惨与堕落，说的时候，母亲地声音常常高张欲裂，不过都尖而未破，她双眼始终不曾放松……” P139 “这么多年来，她让我敬畏有加，可现在我明白这一切全是装腔作势：她丝毫无法控制这个逐渐将我们吞没的混乱世界，她只是个可悲的小女人，全靠伪装在我眼中建立她的形象，当巨大势力相互冲突斗争之际，她根本贱于蝼蚁。我站在走廊上瞪着她，眼神鄙夷至极。” 第三部 再次出现系住百叶窗叶片地细绳。 P153 “因为像您这样的人才，警探先生，这样的人才实在难得。像我们这样的人，我们的职责就是打击坏人，我们……该怎么说好呢？我们就像系住百叶窗叶片的细绳。一旦我们系得不牢靠，一切都会分崩离析。您背负得责任可是相当重大啊，警探先生。” 第四部 P179 “‘不，不，先生’——格雷森先生紧张地笑了笑——‘我指地是另一个欢迎仪式。我的意思是，欢迎令尊令堂历劫多年归来地那个。’” 第五部 P183 “从我抵达地那一刻起，真正教我心里暗暗吃惊的是，这里每一个人都拒绝承认他们都罪有应得。待在这里约两周地时间里，在我所接触的所有这些英国人当中，无论地位高低，我都还没遇到——一次也没有——有谁真心感到愧疚。换言之，在这里，在这个可能吞噬整个闻名世界地大漩涡的涡眼里，大家在心照不宣中无耻可悲地集体否认现实，否认自身的责任，而这种行为转为自我封闭，变本加厉，以冠冕堂皇地自我保护表现于外，这是我经常碰到地情况。而现在眼前地这一群所谓上海的精英，如此不屑一顾地凝望他们地中国邻居在运河对岸受苦受难。” 第六部 P327 “桌上的阅读灯下有一圈温暖的光线，可是房中其他部分都一片幽暗。正当我站在那里观察周遭的情况，有个身影从书桌边站了起来，小心地绕过书桌，回头指着桌后他空出来的座位。‘怎么不过去坐那儿，小海雀？’菲利普叔叔对我说，‘你还记得吧？你以前最喜欢坐我书桌后面的位子了。’” P332 “‘那么我母亲呢？她发生了什么事？’ 菲利普叔叔向前探身，双肘撑着桌子，头部微微往后仰。‘你对于她的事，现在知道的有多少？’他问。他先前在声音里所表现的轻松已经完全消失。他现在看起来有如心事重重的老人，饱受自我悔恨的折磨。尽管他把头往后仰，却还是仔细盯着我看，桌灯的黄光照拂下，看得他白色的鼻毛突出鼻孔。我听到楼下某处，正播放着中国军歌。” P336 “我探身向他，进入桌灯炫目的光亮之中，我有种奇怪的感觉，身后的黑暗愈变愈大，此时在那里摊成了一大片幽暗无光的空间。菲利普叔叔用掌心拭去前额的汗珠。不过他现在专注地看着我，继续说：‘那天后来我去新城饭店见王顾。我尽我所能化解可能面临的灾难。不过为时已晚。他那天下午对我说的话，一点都没有生气的样子。他发现你母亲的精神——他就是这么说的，她的‘精神’——非常迷人。他已经为之倾倒，因此打算娶她为妾，带她回湖南。他说要‘驯服’她，如同对待一匹野生的母马一样。这个你得理解，小海雀，你得理解那时候在上海、在中国是什么样的局势，像王顾这样的人，若是决定要做这类的事，谁也阻止不了他。这点你必须理解。向警方或任何人要求保护你母亲，根本不会有结果。也许能暂时缓一缓，不过终究是无用。没有任何人能保护她，不让这种人得逞。不过你明白吗，我真正担心的是你，小海雀。我不确定他打算怎么处置你，这才是我求他的事。结果我们达成协议。我想办法让她落单，无人守护，而同时我又把你带离现场。我只求他这件事。我不希望他连你也带走。你母亲，只能说是在劫难逃。至于你，还有商量的余地，我就是做了这样的事。’” P338 “‘菲利普叔叔，什么财务安排？’ 他低头看着手背，端详了半晌。‘要不是为了你，她对你的爱，小海雀，我相信你母亲会毫不迟疑结束自己的生命，不会让那个恶棍碰她一下。她总会有办法，也一定会做到。可是她还得担心你。因此，到了最后，她看情势比人强，便做了安排。你将会得到财务上的供应，以换取……换取她的顺从。我亲自监督了大半的程序，经由公司来安排。公司里有个对这件事全无概念的人，还以为这是在为鸦片的安全运送做安排呢！哈！哈！真是个傻子，那个人！’菲利普叔叔摇摇头，面露笑容。接着他的表情又阴沉起来，仿佛他要回到我们原先要谈的主题。 ‘我的生活费，’我平静地说，‘我继承的财产……’‘你在英国的姑妈，她从来就没富有过。真正资助你的人，这么多年来，一直是王顾。’” 在黑夜中摸索，希望能寻得父母那一辈所遗失的真相，奈何在现实的冷酷与成熟面前，我们终究不过孤雏而已，想象不到黑暗中那股势力的强大，压垮了我们本以为还算成熟的臂膀。比起那个时代，我们算得上什么？太过渺小而已。 第七部 P363 “不过，对于我们这种人而言，我们的命运是以孤儿的眼光看待世界，长年追逐着父母消逝的暗影。我们只有尽全力把使命完成，别无解脱之途，在此之前，心中无法得到片刻的宁静。”]]></content>
      <categories>
        <category>阅读</category>
      </categories>
      <tags>
        <tag>阅读</tag>
        <tag>小说</tag>
        <tag>文学</tag>
        <tag>石黑一雄</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[【POJ-3660】解题报告（Floyd传递闭包）]]></title>
    <url>%2Fpost%2F6fc3409b.html</url>
    <content type="text"><![CDATA[原始题目Cow Contest Time Limit: 1000MS Memory Limit: 65536K Total Submissions: 15815 Accepted: 8813 DescriptionN (1 ≤ N ≤ 100) cows, conveniently numbered 1..N, are participating in a programming contest. As we all know, some cows code better than others. Each cow has a certain constant skill rating that is unique among the competitors. The contest is conducted in several head-to-head rounds, each between two cows. If cow A has a greater skill level than cow B (1 ≤ A ≤ N; 1 ≤ B ≤ N; A ≠ B), then cow A will always beat cow B. Farmer John is trying to rank the cows by skill level. Given a list the results of M (1 ≤ M ≤ 4,500) two-cow rounds, determine the number of cows whose ranks can be precisely determined from the results. It is guaranteed that the results of the rounds will not be contradictory. Input Line 1: Two space-separated integers: N and M Lines 2..M+1: Each line contains two space-separated integers that describe the competitors and results (the first integer, A, is the winner) of a single round of competition: A and B Output Line 1: A single integer representing the number of cows whose ranks can be determined Sample Input5 5 4 3 4 2 3 2 1 2 2 5 Sample Output2 SourceUSACO 2008 January Silver 题目大意一共有N头牛，现在知道M条信息，每条信息描述两头牛谁更强一些，问可以确定最多多少头牛的排名。 解题思路 还在学习中，使用Floyd算法求闭包，（A胜B，B胜C，则传递A胜C） 然后对于每头牛扫一遍是否与其他n-1头牛都有确定的胜负关系，如果有的话答案++。 还需要深入学习Floyd算法 解题代码123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960#include &lt;cstdio&gt;#include &lt;cstring&gt;#include &lt;cmath&gt;#include &lt;iostream&gt;#include &lt;iomanip&gt;#include &lt;algorithm&gt;#include &lt;set&gt;#include &lt;map&gt;#include &lt;vector&gt;#include &lt;stack&gt;#include &lt;queue&gt;#define mp make_pair#define pb push_back#define np next_permutation#define rep(i,a,n) for(int i=a;i&lt;n;++i)#define per(i,a,n) for(int i=n-1;i&gt;=a;--i)#define first fi#define second se#define eps 1e-9#define INF 0x3f3f3f3f#define ms(x,a) memset((x),a,sizeof((x)))#define all(x) x.begin(),x.end()#define gapline cout&lt;&lt;"##================##"&lt;&lt;endlusing namespace std;const int maxn=1e3+5;const int mal=26;typedef long long ll;typedef unsigned long long ull;typedef vector&lt;int&gt; vi;typedef pair&lt;int,int&gt; pii;bool ans[maxn][maxn]; int n,m;void Floyd()&#123; rep(k,1,n+1) rep(i,1,n+1) rep(j,1,n+1) ans[i][j]=ans[i][j]|(ans[i][k]&amp;ans[k][j]); &#125;int main()&#123; ios::sync_with_stdio(false); while(cin&gt;&gt;n)&#123; cin&gt;&gt;m; ms(ans,0); rep(i,0,m)&#123; int a,b; cin&gt;&gt;a&gt;&gt;b; ans[a][b]=1; &#125; Floyd(); int aans=0; rep(i,1,n+1)&#123; int ccnt=0; rep(j,1,n+1)&#123; if(ans[i][j]||ans[j][i]) ccnt++; &#125; if(ccnt==n-1) aans++; &#125; cout&lt;&lt;aans&lt;&lt;endl; &#125; &#125; 收获与反思 挖坑，加强理解Floyd最短路算法。]]></content>
      <categories>
        <category>编程</category>
        <category>ACM</category>
      </categories>
      <tags>
        <tag>ACM</tag>
        <tag>算法</tag>
        <tag>2018暑假集训</tag>
        <tag>POJ</tag>
        <tag>Floyd</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[【HDU-1548】解题报告（BFS）]]></title>
    <url>%2Fpost%2Fac92be99.html</url>
    <content type="text"><![CDATA[原始题目A strange lift Time Limit: 2000/1000 MS (Java/Others) Memory Limit: 65536/32768 K (Java/Others) Total Submission(s): 32759 Accepted Submission(s): 11752 Problem DescriptionThere is a strange lift.The lift can stop can at every floor as you want, and there is a number $K_i (0 \le K_i \le N) $ on every floor.The lift have just two buttons: up and down.When you at floor i,if you press the button “UP” , you will go up $K_i$ floor,i.e,you will go to the i+Ki th floor,as the same, if you press the button “DOWN” , you will go down $K_i$ floor,i.e,you will go to the i-Ki th floor.Of course, the lift can’t go up high than N,and can’t go down lower than 1. For example, there is a buliding with 5 floors, and $k_1 = 3, k_2 = 3 , k_3 = 1 , k_4 = 2 , k_5 = 5 . $ Begining from the 1 st floor,you can press the button “UP”, and you’ll go up to the 4 th floor,and if you press the button “DOWN”, the lift can’t do it, because it can’t go down to the -2 th floor,as you know ,the -2 th floor isn’t exist. Here comes the problem: when you are on floor A,and you want to go to floor B,how many times at least he has to press the button “UP” or “DOWN”? InputThe input consists of several test cases.,Each test case contains two lines. The first line contains three integers $N,A,B( 1 \le N,A,B \le 200)$ which describe above,The second line consist $N$ integers $k_1,k_2 \cdots k_n$ . A single 0 indicate the end of the input. OutputFor each case of the input output a interger, the least times you have to press the button when you on floor A,and you want to go to floor B.If you can’t reach floor B,printf “-1”. Sample Input5 1 5 3 3 1 2 5 0 Sample Output3 Recommend8600 题目大意有一个电梯，对于每一层$i$，只能上升或者下降$a_i$（不能低于$1$层或高于$n$层），现在给定初态层数和末态层数，问最少需要操作几次才可以达到末态层数。到达不了输出-1。 解题思路 两方向BFS，注意打标记和输出-1的情况即可。 解题代码123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566#include &lt;cstdio&gt;#include &lt;cstring&gt;#include &lt;iostream&gt;#include &lt;iomanip&gt;#include &lt;map&gt;#include &lt;set&gt;#include &lt;algorithm&gt;#include &lt;queue&gt;#include &lt;vector&gt;#include &lt;stack&gt;//#include &lt;bits/stdc++.h&gt;//#define mp make_pair#define np next_permutation#define pb push_back#define fi first#define se second#define eps 1e-8#define INF 0x3f3f3f3f#define rep(i,a,n) for(int i=a;i&lt;n;++i)#define per(i,a,n) for(int i=n-1;i&gt;=a;--i)using namespace std;typedef long long ll;typedef unsigned long long ull;typedef vector&lt;int&gt; vi;typedef pair&lt;int,int&gt; pii;const int maxn=1e4+5;int vis[maxn];int mp[maxn],n,a,b;void bfs()&#123; int ans=0; int flag=0; queue&lt;pii&gt;q; q.push(make_pair(a,0)); memset(vis,0,sizeof(vis)); vis[a]=1; while(!q.empty())&#123; pii now=q.front(); q.pop(); if(now.fi==b)&#123; cout&lt;&lt;now.second&lt;&lt;endl; flag=1; break; &#125; int down=now.fi-mp[now.fi]; int up=now.fi+mp[now.fi];// cout&lt;&lt;"up="&lt;&lt;up&lt;&lt;" down="&lt;&lt;down&lt;&lt;endl; if(down&gt;=1 &amp;&amp; !vis[down])&#123; vis[down]=1; q.push(make_pair(down,now.second+1)); &#125; if(up&lt;=n &amp;&amp; !vis[up])&#123; vis[up]=1; q.push(make_pair(up,now.second+1)); &#125; &#125; if(!flag) cout&lt;&lt;-1&lt;&lt;endl;&#125;int main()&#123; ios::sync_with_stdio(false); while(cin&gt;&gt;n&amp;&amp;n)&#123; cin&gt;&gt;a&gt;&gt;b; rep(i,1,n+1) cin&gt;&gt;mp[i]; bfs(); &#125; &#125; 收获与反思 简单bfs，注意打对标记即可。]]></content>
      <categories>
        <category>编程</category>
        <category>ACM</category>
      </categories>
      <tags>
        <tag>ACM</tag>
        <tag>算法</tag>
        <tag>2018暑假集训</tag>
        <tag>BFS</tag>
        <tag>HDU</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[【CodeForces-579A】解题报告（二进制）]]></title>
    <url>%2Fpost%2Fc37095b9.html</url>
    <content type="text"><![CDATA[原始题目A. Raising Bacteria time limit per test1 second memory limit per test256 megabytes inputstandard input outputstandard output You are a lover of bacteria. You want to raise some bacteria in a box. Initially, the box is empty. Each morning, you can put any number of bacteria into the box. And each night, every bacterium in the box will split into two bacteria. You hope to see exactly x bacteria in the box at some moment. What is the minimum number of bacteria you need to put into the box across those days? InputThe only line containing one integer x (1 ≤ x ≤ $10^9$). OutputThe only line containing one integer: the answer. Examplesinput5 output2 input8 output1 NoteFor the first sample, we can add one bacterium in the box in the first day morning and at the third morning there will be 4 bacteria in the box. Now we put one more resulting 5 in the box. We added 2 bacteria in the process so the answer is 2. For the second sample, we can put one in the first morning and in the 4-th morning there will be 8 in the box. So the answer is 1. 题目大意初始盒子是空的，每天早晨你可以放任意个细菌到盒子盒子中去，每个细菌在盒子中每天分裂成两个。现在给出x，问最少需要放多少个细菌可以使一定天数后盒子中细菌数量恰好为x。 解题思路 在不限制天数的情况下，恰巧达到x就让每个放入的细菌尽可能繁殖 将x用二进制表示，有多少个1即为答案。 解题代码123456789101112131415161718192021222324252627282930313233343536373839#include &lt;cstdio&gt;#include &lt;cstring&gt;#include &lt;iostream&gt;#include &lt;iomanip&gt;#include &lt;map&gt;#include &lt;set&gt;#include &lt;algorithm&gt;#include &lt;queue&gt;#include &lt;vector&gt;#include &lt;stack&gt;#include &lt;bits/stdc++.h&gt;#define mp make_pair#define np next_permutation#define pb push_back#define fi first#define se second#define eps 1e-8#define INF 0x3f3f3f3fusing namespace std;typedef long long ll;typedef unsigned long long ull;typedef vector&lt;int&gt; vi;typedef pair&lt;int,int&gt; pii;const int maxn=1e5+5;const int maxl=26;ll n;int main()&#123; ios::sync_with_stdio(false); while(cin&gt;&gt;n)&#123; ll ans=0; while(n)&#123; if(n&amp;1) ans++; n&gt;&gt;=1; &#125; cout&lt;&lt;ans&lt;&lt;endl; &#125; &#125; 收获与反思 思维]]></content>
      <categories>
        <category>编程</category>
        <category>ACM</category>
      </categories>
      <tags>
        <tag>ACM</tag>
        <tag>算法</tag>
        <tag>2018暑假集训</tag>
        <tag>CodeForces</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[【HDU-1430】解题报告（数论，康拓展开逆展开，简单哈希，BFS）]]></title>
    <url>%2Fpost%2F6f3b3edd.html</url>
    <content type="text"><![CDATA[原始题目魔板 Time Limit: 10000/5000 MS (Java/Others) Memory Limit: 65536/32768 K (Java/Others) Total Submission(s): 4318 Accepted Submission(s): 1033 Problem Description在魔方风靡全球之后不久，Rubik先生发明了它的简化版——魔板。魔板由8个同样大小的方块组成，每个方块颜色均不相同，可用数字1-8分别表示。任一时刻魔板的状态可用方块的颜色序列表示：从魔板的左上角开始，按顺时针方向依次写下各方块的颜色代号，所得到的数字序列即可表示此时魔板的状态。例如，序列(1,2,3,4,5,6,7,8)表示魔板状态为： 1 2 3 48 7 6 5 对于魔板，可施加三种不同的操作，具体操作方法如下： A: 上下两行互换,如上图可变换为状态87654321 B: 每行同时循环右移一格,如上图可变换为41236785 C: 中间4个方块顺时针旋转一格,如上图可变换为17245368 给你魔板的初始状态与目标状态，请给出由初态到目态变换数最少的变换步骤，若有多种变换方案则取字典序最小的那种。 Input每组测试数据包括两行，分别代表魔板的初态与目态。 Output对每组测试数据输出满足题意的变换步骤。 Sample Input12345678 17245368 12345678 82754631 Sample OutputC AC AuthorLL SourceACM暑期集训队练习赛（三） Recommendlinle 题目大意如题 解题思路 先考虑暴力，对于每个初态，按A，B，C的顺序BFS，到末态，输出。 不过，似乎有些问题。 问题1：如何表示状态？ 问题2：多组数据每次都BFS的话，会T，咋办？ 对于问题1，我们不难发现，不同状态其实对应了1-8的一个排列，很明显根据常识我们知道排列是有顺序的（逆序数逐渐增大）那么我们可否根据排列的数组得到他对应全排列里的序号？其实这和康托展开就搭上关系了。 康拓展开：康托展开是一个全排列到一个自然数的双射，常用于构建哈希表时的空间压缩。 康托展开的实质是计算当前排列在所有由小到大全排列中的顺序，因此是可逆的。 稍微详细点的介绍放在收获与反思里。 这样我们就解决了表示状态的问题。 那么对于问题2呢。我们会发现，魔板从初态到末态，重要的是每个板子相对位置的变化，而不是板子的数。换言之，我们可以做一个初态到’12345678’的映射，重新给板子标号，再将末态各板子按映射关系对应新的标号，即末态按照映射对应一个新标号的末态。 初态 末态 75621483 -&gt; 13846572 ↓ 映射 12345678 -&gt; 58763214 代码为 rep(i,0,len1){ hhash[raw1[i]-&#39;0&#39;]=i+1; } rep(i,0,len1){ b[i]=hhash[raw2[i]-&#39;0&#39;]; } 保留板子相对移动的位置不变化即可，这样我们只要预处理一下’12345678’到各个排列的末态，然后对每组输入，做映射到’12345678’，输出新末态的结果即可。 解题代码123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135#include &lt;cstdio&gt;#include &lt;cstring&gt;#include &lt;cmath&gt;#include &lt;string&gt;#include &lt;iostream&gt;#include &lt;iomanip&gt;#include &lt;sstream&gt;#include &lt;set&gt;#include &lt;map&gt;#include &lt;queue&gt;#include &lt;vector&gt;#include &lt;bits/stdc++.h&gt;#define INF 0x3f3f3f3f#define eps 1e-8#define mp make_pair#define np next_permutation#define pb push_back#define all(x) x.begin(),x.end()#define rep(i,a,n) for(int i=a;i&lt;n;++i)#define per(i,a,n) for(int i=n-1;i&gt;=a;--i)#define ms(x,a) memset((x),a,sizeof((x))) #define mod 998244353 #define gapline cout&lt;&lt;"##---------------##"&lt;&lt;endlusing namespace std;typedef long long ll;typedef unsigned long long ull;typedef vector&lt;int&gt; vi;typedef pair&lt;int,int&gt; pii;const int maxl=8;const int maxn=1e5+5;int A[maxl];//阶乘； int ans_cantor[maxl];//康托展开数组 int next_cantor[maxl];bool vis_cantor[maxl];//康托标记数组 bool vis[maxn];int hhash[20],b[20];string ans[maxn];string raw1,raw2;queue &lt;ll&gt; q;void prechange()&#123; int len1=raw1.length(); rep(i,0,len1)&#123; hhash[raw1[i]-'0']=i+1; &#125; rep(i,0,len1)&#123; b[i]=hhash[raw2[i]-'0']; &#125;&#125;//contar展开，逆展开，数组标号都是从0开始 void cantor(int contar_s[], ll num, int contar_k)&#123;//康托展开，把一个数字num展开成一个数组contar_s，contar_k是数组长度 int t; memset(vis_cantor, 0, sizeof(vis_cantor)); for(int i = 0; i &lt; contar_k; i ++)&#123; t = num / A[contar_k-i-1]; num%=A[contar_k-i-1]; int cnt_cantor=0; rep(j,0,contar_k)&#123; //计算每位的逆序数 if(vis_cantor[j]) continue; if(cnt_cantor==t)&#123; contar_s[i]=j+1,vis_cantor[j]=1;break; &#125; ++cnt_cantor; &#125; &#125;// rep(i,0,contar_k) cout&lt;&lt;contar_s[i]&lt;&lt;' '; //输出康拖展开的结果 // cout&lt;&lt;endl;// gapline;&#125;ll inv_cantor(int contar_s[], int contar_k)&#123;//康托逆展开，把一个数组contar_s换算成一个数字num int cnt;ll num=0; num = 0; for(int i = 0; i &lt; contar_k; i ++)&#123; cnt = 0; for(int j = i + 1; j &lt; contar_k; j ++)&#123; if(contar_s[i] &gt; contar_s[j]) cnt ++;//判断几个数小于它,即求逆序数。 &#125; num += A[contar_k-i-1] * cnt; &#125; return num;&#125;void change(int i)&#123; switch(i)&#123; case 0: //操作A rep(j,0,4) swap(next_cantor[j],next_cantor[maxl-1-j]); break; case 1: //操作B per(j,1,4) swap(next_cantor[(j+1)%4],next_cantor[j]); swap(next_cantor[4],next_cantor[7]); swap(next_cantor[5],next_cantor[4]); swap(next_cantor[6],next_cantor[5]); break; case 2: //操作C swap(next_cantor[1],next_cantor[2]); swap(next_cantor[1],next_cantor[6]); swap(next_cantor[6],next_cantor[5]); break; &#125;&#125;void bfs()&#123; A[0]=A[1]=1; A[2]=2; rep(i,3,maxl+1) A[i]=A[i-1]*i; while(!q.empty()) q.pop(); q.push(0); vis[0]=1; while(!q.empty())&#123; ll temp1=q.front();q.pop(); cantor(ans_cantor,temp1,maxl); rep(i,0,3)&#123; rep(j,0,maxl) next_cantor[j]=ans_cantor[j]; change(i); ll temp2=inv_cantor(next_cantor,maxl); if(!vis[temp2])&#123; q.push(temp2); vis[temp2]=1; ans[temp2]=ans[temp1]+(char)('A'+i); &#125; &#125; &#125;&#125; int main()&#123; ios::sync_with_stdio(false); bfs(); while(cin&gt;&gt;raw1&gt;&gt;raw2)&#123; prechange(); //b[]为最终目标态 ll cnt=inv_cantor(b,maxl); cout&lt;&lt;ans[cnt]&lt;&lt;endl; &#125; &#125; 收获与反思 本题综合应用了数论里的康托展开（用于找到状态数和排列之间的联系），hash到相同情况讨论，以及BFS，值得深入考虑 关于康托展开 https://www.cnblogs.com/linyujun/p/5205760.html 大部分是通过这篇博客以及其他资料学习的，感谢原作者！ 公式为 X = a_n \times (n-1)! + a_{n-1} \times (n-2)! + \cdots + a_2 \times 1! + a_1 \times 0! 其中$a_n$表示第i个元素在未出现的元素中排列第几（从0开始） ，也可以理解成$a_n$表示该位的逆序数。 康托展开得到的X，就是该排列在全排列中的顺序（从0开始）。 逆展开就是循环除以(n-1)!，商为第n位在未出现元素排列第几（从0开始）。模为下一位的被除数。 在详细的等开个数论专题（挖坑）。]]></content>
      <categories>
        <category>编程</category>
        <category>ACM</category>
      </categories>
      <tags>
        <tag>ACM</tag>
        <tag>算法</tag>
        <tag>2018暑假集训</tag>
        <tag>BFS</tag>
        <tag>数论</tag>
        <tag>待补充</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[【AtCoder-4247】解题报告（水题）]]></title>
    <url>%2Fpost%2Ff0b23c5b.html</url>
    <content type="text"><![CDATA[原始题目B - 105 Time limit : 2sec / Memory limit : 1000MB Score: 200 points Problem StatementThe number 105 is quite special - it is odd but still it has eight divisors. Now, your task is this: how many odd numbers with exactly eight positive divisors are there between 1 and N (inclusive)? Constraints N is an integer between 1 and 200 (inclusive). InputInput is given from Standard Input in the following format: N OutputPrint the count. Sample Input 1105 Sample Output 11 Among the numbers between 1 and 105, the only number that is odd and has exactly eight divisors is 105. Sample Input 27 Sample Output 20 1 has one divisor. 3, 5 and 7 are all prime and have two divisors. Thus, there is no number that satisfies the condition. 题目大意给定n，求1到n恰好又8个因数的数字有多少个 集体思路 水题，预处理一下因子个数，再求一下前缀和就行。 解题代码123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960#include &lt;cstdio&gt;#include &lt;cstring&gt;#include &lt;cmath&gt;#include &lt;string&gt;#include &lt;iostream&gt;#include &lt;iomanip&gt;#include &lt;sstream&gt;#include &lt;set&gt;#include &lt;map&gt;#include &lt;queue&gt;#include &lt;vector&gt;#include &lt;bits/stdc++.h&gt;#define INF 0x3f3f3f3f#define eps 1e-8#define mp make_pair#define np next_permutation#define pb push_back#define all(x) (x.begin(),x.end())#define rep(i,a,n) for(int i=a;i&lt;n;++i)#define per(i,a,n) for(int i=n-1;i&gt;=a;--i) #define fi first#define se second using namespace std;const int maxn=1e4+5;const int maxl=26;typedef long long ll;typedef unsigned long long ull;typedef vector&lt;int&gt; vi;typedef pair&lt;int,int&gt; pii; int cnt[maxn],ans[maxn];void solve()&#123; rep(i,1,300) cnt[i]++; rep(i,2,300)&#123; for(int j=1;j*i&lt;=300;j++)&#123; cnt[i*j]++; &#125; &#125; int ccnt=0;ans[0]=0; rep(i,1,300) &#123; if(cnt[i]==8 and (i&amp;1))&#123; ans[i]=++ccnt; &#125; else ans[i]=ccnt; &#125; rep(i,1,300) &#123;// cout&lt;&lt;"ans["&lt;&lt;i&lt;&lt;"]="&lt;&lt;ans[i]&lt;&lt;endl; &#125;&#125; int a,b;int main()&#123; ios::sync_with_stdio(false); solve(); int n; while(cin&gt;&gt;n) cout&lt;&lt;ans[n]&lt;&lt;endl;&#125; 收获与反思无]]></content>
      <categories>
        <category>编程</category>
        <category>ACM</category>
      </categories>
      <tags>
        <tag>ACM</tag>
        <tag>算法</tag>
        <tag>AtCoder</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[【AtCoder-4242】解题报告（思维，水题）]]></title>
    <url>%2Fpost%2Fe769f01f.html</url>
    <content type="text"><![CDATA[原始题目C - To Infinity Time limit : 2sec / Memory limit : 1000MB Score: 300 points Problem StatementMr. Infinity has a string S consisting of digits from 1 to 9. Each time the date changes, this string changes as follows: Each occurrence of 2 in S is replaced with 22. Similarly, each 3 becomes 333, 4 becomes 4444, 5 becomes 55555, 6 becomes 666666, 7 becomes 7777777, 8 becomes 88888888 and 9 becomes 999999999. 1 remains as 1. For example, if S is 1324, it becomes 1333224444 the next day, and it becomes 133333333322224444444444444444 the day after next. You are interested in what the string looks like after $5 \times 10^{15}$ days. What is the K-th character from the left in the string after $5 \times 10^{15}$ days? Constraints S is a string of length between 1 and 100 (inclusive). K is an integer between 1 and $10^{18}$ (inclusive). The length of the string after $5 \times 10^{15}$ days is at least K. InputInput is given from Standard Input in the following format: S K OutputPrint the K-th character from the left in Mr. Infinity’s string after 5×1015 days. Sample Input 11214 4 Sample Output 12 The string S changes as follows: Now: 1214 After one day: 12214444 After two days: 1222214444444444444444 After three days: 12222222214444444444444444444444444444444444444444444444444444444444444444 The first five characters in the string after 5×1015 days is 12222. As K=4, we should print the fourth character, 2. Sample Input 23 157 Sample Output 23 The initial string is 3. The string after 5×1015 days consists only of 3. Sample Input 3299792458 9460730472580800 Sample Output 32 题目大意给定初始的一串数字，之后每一天每个数字会复制该数字次，比如’12223’，下一天变为’1222222333’，如此类推，问经过$5 \times 10^{15}$天后第k位数字是多少。 解题思路由于天数是固定的，而且很大，即便一位2经过5×1015，位数会变为$2^{5 \times 10^{15}}$ ，远超过 $10^{18}$所以只要判断第几位非1即可。 解题代码1234567891011121314151617181920212223242526272829303132333435363738394041424344454647#include &lt;cstdio&gt;#include &lt;cstring&gt;#include &lt;cmath&gt;#include &lt;string&gt;#include &lt;iostream&gt;#include &lt;iomanip&gt;#include &lt;sstream&gt;#include &lt;set&gt;#include &lt;map&gt;#include &lt;queue&gt;#include &lt;vector&gt;#include &lt;bits/stdc++.h&gt;#define INF 0x3f3f3f3f#define eps 1e-8#define mp make_pair#define np next_permutation#define pb push_back#define all(x) (x.begin(),x.end())#define rep(i,a,n) for(int i=a;i&lt;n;++i)#define per(i,a,n) for(int i=n-1;i&gt;=a;--i) #define fi first#define se second using namespace std;const int maxn=1e4+5;const int maxl=26;typedef long long ll;typedef unsigned long long ull;typedef vector&lt;int&gt; vi;typedef pair&lt;int,int&gt; pii;int main()&#123; ios::sync_with_stdio(false); string s; ull k; while(cin&gt;&gt;s&gt;&gt;k)&#123; int index=0; for(int i=0;i&lt;s.length();i++)&#123; if(s[i]!='1')&#123; index=i; break; &#125; &#125; if(k-1&lt;index) cout&lt;&lt;1&lt;&lt;endl; else cout&lt;&lt;s[index]&lt;&lt;endl; &#125;&#125; 收获与反思 思考一下即可，不过拓展应该是天数可变的时候，有机会找一下相关题再补吧。]]></content>
      <categories>
        <category>编程</category>
        <category>ACM</category>
      </categories>
      <tags>
        <tag>ACM</tag>
        <tag>算法</tag>
        <tag>AtCoder</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[【AtCoder-4244】解题报告（暴力，DP）]]></title>
    <url>%2Fpost%2F1448d9c8.html</url>
    <content type="text"><![CDATA[原始题目D - AtCoder Express 2 Time limit : 3sec / Memory limit : 1000MB Score: 400 points Problem StatementIn Takahashi Kingdom, there is a east-west railroad and N cities along it, numbered 1, 2, 3, …, N from west to east. A company called AtCoder Express possesses M trains, and the train i runs from City Li to City Ri (it is possible that Li=Ri). Takahashi the king is interested in the following Q matters: The number of the trains that runs strictly within the section from City pi to City qi, that is, the number of trains j such that pi≤Lj and Rj≤qi. Although he is genius, this is too much data to process by himself. Find the answer for each of these Q queries to help him. Constraints N is an integer between 1 and 500 (inclusive). M is an integer between 1 and 200 000 (inclusive). Q is an integer between 1 and 100 000 (inclusive). 1≤Li≤Ri≤N (1≤i≤M) 1≤pi≤qi≤N (1≤i≤Q) InputInput is given from Standard Input in the following format: N M Q L1 R1 L2 R2 : LM RM p1 q1 p2 q2 : pQ qQ OutputPrint Q lines. The i-th line should contain the number of the trains that runs strictly within the section from City pi to City qi. Sample Input 12 3 1 1 1 1 2 2 2 1 2 Sample Output 13 As all the trains runs within the section from City 1 to City 2, the answer to the only query is 3. Sample Input 210 3 2 1 5 2 8 7 10 1 7 3 10 Sample Output 21 1 The first query is on the section from City 1 to 7. There is only one train that runs strictly within that section: Train 1. The second query is on the section from City 3 to 10. There is only one train that runs strictly within that section: Train 3. Sample Input 310 10 10 1 6 2 9 4 5 4 7 4 7 5 8 6 6 6 7 7 9 10 10 1 8 1 9 1 10 2 8 2 9 2 10 3 8 3 9 3 10 1 10 Sample Output 37 9 10 6 8 9 6 7 8 10 题目大意在一条东西向的铁路上有 $1,2,3 \cdots N$ 个城市，列车公司有$M$列火车，每列火车从$L_i$行驶到 $R_i( L_i \le R_i)$，现在有$Q$个询问每次询问$p_i,q_i$ 两个城市间有多少躺列车的行驶路程恰好再在两城市之间（包括端点）。 解题思路 暴力：由于只需要计数，那么以每个城市为集合，统计该城市出发的列车的行使距离，对于每次询问，遍历pi到qi城市的集合判断距离是否小于终点到遍历点的距离即可。 DP： 把列车行驶看作线段，很明显大的线段包含小的线段。由此联想可以由内向外扩展，考虑DP 以终点作为集合，元素为起始点，预处理后对每个集合排序（代码实际应用vector而非set，因为set不支持迭代器随机访问而且可能会有重复线路） $dp[i][j]$表示从i城市到j城市包含的火车线路。 则状态转移方程为$dp[i][j]=dp[i][j-1]+num[i][j]$ ，$num[i][j]$表示到达j城市且起点不在i城市之前的列车线路数。 求$num[i][j]$，用二分查找lower_bound找到j城市集合中第一个大于等于i的位置，$num[i][j]$即为size减去前缀。 预处理后直接可以输出答案 解题代码 暴力 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364656667686970#include &lt;cstdio&gt;#include &lt;cstring&gt;#include &lt;cmath&gt;#include &lt;string&gt;#include &lt;iostream&gt;#include &lt;iomanip&gt;#include &lt;sstream&gt;#include &lt;set&gt;#include &lt;map&gt;#include &lt;queue&gt;#include &lt;vector&gt;#include &lt;bits/stdc++.h&gt;#define INF 0x3f3f3f3f#define eps 1e-8#define mp make_pair#define np next_permutation#define pb push_back#define all(x) (x.begin(),x.end())#define rep(i,a,n) for(int i=a;i&lt;n;++i)#define per(i,a,n) for(int i=n-1;i&gt;=a;--i)using namespace std; const int maxn=500+5;vector &lt;int&gt; v[maxn]; bool vis[maxn]; void init()&#123; rep(i,0,maxn) v[i].clear(); memset(vis,0,sizeof(vis));&#125; void addedge(int l,int r)&#123; int len=r-l; v[l].pb(len);&#125; int checkedge(int l,int len)&#123;// if(v[l].begin()!=v[l].end()) // cout&lt;&lt;*v[l].begin()&lt;&lt;endl; int ans=upper_bound(v[l].begin(),v[l].end(),len)-v[l].begin();// cout&lt;&lt;"ans="&lt;&lt;ans&lt;&lt;endl; return ans;&#125;int n,m,q,li,ri,pi,qi; int main()&#123; ios::sync_with_stdio(false); while(cin&gt;&gt;n&gt;&gt;m&gt;&gt;q)&#123; init(); rep(i,0,m)&#123; cin&gt;&gt;li&gt;&gt;ri; addedge(li,ri); vis[li]=1; &#125; rep(i,0,maxn)&#123; if(vis[i]) sort(v[i].begin(),v[i].end()); &#125; rep(i,0,q)&#123; cin&gt;&gt;pi&gt;&gt;qi; int cnt=0; for(int i=pi;i&lt;=qi;i++)&#123; int plen=qi-i;// cout&lt;&lt;"plen="&lt;&lt;plen&lt;&lt;endl; cnt+=checkedge(i,plen); &#125; cout&lt;&lt;cnt&lt;&lt;endl; &#125; &#125; &#125; DP 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354#include &lt;cstdio&gt;#include &lt;cstring&gt;#include &lt;cmath&gt;#include &lt;string&gt;#include &lt;iostream&gt;#include &lt;iomanip&gt;#include &lt;sstream&gt;#include &lt;set&gt;#include &lt;map&gt;#include &lt;queue&gt;#include &lt;vector&gt;#include &lt;bits/stdc++.h&gt;#define INF 0x3f3f3f3f#define eps 1e-8#define mp make_pair#define np next_permutation#define pb push_back#define all(x) x.begin(),x.end()#define rep(i,a,n) for(int i=a;i&lt;n;++i)#define per(i,a,n) for(int i=n-1;i&gt;=a;--i)using namespace std; const int maxn=500+5;typedef long long ll;typedef vector&lt;int&gt; vi;typedef pair&lt;int,int&gt; pii; vi v[maxn];int dp[maxn][maxn];int n,m,q,li,ri,pi,qi;void solve()&#123; rep(i,1,n+1) sort(v[i].begin(),v[i].end()); memset(dp,0,sizeof(dp)); rep(l,1,n+1)&#123; for(int r=l;r&lt;=n;r++)&#123; dp[l][r]=dp[l][r-1];// if(r-1&lt;l) continue; dp[l][r]+=(v[r].size()-(lower_bound(v[r].begin(),v[r].end(),l)-v[r].begin())); &#125; &#125;&#125;int main()&#123; ios::sync_with_stdio(false); while(cin&gt;&gt;n&gt;&gt;m&gt;&gt;q)&#123; rep(i,0,m)&#123; cin&gt;&gt;li&gt;&gt;ri; v[ri].pb(li); &#125; solve(); rep(i,0,q)&#123; cin&gt;&gt;pi&gt;&gt;qi; cout&lt;&lt;dp[pi][qi]&lt;&lt;endl; &#125; &#125;&#125; 收获与反思 脑子里别老想着暴力，有重复计算又没有修改为什么不考虑记忆化搜索？不考虑DP？思维训练还不够 很明显的时间差异。]]></content>
      <categories>
        <category>编程</category>
        <category>ACM</category>
      </categories>
      <tags>
        <tag>ACM</tag>
        <tag>算法</tag>
        <tag>AtCoder</tag>
        <tag>DP</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[【AtCoder-4245】解题报告（水题）]]></title>
    <url>%2Fpost%2Ff3d9c661.html</url>
    <content type="text"><![CDATA[原始题目A - Garden Time limit : 2sec / Memory limit : 1000MB Score: 100 points Problem StatementThere is a farm whose length and width are A yard and B yard, respectively. A farmer, John, made a vertical road and a horizontal road inside the farm from one border to another, as shown below: (The gray part represents the roads.)What is the area of this yard excluding the roads? Find it. NoteIt can be proved that the positions of the roads do not affect the area. Constraints A is an integer between 2 and 100 (inclusive). B is an integer between 2 and 100 (inclusive). InputInput is given from Standard Input in the following format: A B OutputPrint the area of this yard excluding the roads (in square yards). Sample Input 12 2 Sample Output 11 In this case, the area is 1 square yard. Sample Input 25 7 Sample Output 224 In this case, the area is 24 square yards. 题目大意一个矩形哇横纵两条宽度为1的道路，问剩下的面积 解题思路小学计算题，秒之 解题代码12345678910111213141516171819202122232425262728293031323334353637#include &lt;cstdio&gt;#include &lt;cstring&gt;#include &lt;cmath&gt;#include &lt;string&gt;#include &lt;iostream&gt;#include &lt;iomanip&gt;#include &lt;sstream&gt;#include &lt;set&gt;#include &lt;map&gt;#include &lt;queue&gt;#include &lt;vector&gt;#include &lt;bits/stdc++.h&gt;#define INF 0x3f3f3f3f#define eps 1e-8#define mp make_pair#define np next_permutation#define pb push_back#define all(x) (x.begin(),x.end())#define rep(i,a,n) for(int i=a;i&lt;n;++i)#define per(i,a,n) for(int i=n-1;i&gt;=a;--i)#define ms(x,a) memset((x),a,sizeof(x))#define fi first#define se secondusing namespace std;const int maxn=1e5+5;const int maxl=26;typedef long long ll;typedef unsigned long long ull;typedef vector&lt;int&gt; vi;typedef pair&lt;int,int&gt; pii;int a,b;int main()&#123; while(cin&gt;&gt;a&gt;&gt;b) cout&lt;&lt;a*b-a-b+1&lt;&lt;endl;&#125; 收获与反思无]]></content>
      <categories>
        <category>编程</category>
        <category>ACM</category>
      </categories>
      <tags>
        <tag>ACM</tag>
        <tag>算法</tag>
        <tag>AtCoder</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[密码技术学习——《图解密码技术》笔记（一）]]></title>
    <url>%2Fpost%2F4b15f9e3.html</url>
    <content type="text"><![CDATA[第3章 对称密码（共享密钥密码）——用相同的密钥进行加密和解密一次性密码本——绝对不会被破译的密码原理： 将明文与一串随机的比特序列进行XOR运算。 完全随机，密钥空间是所有可能的01组合，所以就算破译成功了，我们也无法判断它是正确的明文。比如正确明文是code，但破译会出现从aaaa到zzzz，其中不乏有意义的book，cook等“疑似明文”，由于是完全随机带来的密钥空间有全部可能，我们无法判断真正的明文是什么。 理论上无法破译 不过这样密钥的传送也成了问题，假设我们能够安全的传送密钥，那本身这个方法可以用来安全传递我们的消息了，所以现实中除了特工配送密钥完成元首热线通话以外，一次性密码本没有很高的应用价值。 DESFeistel网络的一轮，右侧直接向下变为输出，右侧与轮密钥XOR生成左侧。 多轮操作，每轮反转左右。 解密就是重复过程（两次XOR抵消从而得到这一轮前的输入）。 三重DES如名，不过是DES加密-&gt;DES解密-&gt;DES加密（由IBM公司提出，用来兼容普通DES，比如三层都是同样的DES密钥，就是普通DES了） 解密过程为DES解密-&gt;DES加密-&gt;DES解密 目前在银行等机构还在使用，但处理速度不高，除了特别重视向下兼容性的情况以外，很少被用于新的用途。 AES取代DES在2000成为新的标准，选定的算法名为Rijndael RijndaelRijndael算法也是由多个轮构成的，其中每一轮分为SubBytes（逐字节替换）、ShiftRows（平移行）、MixColumns（混合列）、AddRoundKey（与轮密钥进行XOR）共四个不中。DES使用Feistel网络作为基本结构，而Rijndael使用SPN结构。 加密：SubBytes -&gt; ShiftRows -&gt; MixColumns -&gt; AddRoundKey 解密：AddRoundKey -&gt; InvMixColumns -&gt; InvShiftRows -&gt; InvSubBytes 破译：由于其过程可以由数学公式来表达，那么理论上可以通过数学运算来求解，意味着Rigndael能够通过数学方法进行破译。不过现在为止还没有出现针对Rigndael的有效攻击。 第4章 分组密码的模式——分组密码是如何迭代的 模式总结表格 模式名称优点缺点备注 ECB模式Electronic CodeBook 电子密码本模式简单快速支持并行计算（加密、解密）明文中的重复排列会反映在密文中通过删除、替换密文分组可以对明文进行操作对包含某些比特错误的密文进行解密时，对应的分组会出错不能抵御重放攻击 不应使用 CBC模式Cipher Block Chaining 密文分组链接模式明文的重复排列不会反映在密文中支持并行计算（仅解密）能够解密任意密文分组对包含某些错误比特的密文进行解密时，第一个分组的全部比特以及后一个分组的相应比特会出错加密不支持并行计算CRYPTREC推荐《实用密码学》推荐 CFB模式Cipher-FeedBack 密文反馈模式不需要填充（padding）支持并行计算（仅解密）能够解密任意密文分组对包含某些错误比特的密文进行解密时，第一个分组的相应比特以及后一个分组的全部比特会出错加密不支持并行计算不能抵御重放攻击CRYPTREC推荐 OFB模式Output-FeedBack 输出反馈模式不需要填充（padding）可事先进行加密、解密的准备加密、解密使用相同结构对包含某些错误比特的密文进行解密时，只有明文中相应的比特会出错不支持并行计算主动攻击者反转密文分组中的某些比特时，明文分组中相对应的比特也会被反转CRYPTREC推荐 CTR模式CounTeR 计数器模式不需要填充（padding）可实现进行加密、解密的准备加密、解密使用相同的结构对包含某些错误比特的密文进行解密时，只有明文中相对应的比特会出错支持并行计算（加密、解密）主动攻击者反转密文分组中的某些比特时，明文分组中相对应的比特也会被反转CRYPTREC推荐《实用密码学》推荐 第5章 公钥密码——用公钥加密，用私钥解密密钥配送问题 通过事先共享密钥来解决（部分场景不现实） 通过密钥分配中心来解决（中心负担大，被破坏代价大风险高） 通过Diffie-Hellman密钥交换来解决（第11章） 通过公钥密码来解决（本章后续） 公钥密码一些特征 发送者只需要加密密钥 接收者只需要解密密钥 解密密钥不可以被窃听者获取 加密密钥被窃听者获取也没问题 无法解决的问题 解决了密钥配送问题，但是无门需要判断所得到的公钥是否正确合法，这个问题被称为公钥认证问题（后面章节）。 速度是对称密的几百分之一，解决方法后面会讲到。 时钟运算补充一些数论知识 除法：在模12的条件下两个数相乘为1，“类倒数”。可以发现规律，和12的最大公约数为1的数（5，7，11），即于12互质的数，存在倒数。 乘方：可以先模再乘，应用同余的性质。 对数：时钟运算中对数成为离散对数。能快速求出离散对数的算法到现在还没有被发现，Diffie-Hellman密钥交换协议以及ElGamal公钥算法中就运用了离散对数。 RSA]]></content>
      <categories>
        <category>密码学</category>
      </categories>
      <tags>
        <tag>密码学</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[《银河帝国8：我，机器人》读书笔记]]></title>
    <url>%2Fpost%2F7ef8a98f.html</url>
    <content type="text"><![CDATA[内容摘录机器人学三大法则 机器人不得伤害人类，或因不作为而使人类受到伤害。 除非违背第一法则，机器人必须服从人类的命令。 在不违背第一及第二法则的情况下，机器人必须保护自己。 第五篇 骗子！ P115 “‘你们的教科书里什么也没有；你们的科学知识一堆搜集来的数据，靠临时的理论粘在一起——而且全都简单到不可思议，简直真不值得我浪费时间。让我感兴趣的是你们的小说。你们会研究人类的动机以及情感的互动关系……’” P132 “厄比身子抵住了墙壁，双腿跪了下来。‘停止！’他尖叫道，‘关上你的心灵！它充满了痛苦、挫折和恨意！我不是故意的，我不骗你！我试图帮助你们，我把你们想听的话告诉你们。我不得不这样做！’” 第六篇 消失无踪 P143 “‘凯文博士，我们要么就是必须舍弃机器人，要么就是对第一法则做些修改——结果我们选择了后者。’……‘并没有取消它，只是作些修改。’寇纳尔解释道，‘这样制成的正子脑，仅含有第一法则的积极部分，也就是：机器人不得伤害人类，到此为止。不再有强迫性的要求，要他们防止外在因素伤害人类，比方说伽马射线。我这样说正确吧，玻格特博士?’” P152 “机器人心理学家说：‘假如修订型机器人从某人上方抛下一个重物，只要他在这样做的时候，明白自己具有足够的力量和反应速度，能在重物砸到那人之前将它抓走，他就不会违反第一法则。然而一旦重物离手，他就不再是主动的媒介，起作用的只剩下盲目的重力。然后那机器人久能改变心意，只要他不作为，就能让重物砸下去。修订后的第一法则允许这个行动。’” 第七篇 逃避！ P200 “接下来就很明显，那项资料进入它的计算机制后，产生了控制恒星际跃迁最短时段的方程式——这意味着人的死亡。统一公司的机器会完全崩溃，正是由于这个原因。但我已将死亡的严重性贬低——并非整个取消，因为第一法则永远无法违反——刚好足以让金头脑能对这个方程式多看一眼；足以给它时间去了解，这段时期过后，那些人会起死回生——正如太空船中的物质和能量会重新出现。换句话说，这个所谓的‘死亡’绝对只是暂时现象。你们懂了吗？”]]></content>
      <categories>
        <category>阅读</category>
      </categories>
      <tags>
        <tag>阅读</tag>
        <tag>小说</tag>
        <tag>艾萨克·阿西莫夫</tag>
        <tag>银河帝国</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[【HDU-2222】解题报告（AC自动机）]]></title>
    <url>%2Fpost%2Fd899bd9.html</url>
    <content type="text"></content>
      <categories>
        <category>编程</category>
        <category>ACM</category>
      </categories>
  </entry>
  <entry>
    <title><![CDATA[【CSU-2056】解题报告（思维，KMP，去0）]]></title>
    <url>%2Fpost%2F448da703.html</url>
    <content type="text"><![CDATA[原始题目2056: a simple game Time Limit: 1 Sec Memory Limit: 128 Mb Submitted: 412 Solved: 73 Description这一天，小A和小B在玩一个游戏，他俩每人都有一个整数，然后两人轮流对他们的整数进行操作，每次在下列两个操作任选一个： （1）对整数进行翻转，如1234翻转成4321 ，1200翻转成21 （2）将整数除以10，如1234/10=123，1/10=0 当操作过程中出现a==b时，则小A就赢了，而操作一直进行下去或不能使a==b则算小B赢。 现在小A求助于你，想让你帮他在知道两人的整数时小A能不能赢，假设每次都是小A先手，并且两人都是采取最优策略 Input首先输入$ T (T \le 100)$，表示有T组数据，然后接下来有$T$行，每行有两个整数$a,b ( 0 \le a,b &lt; 10100000)$。 Output有$T$行，当小A赢了则输出”Yes”,否则输出”No” Sample Input4 1234 123 123 321 1234 12345 123 123 Sample OutputYes Yes No Yes HintSourceAuthorwsf 题目大意如题 解题思路 如果将A，B的整数看作字符串，那两种操作就是反转，去尾。 两人都采取最优策略，考虑小A什么时候输，即B可以无限翻转而A永远不能将自己的串通过两种操作达到B字符串的状态。 那么当B的串或B反转后的串是A的子串时，A就是必赢的 考虑一些特殊情况。 由于末尾0的存在会在反转中自动去掉，所以要提前预处理一下，把末尾0去掉 正方各一次KMP即可。 解题代码123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293//#include &lt;bits/stdc++.h&gt;#include &lt;cstdio&gt; #include &lt;cstring&gt;#include &lt;cstdlib&gt;#include &lt;iostream&gt;#include &lt;iomanip&gt;#include &lt;string&gt;#include &lt;map&gt;#include &lt;set&gt;#include &lt;algorithm&gt;#include &lt;queue&gt;#include &lt;vector&gt;#define pb push_back#define mp make_pairusing namespace std;typedef long long LL;typedef pair&lt;int,int&gt; PII;#define PI acos((double)-1)#define E exp(double(1))#define K 1000000+9#define rep(i,a,n) for(int i=a;i&lt;n;i++)#define per(i,a,n) for(int i=n-1;i&gt;=a;i--)#define ms(x,a) memset((x),(a),sizeof(a))const int maxn=1e6+5;int nt[maxn],nt2[maxn] ;char a[maxn],b[maxn],b2[maxn];int n,m;//参数为模板串和next数组//字符串均从下标0开始void kmpGetNext(char *s,int *Next)&#123; Next[0]=0; int len=strlen(s); for(int i=1,j=0;i&lt;len;i++) &#123; while(j&amp;&amp;s[i]!=s[j]) j=Next[j]; if(s[i]==s[j]) j++; Next[i+1]=j; &#125;// Next[len]=0;&#125;int kmp(char *ss,char *s,int *Next)&#123; kmpGetNext(s,Next);// 调试输出Next数组// int len=strlen(s);// for(int i=0;i&lt;=len;i++)// cout&lt;&lt;Next[i]&lt;&lt;" ";// cout&lt;&lt;endl; int ans=0; int len1=strlen(ss); int len2=strlen(s); for(int i=0,j=0;i&lt;len1;i++) &#123; while(j&amp;&amp;ss[i]!=s[j])j=Next[j]; if(ss[i]==s[j]) j++; if(j==len2)&#123; return 1; &#125; &#125; return 0;// return ans;&#125;int main(void)&#123;// ios::sync_with_stdio(false); int t; scanf("%d",&amp;t); while(t--) &#123; memset(nt,0,sizeof(nt)); memset(nt2,0,sizeof(nt2)); scanf("%s",a); scanf("%s",b); int len1=strlen(a); int len2=strlen(b); while (a[len1-1] == '0'&amp;&amp;len1 &gt; 1) a[--len1] = '\0'; while (b[len2-1] == '0'&amp;&amp;len2 &gt; 1) b[--len2] = '\0'; rep(i,0,len2) b2[i]=b[len2-1-i]; b2[len2]='\0'; // printf("b1= %s\nb2= %s\n",b,b2); if(kmp(a,b,nt)||kmp(a,b2,nt2)) printf("Yes\n"); else printf("No\n"); &#125; return 0;&#125; 收获与反思 思维+KMP]]></content>
      <categories>
        <category>编程</category>
        <category>ACM</category>
      </categories>
      <tags>
        <tag>ACM</tag>
        <tag>算法</tag>
        <tag>CSU</tag>
        <tag>2018暑假集训</tag>
        <tag>KMP</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[【HDU-3746】解题报告（KMP，循环节）]]></title>
    <url>%2Fpost%2Fbb7f8e97.html</url>
    <content type="text"><![CDATA[原始题目Cyclic Nacklace Time Limit: 2000/1000 MS (Java/Others) Memory Limit: 32768/32768 K (Java/Others) Total Submission(s): 14437 Accepted Submission(s): 6022 Problem DescriptionCC always becomes very depressed at the end of this month, he has checked his credit card yesterday, without any surprise, there are only 99.9 yuan left. he is too distressed and thinking about how to tide over the last days. Being inspired by the entrepreneurial spirit of “HDU CakeMan”, he wants to sell some little things to make money. Of course, this is not an easy task. As Christmas is around the corner, Boys are busy in choosing christmas presents to send to their girlfriends. It is believed that chain bracelet is a good choice. However, Things are not always so simple, as is known to everyone, girl’s fond of the colorful decoration to make bracelet appears vivid and lively, meanwhile they want to display their mature side as college students. after CC understands the girls demands, he intends to sell the chain bracelet called CharmBracelet. The CharmBracelet is made up with colorful pearls to show girls’ lively, and the most important thing is that it must be connected by a cyclic chain which means the color of pearls are cyclic connected from the left to right. And the cyclic count must be more than one. If you connect the leftmost pearl and the rightmost pearl of such chain, you can make a CharmBracelet. Just like the pictrue below, this CharmBracelet’s cycle is 9 and its cyclic count is 2: Now CC has brought in some ordinary bracelet chains, he wants to buy minimum number of pearls to make CharmBracelets so that he can save more money. but when remaking the bracelet, he can only add color pearls to the left end and right end of the chain, that is to say, adding to the middle is forbidden. CC is satisfied with his ideas and ask you for help. InputThe first line of the input is a single integer $T ( 0 &lt; T \le 100 )$ which means the number of test cases. Each test case contains only one line describe the original ordinary chain to be remade. Each character in the string stands for one pearl and there are 26 kinds of pearls being described by ‘a’ ~’z’ characters. The length of the string $Len$: $( 3 \le Len \le 100000 )$. OutputFor each case, you are required to output the minimum count of pearls added to make a CharmBracelet. Sample Input3 aaa abca abcde Sample Output0 2 5 Authorpossessor WC SourceHDU 3rd “Vegetable-Birds Cup” Programming Open Contest Recommendlcy 题目大意有一个手环，由不同珠子构成，若要让他成为一个“魅力手环”需要使手环由大于等于两个，完全相同的首尾相接的子串构成。问需要补充多少珠子使手环变为魅力手环。 解题思路 求循环节以及判断是否完全循环，求差值 解题代码1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465666768697071727374757677787980818283848586878889//#include &lt;bits/stdc++.h&gt;#include &lt;cstdio&gt; #include &lt;cstring&gt;#include &lt;cstdlib&gt;#include &lt;iostream&gt;#include &lt;iomanip&gt;#include &lt;string&gt;#include &lt;map&gt;#include &lt;set&gt;#include &lt;algorithm&gt;#include &lt;queue&gt;#include &lt;vector&gt;#define pb push_back#define mp make_pairusing namespace std;typedef long long LL;typedef pair&lt;int,int&gt; PII;#define PI acos((double)-1)#define E exp(double(1))#define K 1000000+9#define rep(i,a,n) for(int i=a;i&lt;n;i++)#define per(i,a,n) for(int i=n-1;i&gt;=a;i--)#define ms(x,a) memset((x),(a),sizeof(a))const int maxn=1e6+5; int nt[maxn];char a[maxn],b[maxn];int n;//参数为模板串和next数组//字符串均从下标0开始void kmpGetNext(char *s,int *Next)&#123; Next[0]=0; int len=strlen(s); for(int i=1,j=0;i&lt;len;i++) &#123; while(j&amp;&amp;s[i]!=s[j]) j=Next[j]; if(s[i]==s[j]) j++; Next[i+1]=j; &#125;// Next[len]=0;&#125;int kmp(char *ss,char *s,int *Next)&#123; kmpGetNext(s,Next);// 调试输出Next数组// int len=strlen(s);// for(int i=0;i&lt;=n;i++)// cout&lt;&lt;Next[i]&lt;&lt;" ";// cout&lt;&lt;endl; // int ans=0;// int len1=strlen(ss);// int len2=strlen(s); for(int i=0,j=0;i&lt;2*n;i++) //倍长 &#123; while(j&amp;&amp;ss[i%n]!=s[j])j=Next[j]; if(ss[i%n]==s[j]) j++; if(j==n)&#123; return 1; &#125; &#125; return 0;&#125;int main(void)&#123; int t; scanf("%d",&amp;t); while(t--)&#123; scanf("%s",a); memset(nt,0,sizeof(nt)); n=strlen(a); kmpGetNext(a,nt); int ans; int k = n-nt[n];//循环节大小 if(k == n) //不循环，补充相同一串 ans = n; else if(n % k == 0) //完全循环，不需要补充 ans = 0; else //补充剩下的 ans = k - (n % k); printf("%d\n",ans); // cout&lt;&lt;endl; &#125; &#125; 收获与反思 对于KMP循环节的问题 $n-nt[n]$求得最长循环节的大小（可能是自身） $n%(n-nt[n])$求剩下的尾巴大小（可用来判断是不是完全循环）]]></content>
      <categories>
        <category>编程</category>
        <category>ACM</category>
      </categories>
      <tags>
        <tag>ACM</tag>
        <tag>算法</tag>
        <tag>2018暑假集训</tag>
        <tag>KMP</tag>
        <tag>HDU</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[【HDU-1686】解题报告（KMP）]]></title>
    <url>%2Fpost%2F6501181e.html</url>
    <content type="text"><![CDATA[原始题目Oulipo Time Limit: 3000/1000 MS (Java/Others) Memory Limit: 32768/32768 K (Java/Others) Total Submission(s): 21478 Accepted Submission(s): 8336 Problem DescriptionThe French author Georges Perec (1936–1982) once wrote a book, La disparition, without the letter ‘e’. He was a member of the Oulipo group. A quote from the book: Tout avait Pair normal, mais tout s’affirmait faux. Tout avait Fair normal, d’abord, puis surgissait l’inhumain, l’affolant. Il aurait voulu savoir où s’articulait l’association qui l’unissait au roman : stir son tapis, assaillant à tout instant son imagination, l’intuition d’un tabou, la vision d’un mal obscur, d’un quoi vacant, d’un non-dit : la vision, l’avision d’un oubli commandant tout, où s’abolissait la raison : tout avait l’air normal mais… Perec would probably have scored high (or rather, low) in the following contest. People are asked to write a perhaps even meaningful text on some subject with as few occurrences of a given “word” as possible. Our task is to provide the jury with a program that counts these occurrences, in order to obtain a ranking of the competitors. These competitors often write very long texts with nonsense meaning; a sequence of 500,000 consecutive ‘T’s is not unusual. And they never use spaces. So we want to quickly find out how often a word, i.e., a given string, occurs in a text. More formally: given the alphabet {‘A’, ‘B’, ‘C’, …, ‘Z’} and two finite strings over that alphabet, a word W and a text T, count the number of occurrences of W in T. All the consecutive characters of W must exactly match consecutive characters of T. Occurrences may overlap. InputThe first line of the input file contains a single number: the number of test cases to follow. Each test case has the following format: One line with the word W, a string over {‘A’, ‘B’, ‘C’, …, ‘Z’}, with 1 ≤ |W| ≤ 10,000 (here |W| denotes the length of the string W). One line with the text T, a string over {‘A’, ‘B’, ‘C’, …, ‘Z’}, with |W| ≤ |T| ≤ 1,000,000. OutputFor every test case in the input file, the output should contain a single number, on a single line: the number of occurrences of the word W in the text T. Sample Input3 BAPC BAPC AZA AZAZAZA VERDI AVERDXIVYERDIAN Sample Output1 3 0 Source华东区大学生程序设计邀请赛_热身赛 Recommendlcy 题目大意 计算T中W的出现次数，W的所有连续字符必须与T的连续字符完全匹配，可能重叠。 解题思路 裸KMP 解题代码123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081//#include &lt;bits/stdc++.h&gt;#include &lt;cstdio&gt; #include &lt;cstring&gt;#include &lt;cstdlib&gt;#include &lt;iostream&gt;#include &lt;iomanip&gt;#include &lt;string&gt;#include &lt;map&gt;#include &lt;set&gt;#include &lt;algorithm&gt;#include &lt;queue&gt;#include &lt;vector&gt;#define pb push_back#define mp make_pairusing namespace std;typedef long long LL;typedef pair&lt;int,int&gt; PII;#define PI acos((double)-1)#define E exp(double(1))#define K 1000000+9#define rep(i,a,n) for(int i=a;i&lt;n;i++)#define per(i,a,n) for(int i=n-1;i&gt;=a;i--)#define ms(x,a) memset((x),(a),sizeof(a))int nt[10006];char a[K],b[10005];int n,m;//参数为模板串和next数组//字符串均从下标0开始void kmpGetNext(char *s,int *Next)&#123; Next[0]=0; int len=strlen(s); for(int i=1,j=0;i&lt;len;i++) &#123; while(j&amp;&amp;s[i]!=s[j]) j=Next[j]; if(s[i]==s[j]) j++; Next[i+1]=j; &#125;// Next[len]=0;&#125;int kmp(char *ss,char *s,int *Next)&#123; kmpGetNext(s,Next);// 调试输出Next数组// int len=strlen(s);// for(int i=0;i&lt;=len;i++)// cout&lt;&lt;Next[i]&lt;&lt;" ";// cout&lt;&lt;endl; int ans=0; int len1=strlen(ss); int len2=strlen(s); for(int i=0,j=0;i&lt;len1;i++) &#123; while(j&amp;&amp;ss[i]!=s[j])j=Next[j]; if(ss[i]==s[j]) j++; if(j==len2)&#123; ans++;// return i-len2+2; &#125; &#125;// return -1; return ans;&#125;int main(void)&#123; int t; scanf("%d",&amp;t); while(t--) &#123; memset(a,0,sizeof(a)); memset(b,0,sizeof(b)); scanf("%s",b); scanf("%s",a); cout&lt;&lt; kmp(a,b,nt)&lt;&lt;endl; &#125; return 0;&#125; 收获与反思 KMP水题]]></content>
      <categories>
        <category>编程</category>
        <category>ACM</category>
      </categories>
      <tags>
        <tag>ACM</tag>
        <tag>算法</tag>
        <tag>2018暑假集训</tag>
        <tag>KMP</tag>
        <tag>HDU</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[【HDU-1358】解题报告（KMP，循环节）]]></title>
    <url>%2Fpost%2F3a3eaae1.html</url>
    <content type="text"></content>
      <categories>
        <category>编程</category>
        <category>ACM</category>
      </categories>
  </entry>
  <entry>
    <title><![CDATA[【HDU-2087】解题报告（KMP，去重）]]></title>
    <url>%2Fpost%2Fc5672df5.html</url>
    <content type="text"><![CDATA[原始题目剪花布条 Time Limit: 1000/1000 MS (Java/Others) Memory Limit: 32768/32768 K (Java/Others) Total Submission(s): 28902 Accepted Submission(s): 17700 Problem Description一块花布条，里面有些图案，另有一块直接可用的小饰条，里面也有一些图案。对于给定的花布条和小饰条，计算一下能从花布条中尽可能剪出几块小饰条来呢？ Input输入中含有一些数据，分别是成对出现的花布条和小饰条，其布条都是用可见ASCII字符表示的，可见的ASCII字符有多少个，布条的花纹也有多少种花样。花纹条和小饰条不会超过1000个字符长。如果遇见#字符，则不再进行工作。 Output输出能从花纹布中剪出的最多小饰条个数，如果一块都没有，那就老老实实输出0，每个结果之间应换行。 Sample Inputabcde a3 aaaaaa aa # Sample Output0 3 Authorqianneng Source冬练三九之二 Recommendlcy 题目大意如题 解题思路 模板加一句$Next[len]=0$，去重即可。 解题代码12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364656667686970717273747576777879808182//#include &lt;bits/stdc++.h&gt;#include &lt;cstdio&gt; #include &lt;cstring&gt;#include &lt;cstdlib&gt;#include &lt;iostream&gt;#include &lt;iomanip&gt;#include &lt;string&gt;#include &lt;map&gt;#include &lt;set&gt;#include &lt;algorithm&gt;#include &lt;queue&gt;#include &lt;vector&gt;#define pb push_back#define mp make_pairusing namespace std;typedef long long LL;typedef pair&lt;int,int&gt; PII;#define PI acos((double)-1)#define E exp(double(1))#define K 1000000+9#define rep(i,a,n) for(int i=a;i&lt;n;i++)#define per(i,a,n) for(int i=n-1;i&gt;=a;i--)#define ms(x,a) memset((x),(a),sizeof(a))int nt[10006];char a[K],b[10005];int n,m;//参数为模板串和next数组//字符串均从下标0开始void kmpGetNext(char *s,int *Next)&#123; Next[0]=0; int len=strlen(s); for(int i=1,j=0;i&lt;len;i++) &#123; while(j&amp;&amp;s[i]!=s[j]) j=Next[j]; if(s[i]==s[j]) j++; Next[i+1]=j; &#125;// Next[len]=0;&#125;int kmp(char *ss,char *s,int *Next)&#123; kmpGetNext(s,Next);// 调试输出Next数组// int len=strlen(s);// for(int i=0;i&lt;=len;i++)// cout&lt;&lt;Next[i]&lt;&lt;" ";// cout&lt;&lt;endl; int ans=0; int len1=strlen(ss); int len2=strlen(s); for(int i=0,j=0;i&lt;len1;i++) &#123; while(j&amp;&amp;ss[i]!=s[j])j=Next[j]; if(ss[i]==s[j]) j++; if(j==len2)&#123; ans++;// return i-len2+2; &#125; &#125;// return -1; return ans;&#125;int main(void)&#123;// ios::sync_with_stdio(false); int t; scanf("%d",&amp;t); while(t--) &#123; memset(a,0,sizeof(a)); memset(b,0,sizeof(b)); scanf("%s",a); scanf("%s",b); cout&lt;&lt; kmp(a,b,nt)&lt;&lt;endl; &#125; return 0;&#125; 收获与反思 KMP水题]]></content>
      <categories>
        <category>编程</category>
        <category>ACM</category>
      </categories>
      <tags>
        <tag>ACM</tag>
        <tag>算法</tag>
        <tag>2018暑假集训</tag>
        <tag>KMP</tag>
        <tag>HDU</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[【CSU-1598】解题报告（KMP）]]></title>
    <url>%2Fpost%2F9a9a4797.html</url>
    <content type="text"><![CDATA[原始题目1598: 最长公共前缀 Time Limit: 1 Sec Memory Limit: 128 Mb Submitted: 222 Solved: 186 Description给定两个字符串$s$和$t$，现有一个扫描器，从$s$的最左边开始向右扫描，每次扫描到一个$t$就把这一段删除，输出能发现$t$的个数。 Input第一行包含一个整数$ T ( T \le 50)$ ，表示数据组数。每组数据第一行包含一个字符串$s$，第二行一个字符串$t$，字符串长度不超过$1000000$。 Output对于每组数据，输出答案。 Sample Input2 ababab ab ababab ba Sample Output 3 2 HintSource国防科学技术大学第十八届银河之光文化节ACM程序设计竞赛初赛 题目大意如题 解题思路 加一个$Next[m]=0$即匹配完成后删除这一段（去重） 不过这个题目水，不加也过了 解题代码12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364656667686970717273747576777879808182//#include &lt;bits/stdc++.h&gt;#include &lt;cstdio&gt; #include &lt;cstring&gt;#include &lt;cstdlib&gt;#include &lt;iostream&gt;#include &lt;iomanip&gt;#include &lt;string&gt;#include &lt;map&gt;#include &lt;set&gt;#include &lt;algorithm&gt;#include &lt;queue&gt;#include &lt;vector&gt;#define pb push_back#define mp make_pairusing namespace std;typedef long long LL;typedef pair&lt;int,int&gt; PII;#define PI acos((double)-1)#define E exp(double(1))#define K 1000000+9#define rep(i,a,n) for(int i=a;i&lt;n;i++)#define per(i,a,n) for(int i=n-1;i&gt;=a;i--)#define ms(x,a) memset((x),(a),sizeof(a))int nt[10006];char a[K],b[10005];int n,m;//参数为模板串和next数组//字符串均从下标0开始void kmpGetNext(char *s,int *Next)&#123; Next[0]=0; int len=strlen(s); for(int i=1,j=0;i&lt;len;i++) &#123; while(j&amp;&amp;s[i]!=s[j]) j=Next[j]; if(s[i]==s[j]) j++; Next[i+1]=j; &#125; Next[len]=0;&#125;int kmp(char *ss,char *s,int *Next)&#123; kmpGetNext(s,Next);// 调试输出Next数组// int len=strlen(s);// for(int i=0;i&lt;=len;i++)// cout&lt;&lt;Next[i]&lt;&lt;" ";// cout&lt;&lt;endl; int ans=0; int len1=strlen(ss); int len2=strlen(s); for(int i=0,j=0;i&lt;len1;i++) &#123; while(j&amp;&amp;ss[i]!=s[j])j=Next[j]; if(ss[i]==s[j]) j++; if(j==len2)&#123; ans++;// return i-len2+2; &#125; &#125;// return -1; return ans;&#125;int main(void)&#123;// ios::sync_with_stdio(false); int t; scanf("%d",&amp;t); while(t--) &#123; memset(a,0,sizeof(a)); memset(b,0,sizeof(b)); scanf("%s",a); scanf("%s",b); cout&lt;&lt; kmp(a,b,nt)&lt;&lt;endl; &#125; return 0;&#125; 收获与反思 KMP水题]]></content>
      <categories>
        <category>编程</category>
        <category>ACM</category>
      </categories>
      <tags>
        <tag>ACM</tag>
        <tag>算法</tag>
        <tag>CSU</tag>
        <tag>2018暑假集训</tag>
        <tag>KMP</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[【CSU-1581】解题报告（思维，KMP）]]></title>
    <url>%2Fpost%2F742966af.html</url>
    <content type="text"><![CDATA[原始题目Problem H: Clock Pictures1581: Clock Pictures Time Limit: 3 Sec Memory Limit: 128 Mb Submitted: 322 Solved: 82 DescriptionYou have two pictures of an unusual kind of clock. The clock has n hands, each having the same length and no kind of marking whatsoever. Also, the numbers on the clock are so faded that you can’t even tell anymore what direction is up in the picture. So the only thing that you see on the pictures, are n shades of the n hands, and nothing else. You’d like to know if both images might have been taken at exactly the same time of the day, possibly with the camera rotated at different angles. Given the description of the two images, determine whether it is possible that these two pictures could be showing the same clock displaying the same time. InputThe ﬁrst line contains a single integer $n$ $(2 ≤ n ≤ 200 000)$, the number of hands on the clock. Each of the next two lines contains n integers $a_i$ $(0 ≤ a_i &lt; 360 000)$,representing the angles of the hands of the clock on one of the images,in thousandths of a degree. The ﬁrst line represents the position of the hands on the ﬁrst image, whereas the second line corresponds to the second image. The number $a_i$ denotes the angle between the recorded position of some hand and the upward direction in the image, measured clockwise. Angles of the same clock are distinct and are not given in any speciﬁc order. OutputOutput one line containing one word: possible if the clocks could be showing the same time,impossible otherwise. Sample Input6 1 2 3 4 5 6 7 6 5 4 3 1 Sample Outputimpossible HINT题目大意 一个有$n$个指针的表盘，看不清数字，以随机顺序给出n个指针相对记录位置（不固定）的顺时针旋转角度，问两个表盘经过旋转是否能够重合（是否表示一个表盘）。 解题思路 对于相同表盘，记录位置不固定，但是两个指针间的角度差固定，判断位移后可不可以相同。 注意第一个指针和末尾指针的角度差需要补3600000 将一组倍长做KMP可以解决这个问题，若位移后可以相同，那么倍长后2倍距离必包含另一串。 解题代码12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364656667686970717273747576777879808182838485868788899091929394//#include &lt;bits/stdc++.h&gt;#include &lt;cstdio&gt;#include &lt;cstring&gt;#include &lt;cstdlib&gt;#include &lt;iostream&gt;#include &lt;iomanip&gt;#include &lt;string&gt;#include &lt;map&gt;#include &lt;set&gt;#include &lt;algorithm&gt;#include &lt;queue&gt;#include &lt;vector&gt;#define pb push_back#define mp make_pairusing namespace std;typedef long long LL;typedef pair&lt;int,int&gt; PII;#define PI acos((double)-1)#define E exp(double(1))#define K 1000000+9#define rep(i,a,n) for(int i=a;i&lt;n;i++)#define per(i,a,n) for(int i=n-1;i&gt;=a;i--)#define ms(x,a) memset((x),(a),sizeof(a))const int maxn=2e5+5; int nt[maxn];int aa[maxn],bb[maxn];int a[maxn],b[maxn];int n;//参数为模板串和next数组//字符串均从下标0开始void kmpGetNext(int *s,int *Next)&#123; Next[0]=0;// int len=strlen(s); for(int i=1,j=0;i&lt;n;i++) &#123; while(j&amp;&amp;s[i]!=s[j]) j=Next[j]; if(s[i]==s[j]) j++; Next[i+1]=j; &#125;// Next[len]=0;&#125;int kmp(int *ss,int *s,int *Next)&#123; kmpGetNext(s,Next);// 调试输出Next数组// int len=strlen(s);// for(int i=0;i&lt;=n;i++)// cout&lt;&lt;Next[i]&lt;&lt;" ";// cout&lt;&lt;endl; // int ans=0;// int len1=strlen(ss);// int len2=strlen(s); for(int i=0,j=0;i&lt;2*n;i++) //倍长 &#123; while(j&amp;&amp;ss[i%n]!=s[j])j=Next[j]; if(ss[i%n]==s[j]) j++; if(j==n)&#123; return 1; &#125; &#125; return 0;&#125;int main(void)&#123; ios::sync_with_stdio(false); while(cin&gt;&gt;n) &#123; memset(a,0,sizeof(a)); memset(b,0,sizeof(b)); rep(i,0,n) cin&gt;&gt;aa[i]; rep(i,0,n) cin&gt;&gt;bb[i]; sort(aa,aa+n); sort(bb,bb+n); rep(i,0,n-1)&#123; a[i]=aa[i+1]-aa[i]; b[i]=bb[i+1]-bb[i]; &#125; a[n-1]=360000+aa[0]-aa[n-1];// rep(i,0,n) cout&lt;&lt;a[i]&lt;&lt;" ";// cout&lt;&lt;endl; b[n-1]=360000+bb[0]-bb[n-1];// rep(i,0,n) cout&lt;&lt;b[i]&lt;&lt;" ";// cout&lt;&lt;endl; if(kmp(a,b,nt)) cout&lt;&lt;"possible"&lt;&lt;endl; else cout&lt;&lt;"impossible"&lt;&lt;endl; &#125; return 0;&#125; 收获与反思 仔细读题，分析题目 倍长KMP可以判断自身位移的情况。]]></content>
      <categories>
        <category>编程</category>
        <category>ACM</category>
      </categories>
      <tags>
        <tag>ACM</tag>
        <tag>算法</tag>
        <tag>CSU</tag>
        <tag>2018暑假集训</tag>
        <tag>KMP</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[【HDU-6373】解题报告（物理力学，模拟，2018杭电多校第六场）]]></title>
    <url>%2Fpost%2Fd73de254.html</url>
    <content type="text"><![CDATA[原始题目Pinball Time Limit: 2000/1000 MS (Java/Others) Memory Limit: 262144/262144 K (Java/Others) Total Submission(s): 604 Accepted Submission(s): 264 Problem DescriptionThere is a slope on the 2D plane. The lowest point of the slope is at the origin. There is a small ball falling down above the slope. Your task is to find how many times the ball has been bounced on the slope. It’s guarantee that the ball will not reach the slope or ground or Y-axis with a distance of less than 1 from the origin. And the ball is elastic collision without energy loss. Gravity acceleration $g=9.8m/s^2$. InputThere are multiple test cases. The first line of input contains an integer T (1 ≤ T ≤ 100), indicating the number of test cases. The first line of each test case contains four integers a, b, x, y (1 ≤ a, b, -x, y ≤ 100), indicate that the slope will pass through the point(-a, b), the initial position of the ball is (x, y). OutputOutput the answer. It’s guarantee that the answer will not exceed 50. Sample Input1 5 1 -5 3 Sample Output2 Source2018 Multi-University Training Contest 6 Recommendchendu 题目大意 给定一个从原点向一个方向延长的斜板，以及初始小球的坐标，重力加速度。求能在斜板上弹跳几次（不考虑能量损失） 解题思路 物理题，把运动分解成沿板方向和垂直于板的方向的分运动，求出沿板子运动的时间$t1$，垂直于板子运动的（每一次上升/下降）的时间$t2$。 考虑一下，当$(2n+1)t2 \lebs t1 &lt; (2(n+1)+1)t2 $ 时，n即为答案 解题代码12345678910111213141516171819202122232425262728293031323334353637383940#include &lt;bits/stdc++.h&gt;#include &lt;cstdio&gt;#include &lt;cmath&gt;#include &lt;cstdlib&gt;#include &lt;cstring&gt;#include &lt;iostream&gt;#include &lt;set&gt;#include &lt;iomanip&gt;#include &lt;algorithm&gt;#include &lt;queue&gt;#include &lt;map&gt;#include &lt;string&gt;#define INF 0x3f3f3f3f#define rep(i,a,n) for(int i=a;i&lt;n;i++)#define per(i,a,n) for(int i=n-1;i&gt;=a;i--)#define ms(x,a) memset((x),(a),sizeof(a))using namespace std;const int maxn=1e5+5;int n,m,t;double a,b,x,y;void solve()&#123; double alfa=atan(b/a); double y1=(y-x*tan(alfa))*cos(alfa); double x1=y*sin(alfa)+x*cos(alfa);// cout&lt;&lt;y1&lt;&lt;" "&lt;&lt;x1&lt;&lt;endl; int n=floor(sqrt(x1/y1*a/b)); cout&lt;&lt;(n+1)/2&lt;&lt;endl;&#125;int main()&#123; ios::sync_with_stdio(false); cin&gt;&gt;t; while(t--)&#123; cin&gt;&gt;a&gt;&gt;b&gt;&gt;x&gt;&gt;y; x=-x; solve(); &#125;&#125; 收获与反思 分运动看时间比判断，队友想出来的= =。]]></content>
      <categories>
        <category>编程</category>
        <category>ACM</category>
      </categories>
      <tags>
        <tag>ACM</tag>
        <tag>算法</tag>
        <tag>2018暑假集训</tag>
        <tag>HDU</tag>
        <tag>2018杭电多校</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[【HDU-6362】解题报告（数学，积分，2018杭电多校第六场）]]></title>
    <url>%2Fpost%2Fb3ee770c.html</url>
    <content type="text"><![CDATA[原始题目oval-and-rectangle Time Limit: 2000/1000 MS (Java/Others) Memory Limit: 32768/32768 K (Java/Others) Total Submission(s): 647 Accepted Submission(s): 310 Problem DescriptionPatrick Star find an oval. The half of longer axes is on the x-axis with length $a$. The half of shorter axes is on the y-axis with length $b$. Patrick Star plan to choose a real number c randomly from $[0,b]$, after that, Patrick Star will get a rectangle : The four vertexes of it are on the outline of the oval. The two sides of it parallel to coordinate axis. One of its side is $y=c$. Patrick Star want to know the expectations of the rectangle’s perimeter. InputThe first line contain a integer $T$ (no morn than 10), the following is $T$ test case, for each test case : Each line contains contains two integer $a, b (0&lt;b&lt;a&lt;105)$. Separated by an white space. OutputFor each test case output one line denotes the expectations of the rectangle’s perimeter . You should keep exactly 6 decimal digits and ignore the remain decimal digits. It is guaranted that the 7-th decimal digit of answer wont be 0 or 9. Sample Input1 2 1 Sample Output8.283185 Source2018 Multi-University Training Contest 6 Recommendchendu 题目大意 椭圆半长轴为$a$，半短轴为$b$，从区间$[0,b]$随机抽实数$c$，求过$(0,c)$点的与椭圆内切，四边与坐标轴平行的长方形周长 解题思路 是个积分题，不过直接用积分函数计算到制定精度会T（没错我就这么T了一发） 手动算一下 最后除以b得到答案 注意要求不四舍五入，精度应该输出$ans-0.0000005$ 解题代码12345678910111213141516171819202122232425262728293031#include &lt;bits/stdc++.h&gt;#include &lt;cstdio&gt;#include &lt;cmath&gt;#include &lt;cstdlib&gt;#include &lt;cstring&gt;#include &lt;iostream&gt;#include &lt;set&gt;#include &lt;iomanip&gt;#include &lt;algorithm&gt;#include &lt;queue&gt;#include &lt;map&gt;#include &lt;string&gt;#define INF 0x3f3f3f3f#define rep(i,a,n) for(int i=a;i&lt;n;i++)#define per(i,a,n) for(int i=n-1;i&gt;=a;i--)#define ms(x,a) memset((x),(a),sizeof(a))using namespace std;const int maxn=1e5+5;#define PI acos(-1.0)int n,m,t;int a,b;int main()&#123; ios::sync_with_stdio(false); cin&gt;&gt;t; while(t--)&#123; cin&gt;&gt;a&gt;&gt;b; double ans=a*PI+2*b; cout&lt;&lt;fixed&lt;&lt;setprecision(6)&lt;&lt;ans-0.0000005&lt;&lt;endl; &#125;&#125; 收获与反思 高数教做人系列]]></content>
      <categories>
        <category>编程</category>
        <category>ACM</category>
      </categories>
      <tags>
        <tag>ACM</tag>
        <tag>算法</tag>
        <tag>2018暑假集训</tag>
        <tag>HDU</tag>
        <tag>2018杭电多校</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[【UVALive-3942】解题报告（字典树，dp）]]></title>
    <url>%2Fpost%2Ff279299a.html</url>
    <content type="text"><![CDATA[原始题目 题目大意 给定一个文本串和n个字符串，用这n个字符串组合成文本串有多少种可能。 解题思路 先将n个字符串储存到字典树里。 考虑DP $dp[i]$表示前i位字符进行第一次分割的可能数目 i从len-1-&gt;0逆序遍历，j从i到len-1遍历。 只要遍历j时遇到染色结点，表明可以在此再分割一次，由此推出状态转移方程。$dp[i] = (dp[i] + dp[j + 1]) % mod$ 解题代码123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145#include &lt;cstdio&gt;#include &lt;cstring&gt;#include &lt;iostream&gt;#include &lt;cstdlib&gt;#include &lt;set&gt;#include &lt;string&gt;#include &lt;cstring&gt;#include &lt;stack&gt;#define rep(i,a,n) for(int i=a;i&lt;n;i++)#define per(i,a,n) for(int i=n-1;i&gt;=a;i--)#define ms(x,a) memset((x),(a),sizeof(x))using namespace std;const int maxn=3e5+5;const int maxl=26;const int mod=20071027;typedef long long ll;typedef struct Trie&#123; int v; Trie* next[maxl];&#125;Trie; Trie *root;void iniTrie()&#123; root=(Trie*)malloc(sizeof(Trie)); for(int i=0;i&lt;maxl;i++) root-&gt;next[i]=NULL; root-&gt;v=-1;&#125;void creTrie(char* a)&#123; int l=strlen(a); Trie *p=root,*q; for(int i=0;i&lt;l;i++) &#123; int id=a[i]-'a'; //并非前缀不能有相同，而是不能在相同的分支上。 if(p-&gt;next[id]!=NULL) &#123; p=p-&gt;next[id]; if(i==l-1)&#123; p-&gt;v=1; return; &#125; &#125; else&#123; q=(Trie*)malloc(sizeof(Trie)); q-&gt;v=0; for(int j=0;j&lt;maxl;j++) q-&gt;next[j]=NULL; p-&gt;next[id]=q; p=p-&gt;next[id]; if(i==l-1)&#123; p-&gt;v=1; return; &#125; &#125; &#125;&#125;bool findTrie(string b)&#123; Trie *p=root; int l=b.length(); for(int i=0;i&lt;l;i++)&#123; int index=b[i]-'a'; if(p-&gt;next[index]!=NULL) p=p-&gt;next[index]; else return false; &#125; return p-&gt;v;&#125;void delTrie(Trie *p) &#123; int i; for(i=0;i&lt;maxl;i++) &#123; if(p-&gt;next[i] != NULL) delTrie(p-&gt;next[i]); &#125; free(p);// printf("1"); p==NULL; return ;&#125; int n,kase;int dp[maxn];char raw[maxn],s[1000];int Dp(char *s, int len) &#123; dp[len] = 1; for (int i = len - 1; i &gt;= 0; --i) &#123; Trie *pp = root;//根节点 for (int j = i; j &lt; len; ++j) &#123; int temp = s[j]-'a'; //cout &lt;&lt; s[j] &lt;&lt; endl; if (pp-&gt;next[temp] == NULL) &#123;//同dfs退出原理 break; &#125; pp = pp-&gt;next[temp]; if (pp-&gt;v == true) &#123; dp[i] = (dp[i] + dp[j + 1]) % mod;//更新方案数 //cout &lt;&lt; j + 1 &lt;&lt; " " &lt;&lt; len &lt;&lt; endl; &#125; &#125; dp[i] %= mod; &#125; return dp[0]; &#125;void solve()&#123; int ans=0; int len=strlen(raw); ms(dp,0); ans=Dp(raw,len); cout &lt;&lt; "Case " &lt;&lt; ++kase &lt;&lt; ": "; cout&lt;&lt;ans&lt;&lt;endl; &#125;int main()&#123;// freopen("in.txt", "r", stdin); ios::sync_with_stdio(false); while(cin&gt;&gt;raw)&#123; iniTrie(); cin&gt;&gt;n; rep(i,0,n)&#123; cin&gt;&gt;s; creTrie(s); &#125; solve(); delTrie(root); &#125;&#125; 收获与反思 字典树与dp结合 记忆化，dp的思想很重要！]]></content>
      <categories>
        <category>编程</category>
        <category>ACM</category>
      </categories>
      <tags>
        <tag>ACM</tag>
        <tag>算法</tag>
        <tag>DP</tag>
        <tag>2018暑假集训</tag>
        <tag>字典树</tag>
        <tag>UVALive</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[【CSU-1216】解题报告（01字典树，异或最大值）]]></title>
    <url>%2Fpost%2F16fa37a4.html</url>
    <content type="text"><![CDATA[原始题目1216: 异或最大值 Time Limit: 2 Sec Memory Limit: 128 Mb Submitted: 1282 Solved: 460 Description给定一些数，求这些数中两个数的异或值最大的那个值 Input多组数据。第一行为数字个数$n (1 \le n \le 10 ^ 5)$。接下来$n$行每行一个32位有符号非负整数。 Output任意两数最大异或值 Sample Input3 3 7 9 Sample Output14 HintSourceCSGrandeur的数据结构习题 题目大意如题 解题思路 和HDU-4825都是求异或最大值，裸的01字典树 正解： 每个数用二进制数表示，用32位的0、1数组（高位在前）储存到01字典树中。 对于每次询问q，将q也表示成01串，从高位到低位每次贪心的顺着字典树向下找相反的结点（0找1，1找0），因为这样可以保证让两个数的异或值尽可能地大（所以一定要从高位向下找）。 解题代码123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129#include &lt;cstdio&gt;#include &lt;cstring&gt;#include &lt;iostream&gt;#include &lt;cstdlib&gt;#include &lt;set&gt;#include &lt;string&gt;#include &lt;cstring&gt;#include &lt;stack&gt;#define rep(i,a,n) for(int i=a;i&lt;n;i++)#define per(i,a,n) for(int i=n-1;i&gt;=a;i--)#define ms(x,a) memset((x),(a),sizeof(a))#define L 32using namespace std;const int maxn=1e5+5;const int maxl=2;typedef long long ll;typedef struct Trie&#123; int v; Trie* next[maxl];&#125;Trie; Trie *root;void iniTrie()&#123; root=(Trie*)malloc(sizeof(Trie)); for(int i=0;i&lt;maxl;i++) root-&gt;next[i]=NULL; root-&gt;v=-1;&#125;void creTrie(int a)&#123; int temp[35]; int id=L-1; while(a)&#123; temp[id--]=(a&amp;1); a/=2; &#125; rep(i,0,id+1) temp[i]=0;// rep(i,0,L) cout&lt;&lt;temp[i];// cout&lt;&lt;endl&lt;&lt;endl; int l=L; Trie *p=root,*q; for(int i=0;i&lt;l;i++) &#123; int id=temp[i]; //并非前缀不能有相同，而是不能在相同的分支上。 if(p-&gt;next[id]!=NULL) &#123; p=p-&gt;next[id];// p-&gt;v++; &#125; else&#123; q=(Trie*)malloc(sizeof(Trie)); q-&gt;v=1; for(int j=0;j&lt;maxl;j++) q-&gt;next[j]=NULL; p-&gt;next[id]=q; p=p-&gt;next[id]; &#125; &#125;&#125;int findTrie(int a)&#123; int aa=a; int temp[35]; int id=L-1; while(a)&#123; temp[id--]=(a&amp;1); a/=2; &#125;// cout&lt;&lt;"#"&lt;&lt;a&lt;&lt;endl; rep(i,0,id+1) temp[i]=0; int aans=0; Trie *p=root; int l=L; for(int i=0;i&lt;l;i++)&#123; int index=!temp[i];// cout&lt;&lt;"index="&lt;&lt;index&lt;&lt;endl; if(p-&gt;next[index]!=NULL)&#123; aans=(aans&lt;&lt;1)+index; p=p-&gt;next[index]; &#125; else&#123; aans=(aans&lt;&lt;1)+temp[i]; p=p-&gt;next[temp[i]]; &#125; &#125; return aans^aa;&#125;void delTrie(Trie *p) &#123; int i; for(i=0;i&lt;maxl;i++) &#123; if(p-&gt;next[i] != NULL) delTrie(p-&gt;next[i]); &#125; free(p);// printf("1"); p==NULL; return ;&#125; int a[maxn],n;int main()&#123; ios::sync_with_stdio(false); while(cin&gt;&gt;n)&#123; iniTrie(); rep(i,0,n)&#123; cin&gt;&gt;a[i]; creTrie(a[i]); &#125; int fans=0; rep(i,0,n)&#123; fans=max(fans,findTrie(a[i])); &#125; cout&lt;&lt;fans&lt;&lt;endl; delTrie(root); &#125; &#125; 收获与反思 异或最大值可以考虑01字典树。]]></content>
      <categories>
        <category>编程</category>
        <category>ACM</category>
      </categories>
      <tags>
        <tag>ACM</tag>
        <tag>算法</tag>
        <tag>CSU</tag>
        <tag>2018暑假集训</tag>
        <tag>字典树</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[【HDU-4825】解题报告（01字典树，异或最大值）]]></title>
    <url>%2Fpost%2F6d52b9f2.html</url>
    <content type="text"><![CDATA[原始题目Xor Sum Time Limit: 2000/1000 MS (Java/Others) Memory Limit: 132768/132768 K (Java/Others) Total Submission(s): 4756 Accepted Submission(s): 2076 Problem DescriptionZeus 和 Prometheus 做了一个游戏，Prometheus 给 Zeus 一个集合，集合中包含了$N$个正整数，随后 Prometheus 将向 Zeus 发起$M$次询问，每次询问中包含一个正整数 $S$ ，之后 Zeus 需要在集合当中找出一个正整数 $K$ ，使得 $K$ 与 $S$ 的异或结果最大。Prometheus 为了让 Zeus 看到人类的伟大，随即同意 Zeus 可以向人类求助。你能证明人类的智慧么？ Input输入包含若干组测试数据，每组测试数据包含若干行。 输入的第一行是一个整数$ T(T &lt; 10)$，表示共有$T$组数据。 每组数据的第一行输入两个正整数$N,M( 1 &lt;\le N,M \le 100000)$，接下来一行，包含$N$个正整数，代表 Zeus 的获得的集合，之后$M$行，每行一个正整数$S$，代表 Prometheus 询问的正整数。所有正整数均不超过$2^{32}$。 Output对于每组数据，首先需要输出单独一行”Case #?:”，其中问号处应填入当前的数据组数，组数从1开始计算。 对于每个询问，输出一个正整数K，使得K与S异或值最大。 Sample Input2 3 2 3 4 5 1 5 4 1 4 6 5 6 3 Sample OutputCase #1: 4 3 Case #2: 4 Source2014年百度之星程序设计大赛 - 资格赛 Recommendliuyiding 题目大意如题 解题思路 直接找的话复杂度O（m*n），会T（本题显然不可能这么简单啊） 正解： 每个数用二进制数表示，用32位的0、1数组（高位在前）储存到01字典树中。 对于每次询问q，将q也表示成01串，从高位到低位每次贪心的顺着字典树向下找相反的结点（0找1，1找0），因为这样可以保证让两个数的异或值尽可能地大（所以一定要从高位向下找）。 解题代码123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135#include &lt;cstdio&gt;#include &lt;cstring&gt;#include &lt;iostream&gt;#include &lt;cstdlib&gt;#include &lt;set&gt;#include &lt;string&gt;#include &lt;cstring&gt;#include &lt;stack&gt;#define rep(i,a,n) for(int i=a;i&lt;n;i++)#define per(i,a,n) for(int i=n-1;i&gt;=a;i--)#define ms(x,a) memset((x),(a),sizeof(a))#define debugin freopen("in.txt","r",stdin)#define debugout freopen("out.txt","w",stdout)#define L 32using namespace std;const int maxn=1e5+5;const int maxl=2;typedef long long ll;typedef struct Trie&#123; int v; Trie* next[maxl];&#125;Trie; Trie *root;void iniTrie()&#123; root=(Trie*)malloc(sizeof(Trie)); for(int i=0;i&lt;maxl;i++) root-&gt;next[i]=NULL; root-&gt;v=-1;&#125;void creTrie(int a)&#123; int temp[35]; int id=L-1; while(a)&#123; temp[id--]=(a&amp;1); a/=2; &#125; rep(i,0,id+1) temp[i]=0;// rep(i,0,L) cout&lt;&lt;temp[i];// cout&lt;&lt;endl&lt;&lt;endl; int l=L; Trie *p=root,*q; for(int i=0;i&lt;l;i++) &#123; int id=temp[i]; //并非前缀不能有相同，而是不能在相同的分支上。 if(p-&gt;next[id]!=NULL) &#123; p=p-&gt;next[id];// p-&gt;v++; &#125; else&#123; q=(Trie*)malloc(sizeof(Trie)); q-&gt;v=1; for(int j=0;j&lt;maxl;j++) q-&gt;next[j]=NULL; p-&gt;next[id]=q; p=p-&gt;next[id]; &#125; &#125;&#125;int findTrie(int a)&#123;// int aa=a; int temp[35]; int id=L-1; while(a)&#123; temp[id--]=(a&amp;1); a/=2; &#125;// cout&lt;&lt;"#"&lt;&lt;a&lt;&lt;endl; rep(i,0,id+1) temp[i]=0; int aans=0; Trie *p=root; int l=L; for(int i=0;i&lt;l;i++)&#123; int index=!temp[i];// cout&lt;&lt;"index="&lt;&lt;index&lt;&lt;endl; if(p-&gt;next[index]!=NULL)&#123; aans=(aans&lt;&lt;1)+index; p=p-&gt;next[index]; &#125; else&#123; aans=(aans&lt;&lt;1)+temp[i]; p=p-&gt;next[temp[i]]; &#125; &#125; return aans; &#125;void delTrie(Trie *p) &#123; int i; for(i=0;i&lt;maxl;i++) &#123; if(p-&gt;next[i] != NULL) delTrie(p-&gt;next[i]); &#125; free(p);// printf("1"); p==NULL; return ;&#125; int a[maxn],n,t,m;int main()&#123; ios::sync_with_stdio(false);// debugin;// debugout; cin&gt;&gt;t; rep(l,1,t+1)&#123; cout&lt;&lt;"Case #"&lt;&lt;l&lt;&lt;":"&lt;&lt;endl; cin&gt;&gt;n&gt;&gt;m; //n树m询问 iniTrie(); rep(i,0,n)&#123; cin&gt;&gt;a[i]; creTrie(a[i]); &#125; rep(i,0,m)&#123; cin&gt;&gt;a[i]; cout&lt;&lt;findTrie(a[i])&lt;&lt;endl; &#125; delTrie(root); &#125; &#125; 收获与反思 异或最大值可以考虑01字典树。]]></content>
      <categories>
        <category>编程</category>
        <category>ACM</category>
      </categories>
      <tags>
        <tag>ACM</tag>
        <tag>算法</tag>
        <tag>2018暑假集训</tag>
        <tag>字典树</tag>
        <tag>HDU</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[【HDU-1251】解题报告（字典树）]]></title>
    <url>%2Fpost%2F585293b8.html</url>
    <content type="text"><![CDATA[原始题目统计难题 Time Limit: 4000/2000 MS (Java/Others) Memory Limit: 131070/65535 K (Java/Others) Total Submission(s): 55180 Accepted Submission(s): 19275 Problem DescriptionIgnatius最近遇到一个难题,老师交给他很多单词(只有小写字母组成,不会有重复的单词出现),现在老师要他统计出以某个字符串为前缀的单词数量(单词本身也是自己的前缀). Input输入数据的第一部分是一张单词表,每行一个单词,单词的长度不超过10,它们代表的是老师交给Ignatius统计的单词,一个空行代表单词表的结束.第二部分是一连串的提问,每行一个提问,每个提问都是一个字符串. 注意:本题只有一组测试数据,处理到文件结束. Output对于每个提问,给出以该字符串为前缀的单词的数量. Sample Inputbanana band bee absolute acm ba b band abc Sample Output2 3 1 0 AuthorIgnatius.L RecommendIgnatius.L 题目大意如题 解题思路 字典树裸题，建立字典树时每个单词每个结点权值++ 访问的时候不在树上输出0，在的话输出结尾结点的权值。 解题代码123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107#include &lt;cstdio&gt;#include &lt;cstring&gt;#include &lt;iostream&gt;#include &lt;cstdlib&gt;#include &lt;set&gt;#include &lt;string&gt;#include &lt;cstring&gt;#include &lt;stack&gt;using namespace std;const int maxn=1e5+5;const int maxl=26;typedef long long ll;typedef struct Trie&#123; int v; Trie* next[maxl];&#125;Trie; Trie *root;void iniTrie()&#123; root=(Trie*)malloc(sizeof(Trie)); for(int i=0;i&lt;maxl;i++) root-&gt;next[i]=NULL; root-&gt;v=-1;&#125;void creTrie(char* a)&#123; int l=strlen(a); Trie *p=root,*q; for(int i=0;i&lt;l;i++) &#123; int id=a[i]-'a'; //并非前缀不能有相同，而是不能在相同的分支上。 if(p-&gt;next[id]!=NULL) &#123; p=p-&gt;next[id]; p-&gt;v++; &#125; else&#123; q=(Trie*)malloc(sizeof(Trie)); q-&gt;v=1; for(int j=0;j&lt;maxl;j++) q-&gt;next[j]=NULL; p-&gt;next[id]=q; p=p-&gt;next[id]; &#125; &#125;&#125;//void printTrie()//&#123;// Trie* p=root;// stack&lt;Trie*&gt;s;// s.push(p);// while(!s.empty())// &#123;// Trie *now=s.top();// s.pop();// if(now-&gt;v==1) printf("%d\n",now-&gt;v);// for(int i=0;i&lt;maxl;i++)// if(now-&gt;next[i]!=NULL)// s.push(now-&gt;next[i]); // &#125;//&#125;int printTrie(char* b)&#123; Trie *p=root; int l=strlen(b); for(int i=0;i&lt;l;i++)&#123; int index=b[i]-'a'; if(p-&gt;next[index]!=NULL) p=p-&gt;next[index]; else&#123; return 0; &#125; &#125; return p-&gt;v;&#125;void delTrie(Trie *p) &#123; int i; for(i=0;i&lt;maxl;i++) &#123; if(p-&gt;next[i] != NULL) delTrie(p-&gt;next[i]); &#125; free(p);// printf("1"); p==NULL; return ;&#125; int t,ccount;int main()&#123; char a[20],c; iniTrie(); while(gets(a)&amp;&amp;a[0]!='\0') creTrie(a); while(~scanf("%s",a)) printf("%d\n",printTrie(a)); delTrie(root);&#125; 收获与反思 字典树裸题，注意建立的时候怎么打标记（染色）。]]></content>
      <categories>
        <category>编程</category>
        <category>ACM</category>
      </categories>
      <tags>
        <tag>ACM</tag>
        <tag>算法</tag>
        <tag>2018暑假集训</tag>
        <tag>字典树</tag>
        <tag>HDU</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[【POJ-1200】解题报告（字符串hash，进制）]]></title>
    <url>%2Fpost%2Fbc8586da.html</url>
    <content type="text"><![CDATA[原始题目Crazy Search Time Limit: 1000MS Memory Limit: 65536K Total Submissions: 32268 Accepted: 8900 DescriptionMany people like to solve hard puzzles some of which may lead them to madness. One such puzzle could be finding a hidden prime number in a given text. Such number could be the number of different substrings of a given size that exist in the text. As you soon will discover, you really need the help of a computer and a good algorithm to solve such a puzzle. Your task is to write a program that given the size, N, of the substring, the number of different characters that may occur in the text, NC, and the text itself, determines the number of different substrings of size N that appear in the text. As an example, consider N=3, NC=4 and the text “daababac”. The different substrings of size 3 that can be found in this text are: “daa”; “aab”; “aba”; “bab”; “bac”. Therefore, the answer should be 5. InputThe first line of input consists of two numbers, N and NC, separated by exactly one space. This is followed by the text where the search takes place. You may assume that the maximum number of substrings formed by the possible set of characters does not exceed 16 Millions. OutputThe program should output just an integer corresponding to the number of different substrings of size N found in the given text. Sample Input3 4 daababac Sample Output5 HintHuge input,scanf is recommended. SourceSouthwestern Europe 2002 题目大意 最多由nc种字符构成的原字符串，求长度为n的子串共有多少种。解题思路 字符串hash 由于最多不超过nc种字符，把每种字符映射到1到nc，字串即可看作类似nc进制的数（不含0） 用set或者vis数组维护一下记录不同数的个数即可。解题代码1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556//#include &lt;bits/stdc++.h&gt;#include &lt;cstdio&gt;#include &lt;cmath&gt;#include &lt;cstdlib&gt;#include &lt;cstring&gt;#include &lt;iostream&gt;#include &lt;set&gt;#include &lt;iomanip&gt;#include &lt;algorithm&gt;#include &lt;queue&gt;#include &lt;map&gt;#include &lt;string&gt;#define INF 0x3f3f3f3f#define rep(i,a,n) for(int i=a;i&lt;n;i++)#define per(i,a,n) for(int i=n-1;i&gt;=a;i--)#define ms(x,a) memset((x),(a),sizeof(a))using namespace std;const int maxn=1e5+5;#define PI acos(-1.0)typedef long long ll;typedef unsigned long long ull;int letter[300];char s[1000005];bool myhash[20000005];int n,nc;int main()&#123; ios::sync_with_stdio(false); while(cin&gt;&gt;n&gt;&gt;nc&gt;&gt;s)&#123; memset(letter,0,sizeof(letter)); memset(myhash,0,sizeof(myhash)); int len=strlen(s); int cnt=0; rep(i,0,len)&#123; if(!letter[s[i]]) &#123; letter[s[i]]=++cnt; if(cnt==nc) break; &#125; &#125; int ans=0; rep(i,0,len-n+1)&#123; int sum=0; for(int j=i;j&lt;i+n;j++)&#123; sum=sum*nc+letter[s[j]]; &#125; if(!myhash[sum])&#123;// cout&lt;&lt;"i="&lt;&lt;i&lt;&lt;endl; ans++; myhash[sum]=1; &#125; else continue; &#125; cout&lt;&lt;ans&lt;&lt;endl; &#125;&#125; 收获与反思 简单字符串hash，没有涉及取模操作]]></content>
      <categories>
        <category>编程</category>
        <category>ACM</category>
      </categories>
      <tags>
        <tag>ACM</tag>
        <tag>算法</tag>
        <tag>2018暑假集训</tag>
        <tag>字符串hash</tag>
        <tag>POJ</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[【HDU-1711】解题报告（KMP模板题，字符串hash）]]></title>
    <url>%2Fpost%2F531de0f8.html</url>
    <content type="text"><![CDATA[原始题目Number Sequence Time Limit: 10000/5000 MS (Java/Others) Memory Limit: 32768/32768 K (Java/Others) Total Submission(s): 39142 Accepted Submission(s): 16165 Problem DescriptionGiven two sequences of numbers : a[1], a[2], …… , a[N], and b[1], b[2], …… , b[M] (1 ≤ M ≤ 10000, 1 ≤ N ≤ 1000000). Your task is to find a number K which make a[K] = b[1], a[K + 1] = b[2], …… , a[K + M - 1] = b[M]. If there are more than one K exist, output the smallest one. InputThe first line of input is a number T which indicate the number of cases. Each case contains three lines. The first line is two numbers N and M (1 ≤ M ≤ 10000, 1 ≤ N ≤ 1000000). The second line contains N integers which indicate a[1], a[2], …… , a[N]. The third line contains M integers which indicate b[1], b[2], …… , b[M]. All integers are in the range of [-1000000, 1000000]. OutputFor each test case, you should output one line which only contain K described above. If no such K exists, output -1 instead. Sample Input2 13 5 1 2 1 2 3 1 2 3 1 3 2 1 2 1 2 3 1 3 13 5 1 2 1 2 3 1 2 3 1 3 2 1 2 1 2 3 2 1 Sample Output6 -1 SourceHDU 2007-Spring Programming Contest Recommendlcy 题目大意 给定一个数字串和一个模式串，输出最早匹配的位置，没有输出-1。 解题思路 KMP把字符匹配改成int即可。 解题代码123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869//#include &lt;bits/stdc++.h&gt;#include &lt;cstdio&gt; #include &lt;cstring&gt;#include &lt;cstdlib&gt;#include &lt;iostream&gt;#include &lt;iomanip&gt;#include &lt;string&gt;#include &lt;map&gt;#include &lt;set&gt;#include &lt;algorithm&gt;#include &lt;queue&gt;#include &lt;vector&gt;#define pb push_back#define mp make_pairusing namespace std;typedef long long LL;typedef pair&lt;int,int&gt; PII;#define PI acos((double)-1)#define E exp(double(1))#define K 1000000+9#define rep(i,a,n) for(int i=a;i&lt;n;i++)#define per(i,a,n) for(int i=n-1;i&gt;=a;i--)#define ms(x,a) memset((x),(a),sizeof(a))int nt[10006];int a[K],b[10005],n,m;//参数为模板串和next数组//字符串均从下标0开始void kmp_next(int *T,int *nt)&#123; nt[0]=0; for(int i=1,j=0;i&lt;m;i++) &#123; while(j&amp;&amp;T[i]!=T[j])j=nt[j-1]; if(T[i]==T[j])j++; nt[i]=j; &#125;&#125;int kmp(int *S,int *T,int *nt)&#123; kmp_next(T,nt); int ans=0; //n //m for(int i=0,j=0;i&lt;n;i++) &#123; while(j&amp;&amp;S[i]!=T[j])j=nt[j-1]; if(S[i]==T[j])j++; if(j==m)&#123;// ans++; return i-m+2; &#125; &#125; return -1;&#125;int main(void)&#123; ios::sync_with_stdio(false); int t;cin&gt;&gt;t; while(t--) &#123; cin&gt;&gt;n&gt;&gt;m; rep(i,0,n) cin&gt;&gt;a[i]; rep(i,0,m) cin&gt;&gt;b[i]; cout&lt;&lt; kmp(a,b,nt)&lt;&lt;endl; &#125; return 0;&#125;//1 2 1 2 3 1 2 3 1 3 2 1 2 3 1 2 3 收获与反思 单模匹配考虑KMP，熟悉模板和算法。]]></content>
      <categories>
        <category>编程</category>
        <category>ACM</category>
      </categories>
      <tags>
        <tag>ACM</tag>
        <tag>算法</tag>
        <tag>2018暑假集训</tag>
        <tag>KMP</tag>
        <tag>HDU</tag>
        <tag>字符串hash</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[【HDU-1224】解题报告（最长路，路径）]]></title>
    <url>%2Fpost%2Fcd18de84.html</url>
    <content type="text"><![CDATA[原始题目Free DIY Tour Time Limit: 2000/1000 MS (Java/Others) Memory Limit: 65536/32768 K (Java/Others) Total Submission(s): 8700 Accepted Submission(s): 2805 Problem DescriptionWeiwei is a software engineer of ShiningSoft. He has just excellently fulfilled a software project with his fellow workers. His boss is so satisfied with their job that he decide to provide them a free tour around the world. It’s a good chance to relax themselves. To most of them, it’s the first time to go abroad so they decide to make a collective tour. The tour company shows them a new kind of tour circuit - DIY circuit. Each circuit contains some cities which can be selected by tourists themselves. According to the company’s statistic, each city has its own interesting point. For instance, Paris has its interesting point of 90, New York has its interesting point of 70, ect. Not any two cities in the world have straight flight so the tour company provide a map to tell its tourists whether they can got a straight flight between any two cities on the map. In order to fly back, the company has made it impossible to make a circle-flight on the half way, using the cities on the map. That is, they marked each city on the map with one number, a city with higher number has no straight flight to a city with lower number. Note: Weiwei always starts from Hangzhou(in this problem, we assume Hangzhou is always the first city and also the last city, so we mark Hangzhou both 1 and N+1), and its interesting point is always 0. Now as the leader of the team, Weiwei wants to make a tour as interesting as possible. If you were Weiwei, how did you DIY it? InputThe input will contain several cases. The first line is an integer T which suggests the number of cases. Then T cases follows. Each case will begin with an integer N(2 ≤ N ≤ 100) which is the number of cities on the map. Then N integers follows, representing the interesting point list of the cities. And then it is an integer M followed by M pairs of integers [Ai, Bi] (1 ≤ i ≤ M). Each pair of [Ai, Bi] indicates that a straight flight is available from City Ai to City Bi. OutputFor each case, your task is to output the maximal summation of interesting points Weiwei and his fellow workers can get through optimal DIYing and the optimal circuit. The format is as the sample. You may assume that there is only one optimal circuit. Output a blank line between two cases. Sample Input2 3 0 70 90 4 1 2 1 3 2 4 3 4 3 0 90 70 4 1 2 1 3 2 4 3 4 Sample OutputCASE 1# points : 90 circuit : 1-&gt;3-&gt;1 CASE 2# points : 90 circuit : 1-&gt;2-&gt;1 AuthorJGShining（极光炫影） Source杭州电子科技大学第三届程序设计大赛 RecommendIgnatius.L 题目大意 自定义旅途路线，1和n+1结点权值为0，剩下结点权值给定，有向图，求最长路。 解题思路 改了一下Dijkstra最短路算法竟然A了。 解题代码123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108#include &lt;cstdio&gt;#include &lt;cstring&gt;#include &lt;string&gt;#include &lt;algorithm&gt;#include &lt;iostream&gt;#include &lt;stack&gt;#include &lt;set&gt;#include &lt;vector&gt;#include &lt;queue&gt;#include &lt;cmath&gt;#include &lt;cstdlib&gt;#include &lt;bits/stdc++.h&gt; using namespace std;#define eps 1e-8#define INF 0x3f3f3f3f#define rep(i,a,n) for(int i=a;i&lt;n;i++)#define per(i,a,n) for(int i=n-1;i&gt;=a;i--)#define all(x) x.begin(),x.end()#define pb push_back#define np next_permutation#define ms(x,a) memset((x),(a),sizeof(x))//优先队列迪杰斯特拉 const int maxn=1e5+5;struct Edge&#123; int u,v,w; Edge(int _u,int _v,int _w):u(_u),v(_v),w(_w)&#123; &#125;;&#125;;vector &lt;Edge&gt; edges[maxn];int dis[maxn],path[maxn],num[maxn],ans[maxn];bool vis[maxn];int n,m,uu,vv,ww,t;void init()&#123; //n个结点的边集都清空 rep(i,0,maxn)&#123; edges[i].clear(); &#125; ms(vis,0); ms(dis,-INF); ms(path,0); ms(num,0);&#125;void addEdge(int u,int v,int w)&#123; edges[u].pb(Edge(u,v,w));&#125;struct Node&#123; int Id,W; Node(int _Id,int _W):Id(_Id),W(_W)&#123; &#125;; bool operator &lt; (const Node &amp;b) const &#123;W&lt;b.W;&#125;&#125;;void Dijkstra(int s)&#123; priority_queue &lt;Node&gt; q; q.push(Node(s,0)) ,dis[s]=0; while(!q.empty())&#123; Node now=q.top(); q.pop(); int index=now.Id; if(dis[index]!=now.W) continue; rep(i,0,edges[index].size())&#123;// cout&lt;&lt;"dis="&lt;&lt;dis[edges[index][i].v]&lt;&lt;" new cost="&lt;&lt;dis[index]+edges[index][i].w; if(dis[edges[index][i].v]&lt;dis[index]+edges[index][i].w)&#123; dis[edges[index][i].v]=dis[index]+edges[index][i].w; q.push(Node(edges[index][i].v,dis[edges[index][i].v])); path[edges[index][i].v]=index;// cout&lt;&lt;" #"&lt;&lt; edges[index][i].v&lt;&lt;" #"&lt;&lt;index&lt;&lt;endl; &#125; &#125; &#125;&#125;int main()&#123;// freopen("in.txt","r",stdin); ios::sync_with_stdio(false); cin&gt;&gt;t; rep(T,1,t+1)&#123; if(T!=1) cout&lt;&lt;endl; cin&gt;&gt;n; init(); rep(i,1,n+1)&#123; cin&gt;&gt;num[i]; //输入点权值 &#125; cin&gt;&gt;m; rep(i,1,m+1)&#123; cin&gt;&gt;uu&gt;&gt;vv; addEdge(uu,vv,num[uu]); &#125; Dijkstra(1); //预处理路径 int cnt=0,ini=n+1; while(1)&#123; ans[cnt++]=ini; ini=path[ini]; if(ini==1) break; &#125; ans[cnt]=1; //输出 cout&lt;&lt;"CASE "&lt;&lt;T&lt;&lt;"#"&lt;&lt;endl&lt;&lt;"points : "&lt;&lt;dis[n+1]&lt;&lt;endl; cout&lt;&lt;"circuit : "; for(int i=cnt;i&gt;0;i--) cout&lt;&lt;ans[i]&lt;&lt;"-&gt;"; cout&lt;&lt;1&lt;&lt;endl; &#125; &#125; 收获与反思 需要研究一下Dij可否算最长路]]></content>
      <categories>
        <category>编程</category>
        <category>ACM</category>
      </categories>
      <tags>
        <tag>ACM</tag>
        <tag>算法</tag>
        <tag>Dijkstra</tag>
        <tag>HDU</tag>
        <tag>最长路</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[【HDU-2544】解题报告（最短路，dij）]]></title>
    <url>%2Fpost%2F34a049ac.html</url>
    <content type="text"><![CDATA[原始题目最短路 Time Limit: 5000/1000 MS (Java/Others) Memory Limit: 32768/32768 K (Java/Others) Total Submission(s): 88011 Accepted Submission(s): 38096 Problem Description在每年的校赛里，所有进入决赛的同学都会获得一件很漂亮的t-shirt。但是每当我们的工作人员把上百件的衣服从商店运回到赛场的时候，却是非常累的！所以现在他们想要寻找最短的从商店到赛场的路线，你可以帮助他们吗？ Input输入包括多组数据。每组数据第一行是两个整数N、M（N≤100，M≤10000），N表示成都的大街上有几个路口，标号为1的路口是商店所在地，标号为N的路口是赛场所在地，M则表示在成都有几条路。N=M=0表示输入结束。接下来M行，每行包括3个整数A，B，C（1≤A,B≤N,1≤C≤1000）,表示在路口A与路口B之间有一条路，我们的工作人员需要C分钟的时间走过这条路。输入保证至少存在1条商店到赛场的路线。 Output对于每组输入，输出一行，表示工作人员从商店走到赛场的最短时间 Sample Input2 1 1 2 3 3 3 1 2 5 2 3 5 3 1 2 0 0 Sample Output3 2 SourceUESTC 6th Programming Contest Online Recommendlcy 题目大意如题 解题思路 单源正权，Dijkstra最短路模板题 解题代码123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384#include &lt;cstdio&gt;#include &lt;cstring&gt;#include &lt;string&gt;#include &lt;algorithm&gt;#include &lt;iostream&gt;#include &lt;stack&gt;#include &lt;set&gt;#include &lt;vector&gt;#include &lt;queue&gt;#include &lt;cmath&gt;#include &lt;cstdlib&gt;#include &lt;bits/stdc++.h&gt; using namespace std;#define eps 1e-8#define INF 0x3f3f3f3f#define rep(i,a,n) for(int i=a;i&lt;n;i++)#define per(i,a,n) for(int i=n-1;i&gt;=a;i--)#define all(x) x.begin(),x.end()#define pb push_back#define np next_permutation#define ms(x,a) memset((x),(a),sizeof(x))//优先队列迪杰斯特拉 const int maxn=1e5+5;struct Edge&#123; int u,v,w; Edge(int _u,int _v,int _w):u(_u),v(_v),w(_w)&#123; &#125;;&#125;;vector &lt;Edge&gt; edges[maxn];int dis[maxn];bool vis[maxn];int n,m,uu,vv,ww;void init(int n)&#123; //n个结点的边集都清空 rep(i,0,maxn)&#123; edges[i].clear(); &#125;&#125;void addEdge(int u,int v,int w)&#123; edges[u].pb(Edge(u,v,w));&#125;struct Node&#123; int Id,W; Node(int _Id,int _W):Id(_Id),W(_W)&#123; &#125;; bool operator &lt; (const Node &amp;b) const &#123;W&gt;b.W;&#125;&#125;;void Dijkstra(int s)&#123; ms(vis,0); ms(dis,INF); priority_queue &lt;Node&gt; q; q.push(Node(s,0)) ,dis[s]=0; while(!q.empty())&#123; Node now=q.top(); q.pop(); int index=now.Id; if(dis[index]!=now.W) continue; rep(i,0,edges[index].size())&#123; if(dis[edges[index][i].v]&gt;dis[index]+edges[index][i].w)&#123; dis[edges[index][i].v]=dis[index]+edges[index][i].w; q.push(Node(edges[index][i].v,dis[edges[index][i].v])); &#125; &#125; &#125;&#125;int main()&#123; ios::sync_with_stdio(false); while(cin&gt;&gt;n&gt;&gt;m&amp;&amp;n+m)&#123; init(n); rep(i,1,m+1)&#123; cin&gt;&gt;uu&gt;&gt;vv&gt;&gt;ww; addEdge(uu,vv,ww); addEdge(vv,uu,ww); &#125; Dijkstra(1); cout&lt;&lt;dis[n]&lt;&lt;endl; &#125; &#125; 收获与反思 理解熟悉模板]]></content>
      <categories>
        <category>编程</category>
        <category>ACM</category>
      </categories>
      <tags>
        <tag>ACM</tag>
        <tag>算法</tag>
        <tag>2018暑假集训</tag>
        <tag>Dijkstra</tag>
        <tag>最短路</tag>
        <tag>HDU</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[《刺杀骑士团长》读书笔记]]></title>
    <url>%2Fpost%2Fd81c5363.html</url>
    <content type="text"><![CDATA[内容摘录第1部 显形理念篇 P95 “免色这个人物身上，总好像有悄然潜伏的什么。那个秘密已经放进带锁的小盒，深深埋入地下。很早以前埋的，如今上面长满绵柔茂密的绿草。而知晓埋那个小盒的场所的，这个世界上唯独免色一人。我不能不在其微笑的深处感觉出拥有那一类型的秘密带来的孤独。” P193 “就是有这一种类的梦。支离破碎犬牙交错的梦。每一块碎片诚然有其量感，但因相互纠缠而抵消了一尽。” P204 “我的感情在永无休止的沉默中犹如以刀具做成的沉重的摆子一样从一个极端画着大大的弧线摆向另一个极端。” P226 “就是说，在我们的人生中，现实与非现实的界线往往很难捕捉。那条界线看上去总是经常来来去去，就像每天兴之所至地随便移动的国境线——必须好好留意其动向才行。否则，就不知道自己现在是在哪一边了。我刚才说再在洞中停留下去可能危险，就是这个意思。” P293 “晚饭时间！人们大概同家人一起面对餐桌，即将把热乎乎的饭菜放入口中。我可以从那些灯光中感受到那种微笑的温煦。” P300 “‘一个人被关在又黑又窄的地方，最可怕的不是死，而是 开始考虑自己可能要永远在这里活下去，那比什么都可怕。那么一想，就吓得透不过气，就好像周围墙壁挤压过来直接把自己压瘪挤死——便是有那样汹涌的错觉。而在那里活下去，人就必须想方设法跨越那种恐惧，即克服自己。为此就需要无限接近死亡。’‘可那伴随着危险。’‘和接近太阳的伊卡洛斯一样。至于接近的极限在哪里，分辨那条生死攸关的线并非易事。那将成为玩命作业。’‘而若回避那种接近，就不能跨越恐惧克服自己。00p’” P333 “历史之中，就那样搁置在黑暗中为好的事件多的要命。正确知识未必使人丰富。客观未必凌驾于主观之上。事实未必吹灭妄想。”]]></content>
      <categories>
        <category>阅读</category>
      </categories>
      <tags>
        <tag>阅读</tag>
        <tag>小说</tag>
        <tag>村上春树</tag>
        <tag>刺杀骑士团长</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[【CSU-1980】解题报告（区间dp，树的中序遍历）]]></title>
    <url>%2Fpost%2Fdc981233.html</url>
    <content type="text"><![CDATA[原始题目1980: 不堪重负的树 Time Limit: 1 Sec Memory Limit: 128 Mb Submitted: 188 Solved: 83 Description小X非常喜欢树，然后他生成了一个大森林给自己玩。 玩着玩着，小X陷入了沉思。 一棵树由N个节点组成，编号为i的节点有一个价值Wi。 假设从树根出发前往第i个节点（可能是树根自己），一共需要经过Di个节点（包括起点和终点），那么这个节点对这棵树产生的负担就是Di与Wi的乘积。 对于一棵树而言，这棵树的负担值为所有节点对它产生的负担之和。 小X学习了dfs，如果他知道树的结构，他当然可以很容易地算出树的负担值。可是现在沉思中的小X并不知道树的结构形态，他只知道一棵二叉树的中序遍历以及每个节点的价值，那么这棵二叉树可能的最小负担值是多少呢？ Input第一行为一个正整数T(T≤20)表示数据组数。 每组数据包括三行。 第一行为一个正整数N(N≤200)。 第二行为N个正整数Wi(Wi≤108)，表示编号为i的节点的价值。 第三行为N个正整数Pi(Pi≤N)，为一个1~N的排列，表示二叉树的中序遍历结果。 Output对于每组数据，输出一行一个正整数，表示这棵树可能的最小负担值。 Sample Input2 4 1 2 3 4 1 2 3 4 7 1 1 1 1 1 1 1 4 2 3 5 7 1 6 Sample Output18 17 Hint对于第一个样例，树根为3，3的左儿子是2，3的右儿子是4，2的左儿子是1，这样构成的树可以达到最小负担。 对于第二个样例，对应的满二叉树可以达到最小负担。 Source2017年8月月赛 Authordevember 题目大意如题 解题思路 先求得中序遍历各节点的权值 预处理前缀和，以及dp数组（初始$dp[i][i]=f[i]$） 对于一棵树可以由左子树、右子树的最优解转移过来，区间dp 状态转移方程dp[i][j]=min(dp[i][k-1]+dp[k+1][j])+\sum_{m=i}^{j} f[i] (i]]></content>
      <categories>
        <category>编程</category>
        <category>ACM</category>
      </categories>
      <tags>
        <tag>ACM</tag>
        <tag>算法</tag>
        <tag>CSU</tag>
        <tag>2018暑假集训</tag>
        <tag>区间DP</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[【POJ-1651】解题报告（区间DP入门）]]></title>
    <url>%2Fpost%2F4fa396eb.html</url>
    <content type="text"><![CDATA[原始题目Multiplication Puzzle Time Limit: 1000MS Memory Limit: 65536K Total Submissions: 13111 Accepted: 8035 DescriptionThe multiplication puzzle is played with a row of cards, each containing a single positive integer. During the move player takes one card out of the row and scores the number of points equal to the product of the number on the card taken and the numbers on the cards on the left and on the right of it. It is not allowed to take out the first and the last card in the row. After the final move, only two cards are left in the row. The goal is to take cards in such order as to minimize the total number of scored points. For example, if cards in the row contain numbers 10, 1, 50, 20, 5, player might take a card with 1, then 20 and 50, scoring 10*1*50 + 50*20*5 + 10*50*5 = 500+5000+2500 = 8000If he would take the cards in the opposite order, i.e. 50, then 20, then 1, the score would be 1*50*20 + 1*20*5 + 10*1*5 = 1000+100+50 = 1150 InputThe first line of the input contains the number of cards $N (3 \le N \le 100)$. The second line contains $N$ integers in the range from $1$ to $100$, separated by spaces. OutputOutput must contain a single integer - the minimal score. Sample Input6 10 1 50 50 20 5 Sample Output3650 Source Northeastern Europe 2001, Far-Eastern Subregion 题目大意 抽卡片，分数每次增加所抽卡片以及其相邻两侧的卡片的数值。不允许抽第一个和最后一个，抽到最后仅剩下这两张卡片，求最小的分数。 解题思路 每个大区间的分数都由最后抽的一张牌分成两个小区间，区间dp问题 状态转移方程dp[i][j]=min(dp[i][k]+dp[k][j]+a[i]*a[k]*a[j]) (i\leq k \leq j)解题代码12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758#include &lt;vector&gt;#include &lt;queue&gt;#include &lt;cstdio&gt;#include &lt;cstring&gt;#include &lt;cstdlib&gt;#include &lt;iostream&gt;#include &lt;algorithm&gt;//#include &lt;bits/stdc++.h&gt;#define ms(i,a) memset((i),(a),sizeof(i))#define rep(i,a,n) for (int i=a;i&lt;n;i++)#define per(i,a,n) for (int i=n-1;i&gt;=a;i--)#define pb push_back#define mp make_pair#define np next_permutation#define all(x) x.begin(),x.end()#define fi first#define se second#define SZ(x) ((int)(x).size()) #define INF 0x3f3f3f3fusing namespace std;int n,t,m; int dp[105][105],a[105],sum[105]; //前缀和 void initial()&#123; ms(dp,0); rep(i,1,n+1)&#123; rep(j,i+2,n+1)&#123; if(j==i+2) dp[i][j]=a[i]*a[i+1]*a[i+2]; else dp[i][j]=INF; &#125; &#125; &#125;int main()&#123; ios::sync_with_stdio(false);// freopen("in.txt","r",stdin); while(cin&gt;&gt;n) &#123; sum[0]=0; rep(i,1,n+1)&#123; cin&gt;&gt;a[i];// sum[i]=sum[i-1]+m; &#125; initial(); for (int len = 4; len &lt;= n; ++len)&#123; for (int i = 1; i + len - 1 &lt;= n; ++i) &#123; int j = i + len - 1; for (int k = i; k &lt;= j; ++k) dp[i][j] = min(dp[i][j], dp[i][k] + dp[k][j] + a[i] * a[k] * a[j]);// cout&lt;&lt;"i="&lt;&lt;i&lt;&lt;" j="&lt;&lt;j&lt;&lt;" dp="&lt;&lt;dp[i][j]&lt;&lt;endl; &#125; &#125; cout&lt;&lt;dp[1][n]&lt;&lt;endl; &#125; return 0;&#125; 收获与反思 注意边界条件 注意dp数组的初始化]]></content>
      <categories>
        <category>编程</category>
        <category>ACM</category>
      </categories>
      <tags>
        <tag>ACM</tag>
        <tag>算法</tag>
        <tag>2018暑假集训</tag>
        <tag>区间DP</tag>
        <tag>POJ</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[【CSU-1592】解题报告（区间DP入门）]]></title>
    <url>%2Fpost%2Fc6d76e9a.html</url>
    <content type="text"><![CDATA[原始题目1592: 石子归并 Time Limit: 1 Sec Memory Limit: 128 Mb Submitted: 896 Solved: 421 Description现在有$n$堆石子，第$i$堆有$a_i$个石子。现在要把这些石子合并成一堆，每次只能合并相邻两个，每次合并的代价是两堆石子的总石子数。求合并所有石子的最小代价。 Input第一行包含一个整数$T ( T \le 50) $ ，表示数据组数。 每组数据第一行包含一个整数$ n ( 2 \le n \le 100 ) $，表示石子的堆数。 第二行包含$n$个正整数$ a_i ( a_i \le 100)$，表示每堆石子的石子数。 Output每组数据仅一行，表示最小合并代价。 Sample Input2 4 1 2 3 4 5 3 5 2 1 4 Sample Output19 33 HintSource国防科学技术大学第十八届银河之光文化节ACM程序设计竞赛初赛 题目大意如题 解题思路 区间dp 状态转移方程：$dp[i][j]=min(dp[i][j],dp[i][i+k]+dp[i+k+1][j]+sum[j]-sum[i-1])$; 解题代码1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859#include &lt;vector&gt;#include &lt;queue&gt;#include &lt;cstdio&gt;#include &lt;cstring&gt;#include &lt;cstdlib&gt;#include &lt;iostream&gt;#include &lt;algorithm&gt;//#include &lt;bits/stdc++.h&gt;#define ms(i,a) memset((i),(a),sizeof(i))#define rep(i,a,n) for (int i=a;i&lt;n;i++)#define per(i,a,n) for (int i=n-1;i&gt;=a;i--)#define pb push_back#define mp make_pair#define np next_permutation#define all(x) x.begin(),x.end()#define fi first#define se second#define SZ(x) ((int)(x).size()) #define INF 0x3f3f3f3fusing namespace std;int n,t,m; int dp[105][105],sum[105]; //前缀和 void initial()&#123; rep(i,1,n+1)&#123; rep(j,1,n+1)&#123; if(i==j) dp[i][j]=0; else dp[i][j]=INF; &#125; &#125; &#125;int main()&#123; ios::sync_with_stdio(false); cin&gt;&gt;t; while(t--) &#123; cin&gt;&gt;n; sum[0]=0; rep(i,1,n+1)&#123; cin&gt;&gt;m; sum[i]=sum[i-1]+m; &#125; initial(); for(int len=1; len&lt;n; len++) &#123; for(int i=1; i+len&lt;=n; i++) &#123; int j=i+len; for(int k=0; i+k&lt;j; k++) dp[i][j]=min(dp[i][j],dp[i][i+k]+dp[i+k+1][j]+sum[j]-sum[i-1]); &#125; &#125; cout&lt;&lt;dp[1][n]&lt;&lt;endl; &#125; return 0;&#125; 收获与反思 对于求区间问题最优解，考虑区间dp]]></content>
      <categories>
        <category>编程</category>
        <category>ACM</category>
      </categories>
      <tags>
        <tag>ACM</tag>
        <tag>算法</tag>
        <tag>CSU</tag>
        <tag>2018暑假集训</tag>
        <tag>区间DP</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[【HDU-1789】解题报告（贪心，多种思路）]]></title>
    <url>%2Fpost%2F9f8e212d.html</url>
    <content type="text"><![CDATA[原始题目Doing Homework again Time Limit: 1000/1000 MS (Java/Others) Memory Limit: 32768/32768 K (Java/Others) Total Submission(s): 17643 Accepted Submission(s): 10264 Problem DescriptionIgnatius has just come back school from the 30th ACM/ICPC. Now he has a lot of homework to do. Every teacher gives him a deadline of handing in the homework. If Ignatius hands in the homework after the deadline, the teacher will reduce his score of the final test. And now we assume that doing everyone homework always takes one day. So Ignatius wants you to help him to arrange the order of doing homework to minimize the reduced score. InputThe input contains several test cases. The first line of the input is a single integer T that is the number of test cases. T test cases follow.Each test case start with a positive integer N(1≤N≤1000) which indicate the number of homework.. Then 2 lines follow. The first line contains N integers that indicate the deadlines of the subjects, and the next line contains N integers that indicate the reduced scores. OutputFor each test case, you should output the smallest total reduced score, one line per test case. Sample Input3 3 3 3 3 10 5 1 3 1 3 1 6 2 3 7 1 4 6 4 2 4 3 3 2 1 7 6 5 4 Sample Output0 3 5 Authorlcy Source2007省赛集训队练习赛（10）_以此感谢DOOMIII Recommendlcy 题目大意 某同学参加完比赛回来补作业，每种作业有ddl天数和扣分值。想让总扣分值尽量少，输出最小值。 解题思路 思路1：贪心，按分值从大到小排序，对于每份作业优先从ddl天向前安排，如果所有天都安排满了，那么ans加上该作业的扣分值（合理性：先安排的作业扣分值一定更大） 思路2：贪心+优先队列，按时间从小到大排序，按天数递增安排作业，可安排则将扣分值入队，如果安排满了，那么]]></content>
      <categories>
        <category>编程</category>
        <category>ACM</category>
      </categories>
      <tags>
        <tag>ACM</tag>
        <tag>算法</tag>
        <tag>2018暑假集训</tag>
        <tag>Greedy</tag>
        <tag>HDU</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[【CSU-1588】解题报告（贪心，水题）]]></title>
    <url>%2Fpost%2F8ddc8a30.html</url>
    <content type="text"><![CDATA[原始题目1588: 合并果子 Time Limit: 1 Sec Memory Limit: 128 Mb Submitted: 1907 Solved: 906 Description现在有$n$堆果子，第$i$堆有 $a_i$个果子。现在要把这些果子合并成一堆，每次合并的代价是两堆果子的总果子数。求合并所有果子的最小代价。 Input第一行包含一个整数$T(T \le 50)$，表示数据组数。 每组数据第一行包含一个整数$ n( 2 \le n \le 1000 )$ ，表示果子的堆数。 第二行包含$n$个正整数$a_i ( a_i \le 100) $，表示每堆果子的果子数。 Output每组数据仅一行，表示最小合并代价。 Sample Input2 4 1 2 3 4 5 3 5 2 1 4 Sample Output19 33 HintSource国防科学技术大学第十八届银河之光文化节ACM程序设计竞赛初赛 题目大意如题 解题思路 贪心，优先队列，每次取顶上两堆果子。 解题代码1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253//#include &lt;bits/stdc++.h&gt;#include &lt;cstdio&gt;#include &lt;cmath&gt;#include &lt;cstdlib&gt;#include &lt;cstring&gt;#include &lt;iostream&gt;#include &lt;set&gt;#include &lt;iomanip&gt;#include &lt;algorithm&gt;#include &lt;queue&gt;#include &lt;map&gt;#include &lt;string&gt;#define INF 0x3f3f3f3f#define rep(i,a,n) for(int i=a;i&lt;n;i++)#define per(i,a,n) for(int i=n-1;i&gt;=a;i--)using namespace std;const int maxn=1e5+5; typedef long long ll;ll t,n,a[maxn];priority_queue&lt;ll, vector&lt;ll&gt;, greater&lt;ll&gt; &gt; pq;int main()&#123; ios::sync_with_stdio(false); int t; cin&gt;&gt;t; while(t--)&#123; while(!pq.empty()) pq.pop(); int n; ll sum=0,sum1,a; cin&gt;&gt;n; rep(i,0,n)&#123; cin&gt;&gt;a; pq.push(a); &#125; while(!pq.empty())&#123; sum1=pq.top(); pq.pop(); sum1+=pq.top(); pq.pop(); if(pq.empty())&#123;// cout&lt;&lt;"empty"&lt;&lt;sum1&lt;&lt;endl; sum+=sum1;break; &#125; else&#123; sum+=sum1;// cout&lt;&lt;"get"&lt;&lt;sum1&lt;&lt;endl; pq.push(sum1); &#125; &#125; cout&lt;&lt;sum&lt;&lt;endl; &#125;&#125; 收获与反思水题]]></content>
      <categories>
        <category>编程</category>
        <category>ACM</category>
      </categories>
      <tags>
        <tag>ACM</tag>
        <tag>算法</tag>
        <tag>CSU</tag>
        <tag>2018暑假集训</tag>
        <tag>Greedy</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[【HDU-6325】解题报告（计算几何，2018杭电多校第三场）]]></title>
    <url>%2Fpost%2F264a9c89.html</url>
    <content type="text"><![CDATA[原始题目Problem G. Interstellar Travel Time Limit: 4000/2000 MS (Java/Others) Memory Limit: 524288/524288 K (Java/Others) Total Submission(s): 638 Accepted Submission(s): 137 Problem DescriptionAfter trying hard for many years, Little Q has finally received an astronaut license. To celebrate the fact, he intends to buy himself a spaceship and make an interstellar travel. Little Q knows the position of $n$ planets in space, labeled by $1$ to $n$. To his surprise, these planets are all coplanar. So to simplify, Little Q put these $n$ planets on a plane coordinate system, and calculated the coordinate of each planet $(x_i,y_i)$. Little Q plans to start his journey at the $1$-th planet, and end at the $n$-th planet. When he is at the $i$-th planet, he can next fly to the $j$-th planet only if $x_i&lt;x_j$, which will cost his spaceship $x_i\times y_j-x_j\times y_i$ units of energy. Note that this cost can be negative, it means the flight will supply his spaceship. Please write a program to help Little Q find the best route with minimum total cost. InputThe first line of the input contains an integer $T(1\leq T\leq10)$, denoting the number of test cases. In each test case, there is an integer $n(2\leq n\leq 200000)$ in the first line, denoting the number of planets. For the next n lines, each line contains $2$ integers $x_i,y_i(0\leq x_i,y_i\leq 10^9)$, denoting the coordinate of the i-th planet. Note that different planets may have the same coordinate because they are too close to each other. It is guaranteed that $y_1=y_n=0,0=x_1&lt;x_2,x_3,…,x_{n-1}&lt;x_n$. OutputFor each test case, print a single line containing several distinct integers $p_1,p_2,…,p_m(1\leq p_i\leq n)$, denoting the route you chosen is $p_1\rightarrow p_2\rightarrow…\rightarrow p_{m-1}\rightarrow p_m$. Obviously $p_1$ should be $1$ and $p_m$ should be $n$. You should choose the route with minimum total cost. If there are multiple best routes, please choose the one with the smallest lexicographically. A sequence of integers $a$ is lexicographically smaller than $a$ sequence of $b$ if there exists such index $j$ that $a_i=b_i$ for all $i&lt;j$, but $a_j&lt;b_j$. Sample Input1 3 0 0 3 0 4 0 Sample Output1 2 3 Source2018 Multi-University Training Contest 3 Recommendchendu 题目大意 给了$n$个星球的横纵坐标，从第一个星球旅行到第n个星球，消耗的燃料是叉积（可能为负） 已知$y_1=y_n=0,0=x_1&lt;x_2,x_3,…,x_{n-1}&lt;x_n$，每次旅行下一个星球的$x$坐标要大于上一个星球。 求消耗燃料的最小值，输出字典序最小的满足条件的访问顺序。 解题思路 即求从第一个点到第n个星球的上半凸包（有向面积最小，负最大） 三点共线和同点的时候要满足字典序最小的要求。 共线时判断中间点字典序是不是小于后点，共点时保留序列最小的。 解题代码123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147148149150151152153154155156157158159160161162163164165166167168169170171172173174175176177178179180181182183184185186187188189190191192193194195196197198199200201202203204205206207208209210211212213214215216217218219220221222223224225226227228229230231232#include &lt;bits/stdc++.h&gt;using namespace std;#define rep(i,a,n) for (int i=a;i&lt;n;i++)#define per(i,a,n) for (int i=n-1;i&gt;=a;i--)#define pb push_back#define mp make_pair#define np next_permutation#define all(x) x.begin(),x.end()#define fi first#define se second#define SZ(x) ((int)(x).size()) const int maxn=2e5+5;const double eps=1e-9;typedef long long ll;ll n,cnt;//有的命名为sgn函数，高精度符号判断 ll dcmp(double x)&#123; //相等函数判断，减少精度问题 if(fabs(x)&lt;eps) return 0; else return x&lt;0?-1:1;&#125;//点的定义 class Point&#123; public: ll x,y; Point (ll x=0,double y=0):x(x),y(y)&#123;&#125; //构造函数，方便代码的编写 &#125;; typedef Point Vector;// 从程序实现上，Vector只是Point的别名//运算符重载 //向量+向量=向量，点+向量=点Vector operator + (const Vector &amp;A,const Vector &amp;B) &#123; return Vector(A.x+B.x,A.y+B.y); &#125;//向量-向量=向量，点-向量-点 Vector operator - (const Vector &amp;A,const Vector &amp;B) &#123; return Vector(A.x-B.x,A.y-B.y); &#125;//向量*数=向量 （数乘） Vector operator * (const Vector &amp;A,double p) &#123; return Vector(A.x*p,A.y*p); &#125;//向量/数=向量 （数除） Vector operator / (const Vector &amp;A,double p) &#123; return Vector(A.x/p,A.y/p); &#125;//向量（点乘）向量=数 （点乘）double operator * (const Vector &amp;A,const Vector &amp;B) &#123; return A.x*B.x+A.y*B.y; &#125;double dot(const Vector &amp;A,const Vector &amp;B)&#123; return A.x*B.x+A.y*B.y; &#125;//向量（叉乘）向量=向量 （叉乘） double operator ^ (const Vector &amp;A,const Vector &amp;B)&#123; return A.x*B.y-A.y*B.x; &#125;ll cross(const Vector &amp;A,const Vector &amp;B)&#123; return A.x*B.y-A.y*B.x; &#125;//计算向量模长 double abs(const Vector &amp;A)&#123; return sqrt(dot(A,A));&#125;//计算平行四边形方向面积double area2(const Point &amp;A,const Point &amp;B,const Point &amp;C)&#123; return cross(B-A,C-A) ;&#125; //按x值递增排序 bool operator &lt; (const Point &amp;A,const Point &amp;B) &#123; return A.x==B.x?A.y&lt;B.y:A.x&lt;B.x; &#125; //判定两个点是否相同，用到dcmp精度判定 bool operator == (const Point &amp;A,const Point &amp;B) &#123; return dcmp(A.x-B.x)==0&amp;&amp; dcmp(A.y-B.y)==0; &#125; //向量旋转Vector rotate(Vector A,double rad) &#123; return Vector(A.x*cos(rad)-A.y*sin(rad),A.x*sin(rad)+A.y*cos(rad));&#125;//计算单位法线，左转90Vector normal(Vector A)&#123; double l=abs(A); return Vector(-A.y/l,A.x/l);&#125; //线段定义 class Line &#123; public: Point s,e; Line()&#123;&#125; Line(Point _s,Point _e)&#123; s=_s;e=_e; &#125; &#125;line[maxn];//判断两线段是否相交 bool inter(Line l1,Line l2)&#123;// cout&lt;&lt;"L1 "&lt;&lt;l1.e.x&lt;&lt;","&lt;&lt;l1.e.y&lt;&lt;" "&lt;&lt;l1.s.x&lt;&lt;","&lt;&lt;l1.s.y&lt;&lt;endl;// cout&lt;&lt;"L2 "&lt;&lt;l2.e.x&lt;&lt;","&lt;&lt;l2.e.y&lt;&lt;" "&lt;&lt;l2.s.x&lt;&lt;","&lt;&lt;l2.s.y&lt;&lt;endl; return ( //根据题目要求端点相交是否算作相交来决定大于等于和小于等于 //排斥实验 max(l1.s.x,l1.e.x)&gt;=min(l2.s.x,l2.e.x) &amp;&amp; max(l2.s.x,l2.e.x)&gt;=min(l1.s.x,l1.e.x) &amp;&amp; max(l1.s.y,l1.e.y)&gt;=min(l2.s.y,l2.e.y) &amp;&amp; max(l2.s.y,l2.e.y)&gt;=min(l1.s.y,l1.e.y) &amp;&amp; //跨立实验 dcmp((l2.s-l1.s)^(l1.s-l1.e))*dcmp((l2.e-l1.s)^(l1.s-l1.e))&lt;0 &amp;&amp; dcmp((l1.s-l2.s)^(l2.s-l2.e))*dcmp((l1.e-l2.s)^(l2.s-l2.e))&lt;0 ) ;&#125;bool inter(Point a1,Point a2,Point b1,Point b2)&#123; Line l1(a1,a2),l2(b1,b2); return inter(l1,l2);&#125;//求两直线交点Point getinter(Line l1,Line l2)&#123; Vector v=l1.s-l1.e; Vector w=l2.s-l2.e; Vector u=l1.e-l2.e; double t=cross(w,u)/cross(v,w); return l1.e+v*t;&#125; Point getinter(Point a1,Point a2,Point b1,Point b2)&#123; Line l1(a1,a2); Line l2(b1,b2); return getinter(l1,l2);&#125;//判定点和线段的关系，//0:不在线段所在直线上//1:在线段内（不含端点） //2:在线段端点//3:在线段两侧的射线上 ll online(Point a,Line l)&#123; if(dcmp(cross(l.s-a,l.e-a))!=0) return 0; double pans=dcmp(dot(l.s-a,l.e-a));// cout&lt;&lt;(l.s-a).x&lt;&lt;","&lt;&lt;(l.s-a).y&lt;&lt;" "&lt;&lt;(l.e-a).x&lt;&lt;","&lt;&lt;(l.e-a).y&lt;&lt;endl; if(pans&lt;0) return 1; else if(pans==0) return 2; else if(pans&gt;0) return 3;&#125;ll online(Point a,Point b1,Point b2)&#123; Line l(b1,b2); return online(a,l);&#125;class node&#123; public: ll index; Point p;&#125; point[maxn],ans[maxn],pre[maxn];bool cmp(node a, node b)&#123; if(a.p.x==b.p.x)&#123; if(a.p.y==b.p.y) return a.index&gt;b.index; return a.p.y&lt;b.p.y; &#125; else &#123; return a.p.x&lt;b.p.x; &#125;&#125;ll ConvexHull()&#123; ll flag=0; ll m=0; for(ll i=1;i&lt;=cnt;i++)&#123; if(!flag &amp;&amp; point[i].index!=1) continue; if(point[i].index==1)&#123; flag=1; &#125; while(m&gt;1 &amp;&amp; cross(ans[m-1].p-ans[m-2].p,point[i].p-ans[m-2].p)&gt;=0) &#123; if(m&gt;1 &amp;&amp; cross(ans[m-1].p-ans[m-2].p,point[i].p-ans[m-2].p)==0)&#123; //判断字典序 if(point[i].index&lt;ans[m-1].index) m--; else break; &#125; else if(m&gt;1 &amp;&amp; cross(ans[m-1].p-ans[m-2].p,point[i].p-ans[m-2].p)&gt;0)&#123; m--; &#125; &#125; ans[m].p=point[i].p; ans[m].index=point[i].index;// cout&lt;&lt;m&lt;&lt;" ans.p=("&lt;&lt;ans[m].p.x&lt;&lt;","&lt;&lt;ans[m].p.y&lt;&lt;" index="&lt;&lt;ans[m].index&lt;&lt;endl;// cout&lt;&lt;"$$$$"&lt;&lt;ans[m].index&lt;&lt;" "&lt;&lt;n&lt;&lt;"$$$$"&lt;&lt;endl; m++; if(ans[m-1].index==n) break;// cout&lt;&lt;m&lt;&lt;" ans.p=("&lt;&lt;ans[m].p.x&lt;&lt;","&lt;&lt;ans[m].p.y&lt;&lt;" index="&lt;&lt;ans[m].index&lt;&lt;endl; &#125; return m;&#125;int main()&#123; ios::sync_with_stdio(false); ll t; cin&gt;&gt;t; while(t--)&#123; cin&gt;&gt;n; cnt=0; rep(i,1,n+1)&#123; cin&gt;&gt;pre[i].p.x&gt;&gt;pre[i].p.y; pre[i].index=i; &#125; sort(pre+1,pre+n+1,cmp); rep(i,1,n+1)&#123; if(i==1) point[++cnt]=pre[i]; else if(pre[i].p.x==point[cnt].p.x) point[cnt]=pre[i]; else point[++cnt]=pre[i]; &#125; ll len=ConvexHull(); rep(i,0,len)&#123; if(i==0) cout&lt;&lt;ans[i].index; else cout&lt;&lt;" "&lt;&lt;ans[i].index; &#125; cout&lt;&lt;endl; &#125;&#125; //1//7//1 1//3 5//3 1//1 3//2 4//7 2//9 1//2 //13//1 0 //3 5//3 1//2 4//5 3//4 6//2 4//7 2//6 13//9 1//3 0//10 1//11 0 收获与反思 注意long long 可能出现共点情况，三点共线情况，都要考虑字典序的要求]]></content>
      <categories>
        <category>编程</category>
        <category>ACM</category>
      </categories>
      <tags>
        <tag>ACM</tag>
        <tag>算法</tag>
        <tag>2018暑假集训</tag>
        <tag>HDU</tag>
        <tag>2018杭电多校</tag>
        <tag>计算几何</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[【POJ-1654】解题报告（计算几何，longlong）]]></title>
    <url>%2Fpost%2F98804e11.html</url>
    <content type="text"><![CDATA[原始题目Area Time Limit: 1000MS Memory Limit: 10000K Total Submissions: 21457 Accepted: 5826 DescriptionYou are going to compute the area of a special kind of polygon. One vertex of the polygon is the origin of the orthogonal coordinate system. From this vertex, you may go step by step to the following vertexes of the polygon until back to the initial vertex. For each step you may go North, West, South or East with step length of 1 unit, or go Northwest, Northeast, Southwest or Southeast with step length of square root of 2. For example, this is a legal polygon to be computed and its area is 2.5: InputThe first line of input is an integer t (1 ≤ t ≤ 20), the number of the test polygons. Each of the following lines contains a string composed of digits 1-9 describing how the polygon is formed by walking from the origin. Here 8, 2, 6 and 4 represent North, South, East and West, while 9, 7, 3 and 1 denote Northeast, Northwest, Southeast and Southwest respectively. Number 5 only appears at the end of the sequence indicating the stop of walking. You may assume that the input polygon is valid which means that the endpoint is always the start point and the sides of the polygon are not cross to each other.Each line may contain up to 1000000 digits. OutputFor each polygon, print its area on a single line. Sample Input4 5 825 6725 6244865 Sample Output0 0 0.5 2 SourcePOJ Monthly—2004.05.15 Liu Rujia@POJ 题目大意 在二维坐标系中点向8个方向移动，经过一系列移动后回到原点，并且边不相交（构成闭合的多边形），求其面积。 解题思路 由于坐标都是整数且很大，由于精度考虑，按照long long计算最后再除以2. 解题代码123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147148149150151152153154155156157158159160161162163164165166167168//计算几何模板，二维几何基础//使用印用注意避免直接在程序中调用构造函数构造无名对象。否则可能会导致程序出错 //#include &lt;bits/stdc++.h&gt;#include &lt;cstdio&gt;#include &lt;cmath&gt;#include &lt;cstdlib&gt;#include &lt;cstring&gt;#include &lt;iostream&gt;#include &lt;set&gt;#include &lt;iomanip&gt;#include &lt;algorithm&gt;#include &lt;queue&gt;#include &lt;map&gt;#include &lt;string&gt;#define INF 0x3f3f3f3f#define rep(i,a,n) for(int i=a;i&lt;n;i++)#define per(i,a,n) for(int i=n-1;i&gt;=a;i--)using namespace std;typedef long long ll;const double eps =1e-10;const int maxn=50;int n;//有的命名为sgn函数，高精度符号判断 int dcmp(double x)&#123; //相等函数判断，减少精度问题 if(fabs(x)&lt;eps) return 0; else return x&lt;0?-1:1;&#125;//点的定义 class Point&#123; public: ll x,y; Point (ll x=0,ll y=0):x(x),y(y)&#123;&#125; //构造函数，方便代码的编写 &#125;; typedef Point Vector;// 从程序实现上，Vector只是Point的别名//运算符重载 //向量+向量=向量，点+向量=点Vector operator + (const Vector &amp;A,const Vector &amp;B) &#123; return Vector(A.x+B.x,A.y+B.y); &#125;//向量-向量=向量，点-向量-点 Vector operator - (const Vector &amp;A,const Vector &amp;B) &#123; return Vector(A.x-B.x,A.y-B.y); &#125;//向量*数=向量 （数乘） Vector operator * (const Vector &amp;A,double p) &#123; return Vector(A.x*p,A.y*p); &#125;//向量/数=向量 （数除） Vector operator / (const Vector &amp;A,double p) &#123; return Vector(A.x/p,A.y/p); &#125;//向量（点乘）向量=数 （点乘）double operator * (const Vector &amp;A,const Vector &amp;B) &#123; return A.x*B.x+A.y*B.y; &#125;double dot(const Vector &amp;A,const Vector &amp;B)&#123; return A.x*B.x+A.y*B.y; &#125;//向量（叉乘）向量=向量 （叉乘） double operator ^ (const Vector &amp;A,const Vector &amp;B)&#123; return A.x*B.y-A.y*B.x; &#125;ll cross(const Vector &amp;A,const Vector &amp;B)&#123; return A.x*B.y-A.y*B.x; &#125;//计算向量模长 double abs(const Vector &amp;A)&#123; return sqrt(dot(A,A));&#125;//计算平行四边形方向面积double area2(const Point &amp;A,const Point &amp;B,const Point &amp;C)&#123; return cross(B-A,C-A) ;&#125; //按x值递增排序 bool operator &lt; (const Point &amp;A,const Point &amp;B) &#123; return A.x==B.x?A.y&lt;B.y:A.x&lt;B.x; &#125; //判定两个点是否相同，用到dcmp精度判定 bool operator == (const Point &amp;A,const Point &amp;B) &#123; return dcmp(A.x-B.x)==0&amp;&amp; dcmp(A.y-B.y)==0; &#125; //向量旋转Vector rotate(Vector A,double rad) &#123; return Vector(A.x*cos(rad)-A.y*sin(rad),A.x*sin(rad)+A.y*cos(rad));&#125;//计算单位法线，左转90Vector normal(Vector A)&#123; double l=abs(A); return Vector(-A.y/l,A.x/l);&#125; //线段定义 class Line &#123; public: Point s,e; Line()&#123;&#125; Line(Point _s,Point _e)&#123; s=_s;e=_e; &#125; &#125;line[maxn];//判断两线段是否相交 bool inter(Line l1,Line l2)&#123;// cout&lt;&lt;"L1 "&lt;&lt;l1.e.x&lt;&lt;","&lt;&lt;l1.e.y&lt;&lt;" "&lt;&lt;l1.s.x&lt;&lt;","&lt;&lt;l1.s.y&lt;&lt;endl;// cout&lt;&lt;"L2 "&lt;&lt;l2.e.x&lt;&lt;","&lt;&lt;l2.e.y&lt;&lt;" "&lt;&lt;l2.s.x&lt;&lt;","&lt;&lt;l2.s.y&lt;&lt;endl; return ( //根据题目要求端点相交是否算作相交来决定大于等于和小于等于 //排斥实验 max(l1.s.x,l1.e.x)&gt;=min(l2.s.x,l2.e.x) &amp;&amp; max(l2.s.x,l2.e.x)&gt;=min(l1.s.x,l1.e.x) &amp;&amp; max(l1.s.y,l1.e.y)&gt;=min(l2.s.y,l2.e.y) &amp;&amp; max(l2.s.y,l2.e.y)&gt;=min(l1.s.y,l1.e.y) &amp;&amp; //跨立实验 dcmp((l2.s-l1.s)^(l1.s-l1.e))*dcmp((l2.e-l1.s)^(l1.s-l1.e))&lt;0 &amp;&amp; dcmp((l1.s-l2.s)^(l2.s-l2.e))*dcmp((l1.e-l2.s)^(l2.s-l2.e))&lt;0 ) ;&#125;bool inter(Point a1,Point a2,Point b1,Point b2)&#123; Line l1(a1,a2),l2(b1,b2); return inter(l1,l2);&#125;//求两直线交点Point getinter(Line l1,Line l2)&#123; Vector v=l1.s-l1.e; Vector w=l2.s-l2.e; Vector u=l1.e-l2.e; double t=cross(w,u)/cross(v,w); return l1.e+v*t;&#125; Point getinter(Point a1,Point a2,Point b1,Point b2)&#123; Line l1(a1,a2); Line l2(b1,b2); return getinter(l1,l2);&#125;//判定点和线段的关系，//0:不在线段所在直线上//1:在线段内（不含端点） //2:在线段端点//3:在线段两侧的射线上 int online(Point a,Line l)&#123; if(dcmp(cross(l.s-a,l.e-a))!=0) return 0; double pans=dcmp(dot(l.s-a,l.e-a));// cout&lt;&lt;(l.s-a).x&lt;&lt;","&lt;&lt;(l.s-a).y&lt;&lt;" "&lt;&lt;(l.e-a).x&lt;&lt;","&lt;&lt;(l.e-a).y&lt;&lt;endl; if(pans&lt;0) return 1; else if(pans==0) return 2; else if(pans&gt;0) return 3;&#125;int online(Point a,Point b1,Point b2)&#123; Line l(b1,b2); return online(a,l);&#125; int main()&#123; int t; cin&gt;&gt;t; while(t--)&#123; Point pnow(0,0),pnext(0,0); ll area=0; string s; cin&gt;&gt;s; int len=s.size(); rep(i,0,len)&#123; pnow=pnext; switch(s[i])&#123; case '8': pnext.y++; break; case '2': pnext.y--; break; case '6': pnext.x++; break; case '4': pnext.x--; break; case '9': pnext.x++, pnext.y++; break; case '7': pnext.x--, pnext.y++; break; case '3': pnext.x++, pnext.y--; break; case '1': pnext.x--, pnext.y--; break; default: break; &#125; area+=cross(pnext,pnow); &#125; area=(area&lt;0?(0-area):area); if(area%2==0) cout&lt;&lt;area/2&lt;&lt;endl; else cout&lt;&lt;area/2&lt;&lt;".5"&lt;&lt;endl; &#125;&#125; 收获与反思 整数坐标注意开long long。 多边形有向面积模板题。]]></content>
      <categories>
        <category>编程</category>
        <category>ACM</category>
      </categories>
      <tags>
        <tag>ACM</tag>
        <tag>算法</tag>
        <tag>2018暑假集训</tag>
        <tag>POJ</tag>
        <tag>计算几何</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[【UVA-10652】解题报告（计算几何，凸包模板）]]></title>
    <url>%2Fpost%2F57bfde8d.html</url>
    <content type="text"><![CDATA[原始题目Board Wrapping 题目大意 给出平面直角坐标系n个长方形模具的中心点，长宽以及顺时针旋转角度，求一个能包含所有模具的最小多边形，并计算模具的面积占多边形面积的百分比。 解题思路 把长方形都看成四个点，则为凸包问题，求凸包面积以及长方形面积计算百分比即可。 解题代码123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147148149150151152153154155156157158159160161162163164165166167168169170171172173//计算几何模板，二维几何基础//使用印用注意避免直接在程序中调用构造函数构造无名对象。否则可能会导致程序出错 #include &lt;bits/stdc++.h&gt;#include &lt;cstdio&gt;#include &lt;cmath&gt;#include &lt;cstdlib&gt;#include &lt;cstring&gt;#include &lt;iostream&gt;#include &lt;set&gt;#include &lt;iomanip&gt;#include &lt;algorithm&gt;#include &lt;queue&gt;#include &lt;map&gt;#include &lt;string&gt;#define INF 0x3f3f3f3f#define rep(i,a,n) for(int i=a;i&lt;n;i++)#define per(i,a,n) for(int i=n-1;i&gt;=a;i--)using namespace std;typedef long long ll;const double eps =1e-10;const int maxn=2500; //注意修改 int n;//有的命名为sgn函数，高精度符号判断 int dcmp(double x)&#123; //相等函数判断，减少精度问题 if(fabs(x)&lt;eps) return 0; else return x&lt;0?-1:1;&#125;//点的定义 class Point&#123; public: double x,y; Point (double x=0,double y=0):x(x),y(y)&#123;&#125; //构造函数，方便代码的编写 &#125;point[maxn],pafter[maxn]; typedef Point Vector;// 从程序实现上，Vector只是Point的别名//运算符重载 Vector operator + (const Vector &amp;A,const Vector &amp;B) &#123; return Vector(A.x+B.x,A.y+B.y); &#125; //向量+向量=向量，点+向量=点Vector operator - (const Vector &amp;A,const Vector &amp;B) &#123; return Vector(A.x-B.x,A.y-B.y); &#125; //向量-向量=向量，点-向量-点 Vector operator * (const Vector &amp;A,double p) &#123; return Vector(A.x*p,A.y*p); &#125; //向量*数=向量 （数乘） Vector operator / (const Vector &amp;A,double p) &#123; return Vector(A.x/p,A.y/p); &#125; //向量/数=向量 （数除）double operator * (const Vector &amp;A,const Vector &amp;B) &#123; return A.x*B.x+A.y*B.y; &#125; //向量（点乘）向量=数 （点乘）bool operator &lt; (const Point &amp;A,const Point &amp;B) &#123; return A.x==B.x?A.y&lt;B.y:A.x&lt;B.x; &#125; //按x值递增排序 bool operator == (const Point &amp;A,const Point &amp;B) &#123; return dcmp(A.x-B.x)==0&amp;&amp; dcmp(A.y-B.y)==0; &#125; //判定两个点是否相同，用到dcmp精度判定 //点乘叉乘 double dot(const Vector &amp;A,const Vector &amp;B)&#123; return A.x*B.x+A.y*B.y; &#125; //向量（叉乘）向量=向量 （叉乘） double operator ^ (const Vector &amp;A,const Vector &amp;B)&#123; return A.x*B.y-A.y*B.x; &#125;double cross(const Vector &amp;A,const Vector &amp;B)&#123; return A.x*B.y-A.y*B.x; &#125;//模长面积 double abs(const Vector &amp;A)&#123; return sqrt(dot(A,A));&#125; //计算向量模长 double area2(const Point &amp;A,const Point &amp;B,const Point &amp;C)&#123; return cross(B-A,C-A) ;&#125; //计算平行四边形方向面积double PolygonArea(Point *p,int n) &#123; double area=0; rep(i,1,n-1)&#123;area+=cross(p[i]-p[0],p[i+1]-p[0]);&#125;return area/2.0; &#125; //计算多边形的有向面积//旋转Vector rotate(Vector A,double rad) &#123; return Vector(A.x*cos(rad)-A.y*sin(rad),A.x*sin(rad)+A.y*cos(rad));&#125; //旋转rad弧度 Vector normal(Vector A)&#123;double l=abs(A);return Vector(-A.y/l,A.x/l);&#125; //计算单位法线，左转90double torad(double deg) &#123; return deg/180*acos(-1); &#125; //角度转弧度 //线段定义 class Line &#123; public: Point s,e; Line()&#123;&#125; Line(Point _s,Point _e)&#123; s=_s;e=_e; &#125; &#125;line[maxn];//判断两线段是否相交 bool inter(Line l1,Line l2)&#123;// cout&lt;&lt;"L1 "&lt;&lt;l1.e.x&lt;&lt;","&lt;&lt;l1.e.y&lt;&lt;" "&lt;&lt;l1.s.x&lt;&lt;","&lt;&lt;l1.s.y&lt;&lt;endl;// cout&lt;&lt;"L2 "&lt;&lt;l2.e.x&lt;&lt;","&lt;&lt;l2.e.y&lt;&lt;" "&lt;&lt;l2.s.x&lt;&lt;","&lt;&lt;l2.s.y&lt;&lt;endl; return ( //根据题目要求端点相交是否算作相交来决定大于等于和小于等于 //排斥实验 max(l1.s.x,l1.e.x)&gt;=min(l2.s.x,l2.e.x) &amp;&amp; max(l2.s.x,l2.e.x)&gt;=min(l1.s.x,l1.e.x) &amp;&amp; max(l1.s.y,l1.e.y)&gt;=min(l2.s.y,l2.e.y) &amp;&amp; max(l2.s.y,l2.e.y)&gt;=min(l1.s.y,l1.e.y) &amp;&amp; //跨立实验 dcmp((l2.s-l1.s)^(l1.s-l1.e))*dcmp((l2.e-l1.s)^(l1.s-l1.e))&lt;0 &amp;&amp; dcmp((l1.s-l2.s)^(l2.s-l2.e))*dcmp((l1.e-l2.s)^(l2.s-l2.e))&lt;0 ) ;&#125;bool inter(Point a1,Point a2,Point b1,Point b2)&#123; Line l1(a1,a2),l2(b1,b2); return inter(l1,l2);&#125;bool cmp(Point a,Point b)&#123; if(a.x==b.x) return a.y&lt;b.y; else return a.x&lt;b.x;&#125;//求两直线交点Point getinter(Line l1,Line l2)&#123;Vector v=l1.s-l1.e;Vector w=l2.s-l2.e;Vector u=l1.e-l2.e;double t=cross(w,u)/cross(v,w);return l1.e+v*t;&#125; Point getinter(Point a1,Point a2,Point b1,Point b2)&#123;Line l1(a1,a2);Line l2(b1,b2);return getinter(l1,l2);&#125;//判定点和线段的关系，//0:不在线段所在直线上//1:在线段内（不含端点） //2:在线段端点//3:在线段两侧的射线上 int online(Point a,Line l)&#123; if(dcmp(cross(l.s-a,l.e-a))!=0) return 0; double pans=dcmp(dot(l.s-a,l.e-a));// cout&lt;&lt;(l.s-a).x&lt;&lt;","&lt;&lt;(l.s-a).y&lt;&lt;" "&lt;&lt;(l.e-a).x&lt;&lt;","&lt;&lt;(l.e-a).y&lt;&lt;endl; if(pans&lt;0) return 1; else if(pans==0) return 2; else if(pans&gt;0) return 3;&#125;int online(Point a,Point b1,Point b2)&#123; Line l(b1,b2); return online(a,l);&#125;//凸包int ConvexHull(Point *p,int n,Point *ch)&#123; sort(p,p+n,cmp); int m=0; for(int i=0;i&lt;n;i++)&#123; while(m&gt;1 &amp;&amp; cross(ch[m-1]-ch[m-2],p[i]-ch[m-2])&lt;=0) m--; ch[m++]=p[i]; &#125; int k=m; for(int i=n-2;i&gt;=0;i--)&#123; while(m&gt;k &amp;&amp; cross(ch[m-1]-ch[m-2],p[i]-ch[m-2])&lt;=0) m--; ch[m++]=p[i]; &#125; if(n&gt;1) m--; return m;&#125; int main()&#123; int t; ios::sync_with_stdio(false); cin&gt;&gt;t; while(t--)&#123; int n,pc=0; double area1=0; cin&gt;&gt;n; rep(i,0,n)&#123; double x,y,w,h,j,ang; cin&gt;&gt;x&gt;&gt;y&gt;&gt;w&gt;&gt;h&gt;&gt;j; Point o(x,y); //原始点 ang=-torad(j); point[pc++]=o+rotate(Vector(w/2,h/2),ang); point[pc++]=o+rotate(Vector(-w/2,h/2),ang); point[pc++]=o+rotate(Vector(w/2,-h/2),ang); point[pc++]=o+rotate(Vector(-w/2,-h/2),ang); area1+= w*h; &#125;// for(int i=0;i&lt;pc;i++) cout&lt;&lt;point[i].x&lt;&lt;","&lt;&lt;point[i].y&lt;&lt;endl; int len=ConvexHull(point,pc,pafter); double area2 = PolygonArea(pafter,len);// cout&lt;&lt;"len="&lt;&lt;len&lt;&lt;" area1="&lt;&lt;area1&lt;&lt;" area2="&lt;&lt;area2&lt;&lt;endl; cout&lt;&lt;fixed&lt;&lt;setprecision(1)&lt;&lt;area1*100/area2&lt;&lt;" %"&lt;&lt;endl; &#125; &#125; 收获与反思 凸包模板]]></content>
      <categories>
        <category>编程</category>
        <category>ACM</category>
      </categories>
      <tags>
        <tag>ACM</tag>
        <tag>算法</tag>
        <tag>2018暑假集训</tag>
        <tag>计算几何</tag>
        <tag>UVA</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[【POJ-1269】解题报告（计算几何，直线相交求交点）]]></title>
    <url>%2Fpost%2Ffb2f630e.html</url>
    <content type="text"><![CDATA[原始题目Intersecting Lines Time Limit: 1000MS Memory Limit: 10000K Total Submissions: 18318 Accepted: 7816 DescriptionWe all know that a pair of distinct points on a plane defines a line and that a pair of lines on a plane will intersect in one of three ways:1) no intersection because they are parallel,2) intersect in a line because they are on top of one another (i.e. they are the same line),3) intersect in a point. In this problem you will use your algebraic knowledge to create a program that determines how and where two lines intersect. Your program will repeatedly read in four points that define two lines in the x-y plane and determine how and where the lines intersect. All numbers required by this problem will be reasonable, say between -1000 and 1000. InputThe first line contains an integer N between 1 and 10 describing how many pairs of lines are represented. The next N lines will each contain eight integers. These integers represent the coordinates of four points on the plane in the order x1y1x2y2x3y3x4y4. Thus each of these input lines represents two lines on the plane: the line through (x1,y1) and (x2,y2) and the line through (x3,y3) and (x4,y4). The point (x1,y1) is always distinct from (x2,y2). Likewise with (x3,y3) and (x4,y4). OutputThere should be N+2 lines of output. The first line of output should read INTERSECTING LINES OUTPUT. There will then be one line of output for each pair of planar lines represented by a line of input, describing how the lines intersect: none, line, or point. If the intersection is a point then your program should output the x and y coordinates of the point, correct to two decimal places. The final line of output should read “END OF OUTPUT”. Sample Input5 0 0 4 4 0 4 4 0 5 0 7 6 1 0 2 3 5 0 7 6 3 -6 4 -3 2 0 2 27 1 5 18 5 0 3 4 0 1 2 2 5 Sample OutputINTERSECTING LINES OUTPUT POINT 2.00 2.00 NONE LINE POINT 2.00 5.00 POINT 1.07 2.20 END OF OUTPUT SourceMid-Atlantic 1996 题目大意给出n组两点确定的直线（不是线段），判断两条直线是平行，相交（给出交点）还是同一直线。 解题思路 计算几何基础题 先求两向量$v_1,v_2$的cross（叉积），若为零则从两条直线的点各取一个构成向量$v_3$和原向量其中一个求叉积，若也为零说明共线，不为零说明平行 非上述则求交点，套模板公式即可 解题代码123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147148149150151152153154155156157158//计算几何模板，二维几何基础//使用印用注意避免直接在程序中调用构造函数构造无名对象。否则可能会导致程序出错 //#include &lt;bits/stdc++.h&gt;#include &lt;cstdio&gt;#include &lt;cmath&gt;#include &lt;cstdlib&gt;#include &lt;cstring&gt;#include &lt;iostream&gt;#include &lt;set&gt;#include &lt;iomanip&gt;#include &lt;algorithm&gt;#include &lt;queue&gt;#include &lt;map&gt;#include &lt;string&gt;#define INF 0x3f3f3f3f#define rep(i,a,n) for(int i=a;i&lt;n;i++)#define per(i,a,n) for(int i=n-1;i&gt;=a;i--)using namespace std;typedef long long ll;const double eps =1e-10;const int maxn=50;int n;//有的命名为sgn函数，高精度符号判断 int dcmp(double x)&#123; //相等函数判断，减少精度问题 if(fabs(x)&lt;eps) return 0; else return x&lt;0?-1:1;&#125;//点的定义 class Point&#123; public: double x,y; Point (double x=0,double y=0):x(x),y(y)&#123;&#125; //构造函数，方便代码的编写 &#125;point[maxn]; typedef Point Vector;// 从程序实现上，Vector只是Point的别名//运算符重载 Vector operator + (const Vector &amp;A,const Vector &amp;B) &#123; return Vector(A.x+B.x,A.y+B.y); &#125; //向量+向量=向量，点+向量=点Vector operator - (const Vector &amp;A,const Vector &amp;B) &#123; return Vector(A.x-B.x,A.y-B.y); &#125; //向量-向量=向量，点-向量-点 Vector operator * (const Vector &amp;A,double p) &#123; return Vector(A.x*p,A.y*p); &#125; //向量*数=向量 （数乘） Vector operator / (const Vector &amp;A,double p) &#123; return Vector(A.x/p,A.y/p); &#125; //向量/数=向量 （数除）double operator * (const Vector &amp;A,const Vector &amp;B) &#123; return A.x*B.x+A.y*B.y; &#125; //向量（点乘）向量=数 （点乘）bool operator &lt; (const Point &amp;A,const Point &amp;B) &#123; return A.x==B.x?A.y&lt;B.y:A.x&lt;B.x; &#125; //按x值递增排序 bool operator == (const Point &amp;A,const Point &amp;B) &#123; return dcmp(A.x-B.x)==0&amp;&amp; dcmp(A.y-B.y)==0; &#125; //判定两个点是否相同，用到dcmp精度判定 //点乘叉乘 double dot(const Vector &amp;A,const Vector &amp;B)&#123; return A.x*B.x+A.y*B.y; &#125; //向量（叉乘）向量=向量 （叉乘） double operator ^ (const Vector &amp;A,const Vector &amp;B)&#123; return A.x*B.y-A.y*B.x; &#125;double cross(const Vector &amp;A,const Vector &amp;B)&#123; return A.x*B.y-A.y*B.x; &#125;//模长面积 double abs(const Vector &amp;A)&#123; return sqrt(dot(A,A));&#125; //计算向量模长 double area2(const Point &amp;A,const Point &amp;B,const Point &amp;C)&#123; return cross(B-A,C-A) ;&#125; //计算平行四边形方向面积double PolygonArea(Point *p,int n) &#123; double area=0; rep(i,1,n-1)&#123;area+=cross(p[i]-p[0],p[i+1]-p[0]);&#125;return area/2.0; &#125; //计算多边形的有向面积//旋转Vector rotate(Vector A,double rad) &#123; return Vector(A.x*cos(rad)-A.y*sin(rad),A.x*sin(rad)+A.y*cos(rad));&#125; //旋转rad弧度 Vector normal(Vector A)&#123;double l=abs(A);return Vector(-A.y/l,A.x/l);&#125; //计算单位法线，左转90//线段定义 class Line &#123; public: Point s,e; Line()&#123;&#125; Line(Point _s,Point _e)&#123; s=_s;e=_e; &#125; &#125;line[maxn];//判断两线段是否相交 bool inter(Line l1,Line l2)&#123;// cout&lt;&lt;"L1 "&lt;&lt;l1.e.x&lt;&lt;","&lt;&lt;l1.e.y&lt;&lt;" "&lt;&lt;l1.s.x&lt;&lt;","&lt;&lt;l1.s.y&lt;&lt;endl;// cout&lt;&lt;"L2 "&lt;&lt;l2.e.x&lt;&lt;","&lt;&lt;l2.e.y&lt;&lt;" "&lt;&lt;l2.s.x&lt;&lt;","&lt;&lt;l2.s.y&lt;&lt;endl; return ( //根据题目要求端点相交是否算作相交来决定大于等于和小于等于 //排斥实验 max(l1.s.x,l1.e.x)&gt;=min(l2.s.x,l2.e.x) &amp;&amp; max(l2.s.x,l2.e.x)&gt;=min(l1.s.x,l1.e.x) &amp;&amp; max(l1.s.y,l1.e.y)&gt;=min(l2.s.y,l2.e.y) &amp;&amp; max(l2.s.y,l2.e.y)&gt;=min(l1.s.y,l1.e.y) &amp;&amp; //跨立实验 dcmp((l2.s-l1.s)^(l1.s-l1.e))*dcmp((l2.e-l1.s)^(l1.s-l1.e))&lt;0 &amp;&amp; dcmp((l1.s-l2.s)^(l2.s-l2.e))*dcmp((l1.e-l2.s)^(l2.s-l2.e))&lt;0 ) ;&#125;bool inter(Point a1,Point a2,Point b1,Point b2)&#123; Line l1(a1,a2),l2(b1,b2); return inter(l1,l2);&#125;bool cmp(Point a,Point b)&#123; if(a.x==b.x) return a.y&lt;b.y; else return a.x&lt;b.x;&#125;//求两直线交点Point getinter(Line l1,Line l2)&#123;Vector v=l1.s-l1.e;Vector w=l2.s-l2.e;Vector u=l1.e-l2.e;double t=cross(w,u)/cross(v,w);return l1.e+v*t;&#125; Point getinter(Point a1,Point a2,Point b1,Point b2)&#123;Line l1(a1,a2);Line l2(b1,b2);return getinter(l1,l2);&#125;//判定点和线段的关系，//0:不在线段所在直线上//1:在线段内（不含端点） //2:在线段端点//3:在线段两侧的射线上 int online(Point a,Line l)&#123; if(dcmp(cross(l.s-a,l.e-a))!=0) return 0; double pans=dcmp(dot(l.s-a,l.e-a));// cout&lt;&lt;(l.s-a).x&lt;&lt;","&lt;&lt;(l.s-a).y&lt;&lt;" "&lt;&lt;(l.e-a).x&lt;&lt;","&lt;&lt;(l.e-a).y&lt;&lt;endl; if(pans&lt;0) return 1; else if(pans==0) return 2; else if(pans&gt;0) return 3;&#125;int online(Point a,Point b1,Point b2)&#123; Line l(b1,b2); return online(a,l);&#125;//凸包int ConvexHull(Point *p,int n,Point *ch)&#123; sort(p,p+n,cmp); int m=0; for(int i=0;i&lt;n;i++)&#123; while(m&gt;1 &amp;&amp; cross(ch[m-1]-ch[m-2],p[i]-ch[m-2])&lt;=0) m--; ch[m++]=p[i]; &#125; int k=m; for(int i=n-2;i&gt;=0;i--)&#123; while(m&gt;k &amp;&amp; cross(ch[m-1]-ch[m-2],p[i]-ch[m-2])&lt;=0) m--; ch[m++]=p[i]; &#125; if(n&gt;1) m--; return m;&#125; int main()&#123; cin&gt;&gt;n; cout&lt;&lt;"INTERSECTING LINES OUTPUT"&lt;&lt;endl; rep(i,0,n)&#123; Line l1,l2; cin&gt;&gt;l1.e.x&gt;&gt;l1.e.y&gt;&gt;l1.s.x&gt;&gt;l1.s.y&gt;&gt;l2.e.x&gt;&gt;l2.e.y&gt;&gt;l2.s.x&gt;&gt;l2.s.y; Vector v1=l1.s-l1.e; Vector v2=l2.s-l2.e; if(dcmp(cross(v1,v2))==0) &#123; Vector v3=l1.s-l2.e; if(dcmp(cross(v1,v3))==0) cout&lt;&lt;"LINE"&lt;&lt;endl; else cout&lt;&lt;"NONE"&lt;&lt;endl; continue; &#125; Point in=getinter(l1,l2); cout&lt;&lt;"POINT "&lt;&lt;fixed&lt;&lt;setprecision(2)&lt;&lt;in.x&lt;&lt;" "&lt;&lt;in.y&lt;&lt;endl; &#125; cout&lt;&lt;"END OF OUTPUT"&lt;&lt;endl;&#125; 收获与反思 第一次接触计算几何，模板积累。]]></content>
      <categories>
        <category>编程</category>
        <category>ACM</category>
      </categories>
      <tags>
        <tag>ACM</tag>
        <tag>算法</tag>
        <tag>2018暑假集训</tag>
        <tag>POJ</tag>
        <tag>计算几何</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[【POJ-1066】解题报告（计算几何，线段交点）]]></title>
    <url>%2Fpost%2F9c28a880.html</url>
    <content type="text"><![CDATA[原始题目Treasure Hunt Time Limit: 1000MS Memory Limit: 10000K Total Submissions: 7927 Accepted: 3269 DescriptionArcheologists from the Antiquities and Curios Museum (ACM) have flown to Egypt to examine the great pyramid of Key-Ops. Using state-of-the-art technology they are able to determine that the lower floor of the pyramid is constructed from a series of straightline walls, which intersect to form numerous enclosed chambers. Currently, no doors exist to allow access to any chamber. This state-of-the-art technology has also pinpointed the location of the treasure room. What these dedicated (and greedy) archeologists want to do is blast doors through the walls to get to the treasure room. However, to minimize the damage to the artwork in the intervening chambers (and stay under their government grant for dynamite) they want to blast through the minimum number of doors. For structural integrity purposes, doors should only be blasted at the midpoint of the wall of the room being entered. You are to write a program which determines this minimum number of doors. An example is shown below: InputThe input will consist of one case. The first line will be an integer n (0 ≤ n ≤ 30) specifying number of interior walls, followed by n lines containing integer endpoints of each wall x1 y1 x2 y2 . The 4 enclosing walls of the pyramid have fixed endpoints at (0,0); (0,100); (100,100) and (100,0) and are not included in the list of walls. The interior walls always span from one exterior wall to another exterior wall and are arranged such that no more than two walls intersect at any point. You may assume that no two given walls coincide. After the listing of the interior walls there will be one final line containing the floating point coordinates of the treasure in the treasure room (guaranteed not to lie on a wall). OutputPrint a single line listing the minimum number of doors which need to be created, in the format shown below. Sample Input7 20 0 37 100 40 0 76 100 85 0 0 75 100 90 0 90 0 71 100 61 0 14 100 38 100 47 47 100 54.5 55.4 Sample OutputNumber of doors = 2 SourceEast Central North America 1999 题目大意在一个100*100的正方形区域中，有n条两端点均在正方形边界的墙将区域分成许多个部分（房间），已知可以破坏每个区域房间墙壁的中点，区域中某个点是宝藏，问从外界到宝藏处最少需要破坏多少个墙壁。 解题思路 由于破坏墙中点后就可以移动到左右端点，故实际上破坏位置在不在中点没有区别。 不可能绕开墙壁，所以走直线最近，每个墙壁最多只会遭遇一次。 所以等价从边界上每个墙壁的端点到宝藏位置连一条线段，和其他线段的交点（严格相交）+1就是所求答案。 利用计算几何中的判断线段是否相交的函数。 解题代码123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147148149150151152153154155156157158159160161162163164165166167168169170171172//计算几何模板，二维几何基础//使用印用注意避免直接在程序中调用构造函数构造无名对象。否则可能会导致程序出错 //#include &lt;bits/stdc++.h&gt;#include &lt;cstdio&gt;#include &lt;cmath&gt;#include &lt;cstdlib&gt;#include &lt;cstring&gt;#include &lt;iostream&gt;#include &lt;set&gt;#include &lt;iomanip&gt;#include &lt;algorithm&gt;#include &lt;queue&gt;#include &lt;map&gt;#include &lt;string&gt;#define INF 0x3f3f3f3f#define rep(i,a,n) for(int i=a;i&lt;n;i++)#define per(i,a,n) for(int i=n-1;i&gt;=a;i--)using namespace std;typedef long long ll;const double eps =1e-10;const int maxn=50;int n;//有的命名为sgn函数，高精度符号判断 int dcmp(double x)&#123; //相等函数判断，减少精度问题 if(fabs(x)&lt;eps) return 0; else return x&lt;0?-1:1;&#125;//点的定义 class Point&#123; public: double x,y; Point (double x=0,double y=0):x(x),y(y)&#123;&#125; //构造函数，方便代码的编写 &#125;point[maxn]; typedef Point Vector;// 从程序实现上，Vector只是Point的别名//运算符重载 Vector operator + (const Vector &amp;A,const Vector &amp;B) &#123; return Vector(A.x+B.x,A.y+B.y); &#125; //向量+向量=向量，点+向量=点Vector operator - (const Vector &amp;A,const Vector &amp;B) &#123; return Vector(A.x-B.x,A.y-B.y); &#125; //向量-向量=向量，点-向量-点 Vector operator * (const Vector &amp;A,double p) &#123; return Vector(A.x*p,A.y*p); &#125; //向量*数=向量 （数乘） Vector operator / (const Vector &amp;A,double p) &#123; return Vector(A.x/p,A.y/p); &#125; //向量/数=向量 （数除）double operator * (const Vector &amp;A,const Vector &amp;B) &#123; return A.x*B.x+A.y*B.y; &#125; //向量（点乘）向量=数 （点乘）bool operator &lt; (const Point &amp;A,const Point &amp;B) &#123; return A.x==B.x?A.y&lt;B.y:A.x&lt;B.x; &#125; //按x值递增排序 bool operator == (const Point &amp;A,const Point &amp;B) &#123; return dcmp(A.x-B.x)==0&amp;&amp; dcmp(A.y-B.y)==0; &#125; //判定两个点是否相同，用到dcmp精度判定 //点乘叉乘 double dot(const Vector &amp;A,const Vector &amp;B)&#123; return A.x*B.x+A.y*B.y; &#125; //向量（叉乘）向量=向量 （叉乘） double operator ^ (const Vector &amp;A,const Vector &amp;B)&#123; return A.x*B.y-A.y*B.x; &#125;double cross(const Vector &amp;A,const Vector &amp;B)&#123; return A.x*B.y-A.y*B.x; &#125;//模长面积 double abs(const Vector &amp;A)&#123; return sqrt(dot(A,A));&#125; //计算向量模长 double area2(const Point &amp;A,const Point &amp;B,const Point &amp;C)&#123; return cross(B-A,C-A) ;&#125; //计算平行四边形方向面积double PolygonArea(Point *p,int n) &#123; double area=0; rep(i,1,n-1)&#123;area+=cross(p[i]-p[0],p[i+1]-p[0]);&#125;return area/2.0; &#125; //计算多边形的有向面积//旋转Vector rotate(Vector A,double rad) &#123; return Vector(A.x*cos(rad)-A.y*sin(rad),A.x*sin(rad)+A.y*cos(rad));&#125; //旋转rad弧度 Vector normal(Vector A)&#123;double l=abs(A);return Vector(-A.y/l,A.x/l);&#125; //计算单位法线，左转90//线段定义 class Line &#123; public: Point s,e; Line()&#123;&#125; Line(Point _s,Point _e)&#123; s=_s;e=_e; &#125; &#125;line[maxn];//判断两线段是否相交 bool inter(Line l1,Line l2)&#123;// cout&lt;&lt;"L1 "&lt;&lt;l1.e.x&lt;&lt;","&lt;&lt;l1.e.y&lt;&lt;" "&lt;&lt;l1.s.x&lt;&lt;","&lt;&lt;l1.s.y&lt;&lt;endl;// cout&lt;&lt;"L2 "&lt;&lt;l2.e.x&lt;&lt;","&lt;&lt;l2.e.y&lt;&lt;" "&lt;&lt;l2.s.x&lt;&lt;","&lt;&lt;l2.s.y&lt;&lt;endl; return ( //根据题目要求端点相交是否算作相交来决定大于等于和小于等于 //排斥实验 max(l1.s.x,l1.e.x)&gt;=min(l2.s.x,l2.e.x) &amp;&amp; max(l2.s.x,l2.e.x)&gt;=min(l1.s.x,l1.e.x) &amp;&amp; max(l1.s.y,l1.e.y)&gt;=min(l2.s.y,l2.e.y) &amp;&amp; max(l2.s.y,l2.e.y)&gt;=min(l1.s.y,l1.e.y) &amp;&amp; //跨立实验 dcmp((l2.s-l1.s)^(l1.s-l1.e))*dcmp((l2.e-l1.s)^(l1.s-l1.e))&lt;0 &amp;&amp; dcmp((l1.s-l2.s)^(l2.s-l2.e))*dcmp((l1.e-l2.s)^(l2.s-l2.e))&lt;0 ) ;&#125;bool inter(Point a1,Point a2,Point b1,Point b2)&#123; Line l1(a1,a2),l2(b1,b2); return inter(l1,l2);&#125;bool cmp(Point a,Point b)&#123; if(a.x==b.x) return a.y&lt;b.y; else return a.x&lt;b.x;&#125;//求两直线交点Point getinter(Line l1,Line l2)&#123;Vector v=l1.s-l1.e;Vector w=l2.s-l2.e;Vector u=l1.e-l2.e;double t=cross(w,u)/cross(v,w);return l1.e+v*t;&#125; Point getinter(Point a1,Point a2,Point b1,Point b2)&#123;Line l1(a1,a2);Line l2(b1,b2);return getinter(l1,l2);&#125;//判定点和线段的关系，//0:不在线段所在直线上//1:在线段内（不含端点） //2:在线段端点//3:在线段两侧的射线上 int online(Point a,Line l)&#123; if(dcmp(cross(l.s-a,l.e-a))!=0) return 0; double pans=dcmp(dot(l.s-a,l.e-a));// cout&lt;&lt;(l.s-a).x&lt;&lt;","&lt;&lt;(l.s-a).y&lt;&lt;" "&lt;&lt;(l.e-a).x&lt;&lt;","&lt;&lt;(l.e-a).y&lt;&lt;endl; if(pans&lt;0) return 1; else if(pans==0) return 2; else if(pans&gt;0) return 3;&#125;int online(Point a,Point b1,Point b2)&#123; Line l(b1,b2); return online(a,l);&#125;//凸包int ConvexHull(Point *p,int n,Point *ch)&#123; sort(p,p+n,cmp); int m=0; for(int i=0;i&lt;n;i++)&#123; while(m&gt;1 &amp;&amp; cross(ch[m-1]-ch[m-2],p[i]-ch[m-2])&lt;=0) m--; ch[m++]=p[i]; &#125; int k=m; for(int i=n-2;i&gt;=0;i--)&#123; while(m&gt;k &amp;&amp; cross(ch[m-1]-ch[m-2],p[i]-ch[m-2])&lt;=0) m--; ch[m++]=p[i]; &#125; if(n&gt;1) m--; return m;&#125; int main()&#123; cin&gt;&gt;n; rep(i,0,n)&#123; cin&gt;&gt;line[i].e.x&gt;&gt;line[i].e.y&gt;&gt;line[i].s.x&gt;&gt;line[i].s.y; &#125; cin&gt;&gt;point[0].x&gt;&gt;point[0].y; if(n==0) cout&lt;&lt;"Number of doors = 1"&lt;&lt;endl; else&#123; int ans=INF; rep(i,0,n)&#123; int cnt=0; Point pn=line[i].e; Line ln(point[0],pn); rep(j,0,n)&#123; if(inter(ln,line[j])) cnt++; &#125;// cout&lt;&lt;"p1 "&lt;&lt;cnt&lt;&lt;endl; ans=min(ans,cnt); cnt=0; pn=line[i].s; ln.s=point[0];ln.e=pn; rep(j,0,n)&#123; if(inter(ln,line[j])) cnt++; &#125; ans=min(ans,cnt);// cout&lt;&lt;"p2 "&lt;&lt;cnt&lt;&lt;endl; &#125; cout&lt;&lt;"Number of doors = "&lt;&lt;ans+1&lt;&lt;endl; &#125; &#125; 收获与反思 第一次接触计算几何，模板积累。]]></content>
      <categories>
        <category>编程</category>
        <category>ACM</category>
      </categories>
      <tags>
        <tag>ACM</tag>
        <tag>算法</tag>
        <tag>2018暑假集训</tag>
        <tag>POJ</tag>
        <tag>计算几何</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[【HDU-6322】解题报告（数论，2018杭电多校第三场）]]></title>
    <url>%2Fpost%2Fe8ae7612.html</url>
    <content type="text"><![CDATA[原始题目Problem D. Euler Function Time Limit: 2000/1000 MS (Java/Others) Memory Limit: 524288/524288 K (Java/Others) Total Submission(s): 150 Accepted Submission(s): 136 Problem DescriptionIn number theory, Euler’s totient function $\varphi(n)$ counts the positive integers up to a given integer $n$ that are relatively prime to $n$. It can be defined more formally as the number of integers $k$ in the range $1\leq k\leq n$ for which the greatest common divisor $\gcd(n, k)$ is equal to $1$. For example, $\varphi(9) = 6$ because $1,2,4,5,7$ and $8$ are coprime with $9$. As another example, $\varphi(1) = 1$ since for $n = 1$ the only integer in the range from $1$ to $n$ is 1 itself, and $\gcd(1, 1) = 1$ . A composite number is a positive integer that can be formed by multiplying together two smaller positive integers. Equivalently, it is a positive integer that has at least one divisor other than $1$ and itself. So obviously $1$ and all prime numbers are not composite number. In this problem, given integer $k$, your task is to find the $k$-th smallest positive integer n, that $\varphi(n)$ is a composite number. InputThe first line of the input contains an integer $T(1\leq T\leq100000)$, denoting the number of test cases.In each test case, there is only one integer $k(1\leq k\leq 10^9)$. OutputFor each test case, print a single line containing an integer, denoting the answer. Sample Input2 1 2 Sample Output5 7 Source2018 Multi-University Training Contest 3 Recommendchendu 题目大意求第k个正整数n，其欧拉函数$\varphi(n)$为合数。 解题思路 数论题 手写一下，发现数稍微大便全是合数。反向考虑$\varphi(n)$为质数。 已知$\varphi(n) = p_1^{k_1-1}(p_1-1)p_2^{k_2-1}(p_2-1)\cdots$，其中$\gcd(p_1, p_2 \cdots)=1$。分情况讨论： 情况1：$n$为$p^k$形式，即只有一个质因子。 子情况1.1：该质因子为$2$，那么要使$\varphi(n)$为质数，则$p^{k-1}$为质数，很明显$k=1,2$，所以该情况下$n$只能为$2,4$ 子情况1.2：该质因数不为$2$，那么要使$\varphi(n)$为质数，$p-1$也得为质数，很明显成立的只有$3$（相邻两个数均为质数） 情况2：$n$由两个质因子构成。 子情况1.1：其中一个为$2$，由于另一个会贡献一个$2$，要使$\varphi(n)$为质数,则$2$质因数指数只能为$1$，另一质因数只能为$3$，指数只能为$1$。 子情况2.2：均不为$2$，那么两个质因子各贡献一个$2$，那么$\varphi(n)$一定为4的倍数，不为质数。 当$n=1,2,3,4,6$时，$\varphi(n)$为质数。 解题代码12345678910111213141516#include&lt;bits/stdc++.h&gt;using namespace std;int main()&#123; int T; long long k; cin&gt;&gt;T; while(T--) &#123; cin&gt;&gt;k; if(k==1) cout&lt;&lt;5&lt;&lt;endl; else cout&lt;&lt;k+5&lt;&lt;endl; &#125; return 0;&#125; 收获与反思 数论先推前几项再分析 掌握欧拉函数的计算方法和性质。]]></content>
      <categories>
        <category>编程</category>
        <category>ACM</category>
      </categories>
      <tags>
        <tag>ACM</tag>
        <tag>算法</tag>
        <tag>2018暑假集训</tag>
        <tag>数论</tag>
        <tag>HDU</tag>
        <tag>2018杭电多校</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[【CSU-2059】解题报告（递推，几何）]]></title>
    <url>%2Fpost%2F34f53a10.html</url>
    <content type="text"><![CDATA[HDU-2050变式拓展 原始题目2059: Water Problem Time Limit: 1 Sec Memory Limit: 128 Mb Submitted: 576 Solved: 199 Description​ 一条‘Z’形线可以将平面分为两个区域，那么由N条Z形线所定义的区域的最大个数是多少呢？每条Z形线由两条平行的无限半直线和一条直线段组成 Input首先输入一个数字T（T&lt;100），代表有T次询问 每次询问输入一个数字N（N&lt;1e8），代表有N条Z形线 Output对于每次询问，在一行输出N条‘Z’形线所能划分的区域的最大个数为多少 Sample Input2 1 2 Sample Output2 12 Hint SourceAuthorcsutsz 题目大意如题 解题思路 先推导递推式，由于数据量大，再推导通项公式最后直接输出。 分析：第i条z形线比第i-1条z形线新分成的最多区域数为新增最多交点个数+1 第i条线最多与前i-1条z形线交 $4*(i-1)$ 个点。dp[i]=dp[i-1]+4\*(i-1)+! , dp[1]=2 所以得到通项公式dp[i]=\frac{9\*(i-1)\*(i)}{2}+i+1 解题代码123456789101112131415161718192021222324252627#include &lt;cstdio&gt;#include &lt;cstring&gt;#include &lt;iostream&gt;#include &lt;set&gt;#include &lt;algorithm&gt;#include &lt;queue&gt;#include &lt;map&gt;#include &lt;string&gt;#define eps 1e-8#define INF 0x3f3f3f3f#define rep(i,a,n) for(int i=a;i&lt;n;i++)#define per(i,a,n) for(int i=n-1;i&gt;=a;i--)using namespace std;const int maxn=1e8+2;typedef long long ll;using namespace std;int main()&#123; int t; cin&gt;&gt;t; for(ll i=0;i&lt;t;i++)&#123; ll a; cin&gt;&gt;a; if(a==1) cout&lt;&lt;2&lt;&lt;endl; else cout&lt;&lt;9*(a-1)*(a)/2+a+1&lt;&lt;endl; &#125;&#125; 收获与反思 折线，z形线，类似的都转化到与新增交点数的关系。]]></content>
      <categories>
        <category>编程</category>
        <category>ACM</category>
      </categories>
      <tags>
        <tag>ACM</tag>
        <tag>CSU</tag>
        <tag>2018暑假集训</tag>
        <tag>递推</tag>
        <tag>几何</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[【ZOJ-1633】解题报告（字符串递推，二分查找）]]></title>
    <url>%2Fpost%2F5e189593.html</url>
    <content type="text"><![CDATA[原始题目Big String Time Limit: 2 Seconds Memory Limit: 65536 KB We will construct an infinitely long string from two short strings: A = “^__^” (four characters), and B = “T.T” (three characters). Repeat the following steps: Concatenate A after B to obtain a new string C. For example, if A = “^__^” and B = “T.T”, then C = BA = “T.T^__^”. Let A = B, B = C — as the example above A = “T.T”, B = “T.T^__^”. Your task is to find out the n-th character of this infinite string. InputThe input contains multiple test cases, each contains only one integer $N (1 \le N \le 2^{63} - 1)$. Proceed to the end of file. OutputFor each test case, print one character on each line, which is the N-th (index begins with 1) character of this infinite string. Sample Input1 2 4 8 Sample OutputT . ^ T Author:CHENG, Long Source:Zhejiang University Local Contest 2003 题目大意由A=”^__^” ， B=”T.T” ， C=BA=”T.T^__^” ，再令C=B, B=A，重复这种操作，问如此构成的字符串第n个字符是什么。 解题思路 $dp[i]$ 表示第i个字符串由多少个字符构成，已知$dp[0]=4,dp[1]=3,dp[2]=7$，根据递推规则可知$dp[i+1]=dp[i]+dp[i-1]$ 折半查找第一个比n大的dp[i]，则第i串里的第n位与第i-1串里的第n-dp[i-1]（可以保证这一项大于零）位对应字符相同。递归操作直至n&lt;7。从”T.T^__^”寻找就可以了 解题代码123456789101112131415161718192021222324252627282930313233343536#include &lt;cstdio&gt;#include &lt;cstring&gt;#include &lt;iostream&gt;#include &lt;set&gt;#include &lt;algorithm&gt;#include &lt;queue&gt;#include &lt;map&gt;#include &lt;string&gt;#define eps 1e-8#define INF 0x3f3f3f3f#define rep(i,a,n) for(int i=a;i&lt;n;i++)#define per(i,a,n) for(int i=n-1;i&gt;=a;i--)using namespace std;using namespace std;typedef long long ll;ll a[95]; //保存字符串的长度int main()&#123; string C = "T.T^__^"; a[0] = 4; a[1] = 3; int i; for(i = 2; i &lt; 90; i++) a[i] = a[i-1] + a[i-2]; ll n; while(cin &gt;&gt; n) &#123; while(n &gt; 7) &#123; int pos = lower_bound(a, a+89, n) - a; n -= a[pos-1]; &#125; cout &lt;&lt; C[n-1] &lt;&lt; endl; &#125; return 0;&#125; 收获与反思 二分查找与递推的结合]]></content>
      <categories>
        <category>编程</category>
        <category>ACM</category>
      </categories>
      <tags>
        <tag>ACM</tag>
        <tag>算法</tag>
        <tag>2018暑假集训</tag>
        <tag>递推</tag>
        <tag>ZOJ</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[【CSU-1587】解题报告（递推，水题）]]></title>
    <url>%2Fpost%2F31f89579.html</url>
    <content type="text"><![CDATA[原始题目1587: 爬楼梯 Time Limit: 1 Sec Memory Limit: 128 Mb Submitted: 867 Solved: 514 Description小时候我们都玩过爬楼梯的游戏：两人猜拳，赢了可向上爬一级，谁先到最高级则获胜。作为大学生，我们应该玩一个更有水平的游戏。现在一个人要上n级楼梯，每一步可以选择上一级或者上两级，但是不能后退。求上这n级楼梯的方案数。 Input第一行只有一个整数$T(1 \le T \le 45)$，表示数据组数。下面的T行每一行有一个整数$ n ( 1 \le n \le 45)$ ，表示有多少级楼梯。 Output对于每一组数据输出一个整数s，表示方案数。 Sample Input4 1 2 3 4 Sample Output1 2 3 5 HintSource国防科学技术大学第十八届银河之光文化节ACM程序设计竞赛初赛 题目大意如题 解题思路 到第i级阶梯可由第i-1级阶梯爬一级或由第i-2级解题爬两层。 解题代码12345678910111213141516171819202122232425262728293031323334353637#include &lt;cstdio&gt;#include &lt;cstring&gt;#include &lt;iostream&gt;#include &lt;set&gt;#include &lt;algorithm&gt;#include &lt;queue&gt;#include &lt;map&gt;#include &lt;string&gt;#define eps 1e-8#define INF 0x3f3f3f3f#define rep(i,a,n) for(int i=a;i&lt;n;i++)#define per(i,a,n) for(int i=n-1;i&gt;=a;i--)using namespace std;const int maxn=1e5+5;typedef long long ll;ll dp[maxn];void solve()&#123; memset(dp,0,sizeof(dp)); dp[1]=1; dp[2]=2; rep(i,3,50)&#123; dp[i]=dp[i-1]+dp[i-2]; &#125; &#125;using namespace std;int main()&#123; int t; solve(); while(cin&gt;&gt;t)&#123; rep(i,0,t)&#123; ll a; cin&gt;&gt;a; cout&lt;&lt;dp[a]&lt;&lt;endl; &#125; &#125;&#125; 收获与反思暂无，水题]]></content>
      <categories>
        <category>编程</category>
        <category>ACM</category>
      </categories>
      <tags>
        <tag>ACM</tag>
        <tag>算法</tag>
        <tag>CSU</tag>
        <tag>2018暑假集训</tag>
        <tag>递推</tag>
        <tag>水题</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[【UVA-12034】解题报告（递推，DP）]]></title>
    <url>%2Fpost%2F5f341cbe.html</url>
    <content type="text"><![CDATA[原始题目12034 - Race Time limit: 1.000 seconds Disky and Sooma, two of the biggest mega minds of Bangladesh went to a far country. They ate, codedand wandered around, even in their holidays. They passed several months in this way. But everythinghas an end. A holy person, Munsiji came into their life. Munsiji took them to derby (horse racing).Munsiji enjoyed the race, but as usual Disky and Sooma did their as usual task instead of passing someromantic moments. They were thinking- in how many ways a race can finish! Who knows, maybe thisis their romance! In a race there are n horses. You have to output the number of ways the race can finish. Note that,more than one horse may get the same position. For example, 2 horses can finish in 3 ways. Both first horse1 first and horse2 second horse2 first and horse1 second InputInput starts with an integer T (≤ 1000), denoting the number of test cases. Each case starts with aline containing an integer n (1 ≤ n ≤ 1000). OutputFor each case, print the case number and the number of ways the race can finish. The result can bevery large, print the result modulo 10056. Sample Input3 1 2 3 Sample OutputCase 1: 1 Case 2: 3 Case 3: 13 题目大意一场赛马比赛中由n匹马，任意两匹马可以同时到达或者一先一后到达，问一共有多少种到达的可能。 解题思路 考虑dp。 $dp[i][j]$表示i匹马用j次到达的可能情况数。 考虑第i匹马的情况，可能和前i-1匹马一同到达，或者单独到达（即第i匹马到达时有并列，无并列）。$dp[i][j]=j*(dp[i-1][j]+dp[i-1][j-1])$，乘j是因为第i匹马名次有j种可能。 解题代码12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849#include &lt;cstdio&gt;#include &lt;cstring&gt;#include &lt;iostream&gt;#include &lt;set&gt;#include &lt;algorithm&gt;#include &lt;queue&gt;#include &lt;map&gt;#include &lt;string&gt;#define eps 1e-8#define INF 0x3f3f3f3f#define rep(i,a,n) for(int i=a;i&lt;n;i++)#define per(i,a,n) for(int i=n-1;i&gt;=a;i--)using namespace std;const int maxn=1e8+2;const int mod=10056;typedef long long ll;ll dp[1005][1005];ll ans[1005];int main()&#123; int t; memset(dp,0,sizeof(dp)); memset(ans,0,sizeof(ans)); dp[1][1]=1; ans[1]=1; for(int i=2;i&lt;=1000;i++)&#123; int sum=0; for(int j=1;j&lt;=i;j++)&#123; if(j==1) dp[i][j]=1; else dp[i][j]=j*(dp[i-1][j]+dp[i-1][j-1])%mod; sum=(sum+dp[i][j])%mod;// cout&lt;&lt;"ans["&lt;&lt;i&lt;&lt;"]="&lt;&lt;ans[i]&lt;&lt;endl; &#125; ans[i]=sum;// cout&lt;&lt;i&lt;&lt;" "&lt;&lt;ans[i]&lt;&lt; " "&lt;&lt;ans[i-1]&lt;&lt;endl; &#125;// for(int i=2;i&lt;=1005;i++)&#123;// cout&lt;&lt;"i="&lt;&lt;i&lt;&lt;" "&lt;&lt;ans[i]&lt;&lt;endl; // &#125; cin&gt;&gt;t; int n,cas=1; while(t--) &#123; cin&gt;&gt;n; cout&lt;&lt;"Case "&lt;&lt;cas++&lt;&lt;": " &lt;&lt;ans[n]&lt;&lt;endl; &#125;&#125; 收获与反思注意取模的运算规则，考虑dp与最终答案的关系。]]></content>
      <categories>
        <category>编程</category>
        <category>ACM</category>
      </categories>
      <tags>
        <tag>ACM</tag>
        <tag>算法</tag>
        <tag>2018暑假集训</tag>
        <tag>递推</tag>
        <tag>UVA</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[【URAL-1081】解题报告（递推，斐波那契）]]></title>
    <url>%2Fpost%2F40dfaace.html</url>
    <content type="text"><![CDATA[题目大意1081. Binary Lexicographic Sequence Time limit: 0.5 second Memory limit: 64 MB Consider all the sequences with length (0 &lt; N &lt; 44), containing only the elements 0 and 1, and no two ones are adjacent (110 is not a valid sequence of length 3, 0101 is a valid sequence of length 4). Write a program which finds the sequence, which is on K-th place (0 &lt; K &lt; 109) in the lexicographically sorted in ascending order collection of the described sequences. InputThe first line of input contains two positive integers N and K. OutputWrite the found sequence or −1 if the number K is larger then the number of valid sequences. Sampleinput3 1 output000 Problem Author:Emil Kelevedzhiev Problem Source:Winter Mathematical Festival Varna ‘2001 Informatics Tournament 题目大意求词典序下第K个长度为N且无相邻位置都为1的0、1序列。无解时输出-1。 解题思路 先考虑长度为n的符合要求序列有多少个。 1（2个）:0 1 2（3个）:00 01 10 3（5个）:000 001 010 100 101 4（8个）:0000 0001 0010 0100 0101 1000 1001 1010 5（13个）:00000 00001 00010 00100 00101 01000 01001 01010 10000 10001 10010 10100 10101 发现规律，个数为斐波那契数列。构成原因：dp[k+1]的前dp[k]项为前面补0，后dp[k-1]项为前面补10 解题代码12345678910111213141516171819202122232425262728293031323334353637383940414243444546#include &lt;cstdio&gt;#include &lt;cstring&gt;#include &lt;iostream&gt;#include &lt;set&gt;#include &lt;algorithm&gt;#include &lt;queue&gt;#include &lt;map&gt;#include &lt;string&gt;#define eps 1e-8#define INF 0x3f3f3f3f#define rep(i,a,n) for(int i=a;i&lt;n;i++)#define per(i,a,n) for(int i=n-1;i&gt;=a;i--)using namespace std;typedef long long ll;const int maxn=1e5+5;ll n,k;ll dp[maxn];void solve()&#123; dp[0]=1; dp[1]=2; dp[2]=3; rep(i,3,50)&#123; dp[i]=dp[i-1]+dp[i-2]; &#125;&#125;int main()&#123; solve(); while(~scanf("%lld%lld",&amp;n,&amp;k))&#123; if(k&gt;dp[n])&#123; printf("-1\n"); &#125; else &#123; while(n) &#123; n--; if(k&lt;=dp[n])printf("0"); else &#123; printf("1"); k-=dp[n]; &#125; &#125; printf("\n"); &#125; &#125;&#125; 收获与反思 注意观察斐波那契数列]]></content>
      <categories>
        <category>编程</category>
        <category>ACM</category>
      </categories>
      <tags>
        <tag>ACM</tag>
        <tag>算法</tag>
        <tag>2018暑假集训</tag>
        <tag>递推</tag>
        <tag>URAL</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[【HDU-2018】解题报告（递推，水题）]]></title>
    <url>%2Fpost%2F36bef409.html</url>
    <content type="text"><![CDATA[原始题目母牛的故事 Time Limit: 2000/1000 MS (Java/Others) Memory Limit: 65536/32768 K (Java/Others) Total Submission(s): 105012 Accepted Submission(s): 51527 Problem Description有一头母牛，它每年年初生一头小母牛。每头小母牛从第四个年头开始，每年年初也生一头小母牛。请编程实现在第n年的时候，共有多少头母牛？ Input输入数据由多个测试实例组成，每个测试实例占一行，包括一个整数n(0&lt;n&lt;55)，n的含义如题目中描述。n=0表示输入数据的结束，不做处理。 Output对于每个测试实例，输出在第n年的时候母牛的数量。每个输出占一行。 Sample Input2 4 5 0 Sample Output2 4 6 Authorlcy SourceC语言程序设计练习（三） Recommendlcy 题目大意如题 解题思路 $b[i]$表示第i年的母牛数，$s[i]$表示第i年的小牛数。有$b[i]=b[i-1]+b[i-3]$;$s[i]=s[i-1]-b[i-3]+b[i]$; 即第i年的母牛等于i-1年的母牛数加上三年前母牛产的小牛数（今年长成母牛），第i年的小牛数等于第i-1年的小牛数减去三年前新产的小牛数（今年长成母牛）加上今年新产的小牛。 输出大小牛的和解题代码123456789101112131415161718192021222324252627282930313233343536#include &lt;cstdio&gt;#include &lt;cstring&gt;#include &lt;iostream&gt;#include &lt;set&gt;#include &lt;algorithm&gt;#include &lt;queue&gt;#include &lt;map&gt;#include &lt;string&gt;#define eps 1e-8#define INF 0x3f3f3f3f#define rep(i,a,n) for(int i=a;i&lt;n;i++)#define per(i,a,n) for(int i=n-1;i&gt;=a;i--)using namespace std;const int maxn=1e8+2;typedef long long ll;int b[100],s[100];void solve()&#123; b[1]=b[2]=b[3]=b[4]=1; s[1]=0; s[2]=1; s[3]=2; s[4]=3; for(int i=5;i&lt;55;i++)&#123; b[i]=b[i-1]+b[i-3]; s[i]=s[i-1]-b[i-3]+b[i]; &#125; &#125;int n;int main()&#123; solve(); while(cin&gt;&gt;n&amp;&amp;n)&#123; cout&lt;&lt;b[n]+s[n]&lt;&lt;endl; &#125;&#125; 收获与反思暂无]]></content>
      <categories>
        <category>编程</category>
        <category>ACM</category>
      </categories>
      <tags>
        <tag>ACM</tag>
        <tag>算法</tag>
        <tag>2018暑假集训</tag>
        <tag>递推</tag>
        <tag>水题</tag>
        <tag>HDU</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[【POJ-1664】解题报告（递推，dp）]]></title>
    <url>%2Fpost%2Fbde4b1f8.html</url>
    <content type="text"><![CDATA[原始题目放苹果 Time Limit: 1000MS Memory Limit: 10000K Total Submissions: 37069 Accepted: 22825 Description把 M 个同样的苹果放在 N 个同样的盘子里，允许有的盘子空着不放，问共有多少种不同的分法？（用 K 表示）5，1，1 和 1，5，1 是同一种分法。 Input第一行是测试数据的数目$ t(0 \le t \le 20)$。以下每行均包含二个整数 M 和 N，以空格分开。 $ 1 \le M , N \le 10 $。 Output对输入的每组数据 M 和 N，用一行输出相应的 K。 Sample Input1 7 3 Sample Output8 Sourcelwx@POJ 题目大意如题 解题思路 $dp[i][j]$ 表示 i 个苹果 j 个盘子的分法。 状态转移： - 当$i&lt;j$时，$dp[i][j]=dp[i][i]$ （不区分盘子，所以盘子多余的情况数和盘子恰好和苹果数相等的情况数相等） - 当$i\geqslantj$，$dp[i][j]=dp[i-j][j]+dp[i][j-1]$ （每个盘子都有苹果和有一个盘子没有苹果两种状况转移）注意初始的情况就好。 解题代码1234567891011121314151617181920212223242526272829303132333435363738394041424344454647#include &lt;cstdio&gt;#include &lt;cstring&gt;#include &lt;iostream&gt;#include &lt;set&gt;#include &lt;algorithm&gt;#include &lt;queue&gt;#include &lt;map&gt;#include &lt;string&gt;#define eps 1e-8#define INF 0x3f3f3f3f#define rep(i,a,n) for(int i=a;i&lt;n;i++)#define per(i,a,n) for(int i=n-1;i&gt;=a;i--)using namespace std;const int maxn=1e8+2;typedef long long ll;ll dp[22][22];void solve()&#123; memset(dp,0,sizeof(dp)); dp[0][0]=1; for(int i=0;i&lt;=21;i++)&#123; for(int j=0;j&lt;=21;j++)&#123; if(i==0) dp[i][j]=1; else if(j==0) dp[i][j]=0; else if(j==1) dp[i][j]=1; else &#123; if(i&lt;j) dp[i][j]=dp[i][i]; else dp[i][j]=dp[i][j-1]+dp[i-j][j]; &#125; &#125; &#125;&#125;int main()&#123; int t; solve(); while(cin&gt;&gt;t)&#123; int m,n; rep(i,0,t)&#123; cin&gt;&gt;m&gt;&gt;n; cout&lt;&lt;dp[m][n]&lt;&lt;endl; &#125; &#125;&#125; 收获与反思注意边界情况的考量]]></content>
      <categories>
        <category>编程</category>
        <category>ACM</category>
      </categories>
      <tags>
        <tag>ACM</tag>
        <tag>算法</tag>
        <tag>DP</tag>
        <tag>2018暑假集训</tag>
        <tag>递推</tag>
        <tag>POJ</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[【HDU-2050】解题报告（递推，几何）]]></title>
    <url>%2Fpost%2F38f8b110.html</url>
    <content type="text"><![CDATA[原始题目折线分割平面 Time Limit: 2000/1000 MS (Java/Others) Memory Limit: 65536/32768 K (Java/Others) Total Submission(s): 37773 Accepted Submission(s): 25282 Problem Description我们看到过很多直线分割平面的题目，今天的这个题目稍微有些变化，我们要求的是n条折线分割平面的最大数目。比如，一条折线可以将平面分成两部分，两条折线最多可以将平面分成7部分，具体如下所示。 Input输入数据的第一行是一个整数$C$,表示测试实例的个数，然后是$C$ 行数据，每行包含一个整数$n ( 0 &lt; n \le 10000)$,表示折线的数量。 Output对于每个测试实例，请输出平面的最大分割数，每个实例的输出占一行。 Sample Input2 1 2 Sample Output2 7 Authorlcy Source递推求解专题练习（For Beginner） Recommendlcy 题目大意如题 解题思路折线类题目思路： dp[i]=dp[i-1]+新增交点数+1 题目数据过大则先手算通项公式。数据小可以直接递推 解题代码 递推写法 12345678910111213141516171819202122232425262728293031323334353637#include &lt;cstdio&gt;#include &lt;cstring&gt;#include &lt;iostream&gt;#include &lt;set&gt;#include &lt;algorithm&gt;#include &lt;queue&gt;#include &lt;map&gt;#include &lt;string&gt;#define eps 1e-8#define INF 0x3f3f3f3f#define rep(i,a,n) for(int i=a;i&lt;n;i++)#define per(i,a,n) for(int i=n-1;i&gt;=a;i--)using namespace std;const int maxn=1e5+5;typedef long long ll;ll dp[maxn];void solve()&#123; memset(dp,0,sizeof(dp)); dp[1]=1; dp[2]=2; rep(i,3,50)&#123; dp[i]=dp[i-1]+dp[i-2]; &#125; &#125;using namespace std;int main()&#123; int t; solve(); while(cin&gt;&gt;t)&#123; rep(i,0,t)&#123; ll a; cin&gt;&gt;a; cout&lt;&lt;dp[a]&lt;&lt;endl; &#125; &#125;&#125; 通项写法 123456789101112131415161718192021222324252627282930#include &lt;cstdio&gt;#include &lt;cstring&gt;#include &lt;iostream&gt;#include &lt;set&gt;#include &lt;algorithm&gt;#include &lt;queue&gt;#include &lt;map&gt;#include &lt;string&gt;#define eps 1e-8#define INF 0x3f3f3f3f#define rep(i,a,n) for(int i=a;i&lt;n;i++)#define per(i,a,n) for(int i=n-1;i&gt;=a;i--)using namespace std;const int maxn=1e5+5;typedef long long ll;using namespace std;int main()&#123; int t; while(cin&gt;&gt;t)&#123; rep(i,0,t)&#123; ll a; cin&gt;&gt;a;// cout&lt;&lt;dp[a]&lt;&lt;endl; cout&lt;&lt;(2*a+1)*(a-1)+2&lt;&lt;endl; &#125; &#125;&#125; 收获与反思 Z形线拓展]]></content>
      <categories>
        <category>编程</category>
        <category>ACM</category>
      </categories>
      <tags>
        <tag>ACM</tag>
        <tag>算法</tag>
        <tag>2018暑假集训</tag>
        <tag>递推</tag>
        <tag>几何</tag>
        <tag>HDU</tag>
        <tag>待补充</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[【HDU-2044】解题报告（递推，水题）]]></title>
    <url>%2Fpost%2F52730f61.html</url>
    <content type="text"><![CDATA[原始题目一只小蜜蜂… Time Limit: 2000/1000 MS (Java/Others) Memory Limit: 65536/32768 K (Java/Others) Total Submission(s): 93384 Accepted Submission(s): 33247 Problem Description有一只经过训练的蜜蜂只能爬向右侧相邻的蜂房，不能反向爬行。请编程计算蜜蜂从蜂房a爬到蜂房b的可能路线数。其中，蜂房的结构如下所示。 Input输入数据的第一行是一个整数N,表示测试实例的个数，然后是N 行数据，每行包含两个整数a和b(0&lt;a&lt;b&lt;50)。 Output对于每个测试实例，请输出蜜蜂从蜂房a爬到蜂房b的可能路线数，每个实例的输出占一行。 Sample Input2 1 2 3 6 Sample Output1 3 Authorlcy Source递推求解专题练习（For Beginner） Recommendlcy 题目大意如题 解题思路递推，dp初步，$dp[i]=dp[i-1]+dp[i-2]$ 解题代码1234567891011121314151617181920212223242526272829303132333435363738394041#include &lt;cstdio&gt;#include &lt;cstring&gt;#include &lt;iostream&gt;#include &lt;set&gt;#include &lt;algorithm&gt;#include &lt;queue&gt;#include &lt;map&gt;#include &lt;string&gt;#define eps 1e-8#define INF 0x3f3f3f3f#define rep(i,a,n) for(int i=a;i&lt;n;i++)#define per(i,a,n) for(int i=n-1;i&gt;=a;i--)using namespace std;const int maxn=1e5+5;typedef long long ll;ll dp[100][100];int main()&#123; ll t; memset(dp,0,sizeof(dp)); dp[0][0]=dp[1][1]=0; for(ll i=1;i&lt;=50-1;i++)&#123; for(ll j=1;j&lt;=50;j++)&#123; if(i==j)dp[i][j]=0; else if(j==i+1) dp[i][j]=1; else if(j==i+2) dp[i][j]=2; else dp[i][j]=dp[i][j-1]+dp[i][j-2];// cout&lt;&lt;i&lt;&lt;" "&lt;&lt;j&lt;&lt;endl; &#125; &#125; while(cin&gt;&gt;t)&#123; ll a,b; rep(i,0,t)&#123; cin&gt;&gt;a&gt;&gt;b; cout&lt;&lt;dp[a][b]&lt;&lt;endl; &#125; &#125;&#125; 收获与反思没啥]]></content>
      <categories>
        <category>编程</category>
        <category>ACM</category>
      </categories>
      <tags>
        <tag>ACM</tag>
        <tag>算法</tag>
        <tag>2018暑假集训</tag>
        <tag>递推</tag>
        <tag>水题</tag>
        <tag>HDU</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[【POJ-3111】解题报告（二分，牛顿迭代，最大化平均值）]]></title>
    <url>%2Fpost%2F8f9cfad3.html</url>
    <content type="text"><![CDATA[原始题目K Best Time Limit: 8000MS Memory Limit: 65536K Total Submissions: 13510 Accepted: 3466 Case Time Limit: 2000MS Special Judge DescriptionDemy has $n$ jewels. Each of her jewels has some value $v_i$ and weight $w_i$. Since her husband John got broke after recent financial crises, Demy has decided to sell some jewels. She has decided that she would keep k best jewels for herself. She decided to keep such jewels that their specific value is as large as possible. That is, denote the specific value of some set of jewels S = {i1, i2, …, ik} as Demy would like to select such k jewels that their specific value is maximal possible. Help her to do so. InputThe first line of the input file contains $n$ — the number of jewels Demy got, and $k$ — the number of jewels she would like to keep $(1 ≤ k ≤ n ≤ 100 000)$. The following $n$ lines contain two integer numbers each — $v_i$ and $w_i$ $(0 ≤ v_i ≤ 10^6, 1 ≤ w_i ≤ 10^6$, both the sum of all $v_i$ and the sum of all $w_i$ do not exceed $10^7$). OutputOutput $k$ numbers — the numbers of jewels Demy must keep. If there are several solutions, output any one. Sample Input3 2 1 1 1 2 1 3 Sample Output1 2 SourceNortheastern Europe 2005, Northern Subregion 题目大意给定 $n$ 个珍珠的价值和重量，要求取其中 $k$ 个并使这 $k$ 个珍珠的平均单位重量价值最大。 解题思路 对平均单位重量价值二分（二分答案），每一次更新每个珍珠 $r_i=v_i-k*w_i$ 即对平均单位重量价值的差值。 排序后取差值最大的3个珍珠，若差值之和大于零（说明平均单位重量价值还不够大），left=mid，否则right=mid。逐渐逼近答案 解题代码123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657#include &lt;cstdio&gt;#include &lt;cstring&gt;#include &lt;iostream&gt;#include &lt;set&gt;#include &lt;algorithm&gt;#include &lt;queue&gt;#include &lt;map&gt;#include &lt;string&gt;#define eps 1e-8#define INF 0x3f3f3f3f#define rep(i,a,n) for(int i=a;i&lt;n;i++)#define per(i,a,n) for(int i=n-1;i&gt;=a;i--)using namespace std;const int maxn=1e5+5;double l,r,mid;int n,k;struct jewl&#123; int id; double vi,wi,ri; &#125;jewls[maxn];bool cmp(jewl a,jewl b)&#123; return a.ri&gt;b.ri;&#125;int main()&#123; while(~scanf("%d%d",&amp;n,&amp;k))&#123; rep(i,1,n+1)&#123; scanf("%lf%lf",&amp;jewls[i].vi,&amp;jewls[i].wi); jewls[i].id=i; &#125; l=0;r=INF; //开始二分寻找答案 while(r-l&gt;eps)&#123; mid=(l+r)/2; rep(i,1,n+1)&#123; jewls[i].ri=jewls[i].vi-mid*jewls[i].wi; &#125; sort(jewls+1,jewls+n+1,cmp); //寻找最大的k个 double sum=0; rep(i,1,k+1)&#123; sum+=jewls[i].ri; &#125; if(sum&gt;=0) l=mid; else r=mid; &#125; rep(i,1,k+1)&#123; if(i==1) printf("%d",jewls[i].id); else printf(" %d",jewls[i].id); &#125; printf("\n"); &#125;&#125; 收获与反思 浮点数二分 最大化平均值经典题。]]></content>
      <categories>
        <category>编程</category>
        <category>ACM</category>
      </categories>
      <tags>
        <tag>ACM</tag>
        <tag>算法</tag>
        <tag>二分</tag>
        <tag>2018暑假集训</tag>
        <tag>POJ</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[【POJ-2785】解题报告（二分水题）]]></title>
    <url>%2Fpost%2F16b5efde.html</url>
    <content type="text"><![CDATA[原始题目4 Values whose Sum is 0 Time Limit: 15000MS Memory Limit: 228000K Total Submissions: 28507 Accepted: 8591 Case Time Limit: 5000MS DescriptionThe SUM problem can be formulated as follows: given four lists A, B, C, D of integer values, compute how many quadruplet (a, b, c, d ) ∈ A x B x C x D are such that a + b + c + d = 0 . In the following, we assume that all lists have the same size n . InputThe first line of the input file contains the size of the lists n (this value can be as large as 4000). We then have n lines containing four integer values (with absolute value as large as $2^{28}$ ) that belong respectively to A, B, C and D . OutputFor each input file, your program has to write the number quadruplets whose sum is zero. Sample Input6 -45 22 42 -16 -41 -27 56 30 -36 53 -37 77 -36 30 -75 -46 26 -38 -10 62 -32 -54 -6 45 Sample Output5 HintSample Explanation: Indeed, the sum of the five following quadruplets is zero: (-45, -27, 42, 30), (26, 30, -10, -46), (-32, 22, 56, -46),(-32, 30, -75, 77), (-32, -54, 56, 30). SourceSouthwestern Europe 2005 题目大意给定四个长度为n的数列，从每一个数列中抽取一个数，问和为零的共有多少种可能。 解题思路 预处理出前两个数列的和sum1与后两个数列的和sum2。 对sum1排序，二分查找sum2中每个元素的相反数，累加输出 注意不要用binary_search函数，而应该用upper_bound - lower_bound ，因为可能sum1数列中有多个元素值均为 -sum2[i] 。如果用binary_search 只能得到是否有，计数会少计。 解题代码12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849#include &lt;cstdio&gt;#include &lt;cstdlib&gt;#include &lt;iostream&gt;#include &lt;cstring&gt;#include &lt;algorithm&gt;#include &lt;stack&gt;#include &lt;vector&gt;#include &lt;set&gt;#include &lt;map&gt;using namespace std;#define rep(i,a,n) for (int i=a;i&lt;n;i++)#define per(i,a,n) for (int i=n-1;i&gt;=a;i--)//#define pb push_back//#define mp make_pair//#define np next_permutation//#define all(x) x.begin(),x.end()//#define fi first//#define se second//#define SZ(x) ((int)(x).size()) //typedef vector &lt;int&gt; vi;typedef long long ll;//typedef pair &lt;int,int&gt; pii;const int mod=1e9+7;const int maxn=4100;ll sum1[maxn*maxn],sum2[maxn*maxn];ll a[maxn],b[maxn],c[maxn],d[maxn];int main()&#123; int n; while(~scanf("%d",&amp;n))&#123; rep(i,0,n)&#123; scanf("%lld %lld %lld %lld",&amp;a[i],&amp;b[i],&amp;c[i],&amp;d[i]); &#125; rep(i,0,n)&#123; rep(j,0,n)&#123; sum1[i*n+j]=a[i]+b[j]; sum2[i*n+j]=c[i]+d[j]; &#125; &#125; sort(sum1,sum1+n*n); ll ans=0; rep(i,0,n*n)&#123; ans+=(upper_bound(sum1,sum1+n*n,-sum2[i])-lower_bound(sum1,sum1+n*n,-sum2[i])); &#125; printf("%lld\n",ans); &#125;&#125; 收获与反思 加深STL里三个函数应用和相互区别。]]></content>
      <categories>
        <category>编程</category>
        <category>ACM</category>
      </categories>
      <tags>
        <tag>ACM</tag>
        <tag>算法</tag>
        <tag>二分</tag>
        <tag>水题</tag>
        <tag>POJ</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[【CodeForces-348A】解题报告（直接或二分）]]></title>
    <url>%2Fpost%2Fdea65d58.html</url>
    <content type="text"><![CDATA[原始题目A. Mafia time limit per test2 seconds memory limit per test256 megabytes input：standard input output：standard output One day n friends gathered together to play “Mafia”. During each round of the game some player must be the supervisor and other n - 1 people take part in the game. For each person we know in how many rounds he wants to be a player, not the supervisor: the i-th person wants to play ai rounds. What is the minimum number of rounds of the “Mafia” game they need to play to let each person play at least as many rounds as they want? InputThe first line contains integer $n (3 ≤ n ≤ 10^5)$. The second line contains $n$ space-separated integers $a_1, a_2 \cdots a_n (1 ≤ a_i ≤ 10^9)$ — the i-th number in the list is the number of rounds the i-th person wants to play. OutputIn a single line print a single integer — the minimum number of game rounds the friends need to let the i-th person play at least ai rounds. Please, do not use the %lld specifier to read or write 64-bit integers in С++. It is preferred to use the cin, cout streams or the %I64d specifier. Examplesinput3 3 2 2 output4 input4 2 2 2 2 output3 NoteYou don’t need to know the rules of “Mafia” to solve this problem. If you’re curious, it’s a game Russia got from the Soviet times: http://en.wikipedia.org/wiki/Mafia_(party_game). 题目大意$n$ 个人进行游戏，每局游戏需要1人监管，剩下 $n-1$ 人参与游戏，现在给出 $n$ 人每人想至少参与游戏的此数，求满足每个人要求的最少游戏盘数。 解题思路水题，可以直接解或者二分 解题代码1234567891011121314151617181920212223#include &lt;iostream&gt;#include &lt;cstdio&gt;#include &lt;cstdlib&gt;#include &lt;algorithm&gt;#include &lt;cstring&gt;#include &lt;cmath&gt;using namespace std;long long a[200010];int main()&#123; int n; long long sum=0,MAX=0; scanf("%d",&amp;n); for(int i=1;i&lt;=n;i++) &#123; scanf("%I64d",a+i); sum+=a[i]; MAX=max(a[i],MAX); &#125; long long ans; if(sum%(n-1)==0) ans=sum/(n-1); else ans=sum/(n-1)+1; ans=max(MAX,ans); printf("%I64d\n",ans);&#125; 收获与反思 二分做法，下界为数列最大值，上界为数列总和，做下面划分12if(mid*(n-1)&gt;=sum) ri=mid;else le=mid+1;]]></content>
      <categories>
        <category>编程</category>
        <category>ACM</category>
      </categories>
      <tags>
        <tag>ACM</tag>
        <tag>算法</tag>
        <tag>二分</tag>
        <tag>2018暑假集训</tag>
        <tag>水题</tag>
        <tag>CodeForces</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[【CodeForces-600B】解题报告（二分，stl二分函数应用）]]></title>
    <url>%2Fpost%2F5aa5290d.html</url>
    <content type="text"><![CDATA[原始题目B. Queries about less or equal elements time limit per test2 seconds memory limit per test256 megabytes input：standard input output：standard output You are given two arrays of integers $a$ and $b$. For each element of the second array $b_j$ you should find the number of elements in array $a$ that are less than or equal to the value $b_j$. InputThe first line contains two integers $n, m (1 ≤ n, m ≤ 2·10^5)$ — the sizes of arrays $a$ and $b$. The second line contains n integers — the elements of array $a ( - 10^9 ≤ ai ≤ 10^9)$. The third line contains m integers — the elements of array $b ( - 10^9 ≤ bj ≤ 10^9)$. OutputPrint m integers, separated by spaces: the j-th of which is equal to the number of such elements in array $a$ that are less than or equal to the value $b_j$. Examplesinput5 4 1 3 5 7 9 6 4 2 8 output3 2 1 4 input5 5 1 2 1 2 5 3 1 4 1 5 output4 2 4 2 5 题目大意给定$a,b$两个数列，对$b$中每一项$b_i$，求$a$中小于等于$b_i$的项的个数。 解题思路 排序后二分，由于寻找小于等于$b_i$的个数，使用stl里的upper_bound函数。 解题代码12345678910111213141516171819202122232425262728293031323334353637383940414243#include &lt;bits/stdc++.h&gt;using namespace std;#define rep(i,a,n) for (int i=a;i&lt;n;i++)#define per(i,a,n) for (int i=n-1;i&gt;=a;i--)#define pb push_back#define mp make_pair#define np next_permutation#define all(x) x.begin(),x.end()#define fi first#define se second#define SZ(x) (int(x).size())typedef long long ll;typedef vector &lt;int&gt; vi;typedef pair&lt;int,int&gt; pii;const int maxn=2e5+5; vector &lt;ll&gt; va,vb;ll pa,pb;ll n,m;int main()&#123; while(~scanf("%lld%lld",&amp;n,&amp;m))&#123; va.clear(); for(ll i=1;i&lt;=n;i++)&#123; scanf("%lld",&amp;pa); va.pb(pa); &#125; sort(all(va)); for(ll i=1;i&lt;=m;i++)&#123; if(i!=1) printf(" "); scanf("%lld",&amp;pb); if(pb&gt;=*(--va.end())) printf("%lld",n); else if(pb&lt;*(va.begin())) printf("0"); else&#123; ll c=upper_bound(all(va),pb)-va.begin(); printf("%lld",c); &#125; &#125; printf("\n"); &#125;&#125; 收获与反思 二分思想练习 upper_bound 与 lower_bound 使用的一些注意 前提： 数组是一个非降序列 参数： 一个数组元素的地址（或者数组名来表示这个数组的首地址，用来表示这个数组的开头比较的元素的地址，不一定要是首地址，只是用于比较的“首”地址）， 一个数组元素的地址（对应的这个数组里边任意一个元素的地址，表示这个二分里边的比较的”结尾’地址）， 一个你要二分查找的那个数。 返回值： 是地址，不是指那个要查找的数的下标，所以就注定了在这个函数的后边就要减去一个尾巴，那就是这个数组用来比较的头地址。 upper_bound 返回的是键值为i的元素可以插入的最后一个位置（上界） lowe_bound 返回的是键值为i的元素可以插入的位置的第一个位置（下界）。 举例在升序的set里面： set里没有元素i的时候，两个元素的返回值是一样的。 1 2 4 5 这个序列，upp（3）和low（3）都返回位置2（下标） 如果只有一个元素i，low返回那个元素的位置，而upp返回那个元素的位置的后一个位置。 1 2 4 5 这个序列upp（2）返回下标2而low（2）返回下标1 多个元素i，low返回那个元素的位置，upp返回那多个元素中的最后一个的后一个位置。 1 2 2 4 5 这个序列 upp（2）返回下标3的位置，low（2）返回下标1的位置。 不存在时的情况： 特别注意：在一个升序的容器里，如果所有元素都大于i则，upp和low都返回begin。都小于i则返回end（越界了）。]]></content>
      <categories>
        <category>编程</category>
        <category>ACM</category>
      </categories>
      <tags>
        <tag>ACM</tag>
        <tag>算法</tag>
        <tag>二分</tag>
        <tag>2018暑假集训</tag>
        <tag>CodeForces</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[【CSU-2092】解题报告（模拟，物理）]]></title>
    <url>%2Fpost%2F15db1cd9.html</url>
    <content type="text"><![CDATA[原始题目2092: Space Golf Time Limit: 1 Sec Memory Limit: 512 Mb Submitted: 77 Solved: 35 SpecialJudge Description You surely have never heard of this new planet surface exploration scheme, as it is being carried out in a project with utmost secrecy. The scheme is expected to cut costs of conventional rover-type mobile explorers considerably, using projected-type equipment nicknamed “observation bullets”. Bullets do not have any active mobile abilities of their own, which is the main reason of their cost-efficiency. Each of the bullets, after being shot out on a launcher given its initial velocity, makes a parabolic trajectory until it touches down. It bounces on the surface and makes another parabolic trajectory. This will be repeated virtually infinitely. We want each of the bullets to bounce precisely at the respective spot of interest on the planet surface, adjusting its initial velocity. A variety of sensors in the bullet can gather valuable data at this instant of bounce, and send them to the observation base. Although this may sound like a conventional target shooting practice, there are several issues that make the problem more difficult. There may be some obstacles between the launcher and the target spot. The obstacles stand upright and are very thin that we can ignore their widths. Once the bullet touches any of the obstacles, we cannot be sure of its trajectory thereafter. So we have to plan launches to avoid these obstacles. Launching the bullet almost vertically in a speed high enough, we can easily make it hit the target without touching any of the obstacles, but giving a high initial speed is energy-consuming. Energy is extremely precious in space exploration, and the initial speed of the bullet should be minimized. Making the bullet bounce a number of times may make the bullet reach the target with lower initial speed. The bullet should bounce, however, no more than a given number of times. Although the body of the bullet is made strong enough, some of the sensors inside may not stand repetitive shocks. The allowed numbers of bounces vary on the type of the observation bullets. You are summoned engineering assistance to this project to author a smart program that tells the minimum required initial speed of the bullet to accomplish the mission. Figure D.1 gives a sketch of a situation, roughly corresponding to the situation of the Sample Input 4 given below. Figure D.1. A sample situation You can assume the following. The atmosphere of the planet is so thin that atmospheric resistance can be ignored. The planet is large enough so that its surface can be approximated to be a completely flat plane. The gravity acceleration can be approximated to be constant up to the highest points a bullet can reach. These mean that the bullets fly along a perfect parabolic trajectory. You can also assume the following. The surface of the planet and the bullets are made so hard that bounces can be approximated as elastic collisions. In other words, loss of kinetic energy on bounces can be ignored. As we can also ignore the atmospheric resistance, the velocity of a bullet immediately after a bounce is equal to the velocity immediately after its launch. The bullets are made compact enough to ignore their sizes. The launcher is also built compact enough to ignore its height. You, a programming genius, may not be an expert in physics. Let us review basics of rigid-body dynamics. We will describe here the velocity of the bullet $v$ with its horizontal and vertical components $v_x$ and $v_y$ (positive meaning upward). The initial velocity has the components $v_{ix}$ and $v_{iy}$, that is, immediately after the launch of the bullet, $v_x = v_ix$ and $v_y = v_iy$ hold. We denote the horizontal distance of the bullet from the launcher as $x$ and its altitude as $y$ at time $t$. The horizontal velocity component of the bullet is kept constant during its flight when atmospheric resistance is ignored. Thus the horizontal distance from the launcher is proportional to the time elapsed. x=v_{ix}t \tag{1} The vertical velocity component vy is gradually decelerated by the gravity. With the gravity acceleration of g, the following differential equation holds during the flight. \frac{d{v_y}}{dt}=-g \tag{2}Solving this with the initial conditions of vy = viy and y = 0 when t = 0, we obtain the following. \begin{eqnarray} y&=&-\frac{1}{2}gt^2+v_{iy}t \tag{3} \\ &=&-(\frac{1}{2}gt-v_{iy})t \tag{4} \end{eqnarray}The equation (4) tells that the bullet reaches the ground again when $t = \frac{2v_{iy}}{g}$. Thus, the distance of the point of the bounce from the launcher is $\frac{2v_{ix}v_{iy}}{g}$. In other words, to make the bullet fly the distance of l, the two components of the initial velocity should satisfy $2v_{ix}v_{iy}= lg$. Eliminating the parameter t from the simultaneous equations above, we obtain the following equation that escribes the parabolic trajectory of the bullet. y=-(\frac{g}{2v_{ix}^2})x^2+(\frac{v_{iy}}{v_{ix}})x \tag{5}For ease of computation, a special unit system is used in this project, according to which the gravity acceleration g of the planet is exactly 1.0. InputThe input consists of several tests case with the following format. d\ n\ b \\ p_1\ h_1 \\ p_2\ h_2 \\ \vdots \\ p_n\ h_n \\For each test, the first line contains three integers, $d$, $n$, and $b$. Here, $d$ is the distance from the launcher to the target spot $(1 ≤ d ≤ 10000)$, $n$ is the number of obstacles $(1 ≤ n ≤ 10)$, and $b$ is the maximum number of bounces allowed, not including the bounce at the target spot $(0 ≤ b ≤ 15)$. Each of the following $n$ lines has two integers. In the k-th line, $pk$ is the position of the k-th obstacle, its distance from the launcher, and hk is its height from the ground level. You can assume that 0 &lt; p1, pk &lt; pk + 1 for $k = 1,\cdots, n − 1$, and $pn &lt; d$. You can also assume that $1 ≤ hk ≤ 10000$ for $k = 1,\cdots, n$. OutputOutput the smallest possible initial speed vi that makes the bullet reach the target. The initial speed vi of the bullet is defined as follows. v_i=\sqrt{v_{ix}^2+v_{iy}^2}The output should not contain an error greater than 0.0001. Sample Input100 1 0 50 100 10 1 0 4 2 100 4 3 20 10 30 10 40 10 50 10 343 3 2 56 42 190 27 286 34 Sample Output14.57738 3.16228 7.78175 11.08710 HintSourceAsia Regional Contest, Tokyo, 2014 题目大意一道物理题，给定终点和起点的距离$d$，以及$n$个距离起点坐标不同的障碍物（板子）。一颗子弹从起点做抛物线运动，可以撞击地面再弹起$b$次（忽略能量损失），求可以越过障碍物恰好达到终点的初始速度值大小的最小值。 解题思路 模拟+贪心（不知道可不可以叫贪心） 转化一下，由于撞击地面弹起能量无损失。所以可以将撞击前后的两段转化为一段。对每个可能的距离更新最小值。 d_i=\frac{d}{i} (i=1,2,3 \cdots b-1) 对于每个$d_i$，先行判断45度（即$v_y=v_x$时）是否满足条件，若满足直接更新最小值。若不满足则根据轨迹方程不断更新直至能越过最高点。 解题代码123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657#include &lt;cstdio&gt;#include &lt;cmath&gt;#include &lt;cstring&gt;#include &lt;string&gt;#define INF 0x3f3f3f3f#define EPS 1e-8using namespace std;int n,b;double d,dis,vx,vy;//障碍物struct obstacles&#123; double h,x; &#125;ob[20];double x[20]; void cal(double x,double h)&#123; vx=sqrt((dis*x/2.0-x*x/2.0)/h); vy=dis/2.0/vx;&#125;int judge()&#123; //判断是否可以跨过所有障碍物 for (int i = 0; i &lt; n; i++)&#123; double h = vy*x[i] / vx - 0.5*x[i]*x[i] / (vx*vx); if (ob[i].h-h &gt;= EPS) return 0; &#125; return 1;&#125;double solve(int cnt)&#123; dis = d/cnt; //划分段 for(int i=0;i&lt;n;i++) x[i]=fmod(ob[i].x,dis); //浮点数取模 vy=vx=sqrt(dis/2); //先检测vy=vx时候 if(judge()) return vx*sqrt(2.0); double ans=INF; for(int i=0;i&lt;n;i++)&#123; cal(x[i],ob[i].h); //根据x[i],ob[i]初的障碍物更新vx vy的值。 if(judge()) ans=min(ans,sqrt(vx*vx+vy*vy)); &#125; return ans; &#125;int main()&#123; while(~scanf("%lf %d %d", &amp;d, &amp;n, &amp;b)) &#123; memset(ob,0,sizeof(ob)); memset(x,0,sizeof(x)); for (int i = 0; i &lt; n; i++) scanf ("%lf %lf", &amp;ob[i].x, &amp;ob[i].h); double ans = INF; for (int i = 1; i &lt;= b+1; i++) ans = min(ans, solve(i)); printf ("%.8f\n", ans); &#125;&#125; 收获与反思 从简单开始考虑，无障碍物的时候45度最远 将多段跳跃等效为一段。 浮点数取模函数 fmod 函数计算 x 除以 y 的 f 浮点余数，这样 x = i*y + f，其中 i 是整数，f 和 x 有相同的符号，而且 f 的绝对值小于 y 的绝对值。 1234result=fmod(x,y);printf("10.0%%-3.0= %f/n",result); //1.0result=fmod(y,x);printf("-3.0%%10.0= %f/n",result); //-3.0]]></content>
      <categories>
        <category>编程</category>
        <category>ACM</category>
      </categories>
      <tags>
        <tag>ACM</tag>
        <tag>算法</tag>
        <tag>CSU</tag>
        <tag>Imitation</tag>
        <tag>2018暑假集训</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[【HDU-6301】解题报告（贪心，预处理）]]></title>
    <url>%2Fpost%2Fc293d2b3.html</url>
    <content type="text"><![CDATA[原始题目Distinct Values Time Limit: 4000/2000 MS (Java/Others) Memory Limit: 32768/32768 K (Java/Others) Total Submission(s): 3168 Accepted Submission(s): 1017 Problem DescriptionChiaki has an array of $n$ positive integers. You are told some facts about the array: for every two elements $a_i$ and $a_j$ in the subarray $a_{l \cdots r} (l≤i&lt;j≤r)$, $a_i≠a_j$ holds. Chiaki would like to find a lexicographically minimal array which meets the facts. InputThere are multiple test cases. The first line of input contains an integer $T$, indicating the number of test cases. For each test case: The first line contains two integers $n$ and $m (1≤n,m≤105)$ — the length of the array and the number of facts. Each of the next $m$ lines contains two integers $l_i$ and $r_i$ $(1≤li≤ri≤n)$. It is guaranteed that neither the sum of all $n$ nor the sum of all $m$ exceeds 106. OutputFor each test case, output $n$ integers denoting the lexicographically minimal array. Integers should be separated by a single space, and no extra spaces are allowed at the end of lines. Sample Input3 2 1 1 2 4 2 1 2 3 4 5 2 1 3 2 4 Sample Output1 2 1 2 1 2 1 2 3 1 1 Source2018 Multi-University Training Contest 1 Recommendliuyiding 题目大意对于一个数列，已知其m个子区间，每个子区间内数列的项两两不同，求复合条件的字典序最小的数列。 解题思路 要求字典序最小，算法就是从前贪心的让每一位都是当前可使用数的最小值（从1开始）。 那么如何处理出第i位可用数字的最小值？ 预处理出$pre[i]$（包含第i位线段的最小左端点，即与第i位不相同的最早位置） 用set维护当前可使用的数，$pt$指向当前可用最小数的位置， 求每一位的$ans[i]$时，先检查，当$pt&lt;pre[i]$时，说明$pt$到$pre[i]$位置间使用过的数可以再次使用，所以开始向set容器里补充$pt$位置的数，直至$pt=pre[i]$，再取set容器中的最小值付给$ans[i]$ 如何与处理出$pre[i]$（见下图） 解题代码123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657#include &lt;bits/stdc++.h&gt;using namespace std;#define rep(i,a,n) for (int i=a;i&lt;n;i++)#define per(i,a,n) for (int i=n-1;i&gt;=a;i--)#define pb push_back#define mp make_pair#define np next_permutation#define all(x) x.begin(),x.end()#define fi first#define se second#define SZ(x) ((int)(x).size()) typedef vector&lt;int&gt; vi;typedef long long ll;typedef pair&lt;int,int&gt; pii;const int mod=1e9+7;const int maxn=2e5+5;set &lt;int&gt; s;int pre[maxn],n,m,ans[maxn]; //预处理出不可相同的区间前端点。 int main()&#123; int t; scanf("%d",&amp;t); while(t--)&#123; s.clear(); scanf("%d%d",&amp;n,&amp;m); rep(i,1,n+1)&#123; pre[i]=i; //没有限制条件，前端点都是自身 s.insert(i); &#125; rep(i,1,m+1)&#123; int l,r; scanf("%d%d",&amp;l,&amp;r); pre[r]=min(l,pre[r]); //有可能多个区间右端点相同。 //易错写成 pre[r]=l;忘记更新 &#125; per(i,1,n) pre[i]=min(pre[i],pre[i+1]); //易错写成n+1 //处理完毕 //初始set均可用 int pt=1; //pt记录当前不可用线段开头 rep(i,1,n+1)&#123; //开头更替，则往set里补充可用最小值 // cout&lt;&lt;"pt="&lt;&lt;pt&lt;&lt;" pre[i]="&lt;&lt;pre[i]&lt;&lt;endl; while(pt&lt;pre[i])&#123; s.insert(ans[pt++]); &#125; ans[i]=*s.begin(); s.erase(*s.begin()); &#125; rep(i,1,n+1)&#123; if(i==1) printf("%d",ans[i]); else printf(" %d",ans[i]); &#125; printf("\n"); &#125;&#125; 收获与反思 预处理出线段的左端点。 贪心的考虑每一位的最小值。]]></content>
      <categories>
        <category>编程</category>
        <category>ACM</category>
      </categories>
      <tags>
        <tag>ACM</tag>
        <tag>算法</tag>
        <tag>2018暑假集训</tag>
        <tag>Greedy</tag>
        <tag>HDU</tag>
        <tag>2018HDU多校</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[【HDU-6300】解题报告（简单几何贪心）]]></title>
    <url>%2Fpost%2F7fe193be.html</url>
    <content type="text"><![CDATA[原始题目Triangle Partition Time Limit: 2000/1000 MS (Java/Others) Memory Limit: 132768/132768 K (Java/Others) Total Submission(s): 1054 Accepted Submission(s): 533 Special Judge Problem DescriptionChiaki has $3n$ points $p_1,p_2,…,p_{3n}$. It is guaranteed that no three points are collinear. Chiaki would like to construct $n$ disjoint triangles where each vertex comes from the $3n$ points. InputThere are multiple test cases. The first line of input contains an integer $T$, indicating the number of test cases. For each test case: The first line contains an integer $n (1≤n≤1000)$ — the number of triangle to construct. Each of the next 3n lines contains two integers $x_i$ and $y_i (−109≤x_i,y_i≤109)$. It is guaranteed that the sum of all $n$ does not exceed 10000. OutputFor each test case, output $n$ lines contain three integers $a_i,b_i,c_i (1≤a_i,b_i,c_i≤3n)$ each denoting the indices of points the i-th triangle use. If there are multiple solutions, you can output any of them. Sample Input1 1 1 2 2 3 3 5 Sample Output1 2 3 Source2018 Multi-University Training Contest 1 Recommendliuyiding 题目大意给出$3n$个点，且任意三点军部贡献，要求按顺序给出$n$个三角形的三个顶点坐标，要求$n$个三角形两两不相交（不共点）。 解题思路反向理解 若两条线相交（如下图） 假设我们连三角形时先连A线再连，B线，若出现A2&gt;B1，则有可能会出现两线相交。 考虑到题目给出任意三点不共线，即人以三点都可以构成一个三角形。我们只要找到一种方法逐个连接出不相交的三角形就行。 按x轴将所有点排序，从小到大每次找三个点即可。 解题代码12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152#include &lt;bits/stdc++.h&gt;using namespace std;#define rep(i,a,n) for (int i=a;i&lt;n;i++)#define per(i,a,n) for (int i=n-1;i&gt;=a;i--)#define pb push_back#define mp make_pair#define np next_permutation#define all(x) x.begin(),x.end()#define fi first#define se second#define SZ(x) ((int)(x).size()) typedef vector&lt;int&gt; vi;typedef long long ll;typedef pair&lt;int,int&gt; pii;const int mod=1e9+7;const int maxn=1e4+5;struct node&#123; int index; pii point;&#125;a[maxn];ll t,n,m;bool cmp(node a, node b)&#123; if(a.point.first==b.point.first) return a.point.second&lt;b.point.second; else return a.point.first&lt;b.point.first;&#125;int main()&#123; ios::sync_with_stdio(false); cin&gt;&gt;t; while(t--)&#123; cin&gt;&gt;n; rep(i,1,3*n+1)&#123; a[i].index=i; cin&gt;&gt;a[i].point.first&gt;&gt;a[i].point.second; &#125; sort(a+1,a+1+3*n,cmp);// rep(i,1,3*n+1)&#123;// cout&lt;&lt;a[i].point.fi&lt;&lt;" "&lt;&lt;a[i].point.se&lt;&lt;endl;// &#125; rep(i,1,3*n+1)&#123; if(i==1) cout&lt;&lt;a[i].index; else cout&lt;&lt;" "&lt;&lt;a[i].index; &#125; cout&lt;&lt;endl; &#125; &#125; 收获与反思 简单的几何贪心，考虑两线相交的条件拓展即可。]]></content>
      <categories>
        <category>编程</category>
        <category>ACM</category>
      </categories>
      <tags>
        <tag>ACM</tag>
        <tag>算法</tag>
        <tag>2018暑假集训</tag>
        <tag>Greedy</tag>
        <tag>HDU</tag>
        <tag>2018HDU多校</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[【HDU-6298】解题报告（数论，整除）]]></title>
    <url>%2Fpost%2F60850415.html</url>
    <content type="text"><![CDATA[原始题目Maximum Multiple Time Limit: 4000/2000 MS (Java/Others) Memory Limit: 32768/32768 K (Java/Others) Total Submission(s): 1503 Accepted Submission(s): 653 Problem DescriptionGiven an integer $n$, Chiaki would like to find three positive integers $x$, $y$ and $z$ such that: $n=x+y+z$, $x∣n$, $y∣n$, $z∣n$ and $xyz$ is maximum. InputThere are multiple test cases. The first line of input contains an integer $T (1≤T≤106)$, indicating the number of test cases. For each test case:The first line contains an integer $n (1≤n≤106)$. OutputFor each test case, output an integer denoting the maximum xyz. If there no such integers, output −1 instead. Sample Input3 1 2 3 Sample Output-1 -1 1 Source 2018 Multi-University Training Contest 1 Recommend liuyiding 题目大意已知三个数的和为$n$，且三个数均能整除$n$，求三个数乘积的最大值。 解题思路数论问题 不妨设$a=\frac{n}{x},b=\frac{n}{y},c=\frac{n}{z}$。由题目条件可以得到 \frac{1}{a}+\frac{1}{b}+\frac{1}{c}=1由于$a,b,c$均为整数（正整数）。所以该方程共有三组解。分别为$a=3,b=3,c=3,xyz=\frac{n^3}{27}$或者$a=2,b=4,c=4,xyz=\frac{n^3}{32}$或者$a=2,b=3,c=6,xyz=\frac{n^3}{36}$ 故判断$n|3,n|4$整除即可。又因为若第三组解成立，则必有第三组解，而且第一组解对应的$xyz$值更大，故不考虑第三组。 解题代码1234567891011121314151617181920212223242526272829303132#include &lt;bits/stdc++.h&gt;using namespace std;#define rep(i,a,n) for (int i=a;i&lt;n;i++)#define per(i,a,n) for (int i=n-1;i&gt;=a;i--)#define pb push_back#define mp make_pair#define np next_permutation#define all(x) x.begin(),x.end()#define fi first#define se second#define SZ(x) ((int)(x).size()) typedef vector&lt;int&gt; vi;typedef long long ll;typedef pair&lt;int,int&gt; pii;const int mod=1e9+7;const int maxn=1e5+5;ll t,n,m;int main()&#123; ios::sync_with_stdio(false); cin&gt;&gt;t; while(t--)&#123; cin&gt;&gt;n; if(!(n%3)) cout&lt;&lt;1ll*n*n*n/27&lt;&lt;endl; else if(!(n%4)) cout&lt;&lt;1ll*n*n*n/32&lt;&lt;endl; else cout&lt;&lt;"-1"&lt;&lt;endl; &#125; &#125; 收获与反思 寻找条件的关系 数论学习]]></content>
      <categories>
        <category>编程</category>
        <category>ACM</category>
      </categories>
      <tags>
        <tag>ACM</tag>
        <tag>算法</tag>
        <tag>2018暑假集训</tag>
        <tag>数论</tag>
        <tag>HDU</tag>
        <tag>2018HDU多校</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[【HDU-6165】解题报告（BFS，搜索优化）]]></title>
    <url>%2Fpost%2F76485a7.html</url>
    <content type="text"><![CDATA[原始题目FFF at Valentine Time Limit: 6000/3000 MS (Java/Others) Memory Limit: 65536/65536 K (Java/Others) Total Submission(s): 1703 Accepted Submission(s): 722 Problem Description At Valentine’s eve, Shylock and Lucar were enjoying their time as any other couples. Suddenly, LSH, Boss of FFF Group caught both of them, and locked them into two separate cells of the jail randomly. But as the saying goes: There is always a way out , the lovers made a bet with LSH: if either of them can reach the cell of the other one, then LSH has to let them go. The jail is formed of several cells and each cell has some special portals connect to a specific cell. One can be transported to the connected cell by the portal, but be transported back is impossible. There will not be a portal connecting a cell and itself, and since the cost of a portal is pretty expensive, LSH would not tolerate the fact that two portals connect exactly the same two cells. As an enthusiastic person of the FFF group, YOU are quit curious about whether the lovers can survive or not. So you get a map of the jail and decide to figure it out. Input Input starts with an integer $T (T≤120)$, denoting the number of test cases. For each case, First line is two number $n$ and $m$, the total number of cells and portals in the jail.$(2≤n≤1000,m≤6000)$ Then next $m$ lines each contains two integer $u$ and $v$, which indicates a portal from $u$ to $v$. OutputIf the couple can survive, print “I love you my love and our love save us!” Otherwise, print “Light my fire!” Sample Input3 5 5 1 2 2 3 2 4 3 5 4 5 3 3 1 2 2 3 3 1 5 5 1 2 2 3 3 1 3 4 4 5 Sample OutputLight my fire! I love you my love and our love save us! I love you my love and our love save us! Source2017 Multi-University Training Contest - Team 9 Recommendliuyiding 题目大意给定一个有向图，问任意两点之间是否连通 解题思路暂时没有其他（正常）想法，SHL写了一个暴力BFS+优化，拿来学习一下。 解题代码12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061#include&lt;bits/stdc++.h&gt;using namespace std;vector&lt;int&gt; v[1010];int Flag[1010][1010],vis[1010];int ans;void bfs(int st)&#123; queue&lt;int&gt; q; while(!q.empty()) q.pop(); q.push(st); memset(vis,0,sizeof vis); vis[st] = 1; while(!q.empty()) &#123; int u = q.front();q.pop(); for(int i = 0; i &lt; v[u].size(); i++) &#123; if(vis[v[u][i]] == 0) &#123; vis[v[u][i]] = 1; q.push(v[u][i]); if(Flag[st][v[u][i]] == 0) &#123; Flag[st][v[u][i]] = Flag[v[u][i]][st] = 1; ans++; &#125; &#125; &#125; &#125;&#125;void Init()&#123; for(int i=0;i&lt;1010;i++) v[i].clear(); memset(Flag,0,sizeof Flag); ans=0;&#125;int main()&#123; int T,n,m;cin&gt;&gt;T; while(T--) &#123; Init(); scanf("%d%d",&amp;n,&amp;m); while(m--) &#123; int x,y; scanf("%d%d",&amp;x,&amp;y); v[x].push_back(y); &#125; for(int i = 1; i &lt;= n; i++) bfs(i); if(ans == n*(n-1)/2) printf("I love you my love and our love save us!\n"); else printf("Light my fire!\n"); &#125; return 0;&#125; 收获与反思待补充]]></content>
      <categories>
        <category>编程</category>
        <category>ACM</category>
      </categories>
      <tags>
        <tag>ACM</tag>
        <tag>算法</tag>
        <tag>2018暑假集训</tag>
        <tag>BFS</tag>
        <tag>HDU</tag>
        <tag>2017HDU多校</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[【HDU-6168】解题报告（数学，规律，分组）]]></title>
    <url>%2Fpost%2Fd9083bc4.html</url>
    <content type="text"><![CDATA[原始题目Numbers Time Limit: 4000/2000 MS (Java/Others) Memory Limit: 131072/131072 K (Java/Others) Total Submission(s): 1466 Accepted Submission(s): 692 Problem Descriptionzk has n numbers a1,a2,…,an. For each (i,j) satisfying 1≤i&lt;j≤n, zk generates a new number (ai+aj). These new numbers could make up a new sequence b1，b2,…,bn(n−1)/2. LsF wants to make some trouble. While zk is sleeping, Lsf mixed up sequence a and b with random order so that zk can’t figure out which numbers were in a or b. “I’m angry!”, says zk. Can you help zk find out which n numbers were originally in a? Input Multiple test cases(not exceed 10). For each test case: ∙The first line is an integer m(0≤m≤125250), indicating the total length of a and b. It’s guaranteed m can be formed as n(n+1)/2. ∙The second line contains m numbers, indicating the mixed sequence of a and b. Each ai is in [1,10^9] Output For each test case, output two lines. The first line is an integer n, indicating the length of sequence a; The second line should contain n space-seprated integers a1,a2,…,an(a1≤a2≤…≤an). These are numbers in sequence a. It’s guaranteed that there is only one solution for each case. Sample Input6 2 2 2 4 4 4 21 1 2 3 3 4 4 5 5 5 6 6 6 7 7 7 8 8 9 9 10 11 Sample Output3 2 2 2 6 1 2 3 4 5 6 Source 2017 Multi-University Training Contest - Team 9 Recommend liuyiding 题目大意已知一个数列由a，b两个数列构成，b数列中的每一项都是a数列中某两项的和，求原数列a 解题思路首先可以确定的几点是 数列$a$有$n$项，则数列$b$有$\frac{n(n-1)}{2}$项，则给定的$c$数列有$\frac{n(n+1)}{2}$项， 由于$a$中任意一项均&gt;=1（即，$a$为正数数列），所以$c$中的最小项极为$a$中的最小项。 也可以推得，$c$中第二小项也为$a$中第二小项。 再往后推 $c$项中第三小的可能是$a$中第三小的项，也可能是b项中第一小的项（即${a_1}+{a_2}$)。 由于$c$由$a$和$b$全部项构成，所以${b_1}={a_1}+{a_2}$必然在$c$中。 由此我们想到筛数的方法。 $c$中去掉${a_1}+{a_2}$的一项后剩下的最小项必然为$a_3$。 再从$c$中去掉${a_1}+{a_3}$，${a_2}+{a_3}$，剩下的最小项必然为$a_4$。 解题代码123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657#include &lt;cstdio&gt;#include &lt;cstring&gt;#include &lt;string&gt;#include &lt;iostream&gt;#include &lt;set&gt;#include &lt;algorithm&gt;#include &lt;iomanip&gt;#include &lt;vector&gt;#include &lt;map&gt;#include &lt;queue&gt;using namespace std;const int maxn=1e5+5;int n,m;vector &lt;int&gt; a,b,c,ans;map &lt;int,int&gt; num;int main()&#123; while(~scanf("%d",&amp;n))&#123; a.clear(); b.clear(); c.clear(); ans.clear(); num.clear(); int temp; for(int i=0;i&lt;n;i++)&#123; scanf("%d",&amp;temp); a.push_back(temp); if(num[temp]==0) num[temp]=1; else num[temp]++; //记录次数 &#125; sort(a.begin(),a.end()); ans.push_back(a[0]); //初始装进一个最小a1 num[a[0]]--; for(int i=1;i&lt;n;i++)&#123; if(!num[a[i]]) continue; for(int j=0;j&lt;ans.size();j++)&#123; num[a[i]+ans[j]]--; &#125; ans.push_back(a[i]); num[a[i]]--; &#125; printf("%d\n",ans.size()); vector &lt;int&gt; ::iterator it; for(it=ans.begin();it!=ans.end();it++)&#123; if(it==ans.begin()) cout&lt;&lt;*it; else cout&lt;&lt;" "&lt;&lt;*it; &#125; cout&lt;&lt;endl; &#125;&#125; 收获与反思 有序数列的构成注意寻找规律。 分组后更新数列状态。]]></content>
      <categories>
        <category>编程</category>
        <category>ACM</category>
      </categories>
      <tags>
        <tag>ACM</tag>
        <tag>算法</tag>
        <tag>2018暑假集训</tag>
        <tag>HDU</tag>
        <tag>2017HDU多校</tag>
        <tag>规律</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[【HDU-6170】解题报告（字符串，正则匹配，dp）]]></title>
    <url>%2Fpost%2F1eeab2ee.html</url>
    <content type="text"><![CDATA[原始题目Two strings Time Limit: 2000/1000 MS (Java/Others) Memory Limit: 65536/65536 K (Java/Others) Total Submission(s): 2511 Accepted Submission(s): 891 Problem DescriptionGiving two strings and you should judge if they are matched. The first string contains lowercase letters and uppercase letters. The second string contains lowercase letters, uppercase letters, and special symbols: “.” and “*”.. can match any letter, and * means the front character can appear any times. For example, “a.b” can match “acb” or “abb”, “a” can match “a”, “aa” and even empty string. ( “\” will not appear in the front of the string, and there will not be two consecutive “*”. InputThe first line contains an integer T implying the number of test cases. (T≤15)For each test case, there are two lines implying the two strings (The length of the two strings is less than 2500). OutputFor each test case, print “yes” if the two strings are matched, otherwise print “no”. Sample Input3 aa a* abb a.* abb aab Sample Outputyes yes no Source2017 Multi-University Training Contest - Team 9 Recommendliuyiding 题目大意给定 $a$，$b$ 两个字符串。$a$字符串只由字母构成，$b$字符串由字母和”.“，”*“两种符号组合成。有如下规则。 “符号可以匹配任意一个字母。 “*“符号可以匹配0个或多个上一字母，且不会出现在开头。判断$a$，$b$两字符串能否匹配。 解题思路改变了”*“规则的正则匹配。可以用C++正则匹配的库做，也可以使用dp做。 dp思路：bool型dp二维数组，$dp[i][j]$表示$a$字符串第i位和$b$字符串第j位能否匹配。 状态转移方程： 当$b_j$为”.“时，$dp[i][j]=dp[i-1][j-1]$。 当$b_j$为字母时，若$a_i=b_j$，则$dp[i][j]=dp[i-1][j-1]$。否则$dp[i][j]=0$。 当$b_j$为”*“时，根据”*“的规则。上一个字母出现次数为$n$。 当$n=0$时，匹配为上一个字母没有出现过，可从$dp[i][j-2]$转移过来。 当$n=1$时，匹配为上一个字母出现一次，可从$dp[i][j-1]$转移过来。 当$n=2$时，匹配为上一个字母出现两次，故若$a_i=a_{i-1}$时，可从$dp[i-1][j-1]$转移过来。否则$dp[i][j]=0$。 当$n&gt;2$时，匹配为上一个出现$n$次，若$a_i=a_{i-1}$时，$dp[i-1][j]$转移过来，可以不断回退直到到上一情况。 解题代码 正则匹配法 123456789101112131415161718192021222324252627282930313233343536373839#include &lt;iostream&gt;#include &lt;algorithm&gt;#include &lt;cstdio&gt;#include &lt;cmath&gt;#include &lt;cstring&gt;#include &lt;string&gt;#include &lt;string.h&gt;#include &lt;map&gt;#include &lt;set&gt;#include &lt;queue&gt;#include &lt;deque&gt;#include &lt;list&gt;#include &lt;bitset&gt;#include &lt;stack&gt;#include &lt;stdlib.h&gt;#include &lt;regex&gt;#define lowbit(x) (x&amp;-x)#define e exp(1.0)#define eps 1e-8//ios::sync_with_stdio(false);// auto start = clock();// cout &lt;&lt; (clock() - start) / (double)CLOCKS_PER_SEC;typedef long long ll;using namespace std; int main()&#123; ios::sync_with_stdio(false); int T; cin&gt;&gt;T; while(T--) &#123; string a,b; cin&gt;&gt;a&gt;&gt;b; b=regex_replace(b,regex("\\.\\*"),"(.)\\1*"); regex_match(a,regex(b))?cout&lt;&lt;"yes"&lt;&lt;endl:cout&lt;&lt;"no"&lt;&lt;endl; &#125; return 0;&#125; dp12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061#include &lt;bits/stdc++.h&gt;using namespace std;#define rep(i,a,n) for (int i=a;i&lt;n;i++)#define per(i,a,n) for (int i=n-1;i&gt;=a;i--)#define pb push_back#define mp make_pair#define np next_permutation#define all(x) x.begin(),x.end()#define fi first#define se second#define INF Ox3f3f3f3f#define SZ(x) ((int)(x).size()) //ios::sync_with_stdio(false);// auto start = clock();// cout &lt;&lt; (clock() - start) / (double)CLOCKS_PER_SEC;const int maxn=2510;char a[maxn],b[maxn];bool dp[maxn][maxn];int n,m;int main()&#123; int TT,T=0; scanf("%d",&amp;TT); while(TT--)&#123; scanf("%s",a+1); scanf("%s",b+1); n=strlen(a+1); m=strlen(b+1); memset(dp,0,sizeof(dp)); dp[0][0]=1; if (b[2]=='*') dp[0][2]=1; for(int i=1;i&lt;=n;i++)&#123; for(int j=1;j&lt;=m;j++)&#123; //字母情况 if(b[j]!='.'&amp;&amp;b[j]!='*')&#123; dp[i][j]=(a[i]==b[j]?dp[i-1][j-1]:0); &#125; else if(b[j]=='.')&#123; dp[i][j]=dp[i-1][j-1]; &#125; else if(b[j]=='*')&#123; dp[i][j]=dp[i][j-1]|dp[i][j-2]; if(a[i]==a[i-1]&amp;&amp;!dp[i][j]) dp[i][j]=dp[i-1][j-1]|dp[i-1][j]; //注意此处!dp[i][j] 否则会将状态由1更新为0，诸如 bb bba*就会出错 &#125; &#125; &#125; if(dp[n][m]) printf("yes\n"); else printf("no\n"); &#125; return 0;&#125;//1//bb//bba* 收获与反思 C++正则匹配regex库，涨姿势。 字符串dp，状态转移的思考需要学习一下。]]></content>
      <categories>
        <category>编程</category>
        <category>ACM</category>
      </categories>
      <tags>
        <tag>ACM</tag>
        <tag>算法</tag>
        <tag>DP</tag>
        <tag>2018暑假集训</tag>
        <tag>HDU</tag>
        <tag>2017HDU多校</tag>
        <tag>正则匹配</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[【CSU-1005】解题报告（数据结构，树入门，2018暑选入门B题）]]></title>
    <url>%2Fpost%2F19e79191.html</url>
    <content type="text"><![CDATA[原始题目1005: Binary Search Tree analogTime Limit: 1 SecMemory Limit: 128 MbSubmitted: 1630Solved: 473 DescriptionBinary Search Tree, abbreviated as BST, is a kind of binary tree maintains the following property: Each node has a Key value, which can be used to compare with each other. For every node in the tree, every Key value in its left subtree is smaller than its own Key value. For every node in the tree, every Key value in its right subtree is equal to or larger than its own Key value. Now we need to analog a BST, we only require one kind of operation: inserting. First, we have an empty BST. Input is a sequence of numbers. We need to insert them one by one flowing the rules below: If the inserted value is smaller than the root’s value, insert it to the left subtree. If the inserted value is larger than or equal to the value of the root’s value, insert it to the right subtree. After each input, we need to output the preorder, inorder, postorder traversal sequences. About tree traversal, the following is from Wikipedia: Depth-first TraversalTo traverse a non-empty binary tree in preorder, perform the following operations recursively at each node, starting with the root node: Visit the root. Traverse the left subtree. Traverse the right subtree. To traverse a non-empty binary tree in inorder (symmetric), perform the following operations recursively at each node: Traverse the left subtree. Visit the root. Traverse the right subtree. To traverse a non-empty binary tree in postorder, perform the following operations recursively at each node: Traverse the left subtree. Traverse the right subtree. Visit the root. Look at the folowing example: Intput is a sequence of 5 integers: 3 6 9 5 1 After each integer inserted the structure of the tree is illustrated in the flowing: 3 / \ 1 6 / \ 5 9 InputThe first integer of the input is T, the number of test cases. Each test case has two lines. The first line contain an integer N,(1≤N≤1000), the number of numbers need to be inserted into the BST. The second line contain N integers separated by space, each integer is in the range of [0,230]. OutputEach test case, output must contain three lines: the preorder, inorder and postorder traversal sequence. The numbers in each line should be separated by a single space and you should not output anything at the end of the line! Output a blank line after each case. Sample Input1 5 3 6 9 5 1 Sample Output3 1 6 5 9 1 3 5 6 9 1 5 9 6 3 HintSource中南大学第五届大学生程序设计竞赛-热身赛 题目大意构建二叉搜索树，然后将树按前序，中序，后序输出。 解题思路构建二叉树，写函数三种序输出即可。树入门题。 解题代码123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990#include &lt;cstdio&gt;#include &lt;cstring&gt;#include &lt;iostream&gt;#include &lt;set&gt;#include &lt;queue&gt;#include &lt;map&gt;#include &lt;algorithm&gt;using namespace std;typedef long long ll;const int maxn=1e5+5;struct node&#123; int x; struct node *left,*right;&#125;list[maxn];int t,i,n,x,flag1=1;struct node root,*p;void Insert(struct node *r,struct node *p)&#123; if(!r) return; if(r-&gt;x&gt;p-&gt;x) &#123; if(r-&gt;left) Insert(r-&gt;left,p); else r-&gt;left=p; &#125; else &#123; if(r-&gt;right) Insert(r-&gt;right,p); else r-&gt;right=p; &#125;&#125;void pretral(struct node *p)&#123; if(!p) return; if(flag1) printf("%d",p-&gt;x),flag1=0; else printf(" %d",p-&gt;x); pretral(p-&gt;left); pretral(p-&gt;right);&#125;void intral(struct node *p)&#123; if(!p) return; intral(p-&gt;left); if(flag1) printf("%d",p-&gt;x),flag1=0; else printf(" %d",p-&gt;x); intral(p-&gt;right);&#125;void postod(struct node *p)&#123; if(!p) return; postod(p-&gt;left); postod(p-&gt;right); if(flag1) printf("%d",p-&gt;x),flag1=0; else printf(" %d",p-&gt;x);&#125;int main()&#123; scanf("%d",&amp;t); while(t--) &#123; scanf("%d",&amp;n); scanf("%d",&amp;root.x); root.left=root.right=0; for(i=0;i&lt;n-1;i++) &#123; scanf("%d",&amp;x); p=&amp;list[i]; p-&gt;x=x; p-&gt;left=p-&gt;right=0; Insert(&amp;root,p); &#125; flag1=1; pretral(&amp;root); printf("\n"); flag1=1; intral(&amp;root); printf("\n"); flag1=1; postod(&amp;root); printf("\n"); printf("\n"); &#125;&#125; 收获与反思数据结构入门，二叉树熟悉，水题。]]></content>
      <categories>
        <category>编程</category>
        <category>ACM</category>
      </categories>
      <tags>
        <tag>ACM</tag>
        <tag>算法</tag>
        <tag>CSU</tag>
        <tag>数据结构</tag>
        <tag>2018暑期选拔</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[【CSU-1224】解题报告（BFS，水题，2018暑选入门A题）]]></title>
    <url>%2Fpost%2Ffb5efb9c.html</url>
    <content type="text"><![CDATA[原始题目1224: ACM小组的古怪象棋Time Limit: 1 SecMemory Limit: 128 MbSubmitted: 851Solved: 347 DescriptionACM小组的Samsara和Staginner对中国象棋特别感兴趣，尤其对马（可能是因为这个棋子的走法比较多吧）的使用进行深入研究。今天他们又在 构思一个古怪的棋局:假如Samsara只有一个马了，而Staginner又只剩下一个将，两个棋子都在棋盘的一边，马不能出这一半棋盘的范围，另外这 一半棋盘的大小很奇特(n行m列)。Samsara想知道他的马最少需要跳几次才能吃掉Staginner的将(我们假定其不会移动)。当然这个光荣的任 务就落在了会编程的你的身上了。 Input每组数据一行，分别为六个用空格分隔开的正整数$n,m,x1,y1,x2,y2$分别代表棋盘的大小$n,m$以及将的坐标和马的坐标。$(1 \le x1,x2 \le n \le 20 ,1 \le y1,y2 \le m \le 20)$ ，将和马的坐标不相同。 Output输出对应也有若干行，请输出最少的移动步数,如果不能吃掉将则输出“-1”(不包括引号)。 Sample Input8 8 5 1 4 5 Sample Output3 HintSourceCSU Monthly 2011 Dec. 题目大意如题 解题思路马的坐标为单入口BFS，如果搜索不到输出-1. 解题代码1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465666768697071727374757677787980#include &lt;queue&gt;#include &lt;cstdio&gt;#include &lt;cstring&gt;#include &lt;cstdlib&gt;#define maxn 35using namespace std; int n,m,x1,y1,x2,y2;bool vis[maxn][maxn];int dir[8][2]=&#123;&#123;-2,1&#125;,&#123;-2,-1&#125;,&#123;-1,2&#125;,&#123;-1,-2&#125;,&#123;1,2&#125;,&#123;1,-2&#125;,&#123;2,1&#125;,&#123;2,-1&#125;&#125;;struct State // BFS 队列中的状态数据结构&#123; int x,y; int Step_Counter; // 搜索步数统计器&#125;;//State a[maxn];int ans[maxn];bool CheckState(State next) // 约束条件检验&#123; if(next.x&gt;=1&amp;&amp;next.x&lt;=n&amp;&amp;next.y&gt;=1&amp;&amp;next.y&lt;=m&amp;&amp;!vis[next.x][next.y]) // 满足条件 &#123;// printf("next x=%d y=%d\n",next.x,next.y); return 1; &#125; else // 约束条件冲突 return 0;&#125;void bfs(State st)&#123; int flag=0; queue &lt;State&gt; q; // BFS 队列 State now,next; // 定义2个状态，当前和下一个 st.Step_Counter=0; // 计数器清零 q.push(st); // 入队 vis[st.x][st.y]=1; // 访问标记 while(!q.empty()) &#123; now=q.front(); // 取队首元素进行扩展// a[now.i].Step_Counter=++circle; if(now.x==x1&amp;&amp;now.y==y1) &#123; flag=1; printf("%d\n",now.Step_Counter); return ; &#125; for(int i=0;i&lt;8;i++) &#123; next.x=now.x+dir[i][0]; next.y=now.y+dir[i][1]; next.Step_Counter=now.Step_Counter+1; // 计数器加1 if(CheckState(next)) // 如果状态满足约束条件则入队 &#123; q.push(next);// printf("insert x=%d y=%d\n",next.x,next.y); vis[next.x][next.y]=1; //访问标记 &#125; &#125; q.pop(); // 队首元素出队 &#125; printf("-1\n"); return;&#125;int main()&#123; while(~scanf("%d%d%d%d%d%d",&amp;n,&amp;m,&amp;x1,&amp;y1,&amp;x2,&amp;y2)) &#123; memset(vis,0,sizeof(vis)); State start; start.x=x2; start.y=y2; bfs(start); &#125; return 0;&#125; 收获与反思bfs，可以考虑将模板改为bool型。]]></content>
      <categories>
        <category>编程</category>
        <category>ACM</category>
      </categories>
      <tags>
        <tag>ACM</tag>
        <tag>算法</tag>
        <tag>CSU</tag>
        <tag>2018暑期选拔</tag>
        <tag>BFS</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[《解忧杂货店》读书笔记]]></title>
    <url>%2Fpost%2F5555df5.html</url>
    <content type="text"><![CDATA[内容摘录第一章 回答在牛奶箱里 P49 “让深爱的人放弃梦想，这比死还让我痛苦。即使分隔两地，我们的心也会永远在一起。你不要有任何顾虑，我希望你无怨无悔地去追寻梦想。” 第三章 在思域车上等到天亮 P101 “不管是骚扰还是恶作剧，写这些信给浪失杂货店的人，和普通的咨询者再本质上是一样的。他们都是内心破了个洞，重要的东西正从那个破洞逐渐流失。” P106 “这么多年咨询信看下来，让我逐渐明白了一件事。很多时候，咨询的人心里已经有了答案，来咨询只是想确认自己的决定是对的。” P107 “或许雄治留恋的不是杂货店，二十烦恼咨询。他觉得一旦关了店离开这里，就不会有人来找他咨询了。” P175 “人与人之间情断义绝，并不需要什么具体的理由，就算表面上有，也很可能只是心已经离开的结果，事后才编造出的借口而已。因为倘若心没有离开，当将会导致关系破裂的事态发生时，理应有人努力去挽救。如果没有，说明其实关系早已破裂。所以那四个人谁也没有挽救披头士乐队，就像看客一般，眼睁睁看着船只沉没。” Last page “我衷心的祈祷你可以相信你自己，无悔地燃烧自己的人生。”]]></content>
      <categories>
        <category>阅读</category>
      </categories>
      <tags>
        <tag>阅读</tag>
        <tag>小说</tag>
        <tag>文学</tag>
        <tag>解忧杂货店</tag>
        <tag>东野圭吾</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[《如何阅读一本书》读书笔记]]></title>
    <url>%2Fpost%2F3c57c5dc.html</url>
    <content type="text"><![CDATA[内容摘录第一篇 阅读的层次第一章 阅读的活力与艺术 P9 “‘阅读的人’（readers），是指那些今天仍然习惯于从书写文字中汲取大量资讯，以增进对世界了解的人。” P10 “太多的咨询就如童太少的资讯一样，都是一种对理解力的阻碍。换句话说，现代的媒体正以压倒性的泛滥资讯阻碍了我们的理解力。” P11 “听众或读者的‘接收’，应该像是棒球赛中的捕手才对。……我们可以把这个类比的概念往前推。捕手的艺术就在能接住任何球的技巧——快速球、曲线球、变化球、慢速球等等。同样地，阅读的艺术也在尽可能掌握住每一种讯息的技巧。” P18 “蒙田说：‘初学者的无知在于未学’，而学者的无知在于学后。” P19 “倾听是从一位出现在你眼前的老师学习——一位活生生的老师——而阅读却是跟一位缺席的老师学习。如果你问一位活生生的老师一个问题，他可能会回答你。如果你还是不懂他的说的话，你可以再问他问题，省下自己思考的时间。然而如果你问一本书一个问题，你就必须自己回答这个问题。在这样的情况下，这本书就跟自然或世界一样。当你提出问题时，只有等你自己作了思考与分析之后，才会在书本上找到答案。” P22 “我们要懂得如何让书本来教导我们。事实上，这就是这本书最主要的目的。” 第二章 阅读的层次 阅读的四个层次，我们称之为基础阅读，检视阅读，分析阅读，主题阅读，这四个层次是渐进的。 P26 “如果说检视阅读是在涌现的时间内，最好也最完整的阅读，那么分析阅读就是在无限的时间里，最好也最完整的阅读。” P27 “弗兰西斯·培根曾今说过：‘有些书可以浅尝辄止，有些书是要生吞活剥，只有少数的书是要咀嚼与消化的。’分析阅读就是要咀嚼与消化一本书。” P27 “在做主题阅读时，阅读者会越读很多书，而不是一本书，并列举出这些书之间相关之处，提出一个所有的书都谈到的主题。但只是书本里字里行间的比较还不够。主题阅读涉及的远不止此。借助他所阅读的书籍，主题阅读这要能够架构出一个可能在哪一本书里都没提过的主题分析。” 第三章 阅读的第一个层次：基础阅读 P37 “我们的历史一直强调，无限制的受教育机会是一个社会能够提供给人民最有价值的服务——或说得正确一点，只有当一个人的自我期许，能力与需要受限制时，教育机会才会受到限制。我们还没有办法提供这种机会之前，不表示我们就有理由要放弃尝试。” 第四章 阅读的第二个层次：检视阅读 P39 “略读的i管应该用不着花太多时间，下面是要如何去做的一些建议：（1）先看书名页，然后如果有序就先看序。（2）研究目录页。（3）如果书中富有索引，也要检阅一下。（4）不妨读一下出版者的介绍。（5）开始挑几个看起来跟主题息息相关的篇章来看。（6）最后一步，把书打开翻看，有时候连续读几页，但不要太多。” P47 “拍摄下来的眼睛在活动时的影片，显示年轻或未受过训练的阅读者，在阅读一行字的时候会在五六个地方发生‘逗留’（fixate）现象。（眼睛在移动时看不见，只有停下来时才能看见。）因此，他们在读这一行字的时候，只能间隔着看到一个个单字或最多两三个字的组合。更糟的是，这些不熟练的阅读这在看过每两三行后，眼睛就自然地‘倒退’（regress）到原点——也就是说，他们又会倒退到先前读过的句子与那一行去了。所有这些习惯不但浪费而且显然降低了阅读的的速度。之所以说是浪费，因为我们的头脑跟眼睛不一样，并不需要一次只‘读’一个字或一个句子。我们的头脑是个惊人的工具，可以在‘一瞥’之间掌握住一个句子或段落——只要眼睛能提供足够资讯。” P50 “在阅读一本书的时候，慢不该慢到不值得，快不该快到有损于满足与理解。不论怎么说，阅读的速度，不论是快还是慢，只不过是阅读问题一个微笑的部分而已。” P51 “在第一次阅读一本很难得书时，不要企图了解每一个子句。这是最最重要的一个规则。这也是检视阅读的基本概念。不要害怕，或是但又自己似乎读得很肤浅。就算是最难读的书也快快地读一遍。当你再度第二次时，你就已经准备好要读这本书了。” 第五章 如何做一个自我要求的读者 P52 “在阅读的时候想要保持清醒，或昏昏入睡，主要看你的阅读目标是什么。如果你的月度目标是获得利益——不论是心灵或精神上的成长——你就得保持清醒。这也意味着在阅读时要尽可能地保持主动，同时还要做一番努力——而这番努力是会有回馈的。” P53 “关于一本书，你一定要提出四个主要的问题。（1）整体来说，这本书到底在谈些什么？（2）作者细部说了什么，怎么说的？（3）这本书说得有道理吗？是全部有道理。还是部分有道理（4）这本书跟你有什么关系？” P60 “所谓艺术或技巧，只属于哪个能养成习惯，而且能依照规则来运作的人。这也是艺术家或任何领域的工匠与众不同之处。” 第二篇 阅读的第三个层次：分析阅读第六章 一本书的分类 实用性vs.理论性作品，理论——是什么，实用——怎么做。 P74 “实用是与某种有效的做法有关，不管是立即或长程的功效。而理论所关注的却是去明白或了解某件事。” P74 “纯科学于应用科学的区别，或是像通常非常粗糙的那种说法，也就是科学与科技之间的区别。有些书或有些老师，只对他们要传达的知识本身感兴趣。这并不是说他们否定知识的实用性，或是他们坚持只该为知识而知识。他们知识将自己限制在某一种沟通或教学方式中，而让其他人去用别的方式。其他这些人的兴趣则在追求知识本身以外的事上，他们关切的是哪些知识能帮忙解决的人生问题。他们也传递知识，但永远带着一种强调知识的实际应用的观点。” P78 “质疑某件事的有效性是理论，而质疑任何事的目的，却是实用。” P75 “要让知识变成有用，就要有操作的规则。我们一定要超越‘知道这是怎么回事’，进而明白‘如果我想做些什么，应该怎么利用它’。”知与行的区别，而本书就是一本告诉我们该怎么做的实用的书。 P81 “如果一本理论的书所强调的内容，超乎你日常、理性、正常生活的经验，那就是科学的书。否则就是一本哲学的书。” 第七章 透视一本书 P85 “对于‘整体内容’这件事，光是一个模糊的认知是不够的，你必须要确切清楚地了解才行。只有一个方法能知道你是否成功了。你必须能用几句话，告诉你自己，或别人，这整本书在说的是什么。（如果你要说的话太多，表示你还没有将整体的内容看清楚，而只是看到了多样的内容。）” P106 “分析阅读的第一阶段，或，找出一本书在谈些什么的四个规则：（1）依照书本的种类与主题作分类。（2）用最简短的句子说出整本书在谈些什么。（3）按照顺序与关系，列出全书的重要部分。将全书的纲要拟出来之后，再将各个部分的纲要也一一列出。（4）找出作者在问的问题，或作者想要解决的问题。” 第八章 与作者找出共通的词义 P116 “就积极面来说，只要熟悉一下哪个领域，你就能找出这些专门的单字；就消极面来说，你只要看到不是平常惯见的单字，就会知道那些字一定是专门用语。” P116 “另外一个线索是，作者与其他作者争执的某个用语就是重要的字。” P119 “你一定要利用上下文自己已经了解的所有字句，来推敲出你所不了解的那个字的意义。” P132 “第五个规则：找出关键字，与作者达成共识。第六个规则可以说是：将一本书中最重要的句子圈起来，找出其中的主旨。第七个规则是：从相关文句的关联中，设法架构出一本书的基本论述。” P133 “从一个赌这的观点来看，对你重要的句子就是一些需要花一点努力来诠释的句子，因为你第一眼看到这些句子时并不能完全理解…….最重要的句子就是在整个论述中，阐述作者判断的部分。” 未完待续 中间换了一个版本，所以页码乱掉了]]></content>
      <categories>
        <category>阅读</category>
      </categories>
      <tags>
        <tag>阅读</tag>
        <tag>社科</tag>
        <tag>如何阅读一本书</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[C++运算符重载与无名对象引用问题的一点思考]]></title>
    <url>%2Fpost%2Fab4ed95b.html</url>
    <content type="text"><![CDATA[问题的发现今天复习C++运算符重载时候的意外发现：关于类的临时对象以及引用的一些思考。来源于C++程序设计（小红书）上给出了“+”号运算符重载的样例。 基本知识回顾重载运算符的习惯 C++规定，赋值运算符=、下标运算符[]、函数调用运算符()、成员运算符-&gt;必须作为成员函数。 流插入运算符&lt;&lt; 和流提取运算符 &gt;&gt;、类型转换运算符不能定义为类的成员函数，只能作为友元函数。 一般将单目运算符和复合运算符重载为成员函数 一般将双目运算符重载为友元函数。NextSo 根据上述的习惯，我对着屏幕敲了书上的样例的类定义的代码。 1234567891011121314151617181920212223242526272829303132333435363738394041424344class Complex&#123; public: Complex() &#123; real=0; imag=0; &#125; Complex(double d)&#123; real=d; imag=0; &#125; Complex(double r,double i)&#123; real =r; imag=i; &#125; friend Complex operator + (Complex &amp;a,Complex &amp;b); friend ostream&amp; operator &lt;&lt; (ostream &amp;,Complex &amp;); private: double real; double imag;&#125;;Complex operator +(Complex &amp;a,Complex &amp;b)&#123; Complex temp; temp.real=a.real+b.real; temp.imag=a.imag+b.imag; return temp;&#125;ostream&amp; operator &lt;&lt; (ostream&amp; output,Complex &amp;a )&#123; cout&lt;&lt;"("&lt;&lt;a.real&lt;&lt;","&lt;&lt;a.imag&lt;&lt;"i)"; return output;&#125;int main()&#123; Complex c1(3,4),c2(5,-10),c3; c3=c1+4.0; cout&lt;&lt;c3&lt;&lt;endl; c3=c3+c1; cout &lt;&lt;c3&lt;&lt;endl;&#125; 写完感觉看着是没什么问题对吧（我真觉的没什么问题）。然而运行了一下就报错了，那…报什么错了？ [Error] no match for &#39;operator+&#39; (operand types are &#39;Complex&#39; and &#39;double&#39;) [Note] candidates are: [Note] Complex operator+(Complex&amp;, Complex&amp;) [Note] no known conversion for argument 2 from &#39;Complex&#39; to &#39;Complex&amp;&#39; 哦哦看了下报错，原来是重载函数写的问题，我先去查了一下代码。 课本上给出的重载运算符声明和定义是： friend Complex operator + (Complex a,Complex b); ... 我自己看走眼敲成了： friend Complex operator + (Complex &amp;a,Complex &amp;b); ... 看出问题在哪了么？没错就是一个”&amp;”的差别，即形参是Complex类对象的引用还是Complex类对象。 问题展开与解决去掉”&amp;”后程序果然可以正常运行的。不过我考虑了一下程序的实现过程，不对啊，一个简单的相加，我传递一个类对象的引用不应该出现什么问题啊，”+”本身又不会对引用的对象进行什么操作，返回类型是一个Complex类的对象。问题出现在哪里了？ 一些奇葩（正经）的实验于是乎我把之前写的简单的”+”重载的程序，函数的形参都改为对象的引用，再运行。结果更奇怪了，除了上述程序，都没有报错。这个程序又独特在哪里了？ 问题点再返回去读一读程序，这个样例用到了转换构造函数。 c3=c1+4.0; 在保留注释掉以后程序果然可以正常运行了，问题确实出现在这里。既然是转换构造函数的问题，隐式调用（默认执行的）方式不可行，那我试一试显式的 c3=c1+Complex(4.0); 然而…报错依旧，只有微小的变化 [Error] no match for &#39;operator+&#39; (operand types are &#39;Complex&#39; and &#39;Complex&#39;) 对照之前的 [Error] no match for &#39;operator+&#39; (operand types are &#39;Complex&#39; and &#39;double&#39;) 原来最开始的程序并没有成功的调用转换构造函数。编译器没有检测到？看来是哪里出了什么之前没考虑过的问题。 思考（不摔桌！不摔桌！冷静！）如果通过引用进行参数传递，可以免去建立实参的拷贝，空间和时间上都可以得到优化，逻辑推理一下，那这种传参的方式应该被推行啊，相近的例子就是流提取和流插入运算符的重载，第二个参数都是自定义类的引用。 那…为何”+”的重载不采用这种方式呢？看来是有问题的，结合之前的实验，在不出现转换构造函数调用的情况下，形参为引用是行得通的。看来这个问题和转换构造函数也相关。 再回过头来看报错信息 [Error] no match for &#39;operator+&#39; (operand types are &#39;Complex&#39; and &#39;Complex&#39;) [Note] candidates are: [Note] Complex operator+(Complex&amp;, Complex&amp;) [Note] no known conversion for argument 2 from &#39;Complex&#39; to &#39;Complex&amp;&#39; 最后一句：Complex到Complex&amp;转换出了问题，这个比较稀奇。从类对象到类对象的引用不应该是顺理成章的事情么，别名而已。Emm问题就在这个别名身上 引用&lt;-&gt;别名转换构造函数出现的无名对象转换构造函数是构造函数的重载，在使用转换构造函数的过程中，我们可以建立一个有名对象，也可以建立一个无名对象。书上中的代码样例 Complex c1(3.5); //调用转换构造函数建立对象c1 Complex(3.6); //调用转换构造函数建立无名对象，合法，但无法使用。 就是这个无名对象的锅，我们回过头来看最开始发现的问题点： c3=c1+Complex(4.0); 由于Complex(4.0)建立的是一个无名对象，而采用我错误写出的以引用作为形参的 “+”运算符重载，会发生什么？没有名字，自然无法引用啊。这也就解释了报错信息为什么Complex到Complex&amp;转换出了问题。无名的对象无法建立引用（没名字你怎么给它找个别名）。 事后诸葛亮根据简单的实验其实能得到一些结论 涉及转换构造函数的运算符重载，形参都应该是类对象而不是类对象的引用。 C++自己实现的”=”应该也是用类对象作形参，因为 c1=Complex(3.6); 这一句是可以正常执行的。 算作对引用以及构造函数的一个探索吧:)]]></content>
      <categories>
        <category>编程</category>
        <category>C++</category>
      </categories>
      <tags>
        <tag>C++</tag>
        <tag>课程学习</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[【CSU-1895】解题报告（数学，矩阵快速幂）]]></title>
    <url>%2Fpost%2F7d8e4f2a.html</url>
    <content type="text"><![CDATA[原始题目1895: Apache is late again Time Limit: 1 Sec Memory Limit: 128 Mb Submitted: 141 Solved: 45 DescriptionApache is a student of CSU. There is a math class every Sunday morning, but he is a very hard man who learns late every night. Unfortunate, he was late for maths on Monday. Last week the math teacher gave a question to let him answer as a punishment, but he was easily resolved. So the math teacher prepared a problem for him to solve. Although Apache is very smart, but also was stumped. So he wants to ask you to solve the problem. Questions are as follows: You can find a m made (1 + sqrt (2)) ^ n can be decomposed into sqrt (m) + sqrt (m-1), if you can output $m% 100000007$ otherwise output No. InputThere are multiply cases. Each case is a line of $n (|n| \le 10 ^ {18})$ OutputLine, if there is no such m output No, otherwise output m% 100,000,007. Sample Input2 Sample Output9 HintSource中南大学第十一届大学生程序设计竞赛 题目大意给定n，若${1 + \sqrt {2}} ^ n$，能表示成$\sqrt {m} + \sqrt {m-1}$，则输出m，否则输出No 解题思路当$n&gt;0$时,试着写出前几项 $(1+\sqrt{2})^1=\sqrt{2}+\sqrt{1}=\sqrt{1^2+1}+\sqrt{1^2}$ $(1+\sqrt{2})^2=\sqrt{9}+\sqrt{8}=\sqrt{3^2}+\sqrt{3^2-1}$ $(1+\sqrt{2})^3=\sqrt{50}+\sqrt{49}=\sqrt{7^2+1}+\sqrt{7^2}$ $(1+\sqrt{2})^4=\sqrt{289}+\sqrt{288}=\sqrt{17^2}+\sqrt{17^2-1}$ 若只观察含有$\sqrt{2}$的项，我们能得到下面的数列 a_1=1,a_2=2,a_3=5,a_4=12,\cdots可以看作是一个二阶差分方程，其通项的矩阵表达 \begin{bmatrix} a_n \\ a_{n-1} \\ \end{bmatrix}=\begin{bmatrix} 2&1 \\1&0 \end{bmatrix}\begin{bmatrix} a_{n-1}\\ a_{n-2}\end{bmatrix}={\begin{bmatrix} 2&1\\ 1&0\end{bmatrix} }^{n-2}\begin{bmatrix}a_2\\ a_1 \end{bmatrix}给定$a_1=1$，$a_2=2$，通过矩阵快速幂计算$a_n$ 解题代码123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293#include &lt;cstdio&gt;#include &lt;cstring&gt;#include &lt;iostream&gt;#include &lt;set&gt;#include &lt;queue&gt;#define mod 100000007 //这里定义模 using namespace std;const int maxn=1e5+5;typedef long long ll;struct Matrix&#123; ll a[2][2]; Matrix() &#123; memset(a,0,sizeof(a)); &#125; Matrix operator * (const Matrix y) &#123; Matrix ans; for(int i = 0; i &lt; 2; i++) for(int j = 0; j &lt; 2; j++) for(int k = 0; k &lt; 2; k++) ans.a[i][j] += (a[i][k]*y.a[k][j])%mod; return ans; &#125; Matrix operator = (const Matrix y) &#123; for(int i=0;i&lt;2;i++) for(int j=0;j&lt;2;j++) a[i][j]=y.a[i][j]; &#125; Matrix operator *= (const Matrix y) &#123; Matrix ans; for(int i=0;i&lt;2;i++) for(int j=0;j&lt;2;j++) for(int k=0;k&lt;2;k++) ans.a[i][j] += (a[i][k]*y.a[k][j])%mod; for(int i=0;i&lt;2;i++) for(int j=0;j&lt;2;j++) a[i][j]=ans.a[i][j]; &#125;&#125;;Matrix qpow(ll x)&#123; Matrix ans; ans.a[0][0]=ans.a[1][1]=1; //单位矩阵 Matrix mul; mul.a[0][0]=2; mul.a[0][1]=mul.a[1][0]=1; while(x) &#123; if(x&amp;1) ans *= mul; mul *= mul; x&gt;&gt;=1; &#125; return ans;&#125;ll pow(ll a,ll b)&#123; ll ans=1; while(b) &#123; if(b&amp;1) ans=(ans*a%mod); a=a*a%mod; b&gt;&gt;=1; &#125; return ans; &#125;ll n;int main()&#123; while(~scanf("%lld",&amp;n)) &#123; if(n&lt;0) printf("No\n"); else if(n==0) printf("1\n"); else if(n==1) printf("2\n"); else if(n==2) printf("9\n"); else if(n==3) printf("50\n"); else &#123; Matrix m=qpow(n-2); ll ans=(m.a[0][0]*2%mod+m.a[0][1]%mod)%mod; if(n&amp;1) printf("%lld\n",ans*ans*2%mod); else printf("%lld\n",(ans*ans%mod*2+1)%mod); &#125; &#125;&#125; 收获与反思 矩阵快速幂练习 注意n&lt;0时候输出No，因为这个T了好几次。]]></content>
      <categories>
        <category>编程</category>
        <category>ACM</category>
      </categories>
      <tags>
        <tag>ACM</tag>
        <tag>算法</tag>
        <tag>2018春季训练</tag>
        <tag>CSU</tag>
        <tag>矩阵快速幂</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[【CSU-2138】解题报告（数学，矩阵快速幂）]]></title>
    <url>%2Fpost%2Fb0d6c7.html</url>
    <content type="text"><![CDATA[原始题目2138: Rikka’s Set Time Limit: 1 Sec Memory Limit: 128 Mb Submitted: 44 Solved: 11 DescriptionRikka is poor at math. Now she asks you for help. A set is known as extraordinary set when the minimum integer of it is equal to its size.min{x : x ∈ S}=|S|For example, S = {3, 7, 8} is extraordinary. gn is the number of extraodinary subsets of {1, 2, …, n}. Rikka wants to know the value of gn. InputInput consists of one integer n(1 ≤ n ≤ 1018) OutputOutput a single integer gnmod1000000009 Sample Input16 Sample Output987 HintSourceAuthorxm 题目大意给定一个{1,2,3……n}的集合，问有多少个集合中元素个数等于集合中元素最小值的子集。 解题思路 对于给定的n， n=1，易知为1 n=2，易知为1 n&gt;=3，我们很容易根据题目想到答案的表达式Mathjax显示不出来好吧。。。就是 C(n-i,i-1) i从2到n的求和+1。 列出前几项，我们发现实际为斐波那契数列（等价证明还没想明白） 运用矩阵快速幂可得到答案。 解题代码12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364656667686970717273747576777879808182838485868788899091#include &lt;cstdio&gt;#include &lt;cstring&gt;#include &lt;iostream&gt;#include &lt;set&gt;#include &lt;queue&gt;#define mod 1000000009 //这里定义模 using namespace std;const int maxn=1e5+5;typedef long long ll;struct Matrix&#123; ll a[2][2]; Matrix() &#123; memset(a,0,sizeof(a)); &#125; Matrix operator * (const Matrix y) &#123; Matrix ans; for(int i = 0; i &lt; 2; i++) for(int j = 0; j &lt; 2; j++) for(int k = 0; k &lt; 2; k++) ans.a[i][j] += (a[i][k]*y.a[k][j])%mod; return ans; &#125; Matrix operator = (const Matrix y) &#123; for(int i=0;i&lt;2;i++) for(int j=0;j&lt;2;j++) a[i][j]=y.a[i][j]; &#125; Matrix operator *= (const Matrix y) &#123; Matrix ans; for(int i=0;i&lt;2;i++) for(int j=0;j&lt;2;j++) for(int k=0;k&lt;2;k++) ans.a[i][j] += (a[i][k]*y.a[k][j])%mod; for(int i=0;i&lt;2;i++) for(int j=0;j&lt;2;j++) a[i][j]=ans.a[i][j]; &#125;&#125;; Matrix qpow(ll x)&#123; Matrix ans; ans.a[0][0]=ans.a[1][1]=1; //单位矩阵 Matrix mul; mul.a[0][0]=mul.a[0][1]=mul.a[1][0]=1; while(x) &#123; if(x&amp;1) ans *= mul; mul*=mul; x&gt;&gt;=1; &#125; return ans;&#125;ll pow(ll a,ll b)&#123; ll ans=1; while(b) &#123; if(b&amp;1) ans=(ans*a%mod); a=a*a%mod; b&gt;&gt;=1; &#125; return ans; &#125;ll n;int main()&#123; while(~scanf("%lld",&amp;n)) &#123; if(n==1) printf("1\n"); else if(n==2) printf("1\n"); else if(n==3) printf("2\n"); else if(n==4) printf("3\n"); else if(n==5) printf("5\n"); else &#123; Matrix m=qpow(n-2); printf("%lld\n",(m.a[0][0]+m.a[0][1])%mod); &#125; &#125;&#125; 收获与反思 多尝试一下前几项，发现规律 矩阵快速幂练习]]></content>
      <categories>
        <category>编程</category>
        <category>ACM</category>
      </categories>
      <tags>
        <tag>ACM</tag>
        <tag>算法</tag>
        <tag>2018春季训练</tag>
        <tag>CSU</tag>
        <tag>矩阵快速幂</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[【AtCoder-4152】解题报告（数学，进制，贪心）]]></title>
    <url>%2Fpost%2F918fcaa1.html</url>
    <content type="text"><![CDATA[原始题目C - Strange Bank Time limit : 2sec Memory limit : 256MB Score : 300 points Problem StatementTo make it difficult to withdraw money, a certain bank allows its customers to withdraw only one of the following amounts in one operation: 1 yen (the currency of Japan) 6 yen, 62(=36) yen, 63(=216) yen, … 9 yen, 92(=81) yen, 93(=729) yen, … At least how many operations are required to withdraw exactly N yen in total? It is not allowed to re-deposit the money you withdrew. Constraints1≤N≤100000N is an integer. InputInput is given from Standard Input in the following format: N OutputIf at least x operations are required to withdraw exactly N yen in total, print x. Sample Input 1127 Sample Output 14 By withdrawing 1 yen, 9 yen, 36(=62) yen and 81(=92) yen, we can withdraw 127 yen in four operations. Sample Input 23 Sample Output 23 By withdrawing 1 yen three times, we can withdraw 3 yen in three operations. Sample Input 344852 Sample Output 316 题目大意规定三种取钱的方法，一次可以取1元，6^k元或者9^k元 （k&gt;=1） ，问取n元最少的次数是多少。 解题思路将n拆成i和n-i。分别用6和9进制表示，维护系数和最小值即可。 解题代码123456789101112131415161718192021222324#include &lt;cstdio&gt;#include &lt;iostream&gt; using namespace std;int n;int main()&#123; while(~scanf("%d" ,&amp;n)) &#123; int res=n; //最大情况肯定为n次 全部每次取1元 for(int i=0;i&lt;=n;i++) &#123; int cc=0; int t=i; while(t) cc+=t%6,t/=6; //计算6进制的系数和 t=n-i; while(t) cc+=t%9,t/=9; //计算9进制的系数和 if(res&gt;cc) res=cc; &#125; printf("%d\n",res); &#125;&#125; 收获与反思 理解题意，三种方法算最小值其实就是求一个数用6/9进制混合表达的系数最小值。 把n拆成两部分，维护系数最小值。 while(t) cc+=t%k,t/=k; 该方法得到的cc为t用k进制表达的系数和。]]></content>
      <categories>
        <category>编程</category>
        <category>ACM</category>
      </categories>
      <tags>
        <tag>ACM</tag>
        <tag>算法</tag>
        <tag>AtCoder</tag>
        <tag>math</tag>
        <tag>2018春季训练</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[【CodeForces-978F】解题报告（二分，排序，数据结构）]]></title>
    <url>%2Fpost%2F32dc51f4.html</url>
    <content type="text"><![CDATA[原始题目Mentors time limit per test3 seconds memory limit per test256 megabytes inputstandard input outputstandard output In BerSoft n programmers work, the programmer i is characterized by a skill ri. A programmer a can be a mentor of a programmer b if and only if the skill of the programmer a is strictly greater than the skill of the programmer b (ra&gt;rb) and programmers a and b are not in a quarrel. You are given the skills of each programmers and a list of k pairs of the programmers, which are in a quarrel (pairs are unordered). For each programmer i, find the number of programmers, for which the programmer i can be a mentor. InputThe first line contains two integers n and k (2≤n≤2⋅105, 0≤k≤min(2⋅105,n⋅(n−1)2)) — total number of programmers and number of pairs of programmers which are in a quarrel. The second line contains a sequence of integers r1,r2,…,rn (1≤ri≤109), where ri equals to the skill of the i-th programmer. Each of the following k lines contains two distinct integers x, y (1≤x,y≤n, x≠y) — pair of programmers in a quarrel. The pairs are unordered, it means that if x is in a quarrel with y then y is in a quarrel with x. Guaranteed, that for each pair (x,y) there are no other pairs (x,y) and (y,x) in the input. OutputPrint n integers, the i-th number should be equal to the number of programmers, for which the i-th programmer can be a mentor. Programmers are numbered in the same order that their skills are given in the input. ExamplesInput4 2 10 4 10 15 1 2 4 3 Output0 0 1 2 Input10 4 5 4 1 5 4 3 7 1 2 5 4 6 2 1 10 8 3 5 Output5 4 0 5 3 3 9 0 2 5 NoteIn the first example, the first programmer can not be mentor of any other (because only the second programmer has a skill, lower than first programmer skill, but they are in a quarrel). The second programmer can not be mentor of any other programmer, because his skill is minimal among others. The third programmer can be a mentor of the second programmer. The fourth programmer can be a mentor of the first and of the second programmers. He can not be a mentor of the third programmer, because they are in a quarrel. 题目大意给定n个人员skill值，并给出k个有矛盾的对，对于每个人，可以做skill值比自己小且没有矛盾人的导师。输出每一个人可做多少人的导师。 解题思路 排序后对每个人的skill值二分查找，存储到ans[]中。 对于每个矛盾对，skill值大的ans减1即可。 解题代码12345678910111213141516171819202122232425262728293031323334353637383940414243444546#include &lt;iostream&gt;#include &lt;cstdio&gt;#include &lt;iomanip&gt;#include &lt;cstring&gt;#include &lt;map&gt;#include &lt;set&gt;#include &lt;queue&gt;#include &lt;algorithm&gt;#define eps 1e-8#define INF 0x3f3f3f3fusing namespace std;typedef long long ll;const int maxn=2e5+5;ll a[maxn],b[maxn];int ans[maxn],n,t,k;int main()&#123; while(~scanf("%d%d",&amp;n,&amp;k)) &#123; for(int i=0;i&lt;n;i++) &#123; scanf("%I64d",&amp;a[i]); b[i]=a[i]; &#125; sort(b,b+n); for(int i=0;i&lt;n;i++) &#123; ans[i]=lower_bound(b,b+n,a[i])-b;// printf("--%d--\n",ans[i]); &#125; for(int i=0;i&lt;k;i++) &#123; int temp1,temp2; scanf("%d%d",&amp;temp1,&amp;temp2); if(a[temp1-1]&gt;a[temp2-1]) ans[temp1-1]--; else if(a[temp2-1]&gt;a[temp1-1]) ans[temp2-1]--; &#125; for(int i=0;i&lt;n;i++) &#123; if(i==0) printf("%d",ans[i]); else printf(" %d",ans[i]); &#125; printf("\n"); &#125;&#125; 收获与反思 二分查找 lower_bound的运用。 注意quarrel列的在线计算。]]></content>
      <categories>
        <category>编程</category>
        <category>ACM</category>
      </categories>
      <tags>
        <tag>ACM</tag>
        <tag>算法</tag>
        <tag>2018春季训练</tag>
        <tag>二分</tag>
        <tag>CodeForces</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[【CodeForces-978E】解题报告（暴力，数学）]]></title>
    <url>%2Fpost%2Ffcb9464d.html</url>
    <content type="text"><![CDATA[原始题目Bus Video System time limit per test1 second memory limit per test256 megabytes inputstandard input outputstandard output The busses in Berland are equipped with a video surveillance system. The system records information about changes in the number of passengers in a bus after stops. If x is the number of passengers in a bus just before the current bus stop and y is the number of passengers in the bus just after current bus stop, the system records the number y−x. So the system records show how number of passengers changed. The test run was made for single bus and n bus stops. Thus, the system recorded the sequence of integers a1,a2,…,an (exactly one number for each bus stop), where ai is the record for the bus stop i. The bus stops are numbered from 1 to n in chronological order. Determine the number of possible ways how many people could be in the bus before the first bus stop, if the bus has a capacity equals to w (that is, at any time in the bus there should be from 0 to w passengers inclusive). InputThe first line contains two integers n and w (1≤n≤1000,1≤w≤109) — the number of bus stops and the capacity of the bus. The second line contains a sequence a1,a2,…,an (−106≤ai≤106), where ai equals to the number, which has been recorded by the video system after the i-th bus stop. OutputPrint the number of possible ways how many people could be in the bus before the first bus stop, if the bus has a capacity equals to w. If the situation is contradictory (i.e. for any initial number of passengers there will be a contradiction), print 0. ExamplesInput3 5 2 1 -3 Output3 Input2 4 -1 1 Output4 Input4 10 2 4 1 2 Output2 NoteIn the first example initially in the bus could be 0, 1 or 2 passengers. In the second example initially in the bus could be 1, 2, 3 or 4 passengers. In the third example initially in the bus could be 0 or 1 passenger. 题目大意给定公交车经历的站数和最大容载量，并给出在各个公交站上/下车的人数，求最初车上人数有几种可能。 解题思路初始sum为0，上下车人数，记录最大值和最小值，计算最大差值，ans=m-(mmax-mmin)+1。 解题代码12345678910111213141516171819202122232425262728293031323334#include &lt;cstdio&gt;#include &lt;cstring&gt;#include &lt;iostream&gt;#include &lt;set&gt;#include &lt;queue&gt;#include &lt;map&gt;#include &lt;vector&gt;#include &lt;algorithm&gt;#define eps 1e-8#define INF 0x3f3f3f3fusing namespace std;const int maxn=2e5+5;typedef long long ll;ll b[maxn],d[maxn],n,m,t,sum,ans;int main()&#123; while(~scanf("%I64d%I64d",&amp;n,&amp;m)) &#123; sum=0; ll mmax=0,mmin=0; for(int i=1;i&lt;=n;i++) &#123; scanf("%I64d",&amp;b[i]); sum+=b[i]; if(sum&gt;mmax) mmax=sum; if(sum&lt;mmin) mmin=sum; &#125;// printf("%I64d %I64d\n",mmin,mmax); ll ans=m-(mmax-mmin)+1; if(ans&lt;=0) printf("0\n"); else printf("%I64d\n",ans); &#125;&#125; 收获与反思 简单数学问题]]></content>
      <categories>
        <category>编程</category>
        <category>ACM</category>
      </categories>
      <tags>
        <tag>ACM</tag>
        <tag>算法</tag>
        <tag>math</tag>
        <tag>2018春季训练</tag>
        <tag>CodeForces</tag>
        <tag>暴力</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[【CodeForces-978D】解题报告（暴力，数学讨论）]]></title>
    <url>%2Fpost%2F44505a5b.html</url>
    <content type="text"><![CDATA[原始题目Almost Arithmetic Progression time limit per test1 second memory limit per test256 megabytes inputstandard input outputstandard output Polycarp likes arithmetic progressions. A sequence [a1,a2,…,an] is called an arithmetic progression if for each i (1≤i&lt;n) the value ai+1−ai is the same. For example, the sequences [42], [5,5,5], [2,11,20,29] and [3,2,1,0] are arithmetic progressions, but [1,0,1], [1,3,9] and [2,3,1] are not. It follows from the definition that any sequence of length one or two is an arithmetic progression. Polycarp found some sequence of positive integers [b1,b2,…,bn]. He agrees to change each element by at most one. In the other words, for each element there are exactly three options: an element can be decreased by 1, an element can be increased by 1, an element can be left unchanged. Determine a minimum possible number of elements in b which can be changed (by exactly one), so that the sequence b becomes an arithmetic progression, or report that it is impossible. It is possible that the resulting sequence contains element equals 0. InputThe first line contains a single integer n (1≤n≤100000) — the number of elements in b. The second line contains a sequence b1,b2,…,bn (1≤bi≤109). OutputIf it is impossible to make an arithmetic progression with described operations, print -1. In the other case, print non-negative integer — the minimum number of elements to change to make the given sequence becomes an arithmetic progression. The only allowed operation is to add/to subtract one from an element (can’t use operation twice to the same position). ExamplesInput4 24 21 14 10 Output3 Input2 500 500 Output0 Input3 14 5 1 Output-1 Input5 1 3 6 9 12 Output1 NoteIn the first example Polycarp should increase the first number on 1, decrease the second number on 1, increase the third number on 1, and the fourth number should left unchanged. So, after Polycarp changed three elements by one, his sequence became equals to [25,20,15,10], which is an arithmetic progression. In the second example Polycarp should not change anything, because his sequence is an arithmetic progression. In the third example it is impossible to make an arithmetic progression. In the fourth example Polycarp should change only the first element, he should decrease it on one. After that his sequence will looks like [0,3,6,9,12], which is an arithmetic progression. 题目大意给定一组数，对每一个数可以不操作，或者+1，或者-1（加减记录改变次数），问这一组数是否可以通过操作变为等差数列 若可以，输出所需改变次数的最小值。 若不可以，输出-1. 解题思路对每种可能的gap遍历数据，更新需要更改的次数的最小值。gap由前两项a[0],a[1]确定，共有9种可能。确定gap后开始从a[2]开始遍历数组，一旦出现不符合则跳出，全部符合则更新最小操作数。 解题代码12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364656667686970717273747576777879808182838485868788#include &lt;cstdio&gt;#include &lt;cmath&gt;#include &lt;cstring&gt;#include &lt;iostream&gt;#include &lt;set&gt;#include &lt;string&gt;#include &lt;iomanip&gt;#include &lt;algorithm&gt;#include &lt;queue&gt;#include &lt;vector&gt;#include &lt;map&gt;#define INF 0x3f3f3f3f#define eps 1e-8using namespace std;const int maxn=1e5+5;typedef long long ll;ll a[maxn+10];int ans; int n,m,t;int main()&#123; while(~scanf("%d",&amp;n)) &#123; ans=INF; for(int i=0;i&lt;n;i++) scanf("%I64d",&amp;a[i]); if(n==1) &#123; printf("0\n"); continue; &#125; ll gap=a[1]-a[0]; ll origin0=a[0],origin1=a[1],ogap=a[1]-a[0]; //第一种情况 for(int i=0;i&lt;9;i++) &#123; int ccnt=0; if(i==0) a[0]=origin0-1,a[1]=origin1-1,ccnt=2; else if(i==1) a[0]=origin0,a[1]=origin1-1,ccnt=1; else if(i==2) a[0]=origin0+1,a[1]=origin1-1,ccnt=2; else if(i==3) a[0]=origin0-1,a[1]=origin1,ccnt=1; else if(i==4) a[0]=origin0,a[1]=origin1,ccnt=0; else if(i==5) a[0]=origin0+1,a[1]=origin1,ccnt=1; else if(i==6) a[0]=origin0-1,a[1]=origin1+1,ccnt=2; else if(i==7) a[0]=origin0,a[1]=origin1+1,ccnt=1; else if(i==8) a[0]=origin0+1,a[1]=origin1+1,ccnt=2; gap=a[1]-a[0]; //开始遍历剩余 int j=2; ll last=a[1]; for(;j&lt;n;j++) &#123;// printf("before a[j]-last=%d\n",a[j]-last); if(a[j]-last==gap) &#123; last=a[j]; continue; &#125; else if(a[j]-last==gap+1) &#123; last=a[j]-1; ccnt++; continue; &#125; else if(a[j]-last==gap-1) &#123; last=a[j]+1; ccnt++; continue; &#125; else break; &#125; if(j==n) ans=min(ans,ccnt); &#125; if(ans==INF) printf("-1\n"); else printf("%d\n",ans); &#125;&#125; 收获与反思 想到可能的等差gap值。 暴力遍历每种gap的可能。]]></content>
      <categories>
        <category>编程</category>
        <category>ACM</category>
      </categories>
      <tags>
        <tag>ACM</tag>
        <tag>算法</tag>
        <tag>math</tag>
        <tag>2018春季训练</tag>
        <tag>CodeForces</tag>
        <tag>暴力</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[【CodeForces-978C】解题报告（水题，前缀和）]]></title>
    <url>%2Fpost%2F9c649212.html</url>
    <content type="text"><![CDATA[原始题目Letters time limit per test4 seconds memory limit per test256 megabytes inputstandard input outputstandard output There are n dormitories in Berland State University, they are numbered with integers from 1 to n. Each dormitory consists of rooms, there are ai rooms in i-th dormitory. The rooms in i-th dormitory are numbered from 1 to ai. A postman delivers letters. Sometimes there is no specific dormitory and room number in it on an envelope. Instead of it only a room number among all rooms of all n dormitories is written on an envelope. In this case, assume that all the rooms are numbered from 1 to a1+a2+⋯+an and the rooms of the first dormitory go first, the rooms of the second dormitory go after them and so on. For example, in case n=2, a1=3 and a2=5 an envelope can have any integer from 1 to 8 written on it. If the number 7 is written on an envelope, it means that the letter should be delivered to the room number 4 of the second dormitory. For each of m letters by the room number among all n dormitories, determine the particular dormitory and the room number in a dormitory where this letter should be delivered. InputThe first line contains two integers n and m (1≤n,m≤2⋅105) — the number of dormitories and the number of letters. The second line contains a sequence a1,a2,…,an (1≤ai≤1010), where ai equals to the number of rooms in the i-th dormitory. The third line contains a sequence b1,b2,…,bm (1≤bj≤a1+a2+⋯+an), where bj equals to the room number (among all rooms of all dormitories) for the j-th letter. All bj are given in increasing order. OutputPrint m lines. For each letter print two integers f and k — the dormitory number f (1≤f≤n) and the room number k in this dormitory (1≤k≤af) to deliver the letter. ExamplesInput3 6 10 15 12 1 9 12 23 26 37 Output1 1 1 9 2 2 2 13 3 1 3 12 Input2 3 5 10000000000 5 6 9999999999 Output1 5 2 1 2 9999999994 NoteIn the first example letters should be delivered in the following order: the first letter in room 1 of the first dormitory the second letter in room 9 of the first dormitory the third letter in room 2 of the second dormitory the fourth letter in room 13 of the second dormitory the fifth letter in room 1 of the third dormitory the sixth letter in room 12 of the third dormitory 题目大意给出n个公寓的房间数，给出从第一个房间开始计数的房间号，要求输出按公寓分开后每个房间对应的公寓号码和在本公寓的房间号码 解题思路根据n个公寓的房间数处理出前缀和，顺序遍历前缀和数组，对每个查询求差值即可。 解题代码123456789101112131415161718192021222324252627282930313233343536373839404142434445464748#include &lt;cstdio&gt;#include &lt;cstring&gt;#include &lt;iostream&gt;#include &lt;set&gt;#include &lt;queue&gt;#include &lt;map&gt;#include &lt;vector&gt;#include &lt;algorithm&gt;#define eps 1e-8#define INF 0x3f3f3f3fusing namespace std;const int maxn=2e5+5;typedef long long ll;ll gcd(ll a,ll b)&#123; return a?gcd(b%a,a):b;&#125;ll lcm(ll a,ll b)&#123; return a/gcd(a,b)*b; &#125; ll n,m,vis[maxn],ans[maxn],cnt;ll a[maxn],sum[maxn];int main()&#123; while(~scanf("%lld%d",&amp;n,&amp;m)) &#123; sum[0]=0; for(ll i=1;i&lt;=n;i++) &#123; scanf("%lld",&amp;sum[i]); sum[i]+=sum[i-1]; //处理前缀和 &#125; ll temp; ll j=0; for(ll i=0;i&lt;m;i++) &#123; scanf("%I64d",&amp;temp); while(temp&gt;sum[j]) j++; printf("%I64d %I64d\n",j,temp-sum[j-1]); &#125; &#125;&#125; 收获与反思前缀和应用。注意如果查询不按顺序的话应该采用二分查找。]]></content>
      <categories>
        <category>编程</category>
        <category>ACM</category>
      </categories>
      <tags>
        <tag>ACM</tag>
        <tag>算法</tag>
        <tag>2018春季训练</tag>
        <tag>水题</tag>
        <tag>CodeForces</tag>
        <tag>前缀和</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[【CodeForces-978B】解题报告（水题，贪心，字符串）]]></title>
    <url>%2Fpost%2F5abc6d45.html</url>
    <content type="text"><![CDATA[原始题目File Name time limit per test1 second memory limit per test256 megabytes inputstandard input outputstandard output You can not just take the file and send it. When Polycarp trying to send a file in the social network “Codehorses”, he encountered an unexpected problem. If the name of the file contains three or more “x” (lowercase Latin letters “x”) in a row, the system considers that the file content does not correspond to the social network topic. In this case, the file is not sent and an error message is displayed. Determine the minimum number of characters to remove from the file name so after that the name does not contain “xxx” as a substring. Print 0 if the file name does not initially contain a forbidden substring “xxx”. You can delete characters in arbitrary positions (not necessarily consecutive). If you delete a character, then the length of a string is reduced by 1. For example, if you delete the character in the position 2 from the string “exxxii”, then the resulting string is “exxii”. InputThe first line contains integer n (3≤n≤100) — the length of the file name. The second line contains a string of length n consisting of lowercase Latin letters only — the file name. OutputPrint the minimum number of characters to remove from the file name so after that the name does not contain “xxx” as a substring. If initially the file name dost not contain a forbidden substring “xxx”, print 0. ExamplesInput6 xxxiii Output1 Input5 xxoxx Output0 Input10 xxxxxxxxxx Output8 NoteIn the first example Polycarp tried to send a file with name contains number 33, written in Roman numerals. But he can not just send the file, because it name contains three letters “x” in a row. To send the file he needs to remove any one of this letters. 题目大意文件名中超过n个（n&gt;=3）连续的x时需要修改n-2次。 解题思路每次贪心的取最大连续个x值，然后判断累加即可。 解题代码12345678910111213141516171819202122232425262728293031323334353637383940414243444546#include &lt;cstdio&gt;#include &lt;cstring&gt;#include &lt;iostream&gt;#include &lt;set&gt;#include &lt;queue&gt;#include &lt;map&gt;#include &lt;vector&gt;#include &lt;algorithm&gt;#define eps 1e-8#define INF 0x3f3f3f3fusing namespace std;const int maxn=1e5+5;typedef long long ll;ll gcd(ll a,ll b)&#123; return a?gcd(b%a,a):b;&#125;ll lcm(ll a,ll b)&#123; return a/gcd(a,b)*b; &#125; int n,m,vis[maxn],ans[maxn],cnt;char a[maxn];int main()&#123; while(~scanf("%d",&amp;n)) &#123; getchar(); cnt=0; int ccnt=0;char temp; gets(a); for(int i=0;i&lt;n;i++) &#123; if(a[i]=='x') ccnt++; else &#123; if(ccnt&gt;=3) cnt+=ccnt-2; ccnt=0; &#125; &#125; if(ccnt&gt;=3) cnt+=ccnt-2; printf("%d\n",cnt); &#125; &#125; 收获与反思字符串简单贪心]]></content>
      <categories>
        <category>编程</category>
        <category>ACM</category>
      </categories>
      <tags>
        <tag>ACM</tag>
        <tag>算法</tag>
        <tag>2018春季训练</tag>
        <tag>Greedy</tag>
        <tag>CodeForces</tag>
        <tag>字符串</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[【CodeForces-978A】解题报告（水题）]]></title>
    <url>%2Fpost%2F36e5881d.html</url>
    <content type="text"><![CDATA[原始题目Remove Duplicates time limit per test1 second memory limit per test256 megabytes inputstandard input outputstandard output Petya has an array a consisting of n integers. He wants to remove duplicate (equal) elements. Petya wants to leave only the rightmost entry (occurrence) for each element of the array. The relative order of the remaining unique elements should not be changed. InputThe first line contains a single integer n (1≤n≤50) — the number of elements in Petya’s array. The following line contains a sequence a1,a2,…,an (1≤ai≤1000) — the Petya’s array. OutputIn the first line print integer x — the number of elements which will be left in Petya’s array after he removed the duplicates. In the second line print x integers separated with a space — Petya’s array after he removed the duplicates. For each unique element only the rightmost entry should be left. ExamplesInput6 1 5 5 1 6 1 Output3 5 6 1 Input5 2 4 2 4 4 Output2 2 4 Input5 6 6 6 6 6 Output1 6 NoteIn the first example you should remove two integers 1, which are in the positions 1 and 4. Also you should remove the integer 5, which is in the position 2. In the second example you should remove integer 2, which is in the position 1, and two integers 4, which are in the positions 2 and 4. In the third example you should remove four integers 6, which are in the positions 1, 2, 3 and 4. 题目大意给一组数，输出不重复的数个数，按序输出。 解题思路水题 解题代码123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354#include &lt;cstdio&gt;#include &lt;cstring&gt;#include &lt;iostream&gt;#include &lt;set&gt;#include &lt;queue&gt;#include &lt;map&gt;#include &lt;vector&gt;#include &lt;algorithm&gt;#define eps 1e-8#define INF 0x3f3f3f3fusing namespace std;const int maxn=1e5+5;typedef long long ll;ll gcd(ll a,ll b)&#123; return a?gcd(b%a,a):b;&#125;ll lcm(ll a,ll b)&#123; return a/gcd(a,b)*b; &#125; int a[maxn],n,m,vis[maxn],ans[maxn],cnt;int main()&#123; while(~scanf("%d",&amp;n)) &#123; cnt=0; memset(vis,0,sizeof(vis)); for(int i=1;i&lt;=n;i++) &#123; scanf("%d",&amp;a[i]); &#125; for(int i=n;i&gt;=1;i--) &#123;// printf("%d",a[i]); if(!vis[a[i]]) &#123; ans[cnt++]=a[i]; vis[a[i]]=1; &#125; &#125; printf("%d\n",cnt); for(int i=cnt-1;i&gt;=0;i--) &#123; if(i==0) printf("%d",ans[i]); else printf("%d ",ans[i]); &#125; printf("\n"); &#125;&#125; 收获与反思无，注意细节一遍成功即可。]]></content>
      <categories>
        <category>编程</category>
        <category>ACM</category>
      </categories>
      <tags>
        <tag>ACM</tag>
        <tag>算法</tag>
        <tag>2018春季训练</tag>
        <tag>水题</tag>
        <tag>CodeForces</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[【CSU-1023】解题报告（二分）]]></title>
    <url>%2Fpost%2F109aa3c8.html</url>
    <content type="text"><![CDATA[原始题目1023: 修路 Time Limit: 1 Sec Memory Limit: 128 Mb Submitted: 632 Solved: 340Description前段时间，某省发生干旱，B山区的居民缺乏生活用水，现在需要从A城市修一条通往B山区的路。假设有A城市通往B山区的路由$m$条连续的路段组成，现在将这m条路段承包给$n$个工程队$(n ≤ m ≤ 300)$。为了修路的便利，每个工程队只能分配到连续的若干条路段（当然也可能只分配到一条路段或未分配到路段）。假设每个工程队修路的效率一样，即每修长度为$1$的路段所需的时间为$1$。现在给出路段的数量$m$，工程队的数量$n$，以及$m$条路段的长度（这$m$条路段的长度是按照从A城市往B山区的方向依次给出，每条路段的长度均小于$1000$），需要你计算出修完整条路所需的最短的时间（即耗时最长的工程队所用的时间）。 Input第一行是测试样例的个数T ，接下来是T个测试样例，每个测试样例占2行，第一行是路段的数量m和工程队的数量n，第二行是m条路段的长度。 Output对于每个测试样例，输出修完整条路所需的最短的时间。 Sample Input2 4 3 100 200 300 400 9 4 250 100 150 400 550 200 50 700 300 Sample Output400 900 HintSource中南大学第四届大学生程序设计竞赛 解题思路 每个队伍必须连续修路，每个队伍效率相同（每天都修单位长度） 可以得到修路的下限和上限，二分修路长度最终得到答案 解题代码123456789101112131415161718192021222324252627282930313233343536373839404142434445464748#include &lt;cstdio&gt;#include &lt;cstring&gt;#include &lt;iostream&gt;#include &lt;set&gt;#include &lt;queue&gt;#include &lt;algorithm&gt;#include &lt;queue&gt;using namespace std;const int maxn=1e5+5;int t,n,m;int road[maxn];int main()&#123; scanf("%d",&amp;t); while(t--) &#123; memset(road,0,sizeof(road)); scanf("%d%d",&amp;m,&amp;n); int high=0,low=0; for(int i=0;i&lt;m;i++) &#123; scanf("%d",&amp;road[i]); high+=road[i]; low=max(road[i],low); &#125; while(low&lt;high) //二分修路的长度 &#123; int mid=(high+low)&gt;&gt;1;// printf("now mid=%d\n",mid); int tot=n-1,sum=road[0]; //一共还有n-1个人可以用 for(int i=1;i&lt;m;i++) &#123; if(sum+road[i]&gt;mid) &#123; tot--; sum=road[i]; &#125; else sum+=road[i]; if(tot&lt;0) break; &#125; if(tot&lt;0) low=mid+1; else high=mid; &#125; printf("%d\n",low); &#125; &#125; 收获与反思 二分思维转换 已知上界下界后利用二分逼近答案]]></content>
      <categories>
        <category>编程</category>
        <category>ACM</category>
      </categories>
      <tags>
        <tag>ACM</tag>
        <tag>算法</tag>
        <tag>2018春季训练</tag>
        <tag>CSU</tag>
        <tag>二分</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[【HDU-1166】解题报告（线段树求和，点维护）]]></title>
    <url>%2Fpost%2F454c2118.html</url>
    <content type="text"><![CDATA[原始题目敌兵布阵 Time Limit: 2000/1000 MS (Java/Others) Memory Limit: 65536/32768 K (Java/Others) Total Submission(s): 111269 Accepted Submission(s): 46637 Problem Description C国的死对头A国这段时间正在进行军事演习，所以C国间谍头子Derek和他手下Tidy又开始忙乎了。A国在海岸线沿直线布置了N个工兵营地,Derek和Tidy的任务就是要监视这些工兵营地的活动情况。由于采取了某种先进的监测手段，所以每个工兵营地的人数C国都掌握的一清二楚,每个工兵营地的人数都有可能发生变动，可能增加或减少若干人手,但这些都逃不过C国的监视。中央情报局要研究敌人究竟演习什么战术,所以Tidy要随时向Derek汇报某一段连续的工兵营地一共有多少人,例如Derek问:“Tidy,马上汇报第3个营地到第10个营地共有多少人!”Tidy就要马上开始计算这一段的总人数并汇报。但敌兵营地的人数经常变动，而Derek每次询问的段都不一样，所以Tidy不得不每次都一个一个营地的去数，很快就精疲力尽了，Derek对Tidy的计算速度越来越不满:”你个死肥仔，算得这么慢，我炒你鱿鱼!”Tidy想：“你自己来算算看，这可真是一项累人的工作!我恨不得你炒我鱿鱼呢!”无奈之下，Tidy只好打电话向计算机专家Windbreaker求救,Windbreaker说：“死肥仔，叫你平时做多点acm题和看多点算法书，现在尝到苦果了吧!”Tidy说：”我知错了。。。”但Windbreaker已经挂掉电话了。Tidy很苦恼，这么算他真的会崩溃的，聪明的读者，你能写个程序帮他完成这项工作吗？不过如果你的程序效率不够高的话，Tidy还是会受到Derek的责骂的. Input第一行一个整数$T$，表示有$T$组数据。每组数据第一行一个正整数$N(N \le 50000)$,表示敌人有$N$个工兵营地，接下来有$N$个正整数,第$i$个正整数$a_i$代表第$i$个工兵营地里开始时有$a_i$个人$(1 \le ai \le 50)$。接下来每行有一条命令，命令有4种形式：(1) Add i j,i和j为正整数,表示第i个营地增加j个人（j不超过30）(2)Sub i j ,i和j为正整数,表示第i个营地减少j个人（j不超过30）;(3)Query i j ,i和j为正整数,i&lt;=j，表示询问第i到第j个营地的总人数;(4)End 表示结束，这条命令在每组数据最后出现;每组数据最多有$40000$条命令 Output对第i组数据,首先输出“Case i:”和回车,对于每个Query询问，输出一个整数并回车,表示询问的段中的总人数,这个数保持在int以内。 Sample Input1 10 1 2 3 4 5 6 7 8 9 10 Query 1 3 Add 3 6 Query 2 7 Sub 10 2 Add 6 3 Query 3 10 End Sample OutputCase 1: 6 33 59 AuthorWindbreaker RecommendEddy 题目大意见中文 解题思路线段树入门题目，点修改（含正负情况），区间询问，注意 解题代码123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106#include &lt;cstdio&gt;#include &lt;cstring&gt;#include &lt;cmath&gt;#include &lt;iostream&gt;#include &lt;iomanip&gt;#include &lt;set&gt;#include &lt;queue&gt;#include &lt;map&gt;#include &lt;vector&gt;#include &lt;algorithm&gt;#include &lt;stack&gt;using namespace std;typedef long long ll;const int maxn=2e5+5;struct node&#123; ll l,r,sum;&#125;tree[maxn];ll a[maxn];void build(ll k, ll l,ll r)&#123; tree[k].l=l; tree[k].r=r; if(tree[k].l==tree[k].r) &#123; tree[k].sum=a[l]; return ; &#125; ll mid=(tree[k].l+tree[k].r)&gt;&gt;1; build(k&lt;&lt;1,l,mid); build(k&lt;&lt;1|1,mid+1,r); tree[k].sum=tree[k&lt;&lt;1].sum+tree[k&lt;&lt;1|1].sum;// printf("k==%lld k.sum==%lld\n",k,tree[k].sum);&#125;void change(ll k,ll d,ll x)&#123; if(tree[k].l==tree[k].r&amp;&amp;tree[k].r==d) &#123; tree[k].sum=tree[k].sum+x; return ; &#125; int mid=(tree[k].l+tree[k].r)&gt;&gt;1; if(d&gt;=tree[k].l&amp;&amp;d&lt;=mid) change(k&lt;&lt;1,d,x); else change(k&lt;&lt;1|1,d,x); tree[k].sum=tree[k&lt;&lt;1].sum+tree[k&lt;&lt;1|1].sum; &#125;ll query(ll k,ll l,ll r)&#123; if(tree[k].l==l&amp;&amp;tree[k].r==r) return tree[k].sum; ll mid=(tree[k].l+tree[k].r)&gt;&gt;1; if(r&lt;=mid) return query(k&lt;&lt;1,l,r); else if(l&gt;=mid+1) return query(k&lt;&lt;1|1,l,r); else return query(k&lt;&lt;1,l,mid)+query(k&lt;&lt;1|1,mid+1,r); &#125;char ch[10];ll t,n,d,x;int main() &#123;// freopen("in.txt","r",stdin);// freopen("out.txt","w",stdout); while(~scanf("%lld",&amp;t)) &#123; int cnt=0; while(t--) &#123; memset(tree,0,sizeof(tree)); memset(a,0,sizeof(a)); cnt++; printf("Case %d:\n",cnt); scanf("%lld",&amp;n); for(int i=1;i&lt;=n;i++) scanf("%lld",&amp;a[i]); build(1,1,n); while(scanf("%s",ch)&amp;&amp;ch[0]!='E') &#123; if(ch[0]=='Q') &#123; scanf("%lld%lld",&amp;d,&amp;x); printf("%lld\n",query(1,d,x)); &#125; else if(ch[0]=='A') &#123; scanf("%lld%lld",&amp;d,&amp;x); change(1,d,x); &#125; else if(ch[0]=='S') &#123; scanf("%lld%lld",&amp;d,&amp;x); change(1,d,-x); &#125; &#125; &#125; &#125; &#125; 收获与反思 Emmm，WA了两次是因为数组开的不够大，这个以为够用了，待分析原因。 进一步熟悉模板。 注意long long。]]></content>
      <categories>
        <category>编程</category>
        <category>ACM</category>
      </categories>
      <tags>
        <tag>ACM</tag>
        <tag>算法</tag>
        <tag>2018春季训练</tag>
        <tag>HDU</tag>
        <tag>线段树</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[【POJ-3468】解题报告（线段树求和，区间维护）]]></title>
    <url>%2Fpost%2F481e8abf.html</url>
    <content type="text"><![CDATA[原始题目A Simple Problem with Integers Time Limit: 5000MS Memory Limit: 131072K Total Submissions: 129411 Accepted: 40139 Case Time Limit: 2000MS Description You have N integers, A1, A2, … , AN. You need to deal with two kinds of operations. One type of operation is to add some given number to each number in a given interval. The other is to ask for the sum of numbers in a given interval. InputThe first line contains two numbers N and Q. 1 ≤ N,Q ≤ 100000.The second line contains N numbers, the initial values of A1, A2, … , AN. -1000000000 ≤ Ai ≤ 1000000000.Each of the next Q lines represents an operation.“C a b c” means adding c to each of Aa, Aa+1, … , Ab. -10000 ≤ c ≤ 10000.“Q a b” means querying the sum of Aa, Aa+1, … , Ab. OutputYou need to answer all Q commands in order. One answer in a line. Sample Input10 5 1 2 3 4 5 6 7 8 9 10 Q 4 4 Q 1 10 Q 2 4 C 3 6 3 Q 2 4 Sample Output4 55 9 15 HintThe sums may exceed the range of 32-bit integers. SourcePOJ Monthly—2007.11.25, Yang Yi 题目大意对于一组序列A,有两种操作，询问：给出对应区间序列的和，增加：给出对应区间区间内所有点增加固定值。 解题思路线段树模板题，区间询问，区间修改，注意long long即可。 解题代码123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147148149150151152153154155156#include &lt;cstdio&gt;#include &lt;cstring&gt;#include &lt;cmath&gt;#include &lt;cmath&gt;#include &lt;iostream&gt;#include &lt;iomanip&gt;#include &lt;string&gt;#include &lt;set&gt;#include &lt;queue&gt;#include &lt;vector&gt;#include &lt;map&gt;using namespace std;const int maxn=2e5+5;typedef long long ll;ll n,m;ll d,x;ll b,e;ll a[maxn];struct node&#123; ll l; ll r; ll sum; ll tag; ll maxnum;&#125;tree[maxn&lt;&lt;2];char ch[2];void build(ll k,ll l,ll r) //k为线段树的角标 &#123; tree[k].l=l; tree[k].r=r; if(l==r) &#123; tree[k].sum=a[l]=a[r]; //叶子节点，单点的sum即是本身 return ; &#125; ll mid=(l+r)&gt;&gt;1; build(k&lt;&lt;1,l,mid); //递归构建左线段（左子树） build(k&lt;&lt;1|1,mid+1,r); //递归构建右线段（右子树） tree[k].sum=tree[k&lt;&lt;1].sum+tree[k&lt;&lt;1|1].sum; return ; &#125;void change1(ll k,ll d,ll x)&#123; if(tree[k].l==tree[k].r&amp;&amp;tree[k].r==d) //找到索引点 &#123; tree[k].maxnum=x; //修改最大值 return ; //修改后再开始回溯 &#125; ll mid=(tree[k].l+tree[k].r)&gt;&gt;1; if(d&gt;=tree[k].l&amp;&amp;d&lt;=mid) //查找点在左子树 change1(k&lt;&lt;1,d,x); //k&lt;&lt;1为左子树, else //查找点在右子树， change1(k&lt;&lt;1|1,d,x); //k&lt;&lt;1|1为右子树 tree[k].maxnum=max(tree[k&lt;&lt;1].maxnum,tree[k&lt;&lt;1|1].maxnum); //递归从新计算非叶结点的值 &#125;void change(ll k) //懒惰操作，有标记才操作一次，有记忆性 &#123; if(tree[k].l==tree[k].r) tree[k].sum+=tree[k].tag; else &#123; tree[k].sum+=(tree[k].r-tree[k].l+1)*tree[k].tag; tree[k&lt;&lt;1].tag+=tree[k].tag; tree[k&lt;&lt;1|1].tag+=tree[k].tag; &#125; tree[k].tag=0; //自身标记清零 &#125;void add(ll k,ll l,ll r,ll x)&#123; if(tree[k].tag) &#123;// printf("--"); change(k); &#125; if(tree[k].l==l&amp;&amp;tree[k].r==r) //在固定的区间打标记 &#123; tree[k].tag+=x; //向下打标记 // printf("k=%lld l=%lld r=%lld tag=%lld\n",k ,l,r,tree[k].tag); return ; &#125;// printf("1 %lld\n",tree[k].sum); tree[k].sum+=(r-l+1)*x;// printf("2 %lld\n",tree[k].sum); ll mid=(tree[k].r+tree[k].l)&gt;&gt;1; if(r&lt;=mid) add(k&lt;&lt;1,l,r,x); else if(l&gt;=mid+1) add(k&lt;&lt;1|1,l,r,x); else &#123; add(k&lt;&lt;1,l,mid,x); add(k&lt;&lt;1|1,mid+1,r,x); &#125;&#125;ll query(ll k,ll l,ll r)&#123;// printf("query %lld .tag=%lld\n",k,tree[k].tag); if(tree[k].tag) &#123;// printf("$"); change(k); &#125; ll mid=(tree[k].l+tree[k].r)&gt;&gt;1; if(tree[k].l==l&amp;&amp;tree[k].r==r) return tree[k].sum; if(r&lt;=mid) return query(k&lt;&lt;1,l,r); else if(l&gt;=mid+1) return query(k&lt;&lt;1|1,l,r); else return query(k&lt;&lt;1,l,mid)+query(k&lt;&lt;1|1,mid+1,r); //中线跨区间 &#125;int main()&#123; while(~scanf("%lld%lld",&amp;n,&amp;m)) &#123; memset(tree,0,sizeof(tree)); for(ll i=1;i&lt;=n;i++) &#123; scanf("%lld",&amp;a[i]); &#125; build(1,1,n); for(ll i=1;i&lt;=m;i++) &#123; scanf("%s",ch); if(ch[0]=='Q') &#123; scanf("%lld%lld",&amp;b,&amp;e);// printf("11"); printf("%lld\n",query(1,b,e)); &#125; else &#123; scanf("%lld%lld%lld",&amp;b,&amp;e,&amp;x); add(1,b,e,x); &#125; &#125; &#125;&#125; 收获与反思 注意数组不要越界，注意long long。 写模板注意sum的写法和取最大值的写法略有不同。 理解lazy（tag）标记，即访问到时才进行一次向下扩展，每次修改并不直接作用于叶子节点。]]></content>
      <categories>
        <category>编程</category>
        <category>ACM</category>
      </categories>
      <tags>
        <tag>ACM</tag>
        <tag>算法</tag>
        <tag>2018春季训练</tag>
        <tag>HDU</tag>
        <tag>线段树</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[【HDU-1754】解题报告（线段树最大值，点维护）]]></title>
    <url>%2Fpost%2F4e876bc2.html</url>
    <content type="text"><![CDATA[原始题目I Hate It Time Limit: 9000/3000 MS (Java/Others) Memory Limit: 32768/32768 K (Java/Others) Total Submission(s): 92291 Accepted Submission(s): 35036 Problem Description很多学校流行一种比较的习惯。老师们很喜欢询问，从某某到某某当中，分数最高的是多少。这让很多学生很反感。 不管你喜不喜欢，现在需要你做的是，就是按照老师的要求，写一个程序，模拟老师的询问。当然，老师有时候需要更新某位同学的成绩。 Input本题目包含多组测试，请处理到文件结束。在每个测试的第一行，有两个正整数 N 和 M ( 0&lt;N≤200000,0&lt;M&lt;5000 )，分别代表学生的数目和操作的数目。学生ID编号分别从1编到N。第二行包含N个整数，代表这N个学生的初始成绩，其中第i个数代表ID为i的学生的成绩。接下来有M行。每一行有一个字符 C (只取’Q’或’U’) ，和两个正整数A，B。当C为’Q’的时候，表示这是一条询问操作，它询问ID从A到B(包括A,B)的学生当中，成绩最高的是多少。当C为’U’的时候，表示这是一条更新操作，要求把ID为A的学生的成绩更改为B。 Output对于每一次询问操作，在一行里面输出最高成绩。 Sample Input5 6 1 2 3 4 5 Q 1 5 U 3 6 Q 3 4 Q 4 5 U 2 9 Q 1 5 Sample Output5 6 5 9 HintHuge input,the C function scanf() will work better than cin Authorlinle Source2007省赛集训队练习赛（6）_linle专场 Recommendlcy 题目大意如中文 解题思路线段树模板题，点修改，维护最大值 解题代码1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465666768697071727374757677787980818283848586878889909192939495969798#include &lt;cstdio&gt;#include &lt;cstring&gt;#include &lt;cmath&gt;#include &lt;cmath&gt;#include &lt;iostream&gt;#include &lt;iomanip&gt;#include &lt;string&gt;#include &lt;set&gt;#include &lt;queue&gt;#include &lt;vector&gt;#include &lt;map&gt;using namespace std;const int maxn=2e5+5;int n,m;int d,x;int a[maxn];struct node&#123; int l; int r; int maxnum;&#125;tree[maxn&lt;&lt;2];char ch[2];void build(int k,int l,int r) //k为线段树的角标 &#123; tree[k].l=l; tree[k].r=r; if(l==r) &#123; tree[k].maxnum=a[l]=a[r]; //叶子节点，单点的max值就是该点的值 return ; &#125; int mid=(l+r)&gt;&gt;1; build(k&lt;&lt;1,l,mid); //递归构建左线段（左子树） build(k&lt;&lt;1|1,mid+1,r); //递归构建右线段（右子树） tree[k].maxnum=max(tree[k&lt;&lt;1].maxnum,tree[k&lt;&lt;1|1].maxnum); //根节点的最大值是左右子树最大值的max return ; &#125;void change(int k,int d,int x)&#123; if(tree[k].l==tree[k].r&amp;&amp;tree[k].r==d) //找到索引点 &#123; tree[k].maxnum=x; //修改最大值 return ; //修改后再开始回溯 &#125; int mid=(tree[k].l+tree[k].r)&gt;&gt;1; if(d&gt;=tree[k].l&amp;&amp;d&lt;=mid) //查找点在左子树 change(k&lt;&lt;1,d,x); //k&lt;&lt;1为左子树, else //查找点在右子树， change(k&lt;&lt;1|1,d,x); //k&lt;&lt;1|1为右子树 tree[k].maxnum=max(tree[k&lt;&lt;1].maxnum,tree[k&lt;&lt;1|1].maxnum); //递归从新计算非叶结点的值 &#125;int query(int k,int l,int r)&#123; int maxnum; if(tree[k].l==l&amp;&amp;tree[k].r==r) return tree[k].maxnum; int mid=(tree[k].l+tree[k].r)&gt;&gt;1; if(r&lt;=mid) maxnum=query(k&lt;&lt;1,l,r); else if(l&gt;=mid+1) maxnum=query(k&lt;&lt;1|1,l,r); else maxnum=max(query(k&lt;&lt;1,l,mid),query(k&lt;&lt;1|1,mid+1,r)); //中线跨区间 return maxnum;&#125;int main()&#123; while(~scanf("%d%d",&amp;n,&amp;m)) &#123; memset(tree,0,sizeof(tree)); for(int i=1;i&lt;=n;i++) &#123; scanf("%d",&amp;a[i]); &#125; build(1,1,n); for(int i=1;i&lt;=m;i++) &#123; scanf("%s%d%d",ch,&amp;d,&amp;x); if(ch[0]=='Q') //查询输入 &#123; printf("%d\n",query(1,d,x)); &#125; else change(1,d,x); &#125; &#125;&#125; 收获与反思 对模板的理解都写在注释里了 本题是维护最大值，可以用int替换ll 切记memset数组]]></content>
      <categories>
        <category>编程</category>
        <category>ACM</category>
      </categories>
      <tags>
        <tag>ACM</tag>
        <tag>算法</tag>
        <tag>2018春季训练</tag>
        <tag>HDU</tag>
        <tag>线段树</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[【CSU-1977】解题报告（二进制，位运算，读题》]]></title>
    <url>%2Fpost%2F4f352d.html</url>
    <content type="text"><![CDATA[原始题目Bit-reversal Permutation Time Limit: 1 Sec Memory Limit: 128 Mb Submitted: 81 Solved: 27 DescriptionA fast Fourier transform (FFT) algorithm computes the discrete Fourier transform (DFT) of a sequence, or its inverse (IFFT). Fourier analysis converts a signal from its original domain (often time or space) to a representation in the frequency domain and vice versa. An FFT rapidly computes such transformations by factorizing the DFT matrix into a product of sparse (mostly zero) factors. As a result, it manages to reduce the complexity of computing the DFT from O(n2), which arises if one simply applies the definition of DFT, to O(nlogn), where n is the data size. ——From Wikipedia During this summer holiday, csuxushu feels so bored to learn FFT. Because FFT is a complicated algorithm, he need to apply a bit-reversal permutation to a sequence first before DFT which is a part of FFT. In applied mathematics, a bit-reversal permutation is a permutation of a sequence of n items, where n = 2^k is a power of two. It is defined by indexing the elements of the sequence by the numbers from 0 to n − 1 and then reversing the binary representations of each of these numbers (padded so that each of these binary numbers has length exactly k). Each item is then mapped to the new position given by this reversed value. Because all fellows in CSU(California State University ) can apply FFT, NTT or even FWT, it is a shame that he even doesn’t know how to take the first step. As one of the best computer programmer in CSU, can you help him? You may think this problem is too hard to solve. In fact, it is a piece of cake to you. Remember to see the hint :-) InputThe first line of the input gives the number of test cases T(T≤10); T test cases follow.Each test case contains a number sequence.In each case, the first line is a number N(1≤N≤10^5), the number of elements in the following sequence.The second line is the sequence.Its length may not be exactly a power of two, so you can append some zeros to make it the minimal power of two larger than or equal to N. OutputFor each test case, output the sequence from input in bit-reversal order. Sample Input1 6 21 58 96 12 45 65 Sample Output21 45 96 0 58 65 12 0 HintBit-reverse Order （图片待添加） 中文提示：可以看到，我们最终处理的系数从左至右的编号的二进制形式分别为000,100,010,110,001,101,011,111，若将其二进制反序，可得000,001,010,011,100,101,110,111，这些反序的二进制编码是从小到大排列的。也就是说，我们可以按照每个下标的二进制编码来确定处理系数的顺序。这种方法就称为位逆序置换(Bit-reversal permutation)。 Source2017年8月月赛 Author徐戍 题目大意将给定序列按位反转后的顺序输出 解题思路看中文提示和图示就能不明白，将序列顺序（从0开始）用二进制位表示后位反转，按反转后从小到大顺序输出。 解题代码123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051#include &lt;cstdio&gt;#include &lt;cstring&gt;#include &lt;set&gt;#include &lt;cmath&gt;#include &lt;map&gt;#include &lt;queue&gt;#include &lt;algorithm&gt;#include &lt;map&gt;using namespace std;const int maxn=2e5+5;int raw[maxn];int t;int m,n;int main()&#123; while(~scanf("%d",&amp;t)) &#123; while(t--) &#123; scanf("%d",&amp;m); &#123; n=0; memset(raw,0,sizeof(raw)); while(pow(2,n)&lt;m) n++; for(int i=0;i&lt;m;i++) &#123; scanf("%d",&amp;raw[i]); &#125; int len=pow(2,n); for(int i=0;i&lt;len;i++) &#123; int bit=0,b=i; for(int j=0;j&lt;n;j++) &#123; bit=bit|(b&amp;1); b&gt;&gt;=1; bit&lt;&lt;=1; &#125;// printf("bit=%d\n",bit); bit&gt;&gt;=1; if(i==0) printf("%d",raw[bit]); else printf(" %d",raw[bit]); &#125; printf("\n"); &#125; &#125; &#125;&#125; 收获与反思用二进制计算方法（按位与、按位或、左移右移），来替代pow(2,n)。否则超时比如将序号进行位反转后再十进制化的代码。 // b为原始序列号 bit为位反转再十进制化的序列号 int bit=0,b=i; for(int j=0;j&lt;n;j++) { bit=bit|(b&amp;1); b&gt;&gt;=1; bit&lt;&lt;=1; } 这一过程不要用 int bit=0,b=i; for(int j=0;j&lt;n;j++) { if(b&amp;1) bit+=pow(n-1-j); b/=2; } //乘方会慢很多很多]]></content>
      <categories>
        <category>编程</category>
        <category>ACM</category>
      </categories>
      <tags>
        <tag>ACM</tag>
        <tag>算法</tag>
        <tag>2018春季训练</tag>
        <tag>CSU</tag>
        <tag>位运算</tag>
        <tag>补图</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Hello Hexo]]></title>
    <url>%2Fpost%2Fa1751c09.html</url>
    <content type="text"><![CDATA[今日博客搬家 bing 基于Hexo-Next-Gemini 还在搬运Evernote和CSDN上的东西 还有很多功能没有添加，欢迎各位提意见]]></content>
  </entry>
  <entry>
    <title><![CDATA[《1Q84》读书笔记]]></title>
    <url>%2Fpost%2F280fbdcb.html</url>
    <content type="text"><![CDATA[内容摘录第一部 P371 “世界这个东西，青豆啊，就是一种记忆和相反的另一种记忆永无休止的斗争。” 第二部 P262 “人的生命虽然本质上是孤独的存在，却不是孤立的存在。” P270 “但店内除了天吾，只有一对像是大学生的青年男女并肩坐在吧台前，正在交头接耳，起劲地说着悄悄话。望着他们，天吾感到了许久不曾有过的深深地寂寞。在这个世界上，自己是孤独的，和谁都没有关联。” P274 “我当时看见了月亮。青豆也看见了同一个月亮。浮在下午三点半依然十分明亮的天上的灰色岩块。沉默而孤独的卫星。两人并肩而立，望着那个月亮。但是，那究竟意味着什么？难道月亮会领我去青豆所在的地方吗？” P276 “天吾专注着望着月光，心中从远古时代传承下来的记忆般的东西被唤醒了。远在人类获得火、工具和语言之前，月亮就始终不变地是人们的朋友。它作为天赐地灯火，不时照亮黑暗的世界，缓解了人们的恐惧。它地圆缺给了人们时间观念。对月亮这种无偿地感谢之情，纵然在黑暗已从绝大部分地域驱逐的现在，似乎依然牢牢烙印在人类的遗传因子里。作为一种温暖的集体记忆。” P311 “我隔着一条马路看到了她，还因为可能被他拥入怀中而颤抖。虽说只有几分钟，我毕竟也全身心地题为过那种激烈的喜悦和期待。她闭上眼睛，紧攥着滑梯的扶手，咬住嘴唇。” P312 “不过这将无所谓。我将为他而死。我不能为自己而活，这种可能性从一开始就被剥夺了。可是，我却能为他而死。这样就够了。我可以微笑着去死。 这不是谎言。” P338 “他像被遗弃在风暴逝去后的静谧中，无法在任何事物上集中精神。” P341 “父亲依旧纹丝不动，他的双眼被牢牢封闭在那黑暗地深坑底部，望去仿佛在静静地等待降雪，将深坑填成白色。” Emmm…我喜欢带鼓点的纯音乐，因为在不知哪个关键的时刻，想起的鼓点声总能巧妙地切合这个场景。 P350 “这二十年间，他心里时时刻刻装着这位少女的面容。 青豆，天吾叫出声来。 少女沉在深深的睡眠中。似乎是很深的自然的睡眠，连呼吸都极其微弱。她的心脏也只是轻微地鼓动着，虚幻得传不到人的耳朵里。甚至连抬起眼睑得力量都没有……青豆在遥远的地方听见了这呼唤。天吾君，她在心中念道，还清晰地呼出声来。但这句话却不会掀动躺在空气蛹中少女的嘴唇，也不会传入天吾的耳朵。”]]></content>
      <categories>
        <category>阅读</category>
      </categories>
      <tags>
        <tag>阅读</tag>
        <tag>小说</tag>
        <tag>村上春树</tag>
        <tag>1Q84</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[《黑豹》观后感]]></title>
    <url>%2Fpost%2F4255f31a.html</url>
    <content type="text"><![CDATA[总的来说，是近几年漫威出的质量比较高的一部电影了，没有过分卖腐，卖情怀。一点点人格之间的矛盾，一点点反思，剧情衔接也很不错，虽然有一点套路，但是在可接受的范围内。 表弟Killmonger让我想起了铁血孤儿团三日月一众人，还有麦基利斯。悲情么？悲情。可惜么？不可惜。他们的行为注定是孤独的悲情的，但欣慰的是他们的死亡是注入世界的一剂良药，让目睹他们死亡的人能感受到他们心中那一点点不同，然后做出改变（就像黑豹和艾里安议长）。或许人们不会记得他们，但历史会。 黑豹带表弟去看生命中第一次也是最后一次瓦坎达的日落，是为自己的父亲赎罪，也是对叔叔的缅怀。他将不在时电影开头的那个黑豹，从此，父亲与叔叔的两种感情将汇聚在他一人身上。月型草被一把火烧了个干干净净，或许他死后也不会再去自己父亲那里了吧。 但是表弟最后嘴里说出的那句“不自由，毋宁死”确实是把原文的意思曲解了。去Google了一下。原句是这样的 “Bury me in the ocean with my ancestors who jumped from ships, cause they knew death was better than bondage,” 我个人更倾向于表弟想表达的是：不愿意在此处与瓦坎达独享安宁（在他眼里是一种绑架，被历史、被先祖的传统绑架），的不自由（矛盾的焦点不在于他们是否拥有走出瓦坎达的边境的freedom，而在于是否应该向外输出自己的科技，武装世界其他角落受压迫的黑人对）。而且，“不自由，毋宁死.”这一句本是美国独立战争时期，Patrick Henry在弗吉尼亚议会演讲的最后一句“Give me liberty or give me death.”的翻译。 忙里偷闲独自看一场电影，还不错。]]></content>
  </entry>
  <entry>
    <title><![CDATA[《亲爱的安德烈》读书笔记]]></title>
    <url>%2Fpost%2Ffd581850.html</url>
    <content type="text"><![CDATA[内容摘录认识一个十八岁的人 P4 “虽然心中有爱，但是爱，冻结在经年累月的沉默里，好像一个疼痛的伤口，没有纱布可绑。” P5 “我们是两代人，中间隔个三十年。我们也是两国人，中间隔个东西文化。我们原来也可能再他十八岁那年，就像水上浮萍一样各自荡开，从此天涯淡泊。 日后的人生旅程，当然还是要漂萍离散——人生哪有恒长的厮守？但是三年的海上旗语，茹月色满怀，我还奢求什么呢。” 第1封信 十八岁那一年 P13 “那‘愚昧无知’的渔村，确实没有给我知识，但是给了我一种能力，悲悯同情的能力。” P14 “你们这一代‘定锚’的价值是什么？终极的关怀是什么？你认为美丽的热带鱼游泳也要在P乎方向吗？或者，你要挑衅地说，这是一个无谓的问题，因为热带鱼只为自己而活？” 第3封信 逃避国家 P21 “觉得德国是个不错得国家这种感觉是没有人敢显露，大家都要藏起来的。” P25 “如果是五十个德国人在街上大喊‘德国第一；’德国万岁‘，会把人给吓死，第二天可以上《纽约时报》了，对吧？” 第5封信 对玫瑰花的反抗 P37 “玩，可以说是天地间学问的根本。” 第6封信 一切都是小小地 P41 “每个人都在走自己的路，每个人都在选择自己的品味， 搞自己的游戏，设定自己的对和错的标准，一切都是小小的、个人的，因为，我们的时代已经不在有’伟大‘的任何特征。” 第7封信 有没有时间革命？ P48 “这世上/没有真实世界这回事/只有谎言/迫使你设法穿越” 第8封信 我是个百分之百的混蛋 P56 “世界上那么多不公正的存在，怎么可能没有‘反叛’的需要？所差的只不过在于你是否愿意看见，是否愿意站起来，行动不行动而已” P56 “至少，我清楚看见自己的生存状态，而且至少，我并不以我的生存状态为荣。” 第9封信 两种道德 P63 “这些国家里的人民，准许，或说要求，他们的政府把大量的钱，花在离他们很遥远但是贫病交迫的人们身上。” 第11封信 阳光照进你的路 P79 “对美的迷恋可以打败任何智者自以为是的心得报告。我只能让你跌倒，看着你跌倒，只能希望你会在跌倒的地方爬起来，希望阳光照过来，照亮你藏着忧伤的心，照亮你眼前看不见尽头的路。” 第13封信 向左走，向右走 P93 “然而母亲想念成长的孩子，总是单向的；充满青春活力的孩子奔向他人生的愿景，眼睛热切望着前方，母亲只能在后头张望他越来越小的背影，揣摩，那地平线有多远，有多长，怎么一下子，就看不见了。” 第14封信 秘密的、私己的美学 P101 “流行文化经过时间的筛子，泥沙被淘汰，金块被留下，留下的就叫做经典或古典……” （文化，大浪淘沙） 第16封信 藏在心中的小镇 P112 “所以我坐在这阳台上，细细回想我们共有的美好时光，把回忆拥在心里，是得往前走，但是直到我从哪里来。” 第17封信 你是哪国人？ P116 “‘逃民’被时代的一把剑切断了她和土地、和传统、和宗族友群的连结韧带，她漂浮，她悬在半空中，因为，她也许对这个世界看得特别透彻，因为她不在友群里，视线不被挡住，但是她处在一种灵魂的孤独中。” P116 “她不要你和她一样，做一个灵魂的漂泊者——那也许是文学的美好境界，却是生活的苦楚。” P118 “可是不管国家这种单位发生了什么根本的变化，有了或没了，兴盛了或灭亡了，变大了或变小了，安德烈，小镇不会变。泥土和记忆不会变。 我很欢喜你心中有一个小镇，在你驶向大海远走高飞之前。” 第20封信 在一个没有咖啡馆的城市里 P134 “酒吧跟咖啡馆，在欧洲，其实就是社区文化。朋友跟街坊邻居习惯去那里聊天，跟老板及侍者也像老友。香港却显得很‘浅’——不知道这个词用得对不对。这里没有咖啡馆，只有蹩脚的连锁店星巴克和太平洋咖啡，要不然就是贵的要死其实根本不值得的大饭店。” P135 “人跟人之间愿意花时间交流，坐下来为了喝咖啡而喝咖啡，为了聊天而聊天，在欧洲是生活很大的一部分，是很重要得一种生活艺术。香港没有这样的生活艺术。” 第21封信 文化，因为逗留香港印象 P144 “那天很热，我背着很重的书，一条街一条街寻找，以为和台北一样，转个弯一定可以看到。可是没有。真的没有。去茶餐厅吧，可是那是一个油腻腻、甜滋滋得地方，匆忙拥挤而喧嚣，有人硬是站在你旁边瞅着你的位子。去星巴克或太平洋吧，可是你带着对跨国企业垄断得不满，疑惧他们对本土产业的消灭。不情愿在那里消费。” P145 “我们在谈的这个所谓‘咖啡馆’，当然不只是一个卖咖啡得的地方，它是一个‘个人’开的小馆，意思是，老板不是一个你看不见摸不着的抽象财团，因此小馆里处处洋溢着小店主人的气质和个性；它是社区的公共‘客厅’，是一个荒凉的大城市里最温暖的小据点。来喝咖啡的人彼此面熟，老板的绰号人人知道。如果因缘际会，来这里的人多半是创作者——作家、导演、学者、反对运动家……那么咖啡馆就是这个城市的文化舞台。” P146 “这个城市，连群众示威的大广场都没有。群众示威，和咖啡馆酒吧里的彻夜闲聊一样，是培养社区共识的行为，对加深文化认同多么关键。示威游行，绝对是极其重要的一种‘逗留文化’。但是，香港是个没有闲人，‘请勿逗留’的城市。” 第22封信 谁说香港没文化？ P156 （读者来信）“在你们的文章中，一再提到咖啡馆，并说明欧洲的咖啡馆出过多少名人。我想来想去，的确想不出，中国历史上这么多著名的文人学者，有谁是在咖啡馆完成大作的。但，他们就因为没有在咖啡馆沉思过，就不能获得你们的认同吗？今天和今后，东方的咖啡馆还是无法和西方咖啡馆相比，但东方的文化今天的成就与未来，就肯定将因此而逊色和不被看好吗？”（个人感触：龙应台先生和安德烈先生来往信件中提到的咖啡馆，代表这一类能给人以文化气息，静下来逗留的场所。既然台北和香港都属于东方地域中受西方文化影响最为深远的城市，作为西方许多文化甚至文明诞生发展的一大影响因素，分布在各个城市角落里的这些充满个人气息的“咖啡厅”，理应也被吸纳进两个城市的发展洪流中。然而事实是，并没有。不知道是怎样的一种过滤方式，这些文明根源的事物就这么被无情的抛掉了，不禁令人遗憾和惋惜。诸子百家以及之后几百年内的各个中国古代先贤，自然不是在咖啡厅里完成自己的大作的，可以是旷野的星空下，可以是周游马车上，但无疑，他们需要这样一个与他人，或者与自我，静下来，慢慢交流咀嚼的契机。西方的工业革命把生产力水平不知翻了多少倍，人们的生活节奏也自然被迫推着加速着，加速着。但是就是这么神奇，历史的车轮再快，也巧妙地避开了城市地一个个咖啡厅，保留了这一份每个人奢求地文化角落，这种保留是奢侈的，也是必要的。） 第26封信 孩子，你喝哪瓶奶？ P177 “你从坏的吃起，到明天，那好的也逐渐变坏了，结果你就一路在追赶那坏的，你永远在吃那不新鲜的苹果。你为什么不能就直接享受那最好的呢？” P179 “请问品味是什么？它不就是细致的分辨、性格的突出，以及独立个体的呈现吗？每一件，都正好是贫穷所吝啬给你的，也是威权政治所剥夺于你的。” P180 “如果太好的环境赋予了你美感和品味，那么它剥夺了你些什么？你的一切，是否其实有另一种的‘贫穷’？” 第28封信 给河马刷牙 P195 “对我最重要的，安德烈，不是你有否成就，而是你是否快乐。而在现代的生活架构里，什么样的工作比较可能给你快了？第一，它给你意义；第二，它给你时间。你的工作是你觉得有意义的，你的工作不绑架你使你成为工作的俘虏，容许你去充分体验生活，你就比较可能是快乐的。至于金钱和名声，哪里是快乐的核心元素呢？假定说，横在你眼前的选择，是到华尔街做银行经理或者到动物园做照顾狮子、河马的管理员，而你是一个喜欢动物研究的人，我就完全不认为银行经理比较有成就，或者狮子、河马的管理员‘平庸’。每天为钱的数字起伏而紧张而斗争，很可能不如每天给大象洗澡，给河马刷牙。” P195 “当你的工作在你心目中有意义，你就有成就感。当你的工作给你时间，不剥夺你的生活，你就有尊严。成就感和尊严，给你快乐。” P195 “我怕你变成画长颈鹿的提摩，不是因为他没钱没名，而是因为他找不到意义。我也要求你读书用功，不是因为我要你跟别人比成就，而是因为，我希望你将来会拥有选择的权利，选择有意义、有时间的工作，而不是被迫谋生。” P195 “如果我们不是在跟别人比名比利，而只是为自己找心灵安适之所在，那么连‘平庸’这个词都不太有意义了。‘平庸’是跟别人比，心灵的安适是跟自己比。我们最终极的负责对象，安德烈，千山万水走到最后，还是‘自己’二字。因此，你当然更没有理由去跟你的上一代比，或者为了符合上一代对你的想象而活。” 第29封信 第二颗眼泪 Kitsch让两颗眼泪快速出场。第一颗眼泪说：孩子在草地上跑，太感动了！第二颗眼泪说，孩子在草地上跑，被感动的感觉实在太棒了。跟全人类一起被感动，尤其棒！使Kitsch成为Kitsch的，使那第二颗眼泪。——《生命中不能承受之轻》 “还好昆德拉说，那第一颗眼泪不是，第二颗才是Kitsch。” 第31封信 两只老虎跑得慢、跑得快 “‘你以后一定不能忍受城乡差距、贫富不均所带来的不公平。’也就是说，‘失败启蒙’给我的教训，不是打入‘成功者’的行列，而是，你要去挑战，去质疑‘成功者’的定义。” 第33封信 人生诘问 “安德烈：我想知道，你怎么面对人家总是期待你有思想、有智慧这个现实？ 安德烈，一半的人在赞美我的同时，总有另外一半的人在批判我。我有充分机会学习如何‘宠辱不惊’。至于人们的‘期待’，那是一种你自己必须学会去‘抵御’的东西，因为那个东西是最容易把你绑死的圈套。不知道就不要说话，傻就不假装聪明。你现在明白为何我推掉几乎所有的演讲、座谈、上电视的邀请吧？我本来就没那么多知识和智能可以天天去讲。” 第35封信 独立宣言 不繁文缛节，却也不失礼貌，给人以必要的人格尊重，这就是你要做的。 在时光里 “‘马克·吐温说，’安德烈伸手拿起一粒绿色的橄榄，放在嘴里，似乎在品尝，然后慢条斯理地说，‘我评判一个人的品格，不看他如何对待比他地位高地人，我看他如何对待比他地位低地人。’”]]></content>
      <categories>
        <category>阅读</category>
      </categories>
      <tags>
        <tag>阅读</tag>
        <tag>龙应台</tag>
        <tag>书信</tag>
        <tag>安德烈</tag>
        <tag>亲爱的安德烈</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[《岛上书店》读书笔记]]></title>
    <url>%2Fpost%2F11246bdd.html</url>
    <content type="text"><![CDATA[书中书目 P97《白鲸》 赫尔曼·麦尔维尔 P99《古拉格群岛》 索尔仁尼琴 P99《纳尼亚传奇》系列 C.S.刘易斯 P107 《洛城机密》詹姆斯·埃尔罗伊 犯罪小说 P119 《真爱如血》电视剧 P132 《好人难寻》弗兰纳里·奥康纳 P135 《卡拉维拉显驰名的跳蛙》 马克吐温 P135 《所罗门之歌》 托妮·莫里森 P135 《奥丽芙·基特里奇》 伊丽莎白·斯特鲁特 P183 《与父亲的对话》 格蕾斯·佩利 P197 《逮香蕉鱼的最佳日子》 J.D.塞林格（A.J.谈到对玛雅作品的建议，移情，为什么人们会做他们想做的事？ P209 《泄密的心》 埃德加·爱伦·坡 P213 《我们的小镇》 桑顿·怀尔德 P216 《德伯家的苔丝》《约翰尼上战场》《永别了，武器》《为欧文·米尼起到》《呼啸山庄》《织工马南》《他们眼望上苍》《我们的秘密城堡》 P223 《铁头》 艾梅·本德 P235 《追忆似水年华》 马塞尔·普鲁斯特 P246 《尘雾家园》 安德烈·迪比三世 P249 《当我们谈论爱情时我们再谈论什么》 雷蒙德·卡佛 P257 《书店老板》 罗尔德·达尔 P269 《美国众神》尼尔·盖曼 因为从心底害怕自己不值得被爱，我们独来独往，然而就是因为独来独往，才让我们以为自己不值得被爱。有一天，你不知道是什么时候，你会驱车上路。有一天，你不知道是什么时候，你会遇到他（她）。你会被爱，因为你今生第一次真正不再孤单。你会选择不在孤单下去。 内容摘录 P210 “一个地方如果没有一家书店，就算不上个地方了。” （AJ 和妮可） P266 “没有书店的地方算不上是个地方。”（兰比亚斯和伊斯梅） P261 他会再试试，他永远不会放弃尝试。“玛雅，我们会成为我们所爱的那样。是爱成就了我们。” 玛雅在摇头。“爸爸，对不起，我听不明白。” “我们不是我们所收集的、得到的、所读的东西，只要我们还或者，我们就是爱，我们所爱的事物，我们所爱的人。所有这些，我认为真的会存活下去。” 她还在摇头。“我听不懂你的话，爸爸。我希望我能。你想让我找艾米吗？要么也许你可以打出来？” 他在冒汗。交谈不再是有趣的，以前曾经很容易。好吧，他想。如果必须用一个单词，那就必须用一个单词吧。 ”爱？”他问。他祈祷自己说得对。 她皱起眉头，努力去辨读他的表情。“手套？”她问，“是你的手冷吗，爸爸？” 她点点头。她把她的手放在她手里。他的手本来冷，这时暖和了，他想好了今天说的够接近了。也许明天，他就能知道该怎么说了。]]></content>
      <categories>
        <category>阅读</category>
      </categories>
      <tags>
        <tag>阅读</tag>
        <tag>文学，小说</tag>
        <tag>岛上书店</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[《1988：我想和这个世界谈谈》读书笔记]]></title>
    <url>%2Fpost%2Ffdc06f3f.html</url>
    <content type="text"><![CDATA[内容摘录 P45 “我说，丁丁哥哥，你去做什么啊？ 丁丁哥哥说，我去和他们谈谈。 我说，你和谁谈谈啊？ 丁丁哥哥唇边露出微笑，急切地说，这个世界。” P62 “这样的旅行在我年少时曾经幻想过无数次，夜晚的国道李，我等待着自己梦寐以求的女子，开着自己梦寐以求的车，去往未知旅程的终点。未知旅程怎么会有终点，旅途上没有疲劳和困意，我们聊着电影和音乐，穿越群山和丛林，最终停在一泓无人的湖水旁边，有一个没有任何经济头脑的人开的酒店，干净便宜。” P86 “混乱的地面道路是最好的地方。1988就像我周围的人，国道就像这个杂乱的世界，在越无序的地方，我越能寻觅到安全感。这安全感的代价就是你要时刻集中精神，否则你就会被庞大的交通工具碾过。” P87 “生活它不是深渊，它是你走过的平原和你想登上的高山，它就像我们睡过的每一张床，你从来不会陷下去，也许它不属于我们，但它一定属于你，你觉得它在往下，是因为引力，它绝不会把你拖下深渊，它指向让你伏在地上，听听它的声音，当你休息好了，听够了，你随时可以站起来，你懂吗？” P97 “小学的离别，那是最不能知道你身边的人未来将变成一个什么样的人的时刻。” 这句话是后面很多故事开展的一个引子。 P98 “在一个陌生的环境里，我可以重新塑造一遍我自己，没有什么事不会改变的，我上一个角色已经演完了，这是我接的新戏。” P124 “我说：‘……但难道就没有人正儿八经的做新闻么？’ 朋友说，都有，每一拨李都有那么几个。 我说，那那些在哪里？ 朋友说，辞退了。” P124 “我坚信邪恶不能压倒正义……嗯。但是他们可以定义正义和邪恶。” P126 “你相信么，在这样一个世界里，你用脑子想过的事情，你总是以为你已经做过了，” P127 “其实温水煮青蛙是一个错误的俗语，温水煮不了青蛙的……不要拿青蛙给现实改变自己找借口，温水是煮不了青蛙的，青蛙没有那么蠢，这就是现实。”不是显示改变了自己，你很强，你没有跳出来，只是你自己不想，事你自己屈服，自己变了。 P141 “我早就想通了，人们埋怨一成不变，但也埋怨居无定所，人其实都无所谓，只要是给日子找点岔子而已，似乎只有违背现在的生活，才真正懂得了生活，生活就是一个婊子、一个戏子。一个你能想到的一切，你所有的比喻就在里面扔吧，你总是对的。因为生活太强大了，最强者总是懒得跟你反驳，甚至任你修饰，然后悄悄地把锅盖盖住。” P163 “当我的生命力只能讲一个故事的时候，我愿将这个故事说出来，这个故事平淡无奇，平铺直叙，既没有曲折，也没有高潮，也就是寻找，相识，分开，就如同走在路上看见一盏红绿灯一样稀松平常，但若驻足，你会发现，它永远闪着黄灯。我就一直看着这盏信号灯，在灯下等了很久，始终不知道黄灯结束以后将要亮起的是红色还是绿色，一直等成了一个红绿色盲。” P164 “我不知道是否有一种很奇怪的感情，它深到你想去结束它，或者冰封它。只因为它出现在错误的时间里，于是你要去等待一个正确时间重启它，而不是让错误的时间去消耗它。少则一天，多则一生。” P177 “移动着的人永远比固定着的人更]]></content>
      <categories>
        <category>阅读</category>
      </categories>
      <tags>
        <tag>阅读</tag>
        <tag>小说</tag>
        <tag>韩寒</tag>
        <tag>1988：我想和这个世界谈谈</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[《水滴直播，让你我的隐私再也不滴水不漏》]]></title>
    <url>%2Fpost%2F75794199.html</url>
    <content type="text"><![CDATA[无意间从朋友圈里看到了一条说说，主体内容是一段搬运自微博：“嘻哈公社”的自媒体采访视频，很短，但简单，却很现实。不知道是不是因为上了大学，看新闻的时间少了，还是真的社会已经适应了这种“直播”的存在，而我成了另类？ 抛开直播圈的其他乱象不说（你们都懂，某平台的某些知名主播的蛇皮操作，各种公关闹剧简直是一出年末大戏），我一直以为直播和生活的界限还是分的很开的。直播归直播，那是镜头上的人物，是在表演，可以有感情的虚假，可以有套路，可以有剧本，起码和“生活”总隔着一个界限。这个界限，你说不出是个怎样的存在，但都能感觉到它在这里，真实的在这里。 我也依稀记得斗鱼之前有过一个户外板块（不知道现在是否还存在），专门供主播分享户外生活的点点滴滴，直播里自然会出现其他“路人”，不过“路人”们都清楚的明白，有一个手持的直播设备在对着自己，无论愿意还是不愿意，至少，他们都是知情者，清楚自己已经穿过那条“界限”，站在这个直播平台提供的“舞台”上，成为了万千观众眼中的表演者。 然而，我从未想到过，我会被剥夺这份知情权，被永远剥夺。 某天，你打开某上市公司的直播平台 你会惊奇的发现 镜头上表情呆滞的自己， 柜台前输入密码的自己， 和密友讨论私事的自己， 表演出丑后尴尬的自己， 买东西犹豫不决的自己， 和那个他/她亲热的自己， 失恋后酒吧买醉的自己， 而且，不仅有你自己，还有无数磕着瓜子吃着西瓜，以单身不知多少年的手速敲击键盘，享受着这种360度全方位无死角的窥屏狂魔们。你生活的一切横截面，无论你想或不向，都会成为这些人的娱乐自我的资源。 我从不认为有错的技术，只有错的人与错误的利用方式。 谢谢水滴直播，谢谢周总，让我明白《楚门的世界》有机会成为现实。 谢谢水滴直播，谢谢周总，让我知道天网监控对个人隐私的侵害是多么的彻底。 谢谢水滴直播，谢谢周总，让我知道删掉360不仅是对电脑的保护，更是对自我的保护。 谢谢水滴直播，谢谢周总，让我知道身边的一切private things是多么的宝贵。]]></content>
      <categories>
        <category>随笔</category>
      </categories>
      <tags>
        <tag>随笔</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[读《还好我不是新加坡人》有感 转自新浪微博]]></title>
    <url>%2Fpost%2F662b8b80.html</url>
    <content type="text"><![CDATA[作者龙应台是台湾著名社会批评家，八十年代她在宝岛“放火”，一时间名声大噪，那本《野火集》让她从此广为人知。而上世纪九十年代，她又在新加坡“放火”,写下了这么一篇极具争议性的文章。 龙应台一向以文笔犀利老辣，说话微言大义而出名，这篇文章显然也有这一特点。细细读来，这篇杂文和她的大多数作品一样，都是着一时事或是小事出发，从而牵引出一个相当大的命题。在本文中她先是提出对新加坡外长在国际会议上以亚洲人代表自居，将狮城文化等同于亚洲文化的不满，在此基础上，她开始批判新加坡的某些法律条文和政府政策。其中最一针见血的要属那句：“给我再高的经济成长，再好的治安，再效率十足的政府，对不起，我也不愿意放弃我那一点个人自由与尊严。” 意料之中的，这篇短文遭到一片骂名。龙应台觉得委屈，另外发文称自己将主要火力放在了外长未经其它亚洲人考据和同意就把自己、乃至把新加坡当作亚洲代表这一点上，她不满外长以亚洲之名发出新加坡人的声音。然而，令那些愤怒的新加坡人真正不满的却是她在文章最后对于狮城的举例讽刺与挖苦。 在我想来，在这场唇舌交战中无论作者还是读者都有点小题大做的嫌疑。众所皆知，一篇好的批判性文章必须夺人眼球，因此，这篇文章的标题和结尾必须令人眼前一亮。龙应台不满自己的亚洲人身份“被代表”，这体现了她尊重人权、支持自由的一面，当然这与她的身份和多年留洋经历是分不开的。而想想新加坡文化与西亚文化、印度文化的巨大差别，让它来代表亚洲人说话的确有点名不正而言不顺。但实际上，我们也必须承认，在特定场合里，让新加坡代表亚洲人说法也未尝不可，本来这就是个多民族的国家，它的文化融合了中华文化、马来回教文化、印度文化，作为亚洲文化的大熔炉，在非正式场合把自己当代表那还是有点说服力的，我们不也常常理直气壮地说“我们亚洲如何如何”吗？但鉴于那是在国际官方会议上的讲话，加之明明知道事后会被西方媒体大肆渲染一番，这为代表实在不合适。 再看那最令狮城人民不满的部分，即龙应台对狮城政策的批判，说真的这部分占全文的比例并不大，又何以一石惊起千层浪呢并且几无附和龙文之音呢?对此龙应台的解释是：一是新加坡人确实比较满意于现状，乐于接受由权威政府领导的生活方式；或者，在权威的笼罩之中，不同基调的声音根本还不敢冒出来。”我觉得这两个原因都有可能。的确，新加坡这个蕞尔小国近几年的发展倍受瞩目，亚洲四小龙之一的实力实在不容小觑。有很多人都在羡慕“花园城市”的廉政与洁净。短短几十年就有了如此大的进步和成就，狮城人民很有可能是对政府十分满意甚至是充满感恩的。当然，这并不代表这个国家就没有问题，但是很明显这种政体、甚至是这份普遍的感激都极有可能成为“敢怒而不敢言者”沉默的原因。所以说，第二个假设也可以成立。 这么说来，是龙应台恶意赚取噱头，鸡蛋里挑骨头了？当然不是。我们必须承认她的出发点是善意的，甚至可以说是极具理想化的，事实上无论在哪一个国家，知识分子愿意为社会的鸡毛蒜皮小事而生气、而发出批判之声，这是一件很幸运的事情，何况和她当年批判台湾相比，这篇文章已经很客气。正因我们身处于这样不够完美的社会与时代，我们才应该对小事看不顺眼、对琐事斤斤计较—只要我们都是为了让这个社会变得更好。批评，让学者们慎思、明辨。也正因如此，当今不少学者都认为，将眼下大热的龙应台和周国平放在一起，两者固然没什么可比性，但是对青年人而言，读多一点龙应台也许会对这个国家更有益。如果硬要就新加坡到底好不好来说，或许只能是：子非鱼安知鱼之乐。 读罢这篇杂文，我想这其中还有很多东西值得我们深思：同是一个多民族国家，新加坡何以拥有这么强的核心凝聚力？再者，如果连这般清廉、法制完善的新加坡都被人这样批评，我们正在崛起的中国又该何去何从？换句话说，如果现在让龙应台来批判中国大陆，她又会有多少文章可作？ 一番深思熟虑后，我想我最欣赏的还要属新加坡《联合早报》，它居然胆敢在本国报纸上刊登这么一篇必将刺痛人民神经的文章。我也钦佩龙应台，她居然胆敢在自己的文集里放进这么多批评自己的文字。看似是拿自己的手打了自己的脸，但为何此时此刻，我有种回到百家争鸣时代的错觉呢?]]></content>
      <categories>
        <category>随笔</category>
      </categories>
      <tags>
        <tag>随笔</tag>
        <tag>读后感</tag>
        <tag>龙应台</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[《野火集》读书笔记]]></title>
    <url>%2Fpost%2Fa4efe87.html</url>
    <content type="text"><![CDATA[内容摘录 P10 “说穿了，龙应台所传承、传递的野火，其实就是一种乌托邦的想象。教导我们在现代的荒原上培养价值的火种，批判的火种，或点灯或放火，在众多的小天地和大天地，边缘和中间之间，找到一种新的文化串联的策略……”《野火集》中野火的多层含义，一方面是指如同普罗米修斯为人类带来神火，龙应台给台湾带来思想与意识观念的”野火“，她这个”盗火的玉娇龙“，背负着维护古典价值的使命，在哪个时代挂起漫野的星星之火。 P11 “如福柯所说，我们一再发现自己处于开始的位置；因为这样，我们更应该一起思索未来，以新的火焰挑战者、文化挑战者为己任，化被动为主动，大力叩问个体生命的意义，将我们共同的困境，化成一场戏剧性的自我追寻，扩张梦想的蓝图和坐标，脚踢东西文明，甚至期待有一天，将龙应台的野火放回西方去。” P24 “……倒觉得八零年代就是太近的昨天，时间很长，路却走得不十分远。” P28 “八零年代，我从台北走到北京，在从莫斯科走到东伯里的大街上，秋色萧萧，已是年代末了。我看见作家在对群众演说，群众在对天空呐喊，天空，默然下起了冷雨，雨水冲洗着人们脸上悲愤激情的泪水。 那是一个最坏也最好的时代，最黑暗也最光明的时代。因为黑暗，所以人们充满了追求光明的力气和反抗黑暗的激情，而且黑白分明，奋斗的目标多么明确。力气、激情、目标明确——八零年代是理想主义风起云涌的时代。只有在得到”光明“之后，在”光明“中面对个人自我的黑暗，发现那黑暗更深不可测，我们才进入了疑惑不安的九零年代，世纪之末。” P31 “个人要从民意的强大束缚中解放出来，要向民意的平庸统治争取不同流俗的权利。极权瓦解之后，压迫着个人的是无数个个人所结成的集体，’民意’.” P31 “梁启超在七十年前说过的话，更令我惊诧其早熟：‘……岂独裁军阀财阀的专横可憎可恨，就是工团的同盟抵抗乃至社会革命还不是同一种强权作用！只不过从前强权，在那一班少数人手里，往后的强权，移在这一班多数人手里罢了。’” P33 “个人，当他是反对者的时候，她不被捕杀就是圣洁的英雄。当他不再是反对者，严酷的测验就来了：他是否能抵挡权力腐化，他是否能承担责任，他是否能容忍异己。许多事实表明：那打破了专制的英雄们竟是无数个专制的个人。个人，才是黑暗的真正来源。” P62 “我爱惜我的学生；像努力迎取阳光的黄色向日葵，他们聪慧、纯洁、奋发，对老师尤其一片真情。但是，他们也是典型的中国学生：缺乏独立自主的个性，盲目服从权威，更严重的，他们没有——完全没有——独立思考的能力。 错在学生吗？ 当然不是。学生是一抔混沌的黏土，在教育者的手中揉搓成形。从小学到大专联考这个漫长过程中的种种问题，暂且不谈，让我们看看这些‘不敢’、‘泪眼汪汪’、‘没有意见’的大学生正在接受什么样的高等教育…….我一直以为大学校长是高瞻远瞩，指导学术与教育大方向的决策人，而不是管馒头稀饭的保姆，但这也暂且不提。这一类型的教育者的用心，毋庸置疑，当然是善意的，问题是，我们论‘事’的时候，用心如何根本不重要，重要的是实际的后果，而教育的后果和其严重！这种喂哺式、育婴式的大学教育刚好吻合心理学家Levy早在一九四三年给所谓‘过度保护’（Overprotection）所作的诠释：第一，给予过多的接触——‘有任何问题，随时来找我’；第二，禁止他独立自主——‘你不许……’；第三，将他‘婴儿化’——‘乖，早睡早起。’；第四，把自己的价值取向加诸其身——‘你听我的……’在这种过度呵护的幼稚教育下成长的大学生，遇事时，除了‘泪眼汪汪’之外又能做什么呢？” 1984，奥威尔的台湾 P117 “要出书时，书稿要送印刷厂了，出版人和我面对面发愁，这一篇，收不收进书里？收进去，可能使整个书被查禁销毁，前功尽弃；不收进去，唉，龙应台实在，实在不甘心！ 夜很深了，我抬起头，说：‘收。’” P120 “那么我们要不要言论自由？这个问题本身大概就是一个忌讳——我们对外号称‘自由’，当然本来就有言论自由，而且是宪法保障的，问‘要不要’简直是自打耳光。可是自打耳光总比等着让别人来打要好得多。” P121 “一方面鼓励学生去努力追求真理，真相。一方面有用各种手段防止学生得到某种知识——学生难道是智能不足。我们希冀他不会发现这两种态度间的严重冲突？这种掩藏式的做法不仅暴露出执政者及教育者的虚伪。而且更可笑的，他根本行不通！思考是追求真理的工具，学生一旦获得这个工具，我们就不可能对他说：你去治学问，但不要碰政治。譬如说一个有能力深思经济问题，文学问题的人，他一定也有能力分析政治问题。反过来说，如果我们执意不让学生在政治问题上刨根问底，唯一的办法就是根本不教他追求真理的原则与方法，不给他‘思考’那个刨根问底的工具——但是这样一来，我们还谈什么教育？” 麦尔教授的老鼠实验——“以不变应万变”的古板愚蠢，甚至还在一代代的加重，“遗传”给后人。 P126 “一个国家，又何尝不是个精神可能崩溃的老鼠？！……如何能不受制于旧习惯、旧观念、就方法，如何不搞‘拧’了去老撞一闪没有乳酪的门而撞得鼻青脸肿，需要的是弹性与智慧。 智慧布政使人之所以为人，鼠之所以为鼠的差别吗？” P131 “在台湾革新很难，一方面固然是由于许多制度的僵化……另外还有保守的执政单位对社会自觉运动的移惧。一个更大的障碍，确实民众本身的缺乏动力。” P142 “‘野火’只有一个简单的要求：撕掉蒙眼布。对‘野火’狂热的反响或许也就传达了那么一个简单但迫切、坚决的讯息：我们不要蒙眼布！让子女，学生，人民都用自己的眼睛去看。自己的头脑去想。” P166 “脱法行为频繁，公权力低落，有一个更根本的原因：执法者与执政者同体……执法者虽然有心执法，但是因为与执政者通体，执法起来就难免背上‘迫害’的大帽子。为了避嫌，只好让法律放个假。” 我的台湾意识 P169 “战前的日本，跟目前的中国台湾一样，所有的教科书都由政府统一编制……把教育作为一种政治手段，就是家永一类的学者所惧怕的，他们害怕历史的大悲剧重演。战后的日本和多数欧美国家一样，教科书由民间自行编制，政府只能审核品质，但是不能操纵它的内容。这种做法的目的，当然在避免一个政府有计划、有系统地制造易于统治的顺民。” 寒食节 P205 “唐朝时，中国的文化到达空前的高峰，是当时世界上最强盛的国家。我们对唐文化的了解有限，尤其是唐朝的节日。 唐人很重视的节日是寒食，设定在冬至后的一百零五日，大约在清明节前的一日。这天全长安城的炉灶内都不能有火，人们吃冷粥及冷饼，等到第二天一早，由大明宫内传出薪火，到家家户户的灶内。 这是一个充满了象征意义的节日，而且非常严厉地执行，寒食日仍起火者，要处以死刑的。”]]></content>
      <categories>
        <category>阅读</category>
      </categories>
      <tags>
        <tag>阅读</tag>
        <tag>龙应台</tag>
        <tag>杂文集</tag>
        <tag>野火集</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[《天幕红尘》读后感]]></title>
    <url>%2Fpost%2F772fc02c.html</url>
    <content type="text"><![CDATA[转自豆瓣 原文地址 数年前，看电视剧《天道》的时候，面对剧尾的那一场诉讼，我佩服得五体投地，于是，给某人出了一道题：如果一个农村家庭作坊被人谴责为滥用童工，怎么辩护？彼时，还算是民商法才子的某人给了一个答案。但是，我依然觉得是电视剧中的辩护词更赞。 电视剧中，中年的农民大叔说，农村的孩子，谁不是从小就帮着家里干活的呢？难道这也是用童工？其实，当时我转述问题的时候也有所遗漏。但是，不管怎么样，《天道》惊艳了我，豆豆也惊艳了我。只是，豆豆创作的小说数量并不多。而我，又属于那种心理洁癖者，很少在看完电视剧以后再看原著小说或者在看完原著小说后又去看电视剧的。所以，我并没有读过《天道》的原著小说《遥远的救世主》，我读了《背叛》。豆豆的小说有着明显的style，就像是大树的年轮，早已融于自身，无法消除。 豆豆的男主，都是有着绝顶的智慧的，就像是罗贯中笔下羽扇纶巾的诸葛亮，对方的一举一动、事态的发展，皆在自己的预料之中。无论是宋一坤，还是丁元英，抑或是叶子农，都是那种其貌不扬，扔在人堆里就找不到的主儿，但是，却具有翻手为云覆手为雨的能力。而他们的这种操纵乾坤的智慧和能力，在小说里，则体现为游走于法律的边缘。这句话，用通俗的说法叫做“打法律的擦边球”。无论是丁元英设计的“劫富济贫”，还是叶子农策划的“劳务输出”，较了真，其实都是违法行为。 但是，叶子农则认为自己的这种行为并非钻法律的空子，因为他的所思所想所作所为，均在法律认可的范围以内，既然法律没有明确禁止，那就是合法的。呵，这个人，倒是懂得将私法上的“法无禁止即自由”的思想应用于实践。“情深不寿，慧极必伤。”善于谋划，并且算无遗策的人，是一种“只可远观”的神话；从某种程度上来讲，他们的存在对于他人来说也是一种“危害”。这样的人，要么屹立于社会之巅，操纵着芸芸众生；要么，注定无法容于世。所以，天神一般的神机妙算的诸葛亮只是罗贯中在正统思想下塑造出来的“演义”。 所以，宋一坤用鲜血来洗刷自己的罪孽；所以，丁元英孤独终老；所以，叶子农倒在了异国他乡。 作品中，人物身上的种种智慧，事实上，都是作者自身智慧的投影。]]></content>
      <categories>
        <category>阅读</category>
      </categories>
      <tags>
        <tag>阅读</tag>
        <tag>小说</tag>
        <tag>豆豆</tag>
        <tag>天幕红尘</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[2018-02-03武汉游记]]></title>
    <url>%2Fpost%2F4f8fe65a.html</url>
    <content type="text"><![CDATA[第一天 2.3号。原本打算集训完直接回家的，临走前两天打开携程，下一站并不是石家庄，而是武汉。脑子里突然想起了那个“一时冲动”。哈，虽然不像自己的风格，但是既然买了票，那就一去吧 2.2集训完，晚上收拾寝室+整理行李就鼓捣到了2点多，拜托馨馨没睡的话6点钟把我叫起来，不过好在重要的事情自己心里也都有个谱，虽然睡眠时间不多，第二天一早还是自然醒了。把计划好的事情一件件做完，还了宁哥的电车钥匙，把没吃完的枇杷送给宿管阿姨，拎着强行塞下的行李箱和电脑包，地铁来到了长沙南站，本想着高铁一路还能看看南方这边郊外的风景，不过也许是前一天晚上收拾得有些晚了，上了高铁倒头就睡，一觉醒来已经是“列车即将到达武汉站“。精神迷糊得导致我下车时候应该把我仅带得一本小说《月亮与六便士》落在了座位上，可能是真的不打算让我读完它了哈哈哈（这可是我仅带的一本小说啊）。下了高铁在武汉站里吃了热干面，听了一个好心大姐的建议，在吃饭的地方换了些零钱然后买了一张城市交通一卡通（后来事实证明它发挥了无比巨大的作用）。午饭过后，乘地铁到了户部巷附近，入住如家，由于是内宾，光线不是很好，得，困意再次袭来，我一个午睡足足睡到了7点钟。还因此错过了我妈的电话，搞得她老人家着急了一番（生怕我这个一米八几的人在武汉被拐了）。 好好的休息了一番后，我便开始了晚上的自由行程，先是户部巷吃了些小吃（热干面，鸭架，哦对那个糊米酒不错，少数我能吃得惯的酒酿产品。。），有意思的是，户部巷里排队最长的竟然是长沙的臭豆腐和大香肠，哇，我这半个长沙人心里也莫名有了几分自豪。顺着巷子走，尽头是一个不起眼的藏酸奶，再一拐面前就是沿江大道了，时间已经过了八点，人并不是很多，江风阵阵，江堤边有不同用处的码头，还有供行人夜赏江景的平台。自小在北方长大的我一直很向往这种有水伴城的感觉，与家乡的人工水系最大的不同，这里是”水养人“，而非”人养水“，面朝江河，或是风平浪静、波澜不惊，亦或是怒浪卷云、波涛汹涌，自然的表现从不因你的喜恶而改变，或者更严谨的说，其内蕴之博大更难凭你一人的感情去左右。如此，无论自己有什么烦恼，跑到江边，去听，去感受，你总会静下来，与人不一样，它无需承诺，无论你在或不在，它总在那里，不怨，不悔，不念，不恼，它的存在，对我自己而言，已是一种终不可达的傲然姿态，对它的这种敬佩，是心底里的。 步行了一段时间，我搭上了来往过武汉长江大桥的公交，回来的时候应该恰好是末班吧。下了车能望到夜里灯光装饰的黄鹤楼，照旧，不喜自拍，但不想错过景致，拍了几张照，走回了旅店，这一小段路也顺便摸清了明早跑步的路线，晚上和三五好友聊了些天，睡觉时候好像也不早了（似乎自己上了大学后一直没有早睡过）。 第二天 2.4号。前一天睡得不早，不过今天早晨还是兴致勃勃的7点钟起来了，既然拿了跑步的衣服，又有如此兴致（PS重点是我竟然起来了），当然要粗发啦，还能留个纪念。 半个小时4.5km跑了武汉长江大桥一个来回，新成就get哈哈，回来的时候看到了纪念碑，上面有毛主席所写的”一桥飞架南北，天堑变通途“。当然，希望自己今后和村上春树先生一样，能坚定的做自己爱干的事业，同时还能坚定的做一个跑者。上午抓紧时间把武昌有文化存留的这一个区域都逛了一遍，黄鹤楼景区无论是火爆的还是冷门的景点都看了一遍，不曾想除了语文书中所提到的崔颢创作《黄鹤楼》，以及李白搁笔的故事，这座”天下江山第一楼“还与诸多历史名人有着千丝万缕的联系。过费祎亭，知晓了传说费祎死后登仙，每乘黄鹤于此憩驾。学了些历史知识，南朝刘宋就三国孙权所建夏口城扩建而成郢州城，地理位置就位于武汉市武昌蛇山，也就是黄鹤楼所在的这一片区域，而此处在宋朝时就是岳飞抗金作战的前线，而岳飞在郢州驻军时间最久，黄鹤楼景区内也有岳飞这一历史名将的雕塑，供后人瞻仰。哦对还有一点，黄鹤楼多次被毁重修，如今的黄鹤楼实际上是建国后重新修建的，清光绪十年（1884年）大火，留下来的只有黄鹤楼东侧的古铜顶。 游完黄鹤楼景区，旁边的首义公园是旧武汉省图书馆所在，但是现在已是危房，修缮中并没有对外开放。我便乘公交，过武昌路隧道，向北，到了沿江边的红色景点区，包括毛泽东旧居，中共五大会议旧址，革命时代的记忆，因为没有相似的经历，所以看革命先辈抛头颅，洒热血，更多的是敬佩，为信仰而奋斗，无需其他理由。之后又回户部巷，到老字号蔡林记吃的武汉正宗热干面。嗯对顺便尝了下恩施小土豆。看了看日期，今天是星期日，想起来多数博物馆都是周一闭馆，作为一个博物馆狂人，赶紧下午麻溜的跑到湖北省博物馆，先把最出名的看了再说，剩下的。。总之以后还会到武汉来的嘛。 博物馆的镇馆之宝应该就是曾侯乙编钟和越王勾践剑了，听了app上的讲解（竟然不是免费的，还很难用，差评），这两件文物以及相关历史和考古知识讲解的都比较仔细，剩下的，知识的系统性和文物的丰富性并比不上陕西历史博物馆等。但凡是参观博物馆，多看看，有收获就是好的。出了博物馆，这时旁边的湖北省美术馆已经关门了，好吧虽然有些可惜，不过还算留下了再来武汉游玩的决心。回去的路上经过现在的武汉省图书馆，不得不说比家乡的河北省图书馆要大好多啊。。外部造型和内部构造以及环境氛围都很让人有静下心来读书的赶脚，进馆的每个人也都很自觉地压低了自己的声音，总之氛围很好。 回到如家拿上行李，准备开拔到民宿的小姐姐家，公交到了楚河汉街附近，也是她强烈安利的，em或许不是因为这个，我也不会选择这边的民宿吧，哈。楚河汉街处于武汉中央文化区，地理位置相当于武汉市的几何中心，官方说明为”万达集团投资500亿元人民币，倾力打造的以文化为核心，兼具旅游、商业、商务、居住功能的世界级文化旅游项目“。晚上一个人走了个来回，哈确实不同的人总会找到不同的吸引点，购物达人-&gt;时装品牌，美食博主-&gt;小吃街，文艺青年-&gt;文创书店，都有适合你的那一个。我吃了点小吃然后就在文华书城看了会儿书，重点是，里！面！有!3D-JP！拼图店！突然回忆起了那段和拼图斗智斗勇，哦不，只有斗智的时光。 第三天 2.5号。emm早晨睡了个懒觉，今天是公交车上的一天哈哈。上车坐公交坐错方向了，不过正好公交线路正好是沿着东湖走一圈，干脆一不做二不休，坐到了终点站再坐回来（不愧是时间多），音乐与东湖美景相伴，这一趟值了。经过武汉长江二桥，我来到了汉阳，听了天骄的安利想着去看一下江汉关博物馆，不过么，确实博物馆周一都不开，江汉关也不例外。不过呐，以江汉关博物馆作为东头，恰巧是汉口地区最出名的文化购物一条街（一条街上足足有三四个阿迪达斯的专卖店。。），建筑都是民国风的，当然，这里不同于汉街，有不少是“真民国”，比如上海银行汉口分行旧址（现在在这里是工商银行的地界了），三段式立面，中段采用爱奥尼双柱巨柱式，还有四明银行旧址（现在是OCE的专卖店），以及不知道是不是真民国遗存的中国银行（看得挺像得），闲逛一小圈后，我又搭乘地铁来到了琴台附近，先去东边得汉阳造文化创意产业园游览了一番，这里的工作氛围并不像大型公司那样紧凑忙碌充满商业气息，相反，一股“文新”感觉扑面而来，作为比较小众的景点，步行游览的人也有，但并不多，三三两两，时而有看着像因公来此处的轿车出入，靠近入口的知音书店或许是和我的生活相交最多了吧，在门口张望了一阵子，书店里的灯透过帘子隐约感觉韩式亮的，但是并没有看到里面有人在的迹象，我还是被好奇心驱使着推开门进了这家书店，少往里一拐，一个年纪比我稍长几岁的姐姐还在吧台读着书，确实没有其他客人，不过看到我来还是很热情的走来欢迎。环顾书店，并不大，中间整齐的放置着六张木制桌椅，很复古，再往里还有一个“国学讲坛”，整体风格相较于现代的书咖更传统些，书籍也是很规则的摆放在两边靠墙的书架上。一杯海盐咖啡，一本1Q84陪着我度过了一个下午，在这里工作的姐姐并没有怎么打扰我，难以言说的“温暖孤独”。 傍晚时分来到了西边的古琴台，这里规划成了一个集成剧院和音乐厅的休闲公园，地图上标记为“月湖风景区”，一个北方人，看到水和湖，又是一脸羡慕的表情，景色还是蛮不错的，公园还很贴心的规划了步行推荐路线，我也确实见到几个在附近居住的武汉市民在这里步行健身。 晚上在光谷逛了一番，emm规划的很大，不过整体的感觉有点杂乱，看看时间已经十年了，再一想，十年！十年前武汉这么靠东的地方就有这样规格的购物广场了，确实发展步伐要快很多啊。比较有意思的小插曲就是晚上部门培训，哇花着全国流量举着手机看了一路（怕是被路人误当成追剧少年了哈哈哈）。 归途，返程。]]></content>
      <categories>
        <category>旅行</category>
      </categories>
      <tags>
        <tag>旅行</tag>
        <tag>游记</tag>
        <tag>武汉</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[【POJ-1458】解题报告（DP，最长相同子序列）]]></title>
    <url>%2Fpost%2F104a4c5d.html</url>
    <content type="text"><![CDATA[原始题目Common Subsequence Time Limit: 1000MS Memory Limit: 10000K Total Submissions: 56895 Accepted: 23740 Problem Description A subsequence of a given sequence is the given sequence with some elements (possible none) left out. Given a sequence X = &lt; x1, x2, …, xm &gt; another sequence Z = &lt; z1, z2, …, zk &gt; is a subsequence of X if there exists a strictly increasing sequence &lt; i1, i2, …, ik &gt; of indices of X such that for all j = 1,2,…,k, xij = zj. For example, Z = &lt; a, b, f, c &gt; is a subsequence of X = &lt; a, b, c, f, b, c &gt; with index sequence &lt; 1, 2, 4, 6 &gt;. Given two sequences X and Y the problem is to find the length of the maximum-length common subsequence of X and Y. InputThe program input is from the std input. Each data set in the input contains two strings representing the given sequences. The sequences are separated by any number of white spaces. The input data are correct. OutputFor each set of data the program prints on the standard output the length of the maximum-length common subsequence from the beginning of a separate line. Sample Inputabcfbc abfcab programming contest abcd mnp Sample Output4 2 0 SourceSoutheastern Europe 2003 题目大意给定两个字符串，求最长相同子序列的长度。 解题思路入门dp，状态转移方程为：dp[i][j]={dp[i-1][j-1]+1(a[i]=a[j]), max(dp[i-1][j],dp[i][j-1])(a[i]!=a[j]} 解题代码12345678910111213141516171819202122232425262728293031#include &lt;cstring&gt;#include &lt;cstdio&gt;#include &lt;algorithm&gt;using namespace std;const int maxn=1005;int len1,len2;char s1[maxn],s2[maxn];int dp[maxn][maxn];void solve()&#123; for(int i=0;i&lt;len1;i++) &#123; for(int j=0;j&lt;len2;j++) &#123; if(s1[i]==s2[j]) dp[i][j]=dp[i-1][j-1]+1; else dp[i][j]=max(dp[i-1][j],dp[i][j-1]); &#125; &#125;&#125;int main()&#123; while(~scanf("%s%s",s1,s2)) &#123; memset(dp,0,sizeof(dp)); len1=strlen(s1),len2=strlen(s2); solve(); printf("%d\n",dp[len1-1][len2-1]); &#125; return 0;&#125; 收获与反思熟悉格式。]]></content>
      <categories>
        <category>编程</category>
        <category>ACM</category>
      </categories>
      <tags>
        <tag>ACM</tag>
        <tag>算法</tag>
        <tag>DP</tag>
        <tag>2018寒假集训</tag>
        <tag>POJ</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[【HDU-1518】解题报告（DFS，极易TLE，剪枝）]]></title>
    <url>%2Fpost%2F3d8072b.html</url>
    <content type="text"><![CDATA[原始题目Square Time Limit: 10000/5000 MS (Java/Others) Memory Limit: 65536/32768 K (Java/Others) Total Submission(s): 17274 Accepted Submission(s): 5409 Problem DescriptionGiven a set of sticks of various lengths, is it possible to join them end-to-end to form a square? InputThe first line of input contains N, the number of test cases. Each test case begins with an integer 4 ≤ M ≤ 20, the number of sticks. M integers follow; each gives the length of a stick - an integer between 1 and 10,000. OutputFor each case, output a line containing “yes” if is is possible to form a square; otherwise output “no”. Sample Input3 4 1 1 1 1 5 10 20 30 40 50 8 1 7 2 6 4 4 3 5 Sample Outputyes no yes SourceUniversity of Waterloo Local Contest 2002.09.21 RecommendLL 题目大意给定M个小木棍的长度，问能否组成一个正方形。 解题思路题目很简单啊，思路也很简单啊，但是写出来就TLE了啊。。。如此可见dfs剪枝是多么的重要。 解题代码12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364656667686970717273747576777879808182#include &lt;queue&gt;#include &lt;cstdio&gt;#include &lt;cstring&gt;#include &lt;cmath&gt;#include &lt;cstdlib&gt;#include &lt;algorithm&gt;using namespace std;//dfsconst int maxn=25;int stick[maxn]; bool vis[maxn];int M,T,sum,len,flag,mmax,mmin; bool cmp(int a, int b)&#123; return a&gt;b?1:0;&#125;void dfs(int count,int now,int index)&#123; if(flag) return; if(count==4) &#123; flag=1; return; &#125; if(now==0) &#123; dfs(count+1,len,M-1); if(flag) return; &#125; else if(now&lt;mmin) return; for(int i=index;i&gt;=0;i--) //剪枝1：从index开始遍历 &#123; if(!vis[i]&amp;&amp;now&gt;=stick[i]) &#123; vis[i]=1; dfs(count,now-stick[i],i-1); //i已经使用过 if(flag) return; vis[i]=0; if(index==M-1)&lt;span class="space" style="white-space:pre;display:inline-block;text-indent:2em;line-height:inherit;"&gt;//剪枝2（重要剪枝）：由于每一边长度都相等，一边不能利用最长木棍的话，那么肯定这组数据肯定过不了，不需要检测了。&lt;/span&gt; &#123; return; &#125; //相同的忽略 while(stick[i]==stick[i-1])&lt;span class="space" style="white-space:pre;display:inline-block;text-indent:2em;line-height:inherit;"&gt; //剪枝3：同样长度的都过不了，无需再走一遍&lt;/span&gt; &#123;// printf("!1"); i--; &#125; &#125; &#125; return ;&#125;int main()&#123;// freopen("in.txt","r",stdin); scanf("%d",&amp;T); while(T--) &#123; memset(vis,0,sizeof(vis)); scanf("%d",&amp;M); flag=sum=0; for(int i=0;i&lt;M;i++) &#123; scanf("%d",&amp;stick[i]); sum+=stick[i]; &#125; sort(stick,stick+M); mmax=stick[M-1],mmin=stick[0]; len=sum/4; if(sum%4||mmax&gt;len) printf("no\n"); else &#123; dfs(0,len,M-1); if(flag) printf("yes\n"); else printf("no\n"); &#125; &#125; return 0; &#125; 收获与反思跟TLE斗智斗勇了一下午，慢慢嚼代码，想剪枝，确定剪枝的效果。（等待补图）]]></content>
      <categories>
        <category>编程</category>
        <category>ACM</category>
      </categories>
      <tags>
        <tag>ACM</tag>
        <tag>算法</tag>
        <tag>2018寒假集训</tag>
        <tag>补图</tag>
        <tag>HDU</tag>
        <tag>DFS</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[【CodeForces-455A】解题报告（DP，long long）]]></title>
    <url>%2Fpost%2Fa1fc03d8.html</url>
    <content type="text"><![CDATA[原始题目A. Boredom time limit per test 1 second memory limit per test 256 megabytes input standard input output standard output Alex doesn’t like boredom. That’s why whenever he gets bored, he comes up with games. One long winter evening he came up with a game and decided to play it. Given a sequence a consisting of n integers. The player can make several steps. In a single step he can choose an element of the sequence (let’s denote it ak) and delete it, at that all elements equal to ak + 1 and ak - 1 also must be deleted from the sequence. That step brings ak points to the player. Alex is a perfectionist, so he decided to get as many points as possible. Help him. InputThe first line contains integer n (1 ≤ n ≤ 105) that shows how many numbers are in Alex’s sequence. The second line contains n integers a1, a2, …, an (1 ≤ ai ≤ 105). OutputPrint a single integer — the maximum number of points that Alex can earn. Examplesinput2 1 2 output2 input3 1 2 3 output4 input9 1 2 1 3 2 2 2 2 3 output10 NoteConsider the third test example. At first step we need to choose any element equal to 2. After that step our sequence looks like this [2, 2, 2, 2]. Then we do 4 steps, on each step we choose any element equals to 2. In total we earn 10 points. 题目大意给出一个数列a1,a2,a3…ai…an。每次选定一个数ai，并且所有与ai-1，ai+1相等的数全部消去，这样消去一次得分为ai。最终把数列全部消去完，问最终最高得分是多少。 解题思路dp，数组A[ai]表示ai出现的次数，并且记录最大值mmax，从0到mmax走一遍dp。 状态转移方程为dp[i]=max(dp[i-1],dp[i-2]+A[i]*i)，即从小到大消去到ai=i时的最高得分为：消去到i-1的最高得分（因为消去i-1时所有i=i-1+1全部被消去）与消去到i-2的最高得分加上消去A[i]个i的得分（即跳过i-1不消去）。 由于涉及求和，ai乘上出现次数会超int范围，故使用long long。 解题代码1234567891011121314151617181920212223242526272829303132333435363738394041#include &lt;queue&gt;#include &lt;cstdio&gt;#include &lt;cstring&gt;#include &lt;cmath&gt;#include &lt;cstdlib&gt;#include &lt;algorithm&gt;//dp[i]=max(dp[i-1],dp[i-2]+a[i]*i)using namespace std;const int maxn=100100;long long dp[maxn],a[maxn];long long n,t,mmax;void solve()&#123; //0不出现，初始化 1 dp[1]=a[1]; for(long long i=2;i&lt;=mmax;i++) &#123; dp[i]=max(dp[i-1],dp[i-2]+a[i]*i); &#125; printf("%lld\n",dp[mmax]);&#125;int main()&#123; while(~scanf("%lld",&amp;n)) &#123; memset(dp,0,sizeof(dp)); memset(a,0,sizeof(a)); long long maxx=0; for(long long i=1;i&lt;=n;i++) &#123; scanf("%lld",&amp;t); if(t&gt;mmax) mmax=t; a[t]++; &#125;// for(long long i=1;i&lt;=n;i++)// printf("a[%d]=%d\n",i,a[i]); solve(); &#125; return 0;&#125; 收获与反思建立好状态转移方程就好，注意long long。]]></content>
      <categories>
        <category>编程</category>
        <category>ACM</category>
      </categories>
      <tags>
        <tag>ACM</tag>
        <tag>算法</tag>
        <tag>DP</tag>
        <tag>2018寒假集训</tag>
        <tag>CodeForces</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[【AtCoder-3881】解题报告（简单DP）]]></title>
    <url>%2Fpost%2Ffbf7f335.html</url>
    <content type="text"><![CDATA[原始题目C - Candies Time limit : 2sec Memory limit : 256MB Score : 300 points Problem Statement We have a 2×N grid. We will denote the square at the i-th row and j-th column (1≤i≤2, 1≤j≤N) as (i,j). You are initially in the top-left square, (1,1). You will travel to the bottom-right square, (2,N), by repeatedly moving right or down. The square (i,j) contains Ai,j candies. You will collect all the candies you visit during the travel. The top-left and bottom-right squares also contain candies, and you will also collect them. At most how many candies can you collect when you choose the best way to travel? Constraints 1≤N≤100 1≤Ai,j≤100 (1≤i≤2, 1≤j≤N) InputInput is given from Standard Input in the following format: N A1,1 A1,2 … A1,N A2,1 A2,2 … A2,N OutputPrint the maximum number of candies that can be collected. Sample Input 1 5 3 2 2 4 1 1 2 2 2 1 Sample Output 1 14The number of collected candies will be maximized when you: move right three times, then move down once, then move right once. Sample Input 2 4 1 1 1 1 1 1 1 1 Sample Output 2 5 You will always collect the same number of candies, regardless of how you travel. Sample Input 3 7 3 3 4 5 4 5 3 5 3 4 4 2 3 2 Sample Output 3 29 Sample Input 4 1 2 3 Sample Output 4 5 题目大意2*N个格子，每个格子里均含有不同数量的蜡烛。每一次只能向右或者向下走，问从（1，1）走到（2，N）最多能收集多少根蜡烛（包括首尾）。 解题思路入门DP，简化成2*N了，状态转移方程：dp[i][j]=max(dp[i-1][j],dp[i][j-1])+a[i][j] 解题代码 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556#include &lt;cstdio&gt;#include &lt;cstring&gt;#include &lt;cmath&gt;#include &lt;iostream&gt;#include &lt;iomanip&gt;#include &lt;set&gt;#include &lt;queue&gt;#include &lt;stack&gt;#include &lt;vector&gt;#include &lt;string&gt;#include &lt;sstream&gt;#include &lt;bits/stdc++.h&gt;#define rep(i,a,n) for(int i=a;i&lt;n;++i)#define per(i,a,n) for(int i=n-1;i&gt;=a;--i);#define ms(x,a) memset((x),a,sizeof((x))) #define INF 0x3f3f3f3f#define eps 1e-8#define fi first#define se second#define mp make_pair#define pb push_back#define np next_permutation#define gapline cout&lt;&lt;"##======================##"&lt;&lt;endlusing namespace std;const int maxn=300;const int maxl=26;const int maxm=1e5+5;typedef long long ll;typedef unsigned long long ull;typedef vector&lt;int&gt; vi;typedef pair&lt;int,int&gt; pii;int n,m;int dp[maxn][maxn],a[maxn][maxn];void solve()&#123; rep(i,1,n+1)&#123; rep(j,1,m+1)&#123; dp[i][j]=max(dp[i-1][j],dp[i][j-1])+a[i][j]; &#125; &#125;&#125; int main()&#123; ios::sync_with_stdio(false); while(cin&gt;&gt;m)&#123; ms(dp,0); n=2; rep(i,1,n+1)&#123; rep(j,1,m+1) cin&gt;&gt;a[i][j]; &#125; solve(); cout&lt;&lt;dp[2][m]&lt;&lt;endl; &#125;&#125; 收获与反思 第一次小比赛实战应用dp，看了看大神们也都是dp秒出说明思路是正确的。能写好状态转移方程就行。 2018.8.23更新 代码优化，利用dp外围空白。]]></content>
      <categories>
        <category>编程</category>
        <category>ACM</category>
      </categories>
      <tags>
        <tag>ACM</tag>
        <tag>算法</tag>
        <tag>AtCoder</tag>
        <tag>DP</tag>
        <tag>2018寒假集训</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[【SCU-1114】解题报告（DP，路径，DFS）]]></title>
    <url>%2Fpost%2Ff4bfd16b.html</url>
    <content type="text"><![CDATA[原始题目下图是个数字三角，请编写一个程序计算从顶部至底部某处一条路径，使得该路径所经过的数字总和最大。 7 3 8 8 1 0 2 7 4 4 每一步可沿左斜线向下或右斜线向下走； 1≤三角形行数≤100 三角形中的数字为整数 0，1，……，99。 如果有多种情况结果都最大，任意输出一种即可。 输入：第一行一个整数N，代表三角形的行数。 接下来N行，描述了一个数字三角。 输出：第一行一个整数，代表路径所经过底数字总和。 第二行N个数，代表所经过的数字。 样例：输入：4 7 3 8 8 1 0 2 7 4 4 输出：25 7 3 8 7 解题思路入门dp，状态转移方程为dp[i][j]=max(dp[i+1][j],dp[i+1][j+1])+a[i][j]; dp[i][j]表示i行j列（即第i行j个数字到底部的最大和）。根据该状态转移方程递归实现即可。 本题不仅需要记录最终的和，还需要记录路径，这时候就需要根据dp的表再用dfs走一遍。 解题代码123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778#include &lt;cstdio&gt;#include &lt;cstring&gt;#include &lt;cstdlib&gt;#include &lt;cmath&gt;using namespace std;const int maxn=1e2+10; int n,m;//n行，m列 int a[maxn][maxn];int f[maxn][maxn];int ans[maxn];int flag;//f[i,j]=max(f[i+1,j],f[i+1,j+1])+a[i,j]int max(int a,int b)&#123; return a&gt;b?a:b;&#125;int dp(int i,int j)//递归实现 &#123; int t; if(i==n)//到底部 &#123; t=a[i][j]; return f[i][j]=t; &#125; else &#123; t=max(dp(i+1,j),dp(i+1,j+1))+a[i][j]; return f[i][j]=t; &#125; &#125;void dfs(int i,int j,int tot,int n) &#123; //cout&lt;&lt;i&lt;&lt;" "&lt;&lt;j&lt;&lt;endl; if(flag) return; if(i==n) &#123; for(int i=1;i&lt;n;i++) printf("%d ",ans[i]); printf("%d\n",ans[n]); flag=1; &#125; int tmp=tot-a[i][j]; if(tmp==f[i+1][j]) &#123; ans[i+1]=a[i+1][j]; dfs(i+1,j,tmp,n); &#125; else if(tmp==f[i+1][j+1]) &#123; ans[i+1]=a[i+1][j+1]; dfs(i+1,j+1,tmp,n); &#125; &#125; int main()&#123; while(~scanf("%d",&amp;n)) &#123; memset(a,0,sizeof(a)); memset(f,0,sizeof(f)); for(int i=1;i&lt;=n;i++) &#123; for(int j=1;j&lt;=i;j++) &#123; scanf("%d",&amp;a[i][j]); &#125; &#125; dp(1,1); printf("%d\n",f[1][1]); flag=0; dfs(0,0,f[1][1],n); &#125; return 0;&#125; 收获与反思开始在怎么寻找路径这里卡住了，学到的东西得反复看啊。。不然真的不会用。]]></content>
      <categories>
        <category>编程</category>
        <category>ACM</category>
      </categories>
      <tags>
        <tag>ACM</tag>
        <tag>算法</tag>
        <tag>DP</tag>
        <tag>2018寒假集训</tag>
        <tag>DFS</tag>
        <tag>SCU</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[【HDU-2717】解题报告（BFS）]]></title>
    <url>%2Fpost%2F5c86d06a.html</url>
    <content type="text"><![CDATA[原始题目Catch That Cow Time Limit: 5000/2000 MS (Java/Others) Memory Limit: 32768/32768 K (Java/Others) Total Submission(s): 17820 Accepted Submission(s): 5260 Problem Description Farmer John has been informed of the location of a fugitive cow and wants to catch her immediately. He starts at a point N (0 ≤ N ≤ 100,000) on a number line and the cow is at a point K (0 ≤ K ≤ 100,000) on the same number line. Farmer John has two modes of transportation: walking and teleporting. Walking: FJ can move from any point X to the points X - 1 or X + 1 in a single minute Teleporting: FJ can move from any point X to the point 2 × X in a single minute. If the cow, unaware of its pursuit, does not move at all, how long does it take for Farmer John to retrieve it? InputLine 1: Two space-separated integers: N and K OutputLine 1: The least amount of time, in minutes, it takes for Farmer John to catch the fugitive cow. Sample Input5 17 Sample Output4 HintThe fastest way for Farmer John to reach the fugitive cow is to move along the following path: 5-10-9-18-17, which takes 4 minutes. SourceUSACO 2007 Open Silver Recommendteddy 题目大意一个人想用最短的时间去抓住一头牛，牛不会动，人的移动规则是：下一次移动可以移动到X+1位置，X-1位置，或者2*X位置（X为当前位置坐标），现在给定人和牛的坐标，求人抓到牛所需要的最短时间（次数） 解题思路很直接的广搜，搜索规则可以理解成三个direction，+1，-1，*2；最后可以加上一点处理（不知道算不算剪枝）因为坐标横大于0，那么若牛的初始坐标值小于人，那么无需广搜可以得到最短次数即坐标值之差（每次左移一个单位），另由于广搜深度增加，每次搜索的量会很大，可以加入判断搜索到结果时立即跳脱循环。 解题代码123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384#include &lt;queue&gt;#include &lt;cstdio&gt;#include &lt;cstring&gt;#include &lt;cmath&gt;#include &lt;cstdlib&gt;#include&lt;algorithm&gt;using namespace std;const int maxn=100001; int n,m; bool vis[maxn]; // 访问标记int dir[3]; //struct State // BFS 队列中的状态数据结构//&#123;// int x;// int Step_Counter; // 搜索步数统计器//&#125;;queue &lt;int&gt; q;int step[maxn];bool CheckState(int X) // 约束条件检验&#123;// int X=now.x; if(X&gt;=0&amp;&amp;X&lt;=100000&amp;&amp;!vis[X]) // 满足条件 &#123;// printf("next X=%d, step=%d\n",X,now.Step_Counter+1); return 1; &#125; else // 约束条件冲突 return 0;&#125;void bfs(int st)&#123; int now,next; // 定义2个状态，当前和下一个 q.push(st); step[st]=0; vis[st]=true; // 访问标记 while(!q.empty()) &#123; now=q.front(); // 取队首元素进行扩展 if(now==m) // 出现目标态，此时为Step_Counter 的最小值，可以退出即可 &#123; printf("%d\n",step[now]); return; &#125; //按照规则搜索下一组数 //两种形式，一种左右，一种倍乘。 dir[0]=-1;dir[1]=1;dir[2]=now; int flag=0; for(int i=0;i&lt;3;i++) &#123; next=now+dir[i];// printf("check X=%d, step=%d\n",next,step[now]+1); if(next==m)//剪枝，立即跳出循环 &#123; while(!q.empty()) q.pop(); step[next]=step[now]+1; q.push(now); q.push(next); break; &#125; if(CheckState(next)) &#123; step[next]=step[now]+1; vis[next]=true; //不要忘了标记已访问 q.push(next); &#125; &#125; q.pop(); // 队首元素出队 &#125; return;&#125;int main()&#123;// freopen("in.txt","r",stdin); while(~scanf("%d%d",&amp;n,&amp;m)) &#123; while(!q.empty()) q.pop(); memset(vis,0,sizeof(vis)); memset(step,0,sizeof(step)); if(n&gt;=m) printf("%d\n",n-m); else bfs(n); &#125;&#125; 收获与反思使用模板里的结构时出现了两次MLE，不知道是什么个情况，有待检查。]]></content>
      <categories>
        <category>编程</category>
        <category>ACM</category>
      </categories>
      <tags>
        <tag>ACM</tag>
        <tag>算法</tag>
        <tag>2018寒假集训</tag>
        <tag>BFS</tag>
        <tag>HDU</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[【POJ-3126】解题报告（BFS，换门牌号，素数筛）]]></title>
    <url>%2Fpost%2F409dbc1a.html</url>
    <content type="text"><![CDATA[原始题目Prime Path Time Limit: 1000MS Memory Limit: 65536K Total Submissions: 24280 Accepted: 13417 Problem Description The ministers of the cabinet were quite upset by the message from the Chief of Security stating that they would all have to change the four-digit room numbers on their offices. — It is a matter of security to change such things every now and then, to keep the enemy in the dark. — But look, I have chosen my number 1033 for good reasons. I am the Prime minister, you know! — I know, so therefore your new number 8179 is also a prime. You will just have to paste four new digits over the four old ones on your office door. — No, it’s not that simple. Suppose that I change the first digit to an 8, then the number will read 8033 which is not a prime! — I see, being the prime minister you cannot stand having a non-prime number on your door even for a few seconds. — Correct! So I must invent a scheme for going from 1033 to 8179 by a path of prime numbers where only one digit is changed from one prime to the next prime. Now, the minister of finance, who had been eavesdropping, intervened. — No unnecessary expenditure, please! I happen to know that the price of a digit is one pound. — Hmm, in that case I need a computer program to minimize the cost. You don’t know some very cheap software gurus, do you? — In fact, I do. You see, there is this programming contest going on… Help the prime minister to find the cheapest prime path between any two given four-digit primes! The first digit must be nonzero, of course. Here is a solution in the case above. 1033 1733 3733 3739 3779 8779 8179 The cost of this solution is 6 pounds. Note that the digit 1 which got pasted over in step 2 can not be reused in the last step – a new 1 must be purchased. InputOne line with a positive number: the number of test cases (at most 100). Then for each test case, one line with two numbers separated by a blank. Both numbers are four-digit primes (without leading zeros). OutputOne line for each case, either with a number stating the minimal cost or containing the word Impossible. Sample Input3 1033 8179 1373 8017 1033 1033 Sample Output6 7 0 SourceNorthwestern Europe 2006 题目大意换门牌号，要求每次只能更换一位，且更换完之后的新数字要是素数，问更换到指定号码的最少步数是多少。 解题思路按个十百千位广搜，&lt;40入口，搜索的规则是，该数没有被搜索过，且该数为素数。由于是BFS，所以第一次搜索到最终更改的门牌号时一定是最少步数，输出该值即可。如果广搜入口全部遍历一编还是未能搜索到最终更改的门牌号，即为不可能，输出Impossible。 要点： 由于要求是素数，所以个位只需要搜索奇数即可，以及千位避开0； 涉及素数，可以用最基础的素数判断（即从2开始逐个除，若有因子则返回false），或者使用素数筛先建立素数表然后直接查表（待补充） 解题代码 素数传统判断 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130#include &lt;queue&gt;#include &lt;cstdio&gt;#include &lt;cstring&gt;#include &lt;cmath&gt;#include &lt;cstdlib&gt;#include&lt;algorithm&gt;#define maxn 10100using namespace std;int n,m; bool vis[maxn]; // 访问标记//int dir[4][2]=&#123;0,1,0,-1,1,0,-1,0&#125;; // 方向向量//int dir[8][2]=&#123;&#123;1,1&#125;,&#123;1,0&#125;,&#123;1,-1&#125;,&#123;0,1&#125;,&#123;0,-1&#125;,&#123;-1,1&#125;,&#123;-1,0&#125;,&#123;-1,-1&#125;&#125; ;struct State // BFS 队列中的状态数据结构&#123; int x; int Step_Counter; // 搜索步数统计器&#125;;bool isPrime(int x)&#123; if(x==0||x==1) return false; else if(x==2||x==3) return true; else &#123; for(int i=2;i&lt;=(int)sqrt(x);i++) &#123; if(x%i==0) return false; &#125; return true; &#125;&#125; State a[maxn];bool CheckState(int s,State now) // 约束条件检验&#123; if(s!=now.x&amp;&amp;!vis[s]&amp;&amp;isPrime(s)) // 满足条件 &#123;// printf("next s=%d, step=%d\n",s,now.Step_Counter+1); return 1; &#125; else // 约束条件冲突 return 0;&#125;void bfs(State st)&#123; queue &lt;State&gt; q; State now,next; // 定义2个状态，当前和下一个 st.Step_Counter=0; // 计数器清零 q.push(st); // 入队 vis[st.x]=1; // 访问标记 while(!q.empty()) &#123; now=q.front(); // 取队首元素进行扩展 if(now.x==m) // 出现目标态，此时为Step_Counter 的最小值，可以退出即可 &#123; printf("%d\n",now.Step_Counter); return; &#125; //按照规则搜索下一组数 for(int i=1;i&lt;=9;i+=2) &#123; int s=now.x/10*10+i; if(CheckState(s,now)) &#123; vis[s]=1; next.x=s; next.Step_Counter=now.Step_Counter+1; q.push(next); &#125; &#125; for(int i=0;i&lt;=9;i++) &#123; int s = now.x / 100 * 100 + i * 10 + now.x % 10; if(CheckState(s,now)) &#123; vis[s]=1; next.x=s; next.Step_Counter=now.Step_Counter+1; q.push(next); &#125; &#125; for(int i=0;i&lt;=9;i++) &#123; int s=now.x/1000*1000+i*100+now.x%100; if(CheckState(s,now)) &#123; vis[s]=1; next.x=s; next.Step_Counter=now.Step_Counter+1; q.push(next); &#125; &#125; for(int i=1;i&lt;=9;i++) &#123; int s=i*1000+now.x%1000; if(CheckState(s,now)) &#123; vis[s]=1; next.x=s; next.Step_Counter=now.Step_Counter+1; q.push(next); &#125; &#125; q.pop(); // 队首元素出队 &#125; printf("Impossible\n"); return;&#125;int main()&#123; int t; scanf("%d",&amp;t); for(int i=0;i&lt;t;i++) &#123;// printf("%d %d\n",t,n);// while(!q.empty()) q.pop(); memset(vis,0,sizeof(vis)); scanf("%d%d",&amp;n,&amp;m); struct State tmp; tmp.x=n; tmp.Step_Counter=0; bfs(tmp); &#125; return 0;&#125; 非线性埃式素数筛 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132#include &lt;queue&gt;#include &lt;cstdio&gt;#include &lt;cstring&gt;#include &lt;cmath&gt;#include &lt;cstdlib&gt;#include&lt;algorithm&gt;#define maxn 10100using namespace std;int n,m; bool vis[maxn]; // 访问标记//int dir[4][2]=&#123;0,1,0,-1,1,0,-1,0&#125;; // 方向向量//int dir[8][2]=&#123;&#123;1,1&#125;,&#123;1,0&#125;,&#123;1,-1&#125;,&#123;0,1&#125;,&#123;0,-1&#125;,&#123;-1,1&#125;,&#123;-1,0&#125;,&#123;-1,-1&#125;&#125; ;struct State // BFS 队列中的状态数据结构&#123; int x; int Step_Counter; // 搜索步数统计器&#125;;bool isPrime[maxn]; void solvePrime() //埃式素数筛 &#123; memset(isPrime,1,sizeof(isPrime)); isPrime[0]=isPrime[1]=false; for(int i=2;i&lt;=maxn;i++) &#123; if(isPrime[i]) &#123; for(int j=i*i;j&lt;=maxn;j+=i) &#123; isPrime[j]=false; &#125; &#125; &#125;&#125;State a[maxn];bool CheckState(int s,State now) // 约束条件检验&#123; if(s!=now.x&amp;&amp;!vis[s]&amp;&amp;isPrime[s]) // 满足条件 &#123;// printf("next s=%d, step=%d\n",s,now.Step_Counter+1); return 1; &#125; else // 约束条件冲突 return 0;&#125;void bfs(State st)&#123; queue &lt;State&gt; q; State now,next; // 定义2个状态，当前和下一个 st.Step_Counter=0; // 计数器清零 q.push(st); // 入队 vis[st.x]=1; // 访问标记 while(!q.empty()) &#123; now=q.front(); // 取队首元素进行扩展 if(now.x==m) // 出现目标态，此时为Step_Counter 的最小值，可以退出即可 &#123; printf("%d\n",now.Step_Counter); return; &#125; //按照规则搜索下一组数 for(int i=1;i&lt;=9;i+=2) &#123; int s=now.x/10*10+i; if(CheckState(s,now)) &#123; vis[s]=1; next.x=s; next.Step_Counter=now.Step_Counter+1; q.push(next); &#125; &#125; for(int i=0;i&lt;=9;i++) &#123; int s = now.x / 100 * 100 + i * 10 + now.x % 10; if(CheckState(s,now)) &#123; vis[s]=1; next.x=s; next.Step_Counter=now.Step_Counter+1; q.push(next); &#125; &#125; for(int i=0;i&lt;=9;i++) &#123; int s=now.x/1000*1000+i*100+now.x%100; if(CheckState(s,now)) &#123; vis[s]=1; next.x=s; next.Step_Counter=now.Step_Counter+1; q.push(next); &#125; &#125; for(int i=1;i&lt;=9;i++) &#123; int s=i*1000+now.x%1000; if(CheckState(s,now)) &#123; vis[s]=1; next.x=s; next.Step_Counter=now.Step_Counter+1; q.push(next); &#125; &#125; q.pop(); // 队首元素出队 &#125; printf("Impossible\n"); return;&#125;int main()&#123; solvePrime(); int t; scanf("%d",&amp;t); for(int i=0;i&lt;t;i++) &#123;// printf("%d %d\n",t,n);// while(!q.empty()) q.pop(); memset(vis,0,sizeof(vis)); scanf("%d%d",&amp;n,&amp;m); struct State tmp; tmp.x=n; tmp.Step_Counter=0; bfs(tmp); &#125; return 0;&#125; 收获与反思题目本身没什么问题，两次TLE都是因为输入输出格式的问题最后一直等待输入，需要再细心一点。 对于素数筛知识的补充。 传统方法：根据是否有大于1小于本身的因子来判断，复杂度为O(nlognlogn) （虽然还不会证明）。 素数筛方法 埃式筛法，即埃拉托斯特尼筛法，本题采用。原理就是排除0，1，从2开始当前未筛去的数最小的数即为素数 改进前后两次的时间对比（图待补充） 另外还有欧拉筛法（线性）有待学习。]]></content>
      <categories>
        <category>编程</category>
        <category>ACM</category>
      </categories>
      <tags>
        <tag>ACM</tag>
        <tag>算法</tag>
        <tag>2018寒假集训</tag>
        <tag>BFS</tag>
        <tag>补图</tag>
        <tag>素数筛</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[【CodeForces-689B】解题报告（BFS）]]></title>
    <url>%2Fpost%2F454c2358.html</url>
    <content type="text"><![CDATA[原始题目B. Mike and Shortcuts time limit per test 3 seconds memory limit per test 256 megabytes input standard input output standard output Recently, Mike was very busy with studying for exams and contests. Now he is going to chill a bit by doing some sight seeing in the city. City consists of n intersections numbered from 1 to n. Mike starts walking from his house located at the intersection number 1 and goes along some sequence of intersections. Walking from intersection number i to intersection j requires |i - j| units of energy. The total energyspent by Mike to visit a sequence of intersections p1 = 1, p2, …, pk is equal to units of energy. Of course, walking would be boring if there were no shortcuts. A shortcut is a special path that allows Mike walking from one intersection to another requiring only 1 unit of energy. There are exactly n shortcuts in Mike’s city, the ith of them allows walking from intersection i to intersection ai (i ≤ ai ≤ ai + 1) (but not in the opposite direction), thus there is exactly one shortcut starting at each intersection. Formally, if Mike chooses a sequence p1 = 1, p2, …, pk then for each 1 ≤ i &lt; k satisfying pi + 1 = api and api ≠ pi Mike will spend only 1 unit of energy instead of |pi - pi + 1| walking from the intersection pi to intersection pi + 1. For example, if Mike chooses a sequence p1 = 1, p2 = ap1, p3 = ap2, …, pk = apk - 1, he spends exactly k - 1 units of total energy walking around them. Before going on his adventure, Mike asks you to find the minimum amount of energy required to reach each of the intersections from his home. Formally, for each 1 ≤ i ≤ n Mike is interested in finding minimum possible total energy of some sequence p1 = 1, p2, …, pk = i. InputThe first line contains an integer n (1 ≤ n ≤ 200 000) — the number of Mike’s city intersection. The second line contains n integers a1, a2, …, an (i ≤ ai ≤ n , , describing shortcuts of Mike’s city, allowing to walk from intersection i to intersection ai using only 1 unit of energy. Please note that the shortcuts don’t allow walking in opposite directions (from ai to i). OutputIn the only line print n integers m1, m2, …, mn, where mi denotes the least amount of total energy required to walk from intersection 1 to intersection i. Examplesinput3 2 2 3 output0 1 2 input5 1 2 3 4 5 output0 1 2 3 4 input7 4 4 4 4 7 7 7 output0 1 2 1 2 3 3 NoteIn the first sample case desired sequences are: 1: 1; m1 = 0; 2: 1, 2; m2 = 1; 3: 1, 3; m3 = |3 - 1| = 2. In the second sample case the sequence for any intersection 1 &lt; i is always 1, i and mi = |1 - i|. In the third sample case — consider the following intersection sequences: 1: 1; m1 = 0; 2: 1, 2; m2 = |2 - 1| = 1; 3: 1, 4, 3; m3 = 1 + |4 - 3| = 2; 4: 1, 4; m4 = 1; 5: 1, 4, 5; m5 = 1 + |4 - 5| = 2; 6: 1, 4, 6; m6 = 1 + |4 - 6| = 3; 7: 1, 4, 5, 7; m7 = 1 + |4 - 5| + 1 = 3. 题目大意给出n个点，如果直接从a1点到an点，耗费|xn-x1|的能量，不过每个点都存在一个到另一个点的“快速路径”，消耗能量为1，现在求从第一个点开始到每一个点消耗能量的最小值。 解题思路广搜，下一次搜索的规则是，左右相邻的点和该点快速路径到达的点（即消耗能量均为1的点），三个方向，这样一层一层往下搜索，第一次到达ai点时消耗的能量（计数器)即为从第一个点到该点消耗的最小能量。 解题代码123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102#include &lt;queue&gt;#include &lt;cstdio&gt;#include &lt;cstring&gt;#include &lt;cmath&gt;#include &lt;cstdlib&gt;#define maxn 200010using namespace std;int n;//个数 bool vis[maxn]; // 访问标记//int dir[4][2]=&#123;0,1,0,-1,1,0,-1,0&#125;; // 方向向量//int dir[8][2]=&#123;&#123;1,1&#125;,&#123;1,0&#125;,&#123;1,-1&#125;,&#123;0,1&#125;,&#123;0,-1&#125;,&#123;-1,1&#125;,&#123;-1,0&#125;,&#123;-1,-1&#125;&#125; ;int dir[3];struct State // BFS 队列中的状态数据结构&#123; int i; int ai; int Step_Counter; // 搜索步数统计器 bool first; int min;&#125;;State a[maxn];int ans[maxn];bool CheckState(State next) // 约束条件检验&#123; if(next.i&gt;0&amp;&amp;next.i&lt;=n&amp;&amp;!vis[next.i]) // 满足条件 &#123;// printf("next %d %d\n",next.i,next.ai); return 1; &#125; else // 约束条件冲突 return 0;&#125;void bfs(State st)&#123; queue &lt;State&gt; q; // BFS 队列 State now,next; // 定义2个状态，当前和下一个 st.Step_Counter=0; // 计数器清零 q.push(st); // 入队 vis[st.i]=1; // 访问标记 int circle=0; while(!q.empty()) &#123; now=q.front(); // 取队首元素进行扩展// a[now.i].Step_Counter=++circle; if(a[now.i].first) // 出现目标态，此时为Step_Counter 的最小值，可以退出即可 &#123; // 做相关处理// printf("first visit i=%d, min=%d\n",now.i,now.Step_Counter); a[now.i].min=now.Step_Counter; a[now.i].first=false;// return; &#125; else if(a[now.i].min&lt;now.Step_Counter) a[now.i].min=now.Step_Counter; dir[0]=now.i-1;dir[1]=now.i+1;dir[2]=now.ai; //生成下一组方向 for(int i=0;i&lt;3;i++) &#123; next.i=dir[i];// 按照规则生成 下一个状态 next.ai=a[dir[i]].ai; next.Step_Counter=now.Step_Counter+1; // 计数器加1 if(CheckState(next)) // 如果状态满足约束条件则入队 &#123; q.push(next);// printf("insert i=%d ai=%d\n",next.i,next.ai); vis[next.i]=1; //访问标记 &#125; &#125; q.pop(); // 队首元素出队 &#125; return;&#125;int main()&#123; while(~scanf("%d",&amp;n)) &#123; memset(vis,0,sizeof(vis)); for(int j=1;j&lt;=n;j++) &#123; a[j].i=j; a[j].first=true; scanf("%d",&amp;a[j].ai); &#125; bfs(a[1]); int flag=1; for(int j=1;j&lt;=n;j++) &#123; if(flag) &#123; printf("%d",a[j].min); flag=0; &#125; else printf(" %d",a[j].min); &#125; printf("\n"); &#125; return 0;&#125; 收获与反思思路清楚的话还是比较好写的，这里没有绝对的目标状态，所以全部遍历一遍每一个都打上Step值，然后输出就行。]]></content>
      <categories>
        <category>编程</category>
        <category>ACM</category>
      </categories>
      <tags>
        <tag>ACM</tag>
        <tag>算法</tag>
        <tag>2018寒假集训</tag>
        <tag>BFS</tag>
        <tag>CodeForces</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[【ZOJ-1709】解题报告（BFS）]]></title>
    <url>%2Fpost%2F42a619f7.html</url>
    <content type="text"><![CDATA[原始题目Oil Deposits Time Limit: 2 Seconds Memory Limit: 65536 KB The GeoSurvComp geologic survey company is responsible for detecting underground oil deposits. GeoSurvComp works with one large rectangular region of land at a time, and creates a grid that divides the land into numerous square plots. It then analyzes each plot separately, using sensing equipment to determine whether or not the plot contains oil. A plot containing oil is called a pocket. If two pockets are adjacent, then they are part of the same oil deposit. Oil deposits can be quite large and may contain numerous pockets. Your job is to determine how many different oil deposits are contained in a grid. InputThe input file contains one or more grids. Each grid begins with a line containing m and n, the number of rows and columns in the grid, separated by a single space. If m = 0 it signals the end of the input; otherwise 1 ≤ m ≤ 100 and 1 ≤ n ≤ 100. Following this are m lines of n characters each (not counting the end-of-line characters). Each character corresponds to one plot, and is either ‘*’, representing the absence of oil, or ‘@’, representing an oil pocket. OutputFor each grid, output the number of distinct oil deposits. Two different pockets are part of the same oil deposit if they are adjacent horizontally, vertically, or diagonally. An oil deposit will not contain more than 100 pockets. Sample Input1 1 * 3 5 *@*@* **@** *@*@* 1 8 @@****@* 5 5 ****@ *@@*@ *@**@ @@@*@ @@**@ 0 0 Sample Output0 1 2 2 SourceMid-Central USA 1997 题目大意给定一个用*和@标记的油田，找出不连续的油田总数。 解题思路每一个点入口BFS，搜索过的标记，最后记录广搜的总次数就行。 解题代码123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596#include &lt;queue&gt;#include &lt;cstdio&gt;#include &lt;cstring&gt;#include &lt;cstdlib&gt;#define maxn 105using namespace std;char map[maxn][maxn];//图int n,m;//n为行数，m为列数bool vis[maxn][maxn]; // 访问标记//int dir[4][2]=&#123;0,1,0,-1,1,0,-1,0&#125;; // 方向向量int dir[8][2]=&#123;&#123;1,1&#125;,&#123;1,0&#125;,&#123;1,-1&#125;,&#123;0,1&#125;,&#123;0,-1&#125;,&#123;-1,1&#125;,&#123;-1,0&#125;,&#123;-1,-1&#125;&#125; ;struct State // BFS 队列中的状态数据结构&#123; int x,y; // 坐标位置 int Step_Counter; // 搜索步数统计器&#125;;State a[maxn];bool CheckState(State s) // 约束条件检验&#123; if(s.x&gt;=0&amp;&amp;s.x&lt;m&amp;&amp;s.y&gt;=0&amp;&amp;s.y&lt;n&amp;&amp;map[s.x][s.y]&amp;&amp;!vis[s.x][s.y]) // 满足条件 &#123;// printf("next %d %d\n",s.x,s.y); return 1; &#125; else // 约束条件冲突 return 0;&#125;void bfs(State st)&#123; queue &lt;State&gt; q; // BFS 队列 State now,next; // 定义2个状态，当前和下一个 st.Step_Counter=0; // 计数器清零 q.push(st); // 入队 vis[st.x][st.y]=1; // 访问标记 while(!q.empty()) &#123; now=q.front(); // 取队首元素进行扩展// if(now==G) // 出现目标态，此时为Step_Counter 的最小值，可以退出即可// &#123;// ...... // 做相关处理// return;// &#125; for(int i=0;i&lt;8;i++) &#123; next.x=now.x+dir[i][0]; // 按照规则生成 下一个状态 next.y=now.y+dir[i][1];// printf("insert %d %d\n",next.x,next.y); next.Step_Counter=now.Step_Counter+1; // 计数器加1 if(CheckState(next)) // 如果状态满足约束条件则入队 &#123; q.push(next);// printf("insert %d %d\n",next.x,next.y); vis[next.x][next.y]=1; //访问标记 &#125; &#125; q.pop(); // 队首元素出队 &#125; return;&#125;int main()&#123; while(~scanf("%d%d",&amp;m,&amp;n)&amp;&amp;m+n) &#123; memset(vis,0,sizeof(vis)); for(int i=0;i&lt;m;i++) &#123; scanf("%s",map[i]); for(int j=0;j&lt;n;j++) &#123; if(map[i][j]=='*') map[i][j]=0; else if(map[i][j]=='@') map[i][j]=1; &#125; &#125; int count=0; for(int i=0;i&lt;m;i++) &#123; for(int j=0;j&lt;n;j++) &#123; if(map[i][j]&amp;&amp;!vis[i][j]) //此区域有油&amp;&amp;没有被访问过 &#123; count++; State curst; curst.x=i;curst.y=j;// printf("search %d %d\n",i,j); bfs(curst);//BFS搜索 &#125; &#125; &#125; printf("%d\n",count); &#125; return 0;&#125; 收获与反思第一次使用模板，对于这种图表示的还比较顺手，如何按照规则查找出下一个状态是广搜的关键。 PS：注意一些细节，比如1和i的区别，一点打错了要debug半天真的伤不起啊。]]></content>
      <categories>
        <category>编程</category>
        <category>ACM</category>
      </categories>
      <tags>
        <tag>ACM</tag>
        <tag>算法</tag>
        <tag>2018寒假集训</tag>
        <tag>BFS</tag>
        <tag>ZOJ</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[【CodeForces-600C】解题报告（贪心，字符串）]]></title>
    <url>%2Fpost%2F265c0f5.html</url>
    <content type="text"><![CDATA[原始题目C. Make Palindrome time limit per test 2 seconds memory limit per test 256 megabytes input standard input output standard output Problem Description A string is called palindrome if it reads the same from left to right and from right to left. For example “kazak”, “oo”, “r” and “mikhailrubinchikkihcniburliahkim” are palindroms, but strings “abb” and “ij” are not. You are given string s consisting of lowercase Latin letters. At once you can choose any position in the string and change letter in that position to any other lowercase letter. So after each changing the length of the string doesn’t change. At first you can change some letters in s. Then you can permute the order of letters as you want. Permutation doesn’t count as changes. You should obtain palindrome with the minimal number of changes. If there are several ways to do that you should get the lexicographically (alphabetically) smallest palindrome. So firstly you should minimize the number of changes and then minimize the palindrome lexicographically. InputThe only line contains string s (1 ≤ |s| ≤ 2·105) consisting of only lowercase Latin letters. OutputPrint the lexicographically smallest palindrome that can be obtained with the minimal number of changes. Examplesinputaabc outputabba inputaabcd outputabcba 题目大意任意输入一串字符，要求输出改动次数最少（移动交换位置不算做改动）且字典序最小的回文串。 解题思路贪心的想法比较直观。由于移动交换位置不算改动。贪心的从两端对称输出典序最小的字母，如果该字母出现次数位奇数，则从字典序最大的字母开始搜索，直至找到第一个出现个数也为奇数的字母（当然也是最大的），大字母的个数-1，小字母个数+1（即用小替换大），偶数个数会调整全部字母出现次数为偶数然后结束，奇数个数的话则需要额外判断，如果搜索到的字母和原字母相同，则说明该字母是中间字母（不一定该字母都在中间！）易错点：把中间字母单独提出来然后相邻的放到中间。 比如aabbhhwwhwwhhbbaa输入本应该原样输出，但是却输出了aabbwwhhhhhwwbbaa，这样会使字典序增大，需要对中间字母特殊处理（正常左右两端输出，只不过最后留一个在中间打印就行。） 解题代码123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147148149150151152153154155156157158159160161162163164165166167168#include &lt;cstdio&gt;#include &lt;iostream&gt;#include &lt;cstring&gt;#include &lt;cmath&gt;#include &lt;algorithm&gt;#define maxn 200100using namespace std;char s[maxn];char outs[maxn];//int alpha[26];bool mark[26];struct node&#123; char letter; int times;&#125;alpha[26];bool cmp(struct node n1,struct node n2)&#123; return n1.letter&gt;n2.letter;&#125;bool cmp1(struct node n1,struct node n2)&#123; return n1.letter&lt;n2.letter;&#125;void odd(int len)&#123;// printf("in odd\n"); for(int i=0;i&lt;len;i++) &#123; alpha[s[i]-97].times++; &#125; sort(alpha,alpha+26,cmp);// for(int i=0;i&lt;26;i++)// &#123;// printf("%d %c %d\n",i,alpha[i].letter,alpha[i].times);// &#125; int point=0,target=0; for(int i=0;i&lt;26;i++) &#123; if(!(alpha[i].times%2)) continue; else &#123; target=i; int j; for(j=target,point=0;j&lt;26;j++) &#123; if(!(alpha[j].times%2)) continue; else point=j; &#125; if(point==0) break; else &#123; alpha[point].times++; alpha[target].times--; &#125; &#125; &#125;// for(int i=0;i&lt;26;i++)// &#123;// printf("%d %c %d\n",i,alpha[i].letter,alpha[i].times);// &#125; char c=alpha[target].letter; char t=alpha[target].times;// printf("target=%c\n",c);// target 中间单值 int count=0; int leftlen=len-alpha[target].times; sort(alpha,alpha+26,cmp1);// printf("now len=%d\n",leftlen); for(int i=0;count&lt;(len-1)/2;i++) &#123; if(alpha[i].letter==c) for(int j=0;j&lt;(alpha[i].times-1)/2;j++) outs[count++]=alpha[i].letter; else for(int j=0;j&lt;alpha[i].times/2;j++) outs[count++]=alpha[i].letter; &#125; int i; for(i=0;i&lt;count;i++) &#123; printf("%c",outs[i]); &#125; printf("%c",c); for(i=count-1;i&gt;=0;i--) &#123; printf("%c",outs[i]); &#125; printf("\n");&#125;void even(int len)&#123;// printf("in even\n"); for(int i=0;i&lt;len;i++) &#123; alpha[s[i]-97].times++; &#125; sort(alpha,alpha+26,cmp);// for(int i=0;i&lt;26;i++)// &#123;// printf("%d %c %d\n",i,alpha[i].letter,alpha[i].times);// &#125; int point=0,target=0; for(int i=0;i&lt;26;i++) &#123;// if(i==25 ) printf("YOO\n"); if(!(alpha[i].times%2)) continue; else &#123; target=i; int j; for(j=target,point=0;j&lt;26;j++) &#123; if(!(alpha[j].times%2)) continue; else point=j; &#125; if(point==0) break; else &#123; alpha[point].times++; alpha[target].times--; &#125; &#125; &#125;// char c=alpha[target].letter;// char t=alpha[target].times;// printf("target=%c\n",c);// //target 中间单值 int count=0;// int leftlen=len-alpha[target].times; sort(alpha,alpha+26,cmp1);// printf("now len=%d\n",leftlen); for(int i=0;count&lt;len/2;i++) &#123; for(int j=0;j&lt;alpha[i].times/2;j++) outs[count++]=alpha[i].letter; &#125; int i; for(i=0;i&lt;count;i++) &#123; printf("%c",outs[i]); &#125; for(i=count-1;i&gt;=0;i--) &#123; printf("%c",outs[i]); &#125; printf("\n");&#125;int main()&#123;// freopen("in.txt", "r", stdin);//其实in.txt是可以修改成其他名字的 比如“输入.txt”，都是可以的，这里只是为了方便起见，下同； // freopen("outmy.txt", "w", stdout); while(~scanf("%s",s)) &#123; memset(alpha,0,sizeof(alpha)); for(int i=0;i&lt;26;i++) &#123; alpha[i].letter='a'+i; alpha[i].times=0; &#125; int len=strlen(s); if(len%2)//Odd odd(len); else even(len); &#125; return 0;&#125; 收获与反思（第一次写贪心，由于开始理解有偏差，改了很多次，代码也很丑陋= =而且太冗长= =，好在最后AC了，需要后面再优化下。）]]></content>
      <categories>
        <category>编程</category>
        <category>ACM</category>
      </categories>
      <tags>
        <tag>ACM</tag>
        <tag>算法</tag>
        <tag>2018寒假集训</tag>
        <tag>Greedy</tag>
        <tag>CodeForces</tag>
        <tag>字符串</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[【HDU-1716】解题报告（排列STL）]]></title>
    <url>%2Fpost%2Fe3e37943.html</url>
    <content type="text"><![CDATA[原始题目排列2 Time Limit: 1000/1000 MS (Java/Others) Memory Limit: 32768/32768 K (Java/Others) Total Submission(s): 9524 Accepted Submission(s): 3467 Problem DescriptionRay又对数字的列产生了兴趣：现有四张卡片，用这四张卡片能排列出很多不同的4位数，要求按从小到大的顺序输出这些4位数。 Input每组数据占一行，代表四张卡片上的数字（0≤数字≤9），如果四张卡片都是0，则输入结束。 Output对每组卡片按从小到大的顺序输出所有能由这四张卡片组成的4位数，千位数字相同的在同一行，同一行中每个四位数间用空格分隔。每组输出数据间空一行，最后一组数据后面没有空行。 Sample Input1 2 3 4 1 1 2 3 0 1 2 3 0 0 0 0 Sample Output1234 1243 1324 1342 1423 1432 2134 2143 2314 2341 2413 2431 3124 3142 3214 3241 3412 3421 4123 4132 4213 4231 4312 4321 1123 1132 1213 1231 1312 1321 2113 2131 2311 3112 3121 3211 1023 1032 1203 1230 1302 1320 2013 2031 2103 2130 2301 2310 3012 3021 3102 3120 3201 3210 解题思路先利用sort排序，然后利用C++STL中的next_permutation()函数将符合要求的排列逐个输出，本题需要注意输出格式有以下几点要求： 需要检测千位发生变化时换行（同一个数的排列每一行打印的四位数个数不一定相等） 含0的序列0不做首位（但是却经历这些排列，注意换行和空格的问题） 老样子，每一行最后一个四位数后没有空格，没有空格，没有空格（输出格式经常出的问题）。 除最后一行之外均有空行。 解题代码123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566#include &lt;cstdio&gt;#include &lt;cstring&gt;#include &lt;cmath&gt;#include &lt;algorithm&gt;using namespace std;int a[4];bool cmp(int a,int b)&#123; return a&lt;b;&#125;int main()&#123;// freopen("in.txt", "r", stdin);// freopen("out.txt", "w", stdout); int i,count=0,num=0; for(i=0;i&lt;4;i++) &#123; int c; scanf("%d",&amp;c); a[count++]=c;// printf("i=%d a[i]=%d\n",i,a[i]); &#125; sort(a,a+count,cmp); while(a[0]||a[1]||a[2]||a[3]) &#123; int circle=0; int qian=a[0]; if(qian&amp;&amp;num) printf("\n"); int sum=0; do &#123; int j; if(a[0]==0) continue; //跳过0开头的排列 if(a[0]!=qian) //换行判定 &#123; qian=a[0]; printf("\n%d",a[0]); &#125; else if(sum) printf(" %d",a[0]); //sum标记第一个数，sum非零四位数前均打印一个空格 else printf("%d",a[0]); for(j=1;j&lt;count-1;j++) &#123; printf("%d",a[j]); &#125; printf("%d",a[j]); sum++; &#125;while(next_permutation(a,a+count)); //使用do while 先打印一次再变为下个排列 printf("\n"); num++; count=0,i=0; for(i=0;i&lt;4;i++) &#123; int c; scanf("%d",&amp;c);// if(c)// &#123; a[count++]=c;// &#125;// printf("i=%d a[i]=%d\n",i,a[i]); &#125; sort(a,a+count,cmp); &#125; return 0; &#125; 收获与反思再次运用next_permutation函数，加深印象，以及对于输出格式的严格控制。]]></content>
      <categories>
        <category>编程</category>
        <category>ACM</category>
      </categories>
      <tags>
        <tag>ACM</tag>
        <tag>算法</tag>
        <tag>2018寒假集训</tag>
        <tag>HDU</tag>
        <tag>STL</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[【POJ-2260】解题报告（模拟，图论引申）]]></title>
    <url>%2Fpost%2F88e8ae98.html</url>
    <content type="text"><![CDATA[原始题目Error Correction Time Limit: 1000MS Memory Limit: 65536K Total Submissions: 6820 Accepted: 4286 Problem Description A boolean matrix has the parity property when each row and each column has an even sum, i.e. contains an even number of bits which are set. Here’s a 4 x 4 matrix which has the parity property: 1 0 1 0 0 0 0 0 1 1 1 1 0 1 0 1 The sums of the rows are 2, 0, 4 and 2. The sums of the columns are 2, 2, 2 and 2.Your job is to write a program that reads in a matrix and checks if it has the parity property. If not, your program should check if the parity property can be established by changing only one bit. If this is not possible either, the matrix should be classified as corrupt. InputThe input will contain one or more test cases. The first line of each test case contains one integer n (n&lt;100), representing the size of the matrix. On the next n lines, there will be n integers per line. No other integers than 0 and 1 will occur in the matrix. Input will be terminated by a value of 0 for n. OutputFor each matrix in the input file, print one line. If the matrix already has the parity property, print “OK”. If the parity property can be established by changing one bit, print “Change bit (i,j)” where i is the row and j the column of the bit to be changed. Otherwise, print “Corrupt”. Sample Input4 1 0 1 0 0 0 0 0 1 1 1 1 0 1 0 1 4 1 0 1 0 0 0 1 0 1 1 1 1 0 1 0 1 4 1 0 1 0 0 1 1 0 1 1 1 1 0 1 0 1 0 Sample OutputOK Change bit (2,3) Corrupt SourceUlm Local 1998 题目大意给定一个n*n的由0/1构成的boolean矩阵，判断是否各行各列和均为偶数。 若是输出OK，若不是，可否更改其中一点的位置使行列均为偶数。输出这个点，若不可以，输出Corrupt 解题思路改一个点即可的充要条件为行和列之中存在且仅有一行与一列的各自的和为奇数。 或者利用邻接矩阵的知识转化为有向图+深度优先搜索？？学姐讲的图论知识，还没有深入学习。]]></content>
      <categories>
        <category>编程</category>
        <category>ACM</category>
      </categories>
      <tags>
        <tag>ACM</tag>
        <tag>算法</tag>
        <tag>2018寒假集训</tag>
        <tag>Imitation</tag>
        <tag>Graph</tag>
        <tag>POJ</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[【POJ-1328】解题报告（二维转一维，贪心）]]></title>
    <url>%2Fpost%2Fcea184b4.html</url>
    <content type="text"><![CDATA[原始题目Radar Installation Time Limit: 1000MS Memory Limit: 10000K Total Submissions: 96097 Accepted: 21364 Problem Description Assume the coasting is an infinite straight line. Land is in one side of coasting, sea in the other. Each small island is a point locating in the sea side. And any radar installation, locating on the coasting, can only cover d distance, so an island in the sea can be covered by a radius installation, if the distance between them is at most d. We use Cartesian coordinate system, defining the coasting is the x-axis. The sea side is above x-axis, and the land side below. Given the position of each island in the sea, and given the distance of the coverage of the radar installation, your task is to write a program to find the minimal number of radar installations to cover all the islands. Note that the position of an island is represented by its x-y coordinates. Figure A Sample Input of Radar Installations InputThe input consists of several test cases. The first line of each case contains two integers $n (1 \le n \le 1000)$ and d, where n is the number of islands in the sea and d is the distance of coverage of the radar installation. This is followed by n lines each containing two integers representing the coordinate of the position of each island. Then a blank line follows to separate the cases. The input is terminated by a line containing pair of zeros OutputFor each test case output one line consisting of the test case number followed by the minimal number of radar installations needed. “-1” installation means no solution for that case. Sample Input3 2 1 2 -3 1 2 1 1 2 0 2 0 0 Sample OutputCase 1: 2 Case 2: 1 SourceBeijing 2002 题目大意给定二维平面N个点的坐标作为小岛坐标，给定雷达辐射半径，求坐标轴上放置雷达的最少个数。 解题思路将小岛在二维平面钟的坐标转化为一维坐标轴上的线段也即数轴上的闭区间。两个闭区间的交集表示可以同时辐射到这两个小岛的雷达可放置的区域。 由此，要使放置雷达的个数最少。将线段按左端点递增排序，采用贪心策略，对于下一个小岛能利用之前的雷达就利用，条件为，下一条线段的左端点小于公用范围（线段）右边界。否则雷达+1，并以该线段作为新雷达的公用范围。 注意：1.共用范围（线段）是不断减小的，后一条线段的有端点大于共用范围右端，则无影响，若小于右端，则新右边界变为该线段的右端点。 解题代码1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465666768697071727374#include &lt;cstdio&gt;#include &lt;cstring&gt;#include &lt;cmath&gt;#include &lt;algorithm&gt;#include &lt;queue&gt;#define maxn 10010using namespace std;struct line&#123; double left; double right;&#125;island[10002];bool cmp(struct line s1,struct line s2)&#123; return s1.left&lt;s2.left;&#125;int main()&#123;// freopen("in.txt", "r", stdin);// freopen("out.txt", "w", stdout); int ni,nd; scanf("%d%d",&amp;ni,&amp;nd); int count=0; while(ni||nd) &#123; bool flag=false; for(int i=0;i&lt;ni;i++) &#123; double x,y; scanf("%lf%lf",&amp;x,&amp;y); if(y&gt;nd) flag=true;// printf("x=%lf y=%lf\n",x,y); island[i].left=x-sqrt(nd*nd-y*y); island[i].right=x+sqrt(nd*nd-y*y); &#125; if(flag) &#123; printf("Case %d: -1\n",++count); scanf("%d%d",&amp;ni,&amp;nd); &#125; else &#123; sort(island,island+ni,cmp);// for(int i=0;i&lt;ni;i++)// printf("island[%d] left=%lf right=%lf\n",i,island[i].left,island[i].right); int num=1; double minright=island[0].right; for(int i=0;i+1&lt;ni;i++) &#123; if(island[i+1].left&lt;=minright) &#123; if(island[i+1].right&lt;minright) &#123; minright=island[i+1].right; &#125; &#125; else &#123; num++;// printf("num++\n"); minright=island[i+1].right; &#125; &#125; printf("Case %d: %d\n",++count,num); scanf("%d%d",&amp;ni,&amp;nd); &#125; &#125;// fclose(stdin);//关闭文件 // fclose(stdout);//关闭文件 return 0;&#125; 收获与反思二维问题转一维，学习一下。]]></content>
      <categories>
        <category>编程</category>
        <category>ACM</category>
      </categories>
      <tags>
        <tag>ACM</tag>
        <tag>算法</tag>
        <tag>2018寒假集训</tag>
        <tag>Greedy</tag>
        <tag>POJ</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[【CodeForces-825B】解题报告（模拟，五子棋）]]></title>
    <url>%2Fpost%2F74479d01.html</url>
    <content type="text"><![CDATA[原始题目B. Five-In-a-Row time limit per test 1 second memory limit per test 256 megabytes input standard input output standard output Alice and Bob play 5-in-a-row game. They have a playing field of size 10 × 10. In turns they put either crosses or noughts, one at a time. Alice puts crosses and Bob puts noughts. In current match they have made some turns and now it’s Alice’s turn. She wonders if she can put cross in such empty cell that she wins immediately. Alice wins if some crosses in the field form line of length not smaller than 5. This line can be horizontal, vertical and diagonal. InputYou are given matrix 10 × 10 (10 lines of 10 characters each) with capital Latin letters ‘X’ being a cross, letters ‘O’ being a nought and ‘.’ being an empty cell. The number of ‘X’ cells is equal to the number of ‘O’ cells and there is at least one of each type. There is at least one empty cell. It is guaranteed that in the current arrangement nobody has still won. OutputPrint ‘YES’ if it’s possible for Alice to win in one turn by putting cross in some empty cell. Otherwise print ‘NO’. ExamplesinputXX.XX..... .....OOOO. .......... .......... .......... .......... .......... .......... .......... .......... outputYES inputXXOXX..... OO.O...... .......... .......... .......... .......... .......... .......... .......... .......... outputNO 题目大意给定一个五子棋棋盘，判断X棋一步之后能否胜利。 解题思路没什么，自己写模拟。遍历每个可下的点判断横竖和斜方向上能否实现大于等于五子相连。 注意边界问题，可以采用左右上下各拓展4行4列。 解题代码123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114#include &lt;cstdio&gt;#include &lt;cstring&gt;#include &lt;cmath&gt;#include &lt;algorithm&gt;#include &lt;queue&gt;#define maxn 10010using namespace std;char map[20][20];bool check(int a,int b)&#123; map[a][b]=1;// printf("begin check %d %d\n",a,b); int conti,i,j; for(conti=0,i=a-4;i&lt;=a+4;i++) //横向判断 &#123; if(map[i][b]==1) &#123; conti++; if(conti&gt;4) return true; &#125; else &#123; conti=0; continue; &#125; &#125; for(conti=0,j=b-4;j&lt;=b+4;j++) //纵向判断 &#123; if(map[a][j]==1) &#123; conti++; if(conti&gt;4) return true; &#125; else &#123; conti=0; continue; &#125; &#125; for(conti=0,i=a-4,j=b-4;i&lt;=a+4;i++,j++) //斜向判断1 &#123; if(map[i][j]==1) &#123; conti++; if(conti&gt;4) return true; &#125; else &#123; conti=0; continue; &#125; &#125; for(conti=0,i=a-4,j=b+4;i&lt;=a+4;i++,j--) //斜向判断1 &#123; if(map[i][j]==1) &#123; conti++; if(conti&gt;4) return true; &#125; else &#123; conti=0; continue; &#125; &#125; map[a][b]=0; return false; &#125;int main()&#123;// freopen("in.txt", "r", stdin);//其实in.txt是可以修改成其他名字的 比如“输入.txt”，都是可以的，这里只是为了方便起见，下同； for(int i=0+4;i&lt;10+4;i++) &#123; scanf("%s",map[i]+4); &#125; for(int i=0+4;i&lt;10+4;i++) &#123; for(int j=0+4;j&lt;10+4;j++) &#123; switch(map[i][j]) &#123; case 'X': map[i][j]=1;break; case 'O': map[i][j]=2;break; case '.': map[i][j]=0;break; &#125;// printf("%d ",map[i][j]); &#125;// printf("\n"); &#125; int flag=0; for(int i=0+4;i&lt;10+4;i++) &#123; for(int j=0+4;j&lt;10+4;j++) &#123; if(map[i][j]||!map[i-1][j]&amp;&amp;!map[i+1][j]&amp;&amp;!map[i][j-1]&amp;&amp;!map[i][j+1]&amp;&amp;!map[i-1][j-1]&amp;&amp;!map[i+1][j+1]&amp;&amp;!map[i-1][j+1]&amp;&amp;!map[i+1][j-1]) continue; else flag=check(i,j); if(flag) &#123;// printf("%d %d \n",i-4,j-4); break; &#125; &#125; if(flag) break; &#125; if(flag) printf("YES\n"); else printf("NO\n");// fclose(stdin);// fclose(stdout); return 0;&#125; 总结与反思模拟的时候要注意细节，尽量不要返工。 能简化的简化（后面会学到剪纸），比如判定周围一圈没有棋子可以直接continue跳过该循环。]]></content>
      <categories>
        <category>编程</category>
        <category>ACM</category>
      </categories>
      <tags>
        <tag>ACM</tag>
        <tag>算法</tag>
        <tag>2018寒假集训</tag>
        <tag>Imitation</tag>
        <tag>CodeForces</tag>
        <tag>Graph</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[【HDU-1027】解题报告（排列STL）]]></title>
    <url>%2Fpost%2Fa4c66bf4.html</url>
    <content type="text"><![CDATA[原始题目Ignatius and the Princess II Time Limit: 2000/1000 MS (Java/Others) Memory Limit: 65536/32768 K (Java/Others) Total Submission(s): 9305 Accepted Submission(s): 5446 Problem Description Now our hero finds the door to the BEelzebub feng5166. He opens the door and finds feng5166 is about to kill our pretty Princess. But now the BEelzebub has to beat our hero first. feng5166 says, “I have three question for you, if you can work them out, I will release the Princess, or you will be my dinner, too.” Ignatius says confidently, “OK, at last, I will save the Princess.” “Now I will show you the first problem.” feng5166 says, “Given a sequence of number 1 to N, we define that 1,2,3…N-1,N is the smallest sequence among all the sequence which can be composed with number 1 to N(each number can be and should be use only once in this problem). So it’s easy to see the second smallest sequence is 1,2,3…N,N-1. Now I will give you two numbers, N and M. You should tell me the Mth smallest sequence which is composed with number 1 to N. It’s easy, isn’t is? Hahahahaha……”Can you help Ignatius to solve this problem? InputThe input contains several test cases. Each test case consists of two numbers, $N$ and $M$ (1 \le N \le 1000, 1 \le M \le 10000). You may assume that there is always a sequence satisfied the BEelzebub’s demand. The input is terminated by the end of file. OutputFor each test case, you only have to output the sequence satisfied the BEelzebub’s demand. When output a sequence, you should print a space between two numbers, but do not output any spaces after the last number. Sample Input6 4 11 8 Sample Output1 2 3 5 6 4 1 2 3 4 5 6 7 9 8 11 10 AuthorIgnatius.L 题目大意定义排列逆序，输出对应编号的排列 解题思路利用C++STL中的next_permutation()函数实现对数组排列，调用m-1次该函数然后按格式输出即可。 解题代码12345678910111213141516171819202122232425262728293031323334#include &lt;iostream&gt; #include &lt;algorithm&gt;#include &lt;string&gt;#include &lt;stack&gt;#include &lt;vector&gt;#define maxn 100010using namespace std;int a[maxn];int main()&#123; int n,m; while(cin&gt;&gt;n&gt;&gt;m)// cin&gt;&gt;n&gt;&gt;m;&#123; for(int i=0;i&lt;n;i++) &#123; a[i]=i+1; &#125;// vector&lt;int&gt; v1(a,a+n); 没有利用上vector 待补充 // vector&lt;int&gt;::iterator p=v1.begin(); int count=m-1; //设置计数器 do //注意使用dowhile &#123;// for(int j=0;j&lt;n;j++)// cout&lt;&lt;a[j]&lt;&lt;" ";// cout&lt;&lt;endl; count--; &#125;while(next_permutation(a,a+n)&amp;&amp;count); for(int j=0;j&lt;n-1;j++) cout&lt;&lt;a[j]&lt;&lt;" "; cout&lt;&lt;a[n-1]&lt;&lt;endl; //输出格式最后一个数后面没有空格 &#125; return 0;&#125; 收获与反思图片待添加]]></content>
      <categories>
        <category>编程</category>
        <category>ACM</category>
      </categories>
      <tags>
        <tag>ACM</tag>
        <tag>算法</tag>
        <tag>2018寒假集训</tag>
        <tag>补图</tag>
        <tag>HDU</tag>
        <tag>STL</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[《乌合之众——群体心理研究》读后感]]></title>
    <url>%2Fpost%2F94c9baee.html</url>
    <content type="text"><![CDATA[内容摘录 P51 影响大众想象力的不是是事实本身，而是他所扩展和传播的方式。 P56 群体的所有信仰都采取宗教形式，对群体来说，必须有个神，否则什么都谈不上。 P92 理性从来就不曾指导过群体，这值得后悔吗？我们不敢这么说。理性把人类带向了文明之路，但缺乏幻觉所激起的那种热情和勇敢。这些幻觉也许是必要的，它们是支配我们的无意识造成的。 P100 第二种领导，意志持久……他们聪明过人，还是智慧有限，这不重要。世界将永远属于他们。他们所拥有的持久意志是一种十分罕见而强大的能力，能战胜一切。 P160 （议会制）它反映了一种心理上错误但被普遍认同的观点，即对某个问题，许多人聚在一起比一小部分人更能做出明智而独立的决定。 P177 随着古老理想的彻底丧失，种族将最终完全失去自己的灵魂，成了一群独处的个人，回到了起点：群体，表现出一切短时间的特征，步调不一，没有前途。文明失去了稳定性，只能随风飘散。民众掌握了至高无上的大权，社会变得越来越野蛮。文明似乎还能辉煌一段时间，因为它扔拥有漫长历史所建的外墙，但那其实是一座已经被虫蛀空的大厦，支撑不了多久，暴风雨一来就会倒塌。从野蛮到文明，一路追逐着梦想，而当这种梦想失去了力量，便开始衰落，走向死亡，这就是一个民族的生命周期。]]></content>
      <categories>
        <category>阅读</category>
      </categories>
      <tags>
        <tag>阅读</tag>
        <tag>社科</tag>
        <tag>古斯塔夫・勒庞</tag>
        <tag>乌合之众</tag>
      </tags>
  </entry>
</search>
