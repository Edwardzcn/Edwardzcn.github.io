<?xml version="1.0" encoding="utf-8"?>
<search>
  
  
  
  <entry>
    <title>《战争时期的日本精神史》读书笔记</title>
    <link href="/post/5ed09799.html"/>
    <url>/post/5ed09799.html</url>
    
    <content type="html"><![CDATA[<h1 id="战争时期日本精神史（1931-1945）"><a href="#战争时期日本精神史（1931-1945）" class="headerlink" title="战争时期日本精神史（1931-1945）"></a>战争时期日本精神史（1931-1945）</h1><h2 id="导读-异端之必要"><a href="#导读-异端之必要" class="headerlink" title="导读 异端之必要"></a>导读 异端之必要</h2><p>译者谈鹤见俊辅。</p><blockquote><p>i “最后一次谈及鹤见俊辅，是在一家过分拥挤的意大利餐厅里。这是纽约 4 月的一个傍晚，我与坂本龙一斜对而坐。”</p><p>“在一张餐巾纸上，我写下了几个日本知识分子的名字，丸山真男、加藤周一以及鹤见俊辅。在我有限的理解中，他们是战后日本社会的关键人物，他们的思想与行动塑造了一代人的成长。”</p><p>iv “他最重要的‘转向’研究也是如此。1959 年至 1961 年间，他与合作者完成了三卷本《转向》，追溯并讨论为何在战时日本，知识分子们，不论他们是马克思主义者、自由派，还是宗教人士，皆在国家权力的强制下，半强迫、半自愿地转变了思想。”</p><p>vii “专制，这种政治生活之癌，是如何一点点侵蚀一个健康肌体，而人们又是怎样丧失抵抗能力的。与德国、意大利不同，日本从未有过一个魅力四射的独裁者，一个总是掩藏于幕后的天皇与一群技术官僚，导致了这一切的发生。”</p><p>viii “教育也是如此，在小学与士兵的教育中，采用以天皇神话为中心的世界观，而高等教育则以欧洲为模板，相信天皇的权威要被限制在宪法之内。前者是‘显教’，后者则是‘密教’。在鹤见俊辅看来，明治时代的缔造者们设计了一套方案，希望‘显教’与‘密教’共存，彼此制衡，但最后显教部分吞没了密教部分。”</p></blockquote><h2 id="一-向-1931-年至-1945-年的日本趋近"><a href="#一-向-1931-年至-1945-年的日本趋近" class="headerlink" title="一 向 1931 年至 1945 年的日本趋近"></a>一 向 1931 年至 1945 年的日本趋近</h2><p>几点随想奠定基调。</p><blockquote><p>P001 “从现在开始，我要谈论的主题是，1931 年至 1945 年的日本精神史。在进入主题之前，我先说明几点随想。”</p></blockquote><ul><li><p><strong>语言与信任</strong>：</p><p>一个有意思的现象，说英语的日本人不值得信任。</p><blockquote><p>P001 “1945 年至 1952 年美军占领日本期间，我曾就此再三向遇见的美国人说明。因此，对我来说，我希望各位在我试图谈论日本之际，对我所说出的话，都能稍打折扣，再予思考。”</p><p>P002 “在我看来，借用欧化语言的表述，未必意味着思考本身的欧化。但由于在短期间内，从欧洲语言中借用如此之多的语汇，就某种意义而言，现代的日本人可说也变得难以了解自己。确实，就某个层面而言，我们已经失去自觉自身思维方式的思路。”</p></blockquote></li><li><p><strong>成为开端</strong>：</p><blockquote><p>P002 “其次，我想强调的是，我希望这门课成为一个开端，借此让我们理解战争期间日本发生了什么，日本之外的地方又发生了什么，以及非战争期间的时代，日本和日本以外的地区发生过什么样的状况。”</p></blockquote></li><li><p><strong>脱离标准范式</strong>：</p><blockquote><p>P003 “那些被当成脱离标准范式的现象，反而更能表现出该社会的文化特征。1931 年至 1945 年日本所发生的事情，不能视为明治初年以来，近代日本史中的一个偶发事件而加以抹杀。”<br>“我们是经由错误成长，并且是经由自觉到我们所犯的错误中，包含的真理与价值而成长。”</p></blockquote></li><li><p><strong>历史的区分</strong>：</p><blockquote><p>P003 “第四，以历史的区分而言，我们在此把第二次世界大战的肇始，设定于 1931 年中日战争（即九一八事变）的爆发。1931 年日本的陆军领导者再中国的满洲开启战端，并进而在这个地区建立日军的傀儡政权。这种方法对整个世界而言，实乃前所未见。因而后来也导致意大利的墨索里尼和德国的希特勒都加以仿效。”</p></blockquote></li></ul><blockquote><p>P004 “当然，倘若外国人对日本的兴趣仅仅是出于异国情调，他的爱好与观点必然维持在其出生国所受的各种文化熏陶。在这样的情况下与日本文化的接触，只是在其原本的各种价值观上，蒙上了一层日本文化的外衣，整个内涵依然没有改变。”</p></blockquote><p>作者的观点，要了解日本文化“真貌”，空间结构下，将中、日、朝放到一起思考，还要再加上对应的时间结构，因而掌握日本再 1931 年至 1945 年漫长争战中的历史背景，就变得至关重要了。</p><blockquote><p>P006 “如何诠释现代的事件，常因我们平时抱持的偏见而有所歧异……单靠被报道出的事并不足恃，因为未被报道的事也包含许多重要的事实。”</p></blockquote><p>突然联想起《有所不为的反叛者》里所提及的“遗忘的重要性”，如果此处以孤岛表示历史显露出的部分，我们不应完全忽略潜藏在遗忘之海之下的真相。</p><h2 id="二-关于转向"><a href="#二-关于转向" class="headerlink" title="二 关于转向"></a>二 关于转向</h2><blockquote><p>P007 “首先，我说明一下‘转向’的背景。1905 年日俄战争结束，对日本而言是个崭新时代的开端。自 1867 年明治新政府成立以来，约莫四十年间，日本国民都生活在必须攀登‘文明阶梯’——如果说真有这种东西的话——的使命感之中。”</p><p>P008 “（反德川政府）运动的倡导者在权力实际转移之前，几乎都为理想捐躯了。例如，吉田寅次郎、桥本左内、坂本龙马、高杉晋作等人。其后，西乡隆盛、大久保利通、木户孝允等，被视为实现这些先烈的构想、成功地推翻德川幕府并建立新政府的重要人物。</p><p>…</p><p>在进入明治时代之后，这些志士们短期内依然保留着一种<strong>敏锐的自觉</strong>，清楚地意识到，参与推翻幕府运动中的精英分子都已不在人世。”</p></blockquote><p>随着先驱入土，最为纯粹的那些思想或许也被带进了地底。后继者们最初还保持着敏锐的自觉与勤勉质朴的特点，但维系不久了。</p><blockquote><p>P009 “在此，我不以明治维新为起点，而谈及幕末到日俄战争这段时间领导阶层的气氛，主要是想凸显明治时代的领导阶层，与承继其后的大正、昭和时代领导阶层的对比。”</p></blockquote><p>日本借鉴中国古科考制度创立了基于学校入学考试制定的身份制度。</p><blockquote><p>P010 “诚如罗纳德·多尔（Ronald Philip Dore）在《学历社会——新文明病》中所述，日本政府早在 1880 年就已经使用考试制度选拔公务人员。当时东京帝国大学法学院的毕业生，任职公务人员不需经过考试，并且保证一开始就能担任较高的职位。”</p></blockquote><p>东 大 新 人 会，要了解东大新人会的重要性，首先建立起 1917 俄国革命对日本大学生产生了重要影响的认识。不过从作者的描述中，我读出了无奈学生太过年轻，领导人根源性改变初始想法仍然不变其领导地位，导致了集体的转向，这种转向在年轻一带中很难称得上背叛，因为他们认为本该如此。</p><blockquote><p>P013 “1918 年 12 月，东京大学法学院的学生赤松克麿、宫崎龙介和石渡春雄创立了‘东大新人会’。组织纲领是由赤松起草，内容如下：</p><ul><li>吾人配合世界文化之势——人类解放的新趋势，并努力促进之。</li><li>吾人致力从事现代日本之合理改造运动。”</li></ul></blockquote><p>最初</p><blockquote><p>P014 “这群新人会的成员对于 20 世纪 20 年代，组织共同阵线阻止军国主义的议题并不感兴趣。”</p></blockquote><p>不久，创始人与初始成员纷纷转向，而他们的带动作用是可怕的。</p><ul><li><p>赤松克麿</p><blockquote><p>“不久，新人会的创始人和创始成员背离了社会主义运动，转而趋向国家社会主义。新人会创始人赤松克麿，1922 年加入日本共产党，其后又脱离共产党，1930 年出任社会民众党的总书记。此后，他开始阐述天皇的责任，认为天皇的责任就是保护国民的利益。这种观点导引他把‘九一八事变’的发生，和建立‘满洲国’的举动正当化。他已经在替日本寻找可以和定为国策的侵略中国政策并存的民主化与社会主义化的道路了。”</p></blockquote></li><li><p>宫崎龙介</p><blockquote><p>“另一位新人会的创始人宫崎龙介，在太平洋战争发生前的时期，即以内阁总理大臣近卫麿公爵的密使身份进行活动，劝说中国国民党与日本合作。”</p></blockquote></li><li><p>麻生久</p><blockquote><p>“新人会创始成员之一的麻生久，曾以 30 年代社会大众党重要领导人的身份，推动工会的领导人与倾向国家社会主义的改革派军官结合。”</p></blockquote></li><li><p>佐野学</p><blockquote><p>“其他创始成员之中，以佐野学最为重要。他二十七岁时，以东京帝国大学毕业生的身份参加东大新人会。1933 年，他四十一岁，担任日本共产党的委员长，同时也是共产党的最高领导人，与同为中央委员委员的锅山贞亲，在狱中发表‘转向’的共同声明。”</p><p>“佐野学与锅山贞亲撤回他们之前所有的主张：<strong>废除天皇制</strong>、<strong>赋予包括被殖民的各民族在内所有民族的自治权等</strong>；并且，他们也撤回了原本所有论点的总结——<strong>反对日本政府的‘九一八事变’政策</strong>。他们改口说，要从苏联的桎梏中解放自己，对天皇及其所代表的文化价值表示尊敬，以发展日本的社会主义。”</p></blockquote><p>佐野学，日共当时的最高负责人，并没有因立场的改变，而提出退党申请。</p></li></ul><blockquote><p>P016 “佐野与锅山的共同声明发表后，‘转向’一词变成那个时代的流行语。这个词汇被一般民众纳入日常生活用语之中。</p></blockquote><p>一段插曲，“转向”词汇的诞生，本是“方向转换”的缩写，但是提出不同词汇的两个人思想主张却又不同。</p><p>明治社会主义者山川均发表《无产阶级运动的方向转换》，提出前卫分子必须回到无产阶级群众中。而德国研学回国的福本和夫则批判山川的 i 昂发，他认为共产主义者应该自觉本身的思考方法，并使之转向，以此对同时代的社会能有所行动。</p><blockquote><p>“于是‘方向转换’被缩写而产生‘转向’一词，意指人妖自觉其自身思索的过程，并给予符合自身思想水准的新方向。也就是说，在这个意义下，‘转向’之前的思想是一种顺从社会习惯行动的惰性思想。”</p><p>“在学生间成为流行语的‘转向’一词，后来被依《治安维持法》设置、对危险言行进行调查的思想警察所采用……被置身在这种技巧下受到诱导的青年，虽然以前依循福本和夫定义的转向之路前进。”</p><p>P017 “这就是 20 世纪 30 年代以后，‘转向’一词被纳入日本日常用语，并广泛使用的整个历史经纬。主要的意义在于，在国家权力之下造成思想的转变是可能发生的。”</p></blockquote><p>转向还是背叛？</p><blockquote><p>P018 “至于‘背叛’——这个词带有明显的贬损意味。有人向警察秘密告自己以前的同志时，就用这个字眼，这种场合或许可以称作背叛。然而，如果我们将 1931 年至 1945 年日本所发生的转向现象，一律都已‘背叛’的恶名统称的话，我们就会丧失<strong>从谬误中发掘真理的机会</strong>。”</p></blockquote><p>后面这段话也是我读的时候的感觉，以家国之转向反过来思考人生的‘转向’。</p><blockquote><p>P019 “我不断地问自己下面的问题：在漫长的人生中，有人能不经历‘转向’的吗？导引这些人‘转向’的条件是什么？他们如何将他们的‘转向’正当化？经历过战争后，回顾‘转向’的时候，他们是怎么思考的？</p><p>在我看来，这些问题在我们研究 1931 年至 1945 年间的日本时，是极为重要的。”</p></blockquote><a id="more"></a><h2 id="三-锁国"><a href="#三-锁国" class="headerlink" title="三 锁国"></a>三 锁国</h2><p>日本人的锁国性。</p><blockquote><p>P022 “日本人始终抱有一种感觉，认为自己一直住在并且也能继续住在自己金瓯无缺的土地上。在这块固若金汤的土地上，日本人往往觉得若要走出国境之外就必须抱定决心，只要身处日本便不用害怕会突然遭到外国人的攻击。这是日本人的一般体验且心照不宣的前提之一，只是很少在日本人日常生活的思考方式中显现出来。我们可以把日本人思考方式的此一层面成为‘锁国性’。”</p></blockquote><p>伊藤整是优秀的知性主义派作家，在 20 世纪 30 年代，收到詹姆斯·乔伊斯（James Joyce）等西欧心理主义文学影响，以身兼诗人、小说家和评论家而闻名。</p><blockquote><p>P025 “通过伊藤整的一生与著作，我们既可以见到自由主义转向的事例之一，也可以在战后时代从转向回复的过程中，看到自古以来的街头技艺的复苏。”</p><p>P028 “锁国性这种日本文化特征，也对转向过程带来影响，甚至可以说转向过程本身大都是来自于锁国性这种文化特征。”</p></blockquote><p>认知锁国性是一个漫长且艰难的过程</p><blockquote><p>P032 “只要锁国性代表日本文化的主要倾向，日本就无法有效地解决日本现今所存在的问题。东大新人会的成员已经自觉到这种新处境的艰困，但不能说他们已具有充分解决问题的方法的洞察力。他们不仅对日本的未来欠缺洞察力，也欠缺对自身未来的洞察力！”</p></blockquote><h2 id="四-关于国体"><a href="#四-关于国体" class="headerlink" title="四 关于国体"></a>四 关于国体</h2><p>谈“国体”是一种广泛存在于世界上国家的基本结构还是日本特有的推进力量。</p><blockquote><p>P033 “国体的概念在这段漫长的战争时期被当成强而有力的语言工具，用来防御或攻击日本人的政治地位。”</p><p>P033 “‘国体’一词的起源，可见于吉田寅次郎（吉田松阴）与山县大华的往来书简中。吉田认为，词语指涉日本民族特有的推进力量。他的论敌山县大华则不承认日本民族中有这种特有的东西。山县指出，世界上每个民族都有同样的推进力量，因此‘国体’概念并非日本所特有。”</p></blockquote><p>根据《古事记》，日本特指的国体。</p><blockquote><p>P034 “……根据这个故事，‘国体’可解释成：以众神之后绵延不绝、万世一系的天皇家系为中心，并以天皇家系为信仰核心的概念。”</p></blockquote><p>根据桥川文三的记述，日本国体概念的形成历史，在十五年战争开始之前，教育体系被划分为之前所提及的“显教”与“密教”双轨制。</p><blockquote><p>P034 “依明治时代建造者的观点而言，日本人应该让作为一个国家宗教的密教和显教部分的信徒，分别接受不同的训练。这是新国家的建造者对日本自锁国状态以来各种困难的解决方式。他们在国际政治权力的波涛中为国家掌舵的同时，使尽量在不损及明知之前家族制度与村落制度的强大结合力下，来完成这项工作。”</p></blockquote><p>当然，十五年战争期间明显是显教压倒密教，不存在重臣阶层区间调节做“屏风”作用的年代。日本显密教体系受到西方欧洲文明强烈的影响。1871 年新政府冒着巨大的金钱风险送一批富有学习能力的年轻人（岩仓具、木户孝允、大久保利通等）去西方国家学习他们的制度。</p><blockquote><p>P037 “这些高级官员派遣团对西方诸国科技的发达与效率印象深刻，也对推行有效率的统治组织所依据的宗教及伦理信条感到羡慕。因此他们试图修改日本的神道传统，采纳作为支撑高效率技术文明的力量。于是，‘天皇崇拜’被当成可让日本更加繁荣的技术文明殿堂之思想基础。”</p></blockquote><p>皇室传说，如前述《古事记》，被改造了！或许我们可以理解为是从混元却落后的制度中分立出“显教”与“密教”。“显教”为表，“密教”为实。</p><blockquote><p>P039 “我不认为这是近代日本才有的特殊现象，在实行神权政治的地方，绝对有其类似的政治惯例。明治以后的政府，除了具有民主政治的性质之外，也包含这种神权政治的特质。至于两者是如何组合交际的，我们必须审慎看待。”</p></blockquote><p>“<strong>现人神</strong>”——天皇的无谬性为中心所建构出的国体观念。</p><p>当明治国家建造者所设计的秩序无法运作时，国民就通过无视法纪的人表现他们积存的不满，“密教”失灵，自由派学说遭到抵制，被抬上“神轿”不放的天皇也很无奈。</p><blockquote><p>P041 “当时，担任天皇侍从武官长的本庄繁陆军上将（1876——1945）在日记中，曾记下他与天皇的对话。本庄试图把当时陆军的想法传达给天皇，天皇对此说出了这样的感想：‘如果我们用思想或信念压抑科学，世界的进步就会停顿下来。如此一来，连进化论之类的思想也被推翻了——然而，这并不是说不需要思想和信念。总之，我认为思想与科学应该同时并进。’”</p><p>P042 “至少自 1931 年以来，领导者对日本与假想敌国在军力和经济力上的差距，一直提供给国民相反的资讯，导致自己也因此陷入自我欺骗的境地。对国家的领导者而言，要从对国民的持续欺骗中，保持自我的清醒，是非常困难的。让当时日本的领导者踏上太平洋战争之路的决策背后，就隐藏着这种困难。回到前述的譬喻来说，由于日本国家宗教的显教部分在漫长的岁月里吞没了密教部分，使得日本国家原始建造者们的构想因而瓦解了。”</p></blockquote><p>二度“国体明征”的宣示——明确以天皇为中心的国体概念，为战前喧嚣一时的右倾思想。</p><p>日本战败，同一个天皇亲自宣称自己是“人”而不是“神”（《人间宣言》的发表）之后，国体观念也像一小片头皮屑般从头上掉下来，之后就只剩下肉体而已。</p><p>结尾语</p><blockquote><p>P045 “然而，日本四面环海，完全没有路上的国界，又使用相同的语言，只要狭窄的岛屿中继续住着稠密的人口，锁国性就没那么容易消除。因此，今后我们还必须不断提问：<strong>国体观念会以何种形式保留下来？</strong>”</p></blockquote><h2 id="五-大亚细亚"><a href="#五-大亚细亚" class="headerlink" title="五 大亚细亚"></a>五 大亚细亚</h2><blockquote><p>P047 “所谓‘大亚细亚’，是日本人用来表达与亚洲大陆居民关系的词语。更精确地说，是指与包含日本人在内的亚洲人和平共存的理想大共同体。”</p></blockquote><p>从鹤见俊辅的理解，军国主义者所提的“大东亚共荣圈”发源于大亚细亚思想，但却不一样，核心词——“军事需要”。</p><blockquote><p>P048 “大东亚共荣圈的范围是依据军事需要而决定的。为了确保 1931 年以后在军事发展上所获得的利权，陆军、海军参谋官与学者合作完成多项草案。在这些草案提出之前，已经有石原莞尔（1889——1949）倡议东亚联盟的构想。石原莞尔是应对‘九一八事变’及其后发生军事行动负起责任的关东军参谋官之一。石原认为，日本必须觉悟，不久将会与包括苏联在内的西方帝国主义国家发生冲突，所以（他本身对这开战也有责任）和中国间的对战状态不能长期持续下去。他的解决方案是，日本、中国和‘满洲国’在平等的基础上建立友好关系。石原是‘满洲国’的主要建造者之一。然而，‘满洲国’成立后，随着东条英机的掌权，石原被逐出权力的核心。不久，所有的陆军，甚至稍后的中央政府，都被纳入东条的势力掌控之下。石原在陆军的所有重要职位全被解除，因为在东条看来，石原的构想里具有谋叛的因子。”</p></blockquote><p>后面讲述大亚细亚思想相关的一个关键人物——尾埼秀实。尾埼于 1937 年加入了后藤隆之助建立起的“昭和研究会”，不仅担任中国问题研究会的主席，还负责全部十二个研究会的协调工作。尾崎在这一期间内活跃于政坛，并与理查德·佐尔格保持密切的联系。不过二人后来双双被日本警察逮捕（间谍罪）。尾崎自己构想出大亚细亚的雏形，并预言问题的源头是国内资本家间的纠葛（和我们所学的国内矛盾转移来发动战争一致）。</p><blockquote><p>P050 “作为中国问题专家的尾崎秀实，曾在 1931 年 1 月号的《中央公论》杂志上，发表题为《‘东亚协同体’的理念及其形成的客观基础》的文章。他说：‘实践东亚协同体理论的过程中伴随发展的得失，虽然乃视中日抗争的张力关系或国际关系而定，但在日本国内推动此事产生的势力集结，才是最重要的问题。’他还预言，实际问题是发生在和日本国内资本家间的纠葛。”</p><p>…</p><p>尾崎作为大亚细亚主义评论家的地位，不应该因为他与佐尔格集团有所牵扯而被贬损。最终判决的审判长高田正是宣判尾埼死刑的法官，他对前前近卫内阁司法大臣、因结识尾崎而失去职位的风见章说：‘<strong>尾崎是值得尊敬的人，他能将信念付诸行动，在这一点上，我非常尊敬他。</strong>’</p></blockquote><p>尾崎是一名独立的共产主义者，与日共与共产国际并无关系，是接近民族主义的共产主义者。在东京帝国大学法务部时期，也并未加入当时流行的新人会运动。我真的佩服他这种纯粹的自我认同，驱动自己将理念付诸实践。</p><blockquote><p>P052 “尾崎被捕并判处死刑之后，包括众多右翼政治立场鲜明的人士及其朋友们都纷纷表示惋惜，由此可见他的人品。他的主要委任律师竹内金太郎，是一位出了名有骨气的国家主义者。他一直为尾崎辩护直到后者被处决为止，并称尾崎为真正的爱国者。”</p></blockquote><p>日本政府纳入了大亚细亚的观念，但却剖有些“功法逆练”的味道。从战争命名中可以看出，不是“太平洋战争”，也不是“对美英战争”，最后定名为“大东亚战争”，其他候补的名称并没有把日本与中国之间持续进行的战争状态包括在内，而此战斗状态才是这次宣战的真正的原因。日本以对东亚地区抱有的“共荣”、“责任”（或许经过右翼分子的伪装），与最初尾崎的大亚细亚观念并不相同，战败岁月里，始终未能正视败给中国的事实。</p><blockquote><p>P053 “这场漫长的战争之所以持续进行，是因为日本政府无力终止战事，这才是真正的原因。换句话说，倘若没有日本文化里固有的锁国性这个条件，这场战争肯定不会持续下去。”</p><p>P057 “大冈升平在这本书中，附了很多与菲律宾战争相关的书籍和小册子的庞大文献表，还强调这个文献目录是这本书最重要的部分。一位小说家说出此言实在极为少见。在此，我们可以感受到，日本文学史与精神史已展现出全新的特质。从其字源来看，所谓的‘大东亚’，是伴随 20 世纪 40 年代日本政府的军事需要而产生额字眼。（后面这几句存疑）战争即将结束前，由于胜利已经无望，日本政府决定让亚洲各民族独立。这个决定意味着日本政府不想再白费力气，因为他们已经无法采取任何措施来改变当前的局势了。”</p></blockquote><p>对后面几句存疑，毕竟鹤见俊辅并没有给出日本政府进行这样思考的依据，而我们不能确定是各民族追求自身独立在先还是日本政府这种“摆脱包袱”的想法在先，即便是后者，也不见得是“决定让亚洲各民族独立”。</p><p>精神史上，日本人著作有沿袭“大亚细亚”观念的系统，他们（以竹内好为主）认为：“日本人必须有所觉悟，我们的民族将在这场战争中改变性格，我们的国家在解放亚洲各民族的努力中也不得不变形。”。他们的构想基于一个预感：不打破日本政府当前的结构，就无法抑制政府领导者支配亚洲各国的野心。</p><p>还有战后评论家松本健一所指，从战后东南亚经济关系中看出的比战时鼓吹的大东亚共荣圈更有效的实现形式。以日本为中心的偏颇性质，仍保有战争时期日本所显示的形态，更有效的实现形式，要打破这种由锁国性引发的偏颇。</p><h2 id="六-非转向的形式"><a href="#六-非转向的形式" class="headerlink" title="六 非转向的形式"></a>六 非转向的形式</h2><p>我曾经以为日本人清晰的了解唐传佛教、神道教的区别，从鹤见的书中我才知道，日本人很少认真思考佛教与神道教的差异。</p><blockquote><p>P062 “日本人很少认真思考佛教与神道教的差异，虽然这两种宗教在西方比较宗教的书籍中被区分为两种不同的宗教，但其实在日本人的感觉中几乎是相连的。在此种宗教意识中，也纳进了佛教及神道教以外的各种宗教，这些宗教最后都消融在日本式的宗教信仰中了。”</p></blockquote><p>本节主要从一条小径研究日本人的宗教信仰是如何形成的，以及日本人共同信仰的性质。不过因为我个人对宗教兴趣不大，了解的也少，所以本节不进行过多摘录。</p><p>转与守。</p><blockquote><p>P074 “……那就是所谓‘非转向’的状态并不是静止不动的状态。由于人乃血肉之躯，行动总处于不停摆动的状态，这也包含不做某种行动的抑制状态。人类无论出于何种状态，都无法脱出这种摆动的状态。进一步说，在摆动的状态中，人必须依靠某种基本价值来支撑自己。这种基本价值基准，在语言的原义中，可称为宗教。”</p></blockquote><h2 id="七-日本之中的朝鲜"><a href="#七-日本之中的朝鲜" class="headerlink" title="七 日本之中的朝鲜"></a>七 日本之中的朝鲜</h2><blockquote><p>P077 “通过日本人对朝鲜人的态度，我们可以将日本人的思想放在一种‘分光仪’中加以分析。这跟区分或左或右的政治思想不同，它可以呈现出各种想法。前文曾稍提及，日本政府试图把文明强加于朝鲜，这里所指的文明指‘西化’。”</p></blockquote><p>日本人（不管左翼还是右翼）都坚信，只要能攀登上文明阶梯，就算是使用暴力亦未尝不可。</p><blockquote><p>P078 “樽井藤吉拟出一个构想——把日本和朝鲜合并为一，在平等的基础上建立一个具有新名称的新国家。这个想法在 1910 年由日本政府付诸实行，却不是建立在樽井所梦想的平等基础上，最后，日本吞并了朝鲜国。”</p></blockquote><p>一些有识之士批评日本自然主义文学太过小我。</p><blockquote><p>P078 “日本政府采取‘日韩合并’的行动，对日本人和朝鲜人带来如何严峻的后果，当时对此进行深思的日本人为数不多，诗人石川啄木是少数其中之一。他在朝鲜国灭亡那天写了一首哀悼的短诗（诗歌），同时，他也写评论，批判日本的自然主义文学只着重刻绘日本人私生活的细节。他又说，如果自然主义文学家有勇气描写日本人的生活，就应该描写国家使日本人的自由窒息的事实。”</p></blockquote><p>对待朝鲜的态度，也是一种“转向”。明治以前，日本朝鲜双方对于所谓的“教养”是以使用中国汉字，写出中国式散文和诗词的能力作为衡量。相较于四面环海的日本国，与中国地理上的接近使得朝鲜使节往往这方面能力远超日本知识分子，因而也使得朝鲜整体得到日本的尊重。但是随着明治维新，上述评价标准被学习西方知识，攀登文明阶梯所取代，日本人也从此看不起朝鲜人。</p><p>石川啄木是一名激进的社会思想家。而在保守的文学家中，还有柳宗悦。</p><blockquote><p>P085 “…….柳宗悦因为热爱朝鲜的工艺，于是对日本政府采取破坏朝鲜民族文化的政策，明显表示抗议。对于日本政府在 1919 年毫不留情地镇压朝鲜独立运动的示威游行，柳宗悦也写过几篇随笔加以抗议……他谨慎地把自己的批评陷于工艺和美术的领域，没有直接对政治本身提出批判。然而，日本吞并朝鲜后，尽管已经过了一二十年，他并没有屈服于这个即成事实，仍不改把日本与朝鲜写成‘两个国家’的作风。”</p></blockquote><h2 id="八-以‘非斯大林化’为目标"><a href="#八-以‘非斯大林化’为目标" class="headerlink" title="八 以‘非斯大林化’为目标"></a>八 以‘非斯大林化’为目标</h2><blockquote><p>P091 “对向来把文明阶梯视为一个实体的日本人而言，1917 年 11 月俄国的布尔什维克革命，为他们的想象力带来了很大的刺激。这个刺激通过东大新人会的组织，扩及日本全国的知识分子，和以准知识分子自居的年轻族群。”</p></blockquote><p>日本共产党诞生之初，存在着侥幸逃过“大逆事件”的幸存者与激进年轻大学生们的思想对立。</p><blockquote><p>P092 “日本共产党创立之初，其领导者山川均是经历过‘大逆事件’，并戮力从事社会主义运动的幸存者之一。他提出忠告：<strong>日本的左翼知识分子必须对劳工阶级每天为挣取生存粮食所付出的努力，表示更大的同情，而且必须和他们结合起来。</strong>不过这个观点，却遭到刚返抵国门不久的福本和夫反驳，他是代表新时代留学德国，并用原文学习共产主义理论的年轻教授。福本和夫在解释列宁主义时指出，<strong>精英知识阶层首先要从群众中抽离出来，再以激进知识分子的身份彻底武装理论，才是左翼群众运动与知识分子进行大团结之前的必要条件。</strong>”</p></blockquote><p>抽离——武装——团结，据鹤见俊辅所讲，福本提出“先离后合”的组织论，在当时信奉社会主义阿知识分子之间获得胜利，而称为日本共产党创立初期深具指导性的理论家。但是后来又受共产国际所送交“1927 年纲领”等诸多影响。</p><p>对于“转向”与“不转向”，日本共产党人似乎走到了死胡同，“转向”则有些许对原始信念的背叛，转而信奉以天皇家系信仰为核心的显教理论，而“不转向”，似乎又意味着没有脱离苏联共产国际的指示，盲目信仰缺乏独立判断与事实依据的空洞理论。</p><blockquote><p>P093 “1931 年日本开始侵略中国，两年后，发生了日本共产党支持者集体转向的事件。有党员要求，要守护日本共产党这面旗帜，需要无比的勇气和长期的坚持抗争。因此有十几人宁愿忍受漫长的牢狱生涯，有几个人死在狱中，也有残存到战争结束的。这些党员，无视于日本政府十五年来所做的军国主义宣传，仍旧忠诚地信奉着苏联共产国际起草的‘纲领是科学’的真理，更遑论对共产国际总部指示的方针做出质疑或批判了。当时，脱离日本共产党的成员在‘转向’的时候，至少已经认识到，共产国际所做的方针，对在日活动的了解不够充分。而这种‘认识’，在他们转向时起了很大的作用。”</p></blockquote>]]></content>
    
    
    <categories>
      
      <category>Life</category>
      
      <category>阅读</category>
      
    </categories>
    
    
    <tags>
      
      <tag>阅读</tag>
      
      <tag>待补充</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>《计算机程序设计艺术卷1》读书笔记</title>
    <link href="/post/d9071f2b.html"/>
    <url>/post/d9071f2b.html</url>
    
    <content type="html"><![CDATA[<h1 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h1><p>这本“圣经”体量太大，所以笔者只记录自己想记录的或者有必要记录的。</p><p>根据作者所提整套丛书的内容总览，卷 1（基本算法）可以看成整套丛书的交集，包含了其他卷都需要用到的基本内容，不仅可以作为阅读其他各卷的参考书，还可以用作一些课程的教材，比如离散数学（1.1 节、1.2 节、1.3.3 节和 2.3.4 节），数据结构（主要是第 2 章）。</p><a id="more"></a><h1 id="第-1-章-基本概念"><a href="#第-1-章-基本概念" class="headerlink" title="第 1 章 基本概念"></a>第 1 章 基本概念</h1><h2 id="算法"><a href="#算法" class="headerlink" title="算法"></a>算法</h2><p>算法（algorithm）的五个特征：有限性、确定性、输入、输出、可行性（有效性）。</p><p>谈算法的有限性（有穷性），一个过程如果具备算法除有限性外的全部特征，那么可以称为<strong>计算方法</strong>。在实践中对各种算法在广义美学意义下判定<strong>好的</strong>，涉及到算法的执行次数、执行效率、对计算机的适应性、算法本身的优雅。面对同一问题的多种算法，判别最佳算法将我们引向<strong>算法分析</strong>（algorithmic analysis）。</p><p><strong>算法的形式定义</strong>：本节最后会用集合论作为算法概念的坚实基础，把一种<strong>计算方法</strong>形式地定义为一个四元组$(Q,I,\Omega,f)$，四个量分别表示计算状态、输入、输出和计算规则。</p><ul><li>$Q$是包含子集$I$和$\Omega$的集合</li><li>$f$是$Q$映射到自身的函数</li><li>$\Omega$应在$f$映射下点点不动</li></ul><p>集合$I$中的每个输入$x$定义一个<strong>计算序列</strong>$x_0,x_1,x_2,\cdots$，如下：</p><script type="math/tex; mode=display">x_0 = x \qquad x_{k+1} = f(x_k) \quad for \quad k \ge 0</script><p>如果$k$是使$x_k$在$\Omega$中的最小整数，就说计算序列在$k$步内中止。某些计算序列可能永远不会终止。对于$I$中的所有$x$都能在有限步骤内中止的计算方法就是<strong>算法</strong>。</p><p>注意$Q$内元素可以为集合，陷入单元素想法的话不好理解书中紧接着对算法 1.1E 的形式化描述。</p><h2 id="数学准备"><a href="#数学准备" class="headerlink" title="数学准备"></a>数学准备</h2><p>本节更可取的学习方式，先略读这一节，在见过后面的大量应用过后，再返回来进行深入的学习。</p><h3 id="数学归纳法"><a href="#数学归纳法" class="headerlink" title="数学归纳法"></a>数学归纳法</h3><p>将数学归纳法看成一个<strong>算法式证明过程</strong>（构造证明），比如下面对任意正整数$n$，产生$P(n)$的证明。</p><ul><li>I1. [证明$P(1)$.] 置$k \leftarrow 1$</li><li>I2. [$k=n$?] 如果$k=n$，算法终止，输出。</li><li>I3. [证明$P(k+1)$.] “如果$P(1),\cdots,P(k)$全部为真，那么$P(k+1)为真$的证明，并输出。</li><li>I4. [增加$k$.] $k$增加 1，转到步骤$I2.$.</li></ul><p>注意，算法过程主要描述了<strong>蕴含关系</strong>的证明（这也是我们使用数学归纳法关注的地方），但若要得到推理出的证明结论，必须要证明前提，这是我们常常会忽略的地方！比如应用到了前述项$P(2)$，但是却是个伪命题。这样即便蕴含关系成立，证明也是错误的。</p><p>注意，将数学归纳法的概念同科学中常说的归纳推理区别开来。</p><p>建设归纳推理是个“猜测”的过程（构造图示理解，如果我们不能证明对于所有$n$都可以进行这种构造，就仍是一种归纳推理）。</p><p>举例，关于斐波那契数列$F$的一个性质，定义$F_0 =0$，$F_1 = 1$，$F_{n+2} = F_{n+1} + F_n$。现在我们证明，如果令$\phi = (1+\sqrt{5})/2$，那么对于所有正整数$n$，我们有：</p><script type="math/tex; mode=display">F_n \le \phi^{n-1} \tag{1}</script><p>称之为$P(n)$（以命题理解），其归纳法证明过程</p><ul><li>对于$n=1$，那么$F_1 = 1 = \phi^0$</li><li><p>假设$P(1),P(2),\cdots,P(n)$全部为真，并且$n &gt; 1$。我们得到：</p><script type="math/tex; mode=display">F_{n+1} = F{n-1} + F{n} \le \phi^{n-2} + \phi^{n-1} = \phi^{n-2}(1+\phi) \tag{2}</script><p>对于数$\phi$有一条重要性质。</p><script type="math/tex; mode=display">1+\phi = \phi^2 \tag{3}</script><p>式(3)带入式(2)后我们得到$F_{n+1} \le \phi^n$，即$P(n+1)$</p></li></ul><!-- TODO --><p>（对拓展欧几里得的数学归纳证明略，待补充）</p><p>其中对拓展欧几里得算法的证明，从未证明算法会终止，我们只证明了<strong>如果算法终止，那么它会给出正确的答案。</strong></p><p>通常需要单独证明算法会终止。</p><p>习题中涉及广义归纳法，这个一般原理称为<strong>良序原理</strong>（回顾良序概念，后面再回过头来看这个题目）。</p><h2 id="数、幂与对数"><a href="#数、幂与对数" class="headerlink" title="数、幂与对数"></a>数、幂与对数</h2><p>考虑对数运算，书中给出的方法，由于有限精度，必须舍入或者<strong>截断</strong>，带来的计算误差。</p><p>放几个习题吧。</p><p>1.2.2.10 证明 $\log_{10} 2$不是有理数。</p><blockquote><p>Prove by contradiction 假设$\log_{10}2$是有理数，则有$\log_{10}2 = \frac{p}{q}$，则$2^q = 10^p$，显然该式矛盾，因为等式左边不被 5 整除，故$\log_{10}2$不是有理数。</p></blockquote><p>1.2.2.19 如果整数$n$的十进制表示长 14 位数，$n$的值能否存入容量为 47 个二进制位和 1 个符号位的一个计算机字。</p><blockquote><p>$\lg n = \log_{10} n / \log_{10} 2 = 14  \lg 10$，又因$\lg 10 \approx 3.322$（向上），$14 \times 3.33 \approx 46.62 &lt; 47$，故可以存入。</p></blockquote>]]></content>
    
    
    <categories>
      
      <category>Life</category>
      
      <category>阅读</category>
      
    </categories>
    
    
    <tags>
      
      <tag>阅读</tag>
      
      <tag>待定</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>字节跳动分布式存储系统研发实习生面试记录</title>
    <link href="/post/d29f5a77.html"/>
    <url>/post/d29f5a77.html</url>
    
    <content type="html"><![CDATA[<h1 id="第一轮面试"><a href="#第一轮面试" class="headerlink" title="第一轮面试"></a>第一轮面试</h1><!-- TODO --><p>（由于当时在搬家记不太清了）</p><p>算法题</p><ul><li><p>分析复杂度</p><blockquote><p>分析下面数据结构的插入的复杂度，A0-Ak 是一个数组，他们要么为空，要么分别存储 1，2，4，8 这么多个元素，如果当前数组满足不了插入，则将当前数组的元素和新插入的元素合并到下一层。每个数组内部都是有序的。新来一个元素先插入 A0，如果 A0 已经有 1 个元素，根据规则，则将两个元素归并插入 A1；如果 A1 有 2 个元素，则将 4 个归并到 A2，诸如此类。</p><p>A0: [1]<br>A1:<br>A2: [4,5,8,10]<br>A3: [2, 6, 9, 12, 13, 16, 20, 25]</p></blockquote></li><li><p>给定$n$段原木和指定木材数量$k$，求满足数量要求的最长木材长度$l$（整数，二分法，拓展思考分数形式，这个没想出来，但是分数形式是必定有解的）。</p><blockquote><p>有一些原木，现在想把这些木头切割成一些长度相同的小段木头，需要得到的小段的数目至少为 k。当然，我们希望得到的小段越长越好，你需要计算能够得到的小段木头的最大长度。</p><p>木头长度的单位是厘米。原木的长度都是正整数，我们要求切割得到的小段木头的长度也要求是整数。无法切出要求至少 k 段的,则返回 0 即可。</p></blockquote></li></ul><h1 id="第二轮面试"><a href="#第二轮面试" class="headerlink" title="第二轮面试"></a>第二轮面试</h1><p>面试问题有以下</p><ul><li>问数据库中 ACID 的实现方式。</li><li>问进程上下文切换的原因，以及线程切换轻量一些的原因（同进程内共享地址空间？）</li><li>锁的种类，问了自旋锁</li><li>用户发起一次 I/O 操作（如 read、write）从用户空间到最底层的过程（操作系统内核）</li><li>Raft 协议中，A、B、C 三个节点，若 A、C 之间出现网络隔离，是否会在 leader election 中出现问题<br>-</li></ul><p>算法题</p><ul><li><p>最长不重复子串（DP）</p><blockquote><p>标题：最长无重复子串</p><p>无重复子串指：子串中每个字符都不相同</p><p>例如：s = ‘aaabcdddd’ 最长的无重复子串为’abcd’长度为 4</p></blockquote></li><li><p>任意两个节点求最近公共祖先</p><blockquote><p>假设 p/q 是二叉树上的两个 node，求离他们最近的公共的 parent</p></blockquote></li><li><p>多线程 Hash Table（不会）</p><blockquote><p>写一个支持高并发访问的 hash table(int)</p></blockquote></li><li><p>链表形式快排</p><blockquote><p>划分链表</p><p>给出一个链表和一个值 $x$ ，以 $x$ 为参照将链表划分成两部分，使所有小于 $x$ 的节点都位于大于或等于 $x$ 的节点之前。两个部分之内的节点之间要保持的原始相对顺序。</p><p>$1→4→3→2→5→2$ 和 $x=3$,</p><p>返回</p><p>$1→2→2→4→3→5$.</p></blockquote></li></ul><a id="more"></a>]]></content>
    
    
    <categories>
      
      <category>Career</category>
      
      <category>面试</category>
      
    </categories>
    
    
    <tags>
      
      <tag>面试</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>CSU-ReadingGroup计划书</title>
    <link href="/post/285520cf.html"/>
    <url>/post/285520cf.html</url>
    
    <content type="html"><![CDATA[<h1 id="CSU-ReadingGroup-计划书"><a href="#CSU-ReadingGroup-计划书" class="headerlink" title="CSU-ReadingGroup 计划书"></a>CSU-ReadingGroup 计划书</h1><h2 id="初衷"><a href="#初衷" class="headerlink" title="初衷"></a>初衷</h2><p>为帮助正在科研、有科研倾向的学生（以本科生为主）了解计算机科学领域发展前沿，以论文分享会为主要活动构建的小组，暂时归属在 Disc0ver 组织下。</p><h2 id="意义"><a href="#意义" class="headerlink" title="意义"></a>意义</h2><p>总的来说，ReadingGroup 仍然属于 Disc0ver 组织<a href="https://github.com/disc0ver-csu" target="_blank" rel="noopener">知识共享平台</a>的一部分，参与者每周可利用 ReadingGroup 的线上会议获取计算机科学领域不同方向的新知。更细致的讲，根据参与者身份不同，收获也不尽相同：</p><ul><li><strong>主讲者</strong>：主讲者经较长时间资料准备后，利用 ReadingGroup 提供的平台进行在线会议分享。这一过程中，细致的准备过程要求主讲者精读 paper，除整体有一个较全面的认识外，加强对数学原理的理解以及相关文献的调研，这是个人粗读 paper 过程中不容易达到的（特别是在文献阅读初期）。分享过程也会锻炼主讲者 Slides 准备的能力，演讲的口才以及答辩能力（因为涉及和听众的互动）。</li><li><strong>听众</strong>：听众在 ReadingGroup 的固定线上会议中的收获是弹性的，轻可简要了解论文涉及的方向，如果听者自身愿意在会议前自主完成一定的 preview 工作，则可随主讲者步伐深入挖掘论文的核心部分。</li></ul><a id="more"></a><h2 id="初步计划"><a href="#初步计划" class="headerlink" title="初步计划"></a>初步计划</h2><ul><li><p>1-3 周</p><ul><li>以邀请制建立 4-6 人的团队，进行为期 1-2 周的试讲。</li><li>广泛听取论文获取、讲解方式、讲解时长的建议。</li><li>这一过程中可能一周会有多次尝试。</li></ul></li><li><p>4-? 周</p><ul><li>据情况邀请更多的听众进入会议，广泛听取意见。</li><li>确定每周固定交流时间</li><li>确定申请主讲者的要求</li><li>排布时间表（以项目形式展现在 Disc0ver 组织）</li></ul></li><li><p>?-? 周</p><ul><li>进行小规模宣传，逐步放开听众申请的限制</li></ul></li></ul><h2 id="需要讨论的问题"><a href="#需要讨论的问题" class="headerlink" title="需要讨论的问题"></a>需要讨论的问题</h2><ul><li>主讲时长与资料选择问题（论文/教材？）</li><li>方向跨度较大是否需要平衡？</li><li>由于不考虑邀请老师加入，讲解材料的质量如何保证，以及其他由于指导老师缺失可能造成的问题（时刻思考）。</li></ul>]]></content>
    
    
    <categories>
      
      <category>Research</category>
      
      <category>方法</category>
      
    </categories>
    
    
    <tags>
      
      <tag>方法</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>华为招聘会——计算产品线笔记</title>
    <link href="/post/f5d17bb6.html"/>
    <url>/post/f5d17bb6.html</url>
    
    <content type="html"><![CDATA[<h1 id="Cloud-amp-AI-BG-（计算产品线）"><a href="#Cloud-amp-AI-BG-（计算产品线）" class="headerlink" title="Cloud &amp; AI BG （计算产品线）"></a>Cloud &amp; AI BG （计算产品线）</h1><h2 id="Part-1"><a href="#Part-1" class="headerlink" title="Part 1"></a>Part 1</h2><ul><li>目的：主要了解该部门提供的岗位、业务需求、岗位要求等。</li><li>愿景：为世界提供最强算力，构建万物互联的智能世界。</li></ul><h2 id="Part-2"><a href="#Part-2" class="headerlink" title="Part 2"></a>Part 2</h2><p>自我介绍，xx 权（无线产品线 2 年控制器、2012 实验室 2 年、计算产品线）</p><h3 id="计算的重要性"><a href="#计算的重要性" class="headerlink" title="计算的重要性"></a>计算的重要性</h3><p><strong>计算</strong>是智能世界的源动力，各种应用场景，比如抢票平台</p><h3 id="岗位链"><a href="#岗位链" class="headerlink" title="岗位链"></a>岗位链</h3><p>中间件类：Storage、Ceph</p><p>三大平台：鲲鹏（基于 ARM）、晟腾（面向 AI）、x86（通用计算平台）</p><p>OpenEuler（自研操作系统）、OpenGauss（自研数据库）</p><p>愿景，打破 Intel、AMD 在 CPU 的垄断地位，为世界提供多一种的算力选择（鲲鹏）。</p><h3 id="海外机会"><a href="#海外机会" class="headerlink" title="海外机会"></a>海外机会</h3><p>贴近技术源头，研发全球化布局，为计算产业创新提供源动力。</p><h3 id="Q-amp-A"><a href="#Q-amp-A" class="headerlink" title="Q&amp;A"></a>Q&amp;A</h3><ol><li>您好我有两个小问题，华为自研操作系统，OpenEuler 和 HarmonyOS（鸿蒙），以我仅有的理解，OpenEuler 是基于 Linux 单内核，以及鸿蒙是基于微内核的。在服务器端，比如我们计算产品线，没有提到陈海波老师所领导的 HarmonyOS，是目前编译工作没有做到基于特定的平台嘛？另一个子问题就是，如果想要进行微内核架构研发相关的工作，华为公司要求我们这些学生具备哪些能力，投递哪个部门比较合适？</li><li></li></ol><a id="more"></a>]]></content>
    
    
    <categories>
      
      <category>Life</category>
      
      <category>随笔</category>
      
    </categories>
    
    
    <tags>
      
      <tag>随笔</tag>
      
      <tag>招聘会</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>《你当像鸟飞往你的山》读书笔记</title>
    <link href="/post/32773e56.html"/>
    <url>/post/32773e56.html</url>
    
    <content type="html"><![CDATA[<h1 id="序"><a href="#序" class="headerlink" title="序"></a>序</h1><p>巴克峰、父亲、童年。</p><p>连绵山脉与芭蕾舞团般漫山遍野的野生小麦，局外人是浪漫与自由，局中人只会说：“这里有我的童年”。</p><blockquote><p>P003 “父亲所有的故事都关乎我们的山，我们的山谷，我们呈锯齿状的爱达荷州。他从来没有告诉过我，如果我离开这座山，如果我飘洋过海，发现自己置身于陌生的地面，再也无法在地平线上搜寻那位公主时，我该怎么办。他从未告诉过我如何知道，我该回家了。”</p></blockquote><a id="more"></a><h1 id="第一部分"><a href="#第一部分" class="headerlink" title="第一部分"></a>第一部分</h1><h1 id="择善"><a href="#择善" class="headerlink" title="择善"></a>择善</h1><blockquote><p>P008 “‘到他晓得弃恶择善的时候，’爸爸的声音低沉而单调，搬运了一整天的废料，他已疲惫不堪，‘他必吃奶油与蜂蜜’。</p><p>…</p><p>他把这段话又大声读了一遍，接着读了第三遍、第四遍。随着每一次重复，声调越来越高。他刚刚因疲倦而肿胀的眼睛，现在睁得大大的，充满警觉。他说，此处有一条神圣教义，他会求问耶和华。</p><p>第二天早上，爸爸把我们冰箱里的牛奶、酸奶和奶酪全部清除干净。当天晚上他回家时，卡车上装了五十加仑的蜂蜜。”</p></blockquote><h2 id="助产士"><a href="#助产士" class="headerlink" title="助产士"></a>助产士</h2><h2 id="奶油色鞋子"><a href="#奶油色鞋子" class="headerlink" title="奶油色鞋子"></a>奶油色鞋子</h2><h2 id="阿帕奇女人"><a href="#阿帕奇女人" class="headerlink" title="阿帕奇女人"></a>阿帕奇女人</h2><h2 id="诚实的污垢"><a href="#诚实的污垢" class="headerlink" title="诚实的污垢"></a>诚实的污垢</h2><p>一个人踏上漫无目的的旅途，是有多大的勇气，又有多大的孤独。</p><blockquote><p>P061 “多年以后，我才会明白他那天离开的代价是什么，他对自己要去的地方有多么不了解……我不知道他为什么这么做，他也不知道。他无法解释这个信念从何而来，也无法解释它是如何发出明亮的光来穿透那黑暗的不确定。”</p><p>“有那么一刻，我在想难道这就是泰勒想要的：漂亮的房子，漂亮的卫生间，漂亮的妹妹。也许他离开就是为了这个。想到这里我就对他心生怨恨。”</p></blockquote><h2 id="大小盾牌"><a href="#大小盾牌" class="headerlink" title="大小盾牌"></a>大小盾牌</h2><p>我无法想象，如果我的母亲沉迷于“肌肉测试”与“精神力量”会怎样。</p><p>“上帝和他的天使就在我们身边守护呢。”所以呢？</p><blockquote><p>P076 “我一瘸一拐地穿过牧场，直到爸爸消失在视野中，才在麦草上失声崩溃。我颤抖着，大口大口地喘着粗气。我不明白我为什么哭。我还活着。我会没事的。天使们已尽了他们地本分。可我为什么无法停止颤抖呢？”</p></blockquote><p>上学=自甘堕落=走向地狱？</p><blockquote><p>P078 “他的意思是说，我不是他养育出地女儿，他地女儿秉持虔诚的信仰。我竟然为了一碗破汤而试图出卖自己与生俱来的权利。”</p></blockquote><h2 id="耶和华必预备"><a href="#耶和华必预备" class="headerlink" title="耶和华必预备"></a>耶和华必预备</h2><p><strong>耶和华必预备</strong>，出自《圣经》：“亚伯拉罕给那地方起名叫耶和华以勒（意思就是‘耶和华必预备’），直到今日人还说：‘在耶和华的山上必有预备’”（《创世记》22:14）神要亚伯拉罕将儿子以撒献上当作祭物，以试验他的顺从和忠心。亚伯拉罕照做，于是神预备了羔羊代替以撒作为祭物，以撒便不必死。这句话是说生活中要顺从神，要有信心和忠心，神必为我们预备一切。</p><blockquote><p>P088 “我试着想象做出决定的那一刻。爸爸看着那些杂草，它们在颤抖的热浪中渴望火焰，迅速燃烧。他看着儿子，心想如果趁火势不大时将其扑灭，就能阻止一场燎原之火，也许还能拯救房子。”</p></blockquote><p>活在这样的精神世界中必不轻松。爸爸先是祈祷孩子保持清醒，没有大事，又要祈祷火势可控，脱下衬衫，与火焰战斗。</p><h2 id="小妓女"><a href="#小妓女" class="headerlink" title="小妓女"></a>小妓女</h2><p>“上帝保佑我们，我们非常有福。”</p><blockquote><p>P096 “我用想的方式唱出了它们。但之前现实从未曾屈服于我的想法。”</p><p>“我从未见过父亲的这一面，但之后又见了许多次——每次都是在我唱歌后。不管他在肥料厂工作了多久，不管他有多累，他都会开车翻山越岭去听我唱歌。”</p></blockquote><h2 id="当时世代的完全人"><a href="#当时世代的完全人" class="headerlink" title="当时世代的完全人"></a>当时世代的完全人</h2><blockquote><p>P098 “一九九九年夏天，我在《安妮》一剧中担任主唱。父亲处于严阵以待的状态。自从我五岁时韦弗一家被围攻，他从未像现在这样肯定，世界末日马上要降临了。”</p><p>P107 “在我看来，与那天早上相比，他更矮小了。他脸上的失望是如此孩子气，一时间我疑惑上帝怎么能不遂他的心愿。他是那样虔诚的信徒，心甘情愿地受苦，就像挪亚心甘情愿去建造方舟一样。”</p><p>P107 “但上帝并未让洪水泛滥。”</p></blockquote><h2 id="羽毛盾牌"><a href="#羽毛盾牌" class="headerlink" title="羽毛盾牌"></a>羽毛盾牌</h2><blockquote><p>P118 “外科医生拔除了这些牙，并让肖恩尽量保护好乳牙，等乳牙全部烂掉，医生就会给牙齿打桩。但他的乳牙从未烂掉，而是留存下来，成了错位童年的顽固遗物，提醒那些目睹他毫无意义、无休无止、不负责任的好斗行为的人，这个男人曾经也是个孩子。”</p></blockquote><h2 id="直觉"><a href="#直觉" class="headerlink" title="直觉"></a>直觉</h2><h2 id="鱼眼睛"><a href="#鱼眼睛" class="headerlink" title="鱼眼睛"></a>鱼眼睛</h2><h2 id="沉默的教堂"><a href="#沉默的教堂" class="headerlink" title="沉默的教堂"></a>沉默的教堂</h2><h2 id="我的双脚已离开土地"><a href="#我的双脚已离开土地" class="headerlink" title="我的双脚已离开土地"></a>我的双脚已离开土地</h2><h2 id="不再是孩子"><a href="#不再是孩子" class="headerlink" title="不再是孩子"></a>不再是孩子</h2><h2 id="不忠的人，违逆的天堂"><a href="#不忠的人，违逆的天堂" class="headerlink" title="不忠的人，违逆的天堂"></a>不忠的人，违逆的天堂</h2><h1 id="第二部分"><a href="#第二部分" class="headerlink" title="第二部分"></a>第二部分</h1><h2 id="守安息日为圣日"><a href="#守安息日为圣日" class="headerlink" title="守安息日为圣日"></a>守安息日为圣日</h2><h2 id="鲜血和羽毛"><a href="#鲜血和羽毛" class="headerlink" title="鲜血和羽毛"></a>鲜血和羽毛</h2><h2 id="回到原点"><a href="#回到原点" class="headerlink" title="回到原点"></a>回到原点</h2><h2 id="父辈的吟诵"><a href="#父辈的吟诵" class="headerlink" title="父辈的吟诵"></a>父辈的吟诵</h2><h2 id="美黄芩"><a href="#美黄芩" class="headerlink" title="美黄芩"></a>美黄芩</h2><h2 id="我们的低语，我们的尖叫"><a href="#我们的低语，我们的尖叫" class="headerlink" title="我们的低语，我们的尖叫"></a>我们的低语，我们的尖叫</h2><h2 id="我来自爱达荷州"><a href="#我来自爱达荷州" class="headerlink" title="我来自爱达荷州"></a>我来自爱达荷州</h2><h2 id="迷途的骑士"><a href="#迷途的骑士" class="headerlink" title="迷途的骑士"></a>迷途的骑士</h2><h2 id="硫黄的作用"><a href="#硫黄的作用" class="headerlink" title="硫黄的作用"></a>硫黄的作用</h2><h2 id="静候水流"><a href="#静候水流" class="headerlink" title="静候水流"></a>静候水流</h2><h2 id="假如我是女人"><a href="#假如我是女人" class="headerlink" title="假如我是女人"></a>假如我是女人</h2><h2 id="卖花女"><a href="#卖花女" class="headerlink" title="卖花女"></a>卖花女</h2><h2 id="毕业"><a href="#毕业" class="headerlink" title="毕业"></a>毕业</h2><h1 id="第三部分"><a href="#第三部分" class="headerlink" title="第三部分"></a>第三部分</h1><h2 id="全能上帝之手"><a href="#全能上帝之手" class="headerlink" title="全能上帝之手"></a>全能上帝之手</h2><h2 id="悲剧之后的闹剧"><a href="#悲剧之后的闹剧" class="headerlink" title="悲剧之后的闹剧"></a>悲剧之后的闹剧</h2><h2 id="大房子里吵架的女人"><a href="#大房子里吵架的女人" class="headerlink" title="大房子里吵架的女人"></a>大房子里吵架的女人</h2><h2 id="物理的巫术"><a href="#物理的巫术" class="headerlink" title="物理的巫术"></a>物理的巫术</h2><h2 id="事物的本质"><a href="#事物的本质" class="headerlink" title="事物的本质"></a>事物的本质</h2><h2 id="太阳以西"><a href="#太阳以西" class="headerlink" title="太阳以西"></a>太阳以西</h2><h2 id="两双挥舞的手臂"><a href="#两双挥舞的手臂" class="headerlink" title="两双挥舞的手臂"></a>两双挥舞的手臂</h2><h2 id="救赎之赌"><a href="#救赎之赌" class="headerlink" title="救赎之赌"></a>救赎之赌</h2><h2 id="家庭"><a href="#家庭" class="headerlink" title="家庭"></a>家庭</h2><h2 id="守望野牛"><a href="#守望野牛" class="headerlink" title="守望野牛"></a>守望野牛</h2><h2 id="教育-Educated"><a href="#教育-Educated" class="headerlink" title="教育 Educated"></a>教育 Educated</h2>]]></content>
    
    
    <categories>
      
      <category>Life</category>
      
      <category>阅读</category>
      
    </categories>
    
    
    <tags>
      
      <tag>阅读</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>密码学告别仪式</title>
    <link href="/post/f2e5126b.html"/>
    <url>/post/f2e5126b.html</url>
    
    <content type="html"><![CDATA[<h1 id="密码学告别仪式"><a href="#密码学告别仪式" class="headerlink" title="密码学告别仪式"></a>密码学告别仪式</h1><p>为期四个月的密码数学挑战赛终于结束了，</p><p>想想最开始偶然间在消息群发现的队友，单纯好奇 Keccak 算法这个新东西，想参加一下这个比赛。比赛过程没有想象中那么自在，周期长、题目新、难度大，想起来筛选文献后一次次尝试复现顶会的实验，自己对着满屏的二进制和十六进制中间结果发呆，南下旅行途中也不时“造访”星巴克，一坐就是一天，只为代数求解多几位的结果。所有过程的收获远大于比赛的最终结果，能够认识帮我一起推公式的队友，决赛还见到了很厉害的翎学姐还有兵哥哥队（解放军，永远的神！），没遗憾。最后还要感谢一下激发我对密码学兴趣的段老师，泪目（一人血书给计科专业恢复密码学及其应用选修课）。</p><p>最终答辩解放军兵哥哥队伍的恐怖成果，值得一个特等奖。我们这种无理论突破的，评委老师也能不嫌弃还给予指导，金主爸爸发 5k 奖金，值了值了。这一程算是告别密码学了吧，我会在系统领域延续这种热爱。</p><p>Talk is cheap, show me the code.<br>Code is small, show me the bits.</p><a id="more"></a>]]></content>
    
    
    <categories>
      
      <category>Life</category>
      
      <category>随笔</category>
      
    </categories>
    
    
    <tags>
      
      <tag>随笔</tag>
      
      <tag>密码学</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>读《The-Ph.D.-Grind》有感</title>
    <link href="/post/1d61dca5.html"/>
    <url>/post/1d61dca5.html</url>
    
    <content type="html"><![CDATA[<h1 id="读《The-PH-D-GRIND》有感"><a href="#读《The-PH-D-GRIND》有感" class="headerlink" title="读《The-PH.D.-GRIND》有感"></a>读《The-PH.D.-GRIND》有感</h1><p>上海交通大学 IPADS 实验室的刘年学长推荐。作为一个曾经想进入 IPADS 的学子，况且把这本书当作一个未曾相识的学长送的离别礼物吧。</p><p>回归书本，讲的是一个博士的心路历程，包括了对在读与可能未来进入博士生涯的建议，且读且珍惜。该书在 Format、Timeliness 和 Tone 三个部分与现有 PhD 相关书籍区分开。</p><ul><li><p>Format:</p><p>回忆录形式</p><ul><li>is a memoir for a general</li><li>can be concrete and detailed when telling my own story</li></ul></li><li><p>Timelines:</p><p>恰在博士毕业后完成回忆录，相较于在读生所写，更加全面的审视走过的整段路。</p></li><li><p>Tone</p></li></ul><h2 id="Prologue"><a href="#Prologue" class="headerlink" title="Prologue"></a>Prologue</h2><p>选择攻读博士学位，一来是父母潜意识的影响，二来是糟糕的工业界实习经历。</p><p>关于父母潜意识作用，作者母亲是大学教授，没有失业风险，也没有各种汇报，具备相对自由的工作方向与研究意愿；相反，父亲是一位高级工程师，就总在埋怨自己工作中的不如意。所以家庭中不同身份的家长，却给出了相同的期望。</p><p>由于相对充实的科研和实习经历，在踏入斯坦福校门前，作者认为他已经为读博做了充足的准备，全无意识到随后的博士一年级将会是他一生中最沮丧、最痛苦的时期。</p><a id="more"></a><h2 id="Year-One-Downfall"><a href="#Year-One-Downfall" class="headerlink" title="Year One: Downfall"></a>Year One: Downfall</h2><h2 id="Year-Two-Inception"><a href="#Year-Two-Inception" class="headerlink" title="Year Two: Inception"></a>Year Two: Inception</h2><h2 id="Year-Three-Rplapse"><a href="#Year-Three-Rplapse" class="headerlink" title="Year Three: Rplapse"></a>Year Three: Rplapse</h2><h2 id="Intermission"><a href="#Intermission" class="headerlink" title="Intermission"></a>Intermission</h2><h2 id="Year-Four-Reboot"><a href="#Year-Four-Reboot" class="headerlink" title="Year Four: Reboot"></a>Year Four: Reboot</h2><h2 id="Year-Five-Production"><a href="#Year-Five-Production" class="headerlink" title="Year Five: Production"></a>Year Five: Production</h2><h2 id="Year-Six-Endgame"><a href="#Year-Six-Endgame" class="headerlink" title="Year Six: Endgame"></a>Year Six: Endgame</h2><h2 id="Epilogue"><a href="#Epilogue" class="headerlink" title="Epilogue"></a>Epilogue</h2>]]></content>
    
    
    <categories>
      
      <category>Life</category>
      
      <category>阅读</category>
      
    </categories>
    
    
    <tags>
      
      <tag>阅读</tag>
      
      <tag>待补充</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>一路向楠——2020夏南行记第五站（重庆）</title>
    <link href="/post/7e1105c8.html"/>
    <url>/post/7e1105c8.html</url>
    
    <content type="html"><![CDATA[<h1 id="2020-夏南行记第五站（重庆）"><a href="#2020-夏南行记第五站（重庆）" class="headerlink" title="2020 夏南行记第五站（重庆）"></a>2020 夏南行记第五站（重庆）</h1><p>我们之所以被称之为人而非动物，语言的产生和发展起着关键作用。当不适应的外部环境到来时，只寻求肢体上本能的抗拒是孩童和动物的行为，我不喜欢。</p><a id="more"></a>]]></content>
    
    
    <categories>
      
      <category>Life</category>
      
      <category>旅行</category>
      
    </categories>
    
    
    <tags>
      
      <tag>旅行</tag>
      
      <tag>待补充</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>一路向楠——2020夏南行记第四站（广州、中山）</title>
    <link href="/post/69108b4d.html"/>
    <url>/post/69108b4d.html</url>
    
    <content type="html"><![CDATA[<h1 id="2020-夏南行记第四站（广州、中山）"><a href="#2020-夏南行记第四站（广州、中山）" class="headerlink" title="2020 夏南行记第四站（广州、中山）"></a>2020 夏南行记第四站（广州、中山）</h1><p>最初定下去中山，行一程，见一人，足矣。</p><p>从上海到中山并无直达铁路，貌似中山也没机场，所以就更无直抵中山的飞机了。来去都经广州转乘，好在去年夏天广-深-港一游以及 10 月再访广州（emm 那时候本想再访香港，局势紧张放弃了）对广州地铁十分熟悉，转乘期间也没有出什么奇怪的状况，可能唯一说得上的事情就是，在地铁上没有提前买好去中山的城际列车票，本憨憨只能站着，而且，由于个子太高还不能通过车窗观赏沿路的风景。</p><p>才下城际，海风裹着中山特有的小镇气息扑面而来，匆忙中举起手机，晚霞也落了大半。给小胡发了消息，看样子本来约好的晚饭局又要变成宵夜局了（长个记性，日后都自觉约 2 小时后的），拖着我的全部家当乘上了 005 号公交，中山的公交号码蛮有趣的，都要凑个三位数，以至于后面坐 007 号时颇有 James Bound 的感觉。</p><p>中山市</p><a id="more"></a>]]></content>
    
    
    <categories>
      
      <category>Computer Science</category>
      
      <category>旅行</category>
      
    </categories>
    
    
    <tags>
      
      <tag>旅行</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>一路向楠——2020夏南行记第三站（上海）</title>
    <link href="/post/61160b7b.html"/>
    <url>/post/61160b7b.html</url>
    
    <content type="html"><![CDATA[<a id="more"></a>]]></content>
    
    
    <categories>
      
      <category>Life</category>
      
      <category>旅行</category>
      
    </categories>
    
    
    <tags>
      
      <tag>旅行</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>一路向楠——2020夏南行记第二站（南昌）</title>
    <link href="/post/d5766eb.html"/>
    <url>/post/d5766eb.html</url>
    
    <content type="html"><![CDATA[<a id="more"></a>]]></content>
    
    
    <categories>
      
      <category>Life</category>
      
      <category>旅行</category>
      
    </categories>
    
    
    <tags>
      
      <tag>旅行</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>一路向楠——2020夏南行记第一站（合肥）</title>
    <link href="/post/c501e3de.html"/>
    <url>/post/c501e3de.html</url>
    
    <content type="html"><![CDATA[<a id="more"></a>]]></content>
    
    
    <categories>
      
      <category>Life</category>
      
      <category>旅行</category>
      
    </categories>
    
    
    <tags>
      
      <tag>旅行</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>形式化验证学习——形式化验证方法概述</title>
    <link href="/post/a0bc491d.html"/>
    <url>/post/a0bc491d.html</url>
    
    <content type="html"><![CDATA[<h1 id="形式化验证方法概述"><a href="#形式化验证方法概述" class="headerlink" title="形式化验证方法概述"></a>形式化验证方法概述</h1><blockquote><p>Formal verification: the only way to guarantee that a system is free of programming errors.</p></blockquote><p>按照陈海波老师 Lecture 中所讲，<strong>形式化验证是确保系统无编程错误的唯一方法</strong>。</p><p>形式化验证为构建正确、可靠的系统提供了系统化手段。基于这种方式构建起来的系统，具备高可信度，由于目前经验证的只是系统局部，由于环境因素必须无条件信任一些未经证明数学完备的构件，所以可以理解为，形式化验证可以达到 99%正确。</p><p>根据现在的发展，形式化验证方法主要分为三大类<sup id="fnref:1" class="footnote-ref"><a href="#fn:1" rel="footnote"><span class="hint--top hint--rounded" aria-label="SOSP 2019——SJTU-IPADS 的集体见闻（Day-2）">[1]</span></a></sup>：</p><ul><li>交互式证明（interactive verification）</li><li>半自动化证明（auto-active verification）</li><li>一键证明（push-button verification）</li></ul><h2 id="交互式证明"><a href="#交互式证明" class="headerlink" title="交互式证明"></a>交互式证明</h2><p>交互式证明（interactive verification），借助 Coq、Isabelle 等交互式证明工具，耗费相当多时间构建证明，一步一进。</p><h2 id="半自动化证明"><a href="#半自动化证明" class="headerlink" title="半自动化证明"></a>半自动化证明</h2><p>半自动化证明（auto-active verification），借助如 Dafny、Verifast 等半自动化证明器这样的工具。这需要开发人员提供证明注释，包括前置条件和后置条件、循环变量和框架注释来指导验证器。虽然与交互验证器相比，自动激活验证器可以减少证明负担，但它们仍然需要大量的工作<sup id="fnref:2" class="footnote-ref"><a href="#fn:2" rel="footnote"><span class="hint--top hint--rounded" aria-label="Helgi Sigurbjarnarson. Push-Button Verification of Systems Software. PhD thesis, University of Washington, Apr 2020.">[2]</span></a></sup>。</p><h2 id="一键证明"><a href="#一键证明" class="headerlink" title="一键证明"></a>一键证明</h2><p>基于 symbolic evaluation 等技术的一键验证，是 UNSAT 一系列工作的研究成果。文献<sup id="fnref:2" class="footnote-ref"><a href="#fn:2" rel="footnote"><span class="hint--top hint--rounded" aria-label="Helgi Sigurbjarnarson. Push-Button Verification of Systems Software. PhD thesis, University of Washington, Apr 2020.">[2]</span></a></sup>是该实验室 2020 年一篇硕士论文，总结了近几年的成果。简言之，<strong>最小化</strong>验证系统软件所需的手动证明负担。</p><p>思路构想，就验证的复杂性、技术或工具而言，并不是所有的系统设计都能平等地验证其正确性。与交互式或自动验证相比，按钮方法将手工校对和注释的负担转移到设计阶段，而设计阶段必须满足三个关键需求<sup id="fnref:2" class="footnote-ref"><a href="#fn:2" rel="footnote"><span class="hint--top hint--rounded" aria-label="Helgi Sigurbjarnarson. Push-Button Verification of Systems Software. PhD thesis, University of Washington, Apr 2020.">[2]</span></a></sup>。</p><p>下面两个核心要点保证了可用符号执行的方式自动化验证实现是否符合抽象规范。</p><ul><li>first-order logic</li><li>finite interface</li></ul><p>使用的核心工具 SMT Z3。</p><a id="more"></a><section class="footnotes"><div class="footnote-list"><ol><li><span id="fn:1" class="footnote-text"><span><a href="https://mp.weixin.qq.com/s/s_P2FZf3uhuPlxliuSTQ0w" target="_blank" rel="noopener">SOSP 2019——SJTU-IPADS 的集体见闻（Day-2）</a><a href="#fnref:1" rev="footnote" class="footnote-backref"> ↩</a></span></span></li><li><span id="fn:2" class="footnote-text"><span><a href="https://unsat.cs.washington.edu/papers/sigurbjarnarson-phd-thesis.pdf" target="_blank" rel="noopener">Helgi Sigurbjarnarson. Push-Button Verification of Systems Software. PhD thesis, University of Washington, Apr 2020.</a><a href="#fnref:2" rev="footnote" class="footnote-backref"> ↩</a></span></span></li></ol></div></section>]]></content>
    
    
    <categories>
      
      <category>Computer Science</category>
      
      <category>形式化验证</category>
      
    </categories>
    
    
    <tags>
      
      <tag>形式化验证</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>读《与学生合作开展研究的体会》感受</title>
    <link href="/post/3eb11354.html"/>
    <url>/post/3eb11354.html</url>
    
    <content type="html"><![CDATA[<h1 id="科学研究的分类"><a href="#科学研究的分类" class="headerlink" title="科学研究的分类"></a>科学研究的分类</h1><p>从陈海波老师的角度看，科学研究主要可分为：</p><ul><li>人类共性问题</li><li>面向国家重大需求</li><li>面向自由探索</li></ul><h1 id="导师——学生关系"><a href="#导师——学生关系" class="headerlink" title="导师——学生关系"></a>导师——学生关系</h1><ul><li><p><strong>合伙人</strong>：</p><blockquote><p>“导师-学生”可以一定程度上理解为初创公司中的合伙人关系，二者关系一旦确认，则不仅共享成果、同时也分担风险。这也在学术评价体系中有体现，例如在论文、项目等评审中按惯例导师与学生是终身规避的。</p></blockquote></li><li><p><strong>互相学习</strong>：</p><blockquote><p>两者也是互相学习的关系。刚开始学生由于专业背景知识不足，缺乏研究技能，需要导师的指导以进入一个专业领域研究的大门。然而，随着学生研究工作的深入，以及对研究方法技能的逐步掌握，由于其工作的专注性与所花时间通常远超过导师，在所涉及领域的技术细节等方面往往要比导师更加深入。而导师则由于其在博士学习期间对一个或几个专业领域的深入学习与研究，以及在担任教职后与不同的学生合作研究的过程中获取的较广泛的专业知识，在研究方法与经验、方向把握与领域的广度上，一般而言远胜学生。</p></blockquote><p>导师与学生间产生良性循环。</p><blockquote><p>学生通过更加专注的学习与探索获取专业领域内更加深入的知识与技能，通过与导师进行交流，以及导师进一步进行试验从而使导师可以获取该领域的第一手与最新的信息，然后导师根据其研究经验与方法对学生的进一步探索与研究提供相应的建议与意见。因此，在高校或科研院所担任科研导师的一个非常重要的好处是，通过与学生以及同事之间的合作，让自己经常保持对这个学科领域前沿的深刻理解与良好的创造力。</p></blockquote></li></ul><h1 id="科研选题"><a href="#科研选题" class="headerlink" title="科研选题"></a>科研选题</h1><p>简要调研、把手弄脏、选择合适</p><blockquote><p>选题通常有两种方式，一种是找学生能做的课题，另一种是找需要解决但挑战较大的问题[3]。根据学生基础、能力与兴趣不同，方式各有不同。我的方式是让学生首先对其感兴趣的领域进行比较简要的调研(mini-survey)，然后通过加入一个现有项目或者对于一些现有的系统进行开发与评测等，从而获取对于相关领域的第一手经验。相对于纯粹的文献阅读，这样做的好处是可以让学生不仅能快速理解一个小领域的技术背景、行业需求与前沿问题，并且还可以通过“让手弄脏”(get hands dirty)很快地让学生获得对该领域有一个直接的感受，从而在后续的过程中与学生一起对于领域内的问题可以大致估计哪些问题是学生能做的问题，是否有难度较低但也挺重要的问题(low-hanging fruit)，哪些是领域内较难但又很重要的问题。因为计算机系统的复杂性，获取第一手的开发经验可以对后续研究的难度进行相对较准确的估计，从而避免为学生设定一个难度过大的问题，学生在经历较长时间的探索后坚持不下去最终放弃。</p></blockquote><h2 id="如何选择一个合适的科研题目"><a href="#如何选择一个合适的科研题目" class="headerlink" title="如何选择一个合适的科研题目"></a>如何选择一个合适的科研题目</h2><blockquote><p>对计算机系统领域而言，通常需要对所处的技术领域产生的背景有较深入的理解。具体而言，包括计算机系统各个部件发展的速度、趋势与前景，这些信息可以通过参加学术界与工业界的学术或技术会议，有些可以通过各种相关的文献等获知。通过这些信息，也可以对现有领域内一些研究项目有一个全面深入的理解。比如，在 2014 年一期关于内存计算的学科前沿讲习班(CCF ADL)Panel 上，美国俄亥俄州立大学的张晓东教授在回答一个关于如何选题的提问时，通过对斯坦福大学 RAMCloud 项目进行案例分析[4]，指出 RAMCloud 项目的背景是内存容量的不断扩大、应用对于大量数据低延迟访问需求增大、网络带宽不断增大与延迟不断降低等趋势下对于计算机系统内存数据存放的一个重新思考与设计。这样的分析可以帮助我们更好地评估选题的前沿性、难度与技术挑战等。</p></blockquote><h2 id="选题的针对性"><a href="#选题的针对性" class="headerlink" title="选题的针对性"></a>选题的针对性</h2><blockquote><p>通常而言，会有不同阶段、不同特点的学生参与科研工作，包括本科生、研究生、博士生以及博士后 1。由于研究基础、科研能力与可用的研究期限不同，通常需要对不同的学生采用不同的选题。对于博士研究生而言，由于时间较为充裕，可以选定一个研究领域进行较长期的研究，以期望在一个技术领域内有较大突破。对于本科生参与科研活动而言，由于部分学生时间较短（毕业后出国、工作等），可以选择一些风险较低，定位较明确的课题。</p></blockquote><h1 id="参加学术会议"><a href="#参加学术会议" class="headerlink" title="参加学术会议"></a>参加学术会议</h1><p>提出问题，让对方知道我来了，搭建可以进一步沟通的平台。但前提，请<strong>事先准备充分</strong>。</p><blockquote><p>因此，参加学术会议的交流质量非常重要。但是大部分工科学生，包括我自己，不是很会社交甚至排斥社交。我在读书的时候或刚开始担任教师的时候去参加学术会议基本上都抢第一个提问的机会（当然要事先充分准备）。这样的一个好处是：让别人知道我来了，让想找我交流的人可以来找我。当然，事先要做好一个会议的名人录“who-is-who”，包括对可能会来参加会议的教师与学生，尤其是作者、程序委员会委员以及资深教授等。</p></blockquote><p>陈海波老师组内要求：</p><ul><li>每年至少出国参加一次顶级学术会议</li><li>每个参会学生必须至少提一个问题</li><li>与至少 10 位以上的学者进行交流</li><li>回国后在组会上做参会情况介绍与感想报告。</li></ul><h1 id="学术报告"><a href="#学术报告" class="headerlink" title="学术报告"></a>学术报告</h1><p>报告、排练、排练再排练。</p><p>需要考虑的方面：结构、风格到语法。</p><ul><li>一般由学生去作会议论文的学术报告</li><li>报告前要进行反复多次排练</li></ul><h1 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h1><p>博士退出机制不完善，导致“完全放养”（“扔到游泳池里学游泳”）的方式在国内不太可行。</p><blockquote><p>此外，由于我们博士退出机制的不完善，因此不适合完全采取“扔到游泳池里学游泳”的方式，而是需要更加细致的管理以保证大部分学生能以较为优秀的方式完成学业与研究工作，这也是“导师-学生”合作能够成功的关键。</p></blockquote><p>待补充剩余内容</p><a id="more"></a>]]></content>
    
    
    <categories>
      
      <category>Research</category>
      
      <category>方法</category>
      
    </categories>
    
    
    <tags>
      
      <tag>方法</tag>
      
      <tag>待补充</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>读《一名系统研究者的攀登之路》感受</title>
    <link href="/post/2da6da2d.html"/>
    <url>/post/2da6da2d.html</url>
    
    <content type="html"><![CDATA[<h1 id="系统研究者应当具备的素质"><a href="#系统研究者应当具备的素质" class="headerlink" title="系统研究者应当具备的素质"></a>系统研究者应当具备的素质</h1><p>这些内容是陈海波老师九年研究过程中的经验与教训，介绍在《一名系统研究者的攀登之路》的感触部分。</p><ol><li><p><strong>批判性思维</strong>：</p><p>想起之前读《有所不为的反叛者》所提到的历史学家的美德：</p><blockquote><p>历史学家有三大美德：批判、怀疑和想象力。</p></blockquote><p>批判是共性。</p><blockquote><p>系统研究中的自由性使系统研究很容易走向“重新发明轮子”或者“发明一个不相干的轮子”的误区。因此，系统研究尤其需要批判性的思维。在与弗兰斯一起工作中，弗兰斯就特意告诫我思考问题需要极度的批判性（super-critical）。</p></blockquote><p>海波老师讲 ISCA 2008 论文的情况，弗兰斯从开始论文的意义部分，就问了一连串的问题，希望海波老师能给出准确的解释，“为什么采取某一策略而非其他”，不对问题，更有可能是思维上的检验。</p><blockquote><p>他希望通过问答的方式看到我在这个过程中对涉及到的问题是否深入地、批评性地思考过了，而不是简单地接受其他人或论文上的观点。</p></blockquote></li><li><p><strong>扎实的基本功</strong>：</p><blockquote><p>计算机系统偏向于实践，强调的是解决问题的整体能力。因此，比较全面的知识面，扎实的系统编程能力与快速学习能力将对开展系统方向的研究至关重要。而这些能力往往需要较长时间的培养。</p></blockquote></li><li><p><strong>发散式思维</strong>：</p><blockquote><p>在研究过程中，如果问题 A 得到解决，那么是否可以解决问题 B？如果问题 A 通过方法 1 得到解决，是否还可能通过方法 2 进行解决呢？各种解决方法各有什么样的优缺点？在研究过程中就需要不断地进行这样发散式的思维。</p></blockquote></li><li><p><strong>开阔的视野与专注的研究</strong>：</p><p>表面看起来似乎是个“两难选择”问题，但实际上在不同阶段可以合适的选择开阔/专注策略，正如海波老师所说。</p><blockquote><p>这看起来更像是一个采用深度优先还是广度优先进行学习与研究的例子。看似一对矛盾体，因此需要去做动态平衡。我个人的体会是，对研究生而言，在一段特定的时间内需要有一个专注的研究点。在选择研究点的时候需要批判性的思考。这样的一个研究点是否值得去做？而一旦这个研究点确定下来了，就要持续深入地去研究一个相对较长的时间，直到可以很肯定地告诉自己这个研究点的问题已经全部解决了，否则就不轻易放弃。</p></blockquote></li><li><p><strong>认真、逻辑严密的写作</strong>：</p><p>寥寥草草写的博文称不上认真、逻辑严密的写作。目前自己的水平充其量是能写下来，而不是懒于写或者不想写。所以，想要达到系统领域学术文章的水平，还要努力、虚心接受相当大的指导与训练。</p><blockquote><p>系统领域对写作非常重视，因为大家普遍认为，严谨细致的写作是严谨细致思维的体现。</p></blockquote></li></ol><a id="more"></a>]]></content>
    
    
    <categories>
      
      <category>Research</category>
      
      <category>方法</category>
      
    </categories>
    
    
    <tags>
      
      <tag>方法</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>Coq学习——交互式定理证明工具Coq的产生与发展（转）</title>
    <link href="/post/5943431e.html"/>
    <url>/post/5943431e.html</url>
    
    <content type="html"><![CDATA[<h1 id="交互式定理证明工具-Coq-的产生与发展（转）"><a href="#交互式定理证明工具-Coq-的产生与发展（转）" class="headerlink" title="交互式定理证明工具 Coq 的产生与发展（转）"></a>交互式定理证明工具 Coq 的产生与发展（转）</h1><p>本文转载自<a href="http://blog.sciencenet.cn/blog-1225851-766624.html" target="_blank" rel="noopener">科学网——王小平的博客</a></p><a id="more"></a><p>Coq is a formal proof management system. It provides a formal language to write mathematical definitions, executable algorithms and theorems together with an environment for semi-interactive development of machine-checked proofs. Typical applications include the formalization of programming languages semantics (e.g. the CompCert compiler certification project or Java Card EAL7 certification in industrial context), the formalization of mathematics (e.g. the full formalization of the 4 color theorem or constructive mathematics at Nijmegen) and teaching.</p><p>1970 年代：Gérard Huet 开始在自动定理证明方面进行工作，使用 LISP 语言实现了带等式的一阶逻辑证明器 SAM。λ 演算成为研究证明论的主要工具。Jean-Yves Girard 证明了分析的一致性，他的证明使用了称为 System-F 的多态 λ 演算中证明的终止性。这一系统被推广到一个表示多态泛函的 Fω 系统，因而可为一类超出了传统序数层次的算法进行编码。John Reynolds 在推广 ML 语言的受限制的多态结构时，又重新实现了这一系统。</p><p>1980 年代：Knuth 和 Bendix 开展了奠基性研究工作。Jean-Marie Hullot 和 Gérard Huet 完成了一个 KB 软件，它以一种自然的方式实现代数结构的自动判定过程和半可判定过程。同时，归纳证明领域也取得了稳步的进展，最著名的工作是 Boyer 和 Moore 的 NQTHM/ACL 系统。同时，逻辑学家（Dana Scott ）和理论计算机科学家（Gordon Plotkin 、Gilles Kahn、Gérard Berry ）正在研究可计算函数的一种逻辑理论（可计算论域），以及有效可用公理化（可计算归纳），目的是为了定义程序语言的语义。Gérard Huet 联合巴黎高等师范学院的 Guy Cousineau 和 Pierre-Louis Curien 在 INRIA Rocquencourt 实验室启动了 Formel 项目。他们准备把 ML 语言不仅用于定义 tactics，同时用于实现整个系统。这一项在函数式方面的研究和开发工作在几年后产生了 CAML 语言族，最终导致了今天的 Objective Caml 语言，它就是现在的 Coq 证明器的实现语言。1984 年，Gilles Kahn 在 Sophia Antipolis 组织了一个类型理论的国际会议，在会上，Thierry Coquand 和 Gérard Huet 展示了一个把依赖类型和多态类型综合在一起的系统，它把 MartinL.f 的构造性理论融入了 Automath 系统的一个扩展，该系统命名为构造演算（Calculus of Constructions）。1989 年，Coq 4.1 版本发布，该版首次加入了由 Benjamin Werner 所设计的从证明中抽取函数式程序（Caml 语法）的机制。</p><p>1990 年代：推出的 Coq 5.6 版提供了进行数学描述的统一语言（Gallina“vernacular”），原始归纳类型，从证明中抽取程序的机制，和一个图形化用户界面。1996 年 11 月发布的 Coq 6.1 版引入了所有上述理论成就，也包括了几项对提高效率有关键作用的技术，特别是 Bruno Barras 的规约机制，</p><p>2000 年以后：Coq 系统经历了完全的重新设计，版本 7 拥有一个函数式核心，主要架构师是 Jean-Christophe Filli.tre，Hugo Herbelin 和 Bruno Barras 。一个用于 tactics 设计的新语言由 David Delahaye 开发出来，此后人们可以用高级语言为复杂的证明策略编程。为了对数值软件进行正确性验证，Micaela Mayero 研究了实数的公理化问题。同时，Yves Bertot 重新利用 CtCoq 的思想，用 Java 语言开发了一个复杂的图形界面 PCoq 。2002 年 Jacek Chr.aszcz 采用了类似 Caml 的方法把模块和函子系统整合在一起。2003 年底，在经过对主要的输入语言进行重新设计之后发布了 8.0 版本（目前版本 8.4）。目前在应用方面，Coq 已经足够强壮，并可用作实现特定证明工具的低层语言</p><p>Coq 迄今最为成功的应用在软件形式化验证方面。Trusted Logic 利用 Coq 成功地完成 JavaCard 语言的整个执行环境的形式化验证。这项安全方面的工作获得 EAL7 证书奖（公共标准下最高级别的奖励）。开发使用了 121000 行 Coq 代码，总共 278 个模块。2013 年 Coq 获得 ACM SIGPLAN 编程语言软件奖。此外，Coq 在数学定理辅助证明方面也有不少斩获，如“四色定理”证明（这样是否意味了数学和计算机变成真正的一家亲，天才的数学家们是否担心害怕自己的饭碗问题呢？随着计算机能力的快速增长， 再过二三十年， 大多数研究都将可以由计算机来做。 它们不仅能证明数学定理， 甚至可以发现数学定理，但就目前两个学科的发展现状而言，计算机至多只能起辅助作用，还不能代替人创造性的思考）。</p><p>值得关注的是，另一种基于高阶逻辑的定理辅助证明系统 Isabelle 也在研究和发展中，它进行函数式程序建模，多数证明只要两步完成：对所选变量进行归纳以及使用自动策略，能够处理集合、函数、关系以及实现递归定义集合，利用了嵌套递归和交叉递归等技术、大量可供选择使用的低级证明策略。</p><p>参考文献：</p><p><a href="http://coq.inria.fr/" target="_blank" rel="noopener">Coq 官方网址</a></p><p><a href="http://zh.wikipedia.org/wiki/Coq" target="_blank" rel="noopener">Coq 维基百科</a></p><p>(德)Yves Bertot Pierre Casteran 著，顾明 译。交互式定理证明与程序开发—Coq 归纳构造演算的艺术。清华大学出版社，2010 年</p>]]></content>
    
    
    <categories>
      
      <category>Computer Science</category>
      
      <category>形式化验证</category>
      
    </categories>
    
    
    <tags>
      
      <tag>形式化验证</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>操作系统学习——文件系统崩溃一致性</title>
    <link href="/post/f1b4a79d.html"/>
    <url>/post/f1b4a79d.html</url>
    
    <content type="html"><![CDATA[<h1 id="文件系统的崩溃一致性"><a href="#文件系统的崩溃一致性" class="headerlink" title="文件系统的崩溃一致性"></a>文件系统的崩溃一致性</h1><p>待读文章：<a href="https://www.usenix.org/system/files/conference/osdi14/osdi14-paper-pillai.pdf" target="_blank" rel="noopener">All File Systems Are Not Created Equal</a></p><p>基于先代文件系统之上的应用程序级崩溃一致性协议（crash-consistency protocol）。</p><p>状态更新来持久化状态，依赖底层文件系统。</p><p>主要贡献：</p><ul><li>BOB 工具</li><li>ALICE 工具</li></ul><h2 id="BOB-工具"><a href="#BOB-工具" class="headerlink" title="BOB 工具"></a>BOB 工具</h2><p>BOB 工具，用来测试这种一致性的满足情况（不同应用文件系统的），测试方法解释，转自<a href="https://www.jianshu.com/p/4bd91c097c35" target="_blank" rel="noopener">文件系统天生就是不平等的-实现崩溃一致性应用的复杂性 | 简书</a>，整体看还是一种 testing 的方法（自底向上抓取）。</p><blockquote><p>BOB 主要是为了测试文件系统的 Persistence Properties。对于一个给定的文件系统，当在发生崩溃之后，有哪些可能的状态，这个就是用 Persistence Properties 来确定的。</p><p>那这个 BOB 是怎么做的呢？首先 BOB 会一个简单的场景去压力测试 Persistence Properties（譬如，一批特定 size 的持续写入来验证 overwrite 的原子性）。BOB 会收集这个场景产生的 block I/O，然后重新排序这些收集的 blocks，选择性的将一些写入到磁盘去产生一个合法的磁盘 state。用这种方式，BOB 能产生一批在崩溃之后，多个对应不同 disk states 的唯一的磁盘 images 。然后 BOB 会在各自的 image 上面执行文件系统的 recovery ，并检查 Persistence Properites 是否继续满足（譬如 Write 是原子的）。</p></blockquote><p>抽取 I/O 操作，重新排列，构建磁盘映像（disk image）。这些磁盘映像是磁盘的物理状态，应对应 crash state 抽象模型的部分状态。然后在各个磁盘映像中执行恢复过程，如果操作是原子的？crash-consistency 的，则应该恢复成功。</p><a id="more"></a><h2 id="ALICE-工具"><a href="#ALICE-工具" class="headerlink" title="ALICE 工具"></a>ALICE 工具</h2><p>ALICE 的原理其实比较简单，就是通过 trace 应用程序的 system call 来直接构建文件的 state。</p><h1 id="主流-Linux-Unix-文件系统架构简介"><a href="#主流-Linux-Unix-文件系统架构简介" class="headerlink" title="主流 Linux/Unix 文件系统架构简介"></a>主流 Linux/Unix 文件系统架构简介</h1><p>原文地址：<a href="http://blog.chinaunix.net/uid-28989651-id-3833383.html" target="_blank" rel="noopener">主流 Linux/Unix 文件系统架构简介</a></p><p>(1) FFS-style 文件系统：代表文件系统有最初的 BerkeleyFFS 和 Ext2，具有的优点是简单、高性能、易于修复和恢复数据，但是每次系统崩溃需要全盘 fsck，无数据一致性保障，无正规的防御磁盘崩溃的措施。</p><p>(2) 日志(Journaling)文件系统：最为流行的现代文件系统架构，典型代表文件系统有 Ext3、Reiserfs 以及其他多种文件系统。日志文件系统加入对近期提交到文件系统的事务的 log，log 顺序地写到磁盘上的一个保留的位置。文件系统的主体不会更改，直到事务完整地写到 log 中为止。日志使得文件系统可以快速从崩溃状态恢复，因为可以“回放”log，完成任意未半完成状态（文件系统的更改信息已经写到了 log 中，但是还没有写到文件系统中）的操作。日志文件系统存在的问题包括两次写问题（每个操作必须写磁盘两次，一次是写到 log 中，另一次是写到文件系统中最终的位置）以及受限的日志空间带来的多种性能问题。此外，日志文件系统也没有改善磁盘崩溃的情况。</p><p>(3) 日志结构（Log-structured）文件系统：典型代表文件系统 LFS。Log-structured 文件系统在文件系统研究社区反响强烈，但是从未用于主流商业产品用途。Log-structured 的主要设计思想是：首先，以 log 的方式将更新写出，这将一组随机写 IO 转换成一个大的连续的写入流，写操作更为高效；其次，整个文件就是一个巨大的连续事务 log，对文件的更新直接追加到 log 中（解决了 Journaling 文件系统的两次写问题），数据的更新不会在本地覆盖写——从这个意义上看 log-structured 文件系统也是一种 Copy-on-write(COW)文件系统。Log-structured 文件系统的主要问题是系统需要大的空闲的 segments 磁盘空间，这些空闲的 segments 由“cleaner”线程创建。非完全空闲的 segments 中的已分配的 blocks 必须移出到其他的 segments 中。尽管对 cleaner 的优化进行了多年的研究，cleaner 线程的开销仍然非常高。此外，计算空闲空间的总数也很困难，因为 COW 文件系统直到数据块的新的拷贝写入成功的时候才会释放该数据块的旧的拷贝块，而一次操作需要完成的数据块拷贝的数量是不可预测的。最后，强制重分配数据块需要在每次写操作的时候做一个“good”的分配决策，而本地更新文件系统仅需要做一次的“good”分配决策。</p><p>(4) 软更新（Soft updates）文件系统：Soft updates 是对 Berkeley FFS 的优化，在文件系统崩溃的时候，保留磁盘上的文件系统格式数据（也就是元数据），使得无需执行 fsck 程序就可挂载文件系统。Soft updates 仔细调整对文件系统的更新顺序，因而任意时刻文件系统发生崩溃，除去部分“leaked”（标记为已分配，实际上是空闲的）的 inodes 和 blocks 外，文件系统数据是一致的。后台 fsck 程序运行在文件系统的快照上，找出这些未引用的 blocks 并将其再次标记为空闲。Soft update 是的负面影响主要是极度复杂，难于理解和实现，并且每个文件系统操作需要其自己独特设计的 update 代码。当前已知的仅有一个实现的 soft updates 实例。</p><p>(5) 写时拷贝（copy-on-write(COW)）文件系统：最新趋势的文件系统架构。COW 文件系统的典型代表是 WAFL (Write Anywhere File Layout, Network Appliance 的内部文件系统)、ZFS 以及 Btrfs。这些文件系统以树的方式组织文件 blocks。当一个 block 更新的时候，就分配一个新的 block，链接 block 的指针指向更新后的 block——当然也会引起这些指针所在的 block 的更新产生。当一组一致的更新写到磁盘之后，root block 自动更新为指向新的 blocks 树，该新的 blocks 树包含最新的分配信息。这种结构方式极其易于实现文件系统快照技术，而且集中了文件系统一致性代码。COW 文件系统的不足之处与 Log-structured 文件系统相似——每次写操作要强制重分配，同时不确定完成一次更新需要多少的磁盘空间。同时，好的同步性能需要加入某种 journal，使得 COW 文件系统的实现更复杂。</p>]]></content>
    
    
    <categories>
      
      <category>Computer Science</category>
      
      <category>操作系统</category>
      
    </categories>
    
    
    <tags>
      
      <tag>操作系统</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>分布式系统学习——NVM717会议记录</title>
    <link href="/post/9b82f934.html"/>
    <url>/post/9b82f934.html</url>
    
    <content type="html"><![CDATA[<h1 id="Kyle-Zhang-汇总"><a href="#Kyle-Zhang-汇总" class="headerlink" title="Kyle Zhang 汇总"></a>Kyle Zhang 汇总</h1><p>四个线程同步向一个文件系统做 IOAT，不同 Socket PM 差异较大。</p><p>进行多 Channel 多线程，多 NUMA 测试。</p><p>（思考一下，NUMA 是什么）</p><p>李：测试一下 PM 应用的最大潜力。ext4-DAX 模式。</p><p>0 上面是 2GB 左右</p><p>1 上面是 3-4GB 左右</p><p>2、3 上面还是 2GB 左右</p><h1 id="关于-level-hash-的测试"><a href="#关于-level-hash-的测试" class="headerlink" title="关于 level-hash 的测试"></a>关于 level-hash 的测试</h1><p>level-hash 到 clevel-hash</p><p>如果这个数据结构可以做 MVCC、OCC 的后端更好一些。（hash table 不太够，最好能再和上层应用结合——&gt; 做一个文件系统？）</p><p>有没有可能在 level-hash 上做一个 OCC（level-hash 上做元数据管理）。</p><p>把 blabla 实现在 level-hash 上？建立 OCC/MVCC？</p><p><a href="https://www.zhihu.com/question/60278698" target="_blank" rel="noopener">OCC 和 MVCC 的区别是什么</a></p><a id="more"></a>]]></content>
    
    
    <categories>
      
      <category>Computer Science</category>
      
      <category>分布式系统</category>
      
    </categories>
    
    
    <tags>
      
      <tag>分布式系统</tag>
      
      <tag>NVM</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>分布式系统学习——NVM-Level-Hash实验</title>
    <link href="/post/16075fb7.html"/>
    <url>/post/16075fb7.html</url>
    
    <content type="html"><![CDATA[<h1 id="Level-Hash-编译遇到问题"><a href="#Level-Hash-编译遇到问题" class="headerlink" title="Level-Hash 编译遇到问题"></a>Level-Hash 编译遇到问题</h1><pre><code class="hljs Bash">[edwardzcn@h1 10:18:28 persistent_level_hashing]<span class="hljs-variable">$make</span>gcc -c test.cIn file included from level_hashing.h:10:0,                 from test.c:1:log.h:9:73: fatal error: .../quartz/src/lib/pmalloc.h: No such file or directory <span class="hljs-comment">#include ".../quartz/src/lib/pmalloc.h"   // path to pmalloc.h in Quartz</span>                                                                         ^compilation terminated.make: *** [test.o] Error 1</code></pre><p>需要修改原有基于 Quartz 的模拟操作，</p><a id="more"></a>]]></content>
    
    
    <categories>
      
      <category>Computer Science</category>
      
      <category>分布式系统</category>
      
    </categories>
    
    
    <tags>
      
      <tag>分布式系统</tag>
      
      <tag>NVM</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>《我执》读书笔记</title>
    <link href="/post/41412e7c.html"/>
    <url>/post/41412e7c.html</url>
    
    <content type="html"><![CDATA[<h1 id="我执"><a href="#我执" class="headerlink" title="我执"></a>我执</h1><blockquote><p>P006 “《我执》写的，正是一种极度强烈的‘有我’的文学；《我执》记录的，正是唯有透过这种‘有我之境’才会出现的奇异景致。”</p><p>P014 “《我执》有浓厚的忏悔录风格，哪里来自奥古斯丁哪些来自卢梭，无法一一细表。”</p></blockquote><p>八月一日 题解</p><blockquote><p>P003 “我知道了；这一切谎言与妄想，卑鄙与怯懦。它们就像颜料和素材，正好可以涂抹出一整座城市，以及其中无数的场景和遭遇。你所见到的，只不过是种偶然。握的越紧越是徒然。此之谓我执。”</p></blockquote><p>八月三日 不可分类者</p><p>归类，你又属于哪一类呢？</p><blockquote><p>P038 “所谓归类，其实就是我们常常会被问到的：‘你喜欢哪一类型的人？’似乎在我们爱一个人以前，首先爱的是一个类型，一种体相，一种性格和特质。这样的类型也许像柏拉图的‘理型’，不存在于此世，只能再脑海之中飘浮。”</p><p>“理想的类型。顾名思义，在理想的世界里面”。</p><p>“可是或许有那么一刻，我们会发现一个不能归类的人，甚至与理想的类型完全沾不上。”</p></blockquote><p>八月四日 禁欲</p><blockquote><p>P40 “对于知识与智能，吾人也不应滥情，随意张口就说：‘我爱智慧’；反该默默地谦卑地爱他，自己构想那最终地完美结局。”</p></blockquote><p>八月五日 真理</p><blockquote><p>P41 “当恋人在对方的身上看到了纯真，他就会以为自己得到真理，他以为自己看到了别人看不见的真实，拥有了一座他人既没发现更不理解的隐秘花园。”</p><p>P42 “在真实与虚伪之间往复，在信与不信之间来回，这是恋人和信徒共有的特征。上一刻仍沉浸在出魂的狂喜之中，下一刻瞬即被冷漠刺醒。”</p></blockquote><p>八月六日 树犹如此</p><blockquote><p>P44 “一棵树的长成，是多么不容易呀。释迦牟尼总爱以树取喻，从其种子的抽芽开始说起，再看根部的延展深入，再到枝干的茁长，树叶的繁茂，花开花落，结实果熟，恰好是生命的循环，更是无数因缘（如阳光，雨水和空气）凑合的成就。”</p></blockquote><p>八月七日 解谜</p><p>爱与被爱着的关系——主奴辩证法。</p><blockquote><p>P45 “你控制了我的身心，不过我看穿了你的真实。”</p></blockquote><p>八月九日 真名</p><p>请呼唤，我的真名。</p><blockquote><p>P51 “奇幻小说的忠实读者，想必都知道‘真名’是怎么回事。传说世界万物俱有真名，一种呈现其真实本质的名字，与一般表面的名字不同，由于它掌握了事物最核心的秘密，所以必须密藏起来，隐而补彰。只有别具慧心天赋异禀的人和经过修炼的魔法师才能找到这个名字，并且呼召它，从而操控事物运行的轨道。”</p><p>“这就是为什么法师可以呼风唤雨了，因为我们凡人只知风叫做‘风’雨叫做‘雨’，但法师知道风和雨真正的名字，他知道它们的本质是什么。”</p><p>P52 “其实这不是小说家们凭空捏造的幻想，而是一种源远流长的信念变形……”</p><p>“恋人也相信真名的魔力，他们总不满足于对方表面的名字，那些人尽皆知、身份证上工整打印的通名；他们喜欢别造昵称，觉得这才是对方的核心。”</p></blockquote><a id="more"></a><p>八月十日 情人之名</p><blockquote><p>P54 “然后，这个名字又将引领恋人走向另一条不归之路：他开始相信遥感甚至神通。他以为一遍遍地呼叫，远方的情人会有所感触，甚至响应。就像你去了异国的城市，在旅馆单人床上哭泣，却想象泪痕将于翌日在情人的枕头上显现一样。这当然是不可能的。这时你会明白，真名的法力已遗你而去。”</p></blockquote><p>八月十六日 不如我们从头来过</p><p>“不如我们从头来过”，一句出口即成空的话。</p><blockquote><p>P66 “若要真的从头再来，方法只有一种，那就是把自己彻底编程另一个人。不是变化你的生活习惯，比如说戒烟或者戒酒；也不是改变容貌声线；而是将你曾经交给对方的那一部分，把你曾经送到对方手中的那一半生命割除。这样子，你就残缺不全了。日后会不会痊愈长肉？不知道。将来是否反而更加完整健康？或许会。但至少你成了新人。”</p><p>“只是如此一来，你们的关系也就不再一样了，变得像是两个陌生人的全新遭遇。所以‘我们从头来过’是可能的，只要这里的‘我们’已经不是‘我们’”。</p></blockquote><p>八月十七日 新我</p><p>变“我们”为陌生的“他们”，又何来的从头呢？既然已变，则再无“从头”可言。</p><blockquote><p>P67 “也就是说‘让我们从头来过’这句话取消了自己的前提。一、不可能再有已成过去的‘我们’；二、也因此不可能再有重来的需要。所以这是一句刚刚出口就立刻成空的话。”</p><p>P68 “所以不管还要不要从头再来，你也只能消灭旧我，创造新我。‘要永远地创造自我’，福柯如是说。”</p></blockquote><p>八月十八日 水底之城</p><blockquote><p>P70 “水不一定能够洗去所有的创伤记忆，但是水一定可以将它们封存，使它们随着时间的流逝腐朽流逝粉碎。”</p><p>“当你想和一个人从头来过，想要创造新的自我，却又不可能割断那不忍让它保存的记忆，就把它沉入水中吧……若无任寻它，那要等上几百年、几千年，海枯石烂，重见天日之际已是无解的谜语。”</p></blockquote><p>八月十九日 同一条河</p><blockquote><p>P72 “至于将要结束的关系，就更不用说了。我们都盼望眼前的河流就是忘川，它永远都不会是同一条河；而踏进去的人在出来的那刻，也就不再是同一个人了。”</p></blockquote><p>八月二十二日 不可能的宽恕</p><p>宽恕，有条件的、相对的宽恕，无条件的、绝对的宽恕。绝对宽恕或许只有圣人才可以做到吧，就像耶稣垂死之际所说。</p><blockquote><p>P77 “父啊！原谅他们吧，他们不知道自己在做什么。”</p></blockquote><p>八月二十三日 无名之伤</p><blockquote><p>P79 “所谓‘受伤’，我们总是听到‘我很受伤’，‘我的心很痛’这类自述，指的当然不是肉身的伤痛。那么‘受伤’到底是什么意思呢？假若不是身体的伤痛，我们可能为这些自述所指涉的伤分类吗？可以判别其分布、症状与程度吗？又如何来命名这些边际模糊的伤口呢？”</p><p>P80 “在这一小段抽离出来的绝对空白里面，你什么都不想，它也没有任何依意蕴。”</p><p>“就像现象学所说的‘意识之悬搁’，人生在世的一切正常活动、正常思维、正常感知，在这一刻全都被悬搁起来了，所以没有时间也没有空间，你坠入了一个不知名的向度之中，不知方位不知长短。”</p><p>P81 “但是我们所说的这种空白不只没有名字，也不发出任何声音，它是沉默的伤口。”</p></blockquote><p>八月二十四日 可怖之美</p><p>回忆起高中的时候，张大师第一次给我们讲何为“壮美”。</p><blockquote><p>P84 “可怖的美，可能就像康德所说的‘崇高’（‘壮美’），人创造不来，也难以承受。因为它发生在人的感知能力的极限，差一点就不属于这个世界，也差一点就要进入这个世界。”</p><p>P85 “极端的美是摧毁性的，人工不可制作，也不能负担。万一它在某一刻偶尔出现在人的身上，那是不详的。”</p></blockquote><p>八月二十六日 瓶中信</p><blockquote><p>P90 “掷瓶入海，而终于被人打开阅读，这根本不是奇迹，而是意外。写瓶中信的人不是敢于下注的赌徒，而是认命的作者，最纯粹的作者。”</p></blockquote><p>抛下瓶中信的那一刻，但凡作者保有一丝丝被开启的希望，瓶中信就丧失了瓶中信本来该有的意义（这是我自己的想法）。根本不曾寄望瓶子有被开启的一天，那是一段不想被人接受的信息。</p><p>八月二十九日 重逢</p><blockquote><p>P95 “虽然明知不该后悔，但他还是后悔自己的鲁莽。他想：‘我再也见不到那个人了。’”</p></blockquote><p>八月三十日 黑暗之心</p><blockquote><p>P97 “要完全认识一个人，一定要认识他的恐惧。”</p><p>P98 “海员绝不爱上大海，相反，海是他最大的梦魇。康拉德几乎没怎么认真写过爱情，那或许是因为没有一个陆地上的人会真正了解水手的恐惧。”</p></blockquote><p>九月九日 没有心的男人</p><blockquote><p>P115 “想象一个男人生来就少了一颗心，他善良，正直，彬彬有礼，但就是没有那颗心。”——芬妮摩尔（Constance Fenimore Woolson）</p></blockquote><p>九月十七日 有钱人的笑话</p><blockquote><p>P138 “财富、美貌，甚至才华，都不是外在的关系，而是<strong>一个人身上无奈的限制与枷锁</strong>。你不能说一个有钱人除了财富之外还有一个完全与此无关的内在，也不能说一个美丽的女子除了美貌之外还有一个不受外在影响的本质，不，<strong>因为这些所谓外在的条件不只深刻地改变了穿戴它们地人</strong>，<strong>甚至还扭曲了他们的人格</strong>。就像一个面具戴的太久的人，他早就失去了原来的面孔。”</p><p>“你很难爱上这样的人，不是因为财富、美貌与才华会使得他们骄纵任性，而是这些外壳如此瞩目，即便是拥有它们得人也不能不自觉。一旦自觉，他就疏离，甚至戒惧。他会变得小心翼翼，仔细审视每个接近自己的人，<strong>然后把自己放上判官得位置</strong>，<strong>以为有能力去判别人心得真伪</strong>。所以他们不能带给任何人亲近的安全感，也不能让任何人亲近。他连自己都和自己不亲近，他总是在过滤他自己。”</p><p>“娱乐杂志有很多这样的笑话，我喜欢这种娱乐。”</p></blockquote><p>九月二十三日 逃逸</p><blockquote><p>P150 “这就是他（指父亲）为我准备的第一个家，百年的记忆与创痛，我用十年就体会完整。然后我用接下来的二十多年逃逸，以为可以建起一个幻想的世界，还有自己。”</p><p>P151 “这个世界没有外面。”</p></blockquote><p>九月二十四日 真空</p><blockquote><p>P154 “人是一间屋一座建筑的伤口，只有去掉了最后一人，建筑物才是完美的。就像画册上看到的那些伟大作品，总是没有人住的时候才最漂亮。”</p></blockquote><p>九月二十六日 生日</p><blockquote><p>P160 “我不知道他的生日是怎么过的，不过我知道很多他不认识的人都在两个星期前开始祝福他，甚至送礼物给他，仿佛国庆。从前我不注重任何纪念日，连家庭成员的生日也都记不住；可是后来才明白一句‘生日快乐’实在别有深意，因为就像弗洛伊德所说，人总是向死而生，生日又怎能不快乐？”</p><p>“‘生日快乐’，是人类‘死亡驱动’（death drive）由衷的呼声。”</p></blockquote><p>九月二十七日 帝国</p><blockquote><p>P161 “大抵所有的卜卦皆如是，既不隐藏也不明言，有的只是一个记号。而记号，皆有待诠释。”</p></blockquote><p>九月二十八日 放逐</p><p>自我放逐</p><blockquote><p>P166 “话说来客拜访他的书房，震慑于藏书之壮丽。主人不在，管家代他回答：‘这里只是主人放书的地方，平常他在花园或者野地上看书。’”</p></blockquote><p>你没有帝国，只能放逐自己。</p><p>九月二十九日 书房</p><blockquote><p>P171 “就像一个人的记忆还在，但却没有秩序与结构去引导他定位提取。我什么都记得，只是失去了辨认的能力与拆墙的决心。”</p></blockquote><p>九月三十日 残缺</p><blockquote><p>P175 “我怀疑自己的习惯其实反映了自己的遗憾，但我的拯救行动钟是徒然。到了最后，我和我的书都将化成灰烬。”</p></blockquote><p>十月三日 寻常</p><p>年少喜读纳兰性德，却难以深刻体会词中透露出来的人生变故的感悟。</p><blockquote><p>P184 “‘当时只道是寻常’这句话本身就把平常变成了异常，所有我们以为会成习惯的平凡人事皆是无常偶然的诡局。只有事后追忆，才明白那寻常是何等的殊异可贵。赐给我们寻常体验的人，是不可恨的。”</p></blockquote>]]></content>
    
    
    <categories>
      
      <category>Life</category>
      
      <category>阅读</category>
      
    </categories>
    
    
    <tags>
      
      <tag>阅读</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>操作系统学习——知识点复习整理提纲</title>
    <link href="/post/c2ed6fef.html"/>
    <url>/post/c2ed6fef.html</url>
    
    <content type="html"><![CDATA[<h1 id="计算机系统概述"><a href="#计算机系统概述" class="headerlink" title="计算机系统概述"></a>计算机系统概述</h1><h2 id="操作系统地体系结构"><a href="#操作系统地体系结构" class="headerlink" title="操作系统地体系结构"></a>操作系统地体系结构</h2><h3 id="大内核和微内核"><a href="#大内核和微内核" class="headerlink" title="大内核和微内核"></a>大内核和微内核</h3><p>操作系统体系结构，关于操作系统在核心态应该提供什么服务、怎样提供服务？有关这一问题的回答形成了两种主要的体系结构：<strong>大内核</strong>（单一内核）和<strong>微内核</strong>。</p><p>大内核系统将操作系统的主要功能模块都作为<strong>一个紧密联系的整体</strong>运行在核心态，从而为应用提供高性能的系统服务。因为各管理模块之间共享信息，能有效利用相互之间的有效特性，所以具有无可比拟的性能优势。</p><p>但随着体系结构应用需求的发展，操作系统的设计规模增长，内核功能如进程管理、虚存、I/O 与设备管理、IPC、文件系统等几个层次，层次间接口定义越发复杂，层次间界限也逐渐模糊。</p><p>为解决操作系统内核代码难以维护的问题，提出了微内核的体系结构。它将内核中最基本的功能（如进程管理等）保留在内核，而将那些不需要在核心态执行的功能移到用户态（？存疑。不应该是逐层陷入内核么）执行，从而降低了内核的设计复杂性。那些移出内核的操作系统代码根据分层的原则被划分成若干服务程序，它们的执行相互独立，交互则都借助于微内核进行通信。</p><p><strong>需要证明的是</strong>，微内核在系统效率上并没有论证由于大内核（陷入过程/通信机制影响了系统的效率）。</p><h2 id="疑难区分点"><a href="#疑难区分点" class="headerlink" title="疑难区分点"></a>疑难区分点</h2><ol><li><p>并行性与并发性的区别和联系</p><p>并行性（parallel）和并发性（concurrency）是既相似又有区别的两个概念，并行性是指两个或多个事件再同一时刻发生，并发性是指两个或多个事件再同一时间间隔内发生。</p><p>在多道程序环境下，并发程序是指在一段时间内，宏观上有多个程序同时运行，但在单处理器系统中每个时刻却仅能有一道程序执行，故微观上这些程序只能分时地交替执行。若在计算机系统中有多个处理器，则这些可以并发执行地程序便被分配到多个处理器上，实现并行执行，即利用每个处理器来处理一个可并发执行地程序。</p></li><li><p>特权指令与非特权指令</p><p>特权指令，是指有特殊权限地指令，由于这类指令地权限最大，使用不当将导致整个系统崩溃，如清内存、置时钟、分配系统资源、修改虚存地段表或页表、修改用户地访问权限等。为保证系统安全，这类指令只能用于<strong>操作系统</strong>或<strong>其他系统软件</strong>，不直接提供给用户使用。</p><p>特权指令必须在核心态执行，用户态下只能使用非特权指令，核心态下可以使用全部指令。在用户态下使用特权指令时，将<strong>产生中断以阻止用户使用特权指令</strong>。用户态转换为核心态地唯一途径是<strong>中断或者异常</strong>？</p></li></ol><p>进程管理<br>进程与线程<br>进程的概念和特征<br>设计概念（数学不严谨的 Specification）：在多道程序环境下，允许多个程序并发执行，此时它们将失去封闭性，并具有间歇性不可再现性的特征（单道的确定性被破坏？）。为此引入了进程（Process）的概念，以便更好描述和控制程序的并发执行，实现操作系统的并发性和共享性（最基本的两个特征），进程曾是分时系统的基本运作单位（面向进程设计的系统），现代系统中多作为线程的容器（面向线程设计的系统）。</p><p>具体实现（实体描述 Implementation）：为了使参与并发执行的程序（含数据）能独立地运行，必须为之配置一个专门的数据结构，称为进程控制块（Process Control Block，PCB）。系统利用 PCB 来描述进程的基本情况和运行状态，进而控制和管理进程。相应地，由程序段、相关数据段和 PCB 三部分构成了进程映像（进程实体）。</p><p>注意：PCB 是进程存在的唯一标识！</p><p>引入进程实体概念后，我们可以把进程定义为：“进程是进程实体的运行过程（抽象实现），是系统进行资源分配和调度的一个独立单位。”</p><p>进程的特征<br>进程的性质描述。</p><p>动态性：进程是程序的一次执行，有执行状态和生命周期。<br>并发性：多个进程实体同时存在内存中，能够在一段时间内同时执行（联系并发 concurrency 的概念）。并发是进程的重要特征。<br>独立性：<br>异步性：<br>结构性：<br>进程的阻塞和唤醒<br>这里描述的进程阻塞过程和唤醒过程实际上就对应了后面一小节，其他调度参见调度的短期调度</p><p>正在执行的进程，由于期待的某些事件未发生，由系统自动执行阻塞原语 Block，使自己由运行态变为阻塞态。可见，进程的阻塞时进程自身的一种主动行为（或者理解为内核行为），也因此只有处于运行态的进程（获得 CPU），才可能将其转换为阻塞态。操作：找 PCB、改未阻塞态、插入等待队列。</p><p>当阻塞进程所期待的事件出现时，如它所启动的 I/O 操作已完成或其所期待的数据已到达，由有关进程（如提供数据的进程）调用唤醒原语 Wakeup，将等待该事件的进程唤醒。操作：找 PCB、从等待队列中移出、置就绪态、插入就绪队列等待调度器调度。</p><p>上下文<br>Switch（切换）负担的主要来源。在计算机科学中，任务（task）的上下文（英语：context）是一个任务所必不可少的一组数据（该任务可以是进程、线程）。这些数据允许任务中断，在这之后仍可在同一个地方继续执行（现场情况）。上下文的这一概念在中断的任务的场景下具有重大意义，其中，任务在被中断之后，处理器保存上下文并提供中断处理（interrupt service routine）。因此，上下文越小，延迟越小。</p><p>上下文的数据可能存放于处理器寄存器、任务所利用的内存、某些操作系统管理的任务所使用的控制寄存器（control registers）。</p><p>（笔者自己的调查）针对放置在寄存器（Register）还是内存（Memory）中我个人看法如下：</p><p>寄存器：最小执行单位（进程/线程）处就绪态时，CPU 利用寄存器内容做计算，此时上下文数据通过 Load/Store（假定 ARM 指令集）将上下文相关数据从内存传送至寄存器<br>任务所用内存：最小执行单位（进程/线程）处于阻塞态时，不利用 CPU 时间，此时上下文数据应在内存中保存。<br>中期调度——挂起的时候应该会把上下文也储存在磁盘上？</p><p>进程切换<br>对于通常的进程而言，其创建、撤销及要求由系统设备完成的 I/O 操作，都是利用系统调用而进入内核，再由内核中的相应处理程序予以完成的。进程切换同样是在内核的支持下实现的，因此可以说，任何进程都是在操作系统内核的支持下运行的，是与内核紧密相关的。</p><p>进程切换是指处理机从一个进程的运行转到另一个进程上运行，在这个过程中，进程的运行环境产生实质性变化。进程切换的过程如下:</p><p>保存处理机的上下文，包括程序计数器和其他寄存器。<br>更新 PCB 信息。<br>把进程的 PCB 移入相应的队列，如就绪、在某事件的阻塞等队列。<br>选择另一个进程执行，并更新其 PCB。<br>更新内存管理的数据结构。<br>恢复处理机上下文（所选择的另一个进程）<br>疑难区分点</p><a id="more"></a><h1 id="进程管理"><a href="#进程管理" class="headerlink" title="进程管理"></a>进程管理</h1><h2 id="进程与线程"><a href="#进程与线程" class="headerlink" title="进程与线程"></a>进程与线程</h2><h3 id="进程的概念和特征"><a href="#进程的概念和特征" class="headerlink" title="进程的概念和特征"></a>进程的概念和特征</h3><p>设计概念（数学不严谨的 Specification）：在多道程序环境下，允许多个程序并发执行，此时它们将失去封闭性，并具有间歇性不可再现性的特征（单道的确定性被破坏？）。为此引入了进程（Process）的概念，以便更好描述和控制程序的并发执行，实现操作系统的并发性和共享性（最基本的两个特征），进程曾是分时系统的基本运作单位（面向进程设计的系统），现代系统中多作为线程的容器（面向线程设计的系统）。</p><p>具体实现（实体描述 Implementation）：为了使参与并发执行的程序（含数据）能独立地运行，必须为之配置一个专门的数据结构，称为<strong>进程控制块</strong>（Process Control Block，PCB）。系统利用 PCB 来描述进程的基本情况和运行状态，进而控制和管理进程。相应地，由<strong>程序段</strong>、<strong>相关数据段</strong>和<strong>PCB</strong>三部分构成了进程映像（进程实体）。</p><p>注意：PCB 是进程存在的<strong>唯一标识</strong>！</p><p>引入进程实体概念后，我们可以把进程定义为：“进程是进程实体的运行过程（抽象实现），是系统进行资源分配和调度的一个独立单位。”</p><h3 id="进程的特征"><a href="#进程的特征" class="headerlink" title="进程的特征"></a>进程的特征</h3><p>进程的性质描述。</p><ul><li><strong>动态性</strong>：进程是程序的一次执行，有执行状态和生命周期。</li><li><strong>并发性</strong>：多个进程实体同时存在内存中，能够在一段时间内同时执行（联系并发 concurrency 的概念）。并发是进程的重要特征。</li><li><strong>独立性</strong>：</li><li><strong>异步性</strong>：</li><li><strong>结构性</strong>：</li></ul><h3 id="进程的阻塞和唤醒"><a href="#进程的阻塞和唤醒" class="headerlink" title="进程的阻塞和唤醒"></a>进程的阻塞和唤醒</h3><p>这里描述的进程阻塞过程和唤醒过程实际上就对应了后面一小节，其他<a href="https://www.edwardzcn98yx.com/post/c2ed6fef.html">调度</a>参见调度的短期调度</p><p>正在执行的进程，由于期待的某些事件未发生，由系统自动执行阻塞原语<code>Block</code>，使自己由运行态变为阻塞态。可见，进程的阻塞时进程自身的一种主动行为（或者理解为内核行为），也因此只有处于运行态的进程（获得 CPU），才可能将其转换为阻塞态。操作：找 PCB、改未阻塞态、插入等待队列。</p><p>当阻塞进程所期待的事件出现时，如它所启动的 I/O 操作已完成或其所期待的数据已到达，由有关进程（如提供数据的进程）调用唤醒原语<code>Wakeup</code>，将等待该事件的进程唤醒。操作：找 PCB、从等待队列中移出、置就绪态、插入就绪队列等待调度器调度。</p><h3 id="上下文"><a href="#上下文" class="headerlink" title="上下文"></a>上下文</h3><p>Switch（切换）负担的主要来源。在计算机科学中，任务（task）的上下文（英语：context）是一个任务所必不可少的一组数据（该任务可以是进程、线程）。这些数据允许任务中断，在这之后仍可在同一个地方继续执行（现场情况）。上下文的这一概念在中断的任务的场景下具有重大意义，其中，任务在被中断之后，处理器保存上下文并提供中断处理（interrupt service routine）。因此，上下文越小，延迟越小。</p><p>上下文的数据可能存放于处理器寄存器、任务所利用的内存、某些操作系统管理的任务所使用的控制寄存器（control registers）。</p><p>（笔者自己的调查）针对放置在寄存器（Register）还是内存（Memory）中我个人看法如下：</p><ul><li>寄存器：最小执行单位（进程/线程）处就绪态时，CPU 利用寄存器内容做计算，此时上下文数据通过 Load/Store（假定 ARM 指令集）将上下文相关数据从内存传送至寄存器</li><li>任务所用内存：最小执行单位（进程/线程）处于阻塞态时，不利用 CPU 时间，此时上下文数据应在内存中保存。</li></ul><p>中期调度——挂起的时候应该会把上下文也储存在磁盘上？</p><h3 id="进程切换"><a href="#进程切换" class="headerlink" title="进程切换"></a>进程切换</h3><p>对于通常的进程而言，其创建、撤销及要求由系统设备完成的 I/O 操作，都是利用系统调用而进入内核，再由内核中的相应处理程序予以完成的。进程切换同样是在内核的支持下实现的，因此可以说，任何进程都是在操作系统内核的支持下运行的，是与内核紧密相关的。</p><p>进程切换是指处理机从一个进程的运行转到另一个进程上运行，在这个过程中，进程的运行环境产生实质性变化。进程切换的过程如下:</p><ol><li>保存处理机的上下文，包括程序计数器和其他寄存器。</li><li>更新 PCB 信息。</li><li>把进程的 PCB 移入相应的队列，如就绪、在某事件的阻塞等队列。</li><li>选择另一个进程执行，并更新其 PCB。</li><li>更新内存管理的数据结构。</li><li>恢复处理机上下文（所选择的另一个进程）</li></ol>]]></content>
    
    
    <categories>
      
      <category>Computer Science</category>
      
      <category>操作系统</category>
      
    </categories>
    
    
    <tags>
      
      <tag>操作系统</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>Coq学习——FRAP阅读笔记Chap12</title>
    <link href="/post/a06ab0a.html"/>
    <url>/post/a06ab0a.html</url>
    
    <content type="html"><![CDATA[<h1 id="CHAPTER-12-Hoare-Logic-Verifying-Imperative-Programs"><a href="#CHAPTER-12-Hoare-Logic-Verifying-Imperative-Programs" class="headerlink" title="CHAPTER 12 Hoare Logic: Verifying Imperative Programs"></a>CHAPTER 12 Hoare Logic: Verifying Imperative Programs</h1><p>从上一章节两个维度前进一步。</p><ul><li>从函数式转为命令式语言</li><li>回到对深度一致性（deep correctness）性质的证明，而非缺乏类型相关的崩溃</li></ul><p>尽管如此，基本的证明结构最终还是一样的，因为我们再一次证明了转移系统的不变量（invariants of transition systems）（跳跃读，需要补 Chap4 5）。</p><a id="more"></a><h2 id="An-Imperative-Language-with-Memory"><a href="#An-Imperative-Language-with-Memory" class="headerlink" title="An Imperative Language with Memory"></a>An Imperative Language with Memory</h2><p>从定义具有无限可变堆（infinite mutable heap）的命令行语言开始。出于一些原因，mix 了语法和语义。在程序的特定部分，我们包含了表达程序状态（program state）的断言（assertion），用 heap $h$ 和 variable valuation $v$ 表示。</p><script type="math/tex; mode=display">\begin{aligned}    \mathbf{Numbers} \quad & n \in \mathbb{N} \\    \mathbf{Variables}  \quad & x  \in \mathbf{Strings} \\    \mathbf{Expressions} \quad & e ::= n|x|e+e|e-e|e \times e | *[e] \\    \mathbf{Boolean} \quad \mathbf{expressions} \quad & b ::= e=e | e < e \\    \mathbf{Commands} \quad  & c ::= \mathbf{skip} | x \leftarrow e |*[e] \leftarrow e | c;c  \\    & \qquad   | \ \mathbf{if}  \ b \ \mathbf{then} \ c \ \mathbf{else} \ c \\    & \qquad | \ \{ a \}  \ \mathbf{while} \ b \ \mathbf{do} \ c  \ | \ \mathbf{assert}(a)\end{aligned}</script><p>循环在其语法中产生了一个额外的断言，实际上我们将在语言语义中忽略它，但它将成为我们将要学习的证明技术的重要部分，特别是在自动化它的过程中。表达式具有标准的递归语义，这里应该说的是$\{ a  \} \ \mathbf{while} \ b  \ \mathbf{do} \ c \ | \ \mathbf{assert}(a)$这部分。</p><p>语义部分描述：（待添加公式）</p><p>通过增加线程堆复杂性，完成了大步骤的语义（big——step semantics）。</p><p>先尝试 Pass 这一部分。直接推理操作语义可能会很乏味，所以开发一些自动证明程序正确性的机制。</p><h2 id="Hoare-Triples"><a href="#Hoare-Triples" class="headerlink" title="Hoare Triples"></a>Hoare Triples</h2><p>如同其他系统一样（有待研究前面的内容？），定义一个语法谓词（syntactic predicate）并一劳永逸地证明它。谓词被写成$\{P\}c\{Q\}$地的形式，该形式被称为<code>Hoare triple</code>，按这种谓词的实现称为<code>Hoare logic</code>。</p><ul><li>$c$，形式化的命令 command</li><li>$P$，前状态 precondition（执行$c$之前计算机的状态）。</li><li>$Q$，后状态 postcondition （执行之后的状态）。</li></ul><h3 id="规则解释"><a href="#规则解释" class="headerlink" title="规则解释"></a>规则解释</h3><ul><li>skip rule. 跳过规则</li><li>assignment rule. 赋值规则<ul><li>前状态：$\{P\}$</li><li>过程为：$x \leftarrow e$</li><li>后状态（这个不大能理解）： $\{ \lambda(h,v). \ \exists v’. P(h,v’) \land v = v’[x \mapsto [e] (h.v’) ]\}$</li></ul></li><li>memory-write rule. 内存写规则</li><li><p>model sequence rule. 顺序执行规则（这个用来表示非常的方便）</p><script type="math/tex; mode=display">\dfrac{\{P\}c_1\{Q\} \quad \{Q\}c_2\{R\}}{ \{P\}c_1;c_2\{R\} }</script></li><li><p>condition rule. 排序规则</p><p>从基本的 sequence 方法开始，变动两个地方。其一是由于子命令再测试表达式不同结果后运行，要扩展 precondition。另一方面，由于可能执行任一段子代码，我们不考虑他们的后置条件（看代码稍微能理解些了）。</p></li><li><p>循环规则</p></li><li>command——specific 规则</li><li>One more essential rule 跟前后条件强弱相关。</li></ul><p>上述这些规则（个人理解，这些就是 Axiom 公理）结合在一起是完整的（完备的？complete），任何关于 pre-post 条件对的 command 都是可证的（这里又回到了命令表示？）。完整证明是通过 Coq 完成的。</p><p>（机翻）自动证明过程基本思路：首先尝试应用丁聪语法树构造函数（比如 assignment 或 loop rule）。如果规则和目标一致，则递归下去。否则，应用后果规则将后置条件替换为匹配规则中的后置条件； 请注意，所有规则都接受任意形状的前提条件，因此我们实际上不需要做任何工作来按摩前提条件。经过这样的步骤之后，可以确保现在适用“基本”规则。</p><p>介绍 Hoare logic 的结尾部分，思考<strong>how it brings to bear some more of the general principles that we have met before.</strong></p><h2 id="Small-Step-Semantics"><a href="#Small-Step-Semantics" class="headerlink" title="Small-Step Semantics"></a>Small-Step Semantics</h2><h2 id="Transition-System-Invariants-from-Hoare-Triples"><a href="#Transition-System-Invariants-from-Hoare-Triples" class="headerlink" title="Transition-System Invariants from Hoare Triples"></a>Transition-System Invariants from Hoare Triples</h2>]]></content>
    
    
    <categories>
      
      <category>Computer Science</category>
      
      <category>形式化验证</category>
      
    </categories>
    
    
    <tags>
      
      <tag>形式化验证</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>Coq学习——FRAP阅读笔记Chap4</title>
    <link href="/post/7905a915.html"/>
    <url>/post/7905a915.html</url>
    
    <content type="html"><![CDATA[<h1 id="CHAPTER-4"><a href="#CHAPTER-4" class="headerlink" title="CHAPTER 4"></a>CHAPTER 4</h1><h2 id="Semantics-for-Arithmetic-Expressions-via-Finite-Maps"><a href="#Semantics-for-Arithmetic-Expressions-via-Finite-Maps" class="headerlink" title="Semantics for Arithmetic Expressions via Finite Maps"></a>Semantics for Arithmetic Expressions via Finite Maps</h2><p>为了解释章节 2 中数学表达式的含义。我们需要一个表示每个变量值的方法。使用<code>finite maps</code>（有限映射），顾名思义，有限域，可通过$m[k \mapsto v]$进行拓展，注意得到还是一个 map。符合下面的基本公理</p><script type="math/tex; mode=display">\dfrac{}{m[k \mapsto v](k) = v} \quad \dfrac{k_1 \ne k_2}{m[ k_1 \mapsto v](k_2) = m(k_2)}</script><p>有了上述工具在手，我们就可以写出算术表达式的语义了。</p><p>递归函数描述<code>maps variable valuations to numbers</code>。</p><script type="math/tex; mode=display">\begin{aligned}    [n] v  & = n \\    [x] v & = v(x) \\    [e_1 + e_2] v & = [e_1] v + [e_2] v \\    [e_1] \times [e_2] v & = [e_1] v \times [e_2] v \\\end{aligned}</script><p>！！注意理解，括号内的 operation 是语法上的！括号外才是数学上的含义。</p><p>为了测试语义的正确性，定义一个 variable sustitution function 替换函数。</p><a id="more"></a>]]></content>
    
    
    <categories>
      
      <category>Computer Science</category>
      
      <category>形式化验证</category>
      
    </categories>
    
    
    <tags>
      
      <tag>形式化验证</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>Coq学习——FRAP阅读笔记Chap3</title>
    <link href="/post/e7613cb6.html"/>
    <url>/post/e7613cb6.html</url>
    
    <content type="html"><![CDATA[<h1 id="CHAPTER-3-Data-Abstraction"><a href="#CHAPTER-3-Data-Abstraction" class="headerlink" title="CHAPTER 3 Data Abstraction"></a>CHAPTER 3 Data Abstraction</h1><h2 id="Algebraic-Interfaces-for-Abstract-Data-Types"><a href="#Algebraic-Interfaces-for-Abstract-Data-Types" class="headerlink" title="Algebraic Interfaces for Abstract Data Types"></a>Algebraic Interfaces for Abstract Data Types</h2><p>举队列为例，在一般编程中，我们构造出数据结构就 ok 了。但是如果我们要遵照形式化正确证明，我们还要补充一个<strong>规则集合</strong>，并用 data type 的操作量化。还是讲队列，需要满足两条：</p><script type="math/tex; mode=display">dequeue(empty) = \cdot</script><script type="math/tex; mode=display">\forall q.dequeue(q) = \cdot \Rightarrow q = empty</script><p>给出两个比较明显的实现：</p><ul><li>enqueue to list fronts and dequeue from listbacks</li><li>enqueue to list backs and dequeuefrom list fronts</li></ul><p>上述两个实现不够效率，这里有一个著名的，更聪明的实现，它实现了平摊常数时间(线性时间覆盖整个操作序列)，但是我们需要扩展我们的代数风格来适应它。</p><a id="more"></a><h2 id="Algebraic-Interfaces-with-Custom-Equivalence-Relations"><a href="#Algebraic-Interfaces-with-Custom-Equivalence-Relations" class="headerlink" title="Algebraic Interfaces with Custom Equivalence Relations"></a>Algebraic Interfaces with Custom Equivalence Relations</h2><p>我们发现用一个新的数学操作来扩展队列的基本接口是很有用的。</p><p>引入等价关系（自反，对称，传递）</p><p>Here is its implementation, relying on list-reversal function <code>rev</code>？？</p><p>双 list 实现队列，不够时反转添加至弹出 stack，形式化等价的证明。</p><script type="math/tex; mode=display">rep((l_1,l_2)) = l_1 \bowtie rev(l_2)</script><script type="math/tex; mode=display">q_1 \approx q_1 = rep(q_1) = rep(q_2)</script><p>为什么我们需要经历引入自定义等价语句的麻烦呢？思考后面的等价问题。一个为$([],[2])$一个为$([2],[])$。这个数据结构是不规范的，因为相同的逻辑值可能有多个物理表示。等价关系让我们指出哪些物理表示是等价的。</p><h2 id="Representation-Functions"><a href="#Representation-Functions" class="headerlink" title="Representation Functions"></a>Representation Functions</h2><p>基于<code>representation functions</code>风格的表示方法。我们可以强制。只要存在任何兼容的函数就足以显示队列实现的正确性，而且这种方法基本上可以将所有其他数据结构转换为抽象数据类型。</p><p>感觉就是把具备的性质用<code>rep()</code>表示出来。</p><p>修正队列的类型定义</p><p>修正的 Axiom（公理）</p><h2 id="Fixing-Parameter-Types-for-Abstract-Data-Types"><a href="#Fixing-Parameter-Types-for-Abstract-Data-Types" class="headerlink" title="Fixing Parameter Types for Abstract Data Types"></a>Fixing Parameter Types for Abstract Data Types</h2><p>这是另一种经典的抽象数据类型：<strong>有限集</strong>（finite sets），我们在这里写<strong>布尔集合</strong>。</p><script type="math/tex; mode=display">\begin{aligned}    t(a) & \quad : \quad  Set \\    empty & \quad : \quad  t(a) \\    add & \quad : \quad  t(a) \times a \rightarrow t(a) \\    member & \quad : \quad t(a) \times a \rightarrow \mathbb{B}\end{aligned}</script><p>一种简单的实现方法是使用 data type unsorted lists。</p><p>我们可以为特定的元素类型和使用模式构建专门的有限集。对于仅构建连续数字集的工作负载，此实现可能比基于泛型列表的实现快得多，它将次方转换为线性时间复杂度。！！给了一个 Range。</p>]]></content>
    
    
    <categories>
      
      <category>Computer Science</category>
      
      <category>形式化验证</category>
      
    </categories>
    
    
    <tags>
      
      <tag>形式化验证</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>Coq学习——FRAP阅读笔记Chap2</title>
    <link href="/post/90660c20.html"/>
    <url>/post/90660c20.html</url>
    
    <content type="html"><![CDATA[<h1 id="CHAPTER-2-Formalizing-Program-Syntax"><a href="#CHAPTER-2-Formalizing-Program-Syntax" class="headerlink" title="CHAPTER 2 Formalizing Program Syntax"></a>CHAPTER 2 Formalizing Program Syntax</h1><h2 id="Concrete-Syntax"><a href="#Concrete-Syntax" class="headerlink" title="Concrete Syntax"></a>Concrete Syntax</h2><p>程序定义来自程序语言，程序语言定义来自它的语法。语法描述了哪些短语是结构正确的。语义（semantics）表达了程序的意义（mean）。从<code>concrete syntax</code>，规定了哪些字符序列是可接受的。</p><p>举例算术运算，我们使用文法（grammar）来表述，给出 BNF，这部分理解，略过。</p><p>我们用得到的最重要的工具将会是<code>inductive definitions</code>，用来解释如何从小集合构造大集合。更一般的表示法，是一组 <code>inference rules</code>来定义一个集合。被定义的集合一般习惯为<strong>符合所有规则的最小集</strong>。举例，给出与上面算术运算 BNF 等价的<code>inference rules</code>定义。$Exp$表示所求集。水平线表示推理，之上为真，则之下为真。</p><a id="more"></a><h2 id="Abstract-Syntax"><a href="#Abstract-Syntax" class="headerlink" title="Abstract Syntax"></a>Abstract Syntax</h2><p>讲了 Concrete Syntax 后，放下它，本书剩余部分关注的是 <code>abstract syntax</code>，它是语言定义的真正核心。现在语言是 <code>abstract syntax trees</code> 抽象语法树，对应 Coq 中的 inductive type 定义或者 Haskell 中的 algebraic datatype 定义。这样的类型可通过用类型枚举它们的 constructor functions（构造函数）。</p><p>对应的构造函数，这些构造函数定义了$Exp$。</p><p><strong>诀窍</strong>：将具体语法（方便写出）表示法在头脑中分解为抽象语法（方便理解）</p><p>注意，将 inductive type 每个构造函数对应一个子句？否则构造函数将不完整。同时注意终止条件（Coq 称为 <code>primitive recursion</code> 原初/初始递归）。</p><h2 id="Structural-Induction-Principles"><a href="#Structural-Induction-Principles" class="headerlink" title="Structural Induction Principles"></a>Structural Induction Principles</h2><p>在本书中，我们不会过多地讨论自然数的证明，而是基于将<strong>自然数</strong>视为一个简单的归纳定义集，基于<strong>结构化归纳</strong>提出一个更一般，更强大的概念，这种归纳在形式上包含数学归纳（包含数学归纳！？）。</p><p>通过对集合的归纳定义，我们得到了一个证明集合中所有元素的某些谓词的归纳原理（归纳定义和归纳原理的相关性）。需要一种 proof obligation per rule。其实还是比较了解的，就是使用谓词的形式来表示定义。</p><ul><li>结论用谓词表示</li><li>前提用谓词表示，并假定前提的 True，即 inductive hypothesis（归纳前提）。</li></ul><p>理论，$\forall e ∈ Exp, ⌈e⌉ ≤ |e|$，用机器去证明。</p><p>这种极小化证明的确如作者所说吓到我了，作者认为定理的验证检查是一种适合机器而不是人的活动，省略一些血腥的细节，这些细节将在伴随的 Coqcode 中找到。</p><h2 id="Decidable-Theories"><a href="#Decidable-Theories" class="headerlink" title="Decidable Theories"></a>Decidable Theories</h2><p>这个还蛮重要的，可判定理论。</p><p>（这个不太明白。。）</p><p>徐老师的解答</p><blockquote><p>这段文字很简练，没有前因后果，所以费解，实际上，简单说，它的意思是：对于问题 f，如果存在一个程序（=机器），对于输入 f，这个程序是会运行停止的。那么，这个 f 就是可判定的，T 的意思是可判定问题的集合。所以，写成 f 属于 T</p></blockquote><p>一些情况下，我们需要填充完整的证明细节，最常见的情况是证明目标符合 <code>decidable theory</code>。根据可计算理论，我们思考某种选择问题，在<strong>限制条件</strong>下能推断出什么。</p><p>Theories 的 Decidablity 判定非常简单（handy，张手就来）。只要我们的目标属于可判定理论的集合，我们就可以通过使判定程序</p><p>（机翻）注意半环理论的适用性与线性算术理论的适用性是不可比拟的。也就是说，有些目标是可以证明的，有些只能通过半环理论证明，有些只能通过林耳算法证明。</p><blockquote><p>归纳到可判定问题，交给计算机</p></blockquote><h2 id="Simplification-and-Rewriting"><a href="#Simplification-and-Rewriting" class="headerlink" title="Simplification and Rewriting"></a>Simplification and Rewriting</h2><ul><li><p><code>Simplification</code>：“代入”已有的 theorem 来简化或者得到中间性质。</p></li><li><p><code>Rewriting</code>：“重写”成不同的表现形式（同样是利用已有的理论），来达到目标的样子（接近证明或者是想要得到其他形式的性质）。</p></li></ul>]]></content>
    
    
    <categories>
      
      <category>Computer Science</category>
      
      <category>形式化验证</category>
      
    </categories>
    
    
    <tags>
      
      <tag>形式化验证</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>Coq学习——FRAP阅读笔记Chap1</title>
    <link href="/post/96f5d9a.html"/>
    <url>/post/96f5d9a.html</url>
    
    <content type="html"><![CDATA[<h1 id="CHAPTER-1-Why-Prove-the-Correctness-of-Program"><a href="#CHAPTER-1-Why-Prove-the-Correctness-of-Program" class="headerlink" title="CHAPTER 1 Why Prove the Correctness of Program"></a>CHAPTER 1 Why Prove the Correctness of Program</h1><p>传统工程学有<strong>标准</strong>的数学工具来设计工业产品。能保证产出的安全性和适用性。这些标准或多或少，在工程师设计阶段会被考虑到。由于标准从更高角度严格制定，所以根据标准进行的设计安全性是有保证的。</p><p>那<strong>为什么软件工程没有对应的公认标准</strong>，以使程序员们可以确信自己的系统是安全、可靠、正确的呢？答案是：这些概念和工具可能还没有 ready for 广泛采纳，但已经经过了数十年的开发了。本书介绍一种特定的工具以及将其应用在完成不同程序验证任务的想法。</p><p>由于该文件处于非常早期的草稿阶段，没什么可多说的，所以会直接跳跃至技术材料部分。最终书本此处会添加一些历史的概述和学者引用。目前你可以相信作者，我们正在研究一种很有前途的方法！</p><a id="more"></a><p>学习该书的 common foundation：</p><ul><li>使用 Coq proof assistant</li><li>理论方法，证明新 property 时，考虑任何技术中会出现的 four broad elements<ul><li>Encoding：每种编程语言都有语法（syntax）和语义（semantic），前者定义程序的样子，后者定义程序运行时的方式（含义对应的行为）。即使直觉上这些元素看起来很明显，我们经常发现，在定义语法和语义的最高级严密性时，还需要做出令人惊讶的微妙选择。看似微不足道的决定可能会对我们的推证过程产生重大影响。</li><li>Invariants： 有关程序的每个定理都是由转换系统（transition system）来陈述的，具备一组状态和状态之间的转换关系。关于程序的证明都已通过寻找转换系统的一个不变式（invariants）来进行。不变式概念的地位很接近于数学中的数学归纳法，广为人知且深受喜爱。</li><li>Abstraction： 一般来说，直接分析转换系统（transition system）太过复杂。我们使用抽象的方式简化成更易理解的 transition system，需证明新的系统保留了原始系统所有的相关属性。</li><li>Modularity： 还是，针对转换系统的复杂性，我们将其拆成系列模块，再用 well-behaved composition operations 将他们重新组合。抽象和模块化通常时同时进行的。</li></ul></li></ul><p>证明在本书后续章节将很少出现，因为作者认为纸质证明太过时了。对应的，每一章包含一个 Coq 源文件，请在这里面阅读、执行、理解。</p>]]></content>
    
    
    <categories>
      
      <category>Computer Science</category>
      
      <category>形式化验证</category>
      
    </categories>
    
    
    <tags>
      
      <tag>形式化验证</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>《孤独六讲》读书笔记</title>
    <link href="/post/d49bb55.html"/>
    <url>/post/d49bb55.html</url>
    
    <content type="html"><![CDATA[<h1 id="两版序言"><a href="#两版序言" class="headerlink" title="两版序言"></a>两版序言</h1><p>早期哲学思想上的不同造成了如今“孤独”在中西方文化中含义的不同。</p><blockquote><p>“西方从‘太阳’、‘唯一’发展出‘孤独’这个词，产生类似庄子哲学‘独与天地精神往来’的自负的孤独感”</p><p>“汉语从儒家人际伦理的缺失发展出‘孤独’二字，总使人哀婉悲悯。”</p><p>“两个不同的文化，从语文开始，赋予了‘孤独’不同的生命意涵。”</p></blockquote><p>序言谈柏拉图的《飨宴篇》，现今的人类都是不完整的，在神的惩罚下，每个人都被劈成了两半，终其一生去寻找本该完整一体。按照作者的理解，《飨宴篇》核心主题在探讨“Eros”——纯粹的肉身之爱，在爱欲渴望中孤独摸索的真情实感。有孤独，但是最物质的“孤独”，当然也最易缺失，最重要。所以作者将相关的内容放置在开头部分《情欲孤独》。不过，作者想谈的“孤独”不仅于此，孤独不一定是某种缺失，或是寻找，也是对自己的尊重。“明白你是谁，成为你自己”，正如新版序言最后所写到。</p><blockquote><p>“你要足够完整，才能健康地去爱其他的人，去照顾和负担其他的人。”</p><p>“孤独的核心价值是——跟自己在一起。”</p></blockquote><p>旧版自序是蒋勋于二〇〇七年所写，比新版序言内容略少，看起来更像是杂糅了不同“孤独”的含义。</p><blockquote><p>“美学的本质或许就是孤独。”</p></blockquote><p>语言联通生活，却沟通浮于表面，语言是孤独的。</p><p>革命颠覆社会，却最终在废墟上流泪，革命也是孤独的。</p><blockquote><p>“我的对话只是自己的独白。”</p></blockquote><a id="more"></a><h1 id="情欲孤独"><a href="#情欲孤独" class="headerlink" title="情欲孤独"></a>情欲孤独</h1><blockquote><p>“孤独没有什么不好，使孤独变得不好，是因为你害怕孤独。”</p></blockquote><h2 id="愈来愈孤独的社会"><a href="#愈来愈孤独的社会" class="headerlink" title="愈来愈孤独的社会"></a>愈来愈孤独的社会</h2><blockquote><p>P24 “感觉到社会的孤独感约莫是在这几年。不论是打开电视或收听广播，到处都是 call in 节目。那个沉默的年代已不存在，每个人都在表达意见，但在一片 call in 声中，我却感觉到现代人加倍的孤独感。尤其在 call in 的过程中，因为时间限制，往往只有几十秒钟，话没说完就被打断了。”</p><p>“每个人都急着讲话，每个人都没把话讲完。”</p><p>“快速而进步的通讯科技，仍然无法照顾到我们内心里那个巨大而荒凉的孤独感。”</p></blockquote><h2 id="害怕孤独"><a href="#害怕孤独" class="headerlink" title="害怕孤独"></a>害怕孤独</h2><p>孤独没什么不好，而且不同年龄层面对的孤独境况也不一样，无需害怕。</p><blockquote><p>P26 “情欲孤独，在本质上并无好与坏的分别，情欲是一种永远不会变的东西，你渴望在身体发育之后，可以和另外一个身体有更多的了解、拥抱，或爱，你用任何名称都可以。因为人本来就是孤独的，犹如柏拉图在两千多年前写下的寓言：每一个人都是被劈开成两半的一个不完整个体，终其一生在寻找另一半，却不一定能找到，因为被劈开的人太多了。”</p></blockquote><p>有时候你以为找到了，有时候你以为永远找不到。</p><p>儒家文化的理想是“大同”社会，不谈隐私，不注重私密也就没有孤独可言。又或许在那种社会环境下，孤独便会是“同”而不可“合”，每个人注定背负的一种感觉。在这本书中，作者并不是遵循儒家思想去隐匿孤独或是消除孤独，正相反。</p><blockquote><p>P30 “儒家文化不谈隐私，不注重个人的私密性。从许多传统小说中，包括张爱玲的，都会提到新婚夫妇与父母同住，隔着一道薄薄的板壁，他们连晚上做爱，都不敢发出声音。一个连私人空间都不允许的文化，当然也不存在孤独感。”</p><p>“因而我要谈的不是如何<strong>消除孤独</strong>，而是如何<strong>完成孤独</strong>，如何<strong>给予孤独</strong>，如何<strong>尊重孤独</strong>。”</p></blockquote><h2 id="对抗群体文化"><a href="#对抗群体文化" class="headerlink" title="对抗群体文化"></a>对抗群体文化</h2><p>从一个熟悉的文化环境转换至另一个陌生的文化环境，这种“文化思乡”也可以理解成是一种孤独，但这种“孤独”和作者在文中提到的抵达巴黎时的“孤独”并不一样。</p><blockquote><p>P33 “…这是他们的私领域，你看是你的不对，不是他们的不对。”</p></blockquote><p>一些西方社会中并不会把“隐秘”和“隐私”等价起来，但在中国却会有这种固有思想，我们会认为藏起来的才是“隐私”，一旦隐私被示众，如果是持有者自愿的，似乎会被社会群体当作撕掉隐私属性的充分条件。蒋勋将两地的不同体验做对比，认为这是不同文化对孤独感的诠释。要我说，这是一种天然的“群体绑架”（或许是我太年轻了）。</p><blockquote><p>P33 “我每次看到这一幕，就会想起沈从文的小说。这是不同的文化对孤独感的诠释”。</p></blockquote><p>当然就如节标题一样，蒋勋或许是更偏向认同彼方文化对孤独感的诠释，他举鲁迅为例。</p><blockquote><p>P34 “鲁迅的小说如《狂人日记》《药》等，都是在触碰传统社会所压抑的孤独感；他的散文更明显，如以孤独为主题的《孤独者》等。鲁迅是一个极度孤独的人，孤独使他一直在逃避群体，所以我们看到他作为一个作家、文学家，最重要的是他要维持他的特立独行、维持他的孤独感，因为他成名了，影响了那么多人。……他害怕被卷入群体之中，只好再次出走……”</p><p>“他一直在出走，因为作为一个社会心灵的思考者，他必须保有长期的孤独。”</p></blockquote><h1 id="语言孤独"><a href="#语言孤独" class="headerlink" title="语言孤独"></a>语言孤独</h1><blockquote><p>“每个人都在说，去没有人在听。”</p></blockquote><!-- TODO --><p>待完善</p>]]></content>
    
    
    <categories>
      
      <category>Life</category>
      
      <category>阅读</category>
      
    </categories>
    
    
    <tags>
      
      <tag>阅读</tag>
      
      <tag>待完善</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>密码技术学习——Keccak论文总结</title>
    <link href="/post/c5c22535.html"/>
    <url>/post/c5c22535.html</url>
    
    <content type="html"><![CDATA[<h1 id="摘要部分"><a href="#摘要部分" class="headerlink" title="摘要部分"></a>摘要部分</h1><h1 id="理论部分"><a href="#理论部分" class="headerlink" title="理论部分"></a>理论部分</h1><h2 id="已有成果研究"><a href="#已有成果研究" class="headerlink" title="已有成果研究"></a>已有成果研究</h2><p>Keccak 自诞生以来，经历了密码学界广泛的分析，全世界各高校与机构的研究对有关 Keccak 算法（及其相关的衍生算法）的研究成果以及 Keccak 团队的密码学分析被汇总在 Team Keccak 网站中，以方便研究者们相互讨论学习。另外该网站上还长期开放着 Keccak 原像与碰撞攻击挑战赛（The Keccak Crunchy Crypto Collision and Pre-image Contest），目前最好的原像攻击成果是 4 轮指定像值的攻击 ，由新加坡南洋理工大学郭建博士的和中国科学院信息工程研究所刘美成副研究员于 2016 年 12 月提交。从目前看，现有的 Keccak 密码分析仍集中在缩减论述后的 Keccak 算法，并不能威胁到其实际应用时的安全性。由于本次赛题二是对具备前缀 0 特征的 Keccak256 哈希值求其原像，求解过程更接近于密码分析中的原像攻击，已有的研究成果如下：</p><p>早期代表性的研究有，2011 年 Naya-Plasencia 等人提出了低轮 Keccak 算法的可行攻击方式，其中包括 2 轮 Keccak-256 第二原像的攻击方式（复杂度为$O(2^{33})$），以及 Morawiecki 等人于 2010 至 2013 年的一系列工作，包括基于 SAT 求解器的密码分析旋转密码分析，并据此完成了 Keccak 原像与碰撞攻击挑战赛中的 3 各 2 轮指定像值的原像攻击。</p><p>通过构造满足一些代数性质的形式来进行密码攻击的方式在后来被开发出来，拓宽了 Keccak 密码分析的思路并推进了其他 Keccak 实例的原像攻击进程。2016 年 Guo，Liu 和 Song 提出了“线性结构”（Linear Structure）的原像攻击设计思路并发现了最高达 4 轮的 Keccak 攻击方法。应用该结构，可在现实时间内实现 2 轮 Keccak-256（即 Keccak[1088,512]）的原像攻击（复杂度为$O(1)$），3 轮 Keccak[640,160]的原像攻击（复杂度为$O(2^7)$）和 3 轮 Keccak[1440,160]的原像攻击（复杂度为$O(1)$），同时也使另外一些形式的 Keccak 实例的原像攻击理论复杂度降低，如 3 轮 Keccak-256（复杂度为$O(2^{192}$)），3 轮 Keccak-512（复杂度为$O(2^{482})$）以及 4 轮 Keccak[1440,160]（复杂度为$O(2^{54})$）。</p><p>在此之后 2017 年由 Li 等人提出“交叉线性结构”（Cross-Linear Structure），并将其应用在一些 Keccak 实例的原像攻击中，成功完成 3 轮 Keccak[240,160]的可行原像攻击（复杂度为$O(2^{45})$）。在这之后，Li 和 Sun 又发现了进一步优化复杂度的方法，将攻击过程划分为离线阶段与在线阶段两个子过程，成功实现 3 轮 Keccak-224 的可行原像攻击（复杂度为$O(2^{39.39})$）。</p><a id="more"></a><h1 id="工具部分"><a href="#工具部分" class="headerlink" title="工具部分"></a>工具部分</h1><h2 id="NTL-数论库"><a href="#NTL-数论库" class="headerlink" title="NTL 数论库"></a>NTL 数论库</h2><h3 id="NTL-数论库介绍"><a href="#NTL-数论库介绍" class="headerlink" title="NTL 数论库介绍"></a>NTL 数论库介绍</h3><p>NTL 是由纽约大学 Victor Shoup 主持编写并维护的一个高性能可移植 C++库，该库提供了相当多的数据结构和算法用于数论研究中矢量，矩阵和多项式的计算。NTL 库在性能上非常优秀，其实现的多项式算法是目前世界上最快的可用方法之一，并已经成为建立多项式分解和确定椭圆曲线的“世界纪录”。</p><p>NTL 数论库使用<br>常用基本类</p><ul><li>ZZ: 大整数</li><li>ZZ_p: 模 p 大整数</li><li>GF2: 模 2 整数</li><li>ZZX: ZZ 单变量多项式</li><li>ZZ_pX: ZZ_p 大整数单变量多项式</li><li>GF2X: GF2 单变量多项式</li><li>ZZ_pE: 大整数环/域扩张</li><li>GF2E: 模 2 整数环/域扩张</li><li>ZZ_pEX: ZZ_pE 单变量多项式</li><li>GF2EX: GF2E 单变量多项式<br>支持的运算符重载，其中%，%=只对大整数和其对应的多项式有意义。</li></ul><p>+， -， (unary) -， +=， -=， ++， —， *， *=， /， /=， %， %=</p><p>向量和矩阵，NTL 向量与 C++ STL 中的向量实现类似，类命名方式为对应基本类前加‘vec<em>’前缀和‘mat</em>’前缀</p><ul><li>vec_ZZ</li><li>vec_GF2</li><li>mat_GF2</li></ul><p>多项式常用函数</p><ul><li>IsIdent 单元矩阵判断</li><li>transpose 矩阵转置</li><li>solve 解矩阵方程（高斯消元法）</li><li>inv 矩阵求逆</li></ul><h2 id="并行编程"><a href="#并行编程" class="headerlink" title="并行编程"></a>并行编程</h2><h3 id="CUDA-并行编程"><a href="#CUDA-并行编程" class="headerlink" title="CUDA 并行编程"></a>CUDA 并行编程</h3><p>CUDA (Compute Unified Device Architecture，统一计算架构) 是 NVIDIA 提出，可在 NVIDIA 图形处理器进行并行计算的计算环境。程序设计这可以利用 CUDA 的 C 语言扩充 (extension) 直接编程，CUDA 会将运费算分配到大量线程(threads)以及图形处理器中数以百计的计算核心中(cores)。</p><p>GPU 不是独立的计算平台，需要与 CPU 协同工作。我们常说的用 GPU 并行计算时，其实是指 CPU+GPU 的异构计算架构。CPU 所在位置为主机端（host），而 GPU 所在位置成为设备端（device）。</p><p>典型的 CUDA 程序的执行流程如下：</p><ol><li>分配 host 内存，进行数据初始化（initalize）</li><li>分配 device 内存，host =&gt; device 内存拷贝</li><li>调用 CUDA 和函数，（GPU 上）完成指定运算</li><li>讲 device 上的运算结果拷贝回 host</li><li>释放 host 和 device 的内存。</li></ol><p>CUDA 这个异构模型通过函数类型限定词开区别 host 和 device 上的函数，主要的三个函数类型限定词如下:</p><ul><li><code>__global__</code>：在 device 上执行，从 host 中调用（一些特定的 GPU 也可以从 device 上调用），返回类型必须是 void，不支持可变参数，不能成为类成员函数。注意用<code>__global__</code>定义的 kernel 是异步的，这意味着 host 不会等待 kernel 执行完就执行下一步。</li><li><code>__device__</code>：在 device 上执行，单仅可以从 device 中调用，不可以和<code>__global__</code>同时用。</li><li><code>__host__</code>：在 host 上执行，仅可以从 host 上调用，一般省略不写，不可以和<code>__global__</code>同时用，但可和<code>__device__</code>同时使用，此时函数会在 device 和 host 都编译。</li></ul><h3 id="OpenMP-并行编程"><a href="#OpenMP-并行编程" class="headerlink" title="OpenMP 并行编程"></a>OpenMP 并行编程</h3><p>OpenMP（Open Multi-Processing）是一套支持跨平台共享内存方式的多线程并发的编程 API，使用 C,C++和 Fortran 语言，可以在大多数的处理器体系和操作系统中运行，包括 Solaris, AIX, HP-UX, GNU/Linux, Mac OS X, 和 Microsoft Windows。包括一套编译器指令、库和一些能够影响运行行为的环境变量。</p><p>OpenMP 采用可移植的、可扩展的模型，为程序员提供了一个简单而灵活的开发平台，从标准桌面电脑到超级计算机的并行应用程序接口。</p><p>混合并行编程模型构建的应用程序可以同时使用 OpenMP 和 MPI，或更透明地通过使用 OpenMP 扩展的非共享内存系统上运行的计算机集群。</p><p>OpenMP 是由 OpenMP Architecture Review Board 牵头提出的，并已被广泛接受的，用于共享内存并行系统的多线程程序设计的一套指导性注释（Compiler Directive）。OpenMP 支持的编程语言包括 C 语言、C++和 Fortran；而支持 OpenMP 的编译器包括 Sun Studio 和 Intel Compiler，以及开放源码的 GCC 和 Open64 编译器。OpenMP 提供了对并行算法的高层的抽象描述，程序员通过在源代码中加入专用的 pragma 来指明自己的意图，由此编译器可以自动将程序进行并行化，并在必要之处加入同步互斥以及通信。当选择忽略这些 pragma，或者编译器不支持 OpenMP 时，程序又可退化为通常的程序（一般为串行），程序码仍然可以正常运作，只是不能利用多线程来加速程序执行。</p><h1 id="结果部分"><a href="#结果部分" class="headerlink" title="结果部分"></a>结果部分</h1><!-- TODO --><p>等待完善</p>]]></content>
    
    
    <categories>
      
      <category>Computer Science</category>
      
      <category>密码学</category>
      
    </categories>
    
    
    <tags>
      
      <tag>待完善</tag>
      
      <tag>密码学</tag>
      
      <tag>Keccak</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>软件测试学习——期末复习汇总</title>
    <link href="/post/da77de95.html"/>
    <url>/post/da77de95.html</url>
    
    <content type="html"><![CDATA[<h1 id="题目设置"><a href="#题目设置" class="headerlink" title="题目设置"></a>题目设置</h1><h2 id="考试形式"><a href="#考试形式" class="headerlink" title="考试形式"></a>考试形式</h2><p>全部纯主观题目，网络上的资料不保证正确性，主要来自音频内容。</p><p>回答方式：有理有据，讲述完整。</p><h2 id="考试内容"><a href="#考试内容" class="headerlink" title="考试内容"></a>考试内容</h2><p>两部分：论述题、综合题</p><p>论述题三个小题（40 分），每个题目围绕一个知识点进行论数。</p><p>综合题两个小题（60 分），针对具体问题，两个问题彼此相关，需要围绕知识点进行论述。</p><p>重要知识点:</p><ul><li>测试的基本概念</li><li>测试在软件开发中的角色，处在开发哪个阶段，与其他软件开发阶段有哪些联系。</li><li>奠定软件测试的<strong>几项基本原则、核心知识</strong>：比如穷举测试不可行、不可证明软件系统的正确性只能用来发现缺陷。测试定律，Myers 不充分测试，重点测试法则。理解定律的<strong>存在前提</strong>，现实情况下的<strong>出现频率</strong>，这些定律<strong>如何应用和指导实践</strong>。</li><li>白盒测试策略，覆盖类型，<strong>MC/DC（修正的判定条件覆盖）</strong>，懂设计逻辑，理解设计的优势。</li><li>黑河测试策略，边界值法，等价类划分法（课上强调要一起用）。先等价类划分，然后基于等价类去设计边界值。</li><li>TDD：掌握如何去做，<strong>需求</strong>的重要性。需要听一下上一段录音。<ul><li>系统必须做什么:</li><li>系统应当做什么：</li><li>系统可以做什么：</li><li>系统最好不要做什么：</li><li>系统禁止做什么：</li></ul></li></ul><p>罗素：不管你信什么，都不要全信它。</p><a id="more"></a><p>下面是重要知识点专题讲解</p><h3 id="软件测试基本原则与一些定律"><a href="#软件测试基本原则与一些定律" class="headerlink" title="软件测试基本原则与一些定律"></a>软件测试基本原则与一些定律</h3><ul><li><p>谈形式化与测试</p><p>形式化验证 是一个很老的研究方向了，且至今一直都有研究者跟进，其中一些研究者主要来自于欧洲。其相关方法，通常仅限于科研，实践中很少见到和用到。</p><p>制约此类方法实践价值的最大瓶颈在于 三个字 “形式化”。<br>这必然涉及到 形式推理，依此判断代码中是否包含错误。<br>问题在于：代码写法多样，难以形式化。除非就用遵循严格形式化的语言编写代码（例如 Z 语言），才能有效支撑形式化验证。<br>但如此一来，带来了另外的麻烦，就是 以形式化语言编写的代码存在的四难：难读、难懂、难写、难改。</p><p>须知，软件是需要变化的，只有持续变化才能持续跟进用户的新需要。由于这四难，使得形式化语言根本无法应用于实践。</p></li></ul><h3 id="TDD-测试驱动开发"><a href="#TDD-测试驱动开发" class="headerlink" title="TDD 测试驱动开发"></a>TDD 测试驱动开发</h3><p>概念：要求在编写某个功能代码之前先编写测试用例，然后只编写能令测试用例通过的功能代码</p><p>需求-设计-构造-测试</p><ul><li><p>TDD 编程的三个环节：</p><p>红灯状态-绿灯状态-重构状态</p><p>从李老师回答的启发：重构状态是指，结构层面的代码优化，想要保证功能和重构之前的<strong>形式一致性</strong>，红灯到绿灯状态是的测试通过是表达代码的<strong>内容一致性</strong>。内容重要性大于大于形式一致性，所以应先测试再重构（虽然我当时问的问题是重构完了是不是要再经历一遍红灯绿灯，李老师可能理解错了）。</p><p>测试套件简表形式</p><p>编号|输入|预期输出|实际输出</p></li></ul>]]></content>
    
    
    <categories>
      
      <category>Computer Science</category>
      
      <category>软件测试</category>
      
    </categories>
    
    
    <tags>
      
      <tag>软件测试</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>USTCReadingGroup——Cloud-Based-Distributed-Training</title>
    <link href="/post/3dd78f6.html"/>
    <url>/post/3dd78f6.html</url>
    
    <content type="html"><![CDATA[<!--文章由 3step 模板生成三步法阅读文献笔记记录--><h1 id="Step-1"><a href="#Step-1" class="headerlink" title="Step 1"></a>Step 1</h1><h2 id="题目摘要引言"><a href="#题目摘要引言" class="headerlink" title="题目摘要引言"></a>题目摘要引言</h2><h2 id="基本理论概况"><a href="#基本理论概况" class="headerlink" title="基本理论概况"></a>基本理论概况</h2><h2 id="结论部分"><a href="#结论部分" class="headerlink" title="结论部分"></a>结论部分</h2><!-- 确定作者的成过以及点出的经验、问题、改进方 --><h2 id="回答基本问题"><a href="#回答基本问题" class="headerlink" title="回答基本问题"></a>回答基本问题</h2><ol><li>类别</li></ol><!-- 这篇论文是什么类型？测试类？对现有系统进行分析的？对原型系统进行描述的？--><ol><li>内容</li></ol><!-- 你读过的其他论文有没有与之相关的？相关性与区别最直接体现在哪里？文章中分析问题用的什么理论基础（通过瞥一眼数学概况与核心证明可以得到）。 --><ol><li>正确性</li></ol><!-- 结论是否看起来真实有效？ --><ol><li>创新点</li></ol><!-- 论文的主要创新点是什么？总结提到的经验、问题和改进方法是什么？ --><ol><li>清晰度</li></ol><!-- 这篇论文是否写的条理清晰 --><h2 id="阅读选择"><a href="#阅读选择" class="headerlink" title="阅读选择"></a>阅读选择</h2><!--1. 继续阅读：论文有价值担保，研究领域非常切合，对当前进行工作有极大帮助，圈内爆火文章2. 不继续阅读：论文不吸引自己，论文价值/正确性存疑，论文作者给出了不适当的假设。3. 库存保留并标记：当前不处于自己的研究领域，但不久的日后相关论文会有用。--><a id="more"></a><h1 id="Step-2"><a href="#Step-2" class="headerlink" title="Step 2"></a>Step 2</h1><h2 id="细读笔记"><a href="#细读笔记" class="headerlink" title="细读笔记"></a>细读笔记</h2><!-- 要仔细阅读论文，但是诸如证明等信息要忽略掉 --><h2 id="问题记录"><a href="#问题记录" class="headerlink" title="问题记录"></a>问题记录</h2><h2 id="未读（且值得读）文献记录"><a href="#未读（且值得读）文献记录" class="headerlink" title="未读（且值得读）文献记录"></a>未读（且值得读）文献记录</h2><!-- 在第二步中，找到以上几篇论文中相同的引用文献、在引用文献中重复的作者名，这些就是你所调研领域的重点论文和科研人员，下载那些重点论文暂时搁到一边。继续访问那些重要科研人员的网页，看下那些论文是在什么会议集结出版的。这能帮你找到那个领域的顶级会议，因为那些重要科研人员通常会在顶级会议发表论文。 --><h1 id="Step-3"><a href="#Step-3" class="headerlink" title="Step 3"></a>Step 3</h1><!-- 试着“在脑中重新实现（virtually re-implement）”那篇论文：也就是，和作者一样做出相同的假设，然后重新实现相同的工作。通过对比你自己得出的和论文中给出的结果，不仅可以很轻易验证一篇论文的创新点是否真实，而且还能发现论文中不会讲的缺点和假想。 --><h2 id="思路复现"><a href="#思路复现" class="headerlink" title="思路复现"></a>思路复现</h2><!-- 推敲作者是如何立题，如何找到突破口，在其中是否有抉择，如何做出的假设？ --><h2 id="证明与推理复现"><a href="#证明与推理复现" class="headerlink" title="证明与推理复现"></a>证明与推理复现</h2><!-- 分析证明过程，确定证明的正确性以及完整性。对证明过程做拓展，调研证明思路来源 --><h2 id="实验验证复现"><a href="#实验验证复现" class="headerlink" title="实验验证复现"></a>实验验证复现</h2><!-- Rework --><h1 id="ReadingGroup-会议"><a href="#ReadingGroup-会议" class="headerlink" title="ReadingGroup 会议"></a>ReadingGroup 会议</h1><h2 id="Motivation"><a href="#Motivation" class="headerlink" title="Motivation"></a>Motivation</h2><p>图</p><p>PC2：Pytorch/Caffee2</p><p>MX：MxNet（）</p><p>GV：Gradient Compression Enable（梯度压缩）</p><p>Q：ec2 和 Azure 时可以设置“部署”在同一个机架？好像不能这个拓扑？<br>A：现在提出的就是，提出一种算法，探测这种拓扑。</p><p>Inefficiencies in Existing Approaches</p><p>拓扑感知</p><h2 id="Design-and-Implementation"><a href="#Design-and-Implementation" class="headerlink" title="Design and Implementation"></a>Design and Implementation</h2><ul><li>Idea #1: Two Level Hierarchial Aggregation<ul><li>HA does not reduce the total amount of data transferred on the wire, but create more localized traffic and avoid slow links</li><li>为什么选择两级，经验法则选取<ul><li>Step. 数据转入 buffer，分块，选出 local master</li></ul></li></ul></li><li>Idea #2: Capturing Network Locality with ProbeEmbed(？嵌入)<ul><li>嵌入到一个欧式空间（优化一个最小值）</li><li>Grouping nodes<ul><li>$k+\frac{n}{k}$，$k = \sqrt{n}$取最值。</li><li>用 K-means</li><li>我问的问题：$a$参数是可调的（$a$越大越“推开”）</li></ul></li></ul></li><li>Idea #3：Reacting to Network Changes with Autotune<ul><li>核心想法：将负载从 bottleneck node 转移走，基于<code>blame</code>（惩罚系数）</li><li>惩罚系数构成：<ul><li>$t(i), l(i), B(i)$</li></ul></li></ul></li></ul><h2 id="Summary"><a href="#Summary" class="headerlink" title="Summary"></a>Summary</h2><ul><li><p>PLink 工作包括：</p><ul><li>Topology-aware</li><li>Hierarchical aggregation</li><li>Autotune</li></ul></li><li><p>Limitations：</p><ul><li>Can’t get enough benefit from finetune</li><li>The complexity of topology-aware 是 O(n)</li></ul></li></ul>]]></content>
    
    
    <categories>
      
      <category>Research</category>
      
      <category>Paper</category>
      
    </categories>
    
    
    <tags>
      
      <tag>Paper</tag>
      
      <tag>三步法</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>分布式系统学习——SOSP2006亚马逊DynamoKV存储系统</title>
    <link href="/post/efb778b6.html"/>
    <url>/post/efb778b6.html</url>
    
    <content type="html"><![CDATA[<!--文章由 3step 模板生成三步法阅读文献笔记记录--><h1 id="Step-1"><a href="#Step-1" class="headerlink" title="Step 1"></a>Step 1</h1><h2 id="题目摘要引言"><a href="#题目摘要引言" class="headerlink" title="题目摘要引言"></a>题目摘要引言</h2><h3 id="题目"><a href="#题目" class="headerlink" title="题目"></a>题目</h3><p>Dynamo，Amazon 高高可用性 KV 存储系统</p><h3 id="摘要"><a href="#摘要" class="headerlink" title="摘要"></a>摘要</h3><p>Amazon 作为世界上最大的电子商务公司之一，轻微中断也会有严重的经济后果。由于亚马逊还同时为许多网站提供服务（作为 IaaS 或者 SaaS ），这同时也会影响公司的商业信誉。亚马逊的服务是在位于全球许多数据中心的数万台服务器和网络组件的基础设施上实现的。在这种规模下，大小组件都会持续地产生故障，从而推动了对系统可靠性和扩展性研究。</p><p>文章描述了 Dynamo 的设计和实现，Dynamo 是一种高可用的键值存储系统，Amazon 的一些核心服务使用该系统提供“always-on”的体验。为了实现这种级别的可用性，Dynamo 在某些故障场景下牺牲了一致性。</p><h3 id="引言"><a href="#引言" class="headerlink" title="引言"></a>引言</h3><p>Amazon 平台业务需求：性能（performance），可靠性（reliability） ，效率（efficiency）</p><h2 id="基本理论概况"><a href="#基本理论概况" class="headerlink" title="基本理论概况"></a>基本理论概况</h2><h2 id="结论部分"><a href="#结论部分" class="headerlink" title="结论部分"></a>结论部分</h2><!-- 确定作者的成过以及点出的经验、问题、改进方 --><h2 id="回答基本问题"><a href="#回答基本问题" class="headerlink" title="回答基本问题"></a>回答基本问题</h2><ol><li>类别</li></ol><!-- 这篇论文是什么类型？测试类？对现有系统进行分析的？对原型系统进行描述的？--><ol><li>内容</li></ol><!-- 你读过的其他论文有没有与之相关的？相关性与区别最直接体现在哪里？文章中分析问题用的什么理论基础（通过瞥一眼数学概况与核心证明可以得到）。 --><ol><li>正确性</li></ol><!-- 结论是否看起来真实有效？ --><ol><li>创新点</li></ol><!-- 论文的主要创新点是什么？总结提到的经验、问题和改进方法是什么？ --><ol><li>清晰度</li></ol><!-- 这篇论文是否写的条理清晰 --><h2 id="阅读选择"><a href="#阅读选择" class="headerlink" title="阅读选择"></a>阅读选择</h2><!--1. 继续阅读：论文有价值担保，研究领域非常切合，对当前进行工作有极大帮助，圈内爆火文章2. 不继续阅读：论文不吸引自己，论文价值/正确性存疑，论文作者给出了不适当的假设。3. 库存保留并标记：当前不处于自己的研究领域，但不久的日后相关论文会有用。--><a id="more"></a><h1 id="Step-2"><a href="#Step-2" class="headerlink" title="Step 2"></a>Step 2</h1><h2 id="细读笔记"><a href="#细读笔记" class="headerlink" title="细读笔记"></a>细读笔记</h2><!-- 要仔细阅读论文，但是诸如证明等信息要忽略掉 --><h2 id="问题记录"><a href="#问题记录" class="headerlink" title="问题记录"></a>问题记录</h2><h2 id="未读（且值得读）文献记录"><a href="#未读（且值得读）文献记录" class="headerlink" title="未读（且值得读）文献记录"></a>未读（且值得读）文献记录</h2><!-- 在第二步中，找到以上几篇论文中相同的引用文献、在引用文献中重复的作者名，这些就是你所调研领域的重点论文和科研人员，下载那些重点论文暂时搁到一边。继续访问那些重要科研人员的网页，看下那些论文是在什么会议集结出版的。这能帮你找到那个领域的顶级会议，因为那些重要科研人员通常会在顶级会议发表论文。 --><h1 id="Step-3"><a href="#Step-3" class="headerlink" title="Step 3"></a>Step 3</h1><!-- 试着“在脑中重新实现（virtually re-implement）”那篇论文：也就是，和作者一样做出相同的假设，然后重新实现相同的工作。通过对比你自己得出的和论文中给出的结果，不仅可以很轻易验证一篇论文的创新点是否真实，而且还能发现论文中不会讲的缺点和假想。 --><h2 id="思路复现"><a href="#思路复现" class="headerlink" title="思路复现"></a>思路复现</h2><!-- 推敲作者是如何立题，如何找到突破口，在其中是否有抉择，如何做出的假设？ --><h2 id="证明与推理复现"><a href="#证明与推理复现" class="headerlink" title="证明与推理复现"></a>证明与推理复现</h2><!-- 分析证明过程，确定证明的正确性以及完整性。对证明过程做拓展，调研证明思路来源 --><h2 id="实验验证复现"><a href="#实验验证复现" class="headerlink" title="实验验证复现"></a>实验验证复现</h2><!-- Rework -->]]></content>
    
    
    <categories>
      
      <category>Computer Science</category>
      
      <category>分布式系统</category>
      
    </categories>
    
    
    <tags>
      
      <tag>Paper</tag>
      
      <tag>三步法</tag>
      
      <tag>分布式系统</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>《Minecraft诞生纪录片》观后感</title>
    <link href="/post/b2053c47.html"/>
    <url>/post/b2053c47.html</url>
    
    <content type="html"><![CDATA[<blockquote><p>So, do you have any words of advice to people out there that, you know, trying to become an indie developer?<br>所以你有没有给那些人们一些建议，比如鼓励他们努力成为一个独立开发者？</p></blockquote><p>Notch 的建议</p><blockquote><p>I think that the best advice I can give everyone is, “Don’t listen to advice”, buf if you are going to listen to advice, then making sure you actually do something is good advice. If you just sit around planning something and not doing it, you’re not actually gonna get anywhere.<br>我想给每个人最好的建议是，“不要听他人的建议”，如果你一定要听的话，那么实实在在做事就是好建议。如果你只是坐着空想而不做，那么你什么都不会收获。</p></blockquote><a id="more"></a>]]></content>
    
    
    <categories>
      
      <category>Life</category>
      
      <category>影视</category>
      
    </categories>
    
    
    <tags>
      
      <tag>影视</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>《武汉人》读书摘录</title>
    <link href="/post/f601635a.html"/>
    <url>/post/f601635a.html</url>
    
    <content type="html"><![CDATA[<p>我没读过《武汉日记》，但我读完了《武汉人》。</p><h1 id="第一部分-“武汉这个地方”"><a href="#第一部分-“武汉这个地方”" class="headerlink" title="第一部分 “武汉这个地方”"></a>第一部分 “武汉这个地方”</h1><h2 id="武汉这个地方"><a href="#武汉这个地方" class="headerlink" title="武汉这个地方"></a>武汉这个地方</h2><blockquote><p>P1 “武汉这个地方一直被人们称做‘江城’。它之所以有着如此的称呼，自然是因为它坐落在中国最大的河流长江之滨的缘故。其实将武汉称做‘湖城’也是不错的。它是‘千湖之省’湖北省的首府，环绕着它的湖泊至少也有一百个左右。这些湖泊便如明珠或玉佩劈挂在武汉的身上，有风吹过时，你说不定会听到它满身叮当作响的声音。旧居的老人们能听得出，那是江之涛和湖之浪因风的撩拨而发出的回应。”</p><p>P2 “三镇的风格不知是哪一年定下的，或许始自张之洞督鄂的时候。虽说现在已随时间的推移和都市的现代化而发生了莫大的变化，但是这种特色却仍明显地存在着。”</p><p>P3 “同许多著名的大都市一样，武汉不仅是个商业都市，也是个工业基地和科研基地。它有着沧桑往事，也有着血泪历史；有着租界之耻辱，也有着反抗之传奇；有着建设高潮，也有着‘文革’笑话；有着英雄，也有着娼妓；有着水一样的车辆和虹霓不眠的夜晚，也有着豪华的酒店和热闹的超市；有着绿树红墙，也有着环境污染；有着平静和美，也有着暴富赤贫。总之，现代都市们所享有的繁华先进和与之并存的都市诟病，武汉也都不差少。”</p></blockquote><h2 id="一个人和一座城市"><a href="#一个人和一座城市" class="headerlink" title="一个人和一座城市"></a>一个人和一座城市</h2><p>张之洞成就了武汉，武汉也成就了张之洞。他在人生最成熟的年纪抵达武汉，将所有经历积淀成实业，推动了武汉近百年的发展历程。</p><blockquote><p>P6 “历经了清流党的高谈阔论，历经了山西巡抚的兴革岁月，历经了两广总督的对法作战，阅历早已促使张之洞由一个空谈者成为一个实干家。武汉这个潜力无限的场地便成为他的收功之地。张之洞督鄂十九年，他成就了武汉，而武汉也成就了张之洞。”</p></blockquote><p>汉阳炼铁厂成为中国最早的官办钢铁企业，为武汉的工业基础作了最初也是最重要的奠基。芦汉铁路的四通八达、“汉阳造”像如今的“Made in China”一样打响名号，还有“张公堤”、“自强学堂”等一系列对武汉民生、教育事业影响深刻的举措。</p><blockquote><p>P8 “张之洞所做的这一切，用两个字形容，就叫‘<strong>开放</strong>’。在一个人存政兴、人亡政熄的年代，张之洞全然以他个人的能量使得地处内地、经济封闭保守的武汉拥有它生平最大的一次起飞。”<br>“可以说，张之洞当年的政绩至今仍影响着武汉，而时间却已经过去了百年。”</p></blockquote><p>在离开武汉后，他的门生们兴建纪念性楼堂，以追忆张之洞之政绩，那时他还没有撒手而去，在世者被世人所纪念，是无数为政者梦寐以求的事情。然后他却说“点缀名胜，眺览江山，大是佳事，何必为区区一迂儒病翁乎。”谦逊可见。</p><p>而方方是这样解释为何从此一人讲起武汉的。</p><blockquote><p>P10 “站在张公堤上，心里充满对这个人的感佩，就觉得要写武汉近百年间发生过的故事，必须从这个人写起，必须从这道堤写起。”</p></blockquote><a id="more"></a><h2 id="楼与传说"><a href="#楼与传说" class="headerlink" title="楼与传说"></a>楼与传说</h2><h2 id="红楼前的革命"><a href="#红楼前的革命" class="headerlink" title="红楼前的革命"></a>红楼前的革命</h2><h2 id="江北的桅杆"><a href="#江北的桅杆" class="headerlink" title="江北的桅杆"></a>江北的桅杆</h2><h2 id="西风烈"><a href="#西风烈" class="headerlink" title="西风烈"></a>西风烈</h2><h2 id="汉口第一路"><a href="#汉口第一路" class="headerlink" title="汉口第一路"></a>汉口第一路</h2><h2 id="汉上花园"><a href="#汉上花园" class="headerlink" title="汉上花园"></a>汉上花园</h2><h2 id="跑马溜溜的汉口"><a href="#跑马溜溜的汉口" class="headerlink" title="跑马溜溜的汉口"></a>跑马溜溜的汉口</h2><h2 id="都市的乐园"><a href="#都市的乐园" class="headerlink" title="都市的乐园"></a>都市的乐园</h2><h2 id="滨湖的大学"><a href="#滨湖的大学" class="headerlink" title="滨湖的大学"></a>滨湖的大学</h2><h1 id="第二部分-“武汉风情”"><a href="#第二部分-“武汉风情”" class="headerlink" title="第二部分 “武汉风情”"></a>第二部分 “武汉风情”</h1><h2 id="在武汉过夏天"><a href="#在武汉过夏天" class="headerlink" title="在武汉过夏天"></a>在武汉过夏天</h2><h2 id="玩水"><a href="#玩水" class="headerlink" title="玩水"></a>玩水</h2><h2 id="当街夜风景"><a href="#当街夜风景" class="headerlink" title="当街夜风景"></a>当街夜风景</h2><h2 id="戏与戏迷"><a href="#戏与戏迷" class="headerlink" title="戏与戏迷"></a>戏与戏迷</h2><h2 id="水的故事"><a href="#水的故事" class="headerlink" title="水的故事"></a>水的故事</h2><h2 id="书香武汉"><a href="#书香武汉" class="headerlink" title="书香武汉"></a>书香武汉</h2><h2 id="六渡桥的铜人像"><a href="#六渡桥的铜人像" class="headerlink" title="六渡桥的铜人像"></a>六渡桥的铜人像</h2><h2 id="关于桥"><a href="#关于桥" class="headerlink" title="关于桥"></a>关于桥</h2><h2 id="高头和底下"><a href="#高头和底下" class="headerlink" title="高头和底下"></a>高头和底下</h2><h2 id="城里的山水"><a href="#城里的山水" class="headerlink" title="城里的山水"></a>城里的山水</h2><h2 id="没有耐性"><a href="#没有耐性" class="headerlink" title="没有耐性"></a>没有耐性</h2><h2 id="在汉口和武昌跳来跳去"><a href="#在汉口和武昌跳来跳去" class="headerlink" title="在汉口和武昌跳来跳去"></a>在汉口和武昌跳来跳去</h2><h1 id="第三部分-“武汉人”"><a href="#第三部分-“武汉人”" class="headerlink" title="第三部分 “武汉人”"></a>第三部分 “武汉人”</h1><h2 id="武汉人说话"><a href="#武汉人说话" class="headerlink" title="武汉人说话"></a>武汉人说话</h2><h2 id="方言武汉"><a href="#方言武汉" class="headerlink" title="方言武汉"></a>方言武汉</h2><h2 id="武汉人的性格"><a href="#武汉人的性格" class="headerlink" title="武汉人的性格"></a>武汉人的性格</h2><h2 id="武汉人过早"><a href="#武汉人过早" class="headerlink" title="武汉人过早"></a>武汉人过早</h2><h2 id="武汉人的菜桌"><a href="#武汉人的菜桌" class="headerlink" title="武汉人的菜桌"></a>武汉人的菜桌</h2><h2 id="热干面的传说及其他"><a href="#热干面的传说及其他" class="headerlink" title="热干面的传说及其他"></a>热干面的传说及其他</h2><h2 id="去汉口吃粉"><a href="#去汉口吃粉" class="headerlink" title="去汉口吃粉"></a>去汉口吃粉</h2><h2 id="德国太婆玛尔塔和法力无边的网"><a href="#德国太婆玛尔塔和法力无边的网" class="headerlink" title="德国太婆玛尔塔和法力无边的网"></a>德国太婆玛尔塔和法力无边的网</h2><h2 id="汉口人是不是从骨子里追求物质的东西"><a href="#汉口人是不是从骨子里追求物质的东西" class="headerlink" title="汉口人是不是从骨子里追求物质的东西"></a>汉口人是不是从骨子里追求物质的东西</h2><h1 id="第四部分-“年少武汉”"><a href="#第四部分-“年少武汉”" class="headerlink" title="第四部分 “年少武汉”"></a>第四部分 “年少武汉”</h1><h2 id="少年往事"><a href="#少年往事" class="headerlink" title="少年往事"></a>少年往事</h2><h2 id="汉口消失的游戏"><a href="#汉口消失的游戏" class="headerlink" title="汉口消失的游戏"></a>汉口消失的游戏</h2><h2 id="行云流水的武汉"><a href="#行云流水的武汉" class="headerlink" title="行云流水的武汉"></a>行云流水的武汉</h2><h1 id="第五部分-“后记”"><a href="#第五部分-“后记”" class="headerlink" title="第五部分 “后记”"></a>第五部分 “后记”</h1><h2 id="我的小说与我生活的城市（代跋）"><a href="#我的小说与我生活的城市（代跋）" class="headerlink" title="我的小说与我生活的城市（代跋）"></a>我的小说与我生活的城市（代跋）</h2>]]></content>
    
    
    <categories>
      
      <category>Life</category>
      
      <category>阅读</category>
      
    </categories>
    
    
    <tags>
      
      <tag>阅读</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>分布式系统学习——OSDI2018PM哈希方案</title>
    <link href="/post/a0c7159f.html"/>
    <url>/post/a0c7159f.html</url>
    
    <content type="html"><![CDATA[<!--文章由 3step 模板生成三步法阅读文献笔记记录--><h1 id="Step-1"><a href="#Step-1" class="headerlink" title="Step 1"></a>Step 1</h1><h2 id="题目摘要引言"><a href="#题目摘要引言" class="headerlink" title="题目摘要引言"></a>题目摘要引言</h2><h3 id="题目"><a href="#题目" class="headerlink" title="题目"></a>题目</h3><p>为 Persistent Memory 设计的写优化 Hashing Index Scheme</p><h3 id="摘要"><a href="#摘要" class="headerlink" title="摘要"></a>摘要</h3><p>由于 NVM 数据一致性和硬件限制的要求，原来为 DRAM 设计的传统索引技术在 PM 中效率低下。为了有效高效地在 PM 中建立数据索引，本文提出了一种高性能写优化的架构—— <code>level hashing</code>（层级 Hashing）。</p><p><code>level hashing</code>（层级 Hashing）提供了基于共享的两层哈希表。不额外增加 NVM 写操作情况下就降低增删查改操作为常数复杂度。为了以较低开销实现一致性（这个是指什么的一致性？），level hashing 使用无日志（log-free）的一致性方案进行增删和 resize 操作。为了更高效 resize，level hashing 调整了 resize 方案，以 1/3 代替原有整表的代价。</p><h3 id="引言"><a href="#引言" class="headerlink" title="引言"></a>引言</h3><p>NVM 引入，对 DRAM 不足之处的补充，RcRAM，PCM，STT-RAM，3D XPoint。由于 byte-addressable 的优势和接近于 DRAM 的 latency，PM 可以直接与 CPU 通过内存总线相连。</p><p>NVM 的劣势:limited endurance and low write performance。</p><p><strong>Tree 索引工作概述</strong>：传统的方式进行数据索引效率低下，因为没有考虑到数据一致性和 NVM 设备的特性（这部分需要再读引用文献 35，46，58，64，68）。现有的许多工作都对 tree-based 数据索引结构进行研究以适应 PM（这部分仍需再读文章）。</p><p><strong>又谈 Hash 索引结构的必要性</strong>：与基于 tree 的索引结构不同，基于 hash 的结构式扁平的（相应，空间代价应该要更大一些？），能够实现 O(1)的查找速率（与总量 N 是独立的）。因而 哈希索引结构被广泛应用于主存系统，例如，它们是<strong>主内存数据库</strong>（27,33,38,65）的基本组件。</p><p>！下面的内容要重点关注，与后面的工作较为相关。</p><p>将哈希索引结构应用于 PM 所面临的挑战：</p><ul><li>High Overhead for Consistency Guarantee.（为保证一致性的高二开销）：</li><li>Performance Degradation for Reducing Writes.（为减少写操作而导致的性能下滑）：</li><li>Cost Inefficiency for Resizing Hash Table.（重设哈希表大小的代价效益问题）：</li></ul><p>为应对上述挑战，本文所提出的方法：</p><ul><li>Low-overhead Consistency Guarantee.（低负担的一致性保证）</li><li>Write-optimized Hash Table Structure. （写优化的哈希表结构 ）</li><li>Cost-efficient Resizing. （代价效益 Resize）</li><li>Real Implementation and Evaluation. （实际实现和分析）</li></ul><h2 id="基本理论概况"><a href="#基本理论概况" class="headerlink" title="基本理论概况"></a>基本理论概况</h2><h2 id="结论部分"><a href="#结论部分" class="headerlink" title="结论部分"></a>结论部分</h2><!-- 确定作者的成过以及点出的经验、问题、改进方 --><p>实现了单机 PM 上高效的哈希方式——level hashing，具备写优化、高性能、低负担的一致性保证与效益更好的 Resize 策略等性质。同时还支持高效的并发 multi-reader 和 multi-writier。</p><p>在 DRAM、PM 混合平台上的测试结果：</p><ul><li>和最先进的哈希方法对比：<ul><li>1.4-3.0 倍插入速率</li><li>1.2-2.1 倍更新速率</li><li>4.3 倍 Resize 调整思虑</li><li>保证较高的搜索和删除性能（文章中没有体现出来）</li></ul></li><li>和最先进的<strong>并发</strong>哈希方法对比：<ul><li>1.6-2.1 倍吞吐量（throughput）</li></ul></li></ul><h2 id="回答基本问题"><a href="#回答基本问题" class="headerlink" title="回答基本问题"></a>回答基本问题</h2><ol><li>类别</li></ol><!-- 这篇论文是什么类型？测试类？对现有系统进行分析的？对原型系统进行描述的？--><p>基于新型硬件对现有系统进行改良。</p><ol><li>内容</li></ol><!-- 你读过的其他论文有没有与之相关的？相关性与区别最直接体现在哪里？文章中分析问题用的什么理论基础（通过瞥一眼数学概况与核心证明可以得到）。 --><p>暂时没有相关性，应该要补充很多 Tree 结构的文章。</p><ol><li>正确性</li></ol><!-- 结论是否看起来真实有效？ --><p>源码开源在<a href="https://github.com/Pfzuo/Level-Hashing" target="_blank" rel="noopener">Level-Hashing</a></p><ol><li>创新点</li></ol><!-- 论文的主要创新点是什么？总结提到的经验、问题和改进方法是什么？ --><p>结合 PM 与 Hash Table，着重应对 Resize 地问题提供了解决方案，以小博大，获得了整体性能地提升。如果从 Hash 数据结构做出发点在 PM 上进行实现，这篇文章应该算不错地入门文章。</p><ol><li>清晰度</li></ol><!-- 这篇论文是否写的条理清晰 --><p>粗略看条理比较清晰，</p><h2 id="阅读选择"><a href="#阅读选择" class="headerlink" title="阅读选择"></a>阅读选择</h2><!--1. 继续阅读：论文有价值担保，研究领域非常切合，对当前进行工作有极大帮助，圈内爆火文章2. 不继续阅读：论文不吸引自己，论文价值/正确性存疑，论文作者给出了不适当的假设。3. 库存保留并标记：当前不处于自己的研究领域，但不久的日后相关论文会有用。--><p>继续阅读！</p><a id="more"></a><h1 id="Step-2"><a href="#Step-2" class="headerlink" title="Step 2"></a>Step 2</h1><h2 id="细读笔记"><a href="#细读笔记" class="headerlink" title="细读笔记"></a>细读笔记</h2><!-- 要仔细阅读论文，但是诸如证明等信息要忽略掉 --><h3 id="NVM-中的数据一致性"><a href="#NVM-中的数据一致性" class="headerlink" title="NVM 中的数据一致性"></a>NVM 中的数据一致性</h3><p>必须解决系统故障时易失性器间与非易失性器间间的数据一致性问题。CPU 和内存控制器可能会调整内存的写记录。我们需要使用缓存线路刷新指令（cache line flush instruction）和内存 fence 指令（memory fence instruction）来保证刷出了内存写内容。CFLUSH 和 MFENCE 指令由 Intel x86 指令集提供。</p><h2 id="问题记录"><a href="#问题记录" class="headerlink" title="问题记录"></a>问题记录</h2><h2 id="未读（且值得读）文献记录"><a href="#未读（且值得读）文献记录" class="headerlink" title="未读（且值得读）文献记录"></a>未读（且值得读）文献记录</h2><ul><li>现有数据索引低效的引用文献（35，46，58，64，68）</li><li>tree-based 数据索引结构研究<ul><li>CDDS B-tree （58）</li><li>NV-tree （64）</li><li>wB+-Tree （17）</li><li>FP-Tree （46）</li><li>WORT （35）</li><li>FAST&amp;FAIR （30）</li></ul></li></ul><!-- 在第二步中，找到以上几篇论文中相同的引用文献、在引用文献中重复的作者名，这些就是你所调研领域的重点论文和科研人员，下载那些重点论文暂时搁到一边。继续访问那些重要科研人员的网页，看下那些论文是在什么会议集结出版的。这能帮你找到那个领域的顶级会议，因为那些重要科研人员通常会在顶级会议发表论文。 --><h1 id="Step-3"><a href="#Step-3" class="headerlink" title="Step 3"></a>Step 3</h1><!-- 试着“在脑中重新实现（virtually re-implement）”那篇论文：也就是，和作者一样做出相同的假设，然后重新实现相同的工作。通过对比你自己得出的和论文中给出的结果，不仅可以很轻易验证一篇论文的创新点是否真实，而且还能发现论文中不会讲的缺点和假想。 --><h2 id="思路复现"><a href="#思路复现" class="headerlink" title="思路复现"></a>思路复现</h2><!-- 推敲作者是如何立题，如何找到突破口，在其中是否有抉择，如何做出的假设？ --><h2 id="证明与推理复现"><a href="#证明与推理复现" class="headerlink" title="证明与推理复现"></a>证明与推理复现</h2><!-- 分析证明过程，确定证明的正确性以及完整性。对证明过程做拓展，调研证明思路来源 --><h2 id="实验验证复现"><a href="#实验验证复现" class="headerlink" title="实验验证复现"></a>实验验证复现</h2><!-- Rework -->]]></content>
    
    
    <categories>
      
      <category>Computer Science</category>
      
      <category>分布式系统</category>
      
    </categories>
    
    
    <tags>
      
      <tag>Paper</tag>
      
      <tag>三步法</tag>
      
      <tag>分布式系统</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>分布式系统学习——Raft拓展版本论文学习</title>
    <link href="/post/9e6f1f62.html"/>
    <url>/post/9e6f1f62.html</url>
    
    <content type="html"><![CDATA[<!--文章由 3step 模板生成三步法阅读文献笔记记录--><h1 id="Step-1"><a href="#Step-1" class="headerlink" title="Step 1"></a>Step 1</h1><h2 id="题目摘要引言"><a href="#题目摘要引言" class="headerlink" title="题目摘要引言"></a>题目摘要引言</h2><h3 id="题目"><a href="#题目" class="headerlink" title="题目"></a>题目</h3><p>寻找一个易于理解的共识算法（拓展版本）</p><h3 id="摘要"><a href="#摘要" class="headerlink" title="摘要"></a>摘要</h3><p>Raft 是解决 log replication management 的分布式共识算法，相当于(multi-)Paxos 效果。为了便于理解，Raft 将共识算法的几个步骤分离开，包括<strong>leader 选举</strong>、<strong>log 复制</strong>、<strong>安全性</strong>。它强调了一致性以减少必须考虑的 states 数量（这个是不是对比 Paxos 说的）。Raft 还包括一个用 overlapping majorities（多数重叠）来改变集群成员的新机制。</p><h3 id="引言"><a href="#引言" class="headerlink" title="引言"></a>引言</h3><p>共识算法允许一组机器在个别成员出现故障时仍能作为一个相关联的群体持续工作。正因为如此，它们在构建可靠的大型软件系统中扮演着重要的角色。Paxos 主导了过去十年关于共识算法的讨论（算法研究、课程教学）。</p><ul><li>Paxos 太难理解了，而且为了支持实际系统，它的架构仍要做许多复杂的调整。</li><li>Raft 设计初衷就是<strong>可理解性</strong>：能被实际系统应用且比 Paxos 更易于学习。</li></ul><p>Raft 为增强<strong>可理解性</strong>，在以下方面做出努力：</p><ul><li>拆解过程：将<strong>leader 选举</strong>、<strong>log 复制</strong>、<strong>安全性</strong>拆分开。</li><li>减少状态空间数：与 Paxos 对比，Raft 降低了不确定性程度（这个不太理解，英文是 nondeterminism）和服务器间出现不一致的方式。</li></ul><p>Raft 新颖的特点：</p><ul><li><strong>Strong leader</strong>：与其他共识算法相比，Raft 有一个更“强势”的领导者。比如，log entries 只会从 leader 开始然后影响其他 servers（flow from the leader to other servers）。</li><li><strong>Leader election</strong>：Raft 使用随机计时器来启动选举过程，这仅需要在现有的 heartbeats（心跳线）机制上增加一点内容，就可以快捷又迅速地解决冲突。</li><li><strong>Membership changes</strong>：Raft 机制对于改变集群中机器配置使用一种新的方法<code>joint consensus</code>，该方法保证转换过程前后两配置下有一个重叠部分（保证一个 majority 的重叠），这样在配置转换过程中，系统仍可以正常工作。</li></ul><p>Raft 有多个开源版本的实现并被应用于实际系统中，教学上得到更好的反馈，其安全性能也得到详细说明和证明。</p><h2 id="基本理论概况"><a href="#基本理论概况" class="headerlink" title="基本理论概况"></a>基本理论概况</h2><h2 id="结论部分"><a href="#结论部分" class="headerlink" title="结论部分"></a>结论部分</h2><!-- 确定作者的成过以及点出的经验、问题、改进方 --><p>启发：在算法设计过程中，<strong>可理解性</strong>同正确性、效率和简洁性同样重要。其他几个性质在开发人员将算法应用于实际系统前都无法验证。而缺少可理解性，可能会使得开发人员在实现的过程中产生误解偏离设计者的原有意图（除非开发者对算法有非常深刻的理解并具备将其实现的直觉），这就导致实现很难保证期望的性质。</p><p>本问讨论了分布式共识算法的设计问题，提出一个新的算法——Raft，相比原来广为流传的 Paxos 来说，更易于理解，且相信能为系统构建提供更好的途径。在设计途中，我们发现自己不断重复使用一些技术，例如分解问题和简化状态空间。 这些技术不仅提高了 Raft 的可理解性，而且更加容易相信它的正确性。</p><h2 id="回答基本问题"><a href="#回答基本问题" class="headerlink" title="回答基本问题"></a>回答基本问题</h2><ol><li>类别</li></ol><!-- 这篇论文是什么类型？测试类？对现有系统进行分析的？对原型系统进行描述的？--><p>基于原有算法进行的新算法设计。</p><ol><li>内容</li></ol><!-- 你读过的其他论文有没有与之相关的？相关性与区别最直接体现在哪里？文章中分析问题用的什么理论基础（通过瞥一眼数学概况与核心证明可以得到）。 --><p>Reading Group 所提到的，结合 Erasure Code 的方案——CRaft。</p><p><a href="https://www.usenix.org/system/files/fast20-wang_zizhong.pdf" target="_blank" rel="noopener">CRaft 论文</a></p><p><a href="https://www.edwardzcn98yx.com/post/262d18ab.html">CRaft 阅读笔记</a></p><ol><li>正确性</li></ol><!-- 结论是否看起来真实有效？ --><p>正确</p><ol><li>创新点</li></ol><!-- 论文的主要创新点是什么？总结提到的经验、问题和改进方法是什么？ --><p>可理解性，可理解性。</p><ol><li>清晰度</li></ol><!-- 这篇论文是否写的条理清晰 --><p>清晰</p><h2 id="阅读选择"><a href="#阅读选择" class="headerlink" title="阅读选择"></a>阅读选择</h2><!--1. 继续阅读：论文有价值担保，研究领域非常切合，对当前进行工作有极大帮助，圈内爆火文章2. 不继续阅读：论文不吸引自己，论文价值/正确性存疑，论文作者给出了不适当的假设。3. 库存保留并标记：当前不处于自己的研究领域，但不久的日后相关论文会有用。--><p>继续阅读！</p><a id="more"></a><h1 id="Step-2"><a href="#Step-2" class="headerlink" title="Step 2"></a>Step 2</h1><h2 id="细读笔记"><a href="#细读笔记" class="headerlink" title="细读笔记"></a>细读笔记</h2><!-- 要仔细阅读论文，但是诸如证明等信息要忽略掉 --><h3 id="状态机复制"><a href="#状态机复制" class="headerlink" title="状态机复制"></a>状态机复制</h3><p>共识算法常出现在状态机复制（replicated state machine）上下文中。一组服务器上的状态机计算相同的粗笨，这样即使其中一些服务器宕机，仍能继续工作。状态机复制常用于解决分布式系统的容错问题。</p><p>状态机复制常用 replicated log 来实现。每个服务器存储一个包含一系列命令的日志，其状态机按顺序执行这些命令。每个日志以相同的顺序包含相同的命令，因此每个状态机处理相同的命令序列。由于状态机是确定的，所以每个状态机都计算相同的状态和相同的输出序列。</p><p>而保证 replicated log 一致就是共识算法的工作。共识模块负责将客户端命令加入日志，并与其他服务器的共识模块通信以保证日志最终以相同的顺序包含相同的请求（same requests in the same order）。当命令被正确地复制，服务器地状态机就会按照日志顺序执行并将结果返回给客户端。</p><p>实际系统应用地一致性算法通常有以下特征：</p><ul><li>保证 non-Byzantine 条件下的安全性（即只设计以应对 fail stop）</li><li>只要保证 majority（绝对多数）的机器是正常且可以通信的，系统就具备完备功能。</li><li>不依赖 timing 来保证一致性（<strong>这一点以前不清楚，作者解释，在最坏情况下，错误时钟和极端消息可能会导致可用性问题</strong>）。</li><li>通常情况下，当 majority 都回复了一次远程调用（RPC）时，命令就完成了，minority 的速度较慢的机器不会影响系统的整体性能。</li></ul><h3 id="Paxos-的优劣势"><a href="#Paxos-的优劣势" class="headerlink" title="Paxos 的优劣势"></a>Paxos 的优劣势</h3><p>Leslie Lamport 的 Paxos 协议是该领域近年被讨论最多的。文章中对 Paxos 评价是这样的。</p><blockquote><p>Paxos first defines a protocol capable of reachingagreement on a single decision, such as a single replicatedlog entry. We refer to this subset assingle-decree Paxos.Paxos then combines multiple instances of this protocol tofacilitate a series of decisions such as a log (multi-Paxos).Paxos ensures both safety and liveness, and it supportschanges in cluster membership. Its correctness has beenproven, and it is efficient in the normal case.<br>Paxos 首先定义了一种协议，该协议能够就单个决定达成共识，例如单个复制日志条目。 我们将这个子集称为单命令 Paxos，然后 Paxos 组合了该协议的多个实例以促进一系列决策，例如日志（multi-Paxos）.Paxos 确保安全性和活跃性，并支持集群成员身份的更改。 它的正确性已经被证明，并且在正常情况下是有效的</p><p>Unfortunately, Paxos has two significant drawbacks.The first drawback is that Paxos is exceptionally diffi-cult to understand. The full explanation [15] is notori-ously opaque; few people succeed in understanding it, andonly with great effort. As a result, there have been severalattempts to explain Paxos in simpler terms [16, 20, 21].These explanations focus on the single-decree subset, yetthey are still challenging. In an informal survey of atten-dees at NSDI 2012, we found few people who were com-fortable with Paxos, even among seasoned researchers.We struggled with Paxos ourselves; we were not able tounderstand the complete protocol until after reading sev-eral simplified explanations and designing our own alter-native protocol, a process that took almost a year.<br>不幸的是，Paxos 有两个明显的缺点。第一个缺点是 Paxos 非常难以理解。 完整的解释[15]非常模糊，只有很少的人能够成功地理解它。 结果，有几种尝试用较简单的术语来解释 Paxos [16，20，21]。这些解释集中在单法则子集上，但它们仍然具有挑战性。 在 NSDI 2012 上对与会者的非正式调查中，我们发现很少有人对 Paxos 感到满意，即使是经验丰富的研究人员也是如此。 在阅读了一些简化的说明并设计了我们自己的替代协议后，我们才了解完整的协议，这一过程耗时近一年。</p><p>We hypothesize that Paxos’ opaqueness derives fromits choice of the single-decree subset as its foundation.Single-decree Paxos is dense and subtle: it is divided intotwo stages that do not have simple intuitive explanationsand cannot be understood independently. Because of this,it is difficult to develop intuitions about why the single-decree protocol works. The composition rules for multi-Paxos add significant additional complexity and subtlety.We believe that the overall problem of reaching consensuson multiple decisions (i.e., a log instead of a single entry)can be decomposed in other ways that are more direct andobvious.<br>我们假设 Paxos 的不透明性源于它对单法则子集的选择的基础。单法则 Paxos 是密集而微妙的：它分为两个阶段，没有简单的直观解释，无法独立理解。 因此，难以理解单法令协议为何起作用的直觉。 多 Paxos 的组成规则增加了许多额外的复杂性和微妙之处。我们认为，可以通过其他更直接和明显的方式来分解在多个决策（即对数而不是单个条目）上达成共识的总体问题。</p><p>The second problem with Paxos is that it does not pro-vide a good foundation for building practical implemen-tations. One reason is that there is no widely agreed-upon algorithm for multi-Paxos. Lamport s descriptionsare mostly about single-decree Paxos; he sketched possi-ble approaches to multi-Paxos, but many details are miss-ing. There have been several attempts to flesh out and op-timize Paxos, such as [26], [39], and [13], but these differ2 from each other and from Lamport s sketches.Systems such as Chubby [4] have implemented Paxos-like algo-rithms, but in most cases their details have not been pub-lished.<br>Paxos 的第二个问题是，它没有为构建实际实现提供良好的基础。一个原因是，对于 multi-Paxos，还没有得到广泛认可的算法。Lamport 的描述大多是关于单一法令的 Paxos;他概述了多 paxos 可能的方法，但是很多细节都被遗漏了。已经有一些尝试来充实和调整 Paxos，如[26]、[39]和[13]，但它们彼此不同，也不同于 Lamport 的草图。像 Chubby[4]这样的系统已经实现了类似 paxos 的算法，但它们的很多细节还没有公开。</p></blockquote><p>single-decree decomposition 的另一个结果是 Paxos 难以用于构建实际系统。详细解释还是看文章吧。</p><p>因此，实际系统与 Paxos 几乎没有相似之处，都从 Paxos 开始，讲述实现的困难，然后发展出完全不同的体系结构。Chubby 的实现者对 Paxos 的评价很典型：</p><blockquote><p>There are significant gaps between the description ofthe Paxos algorithm and the needs of a real-worldsystem. . . . the final system will be based on an un-proven protocol</p></blockquote><h3 id="Designing-for-understandability"><a href="#Designing-for-understandability" class="headerlink" title="Designing for understandability"></a>Designing for understandability</h3><p>在 Raft 设计过程中存在许多要做取舍的点，取舍基于<strong>可理解性</strong>。设计者总是在想如何能使读者完全理解设计方法和实现。</p><p>这种“方便理解”的设计是主观的，不过提出了两种普遍使用的技术：过程拆解、简化状态机状态。</p><h3 id="The-Raft-consensus-algorithm"><a href="#The-Raft-consensus-algorithm" class="headerlink" title="The Raft consensus algorithm"></a>The Raft consensus algorithm</h3><p>算法主体部分。</p><p>图 2（也就是 6.824 课程教授提到的要特别注意的图）提供了简化版算法以供参考。</p><p><img src="https://eddyblog.oss-cn-shenzhen.aliyuncs.com/Raft/Raft_1.png" srcset="/img/loading.gif" alt="Raft_1"></p><p>图 3 列出了算法的核心性质。</p><p><img src="https://eddyblog.oss-cn-shenzhen.aliyuncs.com/Raft/Raft_2.png" srcset="/img/loading.gif" alt="Raft_2"></p><p>文章拆分成四个模块来介绍</p><p>Step 2 阅读中着重理解一下各部分的介绍，对 Safety 证明部分粗略浏览下，放在 Step 3 中进一步阅读。</p><h4 id="Raft-basics"><a href="#Raft-basics" class="headerlink" title="Raft basics"></a>Raft basics</h4><p>每个 server 的三种状态：<strong>leader</strong>，<strong>follower</strong>，<strong>candidate</strong>。系统保证正常情况下只有一个 Leader，在这个架构下。<strong>Leader is strong and followers are passive.</strong>。Leader 负责处理所有客户端请求并展开 replication，而 follower 不会自发启动任何请求，只会被动应答 candidate 和 leader。Candidate（候选者）是用来进行 leader 选举时的状态。如图 4 所示。</p><p><img src="https://eddyblog.oss-cn-shenzhen.aliyuncs.com/Raft/Raft_3.png" srcset="/img/loading.gif" alt="Raft_3"></p><p>Raft 将时间划分为不同长短的 term（任期），用连续整数来标识，每届任期都从一次选举开始。若选票分裂，没有选出 leader，则任期以无 leader 情况结束，并且会在稍后启动新的一轮选举（random time）。如图 5 所示。</p><p><img src="https://eddyblog.oss-cn-shenzhen.aliyuncs.com/Raft/Raft_4.png" srcset="/img/loading.gif" alt="Raft_4"></p><p>在一些情况下（比如网络中断、延迟、隔离），server 可能会观察不到选举过程甚至整个任期。Term 在 Raft 中像一个<a href="https://www.edwardzcn98yx.com/post/b6a38e07.html">逻辑时钟</a>（没错，Lamport 他又来了）。<code>currentTerm</code>在每台机器上都会被持久化维护。服务器间的交流（比如选举信息或是指令执行），类似 Lamport 逻辑时钟的事件（自增原则要看后面的实现细节）。如果一个服务器的 currentterm 比另一个服务器的 currentterm 小，那么它将其 currentterm 更新为更大的值。如果一个候选人或领导发现他的任期已经过期，它立即恢复到 follower 状态。如果服务器收到一个过去任期的请求，它将拒绝该请求。</p><p>Raft 机器间交流通过 RPC 实现，仅需要两种类型的 RPC，后续章节添加了一种 RPC 用来传递快照。</p><ul><li>RequestVote PRCs：由 candidates 发起用于选举（在 Leader election 一节中着重介绍）。</li><li>AppendEntries RPCs：由 leaders 发起，以 heartbeat 形式提供 replicate log 的功能。</li></ul><h4 id="Leader-election"><a href="#Leader-election" class="headerlink" title="Leader election"></a>Leader election</h4><p>主体过程描述如下</p><ul><li>以 follower 身份启动，如果能持续收到来自 candidate 和 leader 的消息，follower 身份会维持。</li><li>在丢失通信达到一定时间（election timeout）后，follower 会开始启动一次选举。</li><li>follower 增加它的 currentTerm 值并转换到 candidate 状态。</li><li>为自己投票同时并行启动 RequestVote RPCs 访问集群内其他机器。</li><li>candidate 维持其身份直至<ul><li>赢得选举<ul><li>得到 majority 的选票</li><li>转换为 leader 身份并开始发送心跳线信息</li></ul></li><li>其他机器赢得选举<ul><li>比较 AppendEntries RPC 中 term 与 currentTerm 的大小，RPC 中任期大于等于自身任期，则转变为 follower。</li><li>否则拒绝 RPC 请求，保持 candidate 身份。</li></ul></li><li>一段时间后发现没有人赢得选举<ul><li>多个 candidate 发起选举导致选票分裂无人当选</li><li>每个 candidate 经过一小段时间后重启选举</li><li>没有其他措施保证时，选票分裂可能重复。（改进：再下次选举前加入 150-300ms 的随机延时）</li><li>从<strong>可理解性</strong>角度抉择：设计者对算法进行了多次调整、包括 rank candidate 形式，每次调整后都会出现新的情况。最后得到的结论，随机重试的方法更明显和可理解。</li></ul></li></ul></li></ul><h4 id="Log-replication"><a href="#Log-replication" class="headerlink" title="Log replication"></a>Log replication</h4><p>图 6 显示日志的组织情况。</p><p><img src="https://eddyblog.oss-cn-shenzhen.aliyuncs.com/Raft/Raft_5.png" srcset="/img/loading.gif" alt="Raft_5"></p><ul><li>选出 leader 后，leader 与客户端进行通信，接受并反馈客户端请求。</li><li>leader 持续向其他机器并行发送 AppendEntries RPCs，维持身份同时拷贝 entry（但不执行）。</li><li>leader 决定什么时间可以<strong>commited</strong> entry（提交），即使集群机器可以执行 entry。<ul><li>条件：当 leader 创建的 entry 被 replicated 到绝对多数的机器。</li></ul></li><li>leader 持续跟踪要进行 commit（已经建立好）的最大的 log index，并将该索引包含在后续的 AppendEntries RPCs 中，以便其他机器最终发现。</li><li>follower 获知 entry 被 commited，便在本地执行该日志。</li></ul><p>Raft 保持下面的重要性质，他们共同构成图 3 的（Log Matching）：</p><ul><li>两份日志中的 entry 块，<strong>若具有相同的 log index 和 term，则储存相同命令</strong>。</li><li>两份日志中的 entry 块，<strong>若具有相同的 log index 和 term，则在之前的日志记录都是相同的</strong>。</li></ul><p>正常情况下，leader 和 follower 间的日志都是一致的，但是如果发生 crash，会出现各种不一致的情况（多出未 commit 的 entry 块、缺少块、历史块产生冲突）。</p><p>在 Raft 中，leader 强迫 follower 遵循自己的日志记录，也即冲突覆盖。 后面 Safty 小节将说明，再加上一个限制条件，这是安全的。</p><p>为了进行覆盖，leader 需要找到和 follower 达成一致的最近 entry，并删除之后所有的 entries。leader 未每个 follower 维护一个<code>nextIndex</code>，标明下一个该传送的 log entry。当一个 leader 刚被选举上台时，他初始化全部 follower 的<code>nextIndex</code>为 leader 最后一个 log+1。如果 follower 与 leader 的日志不一致，AppendEntries RPC 中的一致性检查失败，然后 leader 递减<code>nextIndex</code>的值再次发送 AppendEntries RPC 请求，直至找到能 match 的日志位置。然后如上述，删除后递增<code>nextIndex</code>持续进行请求。</p><p>优化 AppendEntries 交互的方法</p><blockquote><p>当 AppendEntries 失败时，follower 可以知道冲突块所在的 term，以及该 term 第一个块。这样<code>nextIndex</code>一次可以减去该 term 冲突块的数。（作者质疑这种优化的必要性，理由是 failure 并非那么频繁，不会出现大量需要小步修正的 entries）</p></blockquote><p>这种 log replication 机制，对于新选出的 leader，无需额外操作既可以保证集群中日志记录逐渐收敛，并且满足 leader 不重写自己日志的性质。同时只要绝对多数的机器正常运转，一轮 RPCs 就可以将新的 entry 复制到机器上，少数故障不会影响系统表现。</p><h4 id="Safety"><a href="#Safety" class="headerlink" title="Safety"></a>Safety</h4><p>到目前为止所描述的机制还不足以确保每个状态机以同样的顺序执行完全相同的命令，增加一些限制。</p><ul><li><p>选举限制</p><p>个人理解：鸽巢定理的应用</p><p>Raft 使用一个简单的机制保证先前任期 leader 的所有 commited entries 会存在在新选举的 leader 上。这样就保证了日志流是单向的（leader 到 followers）。</p><p>一个 entry 想要被 commited 要得到<strong>majority</strong>的机器的回应，而一个 candidate 必须联系集群中的<strong>majority</strong>才能当选，根据<strong>鸽巢定理</strong>，每条 commited entry 必须至少出现在 candidate 联系的机器中的一台上，如下图所示。</p><p><img src="https://eddyblog.oss-cn-shenzhen.aliyuncs.com/Raft/Raft_6.png" srcset="/img/loading.gif" alt="Raft_6"></p><p>Raft 按如下方式定义日志的新旧：</p><ul><li>不同 term，则越后面的 term 越新（逻辑时钟）</li><li>相同 term，越长的 log 越新</li></ul></li><li><p>提交先前任期的 entry</p><p>对于前一任期 replicate 但是未 commit 的 entry，现在任期的新 leader 在继续 replicate 时无法第一时间意识到达到绝对多数（从而有可能延迟或者忽略到该 commit 的 entry，而被后续任期的 entry 覆盖），如下图所示。</p><p><img src="https://eddyblog.oss-cn-shenzhen.aliyuncs.com/Raft/Raft_7.png" srcset="/img/loading.gif" alt="Raft_7"></p><p>Raft 要求 leader 在 replicate 先前任期中的 entry 时，保留其原有的 term（在其他一些共识算法中，leader 必须使用新的 term 编号来进行复制。）为了避免图中的问题，Raft<strong>不会</strong>根据副本计数来提交过去任期的 entry，<strong>只会</strong>根据计数提交当前任期内的 entry。（交现在不交过去）</p></li><li><p>安全性争论</p><p>反证法证明 Leader Completeness Property</p><p>过程 Pass，见第三部分。</p><p>根据 Leader Completeness Property，可以证明 State Machine Property。</p><p>证明 Pass，见第三部分。</p></li></ul><h4 id="Follower-and-candidate-crashes"><a href="#Follower-and-candidate-crashes" class="headerlink" title="Follower and candidate crashes"></a>Follower and candidate crashes</h4><p>先前讨论的是 leader 出状况，实际上 follower 和 candidate 的崩溃情况要简单些。</p><ul><li>follower 或 candidate 崩溃，leader 持续发送 AppendEntries RPCs</li><li>重连时 RPC 会连通</li><li>若 follower 或 candidate 接受到 RPC 但是在返回结果前崩溃，那么重连时会收到相同的 RPC，因为 Raft RPC 是幂等的，所以无影响。</li></ul><h4 id="Timing-and-availablility"><a href="#Timing-and-availablility" class="headerlink" title="Timing and availablility"></a>Timing and availablility</h4><p>Raft 设计要求，系统安全性不依赖于时间，不会因事件过快/过慢导致错误结果。但还是有些地方肯定存在时间限制。</p><p>Leader election 过程时间要求。</p><script type="math/tex; mode=display">broadcastTime \ll electionTimeout \ll MTBF</script><ul><li><strong>broadcastTime</strong>：并行发送 RPCs 到各个机器并收到回复的平均时间。</li><li><strong>electionTimeout</strong>：前面描述的判定一轮选举的 timeout</li><li><strong>MTBF</strong>：单个机器故障间隙的平均时间。</li></ul><p>分析，Pass，详情见第三节。大致理解，不能太频繁重设 leader，但又要保证真正故障时系统不会长时间停滞。</p><h2 id="问题记录"><a href="#问题记录" class="headerlink" title="问题记录"></a>问题记录</h2><h2 id="未读（且值得读）文献记录"><a href="#未读（且值得读）文献记录" class="headerlink" title="未读（且值得读）文献记录"></a>未读（且值得读）文献记录</h2><!-- 在第二步中，找到以上几篇论文中相同的引用文献、在引用文献中重复的作者名，这些就是你所调研领域的重点论文和科研人员，下载那些重点论文暂时搁到一边。继续访问那些重要科研人员的网页，看下那些论文是在什么会议集结出版的。这能帮你找到那个领域的顶级会议，因为那些重要科研人员通常会在顶级会议发表论文。 --><p><a href="http://research.microsoft.com/users/lamport/pubs/pubs.html#lamport-paxos" target="_blank" rel="noopener">Lamport 发明 Paxos 的前前后后</a></p><p><a href="http://research.microsoft.com/users/lamport/pubs/lamport-paxos.pdf" target="_blank" rel="noopener">The Part-Time Parliament ── Lamport 于 1998 年发表在 ACM Transactions on Computer Systems</a> 注：这是该算法第一次公开发表。</p><p><a href="http://www.cs.utexas.edu/users/lorenzo/corsi/cs380d/past/03F/notes/paxos-simple.pdf" target="_blank" rel="noopener">Paxos made simple</a> 注：Lamport 觉得同行无法接受他的幽默感，于是用容易接受的方法重新表述了一遍。</p><p><a href="https://research.google/pubs/pub39966/" target="_blank" rel="noopener">Google Spanner</a></p><h1 id="Step-3"><a href="#Step-3" class="headerlink" title="Step 3"></a>Step 3</h1><!-- 试着“在脑中重新实现（virtually re-implement）”那篇论文：也就是，和作者一样做出相同的假设，然后重新实现相同的工作。通过对比你自己得出的和论文中给出的结果，不仅可以很轻易验证一篇论文的创新点是否真实，而且还能发现论文中不会讲的缺点和假想。 --><h2 id="思路复现"><a href="#思路复现" class="headerlink" title="思路复现"></a>思路复现</h2><!-- 推敲作者是如何立题，如何找到突破口，在其中是否有抉择，如何做出的假设？ --><h2 id="证明与推理复现"><a href="#证明与推理复现" class="headerlink" title="证明与推理复现"></a>证明与推理复现</h2><!-- 分析证明过程，确定证明的正确性以及完整性。对证明过程做拓展，调研证明思路来源 --><h2 id="实验验证复现"><a href="#实验验证复现" class="headerlink" title="实验验证复现"></a>实验验证复现</h2><!-- Rework -->]]></content>
    
    
    <categories>
      
      <category>Computer Science</category>
      
      <category>分布式系统</category>
      
    </categories>
    
    
    <tags>
      
      <tag>Paper</tag>
      
      <tag>三步法</tag>
      
      <tag>分布式系统</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>多媒体原理与系统——期末复习知识点汇总</title>
    <link href="/post/c66fbeaf.html"/>
    <url>/post/c66fbeaf.html</url>
    
    <content type="html"><![CDATA[<h1 id="绪论"><a href="#绪论" class="headerlink" title="绪论"></a>绪论</h1><h2 id="前言研究方向"><a href="#前言研究方向" class="headerlink" title="前言研究方向"></a>前言研究方向</h2><ul><li>图象语义分析</li><li>语音识别和合成</li><li>多摄像机视频协同系统</li><li>图象视频合成</li><li>对象视频和成</li><li>对象检测跟踪</li><li>图象视频检索</li><li>新型音视频编解码技术</li><li>沉浸式显示关键技术（VR 虚拟空间、AR 真实与虚拟互动）</li><li>多媒体内容和传输安全</li></ul><h1 id="数字音频基础"><a href="#数字音频基础" class="headerlink" title="数字音频基础"></a>数字音频基础</h1><p>主要，参考手写笔记章节这里先不细致复习。</p><h2 id="将模拟音频转换成数字音频"><a href="#将模拟音频转换成数字音频" class="headerlink" title="将模拟音频转换成数字音频"></a>将模拟音频转换成数字音频</h2><p>留意 PCM，DM，ADPCM，自适应差分脉冲编码调制 ADPCM 的步骤。</p><a id="more"></a><h2 id="音频格式文件"><a href="#音频格式文件" class="headerlink" title="音频格式文件"></a>音频格式文件</h2><p>CD-Audio、WAVE、MPEG Audio 家族、MIDI（描述一系列指令而非音乐本出身）、WMA</p><h2 id="音频压缩的原理"><a href="#音频压缩的原理" class="headerlink" title="音频压缩的原理"></a>音频压缩的原理</h2><h1 id="编程环境与平台"><a href="#编程环境与平台" class="headerlink" title="编程环境与平台"></a>编程环境与平台</h1><h2 id="COM-组件与应用"><a href="#COM-组件与应用" class="headerlink" title="COM 组件与应用"></a>COM 组件与应用</h2><ul><li><p>组件：组件(或软件组件)是指构建软件系统的基础性单元或模块，它封装了特定的设计策略，通过标准化、可重用和开放的接口与其它组件进行组合，以便构建完整的应用系统。</p><ul><li>可扩展性：可以方便的将应用系统扩展到网络环境下</li><li>跨平台性：与语言和平台无关的特性使所有的程序员均可充分发挥自己的才智和专长编写组件模块。</li></ul></li><li><p>COM 组件对象和接口</p></li></ul><h2 id="多媒体应用设计的主要特点"><a href="#多媒体应用设计的主要特点" class="headerlink" title="多媒体应用设计的主要特点"></a>多媒体应用设计的主要特点</h2><ul><li>流数据，数据量大，存储和传输的高效性<ul><li>音频流</li><li>视频流</li></ul></li><li>实时性：视频跟踪；不能做迟来大师</li><li>同步性<ul><li>视频与音频的同步</li><li>字幕与图象的同步</li></ul></li><li>自适应性和鲁棒性<ul><li>数据格式复杂</li><li>应用环境复杂（终端设备型号多、失效情况等）</li></ul></li></ul><h2 id="Microsoft-Media-Foundation"><a href="#Microsoft-Media-Foundation" class="headerlink" title="Microsoft Media Foundation"></a>Microsoft Media Foundation</h2><p>MF 介绍相关</p><p>基本组成元素概念和用途、MF 的编程模式、数据管道模式</p><h1 id="波形文件分析"><a href="#波形文件分析" class="headerlink" title="波形文件分析"></a>波形文件分析</h1><h2 id="波形音频文件的概念"><a href="#波形音频文件的概念" class="headerlink" title="波形音频文件的概念"></a>波形音频文件的概念</h2><p>波形音频文件是存储数字音频样本(samples)序列的格式文件，这些样本直接记录了音频的波形，故称波形音频文件。波形音频文件为音频数据处理提供了最基本的数据源。MIDI 音频和 MP3 等各类压缩格式的音频文件最终都要转换成波形音频才能应用。</p><h2 id="WAVE-文件结构"><a href="#WAVE-文件结构" class="headerlink" title="WAVE 文件结构"></a>WAVE 文件结构</h2><p>WAVE 文件是使用最广泛的声波音频文件，它遵从 RIFF(ResourceInterchangeFileFormat)格式标准。WAVE 文件的头四个字节是“RIFF”。WAVE 文件由若干个块(Chunk)组成。按照在文件中出现的先后顺序，一般有四个块，即 RIFF WAVE Chunk，Format Chunk，Fact Chunk(可选)，Data Chunk。</p><p>详细文件结构参见 PPT，需要注意的是，RIFF WAVE Chunk 中的 Size 是 FileLeb-8。Data Chunk 中的 Size 是真正数据部分的 Size。</p><h1 id="无损数据（编码）压缩算法"><a href="#无损数据（编码）压缩算法" class="headerlink" title="无损数据（编码）压缩算法"></a>无损数据（编码）压缩算法</h1><p>这部分有手写笔记</p><h2 id="数据（编码）压缩基础"><a href="#数据（编码）压缩基础" class="headerlink" title="数据（编码）压缩基础"></a>数据（编码）压缩基础</h2><ul><li>编码：将携带信息的一种符号序列按照一定规则映射成另一种符号序列的变换。根据信源的统计特性进行。</li><li>目的：去冗余，压缩信源剩余度，提高传输消息的有效性，把消息变成适合信道传输的信号。</li><li>分类：有损编码、无损编码</li><li>数学模型：见 PPT</li></ul><h2 id="熵编码讲解"><a href="#熵编码讲解" class="headerlink" title="熵编码讲解"></a>熵编码讲解</h2><h2 id="算术编码讲解"><a href="#算术编码讲解" class="headerlink" title="算术编码讲解"></a>算术编码讲解</h2><h2 id="行程编码讲解"><a href="#行程编码讲解" class="headerlink" title="行程编码讲解"></a>行程编码讲解</h2><h1 id="数字图象基础"><a href="#数字图象基础" class="headerlink" title="数字图象基础"></a>数字图象基础</h1><h2 id="数字图像基本概念"><a href="#数字图像基本概念" class="headerlink" title="数字图像基本概念"></a>数字图像基本概念</h2><ul><li><p>图像</p><p>时空中各个坐标点的颜色值（强度）集合。</p><ul><li>3 维动态图像 $I= f(x,y,z,t)$</li><li>3 维度静止图像 $I = f(x,y,z)$</li><li>2 维动态图像$I = f(x,y,t)$</li><li>2 维静止图像 $I = f(x,y)$</li></ul></li><li><p>数字图像</p><p>如何从图像到数字图像？</p></li><li><p>从图像到数字图像</p><ul><li>采样（扫描），行采样+列采样<ul><li>图像分辨率（resolution）：正式用法：单位面积或长度上像素的个数。习惯用法：图像在水平和垂直方向上的像素数的乘积。</li><li>上采样（提高分辨率，放大图像，从而可以显示在更高分辨率的显示设备上。）</li><li>下采样（缩小图像大小）。</li></ul></li><li>量化：像素的位深度，量化等级越多，图像层次越丰富，图像质量好，但数据量大；量化等级越少。</li></ul></li><li><p>颜色</p></li><li><p>亮度</p><p>指色光的明暗程度，由色光所含的能量决定。光源色光的亮度正比于它的光通量(光功率)；物体色光的亮度正比于各点反射光的光通量，<strong>由光源亮度和物体光反射能力共同决定</strong>。</p></li><li><p>色调</p><p>指颜色的类别，如通常所说的红色、绿色、蓝色、品红、青色等色调。光源的色调由其光谱分布（光频率）决定；物体的色调由<strong>照射光源的光谱和物体本身反射特性共同决定</strong>。（例如蓝布在日光照射下，只反射蓝光而吸收其它成分。如果分别在红光，黄光或绿光的照射下，它会呈现黑色。）</p></li><li><p>饱和度</p><p>指色调的深浅程度。各种单色光饱和度最高。单色光中掺入的白光愈多，饱和度愈低，白光占绝大部分时，饱和度接近于零，白光的饱和度等于零。物体色调的饱和度决定于该物体表面反射光谱辐射的选择性程度，物体对光谱某一较窄波段（颜色）的反射率越高，而对其它波长的反射率越低或不反射，则物体的该颜色饱和度就越高。</p></li></ul><h2 id="色彩模型"><a href="#色彩模型" class="headerlink" title="色彩模型"></a>色彩模型</h2><ul><li><p>RGB 模型</p><p>用红、绿、蓝三种基本颜色表示其他颜色的模型。红、绿、蓝原色是<strong>加性</strong>原色，不同量原色混合在一起可以产生不同的复合颜色。</p></li><li><p>RGBA 模型</p><p>在 RGB 的扩展；增加一个 Alpha 通道，表示透明度。如果一个颜色值的 Alpha 通道值为 0，则该颜色是完全透明的(该颜色看不见)；Alpha 通道值为 1，则该颜色完全不透明(只看到该颜色)，这个时候 RGBA 退化为 RGB。</p></li><li><p>CMY 空间和 CMYK 模型</p><ul><li>是用物质吸收光的数量（反射）表示色彩的方式，即通过青(C)、品红(M)、黄(Y)三原色颜料混合表示颜色，称为 CMY 颜色空间。理论上 CMY 空间中，混合青(C)、品(M)、黄(Y)三原色时理论上会得到黑色；实际应用由于工艺问题是暗红色，所以额外引入纯黑<strong>(K，不是 B!)</strong>，得到 CMYK 模型，应用于实际的印刷工业。</li><li>对比 RGB 模型：RGB 中，当红、绿、蓝三原色混合时，产生白色，这种叫加色模型。青、品、黄混合时，产生黑色，这种叫减色模型。</li><li><strong>一般电脑屏（光源）RGB 模型；印刷品（反射源）CMYK 模型</strong></li></ul></li></ul><h2 id="像素色彩格式"><a href="#像素色彩格式" class="headerlink" title="像素色彩格式"></a>像素色彩格式</h2><ul><li>二值图像与灰度图像</li><li>彩色图像</li><li>真彩图像</li><li>伪彩图像</li></ul><h2 id="数字图象存储方式"><a href="#数字图象存储方式" class="headerlink" title="数字图象存储方式"></a>数字图象存储方式</h2><ul><li>真彩图像像素的存储格式<ul><li>RGB888 BGR（低地址-&gt;高地址）</li><li>RGB8888 BGRX（X 为保留或表示透明度，低地址-&gt;高地址）</li></ul></li></ul><h2 id="BMP-图像格式"><a href="#BMP-图像格式" class="headerlink" title="BMP 图像格式"></a>BMP 图像格式</h2><h2 id="GIF-图像格式"><a href="#GIF-图像格式" class="headerlink" title="GIF 图像格式"></a>GIF 图像格式</h2><h2 id="JPEG-图像压缩技术"><a href="#JPEG-图像压缩技术" class="headerlink" title="JPEG 图像压缩技术"></a>JPEG 图像压缩技术</h2><ul><li><p>基于正交余弦变换（FDCT）的有损压缩模型</p><p><img src="https://eddyblog.oss-cn-shenzhen.aliyuncs.com/MultiMedia/JPEG_1.png" srcset="/img/loading.gif" alt="JPEG_1"></p><p>DCT 也是空间域到频率域的转换，左上角低频，右下角高频，实现能量的集中。</p><script type="math/tex; mode=display">F(u,v) = \frac{1}{4}C(u)C(v)[ \sum_{i=0}^{7}\sum_{j=0}^{7}f(i,j) \cos \frac{(2i+1)u\pi}{16} \cos \frac{(2j+1)v\pi}{16}]</script><p>从这个式子我们容易发现，当$u=v=0$时，$C(u),C(v) = \frac{1}{\sqrt{2}}$，得到的$F(0,0)$实际为原空间域均值乘以边长（这里是 8），老师补充，$F(0,0)$与空间边长乘正比（比如 4x4，得到的应该是均值的 4 倍）。</p></li><li><p><strong>DCT 的作用</strong>：DCT 的作用： DCT 变换将空域图像(即由颜色像素值构成的平面空间)转换到频域表示的图像，从而<strong>把能量集中在低频系数上</strong>。DC 值和像素块均值成正比</p></li><li><p><strong>量化</strong>：通过除法和舍入操作，丢弃一些高频信息。</p><script type="math/tex; mode=display">F'(u,v) = Integer(Round ( F(u,v) /Q(u,v)))</script><p>老师谈：设置量化步长时，低频的 DC 系数一般不丢，优先丢表示细节的高频分量，所以见右侧。</p><p>量化表：亮度量化表和色差量化表，即描述$Q(u,v)$（色差右下角好多 99，亮度相对于来说分散一些，这两个表是经验表）。</p><p>量化即 JPEG 压缩过程中，有损的部分。</p></li><li><p><strong>直流系数的编码</strong>：采用差分编码；数据块之间去冗余，<strong>相邻数据块相似</strong>，<strong>像素均值差值不大</strong>，<strong>DC 值差值不大</strong>。（DC 用差分）</p></li><li><p><strong>交流系数的编码</strong>：基于 Z 字形扫描的行程编码，扫描从右下一条龙到左上。（AC 用行程编码）</p></li><li>最后，对前面生成的数据流进行无损压缩编码（哈夫曼或算术编码）。</li></ul><h1 id="图像处理与应用程序设计"><a href="#图像处理与应用程序设计" class="headerlink" title="图像处理与应用程序设计"></a>图像处理与应用程序设计</h1><p>主要目标：</p><ul><li>认识与图像显示和处理有关的 API</li><li>掌握基于 win32 GDI 的图像显示方法</li><li>掌握基于 win32 GDI 的图像数据访问方法</li><li>能够实现简单的图像处理功能</li><li>能够实现滤波</li><li>能够动画效果</li><li>能够在 win32 api 中调用第三方图像处理库</li></ul><h2 id="与图像显示和处理有关的-API"><a href="#与图像显示和处理有关的-API" class="headerlink" title="与图像显示和处理有关的 API"></a>与图像显示和处理有关的 API</h2><p>应用程序域 Win32 API 中间层：GDI、Direct2D… OpenCV、Dlib</p><p>OpenCV 和 Dlib 是跨平台的图像处理函数库</p><h2 id="基于-win32-GDI-的图像显示方法"><a href="#基于-win32-GDI-的图像显示方法" class="headerlink" title="基于 win32 GDI 的图像显示方法"></a>基于 win32 GDI 的图像显示方法</h2><p>教材中的方法</p><ul><li>用 LoadImage 函数载入图像（只能读取 bmp，ico 等格式，常用的 jpeg 不支持）</li><li>用 GetObject 函数获得图像的基本信息（如长宽、位深等）</li><li>用 GlobalAlloc 和 GlobalLock 函数创建一个缓存用来保存图像数据</li><li>用 GetDIBits 函数把图像数据保存到刚才创建的缓存里</li><li>用 SetDIBitsToDevice 函数显示缓存中的图像</li></ul><p>另一个方法（实验代码中使用）</p><ul><li>用 LoadImage 函数载入图像</li><li>用 GetObject 函数获得图像的基本信息（如长款、位深等）</li><li><strong>用 CreateCompatibleDC 和 SelectBitmap 函数创建一个内存绘图句柄并跟新图像绑定</strong></li><li>使用 BitBlt 函数显示内存绘图句柄所关联的图像</li></ul><h2 id="基于-win32-GDI-的图像数据访问方法"><a href="#基于-win32-GDI-的图像数据访问方法" class="headerlink" title="基于 win32 GDI 的图像数据访问方法"></a>基于 win32 GDI 的图像数据访问方法</h2><p>教材中的方法</p><ul><li>方法 1：用 GetPixel 和 SetPixel 函数来对绘图句柄所关联的图像进行访问，可以直接访问单个像素的值。</li><li>方法 1 的优点是直观，缺点是慢。</li></ul><p>补充学习：GetPixel 和 SetPixel 非常慢，老师猜测是由于 GetPixel 和 SetPixel 中设计很多转换（早期索引色彩等）。速度 30s 与实验代码中（1s 不到）差别巨大。</p><p>另一方法 2</p><ul><li>方法 2：用 GlobalLock 函数所返回的缓存区指针来直接访问像素值。</li><li>方法 2 的优点是快，缺点是不够直观。</li></ul><p>方法 3（实验代码中使用）</p><ul><li>通过 CopyImage 函数结合 LR_CREATEDIBSECTION 参数，获得包含了数据指针新图像</li><li>通过 GetObject 函数获得新图像的基本信息结构体（除长宽、位深等信息外，还包含可用的数据指针）</li><li>通过基本信息结构体中的数据指针来访问像素值</li></ul><h2 id="实现简单的图像处理功能"><a href="#实现简单的图像处理功能" class="headerlink" title="实现简单的图像处理功能"></a>实现简单的图像处理功能</h2><p>Pass</p><h1 id="数字视频基础"><a href="#数字视频基础" class="headerlink" title="数字视频基础"></a>数字视频基础</h1><h2 id="视频概述"><a href="#视频概述" class="headerlink" title="视频概述"></a>视频概述</h2><p>一些基本概念</p><ul><li>视频（Video）是指随时间动态变化的一组图像。一幅图像在视频中称为一帧，帧是构成动态图像的基本单元。</li><li>帧：是指组成影片的每一幅静态画面。通常我们看到的电视、电影或其他视频节目，其实是由一系列的静态图像画面构成的，相邻图像的画面之间差别很小，将这些连续的画面高速播放，由于人眼视觉的暂留特性，所以感觉图像是动态的且运动流畅，这些连续图像的每一幅就被称之为一帧。</li><li>帧高宽比：是指影片画面图像的高度和宽度比例。常见的电视格式为标准（标清）的 4:3 或 1.33 和宽屏（高清）的 16:9 或 1.78。</li><li>帧频：是指播放视频时每秒钟所播放的画面数量。电影是每秒 24 帧，PAL 制式的影片是每秒 25 帧，NTSC 制式是每秒 29.97 帧。</li><li>扫描方式：分逐行扫描或隔行扫描。若采用隔行扫描，则先扫描奇数行，再扫描偶数行，因此每幅图像需扫描两次才能完成。</li><li>场：电视机因受信号宽带限制，以隔行扫描的方式显示图像，通过两次扫描来交错显示奇数行和偶数行，每扫描一次叫做一“场”，两个场合并成一帧。</li><li>场频：每秒扫描的场数。<strong>在进行隔行扫描时，场频是帧频的两倍</strong>。</li></ul><h2 id="模拟视频（电视）"><a href="#模拟视频（电视）" class="headerlink" title="模拟视频（电视）"></a>模拟视频（电视）</h2><p>注意消隐信号。</p><p><img src="https://eddyblog.oss-cn-shenzhen.aliyuncs.com/MultiMedia/TV_Systems_1.png" srcset="/img/loading.gif" alt="TV_System"></p><ul><li><p>电视的彩色模型：YUV 模型、YIQ 模型、YCbCr 模型</p><p>YIQ 模型与 YUV 模型类似，YIQ 颜色空间中的 I 和 Q 分量相当于将 YUV 空间中的 UV 分量做了一个 33 度的旋转。</p></li><li><p>复合电视信号（Composite signal）</p><ul><li>RGB/YUV/YIQ 的所有分量一起被编码成一个信号。</li><li>行周期：64us</li><li>信号：52.2us</li><li>行消隐：11.8us ；前肩 1.3us；行同步 4.7us；后肩 5.8us；<strong>彩色和黑白电视的主要区别</strong></li></ul></li><li>分量电视信号（Seperated signal）<ul><li>RGB/YUV/YIQ 的每一个分量分别被编码成一个信号。</li></ul></li><li>S-Video 信号<ul><li>亮度信息被编码成一个信号，两个色差编码成一个复合信号。</li></ul></li><li><strong>为什么电视系统要采用 YUV（YIQ）彩色模型</strong><ul><li><strong>彩色电视信号能兼容黑白电视</strong></li><li><strong>有利于区分编码 Y 信号与 UV 信号</strong></li></ul></li></ul><h2 id="模拟视频的数字化"><a href="#模拟视频的数字化" class="headerlink" title="模拟视频的数字化"></a>模拟视频的数字化</h2><p>复合信号-信号分离-A/D 转换器-数字视频信号</p><h2 id="数字视频的存储格式"><a href="#数字视频的存储格式" class="headerlink" title="数字视频的存储格式"></a>数字视频的存储格式</h2><h1 id="视频应用程序设计"><a href="#视频应用程序设计" class="headerlink" title="视频应用程序设计"></a>视频应用程序设计</h1><p>未加入章节标题</p><h1 id="数字视频编码原理与标准"><a href="#数字视频编码原理与标准" class="headerlink" title="数字视频编码原理与标准"></a>数字视频编码原理与标准</h1><h2 id="数字视频编码的基本原理"><a href="#数字视频编码的基本原理" class="headerlink" title="数字视频编码的基本原理"></a>数字视频编码的基本原理</h2><ul><li>数字视频的<strong>冗余性</strong>：<ul><li>空间冗余（帧内冗余）：一帧视频内部，相邻像素的颜色值近似，这成为帧内冗余。</li><li>时间冗余（帧间冗余）：相邻帧的内容大部分相同。</li><li>统计冗余：如 1,0,0,0,0,0…</li><li>感知冗余：依赖人眼视觉的敏感程度。不敏感的就可以认为是感知冗余</li></ul></li><li>数字视频编码类型<ul><li>帧内编码：利用图像内部的相关性进行压缩，空间冗余压缩。</li><li>帧间编码：利用相邻图像帧之间的相关性进行压缩，时间冗余压缩。</li></ul></li><li>数字视频编码的<strong>基本思想</strong>：<ul><li>空间冗余压缩：主要在帧内编码中理解；</li><li>时间冗余压缩：主要在帧间编码中理解；</li><li>统计冗余压缩：熵编码；</li><li>感知冗余：量化步长体现</li></ul></li><li><p>视频帧的分类</p><ul><li>I 帧：（关键帧？）是利用图像内部的相关性进行压缩的图像帧，即帧内编码图像，数目少</li><li>P 帧：是指对其施加单向预测编码的图像，数目多</li><li>B 帧：是指对其施加双向预测编码的图像，数目多</li></ul><p><img src="https://eddyblog.oss-cn-shenzhen.aliyuncs.com/MultiMedia/VideoEncode_1.png" srcset="/img/loading.gif" alt="VideoEncode_1"></p></li><li><p>视频编码的核心思想：<strong>预测</strong>+<strong>残差</strong></p><ul><li>对于相关的视频图像，发送端不需要把每帧图像上所有的像素值都传送给接收端：</li><li>图像内：记录基准像素（预测像素）和像素残差；根据变化内容和预测像素可以还原当前像素。</li><li>图像间：不同图像帧的残差，和前一帧图像（预测图像）的内容来恢复当前帧图像，</li><li>这就比全部传送每帧图像的具体细节所需的数据量要小得多。WHY?（个人理解：补丁和原像关系一样，储存残差要比储存原始图像，表示所需空间少，存储空间少）</li></ul></li></ul><h2 id="帧内编码"><a href="#帧内编码" class="headerlink" title="帧内编码"></a>帧内编码</h2><p>帧内编码（无预测）</p><p>类似 HPEG 图像压缩，图像分块：4*4；8*8; 16*16 （宏块）</p><p><img src="https://eddyblog.oss-cn-shenzhen.aliyuncs.com/MultiMedia/VideoEncode_2.png" srcset="/img/loading.gif" alt="VideoEncode_2"></p><p>帧内编码（有预测）</p><p><img src="https://eddyblog.oss-cn-shenzhen.aliyuncs.com/MultiMedia/VideoEncode_3.png" srcset="/img/loading.gif" alt="VideoEncode_3"></p><ul><li><p>帧内预测编码</p><p>帧内预测编码：是指利用视频空间域的相关性，使用当前图像已编码的像素来预测当前像素，以达到去除视频空间冗余的目的。</p><p>设当前像素值为,是其水平和垂直位置的坐标，进行帧内预测得到的像素值为计算如下：</p><script type="math/tex; mode=display">\hat{f}(x,y) = \sum_{(k,l) \in Z} a_{k,l} \hat{f}(k,l)</script><p>其中 $a_{k,l}$是二维预测系数， $Z$是参考像素所在的区域，$(k,l)$是参考像素的坐标。</p><p>H.264 一共规定了 3 种大小的亮度帧内预测块：4×4、8×8 及 16×16。其中 4×4 和 8×8 块包含 9 种预测模式，16×16 块包含 4 种预测模式。下面简要介绍几种预测模式，其他预测模式的计算可以参考书籍：</p><p>新一代高效视频编码 H.265HEVC 原理、标准与实现 [万帅，杨付正 编著] 2014 年版</p></li><li><p>4x4 的 9 种预测模式</p><p><img src="https://eddyblog.oss-cn-shenzhen.aliyuncs.com/MultiMedia/VideoEncode_4.png" srcset="/img/loading.gif" alt="VideoEncode_4"></p><ul><li>垂直模式（Vertical Mode 0）：$\hat{f} = B$</li><li>水平模式（Horizontal Mode 1）：$\hat{f} = J$</li><li>DC 模式（DC Mode 2）：$\hat{f} = (A+B+C+D+I+J+K+L+4) \gg 3$</li><li>左下对角线模式（Diagonal-Down-Left Mode 3）：$\hat{f} = (C+2D+E+2) \gg 2$</li><li>右下对角线模式（Diagonal-Down-Right Mode 4）：$\hat{f} = (I+2M+A+2) \gg 2$</li><li>垂直向右模式（Vertical-Right Mode 5）：$\hat{f} = (M+2A+B+2) \gg 2$</li><li>水平向下模式（Horizontal-Down Mode 6）：$\hat{f} = (M+2I+J+2) \gg 2$</li><li>垂直向左模式（Vertical-Left Mode 7）：$\hat{f} = (B+2C+D+2) \gg 2$</li><li>水平向上模式（Vertical-Right Mode 8）：$\hat{f} = (J+2K+L+2) \gg 2$</li></ul></li><li><p>16x16 的 4 种预测模式</p><ul><li>垂直模式</li><li>水平模式</li><li>DC 模式（平均值）</li><li>Plane 模式（平面）</li></ul></li><li><p>最优预测模式</p><p>在 H.264 帧内编码中，采用了率失真优化(RDO)技术来选取最佳的帧内预测模式：</p><p>通过遍历所有预测模式，寻找率失真代价 RDCost 最小的作为最优预测模式，</p><p>率失真代价公式为</p><script type="math/tex; mode=display">RDCost=SSD+\lambda \times Rate</script><p>SSD 表示当前块与重建块的平方差之和，λ 为量化参数 QP 的函数；Rate 表示熵编码后的码率。</p></li></ul><h2 id="帧间编码"><a href="#帧间编码" class="headerlink" title="帧间编码"></a>帧间编码</h2><h3 id="基本计算框架"><a href="#基本计算框架" class="headerlink" title="基本计算框架"></a>基本计算框架</h3><ul><li>P 帧的编码：在参考图像（帧内编码的重建图像）中搜索出与编码图像宏块最相似的宏块（又称最佳匹配宏块），接着计算两者的残差，然后对残差进行 DCT 运算，接着对结果量化和熵编码</li><li>B 帧的编码：双向预测计算与单向预测计算类似，区别在于一个编码图像有前后两个参考图像，算法分别在两个参考图像中搜索出两个最佳匹配宏块(因此得到两个运动向量)，接着求这两个匹配宏块的平均值，然后用这个平均值与编码图像块进行差分运算，之后是 DCT 变换、量化，RLE 编码和 Huffman 编码。</li><li>解码过程：也是逐块进行的，首先是 Huffman 解码并分离出运动向量，根据运动向量，然后在参考图像(先解码)中得到最佳匹配宏块。接着是行程解码，反量化和反向正交余弦变换，得到差分值(残差)，最后把残差补充上去(叠加)，即解码出一个宏块。双向预测解码则类似。</li><li>运动估计：在参考图像中搜索出最佳匹配宏块的计算过程称为运动估计(Motion Estimation，ME)，而参考图像中最佳匹配宏块相对于编码图像宏块基准位置的偏移量(水平方向的为 Δx，垂直方向上为 Δy)，称为运动向量(Motion Vector，MV)。运动向量要参与编码。</li><li>运动补偿：根据运动向量将差分值补充到参考图像匹配宏块中去的过程称为运动补偿(Motion Compensation,MC)</li></ul><h3 id="匹配度计算"><a href="#匹配度计算" class="headerlink" title="匹配度计算"></a>匹配度计算</h3><ul><li><p>绝对差（和）（<strong>Sum</strong> of Absolute Difference）</p><script type="math/tex; mode=display">SAD= \sum_{i=0}^{15}\sum_{j=0}^{15} | f(i,j) - g(i-d_x,j-d_y) |</script></li><li><p>均方差（均）（<strong>Mean</strong> of Square Error）</p><script type="math/tex; mode=display">MSE = \frac{1}{M \times N} \sum_{i=0}^{15}\sum_{j=0}^{15} \big[ f(i,j) - g(i-d_x,j-d_y) \big]</script></li><li><p>平均绝对差（均）（<strong>Mean</strong> of Absolute Difference）</p><script type="math/tex; mode=display">MAD= \frac{1}{M \times N} \sum_{i=0}^{15}\sum_{j=0}^{15} | f(i,j) - g(i-d_x,j-d_y) |</script></li></ul><h3 id="运动搜索算法"><a href="#运动搜索算法" class="headerlink" title="运动搜索算法"></a>运动搜索算法</h3><ul><li><p>全搜索法</p><p>在参考图像中，以宏块为单位，每次错位一个像素，从起始点出发，遍历整个参考图像。计算量<strong>最大</strong>，速度<strong>最慢</strong>，<strong>最精准</strong>（全部枚举）。</p></li><li><p>二维对数搜索法</p><p>一轮搜索中，如果 MSE 值最小点出现在边缘 4 个点中的一个位置，则以该点作为新的中心点，保持步长不变，开始新一轮的十字形分布的 5 点搜索。如果 MSE 值最小点出现在中心点，则保持中心点位置不变，将搜索步长减半，重新构成十字形点群，继续搜索这 5 个点。</p><p>若发现新的十字形点群的中心点位于搜索区的图像边缘，则步长减半,并搜索周围 8 个点（图像内），MSE 值最小点为中心点，继续搜索。</p><p>如果该次搜索步长已经为 1，搜索的 MSE 值最小点所在位置即为最佳匹配宏块位置，停止搜素，其偏移量即为运动向量。</p></li><li><p>三步搜索法</p><p>在参考图像中，以宏块为单位，每次错位 n 个像素，从起始点出发，搜索东西南北东南西南西北东北 8 个方向，选择其中 MAD 最小者重复搜索，三次，但搜索距离减半。（距离分别为 3、2、1）</p></li></ul><h3 id="搜索起点的选择"><a href="#搜索起点的选择" class="headerlink" title="搜索起点的选择"></a>搜索起点的选择</h3><ul><li>以参考帧对应的（0,0）位置为起点：<br>无须计算简单,<br>没有利用视频本身信息，易于陷入局部最优点。<br>没有对运动矢量进行预测，无法使用残差</li><li><p>预测起点位置</p><p>利用相邻块之间和相邻帧之间具有很强的相关性，对初始搜索点进行预测计算。</p><ul><li>基于 SAD（Sum of Absolute Difference）值的起点预测方法。该方法分别求出当前块与其相邻块间的 SAD 值，然后选取 SAD 最小的块的运动矢量作为预测值。<strong>记录运动矢量的预测值和实际运动矢量的残差。</strong>该方法预测精度高,但计算 SAD 值的时间开销大</li><li>利用相邻块和相邻帧对应块的运动矢量来预测当前块的搜索起点。H. 263 使用了 3 个相邻块的运动矢量的中值作为当前块运动矢量的预测值。<strong>记录运动矢量的预测值和实际运动矢量的残差。</strong>该方法计算时间开销小，预测精度相对低于第一种</li><li>方法 1,2 结合，基于相邻运动矢量相等的起点预测方法。如果当前块的各相邻块的运动矢量相等，则以其作为当前块运动矢量的预测值；否则，求出当前块与其相邻块间的 SAD 值，然后选取 SAD 最小的块作为预测起点。记录运动矢量的预测值和实际运动矢量的残差。</li></ul></li></ul><h2 id="国际视频编码标准"><a href="#国际视频编码标准" class="headerlink" title="国际视频编码标准"></a>国际视频编码标准</h2><ul><li><p>MPRG 系列</p><p>而由 ISO 和 IEC(国际电工委员会)的共同委员会中的 MPEG 组织(Moving Picture Expert Group)制定的标准。主要针对视频数据的存储应用，也可应用于视频传输，如 VCD、DVD、广播电视和流媒体等，它们以 MEPG-x 命名，如 MEPG-1、MEPG-2 和 MEPG-4 等。</p></li><li><p>H.26x 系列</p><p>H.26x 系列由 ITU 组织制定的标准。主要是针对实时视频通讯的应用，如视频会议和可视电话等，它们以 H.26x 命名，如 H.261、H.262、H.263 和 H.264 等。</p></li><li><p>H.261 编码器</p><p><img src="https://eddyblog.oss-cn-shenzhen.aliyuncs.com/MultiMedia/H.26X_1.png" srcset="/img/loading.gif" alt="H.261"></p></li><li><p>H.263 编码器<br>H.263 与 H.261 的编码原理基本相同，但是，H.263 在 H.261 的基础上做了很多改进，以提高编码效率：（具体看书）</p><ul><li><strong>H.261 只支持两种图像格式，而 H.263 支持 5 种图像格式：</strong></li><li>图像分块方式改进</li><li>运动补偿方式的改进</li><li>量化处理的改进</li><li>编码方式的改进</li><li><strong>运动估值像素精度的改进：半个像素精度的运动估值</strong></li><li>不受限的运动向量</li><li>先进预测模式</li><li>PB 帧格式的使用</li><li>使用基于语法的算术编码</li></ul><p><img src="https://eddyblog.oss-cn-shenzhen.aliyuncs.com/MultiMedia/H.26X_2.png" srcset="/img/loading.gif" alt="H.263"></p></li><li><p>H.264 编码器：引入了帧内预测</p><p><img src="https://eddyblog.oss-cn-shenzhen.aliyuncs.com/MultiMedia/H.26X_3.png" srcset="/img/loading.gif" alt="H.264"></p></li></ul><h1 id="网络多媒体基础"><a href="#网络多媒体基础" class="headerlink" title="网络多媒体基础"></a>网络多媒体基础</h1><h2 id="网络多媒体的概念"><a href="#网络多媒体的概念" class="headerlink" title="网络多媒体的概念"></a>网络多媒体的概念</h2><ul><li>计算机网络<ul><li><strong>概念</strong>：计算机网络是以<strong>信息传输、资源共享为目标</strong>，通过通信线路连接起来的自治计算机系统的集合。</li><li><strong>分类</strong>：<ul><li>视角一（网络覆盖范围）：以网络大小为标准，即根据网络的覆盖范围与规模来进行分类,将计算机网络分为<strong>个域网</strong> 、<strong>局域网</strong>、<strong>城域网</strong>和<strong>广域网</strong> 4 种类型。</li><li>视角二（传输技术）： 按照网络使用的传输技术来分，可以把计算机网络分为<strong>广播类型的网络</strong>和<strong>点到点类型的网络</strong>。</li></ul></li><li><strong>构成</strong>：计算机网络是一种信息基础设施，它的技术焦点是网络体系结构，包括协议分层模型、协议的数据报文格式、网络节点地址与名称管理、路由算法、数据传输及其管理等。</li><li><strong>体系结构（computer network architecture）</strong>：指网络的技术构成方式，核心内容是<strong>网络协议及其分层模型</strong>。</li></ul></li><li>分布式系统<ul><li><strong>概念</strong>：分布式系统是指以计算机网络为基础，由部署在连网的计算机上的程序或组件，通过传递消息进行通信并协同工作的软件系统。这个定义涵盖了所有可有效部署在连网计算机上的软件系统。</li></ul></li><li>计算机网络与分布式系统<ul><li><strong>区分</strong>：计算机网络和分布式系统是两个容易混淆的概念。我们已经阐明，计算机网络是一种信息基础设施，它的焦点是网络体系结构。而分布式系统则关注组件的协同工作和应用。</li></ul></li><li>网络多媒体<ul><li><strong>概念</strong>：泛指一切<strong>与多媒体相关的网络技术</strong>。例如，多媒体传输协议、流媒体技术等等。</li></ul></li><li>分布式多媒体系统<ul><li><strong>概念</strong>：是指以传输和应用多媒体信息为目标的分布式系统，典型代表。视频会议、互联网电话、交互式电视、远程教育、远程医疗、网络视频监控、网络游戏等</li><li><strong>特点</strong>：<ul><li><strong>1. 多媒体应用程序通常是高度分布的</strong>：并且在通用的分布式计算环境中使用。与其他分布式应用程序竞争网络带宽和计算资源。</li><li><strong>2. 多媒体应用程序对资源的需求是动态的</strong>：分布式多媒体应用可能还涉及其他间歇性负载，需要赋予系统高可用性和良好的可伸缩性。</li><li><strong>3. 多媒体数据是连续的和基于时间的</strong>：所谓连续的和基于时间的特性，是指多媒体 数据内部的一种前后关联性，其比特或数据块之间服从严格的先后顺序。流用于描述这种时序关系的既形象又确定的一个概念。所谓数据流就是基于时序的连续数据。媒体应用程序在处理这种连续数据的时候需要特别注意保持数据的时序关系。</li></ul></li><li><strong>挑战</strong>：<ul><li><strong>异构网络与随机性</strong>：建立在异构物理网络和 IP 协议基础上的互联网，是一个不保证服务质量的基础结构，它的传输延时、带宽和丢包率具有随机性。</li><li><strong>服务质量 QoS</strong>：带宽（bandwidth）、延时（delay）和丢包率（lost rate）3 个主要参数</li></ul></li></ul></li></ul><h2 id="多媒体的传输"><a href="#多媒体的传输" class="headerlink" title="多媒体的传输"></a>多媒体的传输</h2><p>研究方向</p><ul><li>第一个研究方向：<strong>针对网络的异构性和不确定性</strong>，着眼多媒体数据本身的特点，在信源端采用<strong>分层的可伸缩性编码</strong>，通过多种速率来传输不同质量的多媒体数据，从而适应传输链路、交换节点和接受终端的异构性。</li><li>第二个研究方向：是从<strong>网络技术本身</strong>着手，对现有网络模型和基础结构进行改进，例如，提高网络传输带宽、增强路由器等交换设备的能力、提供资源预留与组播服务等。</li><li>第三个研究方向：是<strong>分布式多媒体系统本身的体系结构</strong>，例如基于中心服务器的体系结构有助于简化数据管理，但存在较高的延时，而对等模型（即 p2p 网络模型）则有助于提高系统的可伸缩性，但管理复杂。</li></ul><h2 id="组播技术"><a href="#组播技术" class="headerlink" title="组播技术"></a>组播技术</h2><ul><li><p>网络传播方式：网络有 3 种传输方式：这就是广播（broadcast）、单播（unicast）和多播（组播，multicast）</p><ul><li>广播：广播意味着源端向子网的每一个主机都传送同样的数据包，无论这些主机是否乐意接收这些数据包。</li><li>单播：单播是指在发送者和接收者之间实现的点对点传输. 如果发送者同时给多个接收者传输相同的数据，它必须通过多个连接来发送复制的数据包</li><li>组播：后面详细阐述组播</li></ul></li><li><p>组播概念：</p><ul><li>组播是指将源端的数据传送给<strong>一组特定接收者</strong>的传输方式。</li><li><strong>网络组播</strong>：是指通过网络交换设备（路由器）建立一种<strong>树状分发结构所实现的组传输</strong>。组播大大减轻了源主机的负担，因为源端只需要发送一个数据流；也能够显著降低网络通信量。</li></ul></li><li>应用：广泛应用于<strong>一对多（one-to-many）</strong>的传输<ul><li>新闻/体育/股票/天气信息的更新发布</li><li>远程教育(Distance Learning)</li><li>网络路由信息更新(routing updates)</li><li>远程会议(Teleconferencing)</li><li>分布式交互式游戏和仿真</li><li>内容发布(Content distribution)</li><li>Web 缓存更新(Web-cache updates)</li><li>数据库应用(Database replication)</li></ul></li></ul><h2 id="IP-组播构成"><a href="#IP-组播构成" class="headerlink" title="IP 组播构成"></a>IP 组播构成</h2><ul><li>IP 组播是网络组播的一种具体实现，它通过 IP 路由器构造互联网中的组播分发树，使用 IP 组地址标识群组，通过 IGMP（Internet Group Management Protocol）协议管理群组关系，并包含若干 IP 组播路由协议。</li><li>IP 组播涵盖三个方面的内容：<strong>用户（服务模型）</strong>、<strong>群组关系管理协议</strong>、<strong>组播路由协议</strong></li></ul><h3 id="用户模型"><a href="#用户模型" class="headerlink" title="用户模型"></a>用户模型</h3><ul><li><p>使用 IP 组地址标识群组。如 D 类地址</p><ul><li>范围：224.0.0.0 – 239.255.255.255</li><li>组地址的分配问题</li><li>IANA 指定了一些永久地址 (Well-known : 224.0.0.x and 224.0.1.x )；其他组地址是临时组地址(Transient addresses)，需要动态分配</li><li>每个组地址代表一个主机群组(host group)</li><li>IP 组地址是非结构化的(flat address space)</li></ul></li><li><p>源端无需管理目标主机的 IP 地址</p></li><li>群组成员主机可以位于互联网的任何地方</li><li>群组规模（group size）是任意的</li><li>成员主机可以任意加入或退出群组</li><li>任何子网中不能出现同一数据的副本（？？？TODO）</li></ul><h3 id="群组关系管理协议"><a href="#群组关系管理协议" class="headerlink" title="群组关系管理协议"></a>群组关系管理协议</h3><ul><li>主机通过 IGMP 协议告诉指定路由器希望加入并接收某个特定群组的播组信息，同时路由器通过协议周期性地查询子网内某个已知群组的成员是否处于活动状态，即对该网段是否仍然存在属于某个群组的成员主机保持更新(update)。</li><li><strong>作用</strong>：在子网中建立、维护和撤销群组的信号协议“signaling protocol”。</li><li><strong>目标</strong>：保持路由器对整个局域网上群组关系的更新(keep router up-to-date with group membership of entire LAN)</li><li>路由器不需要知道所有成员的存在，而只需要知道是否有成员主机存在。</li><li>一个网络选择一个路由器充当查询者(querier)，又称指定路由器</li><li>查询者周期性发送群组关系查询报文(IGMP Membership Query message)到一个特定地址(all-systems group ，224.0.0.1)</li><li>所有主机接收到该报文后，启动一个随机计时器(random timers，0~10 秒)</li><li>一旦有一个主机超时，它就发送一个群组关系应答报文(Membership Report)到组 G</li><li>其他主机也接收到该报文，立即终止其定时器</li><li>路由器负责监听所有群组的应答报文，如果一个群组未给出应答(超时)，路由器就终止对该群组报文的转发</li></ul><h3 id="组播路由协议"><a href="#组播路由协议" class="headerlink" title="组播路由协议"></a>组播路由协议</h3><ul><li><strong>组播路由协议的作用</strong>：在网络层建立组播分发树，实现组播数据报文的传输</li><li>域内组播路由协议和域间路由协议。域内路由协议又分为密集模式和稀疏模式两种。密集模式组播路由协议一般采用泛洪技术实现。稀疏模式采用最短路径和共享树技术实现。典型：DVMRP 和 MOSPF。</li><li><strong>组播路由的基本目标</strong>：在网络层为传送组播数据包而建立组播分配树</li><li>组播树的叶结点是指包含有群组成员主机的子网 (detected by IGMP)</li><li>组播路由是一个比较困难的课题(Multicast service model makes it hard)</li><li>匿名性和动态性(dynamic join/leave)</li><li><strong>基于泛播与剪枝技术的路由协议</strong><ul><li>首先在整个网络泛播组播数据包，然后剪除不含成员主机的网络分枝，属于这类技术的协议: 距离向量多播路由协议 DVMRP, PIM-DM。</li></ul></li><li><strong>基于链路状态的路由协议</strong><ul><li>一个路由器知道有成员主机加入群组时，它就在整个网络广播该群组关系；一个路由器接收到组播数据时，它就利用 Dijkstra 算法计算到目标主机的最短路经，并转发组播数据。多播开放最短路径优先协议 MOSPF。</li></ul></li><li>具体：<strong>DVMRP 协议</strong><ul><li>是一种互联网多播路由协议，为互联网络的主机组提供了一种面向无连接信息多播的有效机制。</li><li>是一个“内部网关协议”,适合在自治系统内使用，不适合在不同的自治系统之间使用。</li><li>当前开发的 DVMRP 不能用于为非多播数据报路由，</li><li>DVMRP 数据包封装于 IP 数据报中，使用的 IP 协议号为 2,这点与 Internet 组管理协议(IGMP)相同。</li><li>DVMRP 整合了 RIP 协议中的许多特性，核心算法是截断反向路径转发(Truncated Reverse Path Forwarding,TRPF)技术。</li></ul></li><li>具体：<strong>DVMR 协议的缺陷</strong><ul><li>像其他基于距离向量的协议一样, 受无穷计数(count-to-infinity)和环路影响(transient looping)</li><li>伸缩性受到类 RIP 协议的制约，也引入了新的伸缩性问题(scaling limitations)：路由器的(S,G) 状态，使路由器存储开销比较大!</li><li>广播对网络冲击比较大</li></ul></li></ul><p><img src="https://eddyblog.oss-cn-shenzhen.aliyuncs.com/MultiMedia/MOSPF_1.png" srcset="/img/loading.gif" alt="MOSPF_1"></p><p><img src="https://eddyblog.oss-cn-shenzhen.aliyuncs.com/MultiMedia/MOSPF_2.png" srcset="/img/loading.gif" alt="MOSPF_2"></p><p><img src="https://eddyblog.oss-cn-shenzhen.aliyuncs.com/MultiMedia/MOSPF_1.png" srcset="/img/loading.gif" alt="MOSPF_3"></p><h2 id="多媒体传输协议"><a href="#多媒体传输协议" class="headerlink" title="多媒体传输协议"></a>多媒体传输协议</h2><p><a href="https://www.wowza.com/blog/streaming-protocols" target="_blank" rel="noopener">参考资料</a></p><ul><li>多媒体传输协议的整体层次结构<ul><li>应用层：RTMP、RTSP（应用层到传输层还有 RTCP 和 RTP？）</li><li>传输层：TCP、UDP</li><li>网络层：IGMP、…</li><li><img src="https://eddyblog.oss-cn-shenzhen.aliyuncs.com/MultiMedia/StreamingProtocols_1.png" srcset="/img/loading.gif" alt="StreamingProtocols_1"></li></ul></li><li>RTP 协议<ul><li>RTP（Real-time Transport Protocol，实时传输协议）协议是一种为在互联网上以单播或多播方式传输实时多媒体数据而开发的协议，该协议的主要目标是解决<strong>多媒体数据流的同步问题</strong></li><li>混合器工作原理<ul><li>端系统：产生或接收源数据的主机系统（如果是产生源数据，该端系统即为同步源，例如连接摄像机的计算机等）</li><li>混合器：生成 RTP 保温的主机系统（混合器可以实另一个混合器的同步源，也即构成混合器-&gt;混合器的形式）</li><li>转换器：和混合器都是 RTP 级的中继系统。转换器用在通过 IP 多播不能直接到达的用户区。</li></ul></li><li>应用：<ul><li>从应用开发的角度看，RTP 协议是应用程序的一部分。通常由应用程序将多媒体数据封装到 RTP 数据包中，然后交由套接字（Socket）将 RTP 数据包封装到 UDP 数据包中，进而封装到 IP 包中。</li></ul></li></ul></li><li>RTCP 协议<ul><li>来源：RTP 协议用于封装媒体数据并提供时序信息。但是 RTP 协议本身并不保证多媒体传输<strong>服务质量</strong>，也不提供<strong>流量控制</strong>、<strong>拥塞控制</strong>服务。So，进一步提出了 RTCP 协议。</li><li>RTCP（Real Time Control Protocol，实时控制协议）协议<strong>配合 RTP 协议使用</strong>，其主要任务是为通信双方的应用程序提供统计信息，这些信息包括实时数据包的数量、传输过程中丢失的数据包数量、往返延时、延时抖动等。</li></ul></li><li><p>RTSP 协议</p><ul><li>RTSP 协议处于 RTP 协议和 RTCP 协议的上层</li><li>RTSP 可以对流媒体提供诸如播放、暂停、快进等操作</li><li>RTSP 协议会话过程</li><li>客户机首先通过 HTTP 协议从 Web 服务器获取所请求视频服务的呈现描述文件</li><li>然后客户机根据上述信息向视频服务器请求视频服务。</li><li>初始化完毕，视频服务器为该客户建立一个新的视频服务流，客户端与服务器运行实时流控制协议 RTSP</li><li>当服务完毕，客户端提出拆线(TEARDOWN)请求</li></ul></li><li><p>目前流行的流媒体协议</p><ul><li><img src="https://eddyblog.oss-cn-shenzhen.aliyuncs.com/MultiMedia/StreamingProtocols_2.png" srcset="/img/loading.gif" alt="StreamingProtocols_2"></li></ul></li></ul><h2 id="流媒体技术"><a href="#流媒体技术" class="headerlink" title="流媒体技术"></a>流媒体技术</h2><p>目前较流行的流媒体技术栈</p><ul><li>视频以 H.264 编码，以 FLV 格式封装，以 RTMP 协议传输</li><li>代表为：B 站直播，youtube/twitch</li></ul><p>调研问题</p><ul><li>为什么目前 RTMP 比 RTSP 在流媒体直播应用中更流行？</li><li>为什么 B 站的视频流是 FLV 格式而非 MP4 格式？Flash 不是要被淘汰了吗？</li></ul><p>flv.js 作者的回答</p><blockquote><p>作者：谦谦<br>链接：<a href="https://www.zhihu.com/question/51997376/answer/129065505" target="_blank" rel="noopener">https://www.zhihu.com/question/51997376/answer/129065505</a><br>来源：知乎<br>著作权归作者所有。商业转载请联系作者获得授权，非商业转载请注明出处。</p><p>flv.js 做了三件事：</p><ul><li>HTML5 原生仅支持播放 mp4/webm 格式，flv.js 实现了在 HTML5 上播放 FLV 格式视频</li><li>使 Bilibili 网页端平滑过度到 HTML5 播放器，历史遗留不再是障碍</li><li>对于视频直播，在 HTML5 上支持了延迟极低 HTTP FLV 播放，解开网页端直播对 Flash 的依赖一些人问我为什么不直接采用 MP4 格式，并表示对 FLV 格式的厌恶这个问题一方面是历史遗留问题，由于视频网站前期完全依赖 Flash 播放而选择 FLV 格式；</li></ul><p>另一方面，如果仔细研究过 FLV/MP4 封装格式，你会发现 FLV 格式非常简洁，而 MP4 内部 box 种类繁杂，结构复杂固实而又有太多冗余数据。FLV 天生具备流式特征适合网络流传输，而 MP4 这种使用最广泛的存储格式，设计却并不一定优雅。</p><p>这里我不想谈论多媒体封装格式的优劣。flv.js 是在 HTML5 上实现自定义视频格式播放的一个较好的范例，充分利用了 Media Source Extensions, Fetch API 以及 ECMAScript 6 等 HTML5/Web 上较新的技术，并考验着这些 API：开发期间发现 Edge 对 Fetch API 的支持存在 bug，发现各个浏览器在 MSE 的实现细节上都有一些差异和问题，发现 Safari 的 MSE 实现健壮度较差（滑稽）。</p><p>在 flv.js 项目初期，Media Source Extensions (MSE) 在国内处于无人问津的状态；而 MSE API 已经过近 4 年的发展演进，是 HTML5 多媒体相关最重要的 API 之一。MSE 是 HTML5 上实现自定义格式播放的关键，flv.js 开源也是希望 MSE 能被更广泛地了解和应用。</p><p>最后，Chrome 等浏览器正在加速 Flash 淘汰的进程，HTML5 video 由各浏览器厂商实现了高性能硬解，MSE 作为媒体格式扩展的补充，flv.js 证明了当前 HTML5 多媒体技术已超越陈旧的 Flash。</p></blockquote><p>该页面下另一个人的回答</p><blockquote><p>作者：飞翔的蜗牛<br>链接：<a href="https://www.zhihu.com/question/51997376/answer/134109395" target="_blank" rel="noopener">https://www.zhihu.com/question/51997376/answer/134109395</a><br>来源：知乎<br>著作权归作者所有。商业转载请联系作者获得授权，非商业转载请注明出处。</p><p>…而所有直播协议延迟和实时性最好的就是 RTMP，在中国看美国的视频直播延迟也能控制在 1 秒内，很神奇的一个协议。但是 RTMP 有个缺点，他只能在 PC 端上用 flash 来直播，不支持移动端。如果要在手机上网页端用 html5 播放，那么只能选择 HLS，而且 HLS 在中国看美国的视频直播有时候高达 18 秒的延迟。<br>而真正能解决这个需求的，目前来说只有 flv.js，通过 HTTP-FLV，在手机网页端用 html5 播放，延迟是能控制在 1 秒内的。<br>其实很多外国游戏直播网站都是用 RTMP 来直播。他们都是在手机上用 APP，用 C++来解析的。看过一个英文论坛上的讨论，他们的技术对于网页端播放低延迟直播几乎无解，网页端非常难。很多人都没有意识到，这是非常有技术含量，非常伟大的一项技术。<br>至于很多人为什么不用 MP4，而表示对 FLV 的厌恶的问题。做为一个技术控，我是能理解 B 站为什么用 FLV。因为 adobe 的 RTMP 和 FLV 的格式，都设计的非常的简洁和漂亮，所以才有如此神奇的性能。而对于开发者也是一种解脱，无论用 C 或者 js 处理，代码也都非常简洁。如果你让他用 js 去写 MP4 那一坨坨代码，就陷入无穷的技术坑。所以做为一个技术控，用 FLV 是再自然不过的事情。用 FLV，性能好速度快用户爽，代码易读易控开发者爽。</p></blockquote>]]></content>
    
    
    <categories>
      
      <category>Computer Science</category>
      
      <category>多媒体原理与系统</category>
      
    </categories>
    
    
    <tags>
      
      <tag>多媒体原理与系统</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>分布式系统学习——FAST2016NOVA系统论文学习</title>
    <link href="/post/667c5048.html"/>
    <url>/post/667c5048.html</url>
    
    <content type="html"><![CDATA[<!--文章由 3step 模板生成三步法阅读文献笔记记录--><h1 id="Step-1"><a href="#Step-1" class="headerlink" title="Step 1"></a>Step 1</h1><h2 id="题目摘要引言"><a href="#题目摘要引言" class="headerlink" title="题目摘要引言"></a>题目摘要引言</h2><h3 id="题目"><a href="#题目" class="headerlink" title="题目"></a>题目</h3><p>NOVA：日志结构文件系统，为 Hybrid 主内存设计</p><h3 id="摘要"><a href="#摘要" class="headerlink" title="摘要"></a>摘要</h3><p>NVM 将会很快和 DRAM 一同出现在处理器总线上。这种混合系统会为软件提供亚微秒、高贷款的持久数据访问。</p><h2 id="基本理论概况"><a href="#基本理论概况" class="headerlink" title="基本理论概况"></a>基本理论概况</h2><h2 id="结论部分"><a href="#结论部分" class="headerlink" title="结论部分"></a>结论部分</h2><!-- 确定作者的成过以及点出的经验、问题、改进方 --><h2 id="回答基本问题"><a href="#回答基本问题" class="headerlink" title="回答基本问题"></a>回答基本问题</h2><ol><li>类别</li></ol><!-- 这篇论文是什么类型？测试类？对现有系统进行分析的？对原型系统进行描述的？--><ol><li>内容</li></ol><!-- 你读过的其他论文有没有与之相关的？相关性与区别最直接体现在哪里？文章中分析问题用的什么理论基础（通过瞥一眼数学概况与核心证明可以得到）。 --><ol><li>正确性</li></ol><!-- 结论是否看起来真实有效？ --><ol><li>创新点</li></ol><!-- 论文的主要创新点是什么？总结提到的经验、问题和改进方法是什么？ --><ol><li>清晰度</li></ol><!-- 这篇论文是否写的条理清晰 --><h2 id="阅读选择"><a href="#阅读选择" class="headerlink" title="阅读选择"></a>阅读选择</h2><!--1. 继续阅读：论文有价值担保，研究领域非常切合，对当前进行工作有极大帮助，圈内爆火文章2. 不继续阅读：论文不吸引自己，论文价值/正确性存疑，论文作者给出了不适当的假设。3. 库存保留并标记：当前不处于自己的研究领域，但不久的日后相关论文会有用。--><a id="more"></a><h1 id="Step-2"><a href="#Step-2" class="headerlink" title="Step 2"></a>Step 2</h1><h2 id="细读笔记"><a href="#细读笔记" class="headerlink" title="细读笔记"></a>细读笔记</h2><!-- 要仔细阅读论文，但是诸如证明等信息要忽略掉 --><h2 id="问题记录"><a href="#问题记录" class="headerlink" title="问题记录"></a>问题记录</h2><h2 id="未读（且值得读）文献记录"><a href="#未读（且值得读）文献记录" class="headerlink" title="未读（且值得读）文献记录"></a>未读（且值得读）文献记录</h2><!-- 在第二步中，找到以上几篇论文中相同的引用文献、在引用文献中重复的作者名，这些就是你所调研领域的重点论文和科研人员，下载那些重点论文暂时搁到一边。继续访问那些重要科研人员的网页，看下那些论文是在什么会议集结出版的。这能帮你找到那个领域的顶级会议，因为那些重要科研人员通常会在顶级会议发表论文。 --><h1 id="Step-3"><a href="#Step-3" class="headerlink" title="Step 3"></a>Step 3</h1><!-- 试着“在脑中重新实现（virtually re-implement）”那篇论文：也就是，和作者一样做出相同的假设，然后重新实现相同的工作。通过对比你自己得出的和论文中给出的结果，不仅可以很轻易验证一篇论文的创新点是否真实，而且还能发现论文中不会讲的缺点和假想。 --><h2 id="思路复现"><a href="#思路复现" class="headerlink" title="思路复现"></a>思路复现</h2><!-- 推敲作者是如何立题，如何找到突破口，在其中是否有抉择，如何做出的假设？ --><h2 id="证明与推理复现"><a href="#证明与推理复现" class="headerlink" title="证明与推理复现"></a>证明与推理复现</h2><!-- 分析证明过程，确定证明的正确性以及完整性。对证明过程做拓展，调研证明思路来源 --><h2 id="实验验证复现"><a href="#实验验证复现" class="headerlink" title="实验验证复现"></a>实验验证复现</h2><!-- Rework -->]]></content>
    
    
    <categories>
      
      <category>Computer Science</category>
      
      <category>分布式系统</category>
      
    </categories>
    
    
    <tags>
      
      <tag>三步法</tag>
      
      <tag>分布式系统</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>USTCReadingGroup——Building-An-Elastic-Query-Engine</title>
    <link href="/post/fa2bcc39.html"/>
    <url>/post/fa2bcc39.html</url>
    
    <content type="html"><![CDATA[<!--文章由 3step 模板生成三步法阅读文献笔记记录--><h1 id="Step-1"><a href="#Step-1" class="headerlink" title="Step 1"></a>Step 1</h1><h2 id="题目摘要引言"><a href="#题目摘要引言" class="headerlink" title="题目摘要引言"></a>题目摘要引言</h2><h3 id="题目"><a href="#题目" class="headerlink" title="题目"></a>题目</h3><p>SQL，的 Query 引擎，分布式存储器。</p><h3 id="摘要"><a href="#摘要" class="headerlink" title="摘要"></a>摘要</h3><p>Snowflake，一个 cloud-based 数据仓库系统，提供最先进的数据库系统 SQL 支持。设计目标有如下三个</p><ul><li>计算和存储弹性</li><li>支持 multi-tenancy（多租户，单一软件程序为多个客户的架构）</li><li>高性能</li></ul><p>本文说明了 Snowflake 的设计和实现。给出云基础设施最近的发展对 Snowflake 设计与优化的影响。通过在执行大量查询过程中，收集到的系统各组件大量数据中，加深对现有问题的理解并突出新的研究挑战（包括存储系统设计，高性能查询执行引擎）。</p><h3 id="引言"><a href="#引言" class="headerlink" title="引言"></a>引言</h3><p>无共享架构：persistent data 被划分到多个计算节点，计算节点只对本地数据负责，不会进行共享。缺点与代价</p><ul><li>Hardware-workload mismatch：硬件与工作流失配，无法针对计算节点的适合情况匹配合适的 workload（compute-extensive bandwith-light 还是 compute-light bandwith-extensive）</li><li>Lack of Elasticity：静态并行（static parallelism）和数据分区是（非弹性）无共享架构固有的，这限制了对数据和 time-varying workload 的适应。此外无共享架构也不支持节点的增删的弹性，因为一旦涉及此过程，数据需要 reshuffle，增大带宽压力同时反而降低性能，因为参与数据 reshuffle 的节点同时还负责查询过程。</li></ul><p>传统数据仓库被设计用来进行可预测容量、速率的数据的查询（主要来自内部）。现在越来越多不可预测的来自外部的数据（应有程序日志、社交媒体、Web 应用程序）导致了不可预测的 query workloads。无共享架构应对此类效率较低。</p><p>SnowFlake：把计算和存储节点区分开。数据存储在提供高可用性和按需弹性分配的持久化数据仓库中（Amazon S3、Azure Blob Storage）。计算弹性使用预先预热（pre-warmed）节点，可以按需分配给用户。</p><p>Snowflake 有两个核心而后设计思想</p><ul><li>定制设计的临时存储系统：管理临时/中间数据，在查询执行中与计算节点交换。必要性由于现有持久性存储的局限性：<ul><li>无法提供必要的 latency 和 throughput 性能?（原因不大理解，为了避免计算任务称为瓶颈）</li><li>提供更强的可用性和持久性语义。</li></ul></li><li>临时存储系统充当持久化数据的“缓存”：</li></ul><p>未来可能感兴趣的研究方向：</p><ul><li>Decoupling of compute and ephemeral storage（计算和临时存储解耦）</li><li>Deep storage hierarchy（深存储层次）</li></ul><p>系统应用发现：</p><ul><li>只读，只写，读写查询分别占比：~28%、~13%、~59%</li><li>中间数据在不同查询中可能有数量级的差距，却对实际查询的持久化数据量、时间基本没有什么影响。</li><li>少量的本地存储容量，skewed access distributions 与 temporal patterns 可以为持久化数据访问提供相当高的缓存命中率：60-80%</li><li>部分用户使用到弹性支持。</li><li>峰值资源利用率很高，但平均资源利用率地行低下（极差大）</li></ul><h2 id="基本理论概况"><a href="#基本理论概况" class="headerlink" title="基本理论概况"></a>基本理论概况</h2><h2 id="结论部分"><a href="#结论部分" class="headerlink" title="结论部分"></a>结论部分</h2><p>提供实操 Snowflake 数据仓库的经验，覆盖了设计实现概念中最终更关键的几个部分，实现计算和存储的弹性，以及实现多租户架构下的高性能。在 14 天内执行的 70 million 查询中，我们研究发现一些现有设计的缺点。</p><!-- 确定作者的成过以及点出的经验、问题、改进方 --><h2 id="回答基本问题"><a href="#回答基本问题" class="headerlink" title="回答基本问题"></a>回答基本问题</h2><ol><li>类别</li></ol><!-- 这篇论文是什么类型？测试类？对现有系统进行分析的？对原型系统进行描述的？--><ol><li>内容</li></ol><!-- 你读过的其他论文有没有与之相关的？相关性与区别最直接体现在哪里？文章中分析问题用的什么理论基础（通过瞥一眼数学概况与核心证明可以得到）。 --><ol><li>正确性</li></ol><!-- 结论是否看起来真实有效？ --><ol><li>创新点</li></ol><!-- 论文的主要创新点是什么？总结提到的经验、问题和改进方法是什么？ --><ol><li>清晰度</li></ol><!-- 这篇论文是否写的条理清晰 --><h2 id="阅读选择"><a href="#阅读选择" class="headerlink" title="阅读选择"></a>阅读选择</h2><!--1. 继续阅读：论文有价值担保，研究领域非常切合，对当前进行工作有极大帮助，圈内爆火文章2. 不继续阅读：论文不吸引自己，论文价值/正确性存疑，论文作者给出了不适当的假设。3. 库存保留并标记：当前不处于自己的研究领域，但不久的日后相关论文会有用。--><a id="more"></a><h1 id="Step-2"><a href="#Step-2" class="headerlink" title="Step 2"></a>Step 2</h1><h2 id="细读笔记"><a href="#细读笔记" class="headerlink" title="细读笔记"></a>细读笔记</h2><!-- 要仔细阅读论文，但是诸如证明等信息要忽略掉 --><h2 id="问题记录"><a href="#问题记录" class="headerlink" title="问题记录"></a>问题记录</h2><h2 id="未读（且值得读）文献记录"><a href="#未读（且值得读）文献记录" class="headerlink" title="未读（且值得读）文献记录"></a>未读（且值得读）文献记录</h2><!-- 在第二步中，找到以上几篇论文中相同的引用文献、在引用文献中重复的作者名，这些就是你所调研领域的重点论文和科研人员，下载那些重点论文暂时搁到一边。继续访问那些重要科研人员的网页，看下那些论文是在什么会议集结出版的。这能帮你找到那个领域的顶级会议，因为那些重要科研人员通常会在顶级会议发表论文。 --><p>关于作者提到计算-存储 disaggregation，原理上的内容再看。</p><p>[P. X. Gao, A. Narayan, S. Karandikar, J. Carreira, S. Han,R. Agarwal, S. Ratnasamy, and S. Shenker. Networkrequirements for resource disaggregation. InOSDI,2016]</p><p>[J. Gu, Y. Lee, Y. Zhang, M. Chowdhury, and K. G. Shin.Efficient memory disaggregation with infiniswap. InNSDI, 2017]</p><h1 id="Step-3"><a href="#Step-3" class="headerlink" title="Step 3"></a>Step 3</h1><!-- 试着“在脑中重新实现（virtually re-implement）”那篇论文：也就是，和作者一样做出相同的假设，然后重新实现相同的工作。通过对比你自己得出的和论文中给出的结果，不仅可以很轻易验证一篇论文的创新点是否真实，而且还能发现论文中不会讲的缺点和假想。 --><h2 id="思路复现"><a href="#思路复现" class="headerlink" title="思路复现"></a>思路复现</h2><!-- 推敲作者是如何立题，如何找到突破口，在其中是否有抉择，如何做出的假设？ --><h2 id="证明与推理复现"><a href="#证明与推理复现" class="headerlink" title="证明与推理复现"></a>证明与推理复现</h2><!-- 分析证明过程，确定证明的正确性以及完整性。对证明过程做拓展，调研证明思路来源 --><h2 id="实验验证复现"><a href="#实验验证复现" class="headerlink" title="实验验证复现"></a>实验验证复现</h2><!-- Rework --><h1 id="ReadingGroup-会议"><a href="#ReadingGroup-会议" class="headerlink" title="ReadingGroup 会议"></a>ReadingGroup 会议</h1><h2 id="Introduction"><a href="#Introduction" class="headerlink" title="Introduction"></a>Introduction</h2><ul><li>什么是 Query Engine？<ul><li>右边流程图</li><li>本文主要关注数据储存部分。</li></ul></li><li><p>Store what</p><ul><li>Persistent data<ul><li>Long-live</li></ul></li><li>Intermediate data<ul><li>Short-live</li></ul></li><li>Metadata</li></ul></li><li><p>Shared-nothing architecture</p><ul><li>优势</li><li>劣势<ul><li>中间数据</li><li>Hardware-workload mismatch（较低的资源利用）</li><li>弹性缺失</li></ul></li></ul></li></ul><h2 id="Solution"><a href="#Solution" class="headerlink" title="Solution"></a>Solution</h2><p>Snowflake 总览</p><ul><li>Centralized Control</li><li>Compute Part</li><li>Local Ephemeral Storage（中间存储）</li><li>Remote Persistant Storage（持久化存储）</li></ul><h2 id="实现细节"><a href="#实现细节" class="headerlink" title="实现细节"></a>实现细节</h2><p>Ephemeral Storage System</p><p>为什么要做这个？中间数据需要更低延迟更高的吞吐，Amazon S3 不支持。</p><ul><li>Idea 1:<ul><li>Spill from mem to local SSD</li><li>Spill from local SSD to remote S3</li></ul></li><li><p>Motivation:</p><ul><li>Why not only mem?</li><li>Why not spill to ohters?<ul><li>不用跟踪</li><li>间接性</li></ul></li></ul></li><li><p>Idea 2:</p><ul><li>Caching persistent data</li></ul></li><li><p>Motivation</p><ul><li>S3 太慢了</li><li>中间数据短寿命且 size varies<ul><li>Peak Hith Average LOW</li><li>内存和 SSD 可以更好的优化</li></ul></li><li>Workload<ul><li>一定的局部性</li></ul></li></ul></li><li><p>How：（不同的策略）</p><ul><li>Consistent hashing</li><li>Write-through</li><li>LRU</li></ul></li></ul><h3 id="Caching-Persistent-Data"><a href="#Caching-Persistent-Data" class="headerlink" title="Caching Persistent Data"></a>Caching Persistent Data</h3><ul><li><p>Strategy 1：Consistent hashing</p><p>基于一致性哈希的想法。</p></li><li><p>Strategy 2：Work stealing</p><p>一致性哈希对于静态，ok？</p></li><li><p>Strategy 3：Lazy consistent hashing</p><p>新添加一个 N6，Task6 转向 N6，N1 不用移动到 N6，</p></li></ul><p>Cache 的效果</p><p>见图</p><h3 id="Future-Directions"><a href="#Future-Directions" class="headerlink" title="Future Directions"></a>Future Directions</h3><ul><li>将中间数据和 ephemeral storage 对应起来。</li><li>端到端的性能表现<ul><li>中间数据的吞吐量</li><li>Caching data 的命中率</li></ul></li><li><p>Caching hierarchy</p><ul><li>Existing caching mechanisms are designed for 2-tier： Mem to SSD</li></ul></li><li><p>Task Scheduling：</p><ul><li>一个极端：co-locate the tasks with the files（current）</li><li>另一个极端：locate the tasks in a single node</li><li>有兴趣去找最优的方案。</li></ul></li><li><p>Elasticity</p><ul><li>粒度太不匹配了（query 的变化和虚拟性）。</li><li>李：感觉完全不能匹配，除非 serverless</li><li>serverless：</li></ul></li></ul><h3 id="Other-Problems"><a href="#Other-Problems" class="headerlink" title="Other Problems"></a>Other Problems</h3><p>资源：</p><p>价格：由租用机器时间转化为流量（或者启动时间）。</p><p>挑战：保证隔离性的情况下，多用户使用多机子的性能——Trade Off</p><p>目标：</p>]]></content>
    
    
    <categories>
      
      <category>Research</category>
      
      <category>Paper</category>
      
    </categories>
    
    
    <tags>
      
      <tag>Paper</tag>
      
      <tag>三步法</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>CUDA学习——编程入门</title>
    <link href="/post/461ec2fe.html"/>
    <url>/post/461ec2fe.html</url>
    
    <content type="html"><![CDATA[<h1 id="CUDA-编程极简入门"><a href="#CUDA-编程极简入门" class="headerlink" title="CUDA 编程极简入门"></a>CUDA 编程极简入门</h1><p>学习自<a href="https://zhuanlan.zhihu.com/p/34587739" target="_blank" rel="noopener">CUDA 编程入门极简教程</a></p><p>GPU 不是独立的计算平台，需要与 CPU 协同工作。我们常说的用 GPU 并行计算时，其实是指 CPU+GPU 的异构计算架构。CPU 所在位置为主机端（host），而 GPU 所在位置成为设备端（device）。</p><h2 id="CUDA-编程模型基础"><a href="#CUDA-编程模型基础" class="headerlink" title="CUDA 编程模型基础"></a>CUDA 编程模型基础</h2><p>典型的 CUDA 程序的执行流程如下：</p><ol><li>分配 host 内存，进行数据初始化（initalize）</li><li>分配 device 内存，host =&gt; device 内存拷贝</li><li>调用 CUDA 和函数，（GPU 上）完成指定运算</li><li>讲 device 上的运算结果拷贝回 host</li><li>释放 host 和 device 的内存。</li></ol><p>CUDA 这个异构模型通过函数类型限定词开区别 host 和 device 上的函数，主要的三个函数类型限定词如下:</p><ul><li><code>__global__</code>：在 device 上执行，从 host 中调用（一些特定的 GPU 也可以从 device 上调用），返回类型必须是 void，不支持可变参数，不能成为类成员函数。注意用<code>__global__</code>定义的 kernel 是<strong>异步</strong>的，这意味着 host 不会等待 kernel 执行完就执行下一步。</li><li><code>__device__</code>：在 device 上执行，单仅可以从 device 中调用，不可以和<code>__global__</code>同时用。</li><li><code>__host__</code>：在 host 上执行，仅可以从 host 上调用，一般省略不写，不可以和<code>__global__</code>同时用，但可和<code>__device__</code>同时使用，此时函数会在 device 和 host 都编译。</li></ul><h3 id="kernel"><a href="#kernel" class="headerlink" title="kernel"></a>kernel</h3><p>kernel 是 CUDA 中的一个重要概念，实在 device 上线程中并行（启动很多个线程）执行的函数。一个 kernel 启动的所有线程称为一个<strong>网格</strong>（grid），同一个网格上的线程<strong>共享相同的全局内存空间</strong>。一个 grid 划分为多个<strong>线程块</strong>（block），每个 block 包含很多<strong>线程</strong>（thread），整体看像是很多线程池构成的线程网。</p><p><img src="https://eddyblog.oss-cn-shenzhen.aliyuncs.com/CUDA/CUDA_1.jpg" srcset="/img/loading.gif" alt="CUDA_1"></p><p>grid 和 block 都定义为<code>dim3</code>类型变量。<code>dim3</code>可以看成是包含三个无符号整数（x，y，z）成员的结构体变量，在定义时，缺省值初始化为 1。因此 grid 和 block 可以灵活地定义为 1-dim，2-dim 以及 3-dim 结构。</p><p>kernel 在调用时也必须通过执行配置<code>&lt;&lt;&lt;grid, block&gt;&gt;&gt;</code>来指定 kernel 所使用的线程数及结构。</p><p>有时候，我们要知道一个线程在 blcok 中的全局 ID，此时就必须还要知道 block 的组织结构，这是通过线程的内置变量 blockDim 来获得。它获取线程块各个维度的大小。对于一个 2-dim 的 block $(D_x,D_y)$ ，线程 $x,y$ 的 ID 值为 $(x + y<em>D_x)$ ，如果是 3-dim 的 block $(D_x,D_y,D_z)$ ，线程 $(x,y,z)$ 的 ID 值为 $(x+y</em>D_x+z<em>D_x</em>D_y)$ 。另外线程还有内置变量 gridDim，用于获得网格块各个维度的大小（类似于 shape）。</p><p>kernel 的这种线程结构天然适合 vector，matrix 等运算。</p><h3 id="逻辑层与物理层"><a href="#逻辑层与物理层" class="headerlink" title="逻辑层与物理层"></a>逻辑层与物理层</h3><p>还有重要一点，你需要对 GPU 的硬件实现有一个基本的认识。上面说到了 kernel 的线程组织层次，那么一个 kernel 实际上会启动很多线程，这些线程是逻辑上并行的，但是在物理层却并不一定。这其实和 CPU 的多线程有类似之处，多线程如果没有多核支持，在物理层也是无法实现并行的。但是好在 GPU 存在很多 CUDA 核心，充分利用 CUDA 核心可以充分发挥 GPU 的并行计算能力。GPU 硬件的一个核心组件是 SM，前面已经说过，SM 是英文名是 Streaming Multiprocessor，翻译过来就是流式多处理器。SM 的核心组件包括 CUDA 核心，共享内存，寄存器等，SM 可以并发地执行数百个线程，并发能力就取决于 SM 所拥有的资源数。当一个 kernel 被执行时，它的 gird 中的线程块被分配到 SM 上，一个线程块只能在一个 SM 上被调度。SM 一般可以调度多个线程块，这要看 SM 本身的能力。那么有可能一个 kernel 的各个线程块被分配多个 SM，所以 grid 只是逻辑层，而 SM 才是执行的物理层。SM 采用的是 SIMT (Single-Instruction, Multiple-Thread，单指令多线程)架构，基本的执行单元是线程束（wraps)，线程束包含 32 个线程，这些线程同时执行相同的指令，但是每个线程都包含自己的指令地址计数器和寄存器状态，也有自己独立的执行路径。所以尽管线程束中的线程同时从同一程序地址执行，但是可能具有不同的行为，比如遇到了分支结构，一些线程可能进入这个分支，但是另外一些有可能不执行，它们只能死等，因为 GPU 规定线程束中所有线程在同一周期执行相同的指令，线程束分化会导致性能下降。当线程块被划分到某个 SM 上时，它将进一步划分为多个线程束，因为这才是 SM 的基本执行单元，但是一个 SM 同时并发的线程束数是有限的。这是因为资源限制，SM 要为每个线程块分配共享内存，而也要为每个线程束中的线程分配独立的寄存器。所以 SM 的配置会影响其所支持的线程块和线程束并发数量。总之，就是网格和线程块只是逻辑划分，一个 kernel 的所有线程其实在物理层是不一定同时并发的。所以 kernel 的 grid 和 block 的配置不同，性能会出现差异，这点是要特别注意的。还有，由于 SM 的基本执行单元是包含 32 个线程的线程束，所以 block 大小一般要设置为 32 的倍数。</p><p><img src="https://eddyblog.oss-cn-shenzhen.aliyuncs.com/CUDA/CUDA_2.png" srcset="/img/loading.gif" alt="CUDA_2"></p><h1 id="NVIDA-CUDA-编程指南浏览"><a href="#NVIDA-CUDA-编程指南浏览" class="headerlink" title="NVIDA CUDA 编程指南浏览"></a>NVIDA CUDA 编程指南浏览</h1>]]></content>
    
    
    <categories>
      
      <category>Computer Science</category>
      
      <category>并行计算</category>
      
    </categories>
    
    
    <tags>
      
      <tag>并行计算</tag>
      
      <tag>CUDA</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>软件测试学习——测试工具学习</title>
    <link href="/post/d0bec3bf.html"/>
    <url>/post/d0bec3bf.html</url>
    
    <content type="html"><![CDATA[<h1 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h1><p>这一阵子主要工作集中在 MIT6.824 分布式系统理论方面的学习，集中用 go 语言做了两个大实验，本着一学多用的态度，这次测试工具的学习是 go 语言相关（后续学习 C++测试框架 googleTest）。</p><h1 id="golang-race-检测工具"><a href="#golang-race-检测工具" class="headerlink" title="golang race 检测工具"></a>golang race 检测工具</h1><h2 id="什么是-race"><a href="#什么是-race" class="headerlink" title="什么是 race"></a>什么是 race</h2><p>多线程（Threads、Goroutine）程序对共享变量变量的修改是复杂的，以<code>n=n+1</code>指令的并行执行为例，如果 t1 和 t2 线程几乎同时取出原始 n 值，在各自线程中完成+1 操作然后储存进变量 n，得到的答案可能并非编程人员想要看到的。</p><p>事实上，在上述例子中，我们希望每个线程对共享变量 n 的操作都是有效的，但由于 t1 和 t2 线程几乎同时“看到”n 变量，读取值相同，两次累加从结果看变成了一次累加。</p><p>race 的名字变源自于此，这种对共享变量不恰当的操作看起来像像线程间的“赛跑”。 结果是否正确取决于晚些执行到该指令的线程 t2 能否“看到” 先行抵达的线程 t1 的修改（t1 线程执行累加后的变量值）。</p><a id="more"></a><h2 id="race-预防与检测"><a href="#race-预防与检测" class="headerlink" title="race 预防与检测"></a>race 预防与检测</h2><p>Go 语言提供的锁机制（mu.lock() mu.unlock()）可以帮助我们“锁住”赛跑中的线程，对共享变量加锁是预防 race 出现的常用方式，但是这需要编程人员进行准确细致的编程。不过往往人也有疏忽的时候，可喜的是，golang 在 1.1 之后引入了竞争检测的概念。我们可以使用 <code>go run -race</code> 或者 <code>go build -race</code> 来进行竞争检测。</p><!--more--><p>测试代码 1</p><pre><code class="hljs go"><span class="hljs-keyword">package</span> main<span class="hljs-keyword">import</span> (    <span class="hljs-string">"fmt"</span>)<span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span> &#123;    n := <span class="hljs-number">1</span>    circle := <span class="hljs-number">10</span>    <span class="hljs-keyword">for</span> i := <span class="hljs-number">0</span>; i &lt; circle; i++ &#123;        <span class="hljs-keyword">go</span> <span class="hljs-function"><span class="hljs-keyword">func</span><span class="hljs-params">()</span></span> &#123;            temp := n            <span class="hljs-comment">// time.Sleep(1 * time.Second)</span>            temp *= <span class="hljs-number">10</span>            n = temp            fmt.Println(<span class="hljs-string">"n is "</span>, n)        &#125;()    &#125;&#125;</code></pre><p>运行指令<code>go run -race</code>，进行 race 检测，如下图</p><p><img src="https://eddyblog.oss-cn-shenzhen.aliyuncs.com/SoftwareTesting/Lab5_1.png" srcset="/img/loading.gif" alt="Lab5_1"></p><p>发现了 race，但是由于写回操作较快，没有影响最终结果。</p><p>取消<code>time.Sleep</code>所在行的注释，再次运行指令<code>go run -race</code>，运行结果如下图</p><p><img src="https://eddyblog.oss-cn-shenzhen.aliyuncs.com/SoftwareTesting/Lab5_2.png" srcset="/img/loading.gif" alt="Lab5_2"></p><p>发现了 race，且这次由于线程写回前休眠，所有线程都在其余线程写回前读，所以最终结果被影响。</p><h1 id="golang-goconvey-测试框架"><a href="#golang-goconvey-测试框架" class="headerlink" title="golang goconvey 测试框架"></a>golang goconvey 测试框架</h1><p>GoConvey 是一个开源的 go 语言测试工具，实际上 go 本身提供了<code>go test</code>测试指令供开发者使用，在目录下使用该指令会对该目录中所有后缀为<code>*_test.go</code>进行测试编译，并对前缀为<code>Test*</code>的函数进行单元检测。</p><p>GoConvey 主要是编写并集成好了一些常用的测试语句（如形式、数值断言等），并提供了一个优秀的可视化界面。</p><p><a href="https://github.com/smartystreets/goconvey" target="_blank" rel="noopener">GoConvey 的代码仓库</a></p><h2 id="框架安装"><a href="#框架安装" class="headerlink" title="框架安装"></a>框架安装</h2><p>由于大陆内部使用 go 语言存在一些限制，而且如果启用<code>GO111MODULE</code>，我需要大幅度调整我的项目格式，所以我没有采用 mod，也没有按照官方建议的<code>go get</code>安装方式。</p><p>安装好二进制后，我手动检查了依赖项，并在项目源码<code>\src\github.com</code>分别 clone 几个代码仓库</p><pre><code class="hljs bash"><span class="hljs-built_in">cd</span> <span class="hljs-variable">$GOPATH</span>/srcgit <span class="hljs-built_in">clone</span> https://github.com/smartystreets/goconvey.git ./smartystreets/goconveygit <span class="hljs-built_in">clone</span> https://github.com/smartystreets/assertions.git ./smartystreets/assertionsgit <span class="hljs-built_in">clone</span> https://github.com/jtolds/gls.git ./jtolds/gls</code></pre><p>启动 Web 服务</p><pre><code class="hljs bash"><span class="hljs-built_in">cd</span> <span class="hljs-variable">$GOPATH</span>/bin./goconvey</code></pre><p>显示界面如下图，成功。</p><p><img src="https://eddyblog.oss-cn-shenzhen.aliyuncs.com/SoftwareTesting/Lab5_3.png" srcset="/img/loading.gif" alt="Lab5_3"></p><h2 id="编写测试代码"><a href="#编写测试代码" class="headerlink" title="编写测试代码"></a>编写测试代码</h2><ul><li>待检测程序 student.go</li></ul><pre><code class="hljs Go"><span class="hljs-keyword">package</span> main<span class="hljs-keyword">import</span> <span class="hljs-string">"fmt"</span><span class="hljs-keyword">type</span> Student <span class="hljs-keyword">struct</span> &#123;Num  <span class="hljs-keyword">int</span>Name <span class="hljs-keyword">string</span>Chinaese <span class="hljs-keyword">int</span>English  <span class="hljs-keyword">int</span>Math     <span class="hljs-keyword">int</span>&#125;<span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">NewStudent</span><span class="hljs-params">(num <span class="hljs-keyword">int</span>, name <span class="hljs-keyword">string</span>)</span> <span class="hljs-params">(*Student, error)</span></span> &#123;<span class="hljs-keyword">if</span> num &lt; <span class="hljs-number">1</span> || <span class="hljs-built_in">len</span>(name) &lt; <span class="hljs-number">1</span> &#123;<span class="hljs-keyword">return</span> <span class="hljs-literal">nil</span>, fmt.Errorf(<span class="hljs-string">"num name empty"</span>)&#125;stu := <span class="hljs-built_in">new</span>(Student)stu.Num = numstu.Name = name<span class="hljs-keyword">return</span> stu, <span class="hljs-literal">nil</span>&#125;<span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-params">(this *Student)</span> <span class="hljs-title">GetAve</span><span class="hljs-params">()</span> <span class="hljs-params">(<span class="hljs-keyword">int</span>, error)</span></span> &#123;score := this.Chinaese + this.English + this.Math<span class="hljs-keyword">if</span> score == <span class="hljs-number">0</span> &#123;<span class="hljs-keyword">return</span> <span class="hljs-number">0</span>, fmt.Errorf(<span class="hljs-string">"score is 0"</span>)&#125;<span class="hljs-keyword">return</span> score / <span class="hljs-number">3</span>, <span class="hljs-literal">nil</span>&#125;</code></pre><ul><li>测试程序 student_test.go</li></ul><pre><code class="hljs Go"><span class="hljs-keyword">package</span> main<span class="hljs-keyword">import</span> (<span class="hljs-string">"testing"</span>. <span class="hljs-string">"github.com/smartystreets/goconvey/convey"</span>)<span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">TestNew</span><span class="hljs-params">(t *testing.T)</span></span> &#123;Convey(<span class="hljs-string">"start test new"</span>, t, <span class="hljs-function"><span class="hljs-keyword">func</span><span class="hljs-params">()</span></span> &#123;stu, err := NewStudent(<span class="hljs-number">0</span>, <span class="hljs-string">""</span>)Convey(<span class="hljs-string">"have error"</span>, <span class="hljs-function"><span class="hljs-keyword">func</span><span class="hljs-params">()</span></span> &#123;So(err, ShouldBeError)&#125;)Convey(<span class="hljs-string">"stu is nil"</span>, <span class="hljs-function"><span class="hljs-keyword">func</span><span class="hljs-params">()</span></span> &#123;So(stu, ShouldBeNil)&#125;)&#125;)&#125;<span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">TestScore</span><span class="hljs-params">(t *testing.T)</span></span> &#123;stu, _ := NewStudent(<span class="hljs-number">1</span>, <span class="hljs-string">"test"</span>)Convey(<span class="hljs-string">"if error"</span>, t, <span class="hljs-function"><span class="hljs-keyword">func</span><span class="hljs-params">()</span></span> &#123;_, err := stu.GetAve()Convey(<span class="hljs-string">"have error"</span>, <span class="hljs-function"><span class="hljs-keyword">func</span><span class="hljs-params">()</span></span> &#123;So(err, ShouldBeError)&#125;)&#125;)Convey(<span class="hljs-string">"normal"</span>, t, <span class="hljs-function"><span class="hljs-keyword">func</span><span class="hljs-params">()</span></span> &#123;stu.Math = <span class="hljs-number">60</span>stu.Chinaese = <span class="hljs-number">70</span>stu.English = <span class="hljs-number">80</span>score, err := stu.GetAve()Convey(<span class="hljs-string">"have error"</span>, <span class="hljs-function"><span class="hljs-keyword">func</span><span class="hljs-params">()</span></span> &#123;So(err, ShouldBeError)&#125;)Convey(<span class="hljs-string">"score &gt; 60"</span>, <span class="hljs-function"><span class="hljs-keyword">func</span><span class="hljs-params">()</span></span> &#123;So(score, ShouldBeGreaterThan, <span class="hljs-number">60</span>)&#125;)&#125;)&#125;</code></pre><h2 id="执行测试"><a href="#执行测试" class="headerlink" title="执行测试"></a>执行测试</h2><ul><li><p>VSCode 单元测试结果（go test 命令行）</p><p><img src="https://eddyblog.oss-cn-shenzhen.aliyuncs.com/SoftwareTesting/Lab5_4.png" srcset="/img/loading.gif" alt="Lab5_4"></p><p>由于有一个 Error 预期和 nil 实际类型不符合，测试不通过。</p></li><li><p>Web UI</p><p><img src="https://eddyblog.oss-cn-shenzhen.aliyuncs.com/SoftwareTesting/Lab5_5.png" srcset="/img/loading.gif" alt="Lab5_5"></p><p>同样显示有一个 Error 预期和 nil 实际类型不符合，测试不通过。从结构看，5 个断言，通过 4 个，断言处在哪个测试函数中也清晰明了。极大方便了我们排查缺陷所在。另一个简单程序的测试通过情况如下。</p><p><img src="https://eddyblog.oss-cn-shenzhen.aliyuncs.com/SoftwareTesting/Lab5_6.png" srcset="/img/loading.gif" alt="Lab5_6"></p></li></ul><h1 id="结语"><a href="#结语" class="headerlink" title="结语"></a>结语</h1><p>通过本次阶段性学习，我发现了解、熟悉、熟练使用测试工具是三个层次，过去我只停留在了解层面，将测试部分和业务逻辑部分混在一起编写，排错难，测试烦。</p><p>进行了<code>go run -race</code>检测和<code>GoConvey</code>工具的学习后，我才知道原来语言开发者、开源社区还存在着如此高效的工具，不仅减少了 bug 产生的概率，也减少了 bug 发现后修复，回归的时间，可谓一举多得，感谢老师给了我们这个主动学习领域内各种实用知识的机会。</p>]]></content>
    
    
    <categories>
      
      <category>Computer Science</category>
      
      <category>软件测试</category>
      
    </categories>
    
    
    <tags>
      
      <tag>软件测试</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>软件测试学习——TDD流程实验报告</title>
    <link href="/post/bafae70a.html"/>
    <url>/post/bafae70a.html</url>
    
    <content type="html"><![CDATA[<h1 id="软件测试课程作业四"><a href="#软件测试课程作业四" class="headerlink" title="软件测试课程作业四"></a>软件测试课程作业四</h1><h2 id="实验内容"><a href="#实验内容" class="headerlink" title="实验内容"></a>实验内容</h2><ul><li>依据 TDD 编程流程，编制函数，实现两数相加求和。</li></ul><h2 id="实验过程"><a href="#实验过程" class="headerlink" title="实验过程"></a>实验过程</h2><a id="more"></a><h3 id="TDD-需求阶段"><a href="#TDD-需求阶段" class="headerlink" title="TDD 需求阶段"></a>TDD 需求阶段</h3><p>考虑到浮点数可表达的范围太大不好体现 TDD 设计流程的思想，本实验目标为实现用户控制两<strong>整数</strong>相加并返回结果。</p><ul><li><p>输入阶段：</p><p>用户可手动输入数值或选择退出程序。</p></li><li><p>检测阶段：对用户输入的内容进行检测</p><p>合法输入应为<code>int</code>类型范围内整数，对于不合法的输入提示错误并重新输入，输入为合法范围内但输出数值溢出的情况，会由计算阶段程序在内部进行适当格式转化，对用户透明。</p></li><li><p>计算阶段：计算两数之和</p><p>对合法的输入内容，执行 ADD 求和，并返回结果。</p></li><li><p>输出阶段：</p><p>将得到的结果反馈给用户。</p></li></ul><h3 id="TDD-设计阶段"><a href="#TDD-设计阶段" class="headerlink" title="TDD 设计阶段"></a>TDD 设计阶段</h3><p>基于需求分析的思路，设计方案求精，构建测试用例，用文字描述程序过程。（单元测试 Unit Test 客观上被节省掉）。</p><ul><li><p>构建测试用例</p><p>由于开发过程是，需求-测例-代码，看不到程序结构，这里主要采用黑盒测试的测例构造思路。</p><p>| 测例编号 | 输入                        | 预计输出    | 实际输出 | 备注                                 |<br>| :———- | :————————————— | :————— | :———- | :—————————————————- |<br>| 1        | a=2147483646 b=1            | 2147483647  |          | 4Bytes int 类型边界测试值。          |<br>| 2        | a=2147483647 b=1            | 2147483647  |          | 输出值不再能用 4Bytes 表示，转化测试 |<br>| 3        | a=2147483647 b=2147483647   | 4294967294  |          | 双边界值测试                         |<br>| 4        | a=-2147483647 b=-1          | -2147483648 |          | 负值 4Bytes int 类型边界测试界       |<br>| 5        | a=-2147483648 b=-1          | -2147483649 |          | 负值转化测试                         |<br>| 6        | a=-2147483648 b=-2147483648 | -4294967296 |          | 负值双边界值测试                     |<br>| 7        | a=0.005 b = asdfab          | 2 Error     |          | 不合法的非整数输入测试               |<br>| 8        | a=2147483648 b=-2147483649  | 2 Error     |          | 正负双越界测试                       |</p></li></ul><h3 id="TDD-构造阶段"><a href="#TDD-构造阶段" class="headerlink" title="TDD 构造阶段"></a>TDD 构造阶段</h3><p>在我的构造阶段，我写了一个带格式转化的程序（验证程序）和一个不带格式转化的程序（对照程序）。</p><ul><li>带格式转化程序（验证程序）</li></ul><pre><code class="hljs C++"><span class="hljs-comment">/*** 程序名：testAdd** 程序功能：从input输入文件中逐行输入两个整数值**         在输入合法的情况下（范围4字节有符号int类型）打印运算成功并输出和值。**         否则打印错误信息** 作者：Edwardzcn*/</span><span class="hljs-meta">#<span class="hljs-meta-keyword">include</span> <span class="hljs-meta-string">&lt;bits/stdc++.h&gt;</span></span><span class="hljs-keyword">using</span> <span class="hljs-keyword">namespace</span> <span class="hljs-built_in">std</span>;<span class="hljs-keyword">typedef</span> <span class="hljs-keyword">long</span> <span class="hljs-keyword">long</span> ll;<span class="hljs-keyword">typedef</span> <span class="hljs-keyword">unsigned</span> <span class="hljs-keyword">long</span> <span class="hljs-keyword">long</span> ull;<span class="hljs-keyword">typedef</span> pair&lt;<span class="hljs-keyword">int</span>, <span class="hljs-keyword">int</span>&gt; pii;<span class="hljs-keyword">typedef</span> pair&lt;<span class="hljs-built_in">string</span>, <span class="hljs-built_in">string</span>&gt; pss;<span class="hljs-meta">#<span class="hljs-meta-keyword">define</span> rep(i, a, n) for (int i = a; i &lt; n; ++i)</span><span class="hljs-meta">#<span class="hljs-meta-keyword">define</span> per(i, a, n) for (int i = n - 1; i &gt;= a; --i)</span><span class="hljs-meta">#<span class="hljs-meta-keyword">define</span> DEBUG_INPUT DEBUG_INPUT</span><span class="hljs-comment">/*** 函数名：isNum** 函数功能：用来检测是否为合法输入数** 参数名称与类型：**  string s** 返回值：**  bool*/</span><span class="hljs-function"><span class="hljs-keyword">bool</span> <span class="hljs-title">isNum</span><span class="hljs-params">(<span class="hljs-built_in">string</span> s)</span></span>&#123;    <span class="hljs-keyword">bool</span> flag = <span class="hljs-literal">false</span>;    <span class="hljs-keyword">if</span> (s == <span class="hljs-string">""</span>)        <span class="hljs-keyword">return</span> <span class="hljs-literal">false</span>;    rep(i, <span class="hljs-number">0</span>, s.size())    &#123;        <span class="hljs-keyword">if</span> (i == <span class="hljs-number">0</span> &amp;&amp; s[i] == <span class="hljs-string">'-'</span>)            <span class="hljs-keyword">continue</span>;        <span class="hljs-keyword">if</span> (s[i] &lt; <span class="hljs-string">'0'</span> || s[i] &gt; <span class="hljs-string">'9'</span>)            <span class="hljs-keyword">return</span> <span class="hljs-literal">false</span>;    &#125;    <span class="hljs-keyword">return</span> <span class="hljs-literal">true</span>;&#125;<span class="hljs-comment">/*** 函数名：getAdd** 函数功能：根据两输入值获取商值** 参数名称与类型：**  int a**  int b** 返回值类型：**  long long*/</span><span class="hljs-function">ll <span class="hljs-title">getAdd</span><span class="hljs-params">(<span class="hljs-keyword">int</span> a, <span class="hljs-keyword">int</span> b)</span></span>&#123;    <span class="hljs-keyword">return</span> ll(a) + ll(b);&#125;<span class="hljs-comment">/*** 函数名：main** 函数功能：主函数，入口** 参数名称与类型：**  int argc**  char* argv[]** 返回值类型：**  int*/</span><span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">main</span><span class="hljs-params">(<span class="hljs-keyword">int</span> argc, <span class="hljs-keyword">char</span> *argv[])</span></span>&#123;    <span class="hljs-built_in">cout</span> &lt;&lt; (<span class="hljs-string">"======= Start Program: testAdd ================"</span>) &lt;&lt; <span class="hljs-built_in">endl</span>;<span class="hljs-meta">#<span class="hljs-meta-keyword">ifdef</span> DEBUG_INPUT</span>    freopen(<span class="hljs-string">"input"</span>, <span class="hljs-string">"r"</span>, <span class="hljs-built_in">stdin</span>);    <span class="hljs-comment">// freopen("output", "w", stdout);</span><span class="hljs-meta">#<span class="hljs-meta-keyword">endif</span> <span class="hljs-comment">// DEBUG_INPUT</span></span>    <span class="hljs-built_in">string</span> a, b;    <span class="hljs-keyword">int</span> parseNum;    <span class="hljs-keyword">while</span> (<span class="hljs-built_in">cin</span> &gt;&gt; a &gt;&gt; b)    &#123;        <span class="hljs-keyword">bool</span> a_type = isNum(a);        <span class="hljs-keyword">bool</span> b_type = isNum(b);        <span class="hljs-keyword">int</span> a_int, b_int;        <span class="hljs-keyword">int</span> flag = <span class="hljs-literal">true</span>;        <span class="hljs-comment">// 判断非数字的情况</span>        <span class="hljs-keyword">if</span> (!a_type)        &#123;            flag = <span class="hljs-literal">false</span>;            <span class="hljs-built_in">std</span>::<span class="hljs-built_in">cerr</span> &lt;&lt; <span class="hljs-string">"Error: a="</span> &lt;&lt; a &lt;&lt; <span class="hljs-string">" is not a num."</span> &lt;&lt; <span class="hljs-built_in">endl</span>;        &#125;        <span class="hljs-keyword">if</span> (!b_type)        &#123;            flag = <span class="hljs-literal">false</span>;            <span class="hljs-built_in">std</span>::<span class="hljs-built_in">cerr</span> &lt;&lt; <span class="hljs-string">"Error: b="</span> &lt;&lt; b &lt;&lt; <span class="hljs-string">" is not a num."</span> &lt;&lt; <span class="hljs-built_in">endl</span>;        &#125;        <span class="hljs-keyword">if</span> (!flag)        &#123;            <span class="hljs-built_in">cout</span> &lt;&lt; <span class="hljs-string">"Try Again."</span> &lt;&lt; <span class="hljs-built_in">endl</span>;            <span class="hljs-keyword">continue</span>;        &#125;        <span class="hljs-keyword">try</span>        &#123;            a_int = stoi(a, <span class="hljs-built_in">string</span>::size_type());        &#125;        <span class="hljs-keyword">catch</span> (<span class="hljs-keyword">const</span> <span class="hljs-built_in">std</span>::out_of_range &amp;oor)        &#123;            <span class="hljs-built_in">std</span>::<span class="hljs-built_in">cerr</span> &lt;&lt; <span class="hljs-string">"Error: Value of a out of range! "</span> &lt;&lt; oor.what() &lt;&lt; <span class="hljs-built_in">endl</span>;            flag = <span class="hljs-literal">false</span>;        &#125;        <span class="hljs-keyword">try</span>        &#123;            b_int = stoi(b, <span class="hljs-built_in">string</span>::size_type());        &#125;        <span class="hljs-keyword">catch</span> (<span class="hljs-keyword">const</span> <span class="hljs-built_in">std</span>::out_of_range &amp;oor)        &#123;            <span class="hljs-built_in">std</span>::<span class="hljs-built_in">cerr</span> &lt;&lt; <span class="hljs-string">"Error: Value of b out of range! "</span> &lt;&lt; oor.what() &lt;&lt; <span class="hljs-built_in">endl</span>;            flag = <span class="hljs-literal">false</span>;        &#125;        ll ans = getAdd(a_int, b_int);        <span class="hljs-keyword">if</span> (!flag)        &#123;            <span class="hljs-built_in">cout</span> &lt;&lt; <span class="hljs-string">"Try Again."</span> &lt;&lt; <span class="hljs-built_in">endl</span>;            <span class="hljs-keyword">continue</span>;        &#125;        <span class="hljs-keyword">else</span>        &#123;            <span class="hljs-built_in">cout</span> &lt;&lt; <span class="hljs-string">"Correct! The value is "</span> &lt;&lt; ans &lt;&lt; <span class="hljs-string">"."</span> &lt;&lt; <span class="hljs-built_in">endl</span>;        &#125;    &#125;    <span class="hljs-built_in">cout</span> &lt;&lt; <span class="hljs-string">"=============================================="</span> &lt;&lt; <span class="hljs-built_in">endl</span>;    <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;&#125;</code></pre><ul><li>不带格式转换的程序（对照程序）</li></ul><pre><code class="hljs C++"><span class="hljs-comment">/*** 程序名：testAddCompact** 程序功能：做testAdd程序的对照组，检测数值类型转换的有效性** 作者：Edwardzcn*/</span><span class="hljs-meta">#<span class="hljs-meta-keyword">include</span> <span class="hljs-meta-string">&lt;bits/stdc++.h&gt;</span></span><span class="hljs-keyword">using</span> <span class="hljs-keyword">namespace</span> <span class="hljs-built_in">std</span>;<span class="hljs-keyword">typedef</span> <span class="hljs-keyword">long</span> <span class="hljs-keyword">long</span> ll;<span class="hljs-keyword">typedef</span> <span class="hljs-keyword">unsigned</span> <span class="hljs-keyword">long</span> <span class="hljs-keyword">long</span> ull;<span class="hljs-keyword">typedef</span> pair&lt;<span class="hljs-keyword">int</span>, <span class="hljs-keyword">int</span>&gt; pii;<span class="hljs-keyword">typedef</span> pair&lt;<span class="hljs-built_in">string</span>, <span class="hljs-built_in">string</span>&gt; pss;<span class="hljs-meta">#<span class="hljs-meta-keyword">define</span> rep(i, a, n) for (int i = a; i &lt; n; ++i)</span><span class="hljs-meta">#<span class="hljs-meta-keyword">define</span> per(i, a, n) for (int i = n - 1; i &gt;= a; --i)</span><span class="hljs-meta">#<span class="hljs-meta-keyword">define</span> DEBUG_INPUT DEBUG_INPUT</span><span class="hljs-comment">/*** 函数名：isNum** 函数功能：用来检测是否为合法输入数** 参数名称与类型：**  string s** 返回值：**  bool*/</span><span class="hljs-function"><span class="hljs-keyword">bool</span> <span class="hljs-title">isNum</span><span class="hljs-params">(<span class="hljs-built_in">string</span> s)</span></span>&#123;    <span class="hljs-keyword">bool</span> flag = <span class="hljs-literal">false</span>;    <span class="hljs-keyword">if</span> (s == <span class="hljs-string">""</span>)        <span class="hljs-keyword">return</span> <span class="hljs-literal">false</span>;    rep(i, <span class="hljs-number">0</span>, s.size())    &#123;        <span class="hljs-keyword">if</span> (i == <span class="hljs-number">0</span> &amp;&amp; s[i] == <span class="hljs-string">'-'</span>)            <span class="hljs-keyword">continue</span>;        <span class="hljs-keyword">if</span> (s[i] &lt; <span class="hljs-string">'0'</span> || s[i] &gt; <span class="hljs-string">'9'</span>)            <span class="hljs-keyword">return</span> <span class="hljs-literal">false</span>;    &#125;    <span class="hljs-keyword">return</span> <span class="hljs-literal">true</span>;&#125;<span class="hljs-comment">/*** 函数名：getAdd** 函数功能：根据两输入值获取商值** 参数名称与类型：**  int a**  int b** 返回值类型：**  long long*/</span><span class="hljs-function">ll <span class="hljs-title">getAdd</span><span class="hljs-params">(<span class="hljs-keyword">int</span> a, <span class="hljs-keyword">int</span> b)</span></span>&#123;    <span class="hljs-keyword">return</span> ll(a + b);&#125;<span class="hljs-comment">/*** 函数名：main** 函数功能：主函数，入口** 参数名称与类型：**  int argc**  char* argv[]** 返回值类型：**  int*/</span><span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">main</span><span class="hljs-params">(<span class="hljs-keyword">int</span> argc, <span class="hljs-keyword">char</span> *argv[])</span></span>&#123;    <span class="hljs-built_in">cout</span> &lt;&lt; (<span class="hljs-string">"======= Start Program: testAdd ================"</span>) &lt;&lt; <span class="hljs-built_in">endl</span>;<span class="hljs-meta">#<span class="hljs-meta-keyword">ifdef</span> DEBUG_INPUT</span>    freopen(<span class="hljs-string">"input"</span>, <span class="hljs-string">"r"</span>, <span class="hljs-built_in">stdin</span>);    <span class="hljs-comment">// freopen("output", "w", stdout);</span><span class="hljs-meta">#<span class="hljs-meta-keyword">endif</span> <span class="hljs-comment">// DEBUG_INPUT</span></span>    <span class="hljs-built_in">string</span> a, b;    <span class="hljs-keyword">int</span> parseNum;    <span class="hljs-keyword">while</span> (<span class="hljs-built_in">cin</span> &gt;&gt; a &gt;&gt; b)    &#123;        <span class="hljs-keyword">bool</span> a_type = isNum(a);        <span class="hljs-keyword">bool</span> b_type = isNum(b);        <span class="hljs-keyword">int</span> a_int, b_int;        <span class="hljs-keyword">int</span> flag = <span class="hljs-literal">true</span>;        <span class="hljs-comment">// 判断非数字的情况</span>        <span class="hljs-keyword">if</span> (!a_type)        &#123;            flag = <span class="hljs-literal">false</span>;            <span class="hljs-built_in">std</span>::<span class="hljs-built_in">cerr</span> &lt;&lt; <span class="hljs-string">"Error: a="</span> &lt;&lt; a &lt;&lt; <span class="hljs-string">" is not a num."</span> &lt;&lt; <span class="hljs-built_in">endl</span>;        &#125;        <span class="hljs-keyword">if</span> (!b_type)        &#123;            flag = <span class="hljs-literal">false</span>;            <span class="hljs-built_in">std</span>::<span class="hljs-built_in">cerr</span> &lt;&lt; <span class="hljs-string">"Error: b="</span> &lt;&lt; b &lt;&lt; <span class="hljs-string">" is not a num."</span> &lt;&lt; <span class="hljs-built_in">endl</span>;        &#125;        <span class="hljs-keyword">if</span> (!flag)        &#123;            <span class="hljs-built_in">cout</span> &lt;&lt; <span class="hljs-string">"Try Again."</span> &lt;&lt; <span class="hljs-built_in">endl</span>;            <span class="hljs-keyword">continue</span>;        &#125;        <span class="hljs-keyword">try</span>        &#123;            a_int = stoi(a, <span class="hljs-built_in">string</span>::size_type());        &#125;        <span class="hljs-keyword">catch</span> (<span class="hljs-keyword">const</span> <span class="hljs-built_in">std</span>::out_of_range &amp;oor)        &#123;            <span class="hljs-built_in">std</span>::<span class="hljs-built_in">cerr</span> &lt;&lt; <span class="hljs-string">"Error: Value of a out of range! "</span> &lt;&lt; oor.what() &lt;&lt; <span class="hljs-built_in">endl</span>;            flag = <span class="hljs-literal">false</span>;        &#125;        <span class="hljs-keyword">try</span>        &#123;            b_int = stoi(b, <span class="hljs-built_in">string</span>::size_type());        &#125;        <span class="hljs-keyword">catch</span> (<span class="hljs-keyword">const</span> <span class="hljs-built_in">std</span>::out_of_range &amp;oor)        &#123;            <span class="hljs-built_in">std</span>::<span class="hljs-built_in">cerr</span> &lt;&lt; <span class="hljs-string">"Error: Value of b out of range! "</span> &lt;&lt; oor.what() &lt;&lt; <span class="hljs-built_in">endl</span>;            flag = <span class="hljs-literal">false</span>;        &#125;        ll ans = getAdd(a_int, b_int);        <span class="hljs-keyword">if</span> (!flag)        &#123;            <span class="hljs-built_in">cout</span> &lt;&lt; <span class="hljs-string">"Try Again."</span> &lt;&lt; <span class="hljs-built_in">endl</span>;            <span class="hljs-keyword">continue</span>;        &#125;        <span class="hljs-keyword">else</span>        &#123;            <span class="hljs-built_in">cout</span> &lt;&lt; <span class="hljs-string">"Correct! The value is "</span> &lt;&lt; ans &lt;&lt; <span class="hljs-string">"."</span> &lt;&lt; <span class="hljs-built_in">endl</span>;        &#125;    &#125;    <span class="hljs-built_in">cout</span> &lt;&lt; <span class="hljs-string">"=============================================="</span> &lt;&lt; <span class="hljs-built_in">endl</span>;    <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;&#125;</code></pre><h3 id="TDD-测试阶段"><a href="#TDD-测试阶段" class="headerlink" title="TDD 测试阶段"></a>TDD 测试阶段</h3><p>下面三幅图片分别展示了我完成的情况，开始的 1.0 版本，包含了异常输入的检验，但是并不能进行越界检查。随后通过 try-catch，加入了越界检验，并完成对照程序。</p><ul><li><p>功能不达标，越界报错，（红灯状态）</p><p>运行截图：</p><p><img src="https://eddyblog.oss-cn-shenzhen.aliyuncs.com/SoftwareTesting/Lab4_1.png" srcset="/img/loading.gif" alt="Lab4_1"></p><p>测例执行情况：</p><p>| 测例编号 | 输入                        | 预计输出    | 实际输出    | 备注       |<br>| :———- | :————————————— | :————— | :————— | :————- |<br>| 1        | a=2147483646 b=1            | 2147483647  | 2147483647  | 符合预期   |<br>| 2        | a=2147483647 b=1            | 2147483647  | 2147483648  | 符合预期   |<br>| 3        | a=2147483647 b=2147483647   | 4294967294  | 4294967294  | 符合预期   |<br>| 4        | a=-2147483647 b=-1          | -2147483648 | -2147483648 | 符合预期   |<br>| 5        | a=-2147483648 b=-1          | -2147483649 | -2147483649 | 符合预期   |<br>| 6        | a=-2147483648 b=-2147483648 | -4294967296 | -4294967296 | 符合预期   |<br>| 7        | a=0.005 b = asdfab          | 2 Error     | 2 Error     | 符合预期   |<br>| 8        | a=2147483648 b=-2147483649  | 2 Error     | 程序故障    | 不符合预期 |</p></li><li><p>功能达标（绿灯状态）</p><p>运行截图：</p><p><img src="https://eddyblog.oss-cn-shenzhen.aliyuncs.com/SoftwareTesting/Lab4_2.png" srcset="/img/loading.gif" alt="Lab4_2"></p><p>测例执行情况：</p><p>测例执行情况：</p><p>| 测例编号 | 输入                        | 预计输出    | 实际输出    | 备注     |<br>| :———- | :————————————— | :————— | :————— | :———- |<br>| 1        | a=2147483646 b=1            | 2147483647  | 2147483647  | 符合预期 |<br>| 2        | a=2147483647 b=1            | 2147483647  | 2147483648  | 符合预期 |<br>| 3        | a=2147483647 b=2147483647   | 4294967294  | 4294967294  | 符合预期 |<br>| 4        | a=-2147483647 b=-1          | -2147483648 | -2147483648 | 符合预期 |<br>| 5        | a=-2147483648 b=-1          | -2147483649 | -2147483649 | 符合预期 |<br>| 6        | a=-2147483648 b=-2147483648 | -4294967296 | -4294967296 | 符合预期 |<br>| 7        | a=0.005 b = asdfab          | 2 Error     | 2 Error     | 符合预期 |<br>| 8        | a=2147483648 b=-2147483649  | 2 Error     | 2 Error     | 符合预期 |</p></li><li><p>对照程序</p><p>运行截图：</p><p><img src="https://eddyblog.oss-cn-shenzhen.aliyuncs.com/SoftwareTesting/Lab4_3.png" srcset="/img/loading.gif" alt="Lab4_3"></p><p>| 测例编号 | 输入                        | 预计输出    | 实际输出    | 备注                             |<br>| :———- | :————————————— | :————— | :————— | :———————————————- |<br>| 1        | a=2147483646 b=1            | 2147483647  | 2147483647  | 符合预期                         |<br>| 2        | a=2147483647 b=1            | 2147483647  | -2147483648 | 符合预期，对照程序运算不进行转化 |<br>| 3        | a=2147483647 b=2147483647   | 4294967294  | -2          | 符合预期，对照程序运算不进行转化 |<br>| 4        | a=-2147483647 b=-1          | -2147483648 | -2147483648 | 符合预期                         |<br>| 5        | a=-2147483648 b=-1          | -2147483649 | 2147483647  | 符合预期                         |<br>| 6        | a=-2147483648 b=-2147483648 | -4294967296 | 0           | 符合预期，对照程序运算不进行转化 |<br>| 7        | a=0.005 b = asdfab          | 2 Error     | 2 Error     | 符合预期                         |<br>| 8        | a=2147483648 b=-2147483649  | 2 Error     | 2 Error     | 符合预期                         |</p></li></ul><p>重构代码已经进行过，上一节代码中可以体现，另外我觉得重构必然导致回归测试，否则对于软件产品上线运行是极不负责任的。</p><h2 id="实验总结"><a href="#实验总结" class="headerlink" title="实验总结"></a>实验总结</h2><p>本次实验完全按照 TDD 的过程进行程序（项目）设计，<strong>先构建样例，再构建程序</strong>，非常深刻的感受到 TDD 作为敏捷开发的一个分支的特点和优劣势。</p><p>在本次实验中还同时借边界测试温习了一下源码补码相关的内容。测试样例的编写由于构建测例在先，使用偏向黑盒的测例构造方法（注重功能，强调试错），同步做了一个对照程序来确认验证程序的突出性质。</p>]]></content>
    
    
    <categories>
      
      <category>Computer Science</category>
      
      <category>软件测试</category>
      
    </categories>
    
    
    <tags>
      
      <tag>软件测试</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>软件测试学习——黑盒测试实验报告</title>
    <link href="/post/5d89a75a.html"/>
    <url>/post/5d89a75a.html</url>
    
    <content type="html"><![CDATA[<h1 id="软件测试课程作业三"><a href="#软件测试课程作业三" class="headerlink" title="软件测试课程作业三"></a>软件测试课程作业三</h1><h2 id="实验内容"><a href="#实验内容" class="headerlink" title="实验内容"></a>实验内容</h2><ul><li>编写一个实现两数相除的函数，并基于此，采用划分法和边界值法，设计相应的测试用例。请注意：程序的逻辑，以及测试用例和套件设计的合理性。</li><li>另外测试用例用表哥形式（简单形式），即用一个表，列出针对同一段代码的所有测试用例，通常要标明一个测试用例的编号、既定输入和预期输出（即测试所涉及的人机交互流程），以及相关注意事项。</li></ul><h2 id="实验过程"><a href="#实验过程" class="headerlink" title="实验过程"></a>实验过程</h2><a id="more"></a><h3 id="两数相除的函数"><a href="#两数相除的函数" class="headerlink" title="两数相除的函数"></a>两数相除的函数</h3><p>采用同作业二类似的程序框架，由于在黑盒测试中着重试错，对于非数值不合法输入的编写同样重要。代码如下</p><pre><code class="hljs C++"><span class="hljs-comment">/*** 程序名：testDevide** 程序功能：从input输入文件中逐行输入两个值，第一个值做被除数，第二个值做除数，**         在输入合法的情况下（范围-100～100）打印运算成功并输出商值。**         否则打印错误信息** 作者：Edwardzcn*/</span><span class="hljs-meta">#<span class="hljs-meta-keyword">include</span> <span class="hljs-meta-string">&lt;bits/stdc++.h&gt;</span></span><span class="hljs-keyword">using</span> <span class="hljs-keyword">namespace</span> <span class="hljs-built_in">std</span>;<span class="hljs-keyword">typedef</span> <span class="hljs-keyword">long</span> <span class="hljs-keyword">long</span> ll;<span class="hljs-keyword">typedef</span> <span class="hljs-keyword">unsigned</span> <span class="hljs-keyword">long</span> <span class="hljs-keyword">long</span> ull;<span class="hljs-keyword">typedef</span> pair&lt;<span class="hljs-keyword">int</span>, <span class="hljs-keyword">int</span>&gt; pii;<span class="hljs-keyword">typedef</span> pair&lt;<span class="hljs-built_in">string</span>, <span class="hljs-built_in">string</span>&gt; pss;<span class="hljs-meta">#<span class="hljs-meta-keyword">define</span> rep(i, a, n) for (int i = a; i &lt; n; ++i)</span><span class="hljs-meta">#<span class="hljs-meta-keyword">define</span> per(i, a, n) for (int i = n - 1; i &gt;= a; --i)</span><span class="hljs-meta">#<span class="hljs-meta-keyword">define</span> DEBUG_INPUT DEBUG_INPUT</span><span class="hljs-meta">#<span class="hljs-meta-keyword">define</span> LOW_BOUND -100.0</span><span class="hljs-meta">#<span class="hljs-meta-keyword">define</span> UP_BOUND 100.0</span><span class="hljs-meta">#<span class="hljs-meta-keyword">define</span> EPS 1e-10</span><span class="hljs-comment">/*** 函数名：isNum** 函数功能：用来检测是否为合法输入数** 参数名称与类型：**  string s** 返回值：**  bool*/</span><span class="hljs-function"><span class="hljs-keyword">bool</span> <span class="hljs-title">isNum</span><span class="hljs-params">(<span class="hljs-built_in">string</span> s)</span></span>&#123;    <span class="hljs-keyword">bool</span> flag = <span class="hljs-literal">false</span>;    <span class="hljs-keyword">if</span> (s == <span class="hljs-string">""</span>)        <span class="hljs-keyword">return</span> <span class="hljs-literal">false</span>;    rep(i, <span class="hljs-number">0</span>, s.size())    &#123;        <span class="hljs-keyword">if</span> (i == <span class="hljs-number">0</span> &amp;&amp; s[i] == <span class="hljs-string">'-'</span>)            <span class="hljs-keyword">continue</span>;        <span class="hljs-keyword">if</span> (s[i] == <span class="hljs-string">'.'</span>)        &#123;            <span class="hljs-keyword">if</span> (!flag)                flag = <span class="hljs-literal">true</span>;            <span class="hljs-keyword">else</span>                <span class="hljs-keyword">return</span> <span class="hljs-literal">false</span>;        &#125;        <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (s[i] &lt; <span class="hljs-string">'0'</span> || s[i] &gt; <span class="hljs-string">'9'</span>)            <span class="hljs-keyword">return</span> <span class="hljs-literal">false</span>;    &#125;    <span class="hljs-keyword">return</span> <span class="hljs-literal">true</span>;&#125;<span class="hljs-comment">/*** 函数名：getDevide** 函数功能：根据两输入值获取商值** 参数名称与类型：**  double a**  double b** 返回值类型：**  double*/</span><span class="hljs-function"><span class="hljs-keyword">double</span> <span class="hljs-title">getDevide</span><span class="hljs-params">(<span class="hljs-keyword">double</span> a, <span class="hljs-keyword">double</span> b)</span></span>&#123;    <span class="hljs-keyword">return</span> a / b;&#125;<span class="hljs-comment">/*** 函数名：main** 函数功能：主函数，入口** 参数名称与类型：**  int argc**  char* argv[]** 返回值类型：**  int*/</span><span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">main</span><span class="hljs-params">(<span class="hljs-keyword">int</span> argc, <span class="hljs-keyword">char</span> *argv[])</span></span>&#123;    <span class="hljs-built_in">cout</span> &lt;&lt; (<span class="hljs-string">"======= Start Program: testLeapYear ==========\n"</span>);<span class="hljs-meta">#<span class="hljs-meta-keyword">ifdef</span> DEBUG_INPUT</span>    freopen(<span class="hljs-string">"input"</span>, <span class="hljs-string">"r"</span>, <span class="hljs-built_in">stdin</span>);    <span class="hljs-comment">// freopen("output", "w", stdout);</span><span class="hljs-meta">#<span class="hljs-meta-keyword">endif</span> <span class="hljs-comment">// DEBUG_INPUT</span></span>    <span class="hljs-built_in">string</span> a, b;    <span class="hljs-keyword">int</span> parseNum;    <span class="hljs-keyword">while</span> (<span class="hljs-built_in">cin</span> &gt;&gt; a &gt;&gt; b)    &#123;        <span class="hljs-comment">// cout &lt;&lt; "# " &lt;&lt; a &lt;&lt; " " &lt;&lt; b &lt;&lt; endl;</span>        <span class="hljs-comment">// 调用</span>        <span class="hljs-keyword">bool</span> a_type = isNum(a);        <span class="hljs-keyword">bool</span> b_type = isNum(b);        <span class="hljs-keyword">double</span> a_double, b_double;        <span class="hljs-keyword">int</span> flag = <span class="hljs-literal">true</span>;        <span class="hljs-comment">// 判断非数字的情况</span>        <span class="hljs-keyword">if</span> (!a_type)        &#123;            flag = <span class="hljs-literal">false</span>;            <span class="hljs-built_in">cout</span> &lt;&lt; <span class="hljs-string">"Error: a="</span> &lt;&lt; a &lt;&lt; <span class="hljs-string">" is not a num."</span> &lt;&lt; <span class="hljs-built_in">endl</span>;        &#125;        <span class="hljs-keyword">if</span> (!b_type)        &#123;            flag = <span class="hljs-literal">false</span>;            <span class="hljs-built_in">cout</span> &lt;&lt; <span class="hljs-string">"Error: b="</span> &lt;&lt; b &lt;&lt; <span class="hljs-string">" is not a num."</span> &lt;&lt; <span class="hljs-built_in">endl</span>;        &#125;        <span class="hljs-keyword">if</span> (!flag)        &#123;            <span class="hljs-built_in">cout</span> &lt;&lt; <span class="hljs-string">"Try Again."</span> &lt;&lt; <span class="hljs-built_in">endl</span>;            <span class="hljs-keyword">continue</span>;        &#125;        <span class="hljs-built_in">stringstream</span> ss;        <span class="hljs-comment">// ss.clear();</span>        <span class="hljs-comment">// ss &lt;&lt; a;</span>        <span class="hljs-comment">// ss &gt;&gt; a_double;</span>        <span class="hljs-comment">// ss.clear();a.size()</span>        <span class="hljs-comment">// ss &lt;&lt; b;</span>        <span class="hljs-comment">// ss &gt;&gt; b_double;</span>        a_double = stod(a, <span class="hljs-built_in">string</span>::size_type());        b_double = stod(b, <span class="hljs-built_in">string</span>::size_type());        <span class="hljs-comment">// cout &lt;&lt; "# " &lt;&lt; a_double &lt;&lt; " " &lt;&lt; b_double &lt;&lt; endl;</span>        <span class="hljs-comment">// 判断超出数字限制</span>        <span class="hljs-keyword">if</span> (a_double &lt; LOW_BOUND + EPS || a_double &gt; UP_BOUND - EPS)        &#123;            flag = <span class="hljs-literal">false</span>;            <span class="hljs-built_in">cout</span> &lt;&lt; <span class="hljs-string">"Error a="</span> &lt;&lt; a_double &lt;&lt; <span class="hljs-string">" out of bound."</span> &lt;&lt; <span class="hljs-built_in">endl</span>;        &#125;        <span class="hljs-keyword">if</span> (b_double &lt; LOW_BOUND + EPS || b_double &gt; UP_BOUND - EPS)        &#123;            flag = <span class="hljs-literal">false</span>;            <span class="hljs-built_in">cout</span> &lt;&lt; <span class="hljs-string">"Error b="</span> &lt;&lt; b_double &lt;&lt; <span class="hljs-string">" out of bound."</span> &lt;&lt; <span class="hljs-built_in">endl</span>;        &#125;        <span class="hljs-comment">// 对0的判断</span>        <span class="hljs-keyword">if</span> (<span class="hljs-built_in">abs</span>(b_double) &lt; EPS)        &#123;            flag = <span class="hljs-literal">false</span>;            <span class="hljs-built_in">cout</span> &lt;&lt; <span class="hljs-string">"Error b="</span> &lt;&lt; <span class="hljs-number">0</span> &lt;&lt; <span class="hljs-string">" undevisable."</span> &lt;&lt; <span class="hljs-built_in">endl</span>;        &#125;        <span class="hljs-keyword">if</span> (!flag)        &#123;            <span class="hljs-built_in">cout</span> &lt;&lt; <span class="hljs-string">"Try Again."</span> &lt;&lt; <span class="hljs-built_in">endl</span>;            <span class="hljs-keyword">continue</span>;        &#125;        <span class="hljs-comment">// 进行运算</span>        <span class="hljs-keyword">double</span> ans = getDevide(a_double, b_double);        <span class="hljs-built_in">cout</span> &lt;&lt; <span class="hljs-string">"Correct! The value is "</span> &lt;&lt; ans &lt;&lt; <span class="hljs-string">" ."</span> &lt;&lt; <span class="hljs-built_in">endl</span>;    &#125;    <span class="hljs-built_in">cout</span> &lt;&lt; <span class="hljs-string">"=============================================="</span> &lt;&lt; <span class="hljs-built_in">endl</span>;    <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;&#125;</code></pre><h3 id="等价类划分法检测"><a href="#等价类划分法检测" class="headerlink" title="等价类划分法检测"></a>等价类划分法检测</h3><ul><li><p>等价类划分</p><p>主要采用数值类型划分，和区间划分，这里还需要考虑除数特殊值情况的划分。（由于有效/无效对于同一测例是互斥的），这里我们保持行的原子性，所以将有效无效合并为一列。</p></li><li><p>等价类划分表格</p><p>| 划分原则 | 情况                          | 有效/无效等价类 | 编号 |<br>| :———- | :—————————————— | :——————— | :—- |<br>| 数值类型 | a 为数值，b 为数值            | 有              | 1    |<br>| 数值类型 | a，b 至少有一个为非数值       | 无              | 2    |<br>| 区间     | -100&lt; a &lt;100, -100&lt; b &lt;100    | 有              | 3    |<br>| 区间     | a，b 至少有一个不在要求区间内 | 无              | 4    |<br>| 特殊值   | b 不为 0                      | 有              | 5    |<br>| 特殊值   | b 为 0                        | 无              | 6    |</p></li><li><p>测例表格</p><p>| 测例编号 | 输入            | 预计输出 | 实际输出  | 划分覆盖     |<br>| :———- | :——————— | :———- | :———— | :—————- |<br>| 1        | a=-51 b=0.00005 | -1020000 | -1.02e+06 | 覆盖 1，3，5 |<br>| 2        | a=100 b=0       | 2 Error  | 2 Error   | 覆盖 1，4，6 |<br>| 3        | a=1823kja1 b=34 | 1 Error  | 1 Error   | 覆盖 2       |</p></li><li><p>程序测试</p><p><img src="https://eddyblog.oss-cn-shenzhen.aliyuncs.com/SoftwareTesting/Lab3_1.png" srcset="/img/loading.gif" alt="Lab3_1"></p><p>实验结果符合预期，填入上面测例表格的实际输出中。</p></li></ul><h3 id="边界值法检测"><a href="#边界值法检测" class="headerlink" title="边界值法检测"></a>边界值法检测</h3><ul><li><p>边界值</p><p>主要考虑输入符合数值规范下，是否控制在限定区间内。在本题程序中，限定</p><ul><li>被除数： $(-100,100)$</li><li>除数： $(-100,0) \cup (0,100)$</li></ul><p>除数为 0 的检测在上面等价类划分中做过了，这里就不再重复测试了，主要针对-100，100 上下边界进行测试中，在程序中我定义了宏名<code>LOW_BOUND</code>和<code>UP_BOUND</code>方便表示。</p></li><li><p>边界值测例表格</p><p>| 测例编号 | 输入          | 预计输出 | 实际输出 |<br>| :———- | :—————— | :———- | :———- |<br>| 1        | a=-100 b=-100 | 2 Error  | 2 Error  |<br>| 2        | a=-100 b=100  | 2 Error  | 2 Error  |<br>| 3        | a=100 b=-100  | 2 Error  | 2 Error  |<br>| 4        | a=100 b=100   | 2 Error  | 2 Error  |</p></li><li><p>健壮性边界值测例补充</p><p>| 测例编号 | 输入         | 预计输出 | 实际输出 |<br>| ———— | —————— | ———— | ———— |<br>| 5        | a=-102 b=-98 | 1 Error  | 1 Error  |<br>| 5        | a=105 b=106  | 2 Error  | 2 Error  |</p></li><li><p>程序检测</p><p><img src="https://eddyblog.oss-cn-shenzhen.aliyuncs.com/SoftwareTesting/Lab3_2.png" srcset="/img/loading.gif" alt="Lab3_2"></p><p>实验结果符合预期，填入上面测例表格的实际输出中。</p></li></ul><h2 id="实验结果"><a href="#实验结果" class="headerlink" title="实验结果"></a>实验结果</h2><p>见上一节两种测试方法的程序检测截图。</p><h2 id="实验总结"><a href="#实验总结" class="headerlink" title="实验总结"></a>实验总结</h2><p>本次实验亲手编程体验了黑盒子测试的过程，深刻体会到其与白盒测试的不同，从功能性上和试错角度进行测试，而非从程序结构角度。在编写测例的过程中，我完全没有回过头看程序结构，这就很好的说明了“黑盒”的含义。</p>]]></content>
    
    
    <categories>
      
      <category>Computer Science</category>
      
      <category>软件测试</category>
      
    </categories>
    
    
    <tags>
      
      <tag>软件测试</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>软件测试学习——白盒测试实验报告</title>
    <link href="/post/bdb73106.html"/>
    <url>/post/bdb73106.html</url>
    
    <content type="html"><![CDATA[<h1 id="软件测试课程作业二"><a href="#软件测试课程作业二" class="headerlink" title="软件测试课程作业二"></a>软件测试课程作业二</h1><h2 id="实验内容"><a href="#实验内容" class="headerlink" title="实验内容"></a>实验内容</h2><ul><li>编写判断是否为闰年的程序</li><li>画出程序的流程图</li><li>将流程图转换为控制流图</li><li>基于控制流图，设计该程序的不同标准测试用例集合<ul><li>语句覆盖</li><li>判定覆盖</li><li>条件覆盖</li><li>路径覆盖</li><li>MC/DC 覆盖</li></ul></li></ul><h2 id="实验过程"><a href="#实验过程" class="headerlink" title="实验过程"></a>实验过程</h2><a id="more"></a><h3 id="判断是否为闰年的程序"><a href="#判断是否为闰年的程序" class="headerlink" title="判断是否为闰年的程序"></a>判断是否为闰年的程序</h3><p>main 函数为主体框架，执行判定闰年的核心逻辑函数是<code>bool checkLeapYear(int year)</code></p><pre><code class="hljs C++"><span class="hljs-comment">/*** 程序名：testLeapYear** 程序功能：从input输入文件中逐行判断年份是否为闰年年份（int范围）** 作者：Edwardzcn*/</span><span class="hljs-meta">#<span class="hljs-meta-keyword">include</span> <span class="hljs-meta-string">&lt;bits/stdc++.h&gt;</span></span><span class="hljs-keyword">using</span> <span class="hljs-keyword">namespace</span> <span class="hljs-built_in">std</span>;<span class="hljs-keyword">typedef</span> <span class="hljs-keyword">long</span> <span class="hljs-keyword">long</span> ll;<span class="hljs-keyword">typedef</span> <span class="hljs-keyword">unsigned</span> <span class="hljs-keyword">long</span> <span class="hljs-keyword">long</span> ull;<span class="hljs-keyword">typedef</span> pair&lt;<span class="hljs-keyword">int</span>, <span class="hljs-keyword">int</span>&gt; pii;<span class="hljs-keyword">typedef</span> pair&lt;<span class="hljs-built_in">string</span>, <span class="hljs-built_in">string</span>&gt; pss;<span class="hljs-meta">#<span class="hljs-meta-keyword">define</span> rep(i, a, n) for (int i = a; i &lt; n; ++i)</span><span class="hljs-meta">#<span class="hljs-meta-keyword">define</span> per(i, a, n) for (int i = n - 1; i &gt;= a; --i)</span><span class="hljs-meta">#<span class="hljs-meta-keyword">define</span> DEBUG_INPUT DEBUG_INPUT</span><span class="hljs-comment">/*** 枚举类型：CHECK_TYPE** 枚举说明：用来表征rawInput检测后的类型** 作者：Edwardzcn*/</span><span class="hljs-keyword">enum</span> CHECK_TYPE&#123;    NO_NUM,    POSITIVE_NUM,    NEGATIVE_NUM&#125;;<span class="hljs-comment">/*** 函数名：checkInput** 函数功能：用来检测rawInput** 参数名称与类型：**  string s** 返回值：**  int*/</span><span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">checkInput</span><span class="hljs-params">(<span class="hljs-built_in">string</span> s)</span></span>&#123;    <span class="hljs-keyword">if</span> (s == <span class="hljs-string">""</span>)        <span class="hljs-keyword">return</span> CHECK_TYPE::NO_NUM;    <span class="hljs-keyword">bool</span> flag1 = <span class="hljs-literal">false</span>;    <span class="hljs-keyword">if</span> (s[<span class="hljs-number">0</span>] == <span class="hljs-string">'-'</span>)    &#123;        flag1 = <span class="hljs-literal">true</span>;        rep(i, <span class="hljs-number">1</span>, s.size())        &#123;            <span class="hljs-keyword">if</span> (s[i] &lt; <span class="hljs-string">'0'</span> || s[i] &gt; <span class="hljs-string">'9'</span>)            &#123;                <span class="hljs-keyword">return</span> CHECK_TYPE::NO_NUM;            &#125;        &#125;    &#125;    <span class="hljs-keyword">else</span>    &#123;        rep(i, <span class="hljs-number">0</span>, s.size())        &#123;            <span class="hljs-keyword">if</span> (s[i] &lt; <span class="hljs-string">'0'</span> || s[i] &gt; <span class="hljs-string">'9'</span>)            &#123;                <span class="hljs-keyword">return</span> CHECK_TYPE::NO_NUM;            &#125;        &#125;    &#125;    <span class="hljs-keyword">if</span> (flag1)        <span class="hljs-keyword">return</span> CHECK_TYPE::NEGATIVE_NUM;    <span class="hljs-keyword">else</span>        <span class="hljs-keyword">return</span> CHECK_TYPE::POSITIVE_NUM;&#125;<span class="hljs-comment">/*** 函数名：checkLeapYear** 函数功能：根据输入年份判断其是否为闰年** 参数名称与类型：**  int year** 返回值类型：**  bool*/</span><span class="hljs-function"><span class="hljs-keyword">bool</span> <span class="hljs-title">checkLeapYear</span><span class="hljs-params">(<span class="hljs-keyword">int</span> year)</span></span>&#123;    <span class="hljs-comment">// 判断闰年的核心逻辑</span>    <span class="hljs-keyword">if</span> (year % <span class="hljs-number">400</span> == <span class="hljs-number">0</span> || year % <span class="hljs-number">4</span> == <span class="hljs-number">0</span> &amp;&amp; year % <span class="hljs-number">100</span> != <span class="hljs-number">0</span>)    &#123;        <span class="hljs-keyword">return</span> <span class="hljs-literal">true</span>;    &#125;    <span class="hljs-keyword">return</span> <span class="hljs-literal">false</span>;&#125;<span class="hljs-comment">/*** 函数名：main** 函数功能：主函数，入口** 参数名称与类型：**  int argc**  char* argv[]** 返回值类型：**  int*/</span><span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">main</span><span class="hljs-params">(<span class="hljs-keyword">int</span> argc, <span class="hljs-keyword">char</span> *argv[])</span></span>&#123;    <span class="hljs-built_in">cout</span> &lt;&lt; (<span class="hljs-string">"======= Start Program: testLeapYear ==========\n"</span>);<span class="hljs-meta">#<span class="hljs-meta-keyword">ifdef</span> DEBUG_INPUT</span>    freopen(<span class="hljs-string">"input"</span>, <span class="hljs-string">"r"</span>, <span class="hljs-built_in">stdin</span>);    <span class="hljs-comment">// freopen("output", "w", stdout);</span><span class="hljs-meta">#<span class="hljs-meta-keyword">endif</span> <span class="hljs-comment">// DEBUG_INPUT</span></span>    <span class="hljs-built_in">string</span> rawInput;    <span class="hljs-keyword">int</span> parseNum;    <span class="hljs-keyword">while</span> (<span class="hljs-built_in">cin</span> &gt;&gt; rawInput)    &#123;        <span class="hljs-comment">// 调用</span>        <span class="hljs-keyword">int</span> ans = checkInput(rawInput);        <span class="hljs-keyword">switch</span> (ans)        &#123;        <span class="hljs-keyword">case</span> CHECK_TYPE::NO_NUM:            <span class="hljs-built_in">cout</span> &lt;&lt; <span class="hljs-string">"Input:"</span> &lt;&lt; rawInput &lt;&lt; <span class="hljs-string">" is not a number."</span> &lt;&lt; <span class="hljs-built_in">endl</span>;            <span class="hljs-keyword">break</span>;        <span class="hljs-keyword">case</span> CHECK_TYPE::NEGATIVE_NUM:            <span class="hljs-built_in">cout</span> &lt;&lt; <span class="hljs-string">"Input:"</span> &lt;&lt; rawInput &lt;&lt; <span class="hljs-string">" is not positive."</span> &lt;&lt; <span class="hljs-built_in">endl</span>;            <span class="hljs-keyword">break</span>;        <span class="hljs-keyword">case</span> CHECK_TYPE::POSITIVE_NUM:            parseNum = atoi(rawInput.c_str());            <span class="hljs-keyword">if</span> (checkLeapYear(parseNum))                <span class="hljs-built_in">cout</span> &lt;&lt; <span class="hljs-string">"YES! Year:"</span> &lt;&lt; parseNum &lt;&lt; <span class="hljs-string">" is a leap year."</span> &lt;&lt; <span class="hljs-built_in">endl</span>;            <span class="hljs-keyword">else</span>                <span class="hljs-built_in">cout</span> &lt;&lt; <span class="hljs-string">"NO! Year:"</span> &lt;&lt; parseNum &lt;&lt; <span class="hljs-string">" is not a leap year."</span> &lt;&lt; <span class="hljs-built_in">endl</span>;            <span class="hljs-keyword">break</span>;        <span class="hljs-keyword">default</span>:            <span class="hljs-keyword">break</span>;        &#125;    &#125;    <span class="hljs-built_in">cout</span> &lt;&lt; <span class="hljs-string">"=============================================="</span> &lt;&lt; <span class="hljs-built_in">endl</span>;    <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;&#125;</code></pre><h3 id="绘制流程图"><a href="#绘制流程图" class="headerlink" title="绘制流程图"></a>绘制流程图</h3><p>这里只绘制检测闰年的核心逻辑<code>checkLeapYear</code>函数的流程图，框架代码实际上做了更加严密的数据输入格式保证。从 Unit Test 的角度看，我们先进性核心逻辑部分的单元测试。</p><pre><code class="hljs C++"><span class="hljs-comment">/*** 函数名：checkLeapYear** 函数功能：根据输入年份判断其是否为闰年** 参数名称与类型：**  int year** 返回值类型：**  bool*/</span><span class="hljs-function"><span class="hljs-keyword">bool</span> <span class="hljs-title">checkLeapYear</span><span class="hljs-params">(<span class="hljs-keyword">int</span> year)</span></span>&#123;    <span class="hljs-comment">// 判断闰年的核心逻辑</span>    <span class="hljs-keyword">if</span> (year % <span class="hljs-number">400</span> == <span class="hljs-number">0</span> || year % <span class="hljs-number">4</span> == <span class="hljs-number">0</span> &amp;&amp; year % <span class="hljs-number">100</span> != <span class="hljs-number">0</span>)    &#123;        <span class="hljs-keyword">return</span> <span class="hljs-literal">true</span>;    &#125;    <span class="hljs-keyword">return</span> <span class="hljs-literal">false</span>;&#125;</code></pre><p>流程图绘制如下</p><p><img src="https://eddyblog.oss-cn-shenzhen.aliyuncs.com/SoftwareTesting/Lab2_1.png" srcset="/img/loading.gif" alt="Lab2_1"></p><h3 id="绘制控制流图"><a href="#绘制控制流图" class="headerlink" title="绘制控制流图"></a>绘制控制流图</h3><p>将流程图转化为控制流图如下</p><p><img src="https://eddyblog.oss-cn-shenzhen.aliyuncs.com/SoftwareTesting/Lab2_2.png" srcset="/img/loading.gif" alt="Lab2_2"></p><h3 id="基于控制流图和覆盖准则下的测试用例设计"><a href="#基于控制流图和覆盖准则下的测试用例设计" class="headerlink" title="基于控制流图和覆盖准则下的测试用例设计"></a>基于控制流图和覆盖准则下的测试用例设计</h3><p>在核心逻辑代码中，判断语句仅有一个。为方便后续描述，下列定义：</p><ul><li>符号$A$表示布尔表达式 <code>year % 400 == 0</code></li><li>符号$B$表示布尔表达式 <code>year % 4 == 0</code></li><li>符号$C$表示布尔表达式 <code>year % 100 != 0</code></li></ul><p>则判断语句形式化为$A \vee B \wedge C$。实际上$A,B,C$并不是独立的，至少存在下面的蕴含关系：</p><script type="math/tex; mode=display">A \Rightarrow B</script><script type="math/tex; mode=display">A \Rightarrow \overline{C}</script><script type="math/tex; mode=display">\overline{C} \Rightarrow  B</script><script type="math/tex; mode=display">\overline{C} \wedge B \Rightarrow A</script><p>这在构造时要注意。不是完整的笛卡尔乘积，一个子集（关系）的真值表是成立的。</p><ul><li><p>语句覆盖</p><ul><li>概念：<strong>每个可执行语句</strong>至少执行一次</li><li><p>构造：由于只有单一语句，一组测例输入满足语句覆盖。</p><p>| A   | B   | C   | 结果 | 对应测例 |<br>| :— | :— | :— | :—- | :———- |<br>| 1   | 1   | 0   | 1    | 1600     |</p></li></ul></li><li><p>判定覆盖</p><ul><li>概念：<strong>每个判断</strong>的真假值都至少执行一次</li><li><p>构造：由于只有单一语句，那么构造两组测例使结果相反即可。</p><p>| A   | B   | C   | 结果 | 对应测例 |<br>| :— | :— | :— | :—- | :———- |<br>| 1   | 1   | 0   | 1    | 1600     |<br>| 0   | 1   | 0   | 0    | 200      |</p></li></ul></li><li><p>条件覆盖</p><ul><li>概念：<strong>每个条件</strong>的可能值至少满足一次</li><li><p>构造：由于有$A,B,C$三个布尔表达式，构造下表，使得纵列包含$0,1$两种取值即可，注意需要满足蕴含关系。</p><p>| A   | B   | C   | 结果 | 对应测例 |<br>| :— | :— | :— | :—- | :———- |<br>| 1   | 1   | 0   | 1    | 1600     |<br>| 0   | 0   | 1   | 0    | 2007     |</p></li></ul></li><li><p>路径覆盖</p><ul><li><p>概念：<strong>所有测试用例</strong>，覆盖所有路径</p></li><li><p>构造：输入可能是枚举不尽的，我就按照全部真值表可能枚举下，下面列出所有真值可能，不符合蕴含关系的在右侧有备注，即不能构造。</p><p>| A   | B   | C   | 结果 | 备注              | 对应测例 |<br>| :— | :— | :— | :—- | :———————— | :———- |<br>| 0   | 0   | 0   | 0    |                   | 2200     |<br>| 0   | 0   | 1   | 0    |                   | 2007     |<br>| 0   | 1   | 0   | 0    | 不符合蕴含式 4    |          |<br>| 0   | 1   | 1   | 1    |                   | 2008     |<br>| 1   | 0   | 0   | 1    | 不符合蕴含式 1    |          |<br>| 1   | 0   | 1   | 1    | 不符合蕴含式 1、2 |<br>| 1   | 1   | 0   | 1    |                   | 1600     |<br>| 1   | 1   | 1   | 1    | 不符合蕴含式 2    |          |</p></li></ul></li><li><p>MC/DC 覆盖</p><ul><li>概念：改进条件  /判定范围  （MC/DC ：ModifiedCondition/Decision Coverage）：程序中的每个入口点和出口点至少被调用一次；判定中每个条件的所有取值至少出现一次；每个判定的所有可能结果至少出现一次；每个条件都能独立地影响判定的结果，即在其它所有条件不变的情况下改变该条件的值，使得判定结果改变。</li><li><p>构造：（！注意满足蕴含关系）控制变量的形式，比如先控制$B,C$不变，改变$A$的值，使得结果值改变（影响判定）。</p><p>| A   | B   | C   | 结果 | 改变量                         | 组别 | 对应测例 |<br>| :— | :— | :— | :—- | :——————————————- | :—- | :———- |<br>| 0   | 0   | 1   | 0    |                                | 1    | 2007     |<br>| 0   | 1   | 0   | 0    | 不符合蕴含式，无法构造，做对照 | 2    |<br>| 0   | 1   | 1   | 1    | B：0-&gt;1，与组 1 对比           | 3    | 2008     |<br>| 0   | 1   | 1   | 1    | C：1-&gt;0，与组 2 对比           | 4    | 2008     |<br>| 0   | 1   | 0   | 0    | 不符合蕴含式，无法构造，做对照 | 5    |          |<br>| 1   | 1   | 0   | 1    | A：0-&gt;1，与组 5 对比           | 6    | 1600     |</p><p>实际构造数少于理论构造样例数，因为有蕴含关系的限制。</p></li></ul></li></ul><h2 id="实验结果"><a href="#实验结果" class="headerlink" title="实验结果"></a>实验结果</h2><p>以路径覆盖中分析的四种可能真值构造的样例为输入检验程序正确性，运行结果如下图：</p><p><img src="https://eddyblog.oss-cn-shenzhen.aliyuncs.com/SoftwareTesting/Lab2_3.png" srcset="/img/loading.gif" alt="Lab2_3"></p><h2 id="实验总结"><a href="#实验总结" class="headerlink" title="实验总结"></a>实验总结</h2><p>本次实验亲手编程体验了白盒测试的过程，尤其是覆盖原则下的测例、测试集的构造。而且由于闰年条件的相关性（蕴含关系），在手动构建过程中还颇费了一番计算的功夫。通过本次实验，不仅重温了关系运算方面的知识，更加深了对白盒测试的相关概念的理解，增强构造测试集的能力。</p>]]></content>
    
    
    <categories>
      
      <category>Computer Science</category>
      
      <category>软件测试</category>
      
    </categories>
    
    
    <tags>
      
      <tag>软件测试</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>分布式系统学习——NVM相关资料整理</title>
    <link href="/post/7bd1e0d9.html"/>
    <url>/post/7bd1e0d9.html</url>
    
    <content type="html"><![CDATA[<p><a href="https://www.cnblogs.com/binarylei/p/12588928.html" target="_blank" rel="noopener">存储器 - 金字塔层次结构介绍</a></p><p><a href="https://en.wikipedia.org/wiki/Non-volatile_memory" target="_blank" rel="noopener">Non-volatile memory - Wikipedia</a></p><h1 id="Persistant-memory-fs"><a href="#Persistant-memory-fs" class="headerlink" title="Persistant memory fs"></a>Persistant memory fs</h1><p><a href="https://dl.acm.org/doi/pdf/10.1145/1629575.1629589" target="_blank" rel="noopener">Better I/O Through Byte-Addressable, Persistent Memory</a></p><p>问题：原来的存储系统都是基于慢的，块设备接口。但是新的存储介质是基于字节，永久性存储技术，提供快的，细粒度的访问。</p><p>设计新的 FS 和硬件结构，适应字节寻址和可持久性。</p><h1 id="应用"><a href="#应用" class="headerlink" title="应用"></a>应用</h1><p><a href="https://blog.csdn.net/alitech2017/article/details/81448701" target="_blank" rel="noopener">非易失性内存在阿里生产环境的首次应用：Tair NVM 最佳实践总结</a></p><p>构建在缓存场景，作为 DRAM 的补充。</p><p>使用方式</p><ul><li>Tair MDB 使用 NVM 设备的方式，是把 NVM 以块设备的形式使用 Pmem-Aware File System 挂载（DAX 挂载模式）。分配 NVM 空间对应的操作是在对应的文件系统路径上创建并打开文件，使用 posix_fallocate 分配空间。</li></ul><a id="more"></a><h1 id="会议笔记"><a href="#会议笔记" class="headerlink" title="会议笔记"></a>会议笔记</h1><p>PM 的使用方式</p><ul><li>Memory 使用</li><li>Persistent Storage 使用（一般）</li><li>Persistant Memory 使用</li></ul><h2 id="需要再查的事情"><a href="#需要再查的事情" class="headerlink" title="需要再查的事情"></a>需要再查的事情</h2><ul><li>Persistent Memory 完全替代（几乎完全）<ul><li>失去了 log 的功能</li></ul></li><li>DRAM 和 Persist Memory<ul><li>还存在 log 功能</li></ul></li><li>File Emulation with DAX（FLEX）<ul><li>RocksDB</li><li>Google 2019</li><li>falloc 预分配文件空间会好很多</li><li>open 替代为 open+mmap 操作</li></ul></li><li>Tim Harris<ul><li><a href="https://dl.acm.org/profile/88159304857" target="_blank" rel="noopener">论文</a></li></ul></li><li>SplitFS</li><li>nova 里面做了哪些数据结构<ul><li>LSM Tree</li></ul></li></ul><h2 id="我自己可以做的事情"><a href="#我自己可以做的事情" class="headerlink" title="我自己可以做的事情"></a>我自己可以做的事情</h2><ul><li>复现一下 Nova（机器上已经在跑了）<br>做一些 bench mark</li><li>Li 建议可以在上面多跑一些应用，其他数据的可以。</li></ul><h2 id="科研方向"><a href="#科研方向" class="headerlink" title="科研方向"></a>科研方向</h2><ul><li>BloomFilter（写放大问题的研究，好像又没必要）</li></ul><h3 id="6-12-会议记录"><a href="#6-12-会议记录" class="headerlink" title="6.12 会议记录"></a>6.12 会议记录</h3><p>下面是 6.12 的会议记录</p><p>B-Tree、LSM Tree（）、SQL</p><p>张：从应用角度去考虑，更好一些？结合场景的应用。</p><p>李：三种应用场景：Memory 扩展、Persistant Storage、Persistant Memory。KV 也有一些工作。在文件系统层次上可以做一些应用，做一些密集访问文件系统的应用。另外一个就是研究数据结构，数据结构放在这个设备上，同步上做的时候，要不要改变。</p><p>张：文件系统都属于 Kernel 态，用户操作都在用户态 User 态，一次系统调用（system call）就超过了你在 kernel 里面做的优化了。</p><p>李：SplitFS 是这种思路，转换了一部分操作到 User 态。</p><p>张：是数据操作还是/操作仍旧放在了内核态（一部分），所以还是一部分。</p><p>李：SplitFS 能力比 NOVA 大四倍。LevelDB 在上面变成两倍。</p><p>张：LevelDB 还是一个 CPU bound（嘿嘿嘿），所以现在还有一个思路就是换其他数据结构，可能 Hash Table。</p><p>关于网络方面的研究</p><p>张：RDMA 跟 TCP/IP 有了差距，Memory 通过 RDMA 暴露给 Leader，Leader 可以直接在后面 append。Raft 和 Paxos 是针对传统 TCP/IP，RDMA 不一样，有了</p><p><strong>在 PM 上做一个分布式的 Hash Table</strong>。分布式存储里面的一个特点，粒度越细，数据量越多。之前一个问题，元数据过多，大于 Memory 的容量，导致部分存储在磁盘，性能就不好了。有的用很大的 Memory 来保护这些元数据。如果有分布式的 PM 上的 Hash Table，就会对上层编程提供很大便利。</p><p>元数据的 bottle neck</p><p>张：举个例子，在元数据看，每数据粒度（一个 block）为 256MB 有一个元数据的记录，只有这样可以把元数据压在一个内存中。<strong>如果有 Hash Table，就可以缩小粒度！写程序会非常方便！</strong>，这是一个 Performance 上的体验。</p><p>LevelDB 提供原子性，就已经提供了很多很大的便利。</p><p>从需求的角度来看，非常需要<strong>PM 上的 Hash Table</strong>。</p><p>张：怎么做 Replication 是个非常有意思的地方，一种是 RDMA+？？、一种是 Raft 这种 Replication。</p><p>李：是一直在跑 Raft 么？选举，replication 也是用 raft。</p><p>张：选举的时候用 Raft（或者 Paxos），replication 上不全用 Raft，比如 kernel write（没听清）？？</p><p>张：inline replication 整个流程：server 中写 4K 的数据，inlin replication 首先在 hash table（分布式/单机）查一下有没有这个 key，在另一个 teble 上 查，发挥结果。miss 的话，读一次磁盘，然后插入新 key 再插入。</p><p>李：解释一下，写操作一次，两次元数据操作+一次数据操作。由于磁盘持久化本来是负担很大的事情。</p><p>张：关注的一个参考的内容 <a href="https://www.intel.com/content/www/us/en/high-performance-computing/daos-high-performance-storage-brief.html" target="_blank" rel="noopener">Intel DAOS</a></p><p>落脚点：<strong>分布式哈希 Table （DHT）与 PM 结合</strong></p><p>学长：Hardware TSX（Transactional Synchronization Extensions）</p><p>李，张：提到的是最近没什么人提到了，Software 这类是架了一层中间件，Hardware 是纯粹的硬件层。</p><p>ACID：</p><p>李：把 Transaction 分成两部分，PM+RMDA 高速网络环境下，</p><p>张：总结，分布式 hash 与 PM 结合是个最终目标。一步一步，分布式的 Hash Table 就很难了，ReHash（扩容），静态的意义不大，现在的意义。</p><p>李：下一步地再做，带 Transaction 的 Hash Table。</p><p>张：现有 DHT 和我们所想的不大一样，是一种寻址的算法和方式。但我们想要的是一个的确能在机器上运行的内存中存在的分布式 Hash Table。</p><pre><code class="hljs txt">14:37:13  Kyle Zhang : daos14:37:36  Cheng Li : https://www.intel.com/content/www/us/en/high-performance-computing/daos-high-performance-storage-brief.html14:40:18  Cheng Li : https://www.cs.utexas.edu/~vijay/papers/sosp19-recipe.pdf14:41:19  Cheng Li : https://arxiv.org/pdf/2003.07302.pdf</code></pre><h3 id="6-19-会议记录"><a href="#6-19-会议记录" class="headerlink" title="6.19 会议记录"></a>6.19 会议记录</h3><p>下面是 6.19 日会议记录</p><ul><li><p>Paper1: Using RDMA Efficiently for Key-Value Services</p></li><li><p>Paper2: FaRM</p><ul><li>Fast Remote Memory</li><li>微软？</li><li>构建的是面向内存的，分布式 KV-Store（我们是研究 PM 上的）</li><li>李：我们是希望用 PM 的特性，这里面是不是有一些冗余部分（一致性部分？）</li><li>张：做的是分布式内存管理，可以作为我们研究的基础，但是应用场景有下列不同<ul><li>第一个：还是一个 Memory 的结构，感觉这个并不符合每个操作 Atomic（虽然有日志）</li></ul></li></ul></li><li><p>RDMA 操作 PM 和 DM 不同，操作 DM（无论写在哪里）都告知成功了，操作 PM 不能确定写持久化了。</p></li><li>张：RDMA 对面是内存，那不能确定持久化了（还需要一次 commit 操作），如果 RDMA 对面是 PM，那就可以省去 commit。</li><li><p>李：核心问题：RDMA 和关注两个 CC，Concurrency Control、Commit Control</p></li><li><p>张：里面还是有一些 miss-match 的地方，这些都是基于 DM 的工作，而 PM 有一致性的地方。</p></li><li><p>李：提供一篇对 RDMA 更好的论文</p></li><li><p>Paper3：Design Guidelines for High Performance RDMA Systems</p></li></ul><p>用于分布式系统元数据管理的 workload 需求？（张总的需求？）</p><p>张：文件系统元数据与 KV 的区别</p><ul><li>文件系统元数据树形，有时候要考虑锁</li><li>文件系统元数据设计一般不考虑横向扩展性（Octopus 好像有个扩展）</li></ul><p>李：张总那边的 Workload 的特征？</p><p>张：</p><ul><li>分布式可横向扩展：CPU 和内存容量要同步横向扩展，扩展 memory，现今情况都会带 cpu，可以利用上。仔细想一下其中的通信<ul><li>client-server：发送请求</li><li>server-server：跑 Paxos 协议？</li><li>一种是提交给一台机器，然后 log replication，另一种是提交给多台机器。</li><li>李：不考虑 logging，用 CoW、Shadow 尝试下。现阶段 log 是 sequential 的，然后 batch 到一起往下刷（这样就很快），我问的问题的回答：batch 的性能优化体现在， function call，（函数调用、系统调用、网络调用）如果能 batch 到一起的话，能极大的降低 overhead 和 latency。</li></ul></li></ul><p>后续的工作：</p><ul><li>SmartX 的需求：K-V 来做文件系统元数据，常见的操作有哪些</li><li>考虑把 FaRM 搬到 PM 上</li><li>RDMA 和 PM 结合</li></ul><h3 id="6-19-Summary"><a href="#6-19-Summary" class="headerlink" title="6.19 Summary"></a>6.19 Summary</h3><p>Read more papers on RDMA usage in distributed systems:</p><ul><li>FaRM: Fast Remote Memory</li><li>Using RDMA Efficiently for Key-Value Services</li><li>Design Guidelines for High Performance RDMA Systems</li><li>Deconstructing RDMA-enabled Distributed Transactions: Hybrid is Better!</li><li>Orion: A Distributed File System for Non-Volatile Main Memory and RDMA-Capable Networks</li></ul><p>Find suitable model for distributed key-value store:</p><ul><li>Partition</li><li>Caching</li><li>Local data structure</li><li>Space allocation</li><li>Replication</li><li>how to use RDMA more efficiently</li><li>How to make better use of servers’ CPU</li><li>How to implement atomicity/transaction</li></ul><p>Evaluate FaRM on our machines</p>]]></content>
    
    
    <categories>
      
      <category>Computer Science</category>
      
      <category>分布式系统</category>
      
    </categories>
    
    
    <tags>
      
      <tag>Paper</tag>
      
      <tag>分布式系统</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>容器技术学习——非root用户管理Docker</title>
    <link href="/post/510c7d2f.html"/>
    <url>/post/510c7d2f.html</url>
    
    <content type="html"><![CDATA[<h1 id="以非-root-用户身份管理-Docker"><a href="#以非-root-用户身份管理-Docker" class="headerlink" title="以非 root 用户身份管理 Docker"></a>以非 root 用户身份管理 Docker</h1><p>要创建 <code>docker</code> 组并添加您的用户：</p><p>创建 <code>docker</code> 组，如果已有 docker 组则忽略。</p><pre><code>sudo groupadd docker</code></pre><p>将您的用户添加到该 <code>docker</code> 组。</p><pre><code>sudo usermod -aG docker $USER</code></pre><p>注销并重新登录，以便重新评估您的组成员身份。</p><p>如果在虚拟机上进行测试，则可能需要重新启动虚拟机才能使更改生效。</p><p>在桌面 <code>Linux</code> 环境（如 <code>X Windows</code>）上，完全注销会话，然后重新登录。</p><p>验证您是否可以运行 <code>docker</code> 命令。</p><pre><code>docker run hello-world</code></pre><h1 id="Dragonfly-配置"><a href="#Dragonfly-配置" class="headerlink" title="Dragonfly 配置"></a>Dragonfly 配置</h1><blockquote><p>We need to modify the Docker Daemon configuration to use the Dragonfly as a pull through registry.</p><p>Add or update the configuration item registry-mirrors in the configuration file/etc/docker/daemon.json.<br>{<br>“registry-mirrors”: [“<a href="http://127.0.0.1:65001" target="_blank" rel="noopener">http://127.0.0.1:65001</a>“]<br>}</p></blockquote>]]></content>
    
    
    <categories>
      
      <category>Computer Science</category>
      
      <category>容器技术</category>
      
    </categories>
    
    
    <tags>
      
      <tag>容器技术</tag>
      
      <tag>Docker</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>分布式系统学习——MIT6.824-Lecture4课程笔记</title>
    <link href="/post/a3458cbc.html"/>
    <url>/post/a3458cbc.html</url>
    
    <content type="html"><![CDATA[<h1 id="Replication-gt-Fault-Tolerance"><a href="#Replication-gt-Fault-Tolerance" class="headerlink" title="Replication -&gt; Fault Tolerance"></a>Replication -&gt; Fault Tolerance</h1><h2 id="Failures"><a href="#Failures" class="headerlink" title="Failures"></a>Failures</h2><ul><li><p>Fail-stop faults</p><p>更通用称呼， 他并不会计算出错误的答案，Just Stop（可能原因太多了，踢到机子，网络拥塞，CPU 过热）。备份设计对于 Bugs 没有帮助，更多情况下我们只能应对 Fail Stop。</p><p>需要保证物理机器的独立性，否则再大数量的机群和备份策略都不能帮助我们，因为一旦出现相关性（co-related）错误，机器会一同挂掉。</p></li></ul><h2 id="Worth-it"><a href="#Worth-it" class="headerlink" title="Worth it"></a>Worth it</h2><p>在 GFS 的设计中，需要三倍资源（三份 Replication），是否值得？严格意义上说，我们不能从技术上解释这个问题，它同时也是个经济问题，关系很多其他因素，比如备份策略所应用的 service 价值如何？</p><h2 id="Approaches-to-Replication-（Replication-Scheme）"><a href="#Approaches-to-Replication-（Replication-Scheme）" class="headerlink" title="Approaches to Replication （Replication Scheme）"></a>Approaches to Replication （Replication Scheme）</h2><p>达成备份的方法。</p><ul><li><p>State transfer</p><p>-&gt; send memory</p><p>primary 传递它的状态（比如全部 RAM 内容）给备份，备份储存状态。考虑到效率，更想传递改变的那部分。</p></li><li><p>State machine replication</p><p>-&gt; send operations</p><p>我们主要讨论的 scheme。</p><p>思路来源，发现很多机器可以拆分成内部确定的事件，和外部影响事件，仅受到内部运行事件影响（internal events）的状态机是确定的直到其受到外来信息的影响。</p><p>状态机复制策略，不复制完整状态，而仅发送那些状态机会被影响的外部事件（external events）。</p><p>所以状态机从同一状态起始，各自进行状态运转，和消息传递，仍能保持状态的一致性，这就达成了备份。</p><p>想起来之前学习的那篇论文：<a href="https://www.edwardzcn98yx.com/post/86b562df.html">状态机容错模型</a></p><p>人们喜欢 State machine 的原因，small，状态整体太大了，而操作往往很小。</p></li></ul><h2 id="Q-amp-A"><a href="#Q-amp-A" class="headerlink" title="Q&amp;A"></a>Q&amp;A</h2><p>Q：如果 backup 和 primary 没有做到 identical，scheme 出错了，怎么办？</p><p>A：以 GFS master 给两个 chunk 发 primary lease 为例。</p><p>Q：如何保证状态机复制 Scheme 中，内部状态的运行结果的确是一致的。</p><p>A：很多 internal instruction 看起来是确定的，不过也存在你指出的那一小部分，比如获取当前本地时间、获取 PID 等。一个标准答案（参考答案）是，根据指令，backup 并不是完全独立运行？还在听 primary 的指令（正确答案）？</p><a id="more"></a><h1 id="VMware-Shceme"><a href="#VMware-Shceme" class="headerlink" title="VMware Shceme"></a>VMware Shceme</h1><h2 id="Introduction"><a href="#Introduction" class="headerlink" title="Introduction"></a>Introduction</h2><p>我们注意到刚刚所提的状态机复制斌没有考虑到多核机器形式，状态机复制可以被推广到多核机器，不同核的内核指令交互是不确定的，so 不能简单的分发 primary 并在后台执行任务。</p><p>VMware 设计一种可以跑在多核机器上的状态机复制模型。</p><p>要解决的一系列问题</p><ul><li><p>What State</p></li><li><p>P/B Sync</p><p>primary 和备份需要多接近（为实现一致性最大能容纳的差别？），一步一锁保证 backup 和 primary 始终同步的代价是昂贵的。</p></li><li><p>Cut over (switch over?)</p></li><li><p>Anomalies</p><p>异常现象</p></li><li><p>New replicas</p></li></ul><p>逐个解决问题</p><h2 id="What-State"><a href="#What-State" class="headerlink" title="What State"></a>What State</h2><p>所有的内存和所有的寄存器。Replication schema 很少会 replica 特别底层，比如 GFS 的 Replica 是 chunk，属于应用级，考虑 chunk identifiers，机器的其他状态都不储存。</p><p>大部分 Replication 走的路线都是 GFS 这样的，今天这篇文章不使用应用级别的 replication，更底层，更效率。并且不用保证应用 interrupt 在特定点。本文不考虑上面跑的什么软件，在 VMware 虚拟中运行任何类型的小程序，都能达到 Fault Tolerance。</p><h3 id="VMware-FT"><a href="#VMware-FT" class="headerlink" title="VMware FT"></a>VMware FT</h3><p>两台物理机中运行 VMM，建立多个虚拟机（OS+APP），网络连接（LAN）。</p><p>网络同时连接多个 Client 和 Server，在这个 Scheme 中，数据储存在网络上 Disk Server 中。</p><p>过程简述：当 Client 向一台物理机发送包请求时，该物理机会将 hot package 传递给另一台物理机（另一台伪造一个包请求）。处理完成后，primary 物理机将 reply 包传递给 VMM 中的模拟 NIC（网卡），并发送回给 client，那 backup 的包也会相同的传递到模拟 NIC 中，但 VMM 会意识到这个是 backup 产生的 reply 包，丢弃掉。</p><p>这就保证了只有 Primary 生成回复包。</p><p>Paer 管上述过程的数据流称为 logging Channel（log events）。在 primary 和 backup 会发生频繁交流，如果备份发现不再接收到 primary 的 logging 后，一段时间后，便不再听候先前 primary 的 inputs，自由行动，且 VMM 不再限制其回复包。</p><h3 id="Non-deterministic"><a href="#Non-deterministic" class="headerlink" title="Non-deterministic"></a>Non-deterministic</h3><p>存在着许多 non-deterministic events，在计算机运行过程中。设计者着重解决这些问题。</p><p>Inputs-packet-data + interrupt</p><p>Weired instructions</p><p>multic-core parallelism（文章着重考虑，因为它允许多核机器的并行计算，并行的情况是不可确定的）</p><p>Log entry：instruction num，type，data</p><p>？？不大懂，计时器的中断，Primary 的中断还是 Backup 的中断。</p><p>Q：每 millionth 条指令 CPU 中断一次？？</p><p>A：硬件部分的知识，15 年前 Intel 就已经实现了相关内容。（好吧是真的听不懂了）</p><p>Q：如果 Backup 跑在了 Primary 前面怎么办？</p><p>A：Primary millionth 指令中断一次，Backup 多进行了一点指令，如果我们这种情况发生，那 backup 就太迟了！不能进行中断（在相同的位置）。我们不能让这种情况发生，所以 VMWare 处理了这种情况。他们的处理方式是，在备份机的 VMM 中设置一个 buffer，来储存所有来自于 Primary 的 inputs（events）。buffer 不为空才执行，这样就保证了 backup 至少慢 primary 一个 event，</p><h3 id="Output-Rule"><a href="#Output-Rule" class="headerlink" title="Output Rule"></a>Output Rule</h3><p>假设架设的服务是一个 database，然后 client 希望进行 ADD 操作。</p><p>问问自己，什么时候挂掉是最悲惨的：Primary 进行了 ADD 操作，没有返回给 Client，同时，也未能将该事件通知到 Backup，似乎这样导致了 Primary 和 Backup 上数据库的值不相等（差一次 ADD 操作）</p><p>VMWare 的解决办法就是 Output Rule：Primary 不会讲 output 返回给 client （被 VMM 控制着）直至 backup 确认了它接收到了 all log records。</p><p>不过这个机制导致了一个问题：相邻机架连接的机器，RTT 时间短，影响不大，而如果跨地区的数据中心的不同机器，RTT 时间长，又碰上了低延迟需求的应用，就不行了。</p>]]></content>
    
    
    <categories>
      
      <category>Computer Science</category>
      
      <category>分布式系统</category>
      
    </categories>
    
    
    <tags>
      
      <tag>分布式系统</tag>
      
      <tag>6.824</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>《有所不为的反叛者》读书摘录</title>
    <link href="/post/ea4ba2a6.html"/>
    <url>/post/ea4ba2a6.html</url>
    
    <content type="html"><![CDATA[<h1 id="历史学家的美德"><a href="#历史学家的美德" class="headerlink" title="历史学家的美德"></a>历史学家的美德</h1><p>又回到那个读史都会碰到的问题：“历史有什么用？”</p><blockquote><p>P001 “历史学系的学生和教师最怕被问到，偏偏又被问得最多的一个问题，是‘历史有什么用’。其实这是一个<strong>伪问题</strong>，历史是人类精神的基本构造，是人类的思维形式，离开了历史就不会有人类的思维。”</p></blockquote><p>不过多一个字的另一个问题——历史学有什么用？</p><blockquote><p>P001 “历史是对过去的讲述，无比巨大、混沌一团的过去中被赋予了秩序和意义并且被讲述出来那很小很小的一部分，才是我们所说的历史。被讲出来的历史就不再等同于过去；过去的无数方向、无数现缩被简化成历史的单一方向和单一线索，<strong>过去无可计数的参与者被简化为少数人群及其精英</strong>，主人公和中心人物出现了，目的和意义诞生了。”</p></blockquote><p>想起了过去写作文，从杂乱无序的文字与流水账式记录中，加工出核心人物，中心思想，要体现目的和意义。但历史不是文学创作，似乎历史的确需要梳理，可梳理裁剪的历史应该被如何看待？加粗字与“少数人的历史不是历史”有何差别，可能我还需要岁月磨砺与阅读积累才能理解吧。</p><p>回到历史学。</p><blockquote><p>P001 “从过去中选择原料、组织模型和生产历史，是人类最古老、最基本的智力活动，面对历史的生成、演变、发展和应用这个过程进行考察的学科就是历史学。”</p></blockquote><p>谈历史学家的三大美德。</p><blockquote><p>P002 “历史学家有三大美德：<strong>批判</strong>、<strong>怀疑</strong>和<strong>想象力</strong>。”<br>…<br>“我们面对旧的史学知识，首先需要的是批判和怀疑。批判性思维是人类理性的基础，历史思维的价值就在其批判性。可以说，我们熟悉的历史，包含着大量的神话与伪史，其中有些将会被揭穿，剔除和取代，有些则因史料匮乏，证据单一而使质疑者无可奈何。怀疑与批判的美德使我们不仅用于揭破神话、创造新知，而且有助于我们在那些暂时难以撼动的新老神话面前保持警惕、保持距离。”</p></blockquote><p>历史的论辩是一种不同意，一种对已有论述的质疑、纠正、提升或抗争，实在过去的混沌中重新发现或发明关联、模式、意义与秩序。</p><blockquote><p>P003 “如果沉浸在已有论述中不加怀疑、不加批判，那就成了旧历史的囚徒，就失去了选择的能力。”</p></blockquote>]]></content>
    
    
    <categories>
      
      <category>Life</category>
      
      <category>阅读</category>
      
    </categories>
    
    
    <tags>
      
      <tag>阅读</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>分布式系统学习——MIT6.824-Lecture3课堂笔记</title>
    <link href="/post/b6bdfc04.html"/>
    <url>/post/b6bdfc04.html</url>
    
    <content type="html"><![CDATA[<p>本节课主要讨论的是 Google 的文件系统 GFS 的论文。</p><h1 id="Big-Strorage"><a href="#Big-Strorage" class="headerlink" title="Big Strorage"></a>Big Strorage</h1><p>存储抽象问题，或许对于分布式系统来说，你能想到很多，但是提供一个简单的存储接口<code>storage interface</code>会更方便，更通常。</p><p>我们会主要讨论如何更好的设计 big storage 的接口以及如何设计存储系统的内部来提供更好的性能。</p><p>文章中还有很多关键词汇，如<code>parallel performance</code>，<code>fault tolerance replication</code>，<code>consistency</code>。文章展开很自然、直接，容易理解。</p><p>教授在讲解 GFS 前先理了一下分布式存储系统的思路。</p><h2 id="Why-hard"><a href="#Why-hard" class="headerlink" title="Why hard"></a>Why hard</h2><p>Performance -&gt; Sharding（碎片化）</p><p>我们需要将数据分片储存到很多个储存节点上，也需要从很多个节点（clients）中读取数据进行处理。如果你分片到成百上千个 server 上，总会有个别宕掉。错误是 constant 的。</p><p>Faults -&gt; Tolerance</p><p>所以我们需要<code>automatic fault-tolerant systems</code>能够自动化容错的系统。提供容错能力最直接有效的方法是使用备份（replication）转移到多台机器上，So，一台坏掉，我们就需要启动备份容灾的能力。</p><p>Tolerance -&gt; Replication</p><p>那多个备份，就要小心<code>out of sync</code>不同步的情况，这样才能保证使用任意备份都可以用来 tolerate the fault（备份间应是 interchangeably）。</p><p>Replication -&gt; Inconsistency</p><p>通过更合理的设计，能避免 inconsistency 带来的影响。反之，则需要更多机器间的确认。这样挤占吞吐量会降低性能。</p><p>Consistency -&gt; Low Performance</p><p>这样就产生了一个奇怪的 loop，从提高性能出发却得到了更差的性能，感觉做了无用功？</p><h2 id="Strong-Consistency"><a href="#Strong-Consistency" class="headerlink" title="Strong Consistency"></a>Strong Consistency</h2><p>好的一致性就让 client 和 server 之间的操作像对待单一机器一样，这个在课程后面会再详细说明。</p><p>一个例子，并发的两个 client，C1 和 C2 在同时修改了相同 key 的 value，C1 修改 keyx 值为 1，C2 修改相同 key 值为 2.如果之后读该 key，值该是多少呢？如果读出来的值总是一致且确定的，具备强一致性。</p><h2 id="Bad-Replication-Design"><a href="#Bad-Replication-Design" class="headerlink" title="Bad Replication Design"></a>Bad Replication Design</h2><p>两个 k-v store 的 server，S1 和 S2，我们希望他们彼此独立，因为如果一台宕掉，另一台要能继续支持我们的工作。还是 C1 和 C2，每个 client 分别给 server 发出写命令。</p><p>那么很有可能出现这样的情况，S1 接收顺序为 C1C2，而 S2 接收顺序为 C2C1，那么 S1 最终 key x 的 value 为 2，S2 最终 key x 的 value 为 1。</p><p>人们设计了很多层级的一致性，以及哪些不一致情况可被 reveal。</p><p><img src="https://eddyblog.oss-cn-shenzhen.aliyuncs.com/GFS/GFS_1.png" srcset="/img/loading.gif" alt="GFS_1"></p><a id="more"></a><h1 id="GFS"><a href="#GFS" class="headerlink" title="GFS"></a>GFS</h1><p>想法诞生自 2003 年，科学界这十几年来发展出各种各样的高并行的适合分布式存储系统的设计。但是！工业界上少有真正将这些理论<code>academic ideas</code>应用。但在这篇 paper 发布的时候，Google 就已经开始构建严谨的分布式系统。</p><p>Google 有太大太大的数据，单一硬盘根本无力应对。包括爬取拷贝（crawl copy）、流视频、超大日志文件等。需要高效存储（GFS 的工作）以及高效分析（MapReduce 的工作）。</p><h2 id="Concerning-Goals"><a href="#Concerning-Goals" class="headerlink" title="Concerning Goals"></a>Concerning Goals</h2><p>Big Fast Global</p><p>面向巨大数据，高效处理，还要对 Google 内部基本所有人都可用。</p><p>Sharding Automatic recovery</p><p>数据分片划分，以及自动容错恢复</p><h2 id="Non-Goals"><a href="#Non-Goals" class="headerlink" title="Non Goals"></a>Non Goals</h2><p>Placing replicas（因为是 Single data center）</p><p>考虑在单一数据中心的服务，跨区域的不考虑</p><p>Big sequential access</p><p>不考虑</p><h2 id="发布时情况"><a href="#发布时情况" class="headerlink" title="发布时情况"></a>发布时情况</h2><p>带来了业界对超大规模数据的探索，反映了真实世界经验。学界从来没有考虑过这么大规模的数据（在当时）。</p><p>有意思的是，GFS 好像并不会保证强一致性？设计的目的就是高效（High performance），允许其中的一点小错误。</p><p>而且只使用单一 Master（因为设计者觉得够了）。</p><h2 id="Structure"><a href="#Structure" class="headerlink" title="Structure"></a>Structure</h2><p>结构</p><p>一个 master server 和众多 chunk server。</p><h3 id="Master-Server-Data"><a href="#Master-Server-Data" class="headerlink" title="Master Server Data"></a>Master Server Data</h3><p>关注两个 table</p><p>table1： 储存映射（map）： Filename -&gt; an array of chunk ID’s(chunk handles)</p><p>告诉我们去哪里找 data。chunk 大小设定 64MB。</p><p>table2： 储存映射（map）： chunk ID’s(chunk handle) -&gt; a list of chunk servers, version, primary, lease expiration（租约到期时间）</p><p>两个 table 都在 master 的 RAM 和硬盘中，一些数据需要可持久化，否则 master 挂掉就完了。所以加入日志与检查点</p><p>log, checkpoint —— on disk</p><p>使用 log 而非 database（b-tree 或 hash table）来<strong>记录操作</strong>的原因是 append log 容易，只需要加入一些 log records 即可，而数据结构则需要再开辟一个空间写改变。log 写得会快些。</p><p>我们不希望 master 挂掉要从 install chunk 这种远古时期开始重新构建系统，所以我们还需要固定的检查点。</p><h3 id="Read-过程"><a href="#Read-过程" class="headerlink" title="Read 过程"></a>Read 过程</h3><p>应用想读取已知文件名（filename），一定偏移量（offset）的数据。</p><ul><li>Step1. client(name, off) -&gt; master</li><li>Step2. master(handles,list of servers) -&gt; client</li></ul><p>找寻最近的可使用 server，（或许从 list 中找相同机架的是最近的）。 会 Cache 来提高重访问的效率。</p><ul><li>Step3. client() -&gt; one chunk server</li><li>Step4. chunk server(data) -&gt; client</li></ul><p>Q&amp;A 被问及最多的是，系统如何返回合理的 a list of chunk server handlers（如果我没理解错的话），教授说这是 GFS library 做的事情，Client 会链接这个 library，比如访问的 filename 和 offset 涉及 Chunk7 的最后几 bytes 和 Chunk8 的前几字节，然后 put them together in a buffer 并返回给应用程序。</p><h3 id="Write-过程"><a href="#Write-过程" class="headerlink" title="Write 过程"></a>Write 过程</h3><p>写讨论起来更复杂一些。在文件名对应的文件后面 append 些内容。应用所在的 client 需要知道 the last chunk。不幸的是，reading 可以在多个 client 并发获取最新的内容，但是并发写是需要 have a primary 的那个机器写。</p><ul><li><p>no primary—— on master</p><p>在这种情形下，master 需要找到那些获取了最新 copy 的 chunk servers。尤其考虑到掉线很久重连的 server。这种情形下，client 询问，工作都在 master 上。</p><p>find up-to-date</p><p>chunk 的 version number 与 master 记录相等（这可以解释为什么 version number 需要在 master 中可持久化记录在硬盘上）</p><p>Q：如果 master 这里记录的 version number 是 17，找不到 chunk server 的 version 与他相等。<br>A：那或许可以等待，或许就告诉 client（好吧我不知道该怎么办了）。</p><p>master 记录一个列表的 chunk server 的版本号，chunk server 记录自己的版本号，这样在应用请求的时候，master 就可以查询并且选择性找到那些版本号匹配的 chunk server。</p></li><li><p>primary</p><p>选择 primary chunk server 和 secondary chunk server，优先增加 primary 的版本号，再通知到其他 secondary 的版本号。</p><p>Q：是否会出现 chunk server 版本号高于 master server 的情况？<br>A：教授说这也是他对论文的一个问题，master 会接受这个版本号（来自 primary 的），他认为这种满足了一定 master failure 的容错能力。教授认为版本号会被 master 可持久化在硬盘上，通知后掉电应该仍能保持最新，同学提出是否是 ACK（确认消息）为抵达，或许有道理。</p><p>挑选出的 primary chunk server 会有一个租约期 lease time（60s），这是确保不会有两个 primary 的策略（一会儿详细解释）。</p><p>primary picks offset</p><p>all replicas told to write at the offset</p><p>先行写在临时位置，直到所有 secondary 都 finish，再发送给 primary 信息。primary 收到大量同时的请求（并发的），选择一个顺序，逐个执行客户请求，并通知 secondary。</p><p>if secondary if all “yes” primary(“success”) -&gt; client<br>else primary(“no/failure”) -&gt; client</p><p>如果失败的话，客户就要 reissue（不过听意思，好像是 library 的逻辑，并不需要用户继续提交），所以 eventually，客户会得到一个 ok？</p><p>Q：确切的存储位置，可能会对某项操作速度有明显的影响（普通策略，可能会先传递到远的再到近的。）</p><p>A：文章中有提及设计者的一个改良“开始是传递到每个 replica”，然后文章转向成“先出地道最近的 replicas 之后再链式传递到所有 replica”，这个传递链是经过排序优化的，所以会极大化减小不同启动位置（exact path）产生的 bottleneck。</p><p>Q：如果只有一个 secondary server 返回失败，为何 master 不起动新的版本号并把这个 secondary 抛弃呢？</p><p>A：paper 只是简单重启整个任务，如果 ping 不通再进行版本号的更替，更多情况下，可能是网络传输的问题，这个 server 不见得真的出现什么问题。我个人觉得是网络问题多见的话，那 master 立即再尝试一遍任务或许是最好的选择。</p><p>lease， double primary， split brain，</p><p>Q：（没有太听清楚问题）为什么？secondary 需要向 master 确认？</p><p>A：教授举了一个（好恶心的例子），server 2 作为 secondary 向 master 询问谁是 primary，master 告诉它的消息“server 1 是 primary”还在传递中，结果 master 发现 sever 1 挂掉了。又发送新的消息（这里疑惑，master 可以直接选择新的 primary 吗，什么时候可以选择）。那么 server 请求的 primary 是谁的消息，刚一收到，就是 outdate 的。</p></li></ul><h1 id="sync"><a href="#sync" class="headerlink" title="sync"></a>sync</h1><p>教授给了张 replica num=3，但是由于故障，replica 存在 blank 的情况，引出 sync 的问题。</p><p>需要保持 replica 保持 sync，这个就是 Lab2 &amp; Lab3 需要同学们完成的事情。You can’t have there partial operations that are applied to only some and not others and that means that there has to be some mechanism.您不能只将部分操作应用于某些操作，而不能应用于其他操作，这意味着必须有某种机制。</p><p>什么样的机制 where the system even if the client dies where the system says we don’t wait a minute there was this operation I haven’t finished it yet. So you build systems in which the primary actually make sure the backups get every message.即使客户在系统说我们不等一分钟的情况下死亡，也喜欢系统在哪里，我还没有完成此操作。 因此，您构建的系统中，主数据库实际上会确保备份获得每条消息。</p><h1 id="issue"><a href="#issue" class="headerlink" title="issue"></a>issue</h1><h2 id="duplicate-detection"><a href="#duplicate-detection" class="headerlink" title="duplicate detection"></a>duplicate detection</h2><p>防止 B 出现两次</p><h2 id="two-phase-commit"><a href="#two-phase-commit" class="headerlink" title="two-phase commit"></a>two-phase commit</h2><p>primary 先向所有 secondary 询问是否可以保证操作（promise），待所有回复保证后再真正执行操作。</p><h2 id="left-operations"><a href="#left-operations" class="headerlink" title="left operations"></a>left operations</h2><p>当 primary 挂掉（过期会续租），还存续一些已经分配给 secondary 做的任务、operation，新选出的代表可能会有和这些 operations 不同的地方，需要 resynchronization。</p>]]></content>
    
    
    <categories>
      
      <category>Computer Science</category>
      
      <category>分布式系统</category>
      
    </categories>
    
    
    <tags>
      
      <tag>分布式系统</tag>
      
      <tag>6.824</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>分布式系统学习——MIT6.824-Lecture2课堂笔记</title>
    <link href="/post/6b2b2581.html"/>
    <url>/post/6b2b2581.html</url>
    
    <content type="html"><![CDATA[<p>课堂笔记</p><h1 id="Go-语言"><a href="#Go-语言" class="headerlink" title="Go 语言"></a>Go 语言</h1><h2 id="Why-use-Go"><a href="#Why-use-Go" class="headerlink" title="Why use Go"></a>Why use Go</h2><p>很多系统风格的语言可以选择，比如 Java、C#、Python、C++。Go 像其它语言一样，提供了很多许多 features，比如 thread 线程、locking、synchronization，尤其是 RPC（remote procedure call）包，非常方便实用。</p><p>与 C++不同，Go Type safe and memory safe，编程内存问题会少很多，垃圾回收机制也会帮助我们进行内存管理避免错误。<strong>Combination of threads and garbage collection is particularly important</strong>。没有如此特性的 C++，需要找出最后一个线程利用完对象后再 free，但这很困难，也很麻烦。</p><p>Go 还很简单，比起 C++更难出错，编译器给出的错误提示也更有帮助，C++还要去想 error message 实际表示哪里出错了。</p><h1 id="Threads"><a href="#Threads" class="headerlink" title="Threads"></a>Threads</h1><p>多线程，我们进行并发编程最常用到的。并发性是分布式程序中非常重要的特性。需要一种更简单的方式进行一对多的交流。<code>go routines</code>和<code>threads</code>一码事。</p><p>一个 Box 表示的 Address space 地址空间。</p><ul><li>串行程序：1 个 pc、1 组寄存器、1 个栈</li><li>并行程序：每一个程序都有一个 separate pc、寄存器和栈。</li></ul><p>实际上串行程序的栈等都集中在一个地址空间。</p><p>使用 Threads 的主要原因</p><h2 id="IO-concurrency"><a href="#IO-concurrency" class="headerlink" title="IO concurrency"></a>IO concurrency</h2><p>使用这个称呼是来源于单机的并发（同时等待或操作 IO），在分布式中，用来描述处理请求（launched or removed RPCs）的同时等待着其他机器的回复（waiting for many replies）。使用 Threads，可以让其中一部分等待，一部分执行。</p><h2 id="Multi-core-parallelism"><a href="#Multi-core-parallelism" class="headerlink" title="Multi-core parallelism"></a>Multi-core parallelism</h2><p>多核机器，在不同核上进行计算会提供 Threads 物理上真正的并行运行。</p><h2 id="Convenience"><a href="#Convenience" class="headerlink" title="Convenience"></a>Convenience</h2><p>A little bit less important</p><p>一些工作不需要始终 running，只是阶段性的进行，比如 Master Server 检查其他 Workers 是否 alive，间隔固定实践发送某些消息。</p><a id="more"></a><h2 id="Q-amp-A"><a href="#Q-amp-A" class="headerlink" title="Q&amp;A"></a>Q&amp;A</h2><p>Q：Threads 所带来的 overhead 是否值得？<br>A：负担是有的，但是很多线程不是持续运行，或许经常 Sleep，所以 Probably 负担不大。（后面听不懂了）</p><p>Q：提到 asynchronous program（教授称为 eventdriven programming，事件驱动编程）<br>A：如果不想采用 threads 的方式，却要满足一台 server 同时与多台 clients 交流的需求？那么可以采用 asynchronous program 或者 event-driven programing。单一 thread，单一循环，以不同事件相应。编程比较方便，不能解决的问题。无法达到 parallelism 的特性，单一 loop 并不能完全体现出多核机器的优势。不过通常来说其 overhead 要比多线程编程小一些。</p><p>为什么说 threads 的 overhead 略大，虽然线程都是轻量级的，但每一个线程都有自己的栈，如果有百万个线程，那代价是庞大的。</p><p>Q：Threads 与 Process 的区别，即线程与进程的区别<br>A：Threads inside process，是操作系统的概念了，unix process 具备一个大的地址空间，而线程（threads、go routines 在其内部），一些操作系统并不 care 线程内部用的编程语言？操作系统级会将不同进程的地址空间隔离开，不同 processes 之间的交流是极少的。同一进程内部的线程可以共享一些内存空间，或者根据 channel 进行同步，或者 mutex 信号量。进程间达不到这样的能力。</p><p>Q：带线程的进程间 switch 是怎么操作的？<br>A：比较复杂。可能会从中选择一个。</p><p>一个最主要特点，share memory。同时也容易产生 bug。</p><h2 id="Race-问题"><a href="#Race-问题" class="headerlink" title="Race 问题"></a>Race 问题</h2><p>以 n=n+1 为例，多个线程同时进行，可能答案并不正确。RACE 名字是源于，后来的 Process 是否能看到先来的 Process 的修改，像一场赛跑。（ATOMIC 涉及到指令涉及），Go 语言提供的锁机制（mu.lock() mu.unlock()）可以帮助我们“锁住”共享变量。</p><p>Q：Go 如何知道锁住哪些变量，mutex 变量和需要被“锁”的变量有哪些联系<br>A：<strong>实际上，Go have no idea.（hhhh）。这是编程人员的工作，keep in head the relationship to the data。</strong>变量相互间结构是复杂的（Programming language），里面可能携带有多个锁，根据操作可能会 allowcate 新的 data structure，这都要编程人员自己去想。</p><h2 id="Coordination-问题"><a href="#Coordination-问题" class="headerlink" title="Coordination 问题"></a>Coordination 问题</h2><p>方便线程之间交流协调，Go 提供了下面的工具</p><ul><li>channels：收发信息</li><li>sync.Cond：条件锁，更好地知道是要条件性等待，还是继续执行线程</li><li>wait group：lauch 一组线程并等待完成</li></ul><h2 id="Deadlock-问题"><a href="#Deadlock-问题" class="headerlink" title="Deadlock 问题"></a>Deadlock 问题</h2><p>老生常谈，死锁。</p><h2 id="例子：Web-Crawler"><a href="#例子：Web-Crawler" class="headerlink" title="例子：Web Crawler"></a>例子：Web Crawler</h2><p>爬虫会启动很多个线程进行 URLs 的爬取，希望知道爬取的 URLs 是刚刚 fetch for 还是已经完成，爬虫希望避免重复爬取。Serial fetch 时间很长，我们希望 Parallel fetch，一个最终的问题，如何确定爬虫停止，获取全部的爬虫信息。</p><p>提供的 serial fetch，采取 DFS 爬取树形网页结构，并且用 map、set 储存状态。只有一个 fetch map，递归的 fetch 通过传递该 map 的引用（copy 代价太大了）来确定状态。</p><h3 id="Serial-Crawler"><a href="#Serial-Crawler" class="headerlink" title="Serial Crawler"></a>Serial Crawler</h3><p>迅速建立一批 go routines 就停止了。</p><h3 id="Concurrent-Crawler"><a href="#Concurrent-Crawler" class="headerlink" title="Concurrent Crawler"></a>Concurrent Crawler</h3><p>（<strong>感觉 wait group 实现用到了整型信号量的思路</strong>）加入了 mutex 和 wait group，可以保证 routines 不会 fetch 相同的 url， 如果不加入 42-45 行锁，当两个线程同时尝试两个 url 时候，会同时设定为 true，从而导致重复 fetch。所以读共享 table 操作要加入锁。</p><p>！的确应该用<code>defer done.Done()</code>，否则不能保证函数调用执行完后再释放。</p><p>Q：如何保证 done.Done 操作不会产生 Race 问题？<br>A：有内部锁保证。（可以理解成 sync.WaitGroup 操作都是线程安全的）。</p><p>关于变量 u 的解释没太听懂。</p><p>Q：如果 inner function，作为 go routine 启动并且 refer 了 surrounding function 的变量，那当 surrounding function 返回时，refer 的变量怎么办？<br>A：答案时 Go 的实现会意识外部的 closure 并会分析，编译器会分配<code>heat memory</code>（热内存）来 hold 住这些变量的值，从栈中转移到堆中，这样 inner function 仍能到他们，最后垃圾处理机制会处理这些变量。</p><p>编程中 race 问题是常见的</p><p>Go 提供了优秀的工具，race 检测工具<code>go run -race</code>，检测不同 routines 先读后写又无锁的情况。</p><p>Q：静态分析？<br>A：并不是，race editor 并不是静态分析，是对 run 过程中进行的检测。</p><p>一共多少并发线程可以同时运行</p><p>样例中看起来 5，实际工程中并没有 limit</p><h3 id="Concurrent-Channel"><a href="#Concurrent-Channel" class="headerlink" title="Concurrent Channel"></a>Concurrent Channel</h3><p>使用 Channel 而不是共享变量的形式，channel 是线程安全的（Q&amp;A 里顺便提了一下）。感觉这种形式有点像事件驱动？</p><ul><li>worker 控制 channel 压入（urls 或者 strings 切片）</li><li>master 是个 loop 对 channel 弹出，根据弹出内容执行新建 worker，还是其他。</li></ul>]]></content>
    
    
    <categories>
      
      <category>Computer Science</category>
      
      <category>分布式系统</category>
      
    </categories>
    
    
    <tags>
      
      <tag>分布式系统</tag>
      
      <tag>6.824</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>USTCReadingGroup——Supporting-Very-Large-Models</title>
    <link href="/post/a2116e6d.html"/>
    <url>/post/a2116e6d.html</url>
    
    <content type="html"><![CDATA[<!--文章由 3step 模板生成三步法阅读文献笔记记录--><h1 id="Step-1"><a href="#Step-1" class="headerlink" title="Step 1"></a>Step 1</h1><h2 id="题目摘要引言"><a href="#题目摘要引言" class="headerlink" title="题目摘要引言"></a>题目摘要引言</h2><h3 id="题目"><a href="#题目" class="headerlink" title="题目"></a>题目</h3><p>使用自动数据流图分割支持超大模型</p><h3 id="摘要"><a href="#摘要" class="headerlink" title="摘要"></a>摘要</h3><p>介绍新的模型——Tofu，用于在多个 GPU 上划分超大的 DNN 模型，从而减少单个 GPU 的内存占用。</p><h2 id="基本理论概况"><a href="#基本理论概况" class="headerlink" title="基本理论概况"></a>基本理论概况</h2><h2 id="结论部分"><a href="#结论部分" class="headerlink" title="结论部分"></a>结论部分</h2><!-- 确定作者的成过以及点出的经验、问题、改进方 --><h2 id="回答基本问题"><a href="#回答基本问题" class="headerlink" title="回答基本问题"></a>回答基本问题</h2><ol><li>类别</li></ol><!-- 这篇论文是什么类型？测试类？对现有系统进行分析的？对原型系统进行描述的？--><ol><li>内容</li></ol><!-- 你读过的其他论文有没有与之相关的？相关性与区别最直接体现在哪里？文章中分析问题用的什么理论基础（通过瞥一眼数学概况与核心证明可以得到）。 --><ol><li>正确性</li></ol><!-- 结论是否看起来真实有效？ --><ol><li>创新点</li></ol><!-- 论文的主要创新点是什么？总结提到的经验、问题和改进方法是什么？ --><ol><li>清晰度</li></ol><!-- 这篇论文是否写的条理清晰 --><h2 id="阅读选择"><a href="#阅读选择" class="headerlink" title="阅读选择"></a>阅读选择</h2><!--1. 继续阅读：论文有价值担保，研究领域非常切合，对当前进行工作有极大帮助，圈内爆火文章2. 不继续阅读：论文不吸引自己，论文价值/正确性存疑，论文作者给出了不适当的假设。3. 库存保留并标记：当前不处于自己的研究领域，但不久的日后相关论文会有用。--><a id="more"></a><h1 id="Step-2"><a href="#Step-2" class="headerlink" title="Step 2"></a>Step 2</h1><h2 id="细读笔记"><a href="#细读笔记" class="headerlink" title="细读笔记"></a>细读笔记</h2><!-- 要仔细阅读论文，但是诸如证明等信息要忽略掉 --><h2 id="问题记录"><a href="#问题记录" class="headerlink" title="问题记录"></a>问题记录</h2><h2 id="未读（且值得读）文献记录"><a href="#未读（且值得读）文献记录" class="headerlink" title="未读（且值得读）文献记录"></a>未读（且值得读）文献记录</h2><!-- 在第二步中，找到以上几篇论文中相同的引用文献、在引用文献中重复的作者名，这些就是你所调研领域的重点论文和科研人员，下载那些重点论文暂时搁到一边。继续访问那些重要科研人员的网页，看下那些论文是在什么会议集结出版的。这能帮你找到那个领域的顶级会议，因为那些重要科研人员通常会在顶级会议发表论文。 --><h1 id="Step-3"><a href="#Step-3" class="headerlink" title="Step 3"></a>Step 3</h1><!-- 试着“在脑中重新实现（virtually re-implement）”那篇论文：也就是，和作者一样做出相同的假设，然后重新实现相同的工作。通过对比你自己得出的和论文中给出的结果，不仅可以很轻易验证一篇论文的创新点是否真实，而且还能发现论文中不会讲的缺点和假想。 --><h2 id="思路复现"><a href="#思路复现" class="headerlink" title="思路复现"></a>思路复现</h2><!-- 推敲作者是如何立题，如何找到突破口，在其中是否有抉择，如何做出的假设？ --><h2 id="证明与推理复现"><a href="#证明与推理复现" class="headerlink" title="证明与推理复现"></a>证明与推理复现</h2><!-- 分析证明过程，确定证明的正确性以及完整性。对证明过程做拓展，调研证明思路来源 --><h2 id="实验验证复现"><a href="#实验验证复现" class="headerlink" title="实验验证复现"></a>实验验证复现</h2><!-- Rework --><h1 id="ReadingGroup-笔记"><a href="#ReadingGroup-笔记" class="headerlink" title="ReadingGroup 笔记"></a>ReadingGroup 笔记</h1><p>分布式训练</p><h1 id="How-to-fit-a-large-DNN-across-GPUs"><a href="#How-to-fit-a-large-DNN-across-GPUs" class="headerlink" title="How to fit a large DNN across GPUs"></a>How to fit a large DNN across GPUs</h1><ul><li>(a) 数据并行 Data Parallelism<ul><li>后台 Sync</li><li>适用于小数据规模量</li></ul></li><li>(b) 来不及记录</li><li>(c) 层级并行 Layer Parallelism<ul><li>针对大的模型</li></ul></li></ul><p>tofu</p><p>tensorflow mash</p>]]></content>
    
    
    <categories>
      
      <category>Research</category>
      
      <category>Paper</category>
      
    </categories>
    
    
    <tags>
      
      <tag>Paper</tag>
      
      <tag>三步法</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>《看见》读书摘录</title>
    <link href="/post/d6eb1130.html"/>
    <url>/post/d6eb1130.html</url>
    
    <content type="html"><![CDATA[<h1 id="序言"><a href="#序言" class="headerlink" title="序言"></a>序言</h1><blockquote><p>“要想‘看见’，就要从蒙昧中睁开眼来。”<br>“这才是最困难的地方，因为蒙昧就是我自身，像石头一样成了心里的坝。”</p></blockquote><h1 id="第一章-别当了主持人就不是人了"><a href="#第一章-别当了主持人就不是人了" class="headerlink" title="第一章 别当了主持人就不是人了"></a>第一章 别当了主持人就不是人了</h1><h1 id="第二章-那个温热的跳动就是活着"><a href="#第二章-那个温热的跳动就是活着" class="headerlink" title="第二章 那个温热的跳动就是活着"></a>第二章 那个温热的跳动就是活着</h1><blockquote><p>P34 “九年后，再看二〇〇三年对他的采访，那时候我还不能明白这个人为什么说话语速这么慢，脸上一点表情都没有。现在我理解了，那是沉痛。”<br>“我用了很长时间说服他接受参访。我说：‘你不用作什么判断和结论，只要描述你看到、听到、感觉到的，就可以了。’”<br>“在电话里，他沉默了一下说：‘回忆太痛苦了。’”<br>“‘是，’我说，‘但痛苦也是一种清洗，是对牺牲人的告慰。’”</p></blockquote><p>恐慌，是最可怕的吗？</p><blockquote><p>P38 “我做的节目播出后，有同行说：‘你们在制造恐慌。’当时我身边坐着时任《财经》杂志主编的胡舒立，她说：‘比恐慌更可怕的是轻慢。’”</p></blockquote><h1 id="第三章-双城的创伤"><a href="#第三章-双城的创伤" class="headerlink" title="第三章 双城的创伤"></a>第三章 双城的创伤</h1><blockquote><p>P55 “它们没有被呈现，这是一个新闻媒体的‘政治正确’。我们叙述了一个事情的基本框架，但只是一个简陋的框架，以保护大众能够理解和接受这个‘真相’。”</p></blockquote><p>当柴静对采访小男孩不抱希望时，不曾想正是因为几个月前的非典报道，成了两人相互信任的突破口。</p><blockquote><p>P42 “我不抱希望地问了这么一句，但他说：‘我愿意’。”<br>我蹲在地上，有一秒钟没回过神，居然问他：‘为什么？’<br>他说：‘因为我看过你关于非典地报道。’<br>几个月前做非典报道得到的所有荣誉称赞，都比不上这一句。</p><p>P55 “对人的认识有多深，呈现才有多深”<br>“做这期节目的时候，我对人的了解还远远不够，只下了个简易的判断。”</p></blockquote><p>故事的末尾，终于不再是那句“让我们期待一个民主与法治的社会早日来到”。</p><blockquote><p>P56 “一分多钟，我怔怔地看着他地背影，都没有意识到镜头已经摇回来对着我了，直到海南轻声说‘说点什么’，我愣了一下，说了我的感受：‘看着孩子在采访中离开，我们知道他还有很多话没有说出来，也许那些话才是服毒地真正原因，双城事件调查到最后，我们发现，最大的谜，其实是孩子的内心世界，能不能打开它，可能是每个人都需要面对的问题。’”<br>“这个一分四十四秒的长镜头用在了节目结尾，后来在我的职业生涯中常被提起，说这时镜头前的即兴评述能力什么的。但这个段落，对我来说，跟那些无关，它只是撬起了深扎在我头脑里的一根桩子。之前我坐在演播室里的时候，总认未结尾的评论必须是一个答案，说出‘让我们期待一个民主与法治的社会早日来到’才可以收拾回家，<strong>就好像这演播室只是一个布景，我只是在表演一个职业。</strong>我从来没想过一个节目会以无解来结尾，一直到我明白真实的世界即是可能如此。”</p></blockquote><a id="more"></a><h1 id="第四章-是对峙，不是对抗"><a href="#第四章-是对峙，不是对抗" class="headerlink" title="第四章 是对峙，不是对抗"></a>第四章 是对峙，不是对抗</h1><blockquote><p>P69 “张洁总担心善良的人做不了刚性调查。其实只有善良的人才能刚性”</p><p>“善良的人做‘对抗性’采访，不会跃跃欲试地好斗，但当他决定看护真相的时候，是绝不撤步地对峙。”</p></blockquote><h1 id="第五章-我们终将浑然难分，像水溶于水中"><a href="#第五章-我们终将浑然难分，像水溶于水中" class="headerlink" title="第五章 我们终将浑然难分，像水溶于水中"></a>第五章 我们终将浑然难分，像水溶于水中</h1><blockquote><p>P82 “她吸毒，偷东西，但她是一个人，她受侮辱，做噩梦，受了她本不该受地罪。”</p></blockquote><p>“堕落”一词能出现，本就是太过主流的观点，或许那些边缘人群存在着，却从未被人当作存在过。</p><blockquote><p>P83 “节目播出后原戒毒所所长被捕。但有人说：‘自从柴静去了新闻调查，节目就堕落到了去拍网站新闻的最底下一行。’意思是你们不去拍时政新闻，却关心边缘人群，无非为了耸动，吸引眼球。”</p></blockquote><p>柴静不怕，或者说，根本不在乎。因为现在她如此，九八年的她看到赵铁林拍那些三陪女时，也是如此。<strong>知道和感觉到，本就是两回事。</strong></p><blockquote><p>“来到‘新闻调查后’，我下意识里寻找像阿 V 这样的人——那些我知道，但从没感到他们存在的人。”</p><p>P85 “聚会上，朋友说，你现在做的这些题目太边缘了，大多数人根本不会碰到这些问题。作家野夫说：‘那是因为我们已经不是大多数人，在很大程度上已经免于受辱了。’”</p></blockquote><p>在那个同性之间感情不可流露的年代，陌生人才是最安全的。</p><blockquote><p>P87 “‘你不认识我为，我不认识你’，两个人完了关系大家互相都不认识，不用担心身份的泄露。”<br>“在没有过去和未来的地方，爱或不下来，只有性。”</p></blockquote><p>为什么我们的社会接纳不了同性恋者？</p><blockquote><p>P91 “我问张北川：‘我们的社会为什么不接纳同性恋者？’”<br>“他说：‘因为我们的性文化里，把生于当作性的目的，把无知当纯洁，把愚昧当德行，把偏见当原则。’”</p></blockquote><p>实际上，不是性文化如此，根源文化就带有这样的色彩。</p><blockquote><p>P94 “他就像他拍摄的人一样，承受命运施加于自己的一切，不粉饰，也不需要虚浮的怜悯。”<br>“生和死，苦难和苍老，都蕴含在每一个人的体内，总有一天我们会与之遭逢。”<br>“我们终将浑然难分，像水溶于水中。”</p></blockquote><h1 id="第六章-沉默在尖叫"><a href="#第六章-沉默在尖叫" class="headerlink" title="第六章 沉默在尖叫"></a>第六章 沉默在尖叫</h1><p>讲那些被家暴的女性，和以暴制暴的悲剧。</p><blockquote><p>P101 “这些女人结婚大都在七十年代，没受过教育，没有技能，没有出外打工的机会，像载在水泥之中，动弹不得。”</p></blockquote><p>怕，没有生死概念的人，也不会有悲悯之心。一个得不到爱，得不到教育的人。对这个社会不可能有责任感。</p><p>章末结束语</p><blockquote><p>P115 “这些早就干枯失血的花瓣给我一个刺激，人是一样的，对幸福地愿望一样，对自身完整的需要一样，只是她生在这儿。这么活着，我来到那儿，那么活着，都是偶然。”<br>“万物流变，千百万年，谁都是一小粒，嵌在世界的秩序当中，采访是什么？采访是生命间的往来，认识自己越深，认识他人越深，反之亦然。做完女子监狱那期节目的年底，评论部让每人写一句话印在内部刊物上，代表这一年里自己对工作的认识。我没思量，有一句话浮上心头，以前我会顾忌别人怎么看，会不会太文艺腔，但这次我径直写了下来：‘他人经受的，我必经受。’”</p></blockquote><h1 id="第七章-山西，山西"><a href="#第七章-山西，山西" class="headerlink" title="第七章 山西，山西"></a>第七章 山西，山西</h1><blockquote><p>P127 “二〇〇六年采访孝义 i 的市长，他白皙的四方脸，西装笔挺，不论什么问题，总能说道市里的整顿措施。我问：‘这个城市付出了沉重的代价，现在回头来看的话，这个代价是不可避免的吗？’”<br>“市长说：‘这个代价是惨痛的。’”<br>“我问：‘是不可避免的吗？’”<br>“市长说：‘这个代价是惨痛的。’”<br>“我再问：‘是不可避免的吗？’”<br>“市长端起杯子喝口水，看着我：‘政府对于焦化，始终是冷静的。我们采取措施之后呢，后面的这股劲我们给压住了。’”<br>“‘压住了’”</p><p>P132 “我碰上一个官员，他说：‘你是山西人，我知道。’”<br>“‘对。’”<br>“‘临汾的？’”<br>“‘嗯。’”<br>“他知道得很清楚。带着一点讥笑看着我：‘你怎么不给山西办点好事儿？’”<br>“‘我办的就是。’”</p><p>P132 “大佛微笑的脸上是乌黑的煤灰，吸附 2 二氧化硫和水，长此以往，砂岩所凿的面目会被腐蚀剥落。”<br>“佛犹如此。”</p></blockquote><h1 id="第八章-我只是讨厌屈服"><a href="#第八章-我只是讨厌屈服" class="headerlink" title="第八章 我只是讨厌屈服"></a>第八章 我只是讨厌屈服</h1><p>那个为五毛钱将北京地铁告上法庭的郝劲松，解释自己为何这么“较真”</p><blockquote><p>P139 “他是个普通的学法律的学生，连个律师证都没有，以‘公民’的名义打官司。”<br>……<br>“‘在强大的机构面前人们往往除了服从别无选择，但是我不愿意，’他说，‘我要把他们拖上战场，我不一定能赢，但我会让他们觉得痛，让他们害怕有十几二十几个像我这样的人站出来，让他们因为害怕而迅速改变。’”<br>“‘钱数这么小，很多人觉得失去它并不可惜。’我说。”<br>“‘今天你可以失去获得它的权力，你不抗争，明天你同样会失去更多的权力，人身权，财产权，包括土地、房屋。中国现在这种状况不是偶然造成的，而是长期温水煮青蛙的一个结果，大家会觉得农民的土地被侵占了与我何干，火车不开发票、偷漏税与我何干，别人的房屋被强行拆迁与我何干，有一天这些事情都会落在你的身上。’”<br>“‘但是一个人的力量能改变什么呢？’”<br>“‘看看罗莎·帕克斯，整个世界为之改变。’他说。”</p></blockquote><p>我-只-是-讨-厌-屈-服</p><blockquote><p>P152 “在这个世界上，没有一劳永逸的答案，也没有完美的世界图式。认为一个人、一个概念、一次诉讼就可以彻底解决现实问题，如果不是无知，就是智力上的懒惰。但这个不完美的世界上，还是有一个共有的规则存在。”</p></blockquote><p>暴力是力量，但是是一种危险的力量。不选择这个力量是因为我们有更好的方式——法律。</p><p>章末结束语</p><blockquote><p>P153 “采访郝劲松时，我问过他：‘你以谁的名义在诉讼？’”<br>“‘公民。’”<br>“‘公民和普通百姓的概念区别是什么？’”<br>“‘能独立地表达自己的观点，却不傲慢，对政治表示服从，却不卑躬屈膝。能积极地参与国家的政策，看到弱者知道同情，看到邪恶知道愤怒，我认为他才算是一个真正的公民。’”<br>“我问他最后一个问题：‘你想要一个什么样的世界？’”<br>“这个当时三十四岁的年轻人说：‘我想要宪法赋予我的那个世界。’”</p></blockquote><h1 id="第九章-许多事情，是有人相信，才会存在"><a href="#第九章-许多事情，是有人相信，才会存在" class="headerlink" title="第九章 许多事情，是有人相信，才会存在"></a>第九章 许多事情，是有人相信，才会存在</h1><blockquote><p>P164 “新闻是选择的结果，是人来选择呈现什么。”<br>“两会不光发布政府工作报告。代表是来审议报告的，审议本身是审查评议的意思，必要时提出批评和质询，是人大代表的职责。”</p></blockquote><p>柴静让自己的伙伴切空的会议室画面。</p><blockquote><p>P165 “我等了一秒钟，猜到她已经切到了空无一人的会议室，就用这个画面说开场白：‘子路问孔子，您从政的话，第一件事是什么？孔子说，必也正名乎。这句话用现代的话说，就是对权力的界定要有清晰的认定。这些空无一人的桌椅，其实就是宪法赋予代表的知情、参与、表达、监督的权力。’”</p></blockquote><h1 id="第十章-真相常流失于涕泪交加中"><a href="#第十章-真相常流失于涕泪交加中" class="headerlink" title="第十章 真相常流失于涕泪交加中"></a>第十章 真相常流失于涕泪交加中</h1><p>读的时候感觉，从这一章，柴静开始重构自己的采访方式，探寻什么，怎么探寻。情绪该不该流露？如果要流露怎么流露？探索真相，直面真相，报道真相，无论这个记者是谁，都不可能完美做好这三件事。或许，怎样是‘好’，也很难界定吧。</p><p>柴静的同事李季以及庄主任都提醒过柴静，要事实，不要情绪。</p><blockquote><p>P176 “庄主任审这个片子，看完对我说了一句话：‘要疑问，不要质问。’”<br>“这点讽刺之意都不能流露吗？我问他：‘可是怎么对得起那些死去的人呢？’”<br>“‘记者们提供的是事实，不是情绪。’他说的跟李季一样。”</p><p>P177 “‘痛苦是财富，这话是扯淡。姑娘，痛苦就是痛苦，’他说，‘对痛苦的思考才是财富。’”</p></blockquote><p>《中国改革》杂志被诉案，调查性报道惹上官司常落不了好下场，但这次的法官认为新闻内容当时以一般人的认知能力判断，没有主观捏造或者道听途说，可以合理相信为事实的消息来源支撑，新闻机构就获得了法律所赋予的关于事实方面的豁免权，当法官被问及希望公众如何理解这个判决时，这个法官给出的答复是这样的，我觉得也是社会该推行的。</p><blockquote><p>P181 “这个社会对媒体的容忍有多大，这个社会进步就有多大，一个文明、民主、法治的社会是需要传媒监督的。”</p></blockquote><p>后面谈及真相的力量，读完我发了条说说，这里就 copy 下吧，的确是我的所思所想。</p><p>真相往往是螺旋下降的无底洞。那什么是探寻？柴静博客下的一条评论有些道理。“保持对不同论述的警惕，才能保持自己的独立性。探寻就是要不断相信、不断怀疑、不断幻灭、不断摧毁、不断重建，为的只是避免成为偏见的附庸。或者说，煽动各种偏见的互殴，从而取得平衡，这是我所理解的探寻。”</p><p>我从香港回来总能想起和故友吃的那顿饭，尤其是饭桌上的她带来的新朋友。我问他，“你怎么看新闻，又怎么看待新闻？”他告诉我，“优秀的记者有时善于隐匿自己的感情，而把评述权留给观众，但言下之意，隐匿感情后的文字仍带有不少她的主观感觉。”</p><p>所以，他这样看新闻，把 CNN、BBC 等西方传统媒体拿来，把光明日报人民日报拿来，把大公报苹果日报对着拿来，在各家媒体言语撕成的碎片重构成“再事件”，这是他追寻的真相。</p><p>真相如此，真理如此。追求真 X 的力量比世界上任何其他力量都温柔，但唯独比恐惧更强大。</p><p>不过柴静提到美国政治学者 Ann 的表述，报道中观点太多，把批评当作记者的唯一语言，这样产生的新闻<strong>很难客观</strong>，而人也<strong>慢慢会变成你本来反对的人</strong>。又是一记猛拳。</p><p>一方缺席算不上真相，必须要给他们说话和解释的权利。柴静写信给钱钢老师，说重庆节目后不敢轻易再对任何事物直接发表评论。</p><blockquote><p>P189 “钱老师回信说：‘追求真相的人，不要被任何东西胁迫，包括民意。我们要站在二〇一二、二〇二二，甚至更远的地方来看我们自己。’”<br>“信的最后，他说：‘不要太爱惜你的羽毛。’”</p></blockquote><p>颇有些支援未来的感觉。</p><blockquote><p>P190 “采访不用来评判，只用来了解：不用来改造世界，只用来认识世界。记者的道德，是让人‘明白’。”</p><p>P192 “那位朋友看到的节目中，我采访的官员批评上级政府财政决策失误，说了四十五分钟，很坦率。”<br>“采访完我问他：‘你这个性怎么生存？’”<br>“他说：‘官僚系统是一个复合系统，只有一种人就玩不下去了。’”<br>“‘<strong>那你靠什么直言不讳还能让人接受？</strong>’”<br>“他说：‘准确。’”<br>“我想起问过 Ann，如果你认为安娜的方式并不是最好的方式，那什么是？”<br>“Ann 说：‘<strong>Doing the right thing is the best defence.——准确是最好的防御。</strong>’”</p></blockquote><p>章末结束语混合</p><p>人是不能清空自己的情绪判断的，但要有个戒备，念头起来要能察觉，察觉之后你就不会跟它。情感的基础常是自我感动，自我感动取之便捷，又容易上瘾。对它的自觉抵制，变尤为可贵。每一条细微的新闻背后，都隐藏一条冗长的逻辑链，在我们这，这些逻辑链绝大多数是同一朝向，正是因为者不能言说又不言而喻的秘密，我们需要提醒自己：绝不能走到这这条逻辑链的半山腰就号啕大哭。</p><blockquote><p>P193 “他写道：‘准确是这一工种最重要的手艺，那自我感动，感动先行是准确最大的敌人，真相常流失于涕泪交加中。’”</p></blockquote><h1 id="第十一章-只求了解与认识而已"><a href="#第十一章-只求了解与认识而已" class="headerlink" title="第十一章 只求了解与认识而已"></a>第十一章 只求了解与认识而已</h1><p>这一章讲了虐猫事件的报道始末。</p><blockquote><p>P208 “‘作为一个记者，通往人心之路是如此艰难，你要付出自己的生命，才能得到他人的信任，但又必须在真相面前放下普通人的情感……在这个职业中，我愿意倾尽所有 ，但是，作为一个人，我是如此不安。’”</p></blockquote><p>有的人怕眼泪流下来，有的人怕看到眼泪流下来。</p><blockquote><p>P209 “有的笑容背后是咬紧牙关的灵魂。”</p><p>P211 “真实的人性有无尽的可能。善当然存在，但恶也可能一直存在。歉意不一定能弥补，伤害却有可能被原谅，忏悔也许存在，也许永远没有，都无法强制，强制出来也没有意义。”</p></blockquote><p>拍耍猴的人的摄影师马宏杰打破了只拍预设主题的“政治正确”。</p><blockquote><p>P214 “马宏杰说他会一直把这些人拍下去：‘拍到他们死，或者我死。’”<br>“我问他的原则是什么。”<br>“‘真实。’他说。”</p></blockquote><h1 id="第十二章-新旧之间没有怨诉-唯有真与伪是大敌"><a href="#第十二章-新旧之间没有怨诉-唯有真与伪是大敌" class="headerlink" title="第十二章 新旧之间没有怨诉 唯有真与伪是大敌"></a>第十二章 新旧之间没有怨诉 唯有真与伪是大敌</h1><p>谈媒体的选择性报道，陈虹骂这种选择，记者不应该在潜意识里去预设要歌颂什么或者贬低什么，从而选择抹去哪些本应报道出的内容。</p><p>唐山大地震那些更加震彻人心的照片，或许都淹没在不知名的底片中了。留下来的，只有笑着的。</p><blockquote><p>P222 “如果刀口本身的锋利和痛感感觉不到，后来的蜜汁你吮吸起来也会觉得少了滋味。”</p></blockquote><p>一个记者谈自己没有拍新闻，因为新闻是摆拍的。</p><blockquote><p>P223 “陈虹听完说：‘你为什么不把摆拍新闻的过程拍下来呢？’”<br>“大家都愣了一下。”<br>“他说：‘在认识这个事件的时候，有一个干预它的事件发生了，但你原本可以通过拍摄它，看到这背后更深刻的真实，你失去了一次认识它的机会。’”</p></blockquote><p>无论世界上哪个地方，有政府，就有宣传机器的管控。谈及崔永元去做《我的抗战》。</p><blockquote><p>P230 “那么，知识分子去了什么地方？那些本来应该发出声音和警示的人呢？”<br>“日本人入侵华北日渐深入时，东京大学的校长和理学院的教授曾反对日语对华教学计划，‘不要再为了日本的利益去妨害支那人的生活’，但‘随着跟上形势、整肃学风的声音，自由派教授一个个被解职，或者沉默下去。’”</p></blockquote><p>《朝日新闻》从一九八六年开始征集读者来信，记录普通国民对于二战的回忆。</p><blockquote><p>P231 “很多人写信给他们希望停止，‘我们正在极力将过去忘掉’，‘翻旧账没有一点好处’。”<br>“《朝日新闻》的编辑说：‘一个人忘掉过去可能有自我净化的作用，但一个国家的历史就不同了，尽量掩盖，假装这类事根本没有发生过，难道对我们民族的良知没有损害吗？’”</p></blockquote><p>回归章节标题。钱钢老师离群而去，在港大的图书馆里阅读数以万计的微缩胶卷，写下六十年前旧报纸中的往事，整理成书，名为《旧闻记者》</p><blockquote><p>P232 “他写道：‘研究新闻史的后人，会因为不是在报纸和电讯稿上，而是在历史读物上发现某些记者的名字而不无惋叹，但他们终将意会的是，当曲折奔图突的河流遇到沉沉壅蔽，改道时历史的寻常，这也是一个新闻记者的职责，他似乎心有旁骛，改道别出，但他根本未曾离开一名真正记者的信条。’”<br>“钱老师送这本书给我，我明白他当年让我读历史的原因：‘新旧之间没有怨诉，唯有真与伪是大敌。’”</p></blockquote><h1 id="第十三章-事实就是如此"><a href="#第十三章-事实就是如此" class="headerlink" title="第十三章 事实就是如此"></a>第十三章 事实就是如此</h1><p>缺乏科学精神的文化渗透在整个华夏文明之中。</p><blockquote><p>P239 “蔡元培评论过：‘自汉以后，虽亦思想家辈出，而其大旨不能出儒家之范围……我国从前无所谓科学，无所谓美术，唯用哲学以推测一切事物，往往各家悬想独断。’”</p></blockquote>]]></content>
    
    
    <categories>
      
      <category>Life</category>
      
      <category>阅读</category>
      
    </categories>
    
    
    <tags>
      
      <tag>阅读</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>USTCReadingGroup——On-the-Optimal-Repair-Scaling-Trade-off-in-Locally-Repairable-Codes</title>
    <link href="/post/7450893e.html"/>
    <url>/post/7450893e.html</url>
    
    <content type="html"><![CDATA[<!--文章由 3step 模板生成三步法阅读文献笔记记录--><h1 id="Step-1"><a href="#Step-1" class="headerlink" title="Step 1"></a>Step 1</h1><h2 id="题目摘要引言"><a href="#题目摘要引言" class="headerlink" title="题目摘要引言"></a>题目摘要引言</h2><h3 id="题目"><a href="#题目" class="headerlink" title="题目"></a>题目</h3><p>对 Locally Repairable Codes（本地可修复码）的最佳 Repair-Scaling Trade-off 的探究</p><h3 id="摘要"><a href="#摘要" class="headerlink" title="摘要"></a>摘要</h3><p>LRC 是针对 erasure coded storage（可擦除码存储方案）提升修复性能的可行编码方式的一种。可以<code>减少修复带宽</code>并可<code>用于实践</code>。文章分析了均衡 repair 和 scaling 的最佳 trade-off，设计了更优的分布策略，并在 LAN 环境下测试优于传统的布局方案。</p><h3 id="引言"><a href="#引言" class="headerlink" title="引言"></a>引言</h3><p>存储系统扩容与容错需求，Erasure coding 技术相较于传统备份，达到相同容错能力时所需代价更小（低冗余）。Erasure code 已经被应用很多商业存储系统，如微软 Azure 等。</p><p>Erasure code 以 original data blocks 为输入，可以产生一些附加的冗余块，它们与原始数据块子集可共同作用于恢复全部原始数据，这些冗余块被称为<code>parity blocks</code>。</p><p>Erasure coding 解决方案存在的问题就是修复过程中的 I/O 放大问题。LRC 时 Erasure codes 家族的新成员，设计的主要目的就是以进一步增加冗余存储的代价减小修复过程中的网路贷款与磁盘 I/O 消耗（Local）。</p><p>trade-off 探寻方式，以 coding 参数为变量平衡系统 performance 与 storage efficiency 的关系。</p><h3 id="贡献"><a href="#贡献" class="headerlink" title="贡献"></a>贡献</h3><ul><li>第三节阐述 trade-off 的正是分析。先推导出单集群容错性限制下的放置策略，拓展到其他数据放置策略更贴近最优曲线。</li><li>极端放置策略，最优 scaling 与最优 repair。在 LAN 上的试验结果表明两种极端情况下的优化性能。</li></ul><h2 id="基本理论概况"><a href="#基本理论概况" class="headerlink" title="基本理论概况"></a>基本理论概况</h2><h2 id="结论部分"><a href="#结论部分" class="headerlink" title="结论部分"></a>结论部分</h2><!-- 确定作者的成过以及点出的经验、问题、改进方 --><p>Numerical Studies 和 Testbed Experiments 都证明了该放置策略的有效性。</p><p><a href="http://adslab.cse.cuhk.edu.hk/software/lrctradeoff/" target="_blank" rel="noopener">实验室源码下载地址</a></p><p><a href="https://github.com/kobesi/infocom20_lrctradeoff" target="_blank" rel="noopener">GitHub 源码下载地址</a></p><h2 id="回答基本问题"><a href="#回答基本问题" class="headerlink" title="回答基本问题"></a>回答基本问题</h2><ol><li>类别</li></ol><p>对现有系统分析 Trade-off 并进行改进</p><!-- 这篇论文是什么类型？测试类？对现有系统进行分析的？对原型系统进行描述的？--><ol><li>内容</li></ol><p>和 Erasure Code 相关，RS-Paxos，CRaft。</p><!-- 你读过的其他论文有没有与之相关的？相关性与区别最直接体现在哪里？文章中分析问题用的什么理论基础（通过瞥一眼数学概况与核心证明可以得到）。 --><ol><li>正确性</li></ol><!-- 结论是否看起来真实有效？ --><ol><li>创新点</li></ol><!-- 论文的主要创新点是什么？总结提到的经验、问题和改进方法是什么？ --><ol><li>清晰度</li></ol><p>分析优化，较为清晰</p><!-- 这篇论文是否写的条理清晰 --><h2 id="阅读选择"><a href="#阅读选择" class="headerlink" title="阅读选择"></a>阅读选择</h2><p>继续阅读</p><!--1. 继续阅读：论文有价值担保，研究领域非常切合，对当前进行工作有极大帮助，圈内爆火文章2. 不继续阅读：论文不吸引自己，论文价值/正确性存疑，论文作者给出了不适当的假设。3. 库存保留并标记：当前不处于自己的研究领域，但不久的日后相关论文会有用。--><a id="more"></a><h1 id="Step-2"><a href="#Step-2" class="headerlink" title="Step 2"></a>Step 2</h1><h2 id="细读笔记"><a href="#细读笔记" class="headerlink" title="细读笔记"></a>细读笔记</h2><!-- 要仔细阅读论文，但是诸如证明等信息要忽略掉 --><h3 id="集群存储系统体系结构"><a href="#集群存储系统体系结构" class="headerlink" title="集群存储系统体系结构"></a>集群存储系统体系结构</h3><ul><li>两层体系结构</li><li>一个集群划分成多个存储结点。</li><li>一个集群内的多个节点通过同一台交换机进行通信，集群间通信通过一个网路核心。</li><li>一个 Cluster 可以参考成一个机架或者一个数据中心。</li><li>数据组织状态是 fixed-size 的，作为基本 r/w 单元。</li><li>跨集群带宽比内部集群带宽要稀缺得多（more scarce）</li></ul><h3 id="Locally-Repairable-Codes"><a href="#Locally-Repairable-Codes" class="headerlink" title="Locally Repairable Codes"></a>Locally Repairable Codes</h3><ul><li>4 parameters (k,l,g,c)<ul><li>k 表示 data node 数量</li><li>l 表示 local parity 数量</li><li>g 表示 global parity 数量</li><li>c 表示 集群数</li></ul></li></ul><p>在实践中，发生多个集群同时挂掉的情况不常见，故障情况更多为 node failures 而非 cluster failures，采用 Azure Local Reconstruction Code 的形式。将 k 个 data node 划分为 l 份（ $l \mid k$），每$b = \frac{k}{l}$个划分出来的子块通过异或（XOR）产生一个 local 块。这 b+1 个成为一个 local group。</p><p>修复过程：</p><p>代价，代价平均值</p><p>Scaling 过程：</p><ul><li>fast LRC： （相同 k）l 更小，更多的 local parity，修复表现增强</li><li>compact LRC： （相同 k）l 更大，更少的 local parity，提高存储效率</li><li>upcoding： fast 转向 compact 增大 l，减少 local parity 的过程</li><li>downcoding： compact LRC</li></ul><h2 id="问题记录"><a href="#问题记录" class="headerlink" title="问题记录"></a>问题记录</h2><h2 id="未读（且值得读）文献记录"><a href="#未读（且值得读）文献记录" class="headerlink" title="未读（且值得读）文献记录"></a>未读（且值得读）文献记录</h2><ul><li>Erasure Coding 技术</li><li>LRC 本地修复码</li></ul><!-- 在第二步中，找到以上几篇论文中相同的引用文献、在引用文献中重复的作者名，这些就是你所调研领域的重点论文和科研人员，下载那些重点论文暂时搁到一边。继续访问那些重要科研人员的网页，看下那些论文是在什么会议集结出版的。这能帮你找到那个领域的顶级会议，因为那些重要科研人员通常会在顶级会议发表论文。 --><h1 id="Step-3"><a href="#Step-3" class="headerlink" title="Step 3"></a>Step 3</h1><!-- 试着“在脑中重新实现（virtually re-implement）”那篇论文：也就是，和作者一样做出相同的假设，然后重新实现相同的工作。通过对比你自己得出的和论文中给出的结果，不仅可以很轻易验证一篇论文的创新点是否真实，而且还能发现论文中不会讲的缺点和假想。 --><h2 id="思路复现"><a href="#思路复现" class="headerlink" title="思路复现"></a>思路复现</h2><!-- 推敲作者是如何立题，如何找到突破口，在其中是否有抉择，如何做出的假设？ --><h2 id="证明与推理复现"><a href="#证明与推理复现" class="headerlink" title="证明与推理复现"></a>证明与推理复现</h2><!-- 分析证明过程，确定证明的正确性以及完整性。对证明过程做拓展，调研证明思路来源 --><h2 id="实验验证复现"><a href="#实验验证复现" class="headerlink" title="实验验证复现"></a>实验验证复现</h2><!-- Rework --><h1 id="ReadingGroup-笔记"><a href="#ReadingGroup-笔记" class="headerlink" title="ReadingGroup 笔记"></a>ReadingGroup 笔记</h1><h2 id="BackGround"><a href="#BackGround" class="headerlink" title="BackGround"></a>BackGround</h2><p>符合自己学习的内容</p><h2 id="Motivation"><a href="#Motivation" class="headerlink" title="Motivation"></a>Motivation</h2><p>再 repair 和 scaling cost 间进行一个 Trade-off</p><h2 id="设计"><a href="#设计" class="headerlink" title="设计"></a>设计</h2><p>引理 1 (k,l,g) LRC 可以用人任意 g+i 个 block failures（不等式证明）</p><p>一个简单结论，不能把 g+i 块放置在一个集群中</p><h3 id="举例"><a href="#举例" class="headerlink" title="举例"></a>举例</h3><ul><li>upcoding cost 产生于 local parity 之间</li><li>repair cost 产生于 data 块与 local parity 之间</li></ul><h3 id="分析过程"><a href="#分析过程" class="headerlink" title="分析过程"></a>分析过程</h3><p>就是一个单元变量，每次将 Local Parity 集中集群中分配一个 LP 块到其对应的 local group 中，一次函数。</p><h3 id="验证过程"><a href="#验证过程" class="headerlink" title="验证过程"></a>验证过程</h3><ul><li>flat 放置</li><li>改变块大小的一系列对比试验</li></ul><h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><ul><li>优点<ul><li>关于 LRC 放置的优化</li><li>建模 strictly derived</li></ul></li><li>缺点</li></ul><p>绿色： b = g+1 （想把分配出来的 Local Parity 分配到 Local Group 所在机架上），恰好是边界条件</p><p>如果要实现一个 OPTr</p><p>不同的的 LRC 布置策略是不同的</p>]]></content>
    
    
    <categories>
      
      <category>Research</category>
      
      <category>Paper</category>
      
    </categories>
    
    
    <tags>
      
      <tag>Paper</tag>
      
      <tag>三步法</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>分布式系统学习——云计算发展</title>
    <link href="/post/f3c25b0b.html"/>
    <url>/post/f3c25b0b.html</url>
    
    <content type="html"><![CDATA[<h1 id="云计算发展的背景"><a href="#云计算发展的背景" class="headerlink" title="云计算发展的背景"></a>云计算发展的背景</h1><p>计算模式演变的趋势，计算模式变革的目标</p><ul><li>更方便快捷的使用方式</li><li>更强大的计算能力</li></ul><p>双目标一同发展，是主线</p><p>从计算模式的演变看计算技术发展的趋势</p><p>60-70’s：大型机（mainframe） 集中式、分时共享 （集中）</p><p>80-90’s： 个人计算机人手一台 （分散）</p><p>95-06’s：互联网/网格/集群/数据中心 （又集中，存在内在不同）</p><ul><li>分离 pc 互联以共享资源 — 互联网</li><li>连接更多计算资源以解决大的计算问题 — 网格计算</li><li>多个微处理器构建大型机处理能力 — 集群</li></ul><p>06 年以后：</p><ul><li>前端更分散</li><li>后端更集中</li></ul><p>从信息处理及其模式看物联网发展</p><ul><li>需要在线获取和在线反馈的紧耦合模式 — 物联网</li></ul><h2 id="云计算与物联网"><a href="#云计算与物联网" class="headerlink" title="云计算与物联网"></a>云计算与物联网</h2><p>物联网是计算能力向物理端的延申</p><h2 id="为什么需要云计算"><a href="#为什么需要云计算" class="headerlink" title="为什么需要云计算"></a>为什么需要云计算</h2><h2 id="什么是云计算"><a href="#什么是云计算" class="headerlink" title="什么是云计算"></a>什么是云计算</h2><p>集中式远程<code>计算资源池</code>，按需分配，位终端用户提供强大而廉价的计算服务能力</p><ul><li>工业化部署、商业化运作</li><li>新的、可商业化的计算和服务模式</li><li>计算能力像水电煤气一样，按需分配使用</li><li>资源池物理上对用户透明，就像在云端一样</li></ul><p>“云计算”概念最早再 06 年由 Google 公司正式提出。</p><p>几个典型定义</p><ul><li>云计算是一种能够将动态伸缩的<strong>虚拟化资源</strong>（不一定云计算就一定需要虚拟化资源）通过互联网以<strong>服务</strong>的方式提供给用户的计算模式 — Wiki</li><li>通过网路连接来获取软件和服务的计算模式，用户通过瘦客户端接入云中获取所需资源。 — Wahtis</li><li>云计算既指在互联网上以服务形式提供的应用，也指定数据中心提供这些服务的硬件和软件 — 伯克利</li><li>云计算是一种更友好的业务运行模式，用户登录使用个性化定制服务。</li></ul><p>从运营商角度看：</p><ul><li>云计算是一种新的计算方法和商业模式。</li><li>通过虚拟化等技术按照“即插即用”的方式，自主管理</li></ul><a id="more"></a><h2 id="云计算分类"><a href="#云计算分类" class="headerlink" title="云计算分类"></a>云计算分类</h2><h3 id="按云计算服务层面进行分类"><a href="#按云计算服务层面进行分类" class="headerlink" title="按云计算服务层面进行分类"></a>按云计算服务层面进行分类</h3><ul><li>SaaS：Software as a Service （提供各种应用软件服务）</li><li>PaaS： Platform as a Service （提供软件支撑平台）</li><li>IaaS： Infrastructure as a Service （提供接近于裸机物理机、虚拟机的计算资源和基础设施服务）</li></ul><h3 id="按云计算系统类型进行分类"><a href="#按云计算系统类型进行分类" class="headerlink" title="按云计算系统类型进行分类"></a>按云计算系统类型进行分类</h3><ul><li>公用云：提供面向社会大众、公共群体的云计算服务（如 Amazon 云平台），优点很多，最大缺点是难以保证数据的私密性</li><li>私有云：提供面向应用行业/组织内的云计算服务。如政府机关、移动通信、学校内部使用的云平台。</li></ul><h2 id="云计算体系结构"><a href="#云计算体系结构" class="headerlink" title="云计算体系结构"></a>云计算体系结构</h2><p>CRM: Customer relationship management (CRM) is a technology for managing all your company’s relationships and interactions with customers and potential customers</p><p>ERP: 企业资源计划即 ERP (Enterprise Resource Planning)</p><p>OA: 办公自动化系统</p><p>思考题、调研：VDISK software defined AOP</p><h2 id="云计算业务模式"><a href="#云计算业务模式" class="headerlink" title="云计算业务模式"></a>云计算业务模式</h2><h2 id="云计算发展现状与趋势"><a href="#云计算发展现状与趋势" class="headerlink" title="云计算发展现状与趋势"></a>云计算发展现状与趋势</h2><ul><li>云计算提供一种新的计算模式和服务模式</li><li>通过云计算人们能获得前所未有的强大计算能力，并能按需分配，按需付费</li><li>通过云计算平台强大的计算和存储能力，人们将能完成更难的问题。</li></ul><p>趋势</p><ul><li>云计算与管道、业务软件捆绑</li><li>整合行业软件构建 SaaS 解决方案（微软，IBM，Amazon marketplace）</li><li>PaaS 称为云计算热点<ul><li>中小企业客户需要 PaaS 服务</li></ul></li></ul><p>个性化定制和应用集成（思考题、调研：EAI 企业应用集成，持续集成）</p><p>关注的需求点</p><h2 id="云计算解决的主要问题"><a href="#云计算解决的主要问题" class="headerlink" title="云计算解决的主要问题"></a>云计算解决的主要问题</h2><p>用一个集中管理的巨大化的计算资源池，提供巨大的计算资源和能力</p><ul><li>为小粒度应用体哦概念股资源共享</li><li>为大粒度应用提供大规模计算能力</li><li>（自己补充）对特定计算逻辑以服务形式提供（方便客户）</li></ul><h2 id="云计算关键技术"><a href="#云计算关键技术" class="headerlink" title="云计算关键技术"></a>云计算关键技术</h2><p>举几个典型的来说</p><h3 id="快速部署"><a href="#快速部署" class="headerlink" title="快速部署"></a>快速部署</h3><ul><li>并行部署技术<ul><li>讲传统顺序部署方式改位并行执行，执行多个部署任务</li><li>将虚拟机同时部署到多个物理机上</li></ul></li><li>协同部署技术</li></ul><h3 id="资源调度"><a href="#资源调度" class="headerlink" title="资源调度"></a>资源调度</h3><p>在不同的资源使用者之间进行资源调整的过程</p><ul><li>调整计算任务的资源使用量</li><li>转移计算任务</li></ul><p>云计算新的挑战</p><ul><li>海量规模</li><li>满足服务级别协定</li></ul><p>个人理解：某种角度来看资源调度可以作为负载均衡能力的基础设施</p><h3 id="多租户技术"><a href="#多租户技术" class="headerlink" title="多租户技术"></a>多租户技术</h3><ul><li>大量用户共享同一堆栈的软、硬件资源</li><li>技术难点<ul><li>数据隔离 blabla</li></ul></li></ul><h3 id="大规模数据通信"><a href="#大规模数据通信" class="headerlink" title="大规模数据通信"></a>大规模数据通信</h3><h3 id="大规模分布式存储"><a href="#大规模分布式存储" class="headerlink" title="大规模分布式存储"></a>大规模分布式存储</h3><h3 id="许可证管理与计费"><a href="#许可证管理与计费" class="headerlink" title="许可证管理与计费"></a>许可证管理与计费</h3><h3 id="怎样算是云计算系统"><a href="#怎样算是云计算系统" class="headerlink" title="怎样算是云计算系统"></a>怎样算是云计算系统</h3><p>两个最主要的特征</p><h2 id="云计算的技术挑战"><a href="#云计算的技术挑战" class="headerlink" title="云计算的技术挑战"></a>云计算的技术挑战</h2><h3 id="安全性"><a href="#安全性" class="headerlink" title="安全性"></a>安全性</h3><p>所有云节点都有可能被攻击，现有软件系统该如何调整。</p><h3 id="可用性"><a href="#可用性" class="headerlink" title="可用性"></a>可用性</h3><ul><li>软件系统在一定时间内正常工作的时间占总时间的比重，通常用百分比衡量</li><li>云计算环境能够</li></ul><h3 id="可伸缩性"><a href="#可伸缩性" class="headerlink" title="可伸缩性"></a>可伸缩性</h3><ul><li>通过资源的增加或减少来应对负载的变换，并保持一致的性能<ul><li>垂直伸缩 Scale in： 在现有的服务节点上增加或者减少资源</li><li>水平伸缩 ： 在现有的服务节点上增加或减少服务节点</li></ul></li></ul><h3 id="信息保密"><a href="#信息保密" class="headerlink" title="信息保密"></a>信息保密</h3><ul><li>信息的内容不应该被未授权的人得到</li><li>非法用户访问难度较大</li><li>根本方法上<ul><li>逻辑/物理进行数据隔离</li></ul></li></ul><h3 id="高性能"><a href="#高性能" class="headerlink" title="高性能"></a>高性能</h3><h3 id="标准化"><a href="#标准化" class="headerlink" title="标准化"></a>标准化</h3><p>维护多个云之间的数据</p>]]></content>
    
    
    <categories>
      
      <category>Computer Science</category>
      
      <category>分布式系统</category>
      
    </categories>
    
    
    <tags>
      
      <tag>分布式系统</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>多媒体原理与系统——视频应用系统程序设计</title>
    <link href="/post/36f994e1.html"/>
    <url>/post/36f994e1.html</url>
    
    <content type="html"><![CDATA[<h1 id="错误整理区分"><a href="#错误整理区分" class="headerlink" title="错误整理区分"></a>错误整理区分</h1><h2 id="YUV-采样格式与存储样式差异"><a href="#YUV-采样格式与存储样式差异" class="headerlink" title="YUV 采样格式与存储样式差异"></a>YUV 采样格式与存储样式差异</h2><p>采样格式（描述采样频率比例）</p><div class="table-container"><table><thead><tr><th style="text-align:left">采样比例</th><th style="text-align:left">含义</th></tr></thead><tbody><tr><td style="text-align:left">4:4:4</td><td style="text-align:left">表示色度频道没有下采样。</td></tr><tr><td style="text-align:left">4:2:2</td><td style="text-align:left">表示 2:1 的水平下采样，没有垂直下采样。对于每两个 U 样例或 V 样例，每个扫描行都包含四个 Y 样例。</td></tr><tr><td style="text-align:left">4:2:0</td><td style="text-align:left">表示 2:1 的水平下采样，2:1 的垂直下采样。</td></tr><tr><td style="text-align:left">4:1:1</td><td style="text-align:left">表示 4:1 的水平下采样，没有垂直下采样。对于每个 U 样例或 V 样例，每个扫描行都包含四个 Y 样例。与其他格式相比，4:1:1 采样不太常用，本文不对其进行详细讨论。</td></tr></tbody></table></div><h2 id="存储样式"><a href="#存储样式" class="headerlink" title="存储样式"></a>存储样式</h2><p><code>YU12格式</code>：不是交错存储的</p><blockquote><p>在 android 平台下也叫作 I420 格式，首先是所有 Y 值，然后是所有 U 值，最后是所有 V 值。</p></blockquote><p><code>YV12格式</code>：YV12 格式与 YU12 基本相同，首先是所有 Y 值，然后是所有 V 值，最后是所有 U 值。只要注意从适当的位置提取 U 和 V 值，YU12 和 YV12 都可以使用相同的算法进行处理。</p><p><code>NV21格式</code>：android 手机从摄像头采集的预览数据一般都是 NV21，存储顺序是先存 Y，再 VU 交替存储，NV21 存储顺序是先存 Y 值，再 VU 交替存储：YYYYVUVUVU，以 4 X 4 图片为例子，占用内存为 4 X 4 X 3 / 2 = 24 个字节</p><p><code>NV12格式</code>：NV12 与 NV21 类似，也属于 YUV420SP 格式，NV12 存储顺序是先存 Y 值，再 UV 交替存储：YYYYUVUVUV，以 4 X 4 图片为例子，占用内存为 4 X 4 X 3 / 2 = 24 个字节</p><a id="more"></a>]]></content>
    
    
    <categories>
      
      <category>Computer Science</category>
      
      <category>多媒体原理与系统</category>
      
    </categories>
    
    
    <tags>
      
      <tag>多媒体原理与系统</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>USTCReadingGroup——Raft-an-Understandable-Consensus-Algorithm</title>
    <link href="/post/a6b62976.html"/>
    <url>/post/a6b62976.html</url>
    
    <content type="html"><![CDATA[<!--文章由 3step 模板生成三步法阅读文献笔记记录--><h1 id="Step-1"><a href="#Step-1" class="headerlink" title="Step 1"></a>Step 1</h1><h2 id="题目摘要引言"><a href="#题目摘要引言" class="headerlink" title="题目摘要引言"></a>题目摘要引言</h2><h3 id="题目"><a href="#题目" class="headerlink" title="题目"></a>题目</h3><p>寻找一种<strong>容易理解</strong>的（分布式）一致性算法——Raft。</p><h3 id="摘要"><a href="#摘要" class="headerlink" title="摘要"></a>摘要</h3><p>Raft 是解决 log replication management 的分布式共识算法，相当于(multi-)Paxos 效果，且比 Paxos 高效、易懂，为构建实际系统提供了更好的基础。用多数投票保证了安全性。</p><h3 id="引言"><a href="#引言" class="headerlink" title="引言"></a>引言</h3><h2 id="基本理论概况"><a href="#基本理论概况" class="headerlink" title="基本理论概况"></a>基本理论概况</h2><h2 id="结论部分"><a href="#结论部分" class="headerlink" title="结论部分"></a>结论部分</h2><!-- 确定作者的成过以及点出的经验、问题、改进方 --><h2 id="回答基本问题"><a href="#回答基本问题" class="headerlink" title="回答基本问题"></a>回答基本问题</h2><ol><li>类别</li></ol><!-- 这篇论文是什么类型？测试类？对现有系统进行分析的？对原型系统进行描述的？--><ol><li>内容</li></ol><!-- 你读过的其他论文有没有与之相关的？相关性与区别最直接体现在哪里？文章中分析问题用的什么理论基础（通过瞥一眼数学概况与核心证明可以得到）。 --><ol><li>正确性</li></ol><!-- 结论是否看起来真实有效？ --><ol><li>创新点</li></ol><!-- 论文的主要创新点是什么？总结提到的经验、问题和改进方法是什么？ --><ol><li>清晰度</li></ol><!-- 这篇论文是否写的条理清晰 --><h2 id="阅读选择"><a href="#阅读选择" class="headerlink" title="阅读选择"></a>阅读选择</h2><!--1. 继续阅读：论文有价值担保，研究领域非常切合，对当前进行工作有极大帮助，圈内爆火文章2. 不继续阅读：论文不吸引自己，论文价值/正确性存疑，论文作者给出了不适当的假设。3. 库存保留并标记：当前不处于自己的研究领域，但不久的日后相关论文会有用。--><a id="more"></a><h1 id="Step-2"><a href="#Step-2" class="headerlink" title="Step 2"></a>Step 2</h1><h2 id="细读笔记"><a href="#细读笔记" class="headerlink" title="细读笔记"></a>细读笔记</h2><!-- 要仔细阅读论文，但是诸如证明等信息要忽略掉 --><h2 id="问题记录"><a href="#问题记录" class="headerlink" title="问题记录"></a>问题记录</h2><h2 id="未读（且值得读）文献记录"><a href="#未读（且值得读）文献记录" class="headerlink" title="未读（且值得读）文献记录"></a>未读（且值得读）文献记录</h2><!-- 在第二步中，找到以上几篇论文中相同的引用文献、在引用文献中重复的作者名，这些就是你所调研领域的重点论文和科研人员，下载那些重点论文暂时搁到一边。继续访问那些重要科研人员的网页，看下那些论文是在什么会议集结出版的。这能帮你找到那个领域的顶级会议，因为那些重要科研人员通常会在顶级会议发表论文。 --><h1 id="Step-3"><a href="#Step-3" class="headerlink" title="Step 3"></a>Step 3</h1><!-- 试着“在脑中重新实现（virtually re-implement）”那篇论文：也就是，和作者一样做出相同的假设，然后重新实现相同的工作。通过对比你自己得出的和论文中给出的结果，不仅可以很轻易验证一篇论文的创新点是否真实，而且还能发现论文中不会讲的缺点和假想。 --><h2 id="思路复现"><a href="#思路复现" class="headerlink" title="思路复现"></a>思路复现</h2><!-- 推敲作者是如何立题，如何找到突破口，在其中是否有抉择，如何做出的假设？ --><h2 id="证明与推理复现"><a href="#证明与推理复现" class="headerlink" title="证明与推理复现"></a>证明与推理复现</h2><!-- 分析证明过程，确定证明的正确性以及完整性。对证明过程做拓展，调研证明思路来源 --><h2 id="实验验证复现"><a href="#实验验证复现" class="headerlink" title="实验验证复现"></a>实验验证复现</h2><!-- Rework -->]]></content>
    
    
    <categories>
      
      <category>Research</category>
      
      <category>Paper</category>
      
    </categories>
    
    
    <tags>
      
      <tag>Paper</tag>
      
      <tag>三步法</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>USTCReadingGroup——CRaft</title>
    <link href="/post/262d18ab.html"/>
    <url>/post/262d18ab.html</url>
    
    <content type="html"><![CDATA[<!--文章由 3step 模板生成三步法阅读文献笔记记录--><h1 id="Step-1"><a href="#Step-1" class="headerlink" title="Step 1"></a>Step 1</h1><h2 id="题目摘要引言"><a href="#题目摘要引言" class="headerlink" title="题目摘要引言"></a>题目摘要引言</h2><h3 id="题目"><a href="#题目" class="headerlink" title="题目"></a>题目</h3><p>Erasure-coding-supported 版本的 Raft（协议？），目的是降低存储消耗和网络消耗。</p><h3 id="摘要"><a href="#摘要" class="headerlink" title="摘要"></a>摘要</h3><p>共识协议可以为分布式系统提供高效可用的分布式服务。在这些写一下，对系统的访问日志复制到多个 server 上。但是完整的 replication 产生了很大的网络与存储开销。</p><p><code>Erasure coding</code> 是降低存储和网络开销的一种常见手段。将 complete-entry replication 替换为 erasure coding replication，可以极大地降低开销。RS-Paxos 式第一个支持 Erasure-coding 的共识协议，本文指出 RS-Paxos 的活力问题，尝试解决并提出了 CRAFT。 不仅使用<code>Erasure coding</code>来减少开销，同时又具备与 Raft 一样的活动性。</p><h2 id="基本理论概况"><a href="#基本理论概况" class="headerlink" title="基本理论概况"></a>基本理论概况</h2><p>1</p><h2 id="结论部分"><a href="#结论部分" class="headerlink" title="结论部分"></a>结论部分</h2><!-- 确定作者的成过以及点出的经验、问题、改进方 --><h2 id="回答基本问题"><a href="#回答基本问题" class="headerlink" title="回答基本问题"></a>回答基本问题</h2><ol><li>类别</li></ol><!-- 这篇论文是什么类型？测试类？对现有系统进行分析的？对原型系统进行描述的？--><ol><li>内容</li></ol><!-- 你读过的其他论文有没有与之相关的？相关性与区别最直接体现在哪里？文章中分析问题用的什么理论基础（通过瞥一眼数学概况与核心证明可以得到）。 --><ol><li>正确性</li></ol><!-- 结论是否看起来真实有效？ --><ol><li>创新点</li></ol><!-- 论文的主要创新点是什么？总结提到的经验、问题和改进方法是什么？ --><ol><li>清晰度</li></ol><!-- 这篇论文是否写的条理清晰 --><h2 id="阅读选择"><a href="#阅读选择" class="headerlink" title="阅读选择"></a>阅读选择</h2><!--1. 继续阅读：论文有价值担保，研究领域非常切合，对当前进行工作有极大帮助，圈内爆火文章2. 不继续阅读：论文不吸引自己，论文价值/正确性存疑，论文作者给出了不适当的假设。3. 库存保留并标记：当前不处于自己的研究领域，但不久的日后相关论文会有用。--><a id="more"></a><h1 id="Step-2"><a href="#Step-2" class="headerlink" title="Step 2"></a>Step 2</h1><h2 id="细读笔记"><a href="#细读笔记" class="headerlink" title="细读笔记"></a>细读笔记</h2><!-- 要仔细阅读论文，但是诸如证明等信息要忽略掉 --><h2 id="问题记录"><a href="#问题记录" class="headerlink" title="问题记录"></a>问题记录</h2><h2 id="未读（且值得读）文献记录"><a href="#未读（且值得读）文献记录" class="headerlink" title="未读（且值得读）文献记录"></a>未读（且值得读）文献记录</h2><!-- 在第二步中，找到以上几篇论文中相同的引用文献、在引用文献中重复的作者名，这些就是你所调研领域的重点论文和科研人员，下载那些重点论文暂时搁到一边。继续访问那些重要科研人员的网页，看下那些论文是在什么会议集结出版的。这能帮你找到那个领域的顶级会议，因为那些重要科研人员通常会在顶级会议发表论文。 --><h1 id="Step-3"><a href="#Step-3" class="headerlink" title="Step 3"></a>Step 3</h1><!-- 试着“在脑中重新实现（virtually re-implement）”那篇论文：也就是，和作者一样做出相同的假设，然后重新实现相同的工作。通过对比你自己得出的和论文中给出的结果，不仅可以很轻易验证一篇论文的创新点是否真实，而且还能发现论文中不会讲的缺点和假想。 --><h2 id="思路复现"><a href="#思路复现" class="headerlink" title="思路复现"></a>思路复现</h2><!-- 推敲作者是如何立题，如何找到突破口，在其中是否有抉择，如何做出的假设？ --><h2 id="证明与推理复现"><a href="#证明与推理复现" class="headerlink" title="证明与推理复现"></a>证明与推理复现</h2><!-- 分析证明过程，确定证明的正确性以及完整性。对证明过程做拓展，调研证明思路来源 --><h2 id="实验验证复现"><a href="#实验验证复现" class="headerlink" title="实验验证复现"></a>实验验证复现</h2><!-- Rework --><h1 id="ReadingGroup-会议"><a href="#ReadingGroup-会议" class="headerlink" title="ReadingGroup 会议"></a>ReadingGroup 会议</h1><h2 id="目标"><a href="#目标" class="headerlink" title="目标"></a>目标</h2><p>减少网络存储开销</p><h2 id="Erasure-Code"><a href="#Erasure-Code" class="headerlink" title="Erasure Code"></a>Erasure Code</h2><p>切割编码，一种冗余 Replication 的技术。</p><p>和密码学中的秘密分割不同，从需求看，秘密分割需要保证分割部分不能推测出原有秘密信息（哪怕部分）。纠删码则不考虑这一层，它只需要保证可恢复，且可应用于传输 transport 过程中。</p><ul><li>Reed-Solomon(RS) Code</li></ul><p>流程解释</p><h2 id="Raft"><a href="#Raft" class="headerlink" title="Raft"></a>Raft</h2><p>只讲所需部分</p><ul><li>Term 任期<ul><li>逻辑时间</li><li>一个任期最多有一个 leader</li></ul></li><li>Tree states<ul><li>Follower: 已有 Leader 的 Follower</li><li>Candidate： 没有 Leader 的时候称为候选人</li><li>Leader： 具备 Leader 性质</li></ul></li><li>Preoperty<ul><li>Safty</li><li>Liveness 容灾能力 N=2F+1<ul><li>本文要考虑的性质</li><li>最大容灾能力 F level</li></ul></li></ul></li></ul><h2 id="RS-Paxos"><a href="#RS-Paxos" class="headerlink" title="RS-Paxos"></a>RS-Paxos</h2><ul><li>User (k,m)-RS code</li></ul><p>这个协议的问题，容灾能力有问题，小于 F。</p><h2 id="CRaft-设计思考"><a href="#CRaft-设计思考" class="headerlink" title="CRaft 设计思考"></a>CRaft 设计思考</h2><p>需要一个完整块，反证法证明</p><h2 id="Code-fragment-Replication"><a href="#Code-fragment-Replication" class="headerlink" title="Code-fragment Replication"></a>Code-fragment Replication</h2><p>编码分块副本策略</p><ul><li>当数据被 F+k 块存储后，Data 就被承认了<ul><li>选取任意 F+1 个分块，</li></ul></li><li>如果数据被小于 F+k 块存储<ul><li>需要使用 完整块</li><li>p = 0</li></ul></li></ul><p>如何把编码分块和完整块共同利用</p><h2 id="Prediction"><a href="#Prediction" class="headerlink" title="Prediction"></a>Prediction</h2><p>一种贪心的策略</p><ul><li>使用最近的心跳回答来预测，可能会失败</li></ul><h2 id="New-Leader"><a href="#New-Leader" class="headerlink" title="New Leader"></a>New Leader</h2><p>需要增加新的过程 LeaderPre。</p><p>分类讨论，对于新 Leader。</p><p>Log 分类</p><ul><li>commited 保证了 F+1 可用？？</li><li>uncommitted 好一点的情况，能搜寻够 Fragment，或者搜寻到完整块，最差的情况，需要抛弃。</li></ul><h2 id="设计总结"><a href="#设计总结" class="headerlink" title="设计总结"></a>设计总结</h2><p>Cheng Li: 很想 RS-Paxos</p><p>Raft 中：Leader 一定不会 merge、删除我的日志。</p><p>CRaft 中：三类情况下的最差情况，可能会删除。</p><p>理论证明删除的影响。。</p><h2 id="Theorem"><a href="#Theorem" class="headerlink" title="Theorem"></a>Theorem</h2><ul><li>Log Matching Property</li><li><p>Leader Completeness Property 完全信任性质</p><ul><li>如果一个 log entry，在 givern term T 时提交，那就会。。。 没太懂，这个性质在 CRaft 中满足性质。</li></ul></li><li><p>State Machine Safety Property</p><ul><li>由前两个性质可以推得，在 CRaft 中也同样满足的性质。</li></ul></li></ul><p>一个重要的东西</p>]]></content>
    
    
    <categories>
      
      <category>Research</category>
      
      <category>Paper</category>
      
    </categories>
    
    
    <tags>
      
      <tag>Paper</tag>
      
      <tag>三步法</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>分布式系统学习——分布式存储与数据库系统</title>
    <link href="/post/5afaf228.html"/>
    <url>/post/5afaf228.html</url>
    
    <content type="html"><![CDATA[<h1 id="分布式数据库系统"><a href="#分布式数据库系统" class="headerlink" title="分布式数据库系统"></a>分布式数据库系统</h1><p>什么是分布式数据库，分布在计算机网络上逻辑相互关联的</p><p>DDBS，</p><p>分布式</p><p>数据特性，</p><p>文件的操作，如何做索引，大数据排序。数据库的实现上还是经常用到了底层文件</p><p>自己查！！！</p><h2 id="分布式数据库系统的特点"><a href="#分布式数据库系统的特点" class="headerlink" title="分布式数据库系统的特点"></a>分布式数据库系统的特点</h2><p>集中和自治相结合</p><ol><li>适当增加数据冗余度<ol><li>提高系统的可靠性、可用性</li><li>提高系统性能</li></ol></li><li>全局的一致性、可串行性</li></ol><h2 id="分布式数据库系统的体系结构"><a href="#分布式数据库系统的体系结构" class="headerlink" title="分布式数据库系统的体系结构"></a>分布式数据库系统的体系结构</h2><p>！图</p><a id="more"></a><h3 id="数据分片"><a href="#数据分片" class="headerlink" title="数据分片"></a>数据分片</h3><p>分片应满足的条件：</p><ul><li>完全性</li><li>不相交性</li><li>可重构性</li></ul><h3 id="分布透明性"><a href="#分布透明性" class="headerlink" title="分布透明性"></a>分布透明性</h3><ul><li><p>分片透明性（最高层次）</p><p>用户或程序只对全局关系进行操作而不必考虑关系分片</p></li><li><p>位置透明</p><p>不必了解片段的存储场地，当存储场地变了，分片模式到分布模式的映像，不必改变</p></li><li><p>局部数据模型透明</p><p>用户不用考虑局部 DBMS 所支持的数据模型、使用哪种数据操纵语言。外层针对内模式（Schema）差异透明了。</p></li></ul><h3 id="分布式数据库管理系统"><a href="#分布式数据库管理系统" class="headerlink" title="分布式数据库管理系统"></a>分布式数据库管理系统</h3><p>！图</p><p>同构、异构、同构同质、同构异质</p><h4 id="Components-of-DDBMS"><a href="#Components-of-DDBMS" class="headerlink" title="Components of DDBMS"></a>Components of DDBMS</h4><ul><li><code>User Processor</code>:<ul><li><code>User interface</code>用户接口处理器：interpret 用户命令并格式化返回结果。思考：Format 的方法。</li><li><code>Semantic data controller</code>语义数据控制器：检查完整性约束与授权。</li><li><code>Global query optimizer and decomposer</code>全局查询分解器：查询策略优化。</li><li><code>Global monitor</code>全局管程：监视整体进行状态。</li></ul></li><li><code>Data Processor</code>:<ul><li><code>Local query processor</code>本地查询器：</li><li><code>Local ..</code></li></ul></li></ul><p>总结，DDBMS 由四部分组成</p><ul><li>局部数据库</li><li>全局数据库</li><li>…</li><li>全局数据字典</li></ul><h3 id="查询处理与优化"><a href="#查询处理与优化" class="headerlink" title="查询处理与优化"></a>查询处理与优化</h3><p><code>Query Processing</code></p><ul><li>高层 high-level 语句扫描，语义更正</li><li>高层语句转换为内部查询表示，转化为查询图</li><li>…</li></ul><p>何时优化</p><p>静态优化：在查询执行前（编译阶段），确定优化形式<br>动态优化：查询执行中进行优化（常为启发式的）</p><p>利用 CNF BNF 简化，并进行约束判断。</p><p>Rewriting，利用关系代数重写规则。</p><p>数据的本地化问题</p><ul><li>确定涉及了哪些分片</li><li>执行本地化程序<ul><li>物化</li><li>semi-join Materialization 是用于 semi-join 的一种特殊的子查询物化技术</li></ul></li></ul><p>优化算法</p><p>基本代价模型</p><ul><li>代价组件</li><li>组件权值</li><li>单个操作的代价</li></ul><p>基于半连接的优化策略与连接优化策略。</p><p>采用连接方案还是半连接方案，取决于数据传输和局部处理的相对费用。若传输费用是主要的，则采用半连接方案；若局部处理费用是主要的，采用连接方案。</p><p>同一个场地的两个关系</p><ul><li>嵌套循环法：</li><li>排序扫描法：</li></ul><p>若两个关系在不同场地</p><ul><li>整体传输</li><li>按需传输</li></ul><p>上述方案可以搭配使用</p><h2 id="分布事务管理"><a href="#分布事务管理" class="headerlink" title="分布事务管理"></a>分布事务管理</h2><p>自学</p><p>分布式事务执行的控制模型</p><ul><li>主从控制模型</li><li>三角控制模型</li><li>层次控制模型</li></ul><h2 id="小结"><a href="#小结" class="headerlink" title="小结"></a>小结</h2><ol><li>DDBS 的基本特点：物理分布性、逻辑整体性、场地自治性、场地见的协作性</li><li>DDBS 的分类：同构同质、同构异质</li><li>分布透明性的三个级别</li><li>半连接优化算法的操作过程</li></ol>]]></content>
    
    
    <categories>
      
      <category>Computer Science</category>
      
      <category>分布式系统</category>
      
    </categories>
    
    
    <tags>
      
      <tag>分布式系统</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>分布式系统学习——分布式计算范型</title>
    <link href="/post/fd8d8293.html"/>
    <url>/post/fd8d8293.html</url>
    
    <content type="html"><![CDATA[<p>本章对分布式应用中各种范型进行<strong>分类</strong>，介绍基于这些范型的<strong>典型工具</strong>和<strong>协议</strong>。</p><h1 id="范型和抽象"><a href="#范型和抽象" class="headerlink" title="范型和抽象"></a>范型和抽象</h1><h2 id="抽象"><a href="#抽象" class="headerlink" title="抽象"></a>抽象</h2><p><code>抽象-&gt;理论-&gt;设计</code>，计算机科学研究的三种形态，对应学科问题求解中三个典型过程。</p><p><code>抽象</code>：源于实验学科，抽象的结果是<strong>概念、符号、模型</strong>。</p><p><code>理论</code>：源于数理，主要为定义、定理、公理、证明与结果解释，研究内容跟的基本特征是构造性数学特征。</p><p><code>设计</code>：源于工程学，用来开发求解给定问题的系统和设备主要是需求说明。</p><h2 id="范型"><a href="#范型" class="headerlink" title="范型"></a>范型</h2><p>范型是<strong>一种模式、例子、模型</strong>。（不同形式语言有不同的范型，面向对象、底层 blabla）。<strong>识别基本模型并根据模型分类在研究解决复杂问题时非常有用。</strong></p><p>本章视图描述分布式系统模型、应用的范型、物理模型等等进行分类。</p><a id="more"></a><h2 id="系统模型分类"><a href="#系统模型分类" class="headerlink" title="系统模型分类"></a>系统模型分类</h2><p><code>物理模型</code>：考虑组成系统的计算机和设备的类型以及它们的<strong>互联</strong>，不涉及特定的技术细节。</p><p><code>体系结构模型</code>：从系统的计算元素执行的<strong>计算和通信任务</strong>来描述系统。</p><p><code>基础模型</code>：采用抽象的挂点描述大多数分布式系统面临的单个问题的方案。（交互模型 &amp;&amp; 故障模型 &amp;&amp; 安全模型）。</p><h3 id="物理模型"><a href="#物理模型" class="headerlink" title="物理模型"></a>物理模型</h3><p><strong>早期分布式系统</strong>和初期<strong>互联网规模的分布式系统</strong>特征静态、分立、自治。</p><p><strong>当代的分布式系统</strong>特征</p><ul><li>移动计算：节点移动</li><li>无处不在的计算：嵌入日常物品周围环境</li><li>云计算：一组节点提供给定服务</li></ul><h3 id="体系结构模型"><a href="#体系结构模型" class="headerlink" title="体系结构模型"></a>体系结构模型</h3><p>一个系统体系结构是指：各个独立指定组件的<strong>结构</strong>，</p><ul><li><strong>整体目标</strong>：确保<strong>结构</strong>能满足现在和将来可能的需求。</li><li><strong>主要关心</strong>：系统可靠性、适应性、可管理型和性价比</li></ul><p>体系结构元素与常见问题</p><ul><li>通信实体是什么</li><li>如何通信（通信范型）</li><li>扮演的角色及承担的责任是什么</li><li>如何映射到具体的基础设施上（放置）</li></ul><h4 id="体系结构元素——通信实体"><a href="#体系结构元素——通信实体" class="headerlink" title="体系结构元素——通信实体"></a>体系结构元素——通信实体</h4><ul><li>面向系统的角度：线程、进程、结点。</li><li><p>面向问题的角度：对象（自然单元）、组件（提供的接口和所需接口）、Web 服务（经常跨越组织边界）。</p></li><li><p>进程间通信：相对底层支持（套接字、多播、消息传递）</p></li><li><p>远程调用：最常见的通信范型，双向交换</p><ul><li>请求——应答协议（RR）：一对消息的交换</li><li>远程过程调用（RPC）：远程计算机上进程中的过程能被调用</li><li><p>远程方法调用（RMI）：一个发起调用的对象可以调用一个远程对象中的方法</p><p>进程通信及远程调用的限制：</p></li><li><p>发送者需要知道接收者（空间耦合）</p></li><li>发送者和接收者同时存在（时间耦合）</li></ul></li><li><p>间接通信（时间空间解耦合）</p><ul><li>组通信：一对多通信范型</li><li>发布——订阅系统：提供一个中间服务，有效确保生产者生成的消息被路由到需要这个消息的消费者（体系结构生产者消费者问题特化，特对特）</li><li>消息队列：提供点到点服务</li><li>元组空间：进程可把任意结构化数据存放在一个持久化元组空间，其他进程可读可删除。</li><li>分布式共享内存：用于支持在不共享物理内存的进程间共享数据</li></ul></li></ul><p>小结</p><p><img src="https://eddyblog.oss-cn-shenzhen.aliyuncs.com/DistributeSystemLearning/DistributeParadigms/distribute_paradigms_1.png" srcset="/img/loading.gif" alt="Distribute_Paradigms_1"></p><h4 id="体系结构元素——中间件内容补充"><a href="#体系结构元素——中间件内容补充" class="headerlink" title="体系结构元素——中间件内容补充"></a>体系结构元素——中间件内容补充</h4><p>操作系统及以下，归为平台（Platform），最上层是应用服务，中间有一个中间件（MiddleWare）。</p><p><strong>中间件提供一个编程抽象来屏蔽异构问题</strong>，主要解决包括：</p><ul><li>硬件<ul><li>数据类型在不同硬件平台上表示不同</li><li>存储方式不同（PowerPC 采用 big-endian，X86 采用 little-endian）</li></ul></li><li>通信协议<ul><li>独立于网络底层的传输协议（底层无关）</li></ul></li><li>操作系统<ul><li>在操作系统上提供更高级的抽象 API，屏蔽操作系统级的异构</li></ul></li><li>编程语言<ul><li>CORBA 通过 IDL，可以使得不同的语言写的代码互相调用</li><li>CORBA——公共对象请求代理结构</li></ul></li></ul><h4 id="体系结构模型——分布式系统结构的设计需求"><a href="#体系结构模型——分布式系统结构的设计需求" class="headerlink" title="体系结构模型——分布式系统结构的设计需求"></a>体系结构模型——分布式系统结构的设计需求</h4><p>设计考虑：</p><ul><li>系统组件间的责任划分</li><li>组件在网络上的放置</li><li>等等</li></ul><p>影响 1：<strong>性能问题</strong></p><ul><li>响应能力<ul><li>服务器和网络负载</li><li>OS 中间件与代码引起的延迟</li></ul></li><li>吞吐量</li><li>负载平衡</li></ul><p>影响 2：<strong>QoS 服务质量</strong></p><ul><li>可靠性、安全性</li><li>适应性</li><li>性能一般体现在响应与吞吐，但是还有一些新的解释</li><li>强时间性数据（time-critical data）</li><li>QoS 可以在操作系统层、网络层等多个层级实现</li></ul><p>影响 3：<strong>缓存和复制的使用</strong></p><ul><li>缓存复用频度</li><li>优化访问时间</li></ul><p>影响 4：<strong>可靠性问题</strong></p><ul><li>正确性<ul><li>形式化验证</li><li>Model Checking</li><li>测试技术</li></ul></li><li>容错性<ul><li>冗余是关键</li></ul></li><li>安全性<ul><li>保证数据不受攻击</li><li>通过网络访问数据的权限</li></ul></li></ul><h4 id="体系结构模型——客户-服务器模式"><a href="#体系结构模型——客户-服务器模式" class="headerlink" title="体系结构模型——客户-服务器模式"></a>体系结构模型——客户-服务器模式</h4><p>客户端 Client 发出 Invocation，服务端 Server 返回 Result。</p><p>CS 模式 C 端比较肥胖，分担了 S 端一些任务，但同样，result 计算却又只在，S 端进行。S 端和网络也是瓶颈。</p><h4 id="体系结构模型——层次化体系化结构"><a href="#体系结构模型——层次化体系化结构" class="headerlink" title="体系结构模型——层次化体系化结构"></a>体系结构模型——层次化体系化结构</h4><p>层次化与分层体系结构互补，是一项组织给顶层功能的技术。层次化应用功能分解。（MVC，MVV?）</p><ul><li>表示逻辑：用户交互与用户应用视图逻辑</li><li>应用逻辑：设计应用相关（业务逻辑）详细的应用特定储里</li><li>数据逻辑：涉及应用的持久存储，通常在一个数据库管理系统中。</li></ul><h4 id="体系结构模型——P2P-体系化结构"><a href="#体系结构模型——P2P-体系化结构" class="headerlink" title="体系结构模型——P2P 体系化结构"></a>体系结构模型——P2P 体系化结构</h4><p>结构化 P2P（分布式哈希表 DHT 映射）与非结构化 P2P，与混合 P2P</p><h4 id="体系结构模型变体"><a href="#体系结构模型变体" class="headerlink" title="体系结构模型变体"></a>体系结构模型变体</h4><p>思路：</p><ul><li>使用多个服务器和缓存，增加性能和灵活性</li><li>使用移动代码和移动代理</li><li>用户硬件喜好</li><li>弹性扩展删除的需求</li></ul><p>方式</p><ul><li>服务器组</li><li>代理服务器与缓存</li><li>移动代码（服务器与客户端传递）</li><li>移动代理（Server 间传递）</li><li>网络计算机</li></ul><h2 id="分布式通信范型"><a href="#分布式通信范型" class="headerlink" title="分布式通信范型"></a>分布式通信范型</h2><h3 id="进程间通信"><a href="#进程间通信" class="headerlink" title="进程间通信"></a>进程间通信</h3><ul><li>同一节点（操作系统/体系结构中学习）<ul><li>管道</li><li>消息队列</li><li>共享内存</li></ul></li><li>不同节点<ul><li>基于套接字</li><li>报文传递</li></ul></li></ul><h4 id="消息传递"><a href="#消息传递" class="headerlink" title="消息传递"></a>消息传递</h4><ul><li>发送与接收原语</li><li>阻塞/非阻塞：同步型/异步</li><li>有缓冲/无缓冲（Buffer）</li></ul><h4 id="超时和线程"><a href="#超时和线程" class="headerlink" title="超时和线程"></a>超时和线程</h4><p>阻塞机制为 IPC 提供了必要的同步，但导致的无限挂起问题通常不能被接受，解决方案</p><ul><li>超时机制（Timeout）设置最大阻塞期限</li><li>子进程、线程提供组赛操作，主线程 or 父进程可继续其他储里（挂起子进程或子线程）。</li><li>解决死锁（协议误解或者程序错误）</li></ul><h4 id="IPC-数据表示引例"><a href="#IPC-数据表示引例" class="headerlink" title="IPC 数据表示引例"></a>IPC 数据表示引例</h4><p>在网络体系的物理层中，数据被表示成二进制流，并作为模拟信号进行传输。在应用层中，为支持编程语言提供的数据类型和数据结构，需要用更为复杂的数据表示方法来表示待传输的数据。（如 big endian 与 little endian 的问题）</p><p>一些更优的分布式解决方案</p><h4 id="数据编码"><a href="#数据编码" class="headerlink" title="数据编码"></a>数据编码</h4><p>尽管可以用专门定制的程序，采用双方认同的任意一种数据组装方案执行 IPC（IPC 前的额外程序接口），通用分布式应用要求为交换数据编码提供通用的、独立于平台的方案。因此一些有关网络数据编码的标准应运而生。</p><p>外部数据表示和编码</p><p>三种外部数据表示和编码方法</p><ul><li>CORBA 的公共数据表示</li><li>Java 的对象序列化</li><li>XML（可扩展标记语言）</li></ul><p>此外 Goggle 采用协议缓冲区（protocol buffer），JSON（JavaScript Object Notation）也是近年来常用的外部数据表示方法。</p><ul><li>序列化：将一个对象或者一组关联对象打平成适合于磁盘存储或消息传送的串行格式</li><li>解序列化： 从串行格式中恢复对象或一组对象的状态</li></ul><p>Java 反射的应用</p><ul><li>实现了根据类名创建类的能力，以及为给定的类创建具有给定参数类型的构造函数</li><li>反射使得以完成通用的方式进行序列化和反序列化成为可能</li><li>Java 对象序列化使用反射找到要序列化的对象的类名，以及该类的实例变量的名字、类型和值</li></ul><p>（解序列化有时候像一个动态生成类的过程）</p><h4 id="组播通信"><a href="#组播通信" class="headerlink" title="组播通信"></a>组播通信</h4><ul><li>单个消息从一个进程发送到译组进程的每个成员的操作</li><li>组的成员对发送方常是透明的</li><li>组播的行为有很多种情况，最简单的组播不提供消息传递保证或排序保证</li></ul><p>组播消息为构造具有下列特征的分布式系统提供了基础设施：</p><ul><li><strong>基于复制服务的容错</strong>（比如 Raft 协议，Leader Election 过程都是基于组播通信）</li><li>在自发网络中发现服务</li><li>通过复制的数据获得更好的性能（找寻恢复？）</li><li>事件通知的传播（包括内网穿透等）</li></ul><h4 id="网络虚拟化"><a href="#网络虚拟化" class="headerlink" title="网络虚拟化"></a>网络虚拟化</h4><p>网络虚拟化涉及在一个已有的网络之上构造多个不同的虚拟网络</p><p>每个虚拟网络被设计成支持一个特定的分布式应用</p><ul><li>多媒体数据流</li><li>多人在线游戏</li></ul><p>面向特定应用的虚拟网络构建在一个已有的网络上并为特定的应用进行优化，而不改变底层网络的特征。</p><h5 id="覆盖网络"><a href="#覆盖网络" class="headerlink" title="覆盖网络"></a>覆盖网络</h5><p>积淀和虚拟链接组成的虚拟网络，位于一个底层网络之上</p><ul><li>满足一类应用需求的服务器胡总一个特别高层的服务，例如多媒体内容分发</li><li>在一个给定的联网环境中的更有效的操作</li><li>额外特色，例如：组播或安全通道</li></ul><p>好处</p><ul><li>不改变底层网络就能定义新的网络服务<ul><li>取决于该领域标准化的水平和修补底层路由功能的困难</li></ul></li><li>鼓励对网络服务进行实验和对服务进行面向特定应用的定制</li><li>能定义多个覆盖王，它们能同时存在，从而行成更开放和拓展的网络体系结构</li></ul><p>不足</p><ul><li>引入了额外的间接层</li></ul><p>与属虚的分层概念相关</p><ul><li>一个覆盖网是一层，TCP/IP 结构外存在的一层</li><li>DIY 该层核心元素：寻址模式、要采用的协议、路由方法等。</li></ul><h3 id="客户-服务器范型"><a href="#客户-服务器范型" class="headerlink" title="客户-服务器范型"></a>客户-服务器范型</h3><p>注意说的是<strong>通信范型还是体系结构</strong></p><p>CS 范型服务器扮演服务提供者决策，被动地等待请求的到达。</p><h4 id="寻址"><a href="#寻址" class="headerlink" title="寻址"></a>寻址</h4><ul><li>为了发消息给服务器，客户必须知道服务器的地址</li><li>进程编址方法<ul><li>客户机代码中指明机器/进程号（machine，process number）：文件服务器不透明（类似于绝对地址）</li><li>给每个进程分配唯一地址-&gt;中央服务器（单点故障）</li><li>让进程选择随机地址，用广播定位进程：额外的系统负担</li><li>在客户机中存放 ASCII 服务器名字，运行时寻找它：需要命名服务器（有点像 DNS）</li></ul></li></ul><h4 id="阻塞与非阻塞原语"><a href="#阻塞与非阻塞原语" class="headerlink" title="阻塞与非阻塞原语"></a>阻塞与非阻塞原语</h4><ul><li>有一个要求？？消息要是不可修改的（WHY？）</li></ul><h4 id="有缓冲和无缓冲原语"><a href="#有缓冲和无缓冲原语" class="headerlink" title="有缓冲和无缓冲原语"></a>有缓冲和无缓冲原语</h4><ul><li>无缓冲的形式，当多 C 访问 S 时可能会造成消息丢失的问题</li><li>解决：缓冲，邮箱 blablabla</li></ul><h4 id="可靠的和非可靠原语"><a href="#可靠的和非可靠原语" class="headerlink" title="可靠的和非可靠原语"></a>可靠的和非可靠原语</h4><ul><li>可靠：请求后多一个 ACK（内核到内核的确认）</li></ul><h3 id="P2P-范型"><a href="#P2P-范型" class="headerlink" title="P2P 范型"></a>P2P 范型</h3><h4 id="集中目录式结构"><a href="#集中目录式结构" class="headerlink" title="集中目录式结构"></a>集中目录式结构</h4><p>用户注册与文件检索过程类似于传统的 C/S 模式<br>，区别在于<strong>所有资料并非储存在服务器上，而是储存在各个节点中</strong>。查询选择合适的节点建立直接连接。</p><p>这种结构简单，显示系统信息量的巨大优势和吸引力，同时也揭示了 P2P 系统本质上所不可避免的两个问题：法律版权和资源浪费的问题。</p><h4 id="纯-P2P-网络模型"><a href="#纯-P2P-网络模型" class="headerlink" title="纯 P2P 网络模型"></a>纯 P2P 网络模型</h4><p>广播式 P2P，取消集中的中央服务器。现在应用最广泛的纯 P2P 非结构化拓扑模型——Gnutella 模型。</p><p>明显的问题：易受垃圾信息和病毒的恶意攻击，搜索算法是泛洪方式，低效性。</p><h4 id="混合式网络模型"><a href="#混合式网络模型" class="headerlink" title="混合式网络模型"></a>混合式网络模型</h4><p>Kazza 模型是代表，引入超级节点的概念。根据节点能力不同（计算能力、内存大小 blabla）</p><h4 id="结构化网络模型"><a href="#结构化网络模型" class="headerlink" title="结构化网络模型"></a>结构化网络模型</h4><p>结构化/非结构化根本区别：每个节点所维护的邻居是否能够按照某种全局方式组织起来以利于快速查找。</p><p>目前的主流方式：分布式哈希技术（DHT）。目前扩展性最好的 P2P 路由方式质以。借助 DHT 的优势，取消泛洪算法，又可有效达到目标节点。</p><h3 id="远程过程调用范型"><a href="#远程过程调用范型" class="headerlink" title="远程过程调用范型"></a>远程过程调用范型</h3><p>范型简介补充，自行了解</p><ul><li>请求应答协议</li><li>远程过程调用（RPC），将传统的过程调用模型<strong>扩展</strong>到分布式系统中，允许客户程序透明地调用在服务程序中的过程。</li><li>远程方法调用（RMI），基于对象的编程模型的扩展，允许不用进程运行的对象通过其彼此通信。是对本地方法调用的扩展。（数据库操作中，ODBC）</li></ul><h4 id="RPC-主要步骤"><a href="#RPC-主要步骤" class="headerlink" title="RPC 主要步骤"></a>RPC 主要步骤</h4><p>略</p><h4 id="RPC-的设计问题"><a href="#RPC-的设计问题" class="headerlink" title="RPC 的设计问题"></a>RPC 的设计问题</h4><ul><li>RPC 编程风格——接口编程</li><li>RPC 关联的调用语义</li><li>透明性的关键问题和它如何与远程过程调用相关联</li></ul><h4 id="接口编程"><a href="#接口编程" class="headerlink" title="接口编程"></a>接口编程</h4><ul><li>一些编程语言提供了把程序组织成很多个模块+彼此通信的方法。（面向对象编程典型）</li><li>模块间通信依靠模块间过程调用/访问变量</li><li>通过模块定义显示接口，接口访问过程和变量。</li><li>实现的接口可以隐藏除接口外的所有信息，只要模块接口保持相同，模块的实现就可以随意改变而不影响模块的使用。</li></ul><h4 id="分布式系统的接口"><a href="#分布式系统的接口" class="headerlink" title="分布式系统的接口"></a>分布式系统的接口</h4><ul><li>分布式程序中，模块能够运行在不同的进程中</li><li>服务接口，涉及服务器提供过程的说明、定义和每个过程参数的格式</li><li>分布式编程中使用接口的好处<ul><li>对于任何形式的模块化编程，只需要关系服务接口提供的抽象而不需要关注它们的实现细节（比如 Map、Reduce）</li><li>程序员无需知道实现服务的语言和底层平台</li><li>只要接口保持不变，实现可以改变，自然的支持软件的演化。</li></ul></li><li>接口定义受到分布式底层基础设施的影响<ul><li>某进程访问另一个进程中模块的变量是不可能的</li><li>本地过程调用使用参数传递机制，不适用于调用者和过程在不同进程中的情况<ul><li>不支持引用的传递</li><li>某个参数同时作为输入/输出时，请求和应答必须传值</li><li>内存地址无效化，不能作为调用结果返回（没有意义）</li></ul></li></ul></li><li>接口定义语言（IDL）<ul><li>RPC 可以集成在编程语言中</li><li>接口定义语言，跨语言，以不同语言实现过程以便相互调用</li></ul></li></ul>]]></content>
    
    
    <categories>
      
      <category>Computer Science</category>
      
      <category>分布式系统</category>
      
    </categories>
    
    
    <tags>
      
      <tag>分布式系统</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>【LeetCode-847】解题报告（最短路）</title>
    <link href="/post/adac7ee6.html"/>
    <url>/post/adac7ee6.html</url>
    
    <content type="html"><![CDATA[<h1 id="原始题目"><a href="#原始题目" class="headerlink" title="原始题目"></a>原始题目</h1><p>给出  <code>graph</code>  为有 <code>N</code> 个节点（编号为  <code>0</code>, <code>1</code>, <code>2</code>, …, <code>N-1</code>）的无向连通图。</p><p><code>graph.length = N</code>，且只有节点 <code>i</code>  和 <code>j</code>  连通时，<code>j != i</code>  在列表  <code>graph[i]</code>  中恰好出现一次。</p><p>返回能够访问所有节点的最短路径的长度。你可以在任一节点开始和停止，也可以多次重访节点，并且可以重用边。</p><h1 id="题目大意"><a href="#题目大意" class="headerlink" title="题目大意"></a>题目大意</h1><p>给一邻接表表示的图，求访问所有节点的最短路径（任意起点，可重边重点）。</p><h1 id="解题思路"><a href="#解题思路" class="headerlink" title="解题思路"></a>解题思路</h1><p>数位 dp，但这里不涉及转移，只判断状态是否出现过。（vis[1&lt;&lt;N][n]） 第一维表示访问节点造访状态，第二维表示最后访问节点。</p><p>层序遍历 or 队列保存状态，BFS 下首次访问全状态节点即为答案。</p><a id="more"></a><h1 id="解题代码"><a href="#解题代码" class="headerlink" title="解题代码"></a>解题代码</h1><pre><code class="hljs C++"><span class="hljs-meta">#<span class="hljs-meta-keyword">include</span> <span class="hljs-meta-string">&lt;bits/stdc++.h&gt;</span></span><span class="hljs-keyword">using</span> <span class="hljs-keyword">namespace</span> <span class="hljs-built_in">std</span>;<span class="hljs-keyword">typedef</span> <span class="hljs-keyword">long</span> <span class="hljs-keyword">long</span> ll;<span class="hljs-keyword">typedef</span> <span class="hljs-keyword">unsigned</span> <span class="hljs-keyword">long</span> <span class="hljs-keyword">long</span> ulll;<span class="hljs-keyword">typedef</span> <span class="hljs-built_in">vector</span>&lt;<span class="hljs-keyword">int</span>&gt; vi;<span class="hljs-keyword">typedef</span> pair&lt;<span class="hljs-keyword">int</span>, <span class="hljs-keyword">int</span>&gt; pii;<span class="hljs-keyword">typedef</span> pair&lt;<span class="hljs-built_in">string</span>, <span class="hljs-built_in">string</span>&gt; pss;<span class="hljs-meta">#<span class="hljs-meta-keyword">define</span> rep(i, a, n) for (int i = a; i &lt; n; ++i)</span><span class="hljs-meta">#<span class="hljs-meta-keyword">define</span> per(i, a, n) for (int i = n - 1; i &gt;= a; --i)</span><span class="hljs-meta">#<span class="hljs-meta-keyword">define</span> fi first</span><span class="hljs-meta">#<span class="hljs-meta-keyword">define</span> pb push_back</span><span class="hljs-keyword">typedef</span> <span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">Node</span> &#123;</span>    <span class="hljs-keyword">int</span> state;    <span class="hljs-keyword">int</span> val;    <span class="hljs-keyword">int</span> lst;    Node(<span class="hljs-keyword">int</span> s, <span class="hljs-keyword">int</span> v, <span class="hljs-keyword">int</span> l)        : state(s)        , val(v)        , lst(l)    &#123;    &#125;&#125; Node;<span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Solution</span> &#123;</span><span class="hljs-keyword">public</span>:    <span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">shortestPathLength</span><span class="hljs-params">(<span class="hljs-built_in">vector</span>&lt;<span class="hljs-built_in">vector</span>&lt;<span class="hljs-keyword">int</span>&gt;&gt;&amp; graph)</span>    </span>&#123;        <span class="hljs-keyword">int</span> N = graph.size();        <span class="hljs-keyword">int</span> start_state = <span class="hljs-number">0</span>;        <span class="hljs-keyword">int</span> final_state = (<span class="hljs-number">1</span> &lt;&lt; N) - <span class="hljs-number">1</span>;        <span class="hljs-comment">// 不同状态下的dis表</span>        <span class="hljs-built_in">vector</span>&lt;vi&gt; vis(<span class="hljs-number">1</span> &lt;&lt;N ,  vi(N, <span class="hljs-number">0</span>));        <span class="hljs-built_in">queue</span>&lt;Node&gt; q;        rep(i, <span class="hljs-number">0</span>, N)        &#123;            q.push(Node(<span class="hljs-number">1</span> &lt;&lt; i, <span class="hljs-number">0</span>, i));            vis[<span class="hljs-number">1</span> &lt;&lt; i][i] = <span class="hljs-number">1</span>;        &#125;        <span class="hljs-keyword">while</span> (!q.empty()) &#123;            Node now = q.front();            <span class="hljs-keyword">int</span> nxt_p, nxt_state, nxt_value;            q.pop();            rep(i, <span class="hljs-number">0</span>, graph[now.lst].size())            &#123;                <span class="hljs-comment">// cout&lt;&lt;"lst="&lt;&lt;now.lst&lt;&lt;endl;</span>                nxt_p = graph[now.lst][i];                <span class="hljs-comment">// cout&lt;&lt;"nxt_p="&lt;&lt;nxt_p&lt;&lt;endl;</span>                nxt_state = ((<span class="hljs-number">1</span> &lt;&lt; graph[now.lst][i]) | now.state);                <span class="hljs-comment">// cout&lt;&lt;"nxt_state="&lt;&lt;nxt_state&lt;&lt;endl;</span>                <span class="hljs-keyword">if</span> (nxt_state == final_state) &#123;                    <span class="hljs-keyword">return</span> now.val + <span class="hljs-number">1</span>;                &#125;                <span class="hljs-keyword">if</span> (!vis[nxt_state][nxt_p]) &#123;                    vis[nxt_state][nxt_p] = <span class="hljs-number">1</span>;                    q.push(Node(nxt_state, now.val + <span class="hljs-number">1</span>, nxt_p));                &#125;            &#125;        &#125;        <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;    &#125;&#125;;</code></pre><h1 id="收获与反思"><a href="#收获与反思" class="headerlink" title="收获与反思"></a>收获与反思</h1><ul><li>开始仅用访问状态（一维），发现重访问边、节点无法体现，WA。</li><li>在包括该题在内的最短路问题中，BFS 蕴含了 DP 思想。所以该题不但能用 BFS 解，还能用 DP 解</li></ul>]]></content>
    
    
    <categories>
      
      <category>Computer Science</category>
      
      <category>ACM</category>
      
      <category>LeetCode</category>
      
    </categories>
    
    
    <tags>
      
      <tag>ACM</tag>
      
      <tag>LeetCode</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>USTCReadingGroup——How-to-Copy-Files</title>
    <link href="/post/401bef38.html"/>
    <url>/post/401bef38.html</url>
    
    <content type="html"><![CDATA[<!--文章由 3step 模板生成三步法阅读文献笔记记录--><h1 id="Step-1"><a href="#Step-1" class="headerlink" title="Step 1"></a>Step 1</h1><h2 id="题目摘要引言"><a href="#题目摘要引言" class="headerlink" title="题目摘要引言"></a>题目摘要引言</h2><p><code>Copy-on-Write</code>写时拷贝技术，查阅资料发现，有两个应用运用<code>CoW</code>较为成功</p><ol><li><p>进程的写时拷贝技术（Linux）</p><p>进行<code>fork()</code>时，操作系统不会拷贝父进程的“正文段”、“数据段”、“堆”、“栈”并分配物理块给子进程，而是为<strong>新生成的子进程创建虚拟空间结构，它们来复制于父进程的虚拟究竟结构，但是不为这些段分配物理内存，它们共享父进程的物理空间</strong>。当父进程有更改段的行为发生时（“Write”发生），再为子进程相应段分配物理空间。<a href="https://www.cnblogs.com/biyeymyhjob/archive/2012/07/20/2601655.html" target="_blank" rel="noopener">原文</a>博主援引 LKD《Linux Kernel Development》：</p><blockquote><p>传统的 fork()系统调用直接把所有的资源复制给新创建的进程。这种实现过于简单并且效率低下，因为它拷贝的数据也许并不共享，更糟的情况是，如果新进程打算立即执行一个新的映像，那么所有的拷贝都将前功尽弃。Linux 的 fork()使用写时拷贝（copy-on-write）页实现。写时拷贝是一种可以推迟甚至免除拷贝数据的技术。内核此时并不复制整个进程地址空间，而是让父进程和子进程共享同一个拷贝。只有在需要写入的时候，数据才会被复制，从而使各个进程拥有各自的拷贝。也就是说，资源的复制只有在需要写入的时候才进行，在此之前，只是以只读方式共享。这种技术使地址空间上的页的拷贝被推迟到实际发生写入的时候。在页根本不会被写入的情况下—举例来说，fork()后立即调用 exec()—它们就无需复制了。fork()的实际开销就是复制父进程的页表以及给子进程创建惟一的进程描述符。在一般情况下，进程创建后都会马上运行一个可执行的文件，这种优化可以避免拷贝大量根本就不会被使用的数据（地址空间里常常包含数十兆的数据）。由于 Unix 强调进程快速执行的能力，所以这个优化是很重要的。这里补充一点：Linux COW 与 exec 没有必然联系</p></blockquote></li><li><p>文件系统的写时拷贝技术</p><p>Copy-on-write 在对数据进行修改的时候，不会直接在原来的数据位置上进行操作，而是重新找个位置修改，这样的好处其一是一旦系统突然断电，重启之后不需要做 Fsck。好处就是能保证数据的完整性，掉电的话容易恢复。再者就是和本文内容相关，Cow 常常也作为减少文件物理复制的优化手段。比如很多逻辑卷 manager 支持 block-level 的 Cow 快照。一些文件系统直接支持 Cow 文件或目录。</p></li></ol><h2 id="基本理论概况"><a href="#基本理论概况" class="headerlink" title="基本理论概况"></a>基本理论概况</h2><p>write-optimization 来实现 Copy（复制）与 Write（写）的分离。</p><p>没有出现数学公式，图示过程后是复杂度分析。</p><h2 id="结论部分"><a href="#结论部分" class="headerlink" title="结论部分"></a>结论部分</h2><!-- 确定作者的成过以及点出的经验、问题、改进方 --><p>文章展示了如何利用写优化来实现<strong>Decouple writes from copies</strong>，并实现<code>nimble performance</code>的性质。且这种优化不干扰非相关操作的性能。如在 LXC container 体现出 3-4 倍的拷贝性能提升。</p><p>推广：数据结构批量更新。不仅能够应用于文件系统，还可用在数据库等，比如（在 B-DAG 的实现可用于 KV store）。</p><h2 id="回答基本问题"><a href="#回答基本问题" class="headerlink" title="回答基本问题"></a>回答基本问题</h2><ol><li><p>类别</p><!-- 这篇论文是什么类型？测试类？对现有系统进行分析的？对原型系统进行描述的？--><p>对现有系统的优化，提出一种新模式。</p></li><li><p>内容</p><!-- 你读过的其他论文有没有与之相关的？相关性与区别最直接体现在哪里？文章中分析问题用的什么理论基础（通过瞥一眼数学概况与核心证明可以得到）。 --><p>暂无，文章中提到的 COW 技术没有学习过。</p></li><li><p>正确性</p></li></ol><!-- 结论是否看起来真实有效？ --><ol><li><p>创新点</p><!-- 论文的主要创新点是什么？总结提到的经验、问题和改进方法是什么？ --><p>不同于传统的 COW 技术，通过写优化将 C 与 W 分开达到性能上的进一步提升。</p></li><li><p>清晰度</p></li></ol><!-- 这篇论文是否写的条理清晰 --><h2 id="阅读选择"><a href="#阅读选择" class="headerlink" title="阅读选择"></a>阅读选择</h2><!--1. 继续阅读：论文有价值担保，研究领域非常切合，对当前进行工作有极大帮助，圈内爆火文章2. 不继续阅读：论文不吸引自己，论文价值/正确性存疑，论文作者给出了不适当的假设。3. 库存保留并标记：当前不处于自己的研究领域，但不久的日后相关论文会有用。--><p>继续阅读</p><a id="more"></a><h1 id="Step-2"><a href="#Step-2" class="headerlink" title="Step 2"></a>Step 2</h1><h2 id="细读笔记"><a href="#细读笔记" class="headerlink" title="细读笔记"></a>细读笔记</h2><!-- 要仔细阅读论文，但是诸如证明等信息要忽略掉 --><h3 id="Introduction"><a href="#Introduction" class="headerlink" title="Introduction"></a>Introduction</h3><p>Cow 技术的核心调节参数是 Copy 的粒度：</p><ul><li>粒度大<ul><li>比如文件级</li><li>小改动的代价会被放大</li><li>会增大更新延时</li><li>相关的 Copy 会丧失 share 能力，可能造成大的空间浪费（如只有很小修改）</li></ul></li><li>粒度小<ul><li>更新很快但是碎片花</li><li>按序读代价变大</li></ul></li></ul><p>Nible clones:</p><ul><li><strong>be fast to create</strong></li><li><strong>have excellent read locality</strong>, so that logically related files can be read at near disk bandwidth, even after modifination.</li><li><strong>have fast writes</strong>, both the original and the clone</li><li><strong>conserve space</strong>（节省空间）, the write amplification and disk footprint are as small as possible, even after updates to the original or to the clone.</li></ul><p>现有的 CoW 技术实现都不是 Nible 复制。</p><p>文章 Contribution（详细见第二页右下）:</p><ul><li>提出一个逻辑复制 specifiction（说明？）</li><li>nimble clone 必须满足的一组（性能）条件</li><li>实现了一个符合上述要求的文件系统设计</li></ul><p>CAW（Copy-on-Abundant-Write）：应用于 BetrFS 0.5’s clone 实现，buffer 累计小的修改，直至衡量其维持 delta 的代价超过 copy，如此则重新复制。</p><h3 id="BetrFS-Background"><a href="#BetrFS-Background" class="headerlink" title="BetrFS Background"></a>BetrFS Background</h3><h4 id="B-epsilon-tree"><a href="#B-epsilon-tree" class="headerlink" title="B$^\epsilon$-tree"></a>B$^\epsilon$-tree</h4><p>BetrFS 由 KV-store 的数据结构（B$^{\epsilon}$-tree）来命名，同 B 树变体，B$^\epsilon$-tree 将 kv 对储存在叶子结点中，</p><p><strong>关键特征</strong>：B$^\epsilon$-tree 的内部结点（interior nodes）缓冲了叶子内容将要发生的改变，名为 message。逐曾 flush message 直到达到叶子结点。</p><p>B$^\epsilon$-tree 在每个结点 log 更改，而向下的更新是按批次的，所以 IO 的节省空间遂批次增多而增大。</p><h4 id="Range-Operation"><a href="#Range-Operation" class="headerlink" title="Range Operation"></a>Range Operation</h4><p>BetrFS 对连续键值范围操作的优化，设计用来优化文件系统 namespace 的子树操作。</p><p>full-path keys 带来的遍历，读文件、搜索都是一个 range 操作（相同 prefix）</p><h2 id="问题记录"><a href="#问题记录" class="headerlink" title="问题记录"></a>问题记录</h2><h2 id="未读（且值得读）文献记录"><a href="#未读（且值得读）文献记录" class="headerlink" title="未读（且值得读）文献记录"></a>未读（且值得读）文献记录</h2><!-- 在第二步中，找到以上几篇论文中相同的引用文献、在引用文献中重复的作者名，这些就是你所调研领域的重点论文和科研人员，下载那些重点论文暂时搁到一边。继续访问那些重要科研人员的网页，看下那些论文是在什么会议集结出版的。这能帮你找到那个领域的顶级会议，因为那些重要科研人员通常会在顶级会议发表论文。 --><p>[25]<a href="">the log-structured merge-tree (lsm-tree)</a> （太多相关内容都是基于 LSM-tree 的了，一定要补一下）。</p><h1 id="Step-3"><a href="#Step-3" class="headerlink" title="Step 3"></a>Step 3</h1><!-- 试着“在脑中重新实现（virtually re-implement）”那篇论文：也就是，和作者一样做出相同的假设，然后重新实现相同的工作。通过对比你自己得出的和论文中给出的结果，不仅可以很轻易验证一篇论文的创新点是否真实，而且还能发现论文中不会讲的缺点和假想。 --><h2 id="思路复现"><a href="#思路复现" class="headerlink" title="思路复现"></a>思路复现</h2><!-- 推敲作者是如何立题，如何找到突破口，在其中是否有抉择，如何做出的假设？ --><h2 id="证明与推理复现"><a href="#证明与推理复现" class="headerlink" title="证明与推理复现"></a>证明与推理复现</h2><!-- 分析证明过程，确定证明的正确性以及完整性。对证明过程做拓展，调研证明思路来源 --><h2 id="实验验证复现"><a href="#实验验证复现" class="headerlink" title="实验验证复现"></a>实验验证复现</h2><!-- Rework --><h1 id="会议内容记录"><a href="#会议内容记录" class="headerlink" title="会议内容记录"></a>会议内容记录</h1><h2 id="What-is-logical-Copy"><a href="#What-is-logical-Copy" class="headerlink" title="What is logical Copy?"></a>What is logical Copy?</h2><ul><li><code>cp -r</code> “Not changed”</li><li><code>ln</code> “will change”</li><li><code>ln -s</code> “will change” 硬软连接</li><li><code>cp --reflink</code> 本文内容，逻辑拷贝</li></ul><p>过程描述</p><p>改变之前两个文件指向相同的 Data Block 组，假设对 1 位进行改变，会使 Copy 一个新的 Data Block，产生两大问题：</p><ol><li>一点修改就要改 Data Block</li><li>碎片化，把排排坐有序的 Data Block，变为无序访问了。</li></ol><p>测试过程描述（图示）</p><p>写放大：每个 block（4KB）都做个小修改，</p><p>碎片导致时间开销：越碎片，时间越长？</p><h2 id="当前存在的问题"><a href="#当前存在的问题" class="headerlink" title="当前存在的问题"></a>当前存在的问题</h2><p>物理 Copy、逻辑 Copy 的三个问题，其中还包含一个 Trade Off。</p><h2 id="Contribution"><a href="#Contribution" class="headerlink" title="Contribution"></a>Contribution</h2><p>Implementation</p><h2 id="什么是-BetrFS？"><a href="#什么是-BetrFS？" class="headerlink" title="什么是 BetrFS？"></a>什么是 BetrFS？</h2><ul><li><p>BetrFSL</p><ul><li>an in-kernel， local file system</li><li>built on a KV-store substrate(B$^\epsilon$-tree)</li></ul><p>特征：1. 更小的关键字 fewer pivots. 2. buffer</p></li></ul><h3 id="B-epsilon-tree-1"><a href="#B-epsilon-tree-1" class="headerlink" title="B$^\epsilon$-tree"></a>B$^\epsilon$-tree</h3><p>左边 piviot b 树中的关键字，右边是 buffer</p><h3 id="Cloning-Operation-Semantics"><a href="#Cloning-Operation-Semantics" class="headerlink" title="Cloning Operation Semantics"></a>Cloning Operation Semantics</h3><p>write amplification</p><p>对于 Trade Off，根据已知的 B$^\epsilon$-tree 数据结构的特征，在保证块很大的情况下，写也不慢（减小写放大影响）。</p><p>Postpone：树到 DAG，树的叶子节点是要保证唯一性的。</p><h3 id="GOTO-messages"><a href="#GOTO-messages" class="headerlink" title="GOTO messages"></a>GOTO messages</h3><p>GOTO messages： <code>Prefix /b/0, goto /a</code>。举例子，Docker 逻辑复制，通过 GOTO message 就可以占据一个名称空间，还用原来的物理空间，不扩。</p><p>A GOTO message maps: keyrange(a,b)-&gt;a node 把一个范围的 key 映射到一个 node。(The target node should be the Lowest-Common Ancestor(LCA)). 为什么是公共祖先，我个人理解，再下一层就不饿能保证下次对应相同的 data block。</p><p>由于加了边（Goto 指向边），变成了个有向无环图。</p><p>有向无环图带来的问题，直接指向的位置如果不是最新的（上一层有 buffer），则有过去更改没有刷下来。解决方案，加 Ref 标记，并强制上层路径 flush</p><h3 id="Handling-Fringe-Nodes"><a href="#Handling-Fringe-Nodes" class="headerlink" title="Handling Fringe Nodes"></a>Handling Fringe Nodes</h3><h2 id="Implementation-and-Optimization"><a href="#Implementation-and-Optimization" class="headerlink" title="Implementation and Optimization"></a>Implementation and Optimization</h2><p>Preferential splitting</p><ul><li>分割 leafnodes 的选择</li><li>11</li></ul><p>Background cleaning</p><h2 id="BetrFS-的影响"><a href="#BetrFS-的影响" class="headerlink" title="BetrFS 的影响"></a>BetrFS 的影响</h2><p>写放大和碎片控制都有效，克隆的 Latency 最低的。</p><p>结论：相比于剩下三个文件系统，达到的效果：Low space amplification, Low fragmentation, Low clone latency</p><p>通常的文件系统</p><p>顺序 IO 和随机 IO</p><h2 id="Li-老师点评"><a href="#Li-老师点评" class="headerlink" title="Li 老师点评"></a>Li 老师点评</h2><p>Slides 比文章更好，可以再关注下。</p><p>Research，小而美的问题，比如这个，How to copy files。</p><p>大的 Scope</p>]]></content>
    
    
    <categories>
      
      <category>Research</category>
      
      <category>Paper</category>
      
    </categories>
    
    
    <tags>
      
      <tag>Paper</tag>
      
      <tag>三步法</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>文献学习方法——如何高效的阅读学术论文（简）</title>
    <link href="/post/b0d5859e.html"/>
    <url>/post/b0d5859e.html</url>
    
    <content type="html"><![CDATA[<h1 id="引言"><a href="#引言" class="headerlink" title="引言"></a>引言</h1><p>阐述“三步法”在论文阅读和文献调研中的应用。</p><p>另：不要全篇翻译！不要全篇翻译！不要全篇翻译！</p><h1 id="三步法"><a href="#三步法" class="headerlink" title="三步法"></a>三步法</h1><p>主要思想就是应该在<strong>三步</strong>内读完论文，而不是从开始“耕耘”到最后，每一步要基于之前的阅读完成一个明确的目标：</p><ol><li>第一步要弄清一篇论法。</li><li>第二步要抓住论文的主要内容，但不是细节。</li><li>第三步要帮助你深度理解整篇论文。</li></ol><h2 id="第一步"><a href="#第一步" class="headerlink" title="第一步"></a>第一步</h2><p><strong>快速浏览整篇论文，大致了解</strong>，当文献阅读到达一定程度需要进行阅读筛选时，我们可以在这一步<strong>做出决定是否需要进一步阅读</strong>，当然对于初学者或者有“引路人”存在的情况下，文章价值有担保，所以可以大胆接受，进行进一步阅读。</p><p>第一步由以下几个小部分组成</p><ul><li>认真阅读题目、摘要、引言</li><li>阅读标题和段落开头，除此之外一概不看</li><li>瞥一眼数学部分（如果有的话），以确定其基本理论概况</li><li>阅读结论部分，确定作者的成果以及点出的经验、问题、改进方式。</li><li>瞥一眼引用，找一下是否有自己读过的论文。</li></ul><p>完成第一步后，应该能回答以下几个问题：</p><ul><li><strong>类别</strong>：这篇论文是什么类型？测试类？对现有系统进行分析的？对原型系统进行描述的？</li><li><strong>内容</strong>：你读过的其他论文有没有与之相关的？相关性与区别最直接体现在哪里？文章中分析问题用的什么理论基础（通过瞥一眼数学概况与核心证明可以得到）。</li><li><strong>正确性</strong>：结论是否看起来真实有效？</li><li><strong>创新点</strong>：论文的主要创新点是什么？总结中提到的经验、问题和改进方法是什么？</li><li><strong>清晰度</strong>：这篇论文是否写的条理清晰？</li></ul><p>做出选择</p><ul><li>继续阅读：论文有价值担保，研究领域非常切合，对当前进行工作有极大帮助，圈内爆火文章</li><li>不继续阅读：论文不吸引自己，论文价值/正确性存疑，论文作者给出了不适当的假设。</li><li>库存保留并标记：当前不处于自己的研究领域，但不久的日后相关论文会有用。</li></ul><blockquote><p>顺带提一下，当你写一篇论文时，你可以设想大部分的审稿人（或读者）只对你的论文使用第一步。小心地选择标题和子段落开头部分，摘要应该精确而且易理解。如果一个审稿人在第一步过后还不能理解你论文的主旨，那么很可能你的论文就不过关了。如果一个读者在五分钟内不能理解论文的突出部分，那么很可能以后这篇论文再也不会被捡起。正是由于这些原因，用一个“图示摘要”及一个精心选择的图形总结一篇论文是很棒的想法，以后会在科学杂志中越来越多。</p></blockquote><a id="more"></a><h2 id="第二步"><a href="#第二步" class="headerlink" title="第二步"></a>第二步</h2><p>在第二步中，要仔细阅读论文，但是诸如证明等信息要忽略掉。在阅读时你应该草记下重点，或者在论文空白处写点标注。来自奥格斯堡（Augsburg）的 Dominik Grusemann 建议：</p><blockquote><p>“记录下那些你不懂的部分，或者那些你想问作者的问题”。</p></blockquote><p>如果你是一名论文评审员，以上那些记录在你写评审意见时很有用，也可以在开论文研讨会时帮助你记录你当时的想法。</p><ul><li>仔细论文中阅读图片、表格和其他说明。要特别注意图表：坐标轴标记是否合适？标示的结果是否有误差线？这类常见错误可以区分那些粗制滥造的论文和真正出色的论文。</li><li>为了进一步阅读相关论文，记得要标注相关的未读引用文献<strong>（这是进一步了解论文相关背景的好方法）</strong>。</li></ul><p>第二步对于有经验的读者来说，应该需要一小时左右的时间。经过以上步骤，你应该就了解了论文的整体内容。此时你应该能把论文的主要思想和相关论据讲给其他人听了。对于你感兴趣的论文，读到这个程度就可以了，但是对于那些在你研究领域内的论文来时，还远远不够。</p><p>有些论文，你甚至可能在第二步结束的时候还不能理解。这有可能是因为论文中的主旨对你来说是全新的，论文里的术语和缩写词你都陌生，也可能是因为作者用了你不理解的论据和试验技术，所以导致论文中大部分的内容都不好理解。有些论文有可能写的很差，充斥着未经证实的断言和大量前向引用（forward references）。不过也可能你是在夜里很累的情况下阅读的，因此感觉不太好懂，如果是这样，你可以选择：</p><ul><li>把论文放到一边，期望着在你走向事业成功的路上不需要理解它</li><li>在了解了相关背景知识后，过段时间再回头读，或者</li><li>坚持不懈继续阅读</li></ul><h2 id="第三步"><a href="#第三步" class="headerlink" title="第三步"></a>第三步</h2><p>为了彻底理解一篇论文，尤其是当你是审稿人时，必须要走到第三步。第三部的核心思想是，试着“在脑中重新实现（virtually re-implement）”那篇论文：也就是，和作者一样做出相同的假设，然后重新实现相同的工作。通过对比你自己得出的和论文中给出的结果，不仅可以很轻易验证一篇论文的创新点是否真实，而且还能发现论文中不会讲的缺点和假想。</p><p>这一步需要耗费你很多精力去细化，完成这一步，你就可以验证论文中的每一个假设是否真实。而且，同时要思考下，如果你是作者，会如何呈现并介绍自己的想法。这种虚拟和现实的对比，可以让你对论文中的论据和表达技巧有深刻的理解，当然就可以把这种表达技巧和论据“据为己有”。在完成第三步过程中，你应该时刻不忘记下对于未来研究工作的新想法。</p><p>这一步有可能需要耗费初学者很多小时，对于有经验的研究人员也要至少一两个小时。当完成这一步后，你应该可以在脑海中重现构造论文的整个架构，同时能确定论文中哪些是好的，哪些是一般的论点。特别地，你也应该能明确指出论文中不清晰的假设、漏掉引用的相关工作以及论文中试验和分析的手段潜在的缺点。</p><h1 id="如何完成文献调研"><a href="#如何完成文献调研" class="headerlink" title="如何完成文献调研"></a>如何完成文献调研</h1><p>做文献调研就是考验你读论文技巧的时候了，调研工作有可能需要你阅读几十篇论文，同时也可能是你不熟悉的领域。什么样的论文值得一读？以下就是如何使用“三步法”帮你调研文献。</p><p>首先，使用学术搜索引擎例如 Google Scholar 或者 CiteSeer，并且精心选择搜索词，找出三到五篇领域中“最近最多被引用”的论文。对于以上搜到的论文，使用三步法中的第一步，可以使自己对于相关工作有点感觉，然后阅读它们的相关工作章节。你会对于最近的相关工作有缩略图似的总结，如果你足够幸运的话，有可能在以上相关工作中找到近期发表的调研论文。如果你能找到类似的调研论文，调研工作就完成了！认真阅读那篇调研文献，庆祝自己的运气吧。</p><p>不然，在第二步中，找到以上几篇论文中相同的引用文献、在引用文献中重复的作者名，这些就是你所调研领域的重点论文和科研人员，下载那些重点论文暂时搁到一边。继续访问那些重要科研人员的网页，看下那些论文是在什么会议集结出版的。这能帮你找到那个领域的顶级会议，因为那些重要科研人员通常会在顶级会议发表论文。</p><p>第三步就是访问那些顶级会议的网站，查看一下他们最近的活动。快速扫描一眼就能找到最近的高质量相关论文，这些论文和上面提到暂时放到一边的论文，会对你文献调研工作的第一版本有所帮助。对于这些论文，使用“三步法”中的第二步，如果它们都引用了一篇重要文献，恰巧是你没有搜到的，果断下载并阅读。如果需要，重复以上工作。</p><h1 id="相关工作"><a href="#相关工作" class="headerlink" title="相关工作"></a>相关工作</h1><p>如果你是为了审稿而读论文，Timothy Roscoe 的论文《Writing reviews for systems conferences》可以参考。如果你的计划是写一篇技术性论文，Henning Schulzrinne 的综合网页和 George Whitesides 的过程概述可以参考。最后，Simon Peyton Jones 有一个网页涵盖了所有实验技巧。</p><p>心理学领域的 Iain H. McLean 打包发布了一个可下载的“评审矩阵”，介绍了如何用“三步法”简化在实验心理学领域进行论文评审（你有可能用到），以及对于其他领域的论文如何使用“微调三步法”。</p><h1 id="致谢"><a href="#致谢" class="headerlink" title="致谢"></a>致谢</h1><p>本文第一版由我的学生 Hossein Falaki、 Earl Oliver 和 Sumair Ur Rahman 起草，感谢他们。同时感谢 Christophe Diot 犀利的评论和目光锐利的 Nicole Keshav 的校稿。</p><p>我想把这篇文章做成在线版，在我收到评论后就做出修改更新。如果您有任何评论或者改进建议，请给我发邮件。感谢诸多通讯员多年来的鼓舞人心的反馈。</p><h1 id="引用文献"><a href="#引用文献" class="headerlink" title="引用文献"></a>引用文献</h1><p>[1]<a href="http://psychologyinc.blogspot.com/" target="_blank" rel="noopener">literature review matrix</a></p><p>[2]<a href="http://research.microsoft.com/enus/um/people/simonpj/papers/giving-a-talk/giving-atalk.htm" target="_blank" rel="noopener">s. peyton jones, \research skills</a></p><p>[3]<a href="http://people.inf.ethz.ch/troscoe/pubs/review-writing.pdf" target="_blank" rel="noopener">t. roscoe, \writing reviews for systems conferences</a></p><p>[4]<a href="http://www.cs.columbia.edu/hgs/etc/writing-style.html" target="_blank" rel="noopener">h. schulzrinne, \writing technical articles</a></p><p>[5] G.M. Whitesides, \Whitesides’ Group: Writing a Paper</p>]]></content>
    
    
    <categories>
      
      <category>Research</category>
      
      <category>方法</category>
      
    </categories>
    
    
    <tags>
      
      <tag>三步法</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>分布式系统学习——Hadoop安装与单机模式调试</title>
    <link href="/post/b894091d.html"/>
    <url>/post/b894091d.html</url>
    
    <content type="html"><![CDATA[<p>系列文章主要记录自己在阿里云 ECS 配置安装 Hadoop，搭建伪分布式环境，学习 Hadoop、HDFS、Hbase 相关内容的过程。</p><h1 id="系统安装"><a href="#系统安装" class="headerlink" title="系统安装"></a>系统安装</h1><h2 id="采取什么方式安装-Hadoop"><a href="#采取什么方式安装-Hadoop" class="headerlink" title="采取什么方式安装 Hadoop"></a>采取什么方式安装 Hadoop</h2><p>实际上我们有很多方式来安装 Hadoop，比如通过 Cloudera 图形化界面（就像 Anaconda Navigator 那样），不过网上许多教程都是通过命令行形式进行安装的（包括 Apache 官方网站），鉴于以后要进行服务器管理，分布式搭建，我们也按照官网推荐的方式通过命令行安装 Hadoop。</p><h2 id="建立-Hadoop-用户并配置免密钥-SSH-登录"><a href="#建立-Hadoop-用户并配置免密钥-SSH-登录" class="headerlink" title="建立 Hadoop 用户并配置免密钥 SSH 登录"></a>建立 Hadoop 用户并配置免密钥 SSH 登录</h2><p>从安全角度触发，不要始终用 root 用户进行操作，我们一般会建立<code>hadoop</code>或者<code>hduser</code>等用户（日后很多时候网管也不会给你 root 权限）。</p><p>建立用户过程简述</p><pre><code class="hljs Bash">$ user add -m hadoop<span class="hljs-comment"># -m参数添加用户根目录</span>$ passwd hadoop<span class="hljs-comment"># 为hadoop用户设置密码</span>$ chsh -s /bin/zsh hadoop<span class="hljs-comment"># zsh为本人常使用shell 所以做一下更换</span><span class="hljs-comment"># 接下来进行的是把hadoop添加到sudoers</span>$ chmod u+w /etc/sudoers$ vim /etc/sudoers<span class="hljs-comment"># 在里面增添 hadoop ALL=NOPASSWD:ALL</span>$ chmod u-w /etc/sudoers<span class="hljs-comment"># 测试</span>$ su hadoop$ sudo whoami<span class="hljs-comment"># 出现Root即ok</span></code></pre><p>配置免密登录，检查/home/hadoop/.ssh 文件查看是否有公钥，没有的话通过<code>ssh-gen</code>进行生成。若可以直接<strong>免密</strong>登录本机<code>ssh localhost</code>则可以直接跳过本过程。</p><p>如果不行的话需要将公钥加入授权</p><pre><code class="hljs Bash">cat id_rsa.pub &gt;&gt; authorized_keys</code></pre><a id="more"></a><h1 id="Hadoop-节点存储节点为空"><a href="#Hadoop-节点存储节点为空" class="headerlink" title="Hadoop 节点存储节点为空"></a>Hadoop 节点存储节点为空</h1><p>看它的报错信息好像是节点没有启动，但是我的节点都启动起来了，使用 jps 也能查看到节点信息。<br>使用 hadoop dfsadmin -report 命令查看磁盘使用情况，发现出现以下问题：</p><pre><code class="hljs Bash">Configured Capacity: 0 (0 B)Present Capacity: 0 (0 B)DFS Remaining: 0 (0 B)DFS Used: 0 (0 B)DFS Used%: 0.00%Replicated Blocks:        Under replicated blocks: 0        Blocks with corrupt replicas: 0        Missing blocks: 0        Missing blocks (with replication factor 1): 0        Low redundancy blocks with highest priority to recover: 0        Pending deletion blocks: 0Erasure Coded Block Groups:        Low redundancy block groups: 0        Block groups with corrupt internal blocks: 0        Missing block groups: 0        Low redundancy blocks with highest priority to recover: 0        Pending deletion blocks: 0</code></pre><h2 id="解决方法"><a href="#解决方法" class="headerlink" title="解决方法"></a>解决方法</h2><ol><li><p>停止集群（切换到/sbin 目录下）</p><pre><code class="hljs Bash">$ HADOOP_HOME/sbin/stop-all.sh</code></pre></li><li><p>删除在 hdfs 中配置的 data 目录（即在 core-site.xml 中配置的 hadoop.tmp.dir 对应文件件）下面的所有数据</p><pre><code class="hljs Bash">$ rm -rf /home/hadoop/hdpdata/</code></pre><p>参考<a href="https://www.cnblogs.com/lyr999736/p/9228752.html" target="_blank" rel="noopener">hdfs 默认数据存放路径</a>，在 core-site.xml 没有编辑 data 存放路径时，默认存放到<code>{hadoop.tmp.dir}:/tmp/hadoop-{user.name}</code>。删除以后更换 tmp 数据存储位置。</p></li></ol><p>3、重新格式化 namenode(切换到 hadoop 目录下的 bin 目录下)<code>hadoop namenode -format</code></p><p>4、重新启动 hadoop 集群（切换到 hadoop 目录下的 sbin 目录下）<code>$HADOOP_HOME/sbin/start-all.sh</code></p><h1 id="单机测试流程"><a href="#单机测试流程" class="headerlink" title="单机测试流程"></a>单机测试流程</h1><ol><li><p>格式化 namenode</p><pre><code class="hljs Bash">$ hdfs namenode -format</code></pre></li><li><p>启动 NameNode 的守护进程和 DataNode 的守护进程</p><pre><code class="hljs Bash">$ <span class="hljs-variable">$HADOOP_HOME</span>/sbin/start-dfs.sh</code></pre></li><li><p>通过 Web 浏览，若配置不出问题，应为 <code>https://ip地址:50070</code></p></li><li><p>建立 HDFS 的文件目录并启动 MapReduce 任务</p><pre><code class="hljs Bash">hdfs dfs -mkdir /userhdfs dfs -mkdir /user/&lt;username&gt;</code></pre><p>根据自己的用户名填充，我的是<code>user/hadoop</code></p></li><li><p>拷贝文件到分布式文件系统的 input 目录</p><pre><code class="hljs Bash">hdfs dfs -mkdir inputhdfs dfs -put etc/hadoop/*.xml input</code></pre><p>如果出现节点未启动但是 jps 中进程存在的故障，注意查一下是不是上一点，然后再进行修复。</p></li><li><p>用一些样例程序进行测试</p><pre><code class="hljs Bash"><span class="hljs-comment"># 正则</span>$ hadoop jar share/hadoop/mapreduce/hadoop-mapreduce-examples-3.2.1.jar grep input output_regex <span class="hljs-string">'dfs[a-z.]+'</span><span class="hljs-comment"># 或者 wordcount</span>$ hadoop jar share/hadoop/mapreduce/hadoop-mapreduce-examples-3.2.1.jar wordcount input output_wordcount</code></pre><p><img src="https://eddyblog.oss-cn-shenzhen.aliyuncs.com/Hadoop/hadoop1.png" srcset="/img/loading.gif" alt="Hadoop_1"></p><p>计算完成后还需要通过 <code>-get</code>指令把文件从 HDFS 下载到本地。</p><p><img src="https://eddyblog.oss-cn-shenzhen.aliyuncs.com/Hadoop/hadoop2.png" srcset="/img/loading.gif" alt="Hadoop_2"></p><p>最终结果见下图，证明测试成功。</p><p><img src="https://eddyblog.oss-cn-shenzhen.aliyuncs.com/Hadoop/hadoop4.png" srcset="/img/loading.gif" alt="Hadoop_3"></p><p><img src="https://eddyblog.oss-cn-shenzhen.aliyuncs.com/Hadoop/hadoop3.png" srcset="/img/loading.gif" alt="Hadoop_4"></p></li><li><p>完成全部任务后，停止进程</p><pre><code class="hljs Bash">$ <span class="hljs-variable">$HADOOP_HOME</span>/sbin/stop-dfs.sh</code></pre></li></ol><h1 id="Hadoop-Web-配置-bug"><a href="#Hadoop-Web-配置-bug" class="headerlink" title="Hadoop Web 配置 bug"></a>Hadoop Web 配置 bug</h1><h2 id="启动后无法-list-文件系统"><a href="#启动后无法-list-文件系统" class="headerlink" title="启动后无法 list 文件系统"></a>启动后无法 list 文件系统</h2><p>原因是 WebHDFS 没有完全启动，由于 Aliyun 防火墙的原因，需要自己开放 50070 与 50075 端口。</p><p>访问 namenode 的 hdfs 使用 50070 端口，访问 datanode 的 webhdfs 使用 50075 端口。访问文件、文件夹信息使用 namenode 的 IP 和 50070 端口，访问文件内容或者进行打开、上传、修改、下载等操作使用 datanode 的 IP 和 50075 端口。要想不区分端口，直接使用 namenode 的 IP 和端口进行所有的 webhdfs 操作，就需要在所有的 datanode 上都设置 hefs-site.xml 中的 dfs.webhdfs.enabled 为 true。</p><p>装了 jdk11 的锅</p><p><a href="https://stackoverflow.com/questions/53562981/hadoop-hdfs-3-1-1-on-java-11-web-ui-crash-when-loading-the-file-explorer" target="_blank" rel="noopener">Hadoop/HDFS 3.1.1 (on Java 11) Web UI crash when loading the file explorer? [duplicate]</a></p><blockquote><p>Java 9 deprecated the java.activation module. Java 11 removed it completely.</p><p>Java 9 and Java 10 users could add the module back on Hadoop’s classpath. Put this in $HADOOP_CONF_DIR/hadoop-env.sh(not tested):</p><p>export HADOOP_OPTS=”${HADOOP_OPTS} —add-modules java.activation “<br>Java 11 users must first download the jar dependency and make it available on the classpath. But were does it go?</p><p>I found that putting the jar in any one of these locations will make Hadoop automagically pick it up with the effect that the online file explorer start working:</p></blockquote><pre><code class="hljs Bash"><span class="hljs-variable">$HADOOP_HOME</span>/share/hadoop/common<span class="hljs-variable">$HADOOP_HOME</span>/share/hadoop/common/lib<span class="hljs-variable">$HADOOP_HOME</span>/share/hadoop/mapreduce<span class="hljs-variable">$HADOOP_HOME</span>/share/hadoop/mapreduce/lib</code></pre><blockquote><p>Not sure what exactly the consequences are putting the file in one or the other folder. But, I like to confine my hacks as much as possible and since I already have a separate configuration directory (i.e., not $HADOOP_HOME/etc/hadoop) I’d like to put it there. Having the jar file in any other location also requires of us to add this path to the HADOOP_CLASSPATH variable.</p><p>So, copy-paste into your terminal:</p></blockquote><pre><code class="hljs Bash">URL=https://jcenter.bintray.com/javax/activation/javax.activation-api/1.2.0/javax.activation-api-1.2.0.jarwget <span class="hljs-variable">$URL</span> -P <span class="hljs-variable">$HADOOP_CONF_DIR</span>/lib<span class="hljs-built_in">echo</span> <span class="hljs-string">'export HADOOP_CLASSPATH+=" $HADOOP_CONF_DIR/lib/*.jar"'</span> &gt;&gt; <span class="hljs-variable">$HADOOP_CONF_DIR</span>/hadoop-env.sh</code></pre><blockquote><p>As a final note, I think it’s safe to say that one can not expect Hadoop to work well on anything but really old Java versions. Googling reveals that still open tickets exist for Java 9, 10 and 11. So essentially, this is a Hadoop problem. Having that said, although we solved one problem of getting the online file explorer to work, there will for sure be many other issues down the line.</p></blockquote><h2 id="Browse-Directory-但是无法上传下载文件"><a href="#Browse-Directory-但是无法上传下载文件" class="headerlink" title="Browse Directory 但是无法上传下载文件"></a>Browse Directory 但是无法上传下载文件</h2><p>上个问题解决完成，尝试上传/下载文件，</p><p><img src="https://eddyblog.oss-cn-shenzhen.aliyuncs.com/Hadoop/hadoop5.png" srcset="/img/loading.gif" alt="Hadoop_5"></p><p><img src="https://eddyblog.oss-cn-shenzhen.aliyuncs.com/Hadoop/hadoop6.png" srcset="/img/loading.gif" alt="Hadoop_6"></p><p>实际上是服务器端与客户端 ip 地址与名称映射的问题</p><p>审查 WebUI，发现数据节点 Datanod 的地址是<code>localhost</code>开头而非以主机名<code>nn01</code>开头。修改服务器端 hosts 文件。</p><p><img src="https://eddyblog.oss-cn-shenzhen.aliyuncs.com/Hadoop/hadoop7.png" srcset="/img/loading.gif" alt="Hadoop_6"></p><p>修改主机端 hosts 文件，添加 <code>nn01</code>与其 ip 地址的映射。</p><p>但是修改完成 hosts 文件，50070 端口都不能访问了，哭了。</p><p>查阅资料</p><blockquote><p>这个问题花费了我将近两天的时间，经过多次试错和尝试，现在想分享给大家来解决此问题避免大家入坑，以前都是在局域网上搭建的 hadoop 集群，并且是局域网访问的，没遇见此问题。</p><p>因为阿里云上搭建的 hadoop 集群，需要配置映射集群经过内网访问，也就是局域网的 ip 地址。<br>如果配置为公网 IP 地址，就会出现集群启动不了，namenode 和 secondarynamenode 启动不了，如果将主机的映射文件配置为内网 IP 集群就可以正常启动了。但通过 eclipse 开发工具访问</p><p>会出错，显示了阿里云内网的 ip 地址来访问 datanode，这肯定访问不了啊，这问题真实醉了，就这样想了找了好久一致没有思路。<br>最终发现需要在 hdfs-site.xml 中修改配置项<code>dfs.client.use.datanode.hostname</code>设置为 true，就是说客户端访问 datanode 的时候是通过主机域名访问，就不会出现通过内网 IP 来访问了</p></blockquote><p>上面这个也不管用</p><blockquote><p>在 vi /etc/hosts 里面配置公网和内网的 ip</p><p>内网 IP 地址 你的 hostname<br>公网 IP 地址 别的 hostname</p></blockquote><p>但是对于单机/伪分布式 Hadoop 搭建，怎么解决，没有找到方法。</p><p>换用阿里云内网 ip 地址，可以在 WebUI 中浏览 HDFS 文件目录，并下载、预览内容（不能上传）。</p><p><a href="https://blog.csdn.net/caojianhua2018/article/details/99174958#%EF%BC%885%EF%BC%89Hadoop%E4%BC%AA%E5%88%86%E5%B8%83%E9%85%8D%E7%BD%AE" target="_blank" rel="noopener">伪分布式配置</a></p><h2 id="ClusterID-不匹配导致-DataNode-无法启动"><a href="#ClusterID-不匹配导致-DataNode-无法启动" class="headerlink" title="ClusterID 不匹配导致 DataNode 无法启动"></a>ClusterID 不匹配导致 DataNode 无法启动</h2><p>hadoop 的升级功能需要 data-node 在它的版本文件里存储一个永久性的 clusterID，当 datanode 启动时会检查并匹配 namenode 的版本文件里的 clusterID，如果两者不匹配，就会出现”Incompatible clusterIDs”的异常。<br>　　每次格式化 namenode 都会生成一个新的 clusterID, 如果只格式化了 namenode，没有格式化此 datanode， 就会出现”java.io.IOException: Incompatible namespaceIDs“异常。</p><h2 id="伪分布式运行时提示类缺失"><a href="#伪分布式运行时提示类缺失" class="headerlink" title="伪分布式运行时提示类缺失"></a>伪分布式运行时提示类缺失</h2><p>执行<code>hadoop classpath</code>，copy 到<code>yarn-site.xml</code>配置文件<code>yarn.capplication.clathpath</code>字段</p>]]></content>
    
    
    <categories>
      
      <category>Computer Science</category>
      
      <category>分布式系统</category>
      
    </categories>
    
    
    <tags>
      
      <tag>分布式系统</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>分布式系统学习——分布式存储与文件系统</title>
    <link href="/post/fcfa77c8.html"/>
    <url>/post/fcfa77c8.html</url>
    
    <content type="html"><![CDATA[<h1 id="NoSQL"><a href="#NoSQL" class="headerlink" title="NoSQL"></a>NoSQL</h1><p>类型</p><p>列存储</p><p>Hbase、Cassandra、Hypertable</p><p>文档存储</p><p>MongoDB、CoutTree</p><p>调研：</p><p>什么是 NoSQL 生态圈</p><h1 id="分布式存储系统的定义与实现问题"><a href="#分布式存储系统的定义与实现问题" class="headerlink" title="分布式存储系统的定义与实现问题"></a>分布式存储系统的定义与实现问题</h1><ol><li>数据分布：分布均匀？跨服务器读写</li><li>一致性：如何复制多个数据副本并保证不同副本之间的一致性</li><li>容错</li><li>负载均衡</li><li>事务与并发控制</li><li>易用性</li><li>压缩/解压缩</li></ol><h1 id="分布式存储系统分类"><a href="#分布式存储系统分类" class="headerlink" title="分布式存储系统分类"></a>分布式存储系统分类</h1><ol><li>分布式文件系统：存储 Blob 对象、定长块以及大文件<ol><li>Facebook Haystack</li><li>GFS Amazon EBS</li></ol></li><li>分布式键值存储系统</li></ol><p>调研学习：DAS、SAN、NAS</p><a id="more"></a><h1 id="存储引擎"><a href="#存储引擎" class="headerlink" title="存储引擎"></a>存储引擎</h1><ol><li>哈希存储引擎<ol><li>哈希表的持久化实现</li><li>支持增删改和随机读取，不支持顺序扫描</li><li>对应键值存储系统</li></ol></li><li>B 树存储引擎<ol><li>B 树的持久化实现</li><li>支持增删读改，支持顺序扫描</li><li>对应关系数据库</li></ol></li><li>LSM 树存储引擎<ol><li>支持增删读改，支持顺序扫描</li><li>互联网后台存储系统</li></ol></li></ol><h1 id="数据模型"><a href="#数据模型" class="headerlink" title="数据模型"></a>数据模型</h1><ol><li>文件模型<ol><li>以目录树的形式组织文件</li><li>对象模型与文件模型类似</li></ol></li><li>关系模型</li><li>键值模型</li><li>表格模型<ol><li>支持插入删除更新读取扫描</li><li>不支持多表关联</li></ol></li></ol><p>思考：单点登录（有状态服务器、无状服务器）</p><h2 id="文件服务体系结构"><a href="#文件服务体系结构" class="headerlink" title="文件服务体系结构"></a>文件服务体系结构</h2><h3 id="层次文件-XX"><a href="#层次文件-XX" class="headerlink" title="层次文件 XX"></a>层次文件 XX</h3><ol><li>树形结构目录——目录树</li><li>每个目录包含文件和其他可以从此目录访问的目录的名字</li><li>可以使用路径名来访问任一文件或目录<ol><li>NOTE： UNIX 文件系统不完全是树形的—一个文件可以在一个或多个目录中</li></ol></li><li>目录图一说</li></ol><h3 id="目录图"><a href="#目录图" class="headerlink" title="目录图"></a>目录图</h3><p>目录的维护：目录树中目录位空时，才能删除指向该目录。</p><h3 id="文件组"><a href="#文件组" class="headerlink" title="文件组"></a>文件组</h3><ul><li>位于给定服务器上的文件集合</li><li>一个服务器可以包含数个文件组</li><li>与 UNIX 中的文件集系统，一个存储设备或者分区拥有的文件的集合类似</li><li>分布式系统中</li></ul><h3 id="分布式文件系统中的命名方法"><a href="#分布式文件系统中的命名方法" class="headerlink" title="分布式文件系统中的命名方法"></a>分布式文件系统中的命名方法</h3><p>思考题</p><p>讨论：</p><ol><li>把主机名和文件的本地名字结合起来给文件明明</li><li>把远程文件目录附加到本地名字空间中</li><li>把所有各部分文件系统全部集成组成单一的全局名字结构</li></ol><h3 id="名字的结构"><a href="#名字的结构" class="headerlink" title="名字的结构"></a>名字的结构</h3><ol><li>绝对名字/相对名字</li><li>单层（平面）地址/分层地址</li></ol><h2 id="查找与解析"><a href="#查找与解析" class="headerlink" title="查找与解析"></a>查找与解析</h2><p>迭代名称解析</p><ul><li>解析程序将完整名称（dir，name1，namek）发给 server0</li><li>Server0</li></ul><p>连接：<a href="https://blog.csdn.net/lycb_gz/article/details/11720247" target="_blank" rel="noopener">例解 DNS 递归/迭代名称解析原理</a></p><h1 id="同步机制"><a href="#同步机制" class="headerlink" title="同步机制"></a>同步机制</h1><p>DFS 锁机制例</p><ul><li>分布式锁机制：GFS、GPFS、Lustre</li><li>租赁方式：NFS v4 提出，StorageTank 采用类似机制</li><li>基于时间的机制：NFS v3 提出，SANergy 等采用</li></ul><h2 id="文件的远程访问方法"><a href="#文件的远程访问方法" class="headerlink" title="文件的远程访问方法"></a>文件的远程访问方法</h2><ul><li>远程服务和缓存是实现客户进程对远程文件进行访问的两个互相补充的方法</li><li>常规文件缓存-&gt;减少磁盘读写，而分布式缓存-&gt;减少网络通信量</li><li>分布式文件系统中缓存方案设计<ul><li>被缓存的数据的粒度</li><li>客户缓存器的地点，即使用主存进行缓存，还是使用磁盘</li><li>如何传播被缓存的副本的修改</li><li>如何确定各个客户缓存中的数据是否一致</li></ul></li></ul><h2 id="缓存"><a href="#缓存" class="headerlink" title="缓存"></a>缓存</h2><h3 id="高速缓存"><a href="#高速缓存" class="headerlink" title="高速缓存"></a>高速缓存</h3><ul><li>写直达</li><li>写回</li><li>关闭时写</li><li>集中控制</li></ul><ol><li><p>复制</p><ol><li>通过对每个文件的独立备份来增加系统的可靠性</li><li>当一个文件服务器出现问题时，仍允许文件访问</li><li>把工作量分配到多个服务器上</li></ol></li><li><p>更新协议</p><ol><li>主拷贝复制</li><li>表决（voting）</li></ol></li></ol><h1 id="分布式文件系统举例"><a href="#分布式文件系统举例" class="headerlink" title="分布式文件系统举例"></a>分布式文件系统举例</h1><ol><li><p>NAS</p></li><li><p>VFS</p><p>在定义网络文件系统 NFS 时创造的</p></li><li><p>AFS</p></li><li>Lusture</li><li>GFS<ol><li>继承理念，HDFS 开源</li></ol></li><li>MogileFS</li><li>Fast DFS</li><li>Windows DFS</li><li>Hadoop HDFS</li><li>TFS<ol><li>淘宝提供海量小文件存储系统</li></ol></li></ol>]]></content>
    
    
    <categories>
      
      <category>Computer Science</category>
      
      <category>分布式系统</category>
      
    </categories>
    
    
    <tags>
      
      <tag>分布式系统</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>分布式系统学习——动态调度与负载平衡</title>
    <link href="/post/5824281a.html"/>
    <url>/post/5824281a.html</url>
    
    <content type="html"><![CDATA[<h2 id="动态调度"><a href="#动态调度" class="headerlink" title="动态调度"></a>动态调度</h2><p>集中 分散</p><p>开环 不参考过去决策</p><p>闭环 参考</p><h2 id="负载平衡"><a href="#负载平衡" class="headerlink" title="负载平衡"></a>负载平衡</h2><ol><li><p>负载（系统相关）举例：</p><ol><li>CPU 队列的长度（进程数目）</li><li>某时段 CPU 队列的平均长度</li><li>可用内存的大小</li><li>上下文切换的速率</li><li>系统调用的速率</li></ol><p>负载描述系统的负担状态</p></li></ol><h3 id="负载平衡算法构成方式"><a href="#负载平衡算法构成方式" class="headerlink" title="负载平衡算法构成方式"></a>负载平衡算法构成方式</h3><ol><li>选取发出者</li><li><p>选取任务</p><p>任务应该足够大，值得耗费额外的资源（转移操作）来处理它</p></li><li><p>选出目标</p><ol><li>集中式：收取信息协调者分配</li><li>非集中式：轮询（轮寻？）</li></ol></li></ol><p>信息策略：决定系统中其他站点的状态信息如何收集信息的（懒惰 or 积极）</p><a id="more"></a><h3 id="发送者主动算法"><a href="#发送者主动算法" class="headerlink" title="发送者主动算法"></a>发送者主动算法</h3><p>超载发送给轻载站点</p><ol><li>转移策略：阈值</li><li>选择策略：选择新任务</li><li>定位策略：阈值</li><li>信息策略：</li></ol><h3 id="接收者主动算法"><a href="#接收者主动算法" class="headerlink" title="接收者主动算法"></a>接收者主动算法</h3><p>负载不足时从重载站点获取额外任务</p><h3 id="双向主动算法"><a href="#双向主动算法" class="headerlink" title="双向主动算法"></a>双向主动算法</h3><h3 id="接收者主动的渗透算法"><a href="#接收者主动的渗透算法" class="headerlink" title="接收者主动的渗透算法"></a>接收者主动的渗透算法</h3><p>基本思想：</p><h3 id="预约策略"><a href="#预约策略" class="headerlink" title="预约策略"></a>预约策略</h3><p>一个轻载站点按一定方式查询系统状态，请求某个重载站点</p><h3 id="投标策略"><a href="#投标策略" class="headerlink" title="投标策略"></a>投标策略</h3><ol><li>重载站点向系统广播消息</li><li>接收到这一请求消息的站点根据自己的状态决定是否参与</li></ol><h3 id="广播策略"><a href="#广播策略" class="headerlink" title="广播策略"></a>广播策略</h3><h2 id="智能型任务调度算法"><a href="#智能型任务调度算法" class="headerlink" title="智能型任务调度算法"></a>智能型任务调度算法</h2><ol><li>最佳任务调度是$NP$完全问题，传统研究的寻优，存在一些问题<ol><li>分布式站点自治性和冬天变化的远程对象状态，使局部调度算法具有的全局状态信息是不确定的</li><li>系统观点来看</li></ol></li></ol><p>从而引出 智能型任务调度算法</p><h3 id="任务调度中的知识及其表示"><a href="#任务调度中的知识及其表示" class="headerlink" title="任务调度中的知识及其表示"></a>任务调度中的知识及其表示</h3><ol><li>调度知识：设计任务调度算法的一些经验、原理、规则、就近调度原则、不要调度运行中的任务等。</li><li>对象知识：构成任务调度算法的一些基本知识，一个对象知识主要是由对象提、作用在其上的操作和相关知识三部分组成。</li></ol><p>任务调度程序结构（图）</p><h3 id="任务调度算法的实现"><a href="#任务调度算法的实现" class="headerlink" title="任务调度算法的实现"></a>任务调度算法的实现</h3><ol><li>分层实现<ol><li>核心层：观察处理器的状态。一行成统计数据；将任务分配到指定的处理器；常驻内存</li><li>决策层：完成调度任务决策，包裹状态管理和决策管理</li><li>用户界面层：良好的 HCI。</li></ol></li></ol><p>自学</p><ol><li>基于 DNS 的</li><li>基于反向代理</li><li><p>基于 CDN</p></li><li><p>轮寻算法</p></li><li>Hash 散列算法</li></ol><p>思考题</p><ol><li>目前经常用到的负载均衡技术有哪些，都用在什么地方？</li><li>目前 memcached 集群用到的负载均衡技术有哪些</li><li>调研 JBoss 服务器中的负载平衡机制</li></ol><p>分布式系统范型？</p>]]></content>
    
    
    <categories>
      
      <category>Computer Science</category>
      
      <category>分布式系统</category>
      
    </categories>
    
    
    <tags>
      
      <tag>分布式系统</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>分布式系统学习——ATC19USTC文章</title>
    <link href="/post/6d7ef99f.html"/>
    <url>/post/6d7ef99f.html</url>
    
    <content type="html"><![CDATA[<h1 id="First-Step"><a href="#First-Step" class="headerlink" title="First Step"></a>First Step</h1><h2 id="摘要段"><a href="#摘要段" class="headerlink" title="摘要段"></a>摘要段</h2><p>技术背景：针对 LSM 树 IO 负担问题（频繁检查 SSTable 造成的读增加），通常会在 KV stores 中部署 Bloom 过滤器。Bloom 自身也存在误报，内存开销等问题。</p><p>文章贡献：利用 SSTable 的 access skewness 性质的普遍性，根据数据热点动态调整的异构 Bloom 过滤器——ElasticBF。且 ElasticBF 与 LSM 树的优化可整合到一起共同优化读取性能。性能提升均在 2x 以上。</p><h2 id="前置知识"><a href="#前置知识" class="headerlink" title="前置知识"></a>前置知识</h2><ol><li>LSM-Tree</li><li>SSTables</li><li>Bloom 过滤器</li><li>NoSQL 类型数据库</li></ol><h2 id="标题和段落开头"><a href="#标题和段落开头" class="headerlink" title="标题和段落开头"></a>标题和段落开头</h2><p>第四段主要是 ElasticBF 应用于各 DB 的效果验证。</p><h2 id="First-Step-Conclustion"><a href="#First-Step-Conclustion" class="headerlink" title="First Step Conclustion"></a>First Step Conclustion</h2><ol><li>系统-LSM 优化</li><li>没有读过相关的文章，前置知识都还不了解</li></ol><h2 id="文献调研"><a href="#文献调研" class="headerlink" title="文献调研"></a>文献调研</h2><ol><li>NoSQL 数据库——MonoDB、Cassandra、Dynamo</li><li>LSM-Tree、B-Tree、B+-Tree</li></ol>]]></content>
    
    
    <categories>
      
      <category>Computer Science</category>
      
      <category>分布式系统</category>
      
    </categories>
    
    
    <tags>
      
      <tag>Paper</tag>
      
      <tag>三步法</tag>
      
      <tag>分布式系统</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>【LeetCode-16-22】解题报告（模拟，集合）</title>
    <link href="/post/85a76ac.html"/>
    <url>/post/85a76ac.html</url>
    
    <content type="html"><![CDATA[<h1 id="原始题目"><a href="#原始题目" class="headerlink" title="原始题目"></a>原始题目</h1><p>一只蚂蚁坐在由白色和黑色方格构成的无限网格上。开始时，网格全白，蚂蚁面向右侧。每行走一步，蚂蚁执行以下操作。</p><p>(1) 如果在白色方格上，则翻转方格的颜色，向右(顺时针)转 90 度，并向前移动一个单位。<br>(2) 如果在黑色方格上，则翻转方格的颜色，向左(逆时针方向)转 90 度，并向前移动一个单位。</p><p>编写程序来模拟蚂蚁执行的前 K 个动作，并返回最终的网格。</p><p>网格由数组表示，每个元素是一个字符串，代表网格中的一行，黑色方格由  ‘X’  表示，白色方格由  ‘_‘  表示，蚂蚁所在的位置由  ‘L’, ‘U’, ‘R’, ‘D’  表示，分别表示蚂蚁   左、上、右、下 的朝向。只需要返回能够包含蚂蚁走过的所有方格的最小矩形。</p><h1 id="解题思路"><a href="#解题思路" class="headerlink" title="解题思路"></a>解题思路</h1><p>无需维护整个地图状态，用一个点集合来维护黑色方格，绘图时确定边界为$[min{now,p (p \in S)}, max{now, p (p \in S)}$。</p><p>需要特别注意的是 C++构造输出答案时应用了 <code>vector&lt;string&gt; ans(rows,temp)</code>构造方式，否则超时（逐个 push_back）。</p><a id="more"></a><h1 id="解题代码"><a href="#解题代码" class="headerlink" title="解题代码"></a>解题代码</h1><pre><code class="hljs C++"><span class="hljs-meta">#<span class="hljs-meta-keyword">include</span> <span class="hljs-meta-string">&lt;bits/stdc++.h&gt;</span></span><span class="hljs-keyword">using</span> <span class="hljs-keyword">namespace</span> <span class="hljs-built_in">std</span>;<span class="hljs-keyword">typedef</span> <span class="hljs-keyword">long</span> <span class="hljs-keyword">long</span> ll;<span class="hljs-keyword">typedef</span> <span class="hljs-keyword">unsigned</span> <span class="hljs-keyword">long</span> <span class="hljs-keyword">long</span> ull;<span class="hljs-keyword">typedef</span> pair&lt;<span class="hljs-keyword">int</span>, <span class="hljs-keyword">int</span>&gt; pii;<span class="hljs-meta">#<span class="hljs-meta-keyword">define</span> rep(i, a, n) for (int i = a; i &lt; n; ++i)</span><span class="hljs-meta">#<span class="hljs-meta-keyword">define</span> per(i, a, n) for (int i = n - 1; i &gt;= a; --i)</span><span class="hljs-meta">#<span class="hljs-meta-keyword">define</span> fi first</span><span class="hljs-meta">#<span class="hljs-meta-keyword">define</span> se second</span><span class="hljs-meta">#<span class="hljs-meta-keyword">define</span> pb push_back</span><span class="hljs-meta">#<span class="hljs-meta-keyword">define</span> np next_permutation</span><span class="hljs-meta">#<span class="hljs-meta-keyword">define</span> mp make_pair</span><span class="hljs-meta">#<span class="hljs-meta-keyword">define</span> all(x) x.begin(), x.end()</span><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Solution</span> &#123;</span><span class="hljs-keyword">public</span>:    <span class="hljs-built_in">vector</span>&lt;<span class="hljs-built_in">string</span>&gt; printKMoves(<span class="hljs-keyword">int</span> K)    &#123;        <span class="hljs-keyword">int</span> ax, ay;        <span class="hljs-keyword">int</span> dir[<span class="hljs-number">4</span>][<span class="hljs-number">2</span>] = &#123; &#123; <span class="hljs-number">-1</span>, <span class="hljs-number">0</span> &#125;, &#123; <span class="hljs-number">0</span>, <span class="hljs-number">-1</span> &#125;, &#123; <span class="hljs-number">1</span>, <span class="hljs-number">0</span> &#125;, &#123; <span class="hljs-number">0</span>, <span class="hljs-number">1</span> &#125; &#125;;        <span class="hljs-keyword">int</span> dirid;        <span class="hljs-keyword">char</span> mmp[<span class="hljs-number">4</span>] = &#123; <span class="hljs-string">'L'</span>, <span class="hljs-string">'U'</span>, <span class="hljs-string">'R'</span>, <span class="hljs-string">'D'</span> &#125;;        <span class="hljs-built_in">set</span>&lt;pii&gt; pos;        ax = ay = <span class="hljs-number">0</span>;        pos.clear();        dirid = <span class="hljs-number">2</span>;        rep(i, <span class="hljs-number">0</span>, K)        &#123;            <span class="hljs-keyword">if</span> (pos.count(mp(ax, ay)) == <span class="hljs-number">0</span>) &#123;                <span class="hljs-comment">// bai</span>                dirid = (dirid + <span class="hljs-number">1</span>) % <span class="hljs-number">4</span>;                pos.insert(mp(ax, ay));            &#125; <span class="hljs-keyword">else</span> &#123;                dirid = (dirid + <span class="hljs-number">3</span>) % <span class="hljs-number">4</span>;                pos.erase(mp(ax, ay));            &#125;            ax = ax + dir[dirid][<span class="hljs-number">0</span>];            ay = ay + dir[dirid][<span class="hljs-number">1</span>];        &#125;        <span class="hljs-keyword">int</span> vx_max = ax;        <span class="hljs-keyword">int</span> vx_min = ax;        <span class="hljs-keyword">int</span> vy_max = ay;        <span class="hljs-keyword">int</span> vy_min = ay;        <span class="hljs-keyword">for</span> (<span class="hljs-keyword">auto</span> i : pos) &#123;            vx_max = max(i.first, vx_max);            vx_min = min(i.first, vx_min);            vy_max = max(i.second, vy_max);            vy_min = min(i.second, vy_min);        &#125;        <span class="hljs-keyword">int</span> rows = vy_max - vy_min + <span class="hljs-number">1</span>;        <span class="hljs-keyword">int</span> cols = vx_max - vx_min + <span class="hljs-number">1</span>;        <span class="hljs-built_in">string</span> temp;        <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> i = <span class="hljs-number">0</span>; i &lt; cols; i++)            temp.push_back(<span class="hljs-string">'_'</span>);        <span class="hljs-built_in">vector</span>&lt;<span class="hljs-built_in">string</span>&gt; ans(rows, temp);        <span class="hljs-keyword">for</span> (<span class="hljs-keyword">auto</span> it = pos.begin(); it != pos.end(); it++) &#123;            ans[it-&gt;second - vy_min][it-&gt;first - vx_min] = <span class="hljs-string">'X'</span>;        &#125;        ans[ay - vy_min][ax - vx_min] = mmp[dirid];        <span class="hljs-keyword">return</span> ans;    &#125;&#125;;</code></pre>]]></content>
    
    
    <categories>
      
      <category>Computer Science</category>
      
      <category>ACM</category>
      
      <category>LeetCode</category>
      
    </categories>
    
    
    <tags>
      
      <tag>ACM</tag>
      
      <tag>LeetCode</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>【LeetCode-955】解题报告（暴力，贪心）</title>
    <link href="/post/78fc1ccf.html"/>
    <url>/post/78fc1ccf.html</url>
    
    <content type="html"><![CDATA[<h1 id="原始题目"><a href="#原始题目" class="headerlink" title="原始题目"></a>原始题目</h1><p>给定由  N  个小写字母字符串组成的数组  A，其中每个字符串长度相等。</p><p>选取一个删除索引序列，对于  A  中的每个字符串，删除对应每个索引处的字符。</p><p>比如，有  A = [“abcdef”, “uvwxyz”]，删除索引序列  {0, 2, 3}，删除后  A  为[“bef”, “vyz”]。</p><p>假设，我们选择了一组删除索引  D，那么在执行删除操作之后，最终得到的数组的元素是按 字典序（A[0] &lt;= A[1] &lt;= A[2] … &lt;= A[A.length - 1]）排列的，然后请你返回  D.length  的最小可能值。</p><h1 id="解题思路"><a href="#解题思路" class="headerlink" title="解题思路"></a>解题思路</h1><ol><li><p>裸枚举</p><p>对于每个位置，判断整体是否符合字典序，复杂度$O(WN^{2})$</p></li><li><p>贪心</p><p>对于每个间隔位置，用一个 vis 数组保存前面序列是否出现$A[i-1][j] &lt; A[i][j]$。</p><p>遍历每个位置，不用判断整体字符串，只需考虑新加入的列，结合 vis 数组，如何结合？</p><ul><li>若$vis[i] = 0$，表明之前间隔两边合法字符总是相同字符（反序字符列可以证明被删除），对于当前新加入的列，分三种情况，若出现正序，则更新为$vis[i]=1$；若相等，保持$vis[i]=0$；若出现反序，删除列，保持$vis[i]=0$。</li><li>若$vis[i]=1$，表明之前间隔两边出现至少一次正序，那该间隔无需再考虑，间隔将题目要求分割到不同段的子要求。</li></ul></li></ol><a id="more"></a><h1 id="解题代码"><a href="#解题代码" class="headerlink" title="解题代码"></a>解题代码</h1><ul><li>裸枚举</li></ul><pre><code class="hljs C++"><span class="hljs-meta">#<span class="hljs-meta-keyword">include</span> <span class="hljs-meta-string">&lt;bits/stdc++.h&gt;</span></span><span class="hljs-keyword">using</span> <span class="hljs-keyword">namespace</span> <span class="hljs-built_in">std</span>;<span class="hljs-keyword">typedef</span> <span class="hljs-keyword">long</span> <span class="hljs-keyword">long</span> ll;<span class="hljs-keyword">typedef</span> <span class="hljs-keyword">unsigned</span> <span class="hljs-keyword">long</span> <span class="hljs-keyword">long</span> ull;<span class="hljs-keyword">typedef</span> pair&lt;<span class="hljs-keyword">int</span>, <span class="hljs-keyword">int</span>&gt; pii;<span class="hljs-keyword">typedef</span> pair&lt;<span class="hljs-built_in">string</span>, <span class="hljs-built_in">string</span>&gt; pss;<span class="hljs-keyword">typedef</span> <span class="hljs-built_in">vector</span>&lt;<span class="hljs-keyword">int</span>&gt; vi;<span class="hljs-keyword">typedef</span> <span class="hljs-built_in">vector</span>&lt;<span class="hljs-built_in">string</span>&gt; vs;<span class="hljs-meta">#<span class="hljs-meta-keyword">define</span> rep(i, a, n) for (int i = a; i &lt; n; ++i)</span><span class="hljs-meta">#<span class="hljs-meta-keyword">define</span> per(i, a, n) for (int i = n - 1; i &gt;= a; --i)</span><span class="hljs-meta">#<span class="hljs-meta-keyword">define</span> all(x) x.begin(), x.end()</span><span class="hljs-meta">#<span class="hljs-meta-keyword">define</span> mp make_pair</span><span class="hljs-meta">#<span class="hljs-meta-keyword">define</span> pb push_back</span><span class="hljs-meta">#<span class="hljs-meta-keyword">define</span> np next_permutation</span><span class="hljs-meta">#<span class="hljs-meta-keyword">define</span> fi first</span><span class="hljs-meta">#<span class="hljs-meta-keyword">define</span> se second</span><span class="hljs-function"><span class="hljs-keyword">bool</span> <span class="hljs-title">compare</span><span class="hljs-params">(<span class="hljs-built_in">vector</span>&lt;<span class="hljs-built_in">string</span>&gt;&amp; A)</span></span>&#123;    rep(i, <span class="hljs-number">1</span>, A.size())    &#123;        <span class="hljs-keyword">if</span> (A[i - <span class="hljs-number">1</span>] &gt; A[i]) &#123;            <span class="hljs-keyword">return</span> <span class="hljs-literal">false</span>;        &#125;    &#125;    <span class="hljs-keyword">return</span> <span class="hljs-literal">true</span>;&#125;<span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Solution</span> &#123;</span><span class="hljs-keyword">public</span>:    <span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">minDeletionSize</span><span class="hljs-params">(<span class="hljs-built_in">vector</span>&lt;<span class="hljs-built_in">string</span>&gt;&amp; A)</span>    </span>&#123;        <span class="hljs-built_in">vector</span>&lt;<span class="hljs-built_in">string</span>&gt; test(A.size(), <span class="hljs-string">""</span>);        <span class="hljs-keyword">int</span> ans = <span class="hljs-number">0</span>;        rep(i, <span class="hljs-number">0</span>, A.front().size())        &#123;            rep(j, <span class="hljs-number">0</span>, A.size())            &#123;                test[j].pb(A[j][i]);            &#125;            <span class="hljs-keyword">if</span> (!compare(test)) &#123;                ans++;                rep(j, <span class="hljs-number">0</span>, A.size())                &#123;                    test[j].pop_back();                &#125;            &#125;        &#125;        <span class="hljs-keyword">return</span> ans;    &#125;&#125;;</code></pre><ul><li>贪心</li></ul><pre><code class="hljs C++">class Solution &#123;public:    int minDeletionSize(vector&lt;string&gt;&amp; A)    &#123;        int ans = 0;        vi pos(A.size(), 0);        rep(i, 0, A.front().size())        &#123;            int flag = 0;            rep(j, 1, A.size())            &#123;                if (!pos[j] &amp;&amp; A[j][i] &lt; A[j - 1][i]) &#123;                    ans++;                    flag = 1;                    break;                &#125;            &#125;            if (flag)                continue;            rep(j, 1, A.size())            &#123;                if (A[j - 1][i] &lt; A[j][i]) &#123;                    pos[j] = 1;                &#125;            &#125;        &#125;        return ans;    &#125;&#125;;</code></pre><h1 id="收获与反思"><a href="#收获与反思" class="headerlink" title="收获与反思"></a>收获与反思</h1><p>暂无</p>]]></content>
    
    
    <categories>
      
      <category>Computer Science</category>
      
      <category>ACM</category>
      
      <category>LeetCode</category>
      
    </categories>
    
    
    <tags>
      
      <tag>ACM</tag>
      
      <tag>LeetCode</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>算法与数据结构学习——DP背包问题备课提纲</title>
    <link href="/post/bc73800d.html"/>
    <url>/post/bc73800d.html</url>
    
    <content type="html"><![CDATA[<h1 id="动态规划（DP）简介"><a href="#动态规划（DP）简介" class="headerlink" title="动态规划（DP）简介"></a>动态规划（DP）简介</h1><blockquote><p>Those who cannot remember the past are condemned to repeat it.</p></blockquote><h2 id="什么是动态规划算法"><a href="#什么是动态规划算法" class="headerlink" title="什么是动态规划算法"></a>什么是动态规划算法</h2><blockquote><p>Dynamic programming is both a mathematical optimization method and a computer programming method. The method was developed by Richard Bellman in the 1950s and has found applications in numerous fields, from aerospace engineering to economics. In both contexts it refers to simplifying a complicated problem by breaking it down into simpler sub-problems in a recursive manner.</p><p>Dynamic programming has evolvd into a major paradigm of algorithm design in computer science. The name was coined in 1957 by Richard Bellman to decribe a type of <code>optimum control problem</code>.</p></blockquote><p>根据前述内容以及余老师 PPT 上的介绍，动态规划（DP）诞生初用于描述一类问题而非描述一种求解方式。不过随着时间演变，现在 DP 更常用来表示一类算法（尤其在 CS 领域）。</p><h2 id="核心思想"><a href="#核心思想" class="headerlink" title="核心思想"></a>核心思想</h2><ul><li>解决小规模的子问题</li><li>将小规模问题的解（解集）储存起来</li><li>利用小规模问题解集状态转移至大规模问题的解集状态</li><li>最终解（最大规模的 final 解）即为我们所求的最终解</li></ul><h2 id="适用条件"><a href="#适用条件" class="headerlink" title="适用条件"></a>适用条件</h2><blockquote><p>There are two key attributes that a problem must have in order for dynamic programming to be applicable: optimal substructure and overlapping sub-problems.</p></blockquote><h3 id="最优子结构（Optimal-structure）"><a href="#最优子结构（Optimal-structure）" class="headerlink" title="最优子结构（Optimal structure）"></a>最优子结构（Optimal structure）</h3><p>A problem is said to have <code>optimal substructure</code> if an optimal solution can be constructed efficiently from optimal sulutions to its subprolems. Also is called <code>Principle of Optimality</code> by Bellman.</p><h3 id="子问题重叠（Overlapping-sub-problems）"><a href="#子问题重叠（Overlapping-sub-problems）" class="headerlink" title="子问题重叠（Overlapping sub-problems）"></a>子问题重叠（Overlapping sub-problems）</h3><p>子问题重叠并不是定义 DP 类型问题的必要条件，但是当子问题出现大规模重叠时，DP 算法更能体现效果，最简单直接的例子：分治思想和 DP 思想求解斐波那契额数列。</p><h2 id="随便谈谈"><a href="#随便谈谈" class="headerlink" title="随便谈谈"></a>随便谈谈</h2><h3 id="与分治法（Divide-and-Conquer）对比"><a href="#与分治法（Divide-and-Conquer）对比" class="headerlink" title="与分治法（Divide and Conquer）对比"></a>与分治法（Divide and Conquer）对比</h3><blockquote><p>If a problem can be solved by combining optimal solutions to non-overlapping sub-problems, the strategy is called “divide and conquer” instead.[1] This is why merge sort and quick sort are not classified as dynamic programming problems — Introduction to Algorithms (2nd ed.), MIT Press.</p></blockquote><p>子问题孤立，更适用于分治法，这点出了“Divide and Conquer”与“Dynamic Programming”，两种算法思想的本质不同。此外，求解过程中，分治法倾向于从顶向下递归分解问题然后再递归合成大规模问题的解，而动态规划算法则初始计算小问题的解，根据状态转移方程自底向上计算所求状态的解。</p><h3 id="与贪心算法（Greedy）对比"><a href="#与贪心算法（Greedy）对比" class="headerlink" title="与贪心算法（Greedy）对比"></a>与贪心算法（Greedy）对比</h3><p>贪心算法，对于尚未加入解集的元素按固定策略（最大或最小）选取状态转移，即总是遵循某种规则，做出局部最优的选择，以推导出全局最优解，所解决的问题也具有最优子结构性质。</p><p>以即将要讨论的 01 背包问题为例，贪心想法是在一次选择中选取未选择物体中价值/重量比最高的。这个局部选择是最优的，但不考虑整体背包选择方案是否最优。而动态优化则要求当前拾取物体从之前状态（减去该物体重量的最优态）转移过来，这样就保证了一定的全局性质。</p><h3 id="前向性"><a href="#前向性" class="headerlink" title="前向性"></a>前向性</h3><p>No backwards: depending on the current state.</p><p>下一时刻的状态只与当前状态有关，而和当前状态之前的状态无关，当前的状态是对以往决策的总结，个人理解，这就是<code>Dynamic</code>的体现。</p><a id="more"></a><h1 id="经典-DP-问题：背包问题"><a href="#经典-DP-问题：背包问题" class="headerlink" title="经典 DP 问题：背包问题"></a>经典 DP 问题：背包问题</h1><p>背包问题相信大家都不陌生，它是动态规划算法学习过程中不得不提的经典系列问题，而 01 背包问题又是该系列问题的基础。</p><p>在编程解决问题的过程中，我们常会使用空间优化与常数优化来加速程序的执行，在程序设计竞赛中，由于时间上的限制，我们的关注点常在程序的运行结果是否与标程的运行结果相一致，对于优化的影响却无暇关心。</p><p>优化问题，也是计算机科学家与专业编程人员常常关注的点，利用本节课的时间，我们会着重讨论求解 01 背包问题的优化方式以及其影响。</p><h2 id="01-背包题目"><a href="#01-背包题目" class="headerlink" title="01 背包题目"></a>01 背包题目</h2><p>有$N$件物品和一个容量为$V$的背包。放入第$i$件物品耗费的费用是$C_i$，得到的价值是$Value_i$。求解将哪些物品装入背包可使价值总和最大。</p><h2 id="基本解题思路"><a href="#基本解题思路" class="headerlink" title="基本解题思路"></a>基本解题思路</h2><p>因为每种物品只有一件，选择只有放（1）、不放（0）两种状态，所以称这类问题为 01 背包问题。</p><p>该问题对应的子问题为：<strong>取其中$i$件物品放入背包得到的最大价值</strong>。为了方便，我们给原物体一个序，则对应子问题为：<strong>取前$i$件物品放入背包得到的最大价值</strong>。根据该子问题，我们定义状态$F[i,v]$为前$i$件物品放入限制重量为$v$所能得到的最大价值，然后我们可以想出状态转移方程。</p><script type="math/tex; mode=display">F[i,v] = max \{ F[i-1,v] , F[i-1,v-C_i] + Value_i \}</script><p>该状态转移方程的含义为：按序逐个拾取物体的过程中，拾取$i$号且背包限制为$v$重量状态（$F[i,v]$），其只由两种状态转移而来，不选择该物体（则状态取值同相同限重量拾取上个物体时的状态 $F[i-1,v]$），选择该物体（则状态取值由上次选择时，限重为当下限重减去此次拾取物体重量的状态转移而来$F[i-1,v-C_i]+Value_i$）。</p><p>最优子结构性质与无后向性是可证的，见下一节附加内容。</p><p>原文特别强调了上述转移方程的重要性，也做了相应的解释：</p><blockquote><p>这个方程非常重要，基本上所有跟背包象关的问题的方程都是由它衍生出来的。所以有必要将它详细解释一下：“将前$i$件物品放入容量为$v$的背包中”这个子问题，若只考虑第$i$件物品的策略（放或不放），那么就可以转化为一个只和前$i-1$件物品相关的问题。如果不放第$i$件物品，那么问题就转化为“前$i-1$件物品放入容量为$v$的背包中”，价值为$F[i-1,v]$；如果放第$i$件物品，那么问题就转化为“前$i-1$件物品放入剩下的容量为$v-C_i$的背包中”，此时能获得的最大价值就是$F[i-1,v-C_i]$再加上通过放入第$i$件物品获得的价值$Value_i$。</p></blockquote><p>伪代码描述：</p><pre><code class="hljs C++">F[<span class="hljs-number">0</span>,<span class="hljs-number">0.</span>.V] ← <span class="hljs-number">0</span><span class="hljs-keyword">for</span> i ← <span class="hljs-number">1</span> to n    <span class="hljs-keyword">for</span> v ← w[i] to V        F[i,v] ← max&#123;F[i<span class="hljs-number">-1</span>,v] , F[i<span class="hljs-number">-1</span>,v-w[i]]+v[i]&#125;</code></pre><h2 id="附加：最优子结构证明"><a href="#附加：最优子结构证明" class="headerlink" title="附加：最优子结构证明"></a>附加：最优子结构证明</h2><p>学习自博客<a href="https://blog.csdn.net/mspolo/article/details/8738676" target="_blank" rel="noopener">01 背包存在最优子结构的证明</a></p><p>表述：</p><blockquote><p>$n$为背包重量限制，$w[i]$为$i$物体重量，$v[i]$为$i$物体价值，如果$(z_1,z_2 \cdots z_k)$是问题$f_k(n)$的最优解，那么</p><ol><li>对于任意$1 \le j \le k$，有$z_j = 1$（确定$j$物体状态为取），则有$(z_1,z_2 \cdots z_{j_1} , z_{j+1} , z_{j+2} \cdots z_k)$是问题$f_{k-1}(n-w[j])+ v[j]$的最优解</li><li>对于任意$1 \le j \le k$，有$z_j = 0$（确定$j$物体状态为不取），则有$(z_1,z_2 \cdots z_{j_1} , z_{j+1} , z_{j+2} \cdots z_k)$是问题$f_{k-1}(n)$的最优解。</li></ol><p>这里 $i$ 表示子问题的规模，表述为将 $i$ 个物品放入容量为$v$的背包中，</p></blockquote><p>证明（反证法）：</p><p>假设子问题不是最优解，对于情况 1，假设存在$(z_1’,z_2’ \cdots z_{j-1}’ , z_{j+1}’ ,\cdots z_k’)$ 是子问题的最优解，那么 $f_k(n)$的最优解将会是$(z_1’,z_2’ \cdots z_{j-1}’ , z_j , z_{j+1}’ \cdots z_k’)$，与假设矛盾。情况 2 同理。</p><h1 id="算法优化与代价"><a href="#算法优化与代价" class="headerlink" title="算法优化与代价"></a>算法优化与代价</h1><h2 id="空间复杂度优化"><a href="#空间复杂度优化" class="headerlink" title="空间复杂度优化"></a>空间复杂度优化</h2><p>由于要使用$dp[n][v]$状态空间，如果储存全部状态，根据伪代码思路，该动态优化算法的时间和空间复杂度均为$O(VN)$，其中时间复杂度应该已经不能再优化了，但空间复杂度却可以优化到$O(V)$。</p><p>我们观察状态转移方程</p><script type="math/tex; mode=display">F[i,v] = max \{ F[i-1,v] , F[i-1,v-C_i] + Value_i \}</script><p>我们每轮计算前$i$个在不同限重背包的最优值时，利用的状态只有$i-1$时的状态，也即上一轮外层循环得到的值，据此我们可以使用一些优化方法。</p><h3 id="滚动数组"><a href="#滚动数组" class="headerlink" title="滚动数组"></a>滚动数组</h3><p>每次都使用固定的几个存储空间，来达到压缩 or 节省存储空间的目的。主要应用在递推或动态规划中。</p><p>代码描述</p><pre><code class="hljs C++"><span class="hljs-keyword">for</span> (i=<span class="hljs-number">1</span> ;i &lt;= n; i++)&#123;    <span class="hljs-keyword">for</span> (v = w[i] ; v &lt;= V ; v++)    &#123;        dp[<span class="hljs-number">1</span>][v] = max(dp[<span class="hljs-number">0</span>][v],dp[<span class="hljs-number">0</span>][v-w[i]]+v[i]);    &#125;    <span class="hljs-comment">// 一轮更新结束后统一翻转</span>    <span class="hljs-keyword">for</span> (v = <span class="hljs-number">0</span>; v&lt;=V ; v++)&#123;        dp[<span class="hljs-number">0</span>][v] = dp[<span class="hljs-number">1</span>][v];    &#125;&#125;</code></pre><p>当然我们还发现状态转移方程中，只会利用背包限重状态小于等于要更新状态的已知状态，所以我们按逆序（从大到小）遍历内层循环，就可以避免在同一轮外层循环中先更新的影响后更新的值，由此修改滚动数组代码。</p><pre><code class="hljs C++"><span class="hljs-keyword">for</span> (i=<span class="hljs-number">1</span> ;i &lt;= n; i++)&#123;    <span class="hljs-keyword">for</span> (v = V ; v &gt;= w[i] ; v--)    &#123;        dp[<span class="hljs-number">1</span>][v] = max(dp[<span class="hljs-number">0</span>][v],dp[<span class="hljs-number">0</span>][v-w[i]]+v[i]);        dp[<span class="hljs-number">0</span>][v] = dp[<span class="hljs-number">1</span>][v];    &#125;&#125;</code></pre><h3 id="压缩至一维数组"><a href="#压缩至一维数组" class="headerlink" title="压缩至一维数组"></a>压缩至一维数组</h3><p>那既然逆序已经避免同一轮更新中先更新的影响后更新的值，实际上滚动数组也非必要了。我们使用一维数组便可实现状态转移，并且保证计算$dp[v]$时，$dp[v-w[i]]$保存的是对应二维$dp[i-1][v-w[i]]$的值。</p><pre><code class="hljs C++"><span class="hljs-keyword">for</span> (i=<span class="hljs-number">1</span> ;i &lt;= n; i++)&#123;    <span class="hljs-keyword">for</span> (v = V ; v &gt;= w[i] ; v--)    &#123;        dp[v] = max(dp[v],dp[v-w[i]]+v[i]);    &#125;&#125;</code></pre><h2 id="时间复杂度常数优化"><a href="#时间复杂度常数优化" class="headerlink" title="时间复杂度常数优化"></a>时间复杂度常数优化</h2><p>伪代码中</p><pre><code class="hljs C++"><span class="hljs-keyword">for</span> i ← <span class="hljs-number">1</span> to n    <span class="hljs-keyword">for</span> v ← V to w[i]</code></pre><p>《背九》原作者给出可以优化为$V \quad to \quad max(V − \sum_i^N C_i, C_i)$。我个人认为可以严格到$V \quad to \quad max(V - \sum_{i+1}^N C_i,C_i)$。</p><pre><code class="hljs C++">for i ← 1 to n    for v ← V to max(w[i],V-(w[i+1]+...+w[n]))</code></pre><p>如何理解这个常数优化？，我们需要回过头来再看看状态转移方程。</p><script type="math/tex; mode=display">F[i,v] = max \{ F[i-1,v] , F[i-1,v-C_i] + Value_i \}</script><p>我们固定某一限重状态随$i$递增的变化，不妨研究与最终答案相关的，$final(i)= F[i][V]$。我们发现在$i$递增一轮过程中。$final$只会变动一次，且只有两个可能的方向，不变（延续$i$上一轮递增后得到的结果），改变（受$F[i-1][V-w[i]]$影响）。</p><p>如果我们将，可以影响$final$的所有限重状态，随$i$减小（逆序），画出来，我们可以发现能够影响到答案（最终状态）的边界是逐渐减小的。</p><p>我们可以发现，能够影响$final$的重量状态是有限的，并且随$i$减小，可影响的状态逐渐扩张，最后一次只有$final=dp[n][V]$单一状态影响最终答案（因为它本身就是最终答案），每一轮可能影响到$final$的边界应是，$max(V - \sum_{i+1}^N Value_i,C_i)$，这里可以补充一下，原作者认为是求和下限应为$i$，带入最后$i=N$我们发现在最后一轮除了更新$dp[N]$还更新了其他与最终答案无关的状态，所以我觉得这个更严格的界限是正确的。</p><p>反过来想也可以，在计算$dp[v]$时，若某一限重状态最终能够影响$final$，必然要经过几轮$i$递增（理想状态是，$dp[v+w[i+1]$每次都能受到影响），这也提醒我们，某一状态影响最终结果是需要一定时间限制的，在$i$逐渐靠近$n$时，即便我们遇到重量很小但是价值很大的一颗“金子”，我们也不一定需要从它的重量开始更新状态。</p><p>举例来讲比如最后三个物体是</p><pre><code class="hljs C++"><span class="hljs-comment">// n = 10   V = 50</span><span class="hljs-comment">// 当前dp[50]=150</span>w[n<span class="hljs-number">-2</span>]=<span class="hljs-number">2</span>  v[n<span class="hljs-number">-2</span>]=<span class="hljs-number">100</span> <span class="hljs-comment">//金子</span>w[n<span class="hljs-number">-1</span>]=<span class="hljs-number">5</span>  v[n<span class="hljs-number">-1</span>]=<span class="hljs-number">40</span>w[n]=<span class="hljs-number">3</span>    v[n]=<span class="hljs-number">50</span></code></pre><p>此时$w[i] = 2$,$V-sum=42$（按照底为$i+1$的求和）。如果只是为了获得正确的$dp[50]$，我们需要从$v=50$更新到$v=42$就够了呢？还是说要更新到$v=2$，显然，我们更新到$v=42$就够了，即便后面两个物体在最优解中都要取，$dp[42]$会影响下一轮的$dp[47]$，进而影响最终的$dp[50]$。</p><h2 id="优化的代价"><a href="#优化的代价" class="headerlink" title="优化的代价"></a>优化的代价</h2><blockquote><p>优化不是无代价的</p></blockquote><p>承上面例子，显然根据常数优化算法，我们最终可以得到正确的$dp[50]$，但我们在想，有没有少些什么？</p><p>很明显啊，在倒数第三轮外层循环我们没有计算新的$dp[2]$（而大概率碰到金子，2 格背包我们应该捡起来啊！），那么不更新的代价是什么呢？</p><p>针对题目，影响最终答案么？</p><p><strong>不影响</strong>。</p><p>不针对题目，影响答案么？</p><p><strong>影响</strong>，因为改变了状态空间解集。</p><h3 id="朴素二维动态规划得到的解集"><a href="#朴素二维动态规划得到的解集" class="headerlink" title="朴素二维动态规划得到的解集"></a>朴素二维动态规划得到的解集</h3><p>$dp[n][V]$储存了（在该遍历序下）<strong>任意小于序长度前缀，任意小于最大限制容量</strong>的解集。也即在不增删修改物品条件下，后续满足上述条件的任意询问$Q_1$，都可以在$O(1)$的时间给出答案。</p><h3 id="一维压缩空间优化得到的解集"><a href="#一维压缩空间优化得到的解集" class="headerlink" title="一维压缩空间优化得到的解集"></a>一维压缩空间优化得到的解集</h3><p>$dp[V]$储存了<strong>长度等于序长，任意小于最大限制容量</strong>的解集。同样，不改变物体，对该序询问容量小于限制的背包问题$Q_2$，都可以在$O(1)$的时间给出答案，但是如果想询问前缀问题（而非序长），则不能获得，<strong>因为在外层循环迭代中，没有保留这部分结果</strong>。</p><h3 id="空间优化-常数优化的解集"><a href="#空间优化-常数优化的解集" class="headerlink" title="空间优化+常数优化的解集"></a>空间优化+常数优化的解集</h3><p>只能保证$dp[i],i=V$单个值是正确的，而<strong>其他值均无意义</strong>。</p><p>根据上述这些“发现”，我们能学到什么？</p><p>对于正在讨论的问题，如果关注单解，那么空间+常数优化自然是很好的选择，但是如果数据固定而频繁询问，不考虑更新算法的话，那么朴素的二维 dp 或许是最好的。优化不应该是盲目的，有些优化需要我们理解背后更深的意义及影响，才能更好的应用在我们的程序中。</p><h1 id="其他-DP-优化算法"><a href="#其他-DP-优化算法" class="headerlink" title="其他 DP 优化算法"></a>其他 DP 优化算法</h1><p>空间复杂度常与实现方式有关，这里我们考虑通用的时间复杂度优化，影响动态规划时间复杂度的因素：</p><p>时间复杂度=所需计算状态总数*每个状态转移的状态数*每次状态转移的时间</p><p>通常，我们考虑对动态优化算法进行优化时，要从上述三个因素着手。</p><blockquote><p>需要指出的是：这三者之间不是相互独立的，而是相互联系，矛盾而统一的。有时，实现了某个因素的优化，另外两个因素也随之得到了优化；有时，实现某个因素的优化却要以增大另一因素为代价。因此，这就要求我们在优化时，坚持“全局观”，实现三者的平衡。 ——《动态规划算法的优化技巧》毛子青</p></blockquote><p>回顾 01 背包问题时间复杂度常数优化，我们是优化了所需计算状态总数（对应二维数组容易理解）。本节后面内容，将结合其他经典的动态规划问题，介绍另外的优化方法。</p><h2 id="矩阵优化递推"><a href="#矩阵优化递推" class="headerlink" title="矩阵优化递推"></a>矩阵优化递推</h2><p>常用于线性递推式，能以对数优化线性计算。通用模型：</p><script type="math/tex; mode=display">f(n-1) = a f(n-1) + b f(n-2) + c</script><p>矩阵递推式代替原有递推式，将所求转换为矩阵连乘形式。</p><script type="math/tex; mode=display">\left[ \begin{matrix}   f(n) \\   f(n-1) \\   1  \end{matrix}\right]=\left[ \begin{matrix}    a & b & c \\    1 & 0 & 0 \\    0 & 0 & 1 \\ \end{matrix}\right]\times\left[\begin{matrix}    f(n-1) \\    f(n-2) \\    1\\\end{matrix}\right]</script><p>这样做有什么好处呢？将系数矩阵设为$base$</p><script type="math/tex; mode=display">base = \left[    \begin{matrix}    a & b & c \\    1 & 0 & 0 \\    0 & 0 & 1 \\    \end{matrix}\right]</script><script type="math/tex; mode=display">\left[ \begin{matrix}   f(n) \\   f(n-1) \\   1  \end{matrix}\right]={base}^{n-2}\left[\begin{matrix}    f(2) \\    f(1) \\    1\\\end{matrix}\right]</script><p>${base}^{n-2}$可用快速幂算法加速运算。</p><p>举例题目：【洛谷-P1962 斐波那契数列】【CSU-1895 Apache is late again】</p><p>这里以后者题目为例。</p><p>利用（矩阵）快速幂算法进行运算。</p><h2 id="利用决策单调性进行优化"><a href="#利用决策单调性进行优化" class="headerlink" title="利用决策单调性进行优化"></a>利用决策单调性进行优化</h2><p>学习自毛子青的《动态规划算法的优化技巧》，该优化方法针对每个状态转移数的优化。</p><p>石子合并问题也是经典的DP问题，描述如下： 在一个操场上摆放着一排n（n≤20）堆石子。现要将石子有次序地合并成一堆。规定每次只能选相邻的2堆石子合并成新的一堆，并将新的一堆石子数记为该次合并的得分。</p><p>试编程求出将n堆石子合并成一堆的最小得分和最大得分以及相应的合并方案。</p><p>核心：状态转移方程</p><script type="math/tex; mode=display">m[i,j] = \min_{i<k≤j} \{m[i, k-1]+m[k,j] + \sum_{l=i}^jd[l] \}  \quad i＜j</script><h3 id="四边形不等式"><a href="#四边形不等式" class="headerlink" title="四边形不等式"></a>四边形不等式</h3><p>当函数$w[i,j]$满足$w[i,j]+w[i’,j’]  \le w[i’,j] + w[i,j’] , \quad i \le i’ \le j \le j’$。</p><p>当函数$w[i,j]$满足$w[i’,j]≤w[i,j’]  \quad i \le i’ \le j \le j’$时称$w$关于区间包含关系单调。</p><p>在石子归并问题中，我们可以依次证明$\sum_{l=i}^j𝑑[l]$、$𝑚[𝑖,𝑗]$、$𝑠[𝑖,𝑗]$满足四边形不等式。所以优化状态转移数，状态转移方程为：</p><script type="math/tex; mode=display">m[i,j] = \min_{s[i,j-1]<k≤s[i+1,j]} \{m[i, k-1]+m[k,j] + \sum_{l=i}^jd[l] \}  \quad i＜j</script>]]></content>
    
    
    <categories>
      
      <category>Computer Science</category>
      
      <category>算法与数据结构</category>
      
    </categories>
    
    
    <tags>
      
      <tag>算法与数据结构</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>算法与数据结构学习——01背包问题常数优化算法对问题解集的影响</title>
    <link href="/post/1590e320.html"/>
    <url>/post/1590e320.html</url>
    
    <content type="html"><![CDATA[<h1 id="再述-01-背包问题"><a href="#再述-01-背包问题" class="headerlink" title="再述 01 背包问题"></a>再述 01 背包问题</h1><p>本篇博文使用题目及符号的习惯表达方式均来自于《背包问题九讲》。</p><p>背包问题相信大家都不陌生，动态规划算法学习过程中不得不提得经典系列问题，而 01 背包问题又是系列问题得基础，在编程实现过程中，我们常会使用空间优化与常数优化来加速程序的执行，在程序设计竞赛中我们关注点在程序的运行结果是否与标程的运行结果是否一致，但对于优化的影响却不甚关心，我记得在自己学习编译原理优化一章时，徐老师常常谈起优化的代价，今天这篇博文主题便是这个经典问题空间优化与常数优化的影响与代价。</p><p>对原题目非常熟悉的请直接跳过前面题目和思路以及优化方法介绍，阅览最后两节内容。</p><h1 id="题目"><a href="#题目" class="headerlink" title="题目"></a>题目</h1><p>有$N$件物品和一个容量为$V$的背包。放入第$i$件物品耗费的费用是$C_i^1$，得到的价值是$Value_i$。求解将哪些物品装入背包可使价值总和最大。</p><h1 id="基本解题思路"><a href="#基本解题思路" class="headerlink" title="基本解题思路"></a>基本解题思路</h1><p>因为每种物品只有一件，选择只有放（1）、不放（0）两种状态，所以称这类问题为 01 背包问题。</p><p>该问题对应的子问题为：<strong>前$i$件物品放入背包得到的最大价值。</strong>，根据该子问题，我们定义状态$F[i,v]$为前$i$件物品放入限制重量为$v$所能得到的最大价值，然后我们可以想出状态转移方程。</p><script type="math/tex; mode=display">F[i,v] = max \{ F[i-1,v] , F[i-1,v-C_i] + Value_i \}</script><p>其含义为：逐个拾取编号问题过程中，拾取$i$号且背包限制为$v$重量时（$F[i,v]$），其只由两种状态转移而来，不选择该物体（则状态同相同限重量拾取上个物体时的状态 $F[i-1,v]$），选择该物体（则状态由上次选择时，限重为当下限重减去此次拾取物体重量的状态转移而来$F[i-1,v-C_i]+Value_i$）。</p><p>最优子结构性质与无后向性是可证的，见下一节附加内容。</p><p>原文特别强调了上述转移方程的重要性，也做了相应的解释：</p><blockquote><p>这个方程非常重要，基本上所有跟背包象关的问题的方程都是由它衍生出来的。所以有必要将它详细解释一下：“将前$i$件物品放入容量为$v$的背包中”这个子问题，若只考虑第$i$件物品的策略（放或不放），那么就可以转化为一个只和前$i-1$件物品相关的问题。如果不放第$i$件物品，那么问题就转化为“前$i-1$件物品放入容量为$v$的背包中”，价值为$F[i-1,v]$；如果放第$i$件物品，那么问题就转化为“前$i-1$件物品放入剩下的容量为$v-C_i$的背包中”，此时能获得的最大价值就是$F[i-1,v-C_i]$再加上通过放入第$i$件物品获得的价值$Value_i$。</p></blockquote><p>伪代码描述：</p><pre><code class="hljs C++">F[<span class="hljs-number">0</span>,<span class="hljs-number">0.</span>.V] ← <span class="hljs-number">0</span><span class="hljs-keyword">for</span> i ← <span class="hljs-number">1</span> to n    <span class="hljs-keyword">for</span> v ← w[i] to V        F[i,v] ← max&#123;F[i<span class="hljs-number">-1</span>,v] , F[i<span class="hljs-number">-1</span>,v-w[i]]+v[i]&#125;</code></pre><h1 id="附加：最优子结构证明"><a href="#附加：最优子结构证明" class="headerlink" title="附加：最优子结构证明"></a>附加：最优子结构证明</h1><p>学习自博客<a href="https://blog.csdn.net/mspolo/article/details/8738676" target="_blank" rel="noopener">01 背包存在最优子结构的证明</a></p><p>表述：</p><blockquote><p>$n$为背包重量限制，$w[i]$为$i$物体重量，$v[i]$为$i$物体价值，如果$(z_1,z_2 \cdots z_k)$是问题$f_k(n)$的最优解，那么</p><ol><li>对于任意$1 \le j \le k$，有$z_j = 1$（确定$j$物体状态为取），则有$(z_1,z_2 \cdots z_{j_1} , z_{j+1} , z_{j+2} \cdots z_k)$是问题$f_{k-1}(n-w[j])+ v[j]$的最优解</li><li>对于任意$1 \le j \le k$，有$z_j = 0$（确定$j$物体状态为不取），则有$(z_1,z_2 \cdots z_{j_1} , z_{j+1} , z_{j+2} \cdots z_k)$是问题$f_{k-1}(n)$的最优解。</li></ol><p>这里 $i$ 表示子问题的规模，表述为将 $i$ 个物品放入容量为$v$的背包中，</p></blockquote><p>证明（反证法）：</p><p>假设子问题不是最优解，对于情况 1，假设存在$(z_1’,z_2’ \cdots z_{j-1}’ , z_{j+1}’ ,\cdots z_k’)$ 是子问题的最优解，那么 $f_k(n)$的最优解将会是$(z_1’,z_2’ \cdots z_{j-1}’ , z_j , z_{j+1}’ \cdots z_k’)$，与假设矛盾。</p><a id="more"></a><h1 id="空间复杂度优化"><a href="#空间复杂度优化" class="headerlink" title="空间复杂度优化"></a>空间复杂度优化</h1><p>由于要使用$dp[n][v]$状态空间，如果储存全部状态，根据伪代码思路，该动态优化算法的时间和空间复杂度均为$O(VN)$，汽中时间复杂度应该已经不能再优化了，但空间复杂度却可以优化到$O(V)$。</p><p>我们观察状态转移方程</p><script type="math/tex; mode=display">F[i,v] = max \{ F[i-1,v] , F[i-1,v-C_i] + Value_i \}</script><p>我们每轮计算前$i$个在不同限重背包的最优值时，利用的状态只有$i-1$时的状态，也即上一轮外层循环得到的值，据此我们可以使用一些优化方法。</p><h2 id="滚动数组"><a href="#滚动数组" class="headerlink" title="滚动数组"></a>滚动数组</h2><p>每次都使用固定的几个存储空间，来达到压缩\节省存储空间的目的。主要应用在递推或动态规划中。</p><p>代码描述</p><pre><code class="hljs C++"><span class="hljs-keyword">for</span> (i=<span class="hljs-number">1</span> ;i &lt;= n; i++)&#123;    <span class="hljs-keyword">for</span> (v = w[i] ; v &lt;= V ; v++)    &#123;        dp[<span class="hljs-number">1</span>][v] = max(dp[<span class="hljs-number">0</span>][v],dp[<span class="hljs-number">0</span>][v-w[i]]+v[i]);    &#125;    <span class="hljs-comment">// 一轮更新结束后统一翻转</span>    <span class="hljs-keyword">for</span> (v = <span class="hljs-number">0</span>; v&lt;=V ; v++)&#123;        dp[<span class="hljs-number">0</span>][v] = dp[<span class="hljs-number">1</span>][v];    &#125;&#125;</code></pre><p>当然我们还发现状态转移方程中，只会利用背包限重状态小于等于要更新状态的已知状态，所以我们按逆序（从大到小）遍历内层循环，就可以避免在同一轮外层循环中先更新的影响后更新的值，由此修改滚动数组代码。</p><pre><code class="hljs C++"><span class="hljs-keyword">for</span> (i=<span class="hljs-number">1</span> ;i &lt;= n; i++)&#123;    <span class="hljs-keyword">for</span> (v = V ; v &gt;= w[i] ; v--)    &#123;        dp[<span class="hljs-number">1</span>][v] = max(dp[<span class="hljs-number">0</span>][v],dp[<span class="hljs-number">0</span>][v-w[i]]+v[i]);        dp[<span class="hljs-number">0</span>][v] = dp[<span class="hljs-number">1</span>][v];    &#125;&#125;</code></pre><h2 id="一维数组"><a href="#一维数组" class="headerlink" title="一维数组"></a>一维数组</h2><p>那既然逆序已经避免同一轮更新中先更新的影响后更新的值，实际上滚动数组也非必要了。我们使用一维数组便可实现状态转移，并且保证计算$dp[v]$时，$dp[v-w[i]]$保存的是对应二维$dp[i-1][v-w[i]]$的值。</p><pre><code class="hljs C++"><span class="hljs-keyword">for</span> (i=<span class="hljs-number">1</span> ;i &lt;= n; i++)&#123;    <span class="hljs-keyword">for</span> (v = V ; v &gt;= w[i] ; v--)    &#123;        dp[v] = max(dp[v],dp[v-w[i]]+v[i]);    &#125;&#125;</code></pre><h1 id="时间复杂度常数优化"><a href="#时间复杂度常数优化" class="headerlink" title="时间复杂度常数优化"></a>时间复杂度常数优化</h1><p>伪代码中</p><pre><code class="hljs C++"><span class="hljs-keyword">for</span> i ← <span class="hljs-number">1</span> to n    <span class="hljs-keyword">for</span> v ← V to w[i]</code></pre><p>原作者给出可以优化为$V \quad to \quad max(V − \sum_i^N C_i, C_i)$。我个人认为可以严格到$V \quad to \quad max(V - \sum_{i+1}^N C_i,C_i)$。</p><pre><code class="hljs C++">for i ← 1 to n    for v ← V to max(w[i],V-(w[i+1]+...+w[n]))</code></pre><p>背包九讲中没有对这一优化做阐述，我自己的理解是这样的：</p><p>再回过头来看状态转移方程。</p><script type="math/tex; mode=display">F[i,v] = max \{ F[i-1,v] , F[i-1,v-C_i] + Value_i \}</script><p>我们固定某一限重状态随$i$递增的变化，不妨研究与最终答案相关的，$final(i)= F[i][V]$。我们发现在$i$递增一轮过程中。$final$只会变动一次，且只有两个可能的方向，不变（延续$i$上一轮递增后得到的结果），改变（受$F[i-1][V-w[i]]$影响）。</p><p>如果我们将，可以影响$final$的所有限重状态，随$i$减小（逆序），画出来，我们可以发现能够影响到答案（最终状态）的边界是逐渐减小的。</p><p>我们可以发现，能够影响$final$的重量状态是有限的，并且随$i$减小，可影响的状态逐渐扩张，最后一次只有$final=dp[n][V]$单一状态影响最终答案（因为它本身就是最终答案），每一轮可能影响到$final$的边界应是，$max(V - \sum_{i+1}^N Value_i,C_i)$，这里可以补充一下，原作者认为是求和下限应为$i$，带入最后$i=N$我们发现在最后一轮除了更新$dp[N]$还更新了其他与最终答案无关的状态，所以我觉得这个更严格的界限是正确的。</p><p>反过来想也可以，在计算$dp[v]$时，若某一限重状态最终能够影响$final$，必然要经过几轮$i$递增（理想状态是，$dp[v+w[i+1]$每次都能受到影响），这也提醒我们，某一状态影响最终结果是需要一定时间限制的，在$i$逐渐靠近$n$时，即便我们遇到重量很小但是价值很大的一颗“金子”，我们也不一定需要从它的重量开始更新状态。</p><p>举例来讲比如最后三个物体是</p><pre><code class="hljs C++"><span class="hljs-comment">// n = 10   V = 50</span><span class="hljs-comment">// 当前dp[50]=150</span>w[n<span class="hljs-number">-2</span>]=<span class="hljs-number">2</span>  v[n<span class="hljs-number">-2</span>]=<span class="hljs-number">100</span> <span class="hljs-comment">//金子</span>w[n<span class="hljs-number">-1</span>]=<span class="hljs-number">5</span>  v[n<span class="hljs-number">-1</span>]=<span class="hljs-number">40</span>w[n]=<span class="hljs-number">3</span>    v[n]=<span class="hljs-number">50</span></code></pre><p>此时$w[i] = 2$,$V-sum=42$（按照底为$i+1$的求和）。如果只是为了获得正确的$dp[50]$，我们需要从$v=50$更新到$v=42$就够了呢？还是说要更新到$v=2$，显然，我们更新到$v=42$就够了，即便后面两个物体在最优解中都要取，$dp[42]$会影响下一轮的$dp[47]$，进而影响最终的$dp[50]$。</p><h1 id="Special-优化的代价"><a href="#Special-优化的代价" class="headerlink" title="Special 优化的代价"></a>Special 优化的代价</h1><blockquote><p>优化不是无代价的</p></blockquote><p>承上面例子，显然根据常数优化算法，我们最终可以得到正确的$dp[50]$，但我们在想，有没有少些什么？</p><p>很明显啊，在倒数第三轮外层循环我们没有计算新的$dp[2]$（而大概率碰到金子，2 格背包我们应该捡起来啊！），那么不更新的代价是什么呢？</p><p>针对题目，影响最终答案么？</p><p><strong>不影响</strong>。</p><p>不针对题目，影响答案么？</p><p><strong>影响</strong>，因为改变了状态空间解集。</p><h2 id="朴素二维动态规划得到的解集"><a href="#朴素二维动态规划得到的解集" class="headerlink" title="朴素二维动态规划得到的解集"></a>朴素二维动态规划得到的解集</h2><p>$dp[n][V]$储存了（在该遍历序下）<strong>任意小于序长度前缀，任意小于最大限制容量</strong>的解集。也即在不增删修改物品条件下，后续满足上述条件的任意询问$Q_1$，都可以在$O(1)$的时间给出答案。</p><h2 id="一维压缩空间优化得到的解集"><a href="#一维压缩空间优化得到的解集" class="headerlink" title="一维压缩空间优化得到的解集"></a>一维压缩空间优化得到的解集</h2><p>$dp[V]$储存了<strong>长度等于序长，任意小于最大限制容量</strong>的解集。同样，不改变物体，对该序询问容量小于限制的背包问题$Q_2$，都可以在$O(1)$的时间给出答案，但是如果想询问前缀问题（而非序长），则不能获得，<strong>因为在外层循环迭代中，没有保留这部分结果</strong>。</p><h2 id="空间优化-常数优化的解集"><a href="#空间优化-常数优化的解集" class="headerlink" title="空间优化+常数优化的解集"></a>空间优化+常数优化的解集</h2><p>只能保证$dp[i],i=V$单个值是正确的，而<strong>其他值均无意义</strong>。</p><p>这些发现很明显在提醒，如果关注单捷，那么空间+常数优化自然是很好的选择，但是如果数据固定而频繁询问，那么朴素方法或许才是最好的，优化不应该是盲目的，有些优化需要我们理解背后更深的意义及影响，才能更好的应用于我们程序中</p><p>本来这篇文章只想讨论这个内容，不过写着写着就补充了许多其他内容（<del>飘了</del>），希望和大家今后继续关注这些不该被忽略的小细节 hh。</p>]]></content>
    
    
    <categories>
      
      <category>Computer Science</category>
      
      <category>算法与数据结构</category>
      
    </categories>
    
    
    <tags>
      
      <tag>算法与数据结构</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>【洛谷-P2430】解题报告（01背包）</title>
    <link href="/post/a65b0def.html"/>
    <url>/post/a65b0def.html</url>
    
    <content type="html"><![CDATA[<h1 id="原始题目"><a href="#原始题目" class="headerlink" title="原始题目"></a>原始题目</h1><p><a href="https://www.luogu.com.cn/problem/P2430" target="_blank" rel="noopener">P2430 严酷的训练</a></p><h1 id="题目大意"><a href="#题目大意" class="headerlink" title="题目大意"></a>题目大意</h1><p>给定时间限制，每道问题耗费的时间以及奖励，求限制时间内最大奖励。</p><h1 id="解题思路"><a href="#解题思路" class="headerlink" title="解题思路"></a>解题思路</h1><p>将时间限制理解为背包容量，题目耗费的时间与其价值为装入背包物体的重量与价值，裸 01 背包问题。</p><a id="more"></a><h1 id="解题代码"><a href="#解题代码" class="headerlink" title="解题代码"></a>解题代码</h1><pre><code class="hljs C++"><span class="hljs-meta">#<span class="hljs-meta-keyword">include</span> <span class="hljs-meta-string">&lt;bits/stdc++.h&gt;</span></span><span class="hljs-keyword">using</span> <span class="hljs-keyword">namespace</span> <span class="hljs-built_in">std</span>;<span class="hljs-keyword">typedef</span> <span class="hljs-keyword">long</span> <span class="hljs-keyword">long</span> ll;<span class="hljs-keyword">typedef</span> <span class="hljs-keyword">unsigned</span> <span class="hljs-keyword">long</span> <span class="hljs-keyword">long</span> ull;<span class="hljs-keyword">typedef</span> pair&lt;<span class="hljs-keyword">int</span>, <span class="hljs-keyword">int</span>&gt; pii;<span class="hljs-keyword">typedef</span> <span class="hljs-built_in">vector</span>&lt;<span class="hljs-keyword">int</span>&gt; vi;<span class="hljs-meta">#<span class="hljs-meta-keyword">define</span> rep(i, a, n) for (int i = a; i &lt; n; ++i)</span><span class="hljs-meta">#<span class="hljs-meta-keyword">define</span> per(i, a, n) for (int i = n - 1; i &gt;= a; --i)</span><span class="hljs-meta">#<span class="hljs-meta-keyword">define</span> fi first</span><span class="hljs-meta">#<span class="hljs-meta-keyword">define</span> se second</span><span class="hljs-keyword">const</span> <span class="hljs-keyword">int</span> maxn = <span class="hljs-number">1e4</span> + <span class="hljs-number">5</span>;<span class="hljs-keyword">const</span> <span class="hljs-keyword">int</span> maxm = <span class="hljs-number">200</span>;<span class="hljs-keyword">int</span> a, b;<span class="hljs-keyword">int</span> mark[maxn];<span class="hljs-keyword">int</span> m, n, t;<span class="hljs-keyword">int</span> dp[maxn], v[maxn], w[maxn];<span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span>&#123;    ios::sync_with_stdio(<span class="hljs-literal">false</span>);    <span class="hljs-keyword">while</span> (<span class="hljs-built_in">cin</span> &gt;&gt; a &gt;&gt; b) &#123;        <span class="hljs-keyword">int</span> tt = b / a;        <span class="hljs-built_in">cin</span> &gt;&gt; m &gt;&gt; t;        rep(i, <span class="hljs-number">1</span>, t + <span class="hljs-number">1</span>)        &#123;            <span class="hljs-built_in">cin</span> &gt;&gt; mark[i];        &#125;        <span class="hljs-keyword">int</span> sum = <span class="hljs-number">0</span>;        w[<span class="hljs-number">0</span>] = <span class="hljs-number">0</span>;        rep(i, <span class="hljs-number">1</span>, m + <span class="hljs-number">1</span>)        &#123;            <span class="hljs-built_in">cin</span> &gt;&gt; w[i] &gt;&gt; v[i];            w[i] = mark[w[i]];            w[<span class="hljs-number">0</span>] += w[i];        &#125;        <span class="hljs-built_in">cin</span> &gt;&gt; n;        n /= tt;        <span class="hljs-comment">// cout &lt;&lt; "n= " &lt;&lt; n &lt;&lt; endl;</span>        <span class="hljs-built_in">memset</span>(dp, <span class="hljs-number">0</span>, <span class="hljs-keyword">sizeof</span>(dp));        rep(i, <span class="hljs-number">1</span>, m + <span class="hljs-number">1</span>)        &#123;            sum += w[i];            per(j, max(w[i], n - w[<span class="hljs-number">0</span>] + sum), n + <span class="hljs-number">1</span>)            &#123;                dp[j] = max(dp[j], dp[j - w[i]] + v[i]);            &#125;        &#125;        <span class="hljs-built_in">cout</span> &lt;&lt; dp[n] &lt;&lt; <span class="hljs-built_in">endl</span>;    &#125;&#125;</code></pre><h1 id="收获与反思"><a href="#收获与反思" class="headerlink" title="收获与反思"></a>收获与反思</h1><p>回顾此题目时对 0 1 背包的常数优化的原理及代价在另一篇博文中详细讨论</p>]]></content>
    
    
    <categories>
      
      <category>Computer Science</category>
      
      <category>ACM</category>
      
      <category>洛谷</category>
      
    </categories>
    
    
    <tags>
      
      <tag>ACM</tag>
      
      <tag>洛谷</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>多媒体原理与系统——音频wave文件</title>
    <link href="/post/32dcdd6d.html"/>
    <url>/post/32dcdd6d.html</url>
    
    <content type="html"><![CDATA[<h1 id="波形音频文件分析"><a href="#波形音频文件分析" class="headerlink" title="波形音频文件分析"></a>波形音频文件分析</h1><h2 id="波形音频文件概念"><a href="#波形音频文件概念" class="headerlink" title="波形音频文件概念"></a>波形音频文件概念</h2><p>波形音频文件是存储数字音频样本序列的格式文件，这些样本<strong>直接</strong>记录了音频的波形，故称为波形音频文件。MIDI、MP3等编码压缩过的音频文件最终都要转化成波形音频文件进行使用播放。</p><p>WAVE，使用最广泛，遵循RIFF格式标准。头四个字节是RIFF。WAVE文件由多个chunk组成。</p><h3 id="RIFF-Wave-Chunk部分"><a href="#RIFF-Wave-Chunk部分" class="headerlink" title="RIFF Wave Chunk部分"></a>RIFF Wave Chunk部分</h3><p>以RIFF作为开始表示，紧跟着size字段，最后是type字段位‘wave’。size是wav文件减去id和size占用的字节数。File字节-8=size。</p><h3 id="Format-Chunk部分"><a href="#Format-Chunk部分" class="headerlink" title="Format Chunk部分"></a>Format Chunk部分</h3><p>id补了一个空格，和其他chunk保持一致，都是4字节。</p><h3 id="Fact-Chunk部分"><a href="#Fact-Chunk部分" class="headerlink" title="Fact Chunk部分"></a>Fact Chunk部分</h3><p>可选字段，当wav文件从一些专用软件转化来时，包含该chunk。包括三部分，id、size、data，都为4字节大小。</p><h3 id="Data-Chunk部分"><a href="#Data-Chunk部分" class="headerlink" title="Data Chunk部分"></a>Data Chunk部分</h3><p>是真正保存wav数据的地方，以‘data’作为该chunk的标示。然后是数据大小，紧接着就是wav数据。</p><h1 id="实操PlaySound函数"><a href="#实操PlaySound函数" class="headerlink" title="实操PlaySound函数"></a>实操PlaySound函数</h1><p>使用内置，无需调用MF。</p>]]></content>
    
    
    <categories>
      
      <category>Computer Science</category>
      
      <category>多媒体原理与系统</category>
      
    </categories>
    
    
    <tags>
      
      <tag>多媒体原理与系统</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>我的人生解答书——职业规划</title>
    <link href="/post/454e4886.html"/>
    <url>/post/454e4886.html</url>
    
    <content type="html"><![CDATA[<h1 id="我的职业规划"><a href="#我的职业规划" class="headerlink" title="我的职业规划"></a>我的职业规划</h1><p>对于每个不以自由职业者（Self-employed）为最终目标的学生，<strong>职业规划</strong>是绕不过来的一环。大学三年我很多次在内心中问过自己这个问题，奈何总以“并非不想思考，只是时候未到”的幌子糊弄过去。那时我总觉得自身还处在对行业一无所知的情况下，毫无经验、技术、人脉的积累，再怎样细致思考，也都是自圆自说，没有价值。</p><p>现在，是时候给自己画一张完整的“职业规划”路线图了。</p><h2 id="我为什么选择计算机科学与技术专业"><a href="#我为什么选择计算机科学与技术专业" class="headerlink" title="我为什么选择计算机科学与技术专业"></a>我为什么选择计算机科学与技术专业</h2><p>要讲职业规划，我觉得不先讲专业选择都是耍流氓。假设一下，如果我现在所学的专业（计算机科学与技术）都不是我理想中想学的专业，那职业规划无论多好，都无法与我的兴趣相切合（这里排除那些无兴趣只以获取学习能力而读书的人）。兴趣是在一个行业耕耘的必要条件，没有兴趣，也就没有成就感与幸福感的获得。个人愚见，强行在一个不喜欢的行业中做职业规划，倒不如“规划”如何转行。</p><blockquote><p>“明白你是谁，成为你自己” —— 凯特•阿特金森《Life After Life》</p></blockquote><p>中国的教育体制和高校招生有不可否认的积极的一面，比如公平性、统一性，但在专业选择方面却仍存在巨大的改善空间。“高考前一无所知，高考后逼你选择”依旧是很多高考生不得不面临的现实，我生源自河北，在“环北京贫困带”光环的笼罩下，这种情况因教育资源匮乏、竞争压力巨大更显突出。我见过许多同龄人在高考过后的大学生活中，因最后选择的专业方向不符合自己的兴趣、意志，逐渐丧失前行的动力。</p><p>还好，我高中母校较为自由的学习环境让我提早了解到些专业方面的知识，父母也将高考志愿的最后选择权留给了我。我到现在都由衷地感谢他们——没有扯断我“成为自己”的翅膀。</p><p>回到专业选择这个问题本身，高中学习三个感兴趣的方向：金融、土木、计算机，这个兴趣来由不能解释，有点一见钟情的意思吧，那推动我做出最终选择的因素很明确，一是“想做出一些突破”，二是“不想靠父母”，下面我会进一步阐述这两个因素，如果您想直接看我的个人职业规划，请跳至下一节。</p><ul><li><p>“想做出一些突破”</p><p>高中的时候的老师给我们展示过一组图，我找不到原图了，就自己画了了一下。</p><p><img src="https://eddyblog.oss-cn-shenzhen.aliyuncs.com/DegreeDifference/DegreeDifference_1.png" srcset="/img/loading.gif" alt="Degree_1"></p><p><img src="https://eddyblog.oss-cn-shenzhen.aliyuncs.com/DegreeDifference/DegreeDifference_2.png" srcset="/img/loading.gif" alt="Degree_2"></p><p><img src="https://eddyblog.oss-cn-shenzhen.aliyuncs.com/DegreeDifference/DegreeDifference_3.png" srcset="/img/loading.gif" alt="Degree_3"></p><p><img src="https://eddyblog.oss-cn-shenzhen.aliyuncs.com/DegreeDifference/DegreeDifference_4.png" srcset="/img/loading.gif" alt="Degree_4"></p><p>这组图给我留下了很深刻的印象，或许它们并不能合适地描述所有专业的学习路径，但至少对我来说，我希望我日后的学习路径是这个样子的，并且渴望最终能达到最后一幅图的浅蓝色部分，那综合一下，符合这幅图的最理想的职业应具备下面的特征。</p><ul><li>特征 1. 需要具备一定领域内的知识储备</li><li>特征 2. 领域内有较多的突破空间</li><li>特征 3. 突破的方向是可确定的而非纯凭运气</li></ul><p>特征 1 让我排除了理学性质的基础学科。因为所需要的知识储备太过巨大，我了解自己的能力和优势，为基础学科做贡献是浪漫的，但我不适合。</p><p>特征 2 则让排除了金融和土木。前者的突破空间不太明晰，作为一个模型+经验构建起来的偏社科的学科，很多理论都仍有多个学派的争论，而且可能争到最后也是“信与不信”的区别，而非“对与不对”；后者的突破空间被大量前人构建起来的规范和先例限制住了，比起计算机等新型学科，人们畏于提出新的见解，对抗现有标准（少，并非没有）。这个专业的人们需要学习《有所不为的反叛者》中提到的“历史学家”的美德：<strong>批判</strong>、<strong>怀疑</strong>和<strong>想象力</strong>。</p><p>特征 3 则排除了一众理工科。不可否认人类历史上许多进步都是少数人在极低概率下机缘巧合摸索出的门路，但我实在无法忍受换比例炼丹法和撞大运式科研，比如探索新材料、构造蛋白质等等。我不否认其意义，甚至我还要为一些领域（实验物理、材料等）辩解，从算法的角度看他们科研的策略：有理论指导，那就启发式搜索；没有理论指导，那就暴力枚举。我认为这种策略不该被批评，在实验走在理论前面的学科，枚举是被迫的选择。但你问我想从事这个领域的研究么？我不想，我宁愿找一个理论和实验并肩前行的学科。</p><p>该批评的是那些不探索更高效策略与理论，只求枚举两种情况发 paper 的“科研”人员。</p></li><li><p>“不想靠父母”</p><p>当时选志愿的最后阶段，母亲总是建议我学自动化或者电气系统方面的专业，理由很简单：我父亲在国企电厂中工作。我当时很排斥她的这些话，因为我觉得这就是“走关系”，早该被视为糟粕、被时代抛弃的观念。</p><p>大一寒假回家，跟父亲一聊，我才发觉我只了解事情的一层。事实上，像电厂这样的国有控股企业，内部都有一套政策，每年都会要求企业内员工登记家庭内孩子的学业情况，作为“人才储备库”的资料。而当这个孩子有意进入相关企业时，其资料会从该储备库中调出，出于对内部资料的信任和多一份的了解，这个孩子相较于外界应聘者会多一层优势。所以有时这个途径不见得是我所排斥的那种“走关系”，而更像一些民营企业的“内部推荐”。</p><p>我理解父母的心情，但我还是不喜欢这个方向。强电弱电让我选其一，我还是希望能在弱电的世界里独自打拼。以电力系统为代表的强电方向内的企业不乏军人转业或者体制内高管空降，反观弱电那边，半导体行业、互联网公司的快速起步说明了白手起家和技术制胜的可能性。结合之前所说的我喜欢研究方向的三个特征，计算机还是略胜于自动化与电气。</p><p>最后推了我一把的就是 CS 专业的前辈——陈立杰，在清华特奖答辩中说的那句名言。</p><blockquote><p>“成为黄金时代大潮中的一朵浪花，为人类的智慧添砖加瓦。”</p></blockquote><p>毕业时看到，心里三个字：我也想。</p></li></ul><a id="more"></a><h2 id="我个人的职业规划"><a href="#我个人的职业规划" class="headerlink" title="我个人的职业规划"></a>我个人的职业规划</h2><p>大学前三年的学习，我尽最大努力接触了在中南 CS 专业可以接触到的各种学习途径，个人评价如下图所示。</p><p><img src="https://eddyblog.oss-cn-shenzhen.aliyuncs.com/DegreeDifference/MyWay_1.png" srcset="/img/loading.gif" alt="MyWay_1"></p><p>在高考后我确定了以后学习的专业，就像之前那个学历描述图中一样，我找到了一个平台。不过，我要采用什么样的“建造方式”，使用怎样的“材料”，搭建成怎样的“建筑”，我仍旧一无所知。</p><p>大学这三年的学习是知识积累的过程，也是不断试错的过程。对我而言，这是一份独一无二的宝贵财富。而我现在需要做的，就是分析这些经历，整理出较为客观的<strong>自身在该领域（专业）上的优势与劣势</strong>，据此<strong>梳理出适合我的职业发展路线</strong>，然后，再<strong>在此路线上进行合理规划</strong>，规划后<strong>定期检验并修正</strong>，行成<strong>正向推动的循环</strong>。</p><p><img src="https://eddyblog.oss-cn-shenzhen.aliyuncs.com/DegreeDifference/MyWay_2.png" srcset="/img/loading.gif" alt="MyWay_2"></p><h3 id="分析优劣势"><a href="#分析优劣势" class="headerlink" title="分析优劣势"></a>分析优劣势</h3><p>那结合前述学习途径中的感受，我分析自己目前的优势与劣势如下：</p><ul><li><p>优势</p><ul><li>对数理逻辑敏感，代数知识掌握较好。</li><li>喜欢了解计算机发展史，对一些方向憧憬且怀有神圣感。</li><li>不反感实验，尤其是可以反映原理的系统级大型实验。</li><li>不盲从热门，对密码学/系统/形式化语言兴趣浓厚</li><li>文理两不误，可以加入哲学思辨和对历史、社会现实的思考。</li></ul></li><li><p>劣势</p><ul><li>工业界框架了解少，框架源码阅读少</li><li>时间管理能力差，时间预期不够准确，容易赶 ddl</li><li>参与项目少，成功更少</li><li>主观感觉太强烈，缺少在用户/客户/第三方的视角</li><li>取舍能力差，面临多机会的时候难做决断</li></ul></li></ul><p>综合上述优劣势，我个人觉得自己不适合本科毕业后直接进入工作岗位。我应该在高校中对兴趣浓厚的方向做<code>One More Step</code>进一步的研究，同时，也需要利用一段时间来实习、或参与开源项目，来补足自己在项目推进上的短板。接下来我会梳理可能的职业发展路线，不过分叉后并不在当下，我希望将职业的选择权留给研究生毕业的自己。在研究生阶段的科研完成后，或是留在高校一步一步到获得教职，或是进入工业界在技术岗位上摸爬滚打。</p><h3 id="梳理职业发展路线"><a href="#梳理职业发展路线" class="headerlink" title="梳理职业发展路线"></a>梳理职业发展路线</h3><p>画出路线图前，我还需要再看一眼我的专业名称。</p><p>“计算机科学与技术”，拆解这个词，“计算机”是主体，“科学”与“技术”则是在主体上可探索的两个方向。在中南读本科阶段，我们对科学向的知识和技术向的知识一并吸取，因为它们都偏向计算机的基础部分，有相当大一部分是重叠甚至重复的。不过随着学历提高（甚至在本科学校中随学校层次的提高），这两者的边界会越来越清晰，从而发生称呼上的转变，科学向——“做科研”，技术向——“做（工程）项目”。</p><p>我总觉得惋惜的是，在中南的学习过程中，很多时候，“技术”被强调而“科学”却被忽视。举个简单例子，在数字图像处理学习过程中，老师要求我们学会应用 OpenCV 的图像处理函数，调用 DFT、IDFT 接口，以及学会用累积分布函数做转换函数实现直方图均衡化。但是，我们却不要求理解离散傅里叶变换的过程，以及为什么使用累积分布函数才可以实现均衡化。如果前者对于一些本科生（甚至研究生）来说过于过于晦涩，不必深究，可后者只是一个概率论中的简单原理：随机变量函数的概率密度分布，我们每个人都在概率论这门基础课程中学到过。还有在分布式课程中我们强调分布式应用，却不懂 Map Reduce、Raft 等概念。恰巧，我还是那个对“科学”部分的兴趣大于“技术”部分的孩子，这个现状还需我们的努力，下面是我 19 年 10 月和一位熟悉的老师的聊天记录，正如上面所说，我们不只做“技术”，还要懂“科学”。</p><p><img src="https://eddyblog.oss-cn-shenzhen.aliyuncs.com/DegreeDifference/MyWay_3.jpg" srcset="/img/loading.gif" alt="MyWay_3"></p><p>这两者本无高下之分，可能很多人走到科研的船头开始鄙视工业界不合乎逻辑的野蛮生长，在工业界呆久的人开始鄙视学院派的理论不落地。这是“职业病”，要改。这个领域想要发展，离不开学院与工业界的通力合作。在边界愈发明细的道路前方，我们反而需要不停地架设沟通这两段地桥梁。这些桥梁，不仅要多，还要快，甚至还要立体交叉。</p><p>根据前面的构想，我的基本路线如下图所示：</p><p><img src="https://eddyblog.oss-cn-shenzhen.aliyuncs.com/DegreeDifference/MyWay_4.png" srcset="/img/loading.gif" alt="MyWay_4"></p><p>当然这是一个 General 的路线图，并没有结合我前面分析地优劣势，也没有对高校教师招聘要求、企业的技术岗招频要求做调研。所以我先做了附件 1——互联网行业技术岗薪资情况调研，和附件 2——部分技术职位及其要求调研。下一节会在这个路线图上补充更加具体的细节。</p><h3 id="基于职业路线的学习规划"><a href="#基于职业路线的学习规划" class="headerlink" title="基于职业路线的学习规划"></a>基于职业路线的学习规划</h3><p>调研的结论其实并不那么理想，因为行业分工的细化导致每个岗位所需的能力不尽相同。不过我还是稍微梳理了下研究员岗位的一些共性，毕竟，这大概率是我理想中想去的地方。</p><ul><li>熟练掌握 Linux ，加深 Kernel 理解。</li><li>熟练掌握 1-2 门编程语言（golang、python、C/C++等），外加一门脚本语言</li><li>必要的文献学习能力，关注领域内前沿知识</li><li>深入好奇心和独立学习能力，愿意深入钻研技术原理。</li><li>熟悉常用 benchmark 和分析方法</li><li>有完整的项目开发经验</li><li>可对现有系统进行升级和优化</li><li><p>对于系统方向</p><ul><li>熟悉容器技术，以及开源资源调度方案</li><li>熟悉常用的中间件</li><li>熟悉大规模集群控制，分布式存储</li></ul></li><li><p>对于安全方向</p><ul><li>针对性掌握测试工具</li><li>针对性掌握漏洞模式及其利用技巧</li></ul></li></ul><p>结合前一小结分析的自身优劣势，我给自己定制的职业路线图如下</p><p><img src="https://eddyblog.oss-cn-shenzhen.aliyuncs.com/DegreeDifference/MyWay_5.png" srcset="/img/loading.gif" alt="MyWay_5"></p><h1 id="附件-1-互联网行业技术岗薪资情况"><a href="#附件-1-互联网行业技术岗薪资情况" class="headerlink" title="附件 1 互联网行业技术岗薪资情况"></a>附件 1 互联网行业技术岗薪资情况</h1><p>资料来源<a href="https://www.sohu.com/a/323276705_263537" target="_blank" rel="noopener">互联网公司职级、薪资、股权大揭秘（附 BAT、头条、华为薪资职级对比）</a>，<a href="https://www.v2ex.com/amp/t/430139" target="_blank" rel="noopener">V2EX 论坛</a>，<a href="https://www.dyhzdl.cn/k/doc/07f4c2f06529647d2628527c.html" target="_blank" rel="noopener">华为各级员工工资</a>，数值上可能有较大波动，只代表一家之言。</p><h2 id="阿里"><a href="#阿里" class="headerlink" title="阿里"></a>阿里</h2><p>阿里技术线校招从 P4 起，目前阿里需求量最大的职级范围分布在 P6-P8，这也是阿里集团占比最大的级别。P6 级别的程序员 title 是高级工程师，P7 便已经是专家级别，P8 则是高级专家。表格中展示的薪资可能略高。</p><p>牛客网：正常的本科、硕士都是 P5 起，职级上没有差别，最大也是升职快些，（一些面试官和内部员工解释）这是考虑录取后，但是考虑录取，本科竞争优势平均下来看弱于硕士（硕士相当于加了个保险，哎，这点上我还是不大赞同）。阿里星的评级是 P6，待遇是 P6+（有人说薪资不受评级限制。）。部分博士入职可能给 P6 评级。</p><p>某朋友的朋友：对于达摩院这种地方，能力很好的能进（不过听说，裁人先从达摩院开始裁，因为业务没啥产出）。校招都是从最低开始，除非进来评级很高（感觉这个意思就是评阿里星）？达摩院进来不是高职级（这是误区），所在的 BU2020 年一年才 3 个。</p><div class="table-container"><table><thead><tr><th>级别</th><th>职级名称</th><th>薪资（16 薪）</th><th>股票</th></tr></thead><tbody><tr><td>P4</td><td>初级工程师</td><td>10-20W?</td><td>几乎不授予</td></tr><tr><td>P5</td><td>中级工程师</td><td>20-30W?</td><td>几乎不授予</td></tr><tr><td>P6</td><td>高级工程师</td><td>40W</td><td>几乎不授予</td></tr><tr><td>P7</td><td>专家</td><td>50-70W</td><td>800-1200</td></tr><tr><td>P8</td><td>高级专家</td><td>70-100W</td><td>2000-2200</td></tr><tr><td>P9</td><td>资深专家</td><td>100-120W</td><td>6000-8000</td></tr><tr><td>P10</td><td>研究员</td><td>150W+</td><td>12000+</td></tr></tbody></table></div><h2 id="腾讯"><a href="#腾讯" class="headerlink" title="腾讯"></a>腾讯</h2><p>腾讯不久前刚刚宣布调整职级，取消了原有的 6 级 18 等（1.1-6.3 级）的职级体系设计，将专业职级体系优化为 14 级 (4-17 级)。至于薪资水平，主要参考和阿里平级来预测，但腾讯内部不同部门差别还是比较大的（比如腾讯游戏薪资高，腾讯云股票高）。</p><div class="table-container"><table><thead><tr><th>级别</th><th>职级名称</th><th>薪资 （16-18 薪）</th><th>股票</th></tr></thead><tbody><tr><td>4</td><td>4 级工程师</td><td>10-20W</td><td>?</td></tr><tr><td>5</td><td>5 级工程师</td><td>10-20W</td><td>?</td></tr><tr><td>6</td><td>6 级工程师</td><td>20-30W?</td><td>?</td></tr><tr><td>7</td><td>7 级工程师</td><td>20-30W?</td><td>?</td></tr><tr><td>8</td><td>8 级工程师</td><td>30-40W?</td><td>有</td></tr><tr><td>9</td><td>9 级工程师</td><td>50-60W</td><td>有</td></tr><tr><td>10</td><td>10 级工程师</td><td>60-80W</td><td>有</td></tr><tr><td>11</td><td>11 级工程师</td><td>80-100W</td><td>有</td></tr><tr><td>…</td><td>…</td><td>…</td><td>…</td></tr><tr><td>15</td><td>15 级工程师</td><td>600W-800W</td><td>有</td></tr></tbody></table></div><h2 id="百度"><a href="#百度" class="headerlink" title="百度"></a>百度</h2><p>感觉百度总是在走下坡路，资料仅供参考。百度技术线 T5、T6 占比最大。T10-T12 人数非常少，具有代表性的人物有前百度首席科学家吴恩达、百度最年轻 T10 楼天城（楼教）等。</p><div class="table-container"><table><thead><tr><th>级别</th><th>职级名称</th><th>薪资（14.6 薪）</th><th>股票（价值，每年折合）</th></tr></thead><tbody><tr><td>T4</td><td>中级工程师</td><td>15-30W</td><td>几乎不授予</td></tr><tr><td>T5</td><td>高级工程师</td><td>30-45W</td><td>几乎不授予</td></tr><tr><td>T6</td><td>资深工程师</td><td>40-60W</td><td>20-30W</td></tr><tr><td>T7</td><td>?</td><td>55-80W</td><td>40-60W</td></tr><tr><td>T8</td><td>?</td><td>75-100W</td><td>60-80W</td></tr><tr><td>T9</td><td>?</td><td>100-150W</td><td>100W+</td></tr></tbody></table></div><h2 id="华为"><a href="#华为" class="headerlink" title="华为"></a>华为</h2><blockquote><p>按华为《2015 年虚拟受限股分红预通知》，每股分红 1.95 元，升值 0.91 元，合计 2.86 元，工作五年基本可达十五级，饱和配股（包括 TUP）9 万股，分红 + 升值达 2.86*9 万 =25.74 万元，即使不饱和配股，基本分红也可以达到税前 20 万。工作 10 年，17 级配股普遍超过 20 万，税前分红 + 升值超过 50 万，而 23 级虚拟股票超过 200 万股，税前分红 + 升值超 500 万。（数据仅供参考）</p></blockquote><p>收入差异很大，如一个社招 18 级员工，进入华为以后前四年每年收入最多 35W（和下表差异很大，我该信谁?）。而一个土著 18 级，年收入最少百万（待确认），这个差距是股票和讲金造成的</p><p>按给定的档位给虚拟股做个插值，最后结果如下表。</p><div class="table-container"><table><thead><tr><th>级别</th><th>职级名称</th><th>薪资（每年总包）</th><th>虚拟股</th></tr></thead><tbody><tr><td>15</td><td>普通工程师 A</td><td>15-30W</td><td>无</td></tr><tr><td>16</td><td>高级工程师 B</td><td>40-60W</td><td>无</td></tr><tr><td>17</td><td>高级工程师 A</td><td>60-80W</td><td>跨度很大</td></tr><tr><td>18</td><td>主任工程师</td><td>100-180W</td><td>跨度很大</td></tr><tr><td>19</td><td>技术专家</td><td>180W+</td><td>跨度很大</td></tr></tbody></table></div><h2 id="新浪"><a href="#新浪" class="headerlink" title="新浪"></a>新浪</h2><p>消息来自一位认识的新浪推荐算法部门的 hr（调到技术部门下属），新浪技术部门走 L 职级，校招进来无论本科还是硕士基本都是 L0，区别在于晋升速度（基本没有例外）。L3-a 以上就是高职级了，L3-b 以上是核心员工。</p><div class="table-container"><table><thead><tr><th>级别</th><th>职位名称</th><th>薪资</th><th>股票期权</th></tr></thead><tbody><tr><td>L0</td><td>新入职工程师</td><td>15-25W</td><td>?</td></tr><tr><td>L1-a</td><td>?</td><td>?</td><td>?</td></tr><tr><td>L1-b</td><td>?</td><td>?</td><td>?</td></tr><tr><td>L2-a</td><td>?</td><td>?</td><td>?</td></tr><tr><td>L2-b</td><td>?</td><td>?</td><td>?</td></tr><tr><td>L3-a</td><td>高级工程师</td><td>?</td><td>?</td></tr><tr><td>L3-b</td><td>技术专家?</td><td>?</td><td>?</td></tr></tbody></table></div><h1 id="附件-2-部分技术职位及其要求"><a href="#附件-2-部分技术职位及其要求" class="headerlink" title="附件 2 部分技术职位及其要求"></a>附件 2 部分技术职位及其要求</h1><h2 id="高校教职要求"><a href="#高校教职要求" class="headerlink" title="高校教职要求"></a>高校教职要求</h2><h3 id="中南大学计算机院"><a href="#中南大学计算机院" class="headerlink" title="中南大学计算机院"></a>中南大学计算机院</h3><ul><li>学科领军人才<ul><li>50 岁以下</li><li>取得同行认可的重大科研成果</li><li>具有组织和主持国家科研项目、国际合作项目的能力</li><li>具有统筹学科发展规划，带领本学科赶超和保持国内外先进水平的能力</li></ul></li><li>青年拔尖人才<ul><li>40 岁以下</li><li>具有独立的科学研究能力和稳定的研究方向，学术思想活跃，有成为相关领域学术带头人的发展潜力。</li></ul></li><li>青年优秀人才<ul><li>38 岁以下（特聘教授 38 岁以下，特聘副教授 35 岁以下，讲师 32 岁以下（博士后放宽到 35 岁）），获得国内外高水平大学或科研院所博士学位，且第一学历为高水平大学全日制本科。</li></ul></li></ul><h2 id="企业技术岗"><a href="#企业技术岗" class="headerlink" title="企业技术岗"></a>企业技术岗</h2><p>由于以进入实验室为目标，企业普通技术管道的岗位待后续补充。</p><h2 id="企业实验室"><a href="#企业实验室" class="headerlink" title="企业实验室"></a>企业实验室</h2><h3 id="腾讯——科恩实验室"><a href="#腾讯——科恩实验室" class="headerlink" title="腾讯——科恩实验室"></a>腾讯——科恩实验室</h3><p>偏向终端安全</p><p>安全研究员 - Android/Linux 底层方向</p><ul><li>工作职责：<ul><li>Android 底层（系统服务/框架/内核）安全漏洞挖掘和分析</li><li>漏洞利用方式和技巧研究</li><li>防护机制的分析和研究</li></ul></li><li>职位要求：<ul><li>熟悉 IDA Pro 等常用二进制分析工具</li><li>熟练掌握 C 语言、熟悉 C++, Python</li><li>熟练掌握 arm/arm64 汇编及其体系架构</li><li>具有对 Android 底层安全漏洞成因、原理及利用方式的基本知识</li><li>有相关漏洞挖掘经验、实际利用代码作品或者 CTF 竞赛经验者优先</li></ul></li></ul><p>WEB&amp;APP 安全研究员 - 智能终端安全方向</p><ul><li>工作职责：<ul><li>对各种 IT 业务系统实施渗透测试</li><li>对 APP 和云端通信过程实施渗透测试</li><li>提出安全漏洞的修复方案和改进建议</li></ul></li><li>职位要求：<ul><li>熟悉渗透测试的步骤、方法、流程、实施方案</li><li>熟悉主机、网络、WEB 的渗透测试项目</li><li>熟悉各种主流测试工具(nmap\sqlmap\awvs 等)</li><li>熟悉 APP 和 WEB 端的各种常见漏洞类型，有独立发现漏洞能力</li></ul></li></ul><p>系统安全研究员 - 智能终端安全方向</p><ul><li>工作职责：<ul><li>负责智能终端设备的安全测试</li></ul></li><li>职位要求：<ul><li>熟悉 Android/Linux 系统原理及安全机制</li><li>较强的逆向分析能力，熟悉 ARM、x86/64 等指令集</li><li>熟练掌握各种安全工具，例如 IDA、GDB、JEB 等</li><li>了解智能硬件领域常见的漏洞模式及其利用技巧</li><li>熟悉至少一门脚本语言</li><li>懂 RTOS、固件分析等是加分项</li></ul></li></ul><h3 id="腾讯——AI-实验室"><a href="#腾讯——AI-实验室" class="headerlink" title="腾讯——AI 实验室"></a>腾讯——AI 实验室</h3><p>AI 后台开发工程师</p><ul><li>工作职责<ul><li>负责推荐引擎平台相关模块开发；</li><li>负责 NLP 平台相关模块开发；</li><li>负责机器学习/深度学习平台开发；</li><li>负责 AI 基础平台的组件开发、负责 AI 计算平台建设、负责 AI 游戏离线平台/AI 医疗离线平台建设。</li></ul></li></ul><p>机器翻译工程师</p><ul><li>工作职责<ul><li>调研及跟踪当前前沿的机器翻译相关算法发展方向及技术；</li><li>根据应用场景在超大规模语料下优化机器翻译算法性能；</li><li>优化机器翻译模型解码速度，满足上线要求。</li></ul></li></ul><p>反垃圾算法工程师</p><ul><li>工作职责<ul><li>主要负责文本数据的反垃圾算法研究，包括机器学习、文本语义理解、社群关系挖掘等技术；</li><li>在反垃圾任务上，负责对海量数据与实时热点进行分析，挖掘各类特征，利用机器学习、深度学习等技术识别潜在的作弊文本；</li><li>针对不同业务场景、不同的文本类型构建合适的算法模型。</li></ul></li></ul><p>搜索排序算法工程师</p><ul><li>工作职责<ul><li>主要负责搜索引擎排序算法的研究, 对相关性计算进行优化, 提升搜索质量；</li><li>具体方向包含复杂场景下的文本理解, 匹配模型, 多样性控制、文本相关等技术；</li><li>支持多种不同搜索场景下的需求, 能够设计相应的算法并落地实施。</li></ul></li></ul><p>OCR 算法工程师</p><ul><li>工作职责<ul><li>搭建基于图像特征/CNN 的图像/视频中的文字信息检测模型并优化；</li><li>搭建基于 CNN/LSTM 的中文、英文等多语种 OCR 识别模型并优化；</li><li>模型压缩及优化，提高算法速度，性能；</li><li>追踪前沿的文字检测/识别技术并复现，优化。</li></ul></li></ul><p>数据挖掘工程师</p><ul><li>工作职责<ul><li>负责安全产品相关系统中的数据统计，分析挖掘工作；</li><li>应用机器学习和数据挖掘等相关技术进行安全产品的数据建模；</li><li>通过用户行为数据建模、分析用户特征等，为业务决策提供参考。</li></ul></li></ul><p>下面是实习生</p><p>医疗 AI 实习生</p><ul><li>工作职责<ul><li>医疗影像算法开发，包含筛查、分类、分割、诊断、预测等。</li></ul></li><li>工作要求<ul><li>有计算机视觉，图像处理，机器学习领域经验；</li><li>熟悉深度学习，有深度学习解决计算机视觉问题的经验。有医学图像的项目经验优先；</li><li>熟悉 python 或 c/c++编程；</li><li>团队合作, 沟通能力佳；</li><li>计算机相关学科博士或硕士生。</li></ul></li></ul><p>语音识别/语音合成 实习生</p><ul><li>工作职责<ul><li>负责语音识别/合成方向的技术研发工作，包括但不限于语音前端处理、声学模型/语言模型的建立、语言解码、语音合成(TTS)等；</li><li>负责语音识别/合成方向前沿问题的探索与研究，结合未来实际应用场景，提供全面的技术解决方案。</li></ul></li><li>工作要求<ul><li>计算机、人工智能等相关专业的博士或硕士；</li><li>熟悉语音处理、对话系统和机器学习等领域，有相关的的项目或研究经验优先；</li><li>熟悉 python 或 c/c++编程及深度学习框架。</li></ul></li></ul><p>自然语言处理 实习生</p><ul><li>工作职责<ul><li>负责自然语言处理及语音方向的技术研发工作，包括但不限于词法分析、自动对话、语义挖掘和语言逻辑等；</li><li>负责自然语言处理及语音方向的前沿问题的探索与研究，结合未来实际应用场景，提供全面的技术解决方案。</li></ul></li><li>工作要求<ul><li>计算机、人工智能等相关专业的博士；</li><li>熟悉自然语言处理、对话系统和机器学习等领域，有相关的的项目或研究经验优先；</li><li>有良好的文献检索及前沿问题探索能力及创造力；</li><li>熟悉 python 或 c/c++编程及深度学习框架；</li><li>能保证至少 3 个月的实习时间。</li></ul></li></ul><h3 id="阿里——达摩院"><a href="#阿里——达摩院" class="headerlink" title="阿里——达摩院"></a>阿里——达摩院</h3><p>职位：</p><p>智能语音技术专家</p><p>如果你希望自己的工作在淘宝，支付宝，阿里云，天猫精灵这些大家都熟知的产品中，被中国和世界数以亿计的用户使用，你应该加入我们。</p><ul><li>岗位描述：<ul><li>负责包含语音识别、合成、声纹、自学习平台等在内的 AI 公共云&amp;专有云产品研发；</li><li>负责语音相关大规模分布式模型训练生产平台建设；</li><li>深入发掘和分析业务需求，撰写技术方案和系统设计、编写核心代码；</li><li>不断升级和优化系统，打造可定制、高性能、高可用、自动伸缩的开放云服务。</li></ul></li><li>岗位要求：<ul><li>具备扎实的计算机科学功底和出色的编程能力，熟悉常见算法和数据结构；</li><li>熟练掌握 C/C++/Java 任一语言，有完整的项目开发经验，具有良好的编程习惯；</li><li>熟悉分布式系统原理，熟悉计算机网络；</li><li>善于思考，能独立分析和解决问题；</li><li>具有人工智能相关行业背景和工作经验优先。</li></ul></li></ul><p>资源调度专家</p><ul><li>岗位描述：<ul><li>跟踪业界在异构混布系统进行自动运维和弹性计算资源管理的先进技术，并有效地结合到系统中，去支持业务的高速发展。</li><li>负责对自动运维、基础组件和弹性调度等技术开发，提升稳定性和成本优化无止境。</li><li>结合业界算法技术、虚拟化运维发布技术、故障隔离分析技术，不断优化自动运维和弹性计算系统的性能和效率。</li><li>结合公司内部和外部的业务需求，创新开拓，发展自动运维和弹性计算系统的前沿技术，给业务场景带来更多的想象空间。”</li></ul></li><li>岗位要求：<ul><li>深入了解混布系统和虚拟环境中的运维发布管理技术，对 docker 等容器技术熟悉，并有实际开发运作经验。</li><li>对开源的运维发布、弹性调度系统，例如 kubernetes，mesos 等，有深入了解或是实际使用经验。</li><li>熟练掌握 1-2 门编程语言（golang、python、C/C++等），有系统开发编程的经验。</li><li>熟悉 linux 环境， 对 Linux 虚拟环境有深入理解。 可以独立进行系统应用性能分析与优化。</li><li>对技术有深入好奇心和独立学习能力，愿意深入钻研技术原理。</li></ul></li><li>有以下一个或多个经验更佳：<ul><li>深入了解 GPU 计算的性能和优化。</li><li>对机器学习、深度学习有深入了解并有一定程度上的智能运维经验。</li></ul></li></ul><p>NLP 应用工程专家</p><p>待补充</p><p>New Memory System Architect</p><p>待补充</p><h3 id="阿里——平头哥"><a href="#阿里——平头哥" class="headerlink" title="阿里——平头哥"></a>阿里——平头哥</h3><p>团队描述：</p><p>你有机会和一流的芯片团队一起搭建高端芯片设计平台，参与新一代计算芯片的开发。</p><p>职位:</p><p>芯片架构师</p><ul><li>岗位描述：<ul><li>SOC 模块的架构和微架构</li><li>驱动全局的芯片特性(虚拟化等)</li><li>片上互连，高速缓存子系统和高速缓存一致性协议</li><li>芯片 RAS, 功耗, 安全管理</li><li>分析业务特点，推动软硬件协同设计</li><li>系统性能测试和竞争性分析.</li></ul></li><li>岗位要求：<ul><li>10 年以上芯片架构和设计经验.</li><li>软件编程能力（C/C++，python）</li><li>对一个和多个 SOC 模块架构有深度的理解.</li></ul></li><li>岗位加分：<ul><li>熟悉常用 benchmark 和分析方法.</li><li>熟悉大数据/云计算应用软件.</li><li>熟悉 Linux Kernel 和系统软件.</li></ul></li></ul><p>芯片设计专家</p><ul><li>岗位描述：<ul><li>定义微架构以及撰写详细的设计规范</li><li>编写 RTL 代码实现高性能的数字电路设计</li><li>与性能分析团队一起进行芯片性能改进</li><li>与设计验证团队一起制定验证测试计划，覆盖率分析，芯片仿真以及调试</li><li>负责物理设计团队进行模块的物理综合和设计</li></ul></li><li>岗位要求：<ul><li>Verilog/SystemVerilog RTL 设计能力</li><li>具有计算机体系结构知识.</li><li>具有物理综合，时序分析，时序收敛，形式验证，可测性设计等方面的经验</li></ul></li><li>岗位加分：<ul><li>有 ASIC 设计经验(学术或工业界), 经过一次完整的流片经验.</li><li>熟悉任一 CPU，GPU，DSP 或者 AI 加速器的硬件架构.</li><li>有微架构 PPA 调优经验.</li><li>熟悉脚本编程语言，譬如 Python 或者 Tcl</li></ul></li></ul><p>Web 工具开发专家</p><ul><li>岗位描述：<ul><li>正确理解需求, 高质量完成 Web 平台 和 Native 应用；</li><li>对公司自动化测试技术提供工具支持；</li><li>根据产品需求完成应用软件接口定义、功能设计，完成软件详细设计;</li><li>编写功能脚本，完成各项自动化任务；</li><li>设计和实现覆盖整个研发生命周期的工具和系统，如持续集成，代码发布，容量规划，系统监控等；</li><li>设计和维护我们的基础架构和服务，保障系统正常运行，提高研发效率；</li></ul></li><li>岗位要求：<ul><li>后端开发方向：</li><li>精通 Python、C++、Java、golang 中的至少一门语言；</li><li>精通 Python 主流框架 Django、Flask、tornado 或 Java 主流框架 SpringMVC 的一种或多种；</li><li>深入理解 linux 系统，熟悉 Nginx、Apache、Tomcat 等的工作原理，熟悉常用的中间件 （RabbitMQ、Memcached、Zookeeper、Etcd、Consul 等；</li><li>熟悉前端工程化与模块化开发，并有实践经验（ React / AuglarJS / Vue 等）；</li><li>熟悉 MongoDB、MySQL、Redis 等数据库，具备数据库运维能力；</li><li>熟悉 k8s 等容器集群技术；</li><li>熟悉异步框架、集群与负载均衡，消息中间件，容灾备份等技术；</li><li>对云服务和商业化支持有深入的理解；</li><li>前端开发方向：</li><li>熟练掌握各种前端技术，包括 HTML/CSS/JavaScript/Node.js 等</li><li>有全栈经验，涵盖以下领域任意多项：后端服务、Web、数据存储、数据分析</li><li>深入了解 JavaScript 语言，使用过 React 或 Vue.js 等主流开发框架</li><li>对用户体验、交互操作及用户需求分析等有一定了解</li><li>对云平台或开发者相关的产品有一定认识。</li><li>全栈开发工程师最佳</li></ul></li></ul><h3 id="阿里——AQL（量子实验室）"><a href="#阿里——AQL（量子实验室）" class="headerlink" title="阿里——AQL（量子实验室）"></a>阿里——AQL（量子实验室）</h3><p>团队介绍：</p><p>AQL’s mission is to realize the revolutionary potentials of quantum computing. Our interdisciplinary and international expert team is based in Hangzhou, China and Bellevue (WA), USA.</p><p>职位：</p><p>Quantum Scientist, Error Correction</p><ul><li>岗位描述：<ul><li>The goal of quantum error-correction is to realize logical qubits with minimum overhead and under hardware constraints. You will work together with a team of quantum error-correction experts to cover a diverse range of important topics, from empirical tools for finding codes and optimally implementing error-correction, to fundamental questions in the field.</li></ul></li><li>岗位要求：<ul><li>PhD degree with a focus on quantum error correction.</li><li>Strong research record.</li></ul></li></ul><p>待补充</p><h1 id="Offer-与薪资"><a href="#Offer-与薪资" class="headerlink" title="Offer 与薪资"></a>Offer 与薪资</h1><blockquote><p>hr 面会问你拿了几个 offer 了 或者主管面就会问 像我美团主管面就问我拿了几个 offer 了 然后 hr 面可能会谈薪资，你如果说拿了阿里 offer 他一般会提高价钱的，当然也是有限度的，会参考你在这个公司的面试评级，以及这个公司的容许范围。 如果 hr 面不谈就是意向书面谈，一般会来个电话跟你介绍一下福利待遇，谈一下薪资，这时候你如果不满意也可以拿着阿里这种公司的 offer 跟他谈。 再就是谈完薪资之后，你拿到阿里 offer 了，就可以联系 hr 来谈能不能涨一次。</p><p>看情况，基本如实说，但是不要讲那种明显比这个公司好的 offer。比如我快手 hr 面的时候问我多少 offer，以及哪些在走流程，我就没讲腾讯已经到三面了，只讲了我比较稳的那些。我觉得原则就是要有个限度，不要让人家觉得你已经拿到了他们给不了的好 offer，也不要让人家觉得你特别菜拿不到 offer，毕竟拿多少 offer 也是你能力的体现</p></blockquote>]]></content>
    
    
    <categories>
      
      <category>Life</category>
      
      <category>随笔</category>
      
    </categories>
    
    
    <tags>
      
      <tag>随笔</tag>
      
      <tag>职业规划</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>《文化商人——21世纪的出版业》读后感</title>
    <link href="/post/e9133a78.html"/>
    <url>/post/e9133a78.html</url>
    
    <content type="html"><![CDATA[<h1 id="略读体会"><a href="#略读体会" class="headerlink" title="略读体会"></a>略读体会</h1><p>以英美出版业为首的英语世界出版业的确与我所了解到的中国出版界大有不同。首先是分工的细化，或许是历史上对知识产权的重视，英美很早就有了著作代理人这样的角色，成为著作人和出版商之间的桥梁，这一角色是书本第二章主要介绍的内容。出版社，集团等概念也充分反映出整个行业的细化，而这些是我从未了解过的（或许也是因为我并不属于这个行业，对中国出版业了解不深）</p><p>读完之后顺便咨询了些文新院的同学，毕业以后做编辑，进入出版业的同学有多少？所有人的回答都是，不多。学姐A：“学长学姐以及他们这一届很少去当回复的”，学姐B：“应该有吧，但是我身边没有，实习有一些对口的岗位”，学姐C咨询了一下她的辅导员，回复说：“身边没有，整个年级数量也不多，差不多10来个人吧”。对比整个年级近200人的数量，也是非常小众的一部分人。而同届同学D则回复：“没有了解过，应该有的吧。我们大部分毕业了是去读研，很少是直接工作的。专业内想当老师的偏多，当然想去新媒体或者新闻行业的也有。” 像我所在层级的学校步入这个行业的都很少，也可以从一个侧面反映出我国出版业整体人才吸引力不足。</p>]]></content>
    
    
    <categories>
      
      <category>Life</category>
      
      <category>阅读</category>
      
    </categories>
    
    
    <tags>
      
      <tag>阅读</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>机器学习——复习大纲</title>
    <link href="/post/9626187a.html"/>
    <url>/post/9626187a.html</url>
    
    <content type="html"><![CDATA[<h1 id="题型"><a href="#题型" class="headerlink" title="题型"></a>题型</h1><ul><li>一定会考的：决策树，神经网络，过拟合，集成学习</li><li>ppt 提出的问题会以选择题形式考察</li><li>不会考数学推导和证明</li></ul><p>必须要带计算器！</p><p>12.31（周二）下午 4-5 点半。B206</p><h1 id="Chap1-基本概念"><a href="#Chap1-基本概念" class="headerlink" title="Chap1 基本概念"></a>Chap1 基本概念</h1><p>基本术语：属性，属性值，属性空间，训练样本，测试样本</p><p>监督学习与非监督学习</p><p>区别，给出一个问题确定是哪种问题类型。分类和回归，分类和聚类。 标签的问题。</p><p>李：</p><p><strong>！！线性判别分析，两类现行判别分析，内部方差，中心距离</strong><br><strong>！！如何求判别线</strong></p><h1 id="Chap2-线性模型"><a href="#Chap2-线性模型" class="headerlink" title="Chap2 线性模型"></a>Chap2 线性模型</h1><h2 id="归一化"><a href="#归一化" class="headerlink" title="归一化"></a>归一化</h2><ul><li>特征尺度归一化（确保特征在相同的尺度）</li><li>范围归一化：使得每个特征尽量接近某个范围，如$0 \le x_i \le 1$</li><li>零均值归一化：用$x_i - \mu_i$替代$x_i$，即$x_i - \mu_i \rightarrow x_i$，其中$\mu_i = \frac{1}{m} \sum_{i=1}^m x_i$</li><li>零均值+范围归一化，如$-0.5 \le x_i \le 0.5$</li><li>零均值单位方差归一化：$\frac{x_i - \mu_i}{\sigma_i} \rightarrow x_i$</li></ul><h2 id="机器学习三要素"><a href="#机器学习三要素" class="headerlink" title="机器学习三要素"></a>机器学习三要素</h2><ul><li>模型、策略、算法？</li><li>数据、模型、算法？哪个对</li></ul><h2 id="线性模型基本形式"><a href="#线性模型基本形式" class="headerlink" title="线性模型基本形式"></a>线性模型基本形式</h2><script type="math/tex; mode=display">f(x) = w^{T}x+b  = \theta^T x</script><p>两种表示，注意前式中带偏秩，但是并不表达在矩阵相乘中。</p><script type="math/tex; mode=display">J(\theta) = \frac{1}{2m} \sum_{i=1}^{m} (h_\theta (x^{(i)}) - y ^{(i)})^2</script><p>求解损失函数最小值，梯度下降方法为常见方法之一，梯度下降只能达到局部最优，凸函数可以达到全局最优。</p><ul><li>什么是线性关系、</li><li>一元线性回归，损失函数相关，最小化损失函数。</li><li>梯度下降法，梯度的方向。</li><li>欠拟合、过拟合。</li></ul><h3 id="学习率"><a href="#学习率" class="headerlink" title="学习率"></a>学习率</h3><ul><li><strong>怎样确保梯度下降算法正确的执行（收敛性）</strong><ul><li>自动收敛测试：每次迭代损失函数$J(\theta)$是否减少</li><li>收敛条件：定义不再进行迭代的收敛阈值（如$10^{-3}$）</li></ul></li><li><strong>怎样选择学习率$\alpha$</strong><ul><li>对于足够小的$\alpha$，$J(\theta)$应该在每一次迭代中减少</li><li>如果$\alpha$太小，梯度下降算法则会收敛很慢</li><li>如果$\alpha$太大，梯度下降算法则不会收敛：发散或震荡</li><li>用户可以以非常低的学习率开始训练模型，在每一次迭代过程中逐渐提高学习率（线性提高或者指数提高都可以），用户可以用这种方法估计出最佳学习率。</li></ul></li></ul><h2 id="改进方法"><a href="#改进方法" class="headerlink" title="改进方法"></a>改进方法</h2><ul><li>正规方程（The normal equations）<ul><li>对于求函数极小值问题，令函数微分为零，然后求解方程（而非每次对梯度递减）可得到解析解</li><li>西瓜数 P54 P55</li></ul></li></ul><p>现在使用的梯度下降为批量梯度下降（BGD），每次需要计算所有的样本（1-&gt;m），可以采用随机梯度下降（SGD）（随机选取一个样本，伪梯度下降）</p><h2 id="梯度下降的改进方法"><a href="#梯度下降的改进方法" class="headerlink" title="梯度下降的改进方法"></a>梯度下降的改进方法</h2><h3 id="动量法"><a href="#动量法" class="headerlink" title="动量法"></a>动量法</h3><p>动量法是一种非常简单的改进方法，已经成功应用数十年。动量法的核心思想是：在梯度方向一致的地方加速，在梯度方向不断改变的地方减速。</p><ul><li>在下降初期，使用前一次的大比重下降方向，加速。</li><li>在越过函数谷面时，异常的学习率，会使得两次更新方向基本相反，在原地“震荡” 此时，动量因子使得更新幅度减小，协助越过函数谷面。</li><li>在下降中后期，函数面局部最小值所在的吸引盆数量较多，一旦陷进吸引盆地当中，梯度趋于零，会导致止步不前，学习无法进行。如果有动量项的话，动量因子使得更新幅度增大，协助跃出吸引盆。</li></ul><p><img src="https://eddyblog.oss-cn-shenzhen.aliyuncs.com/MachineLearning/Review/Review_19.jpg" srcset="/img/loading.gif" alt="jpg"></p><h3 id="NAM"><a href="#NAM" class="headerlink" title="NAM"></a>NAM</h3><p>略</p><a id="more"></a><h1 id="Chap3-logistic-回归"><a href="#Chap3-logistic-回归" class="headerlink" title="Chap3 logistic 回归"></a>Chap3 logistic 回归</h1><p>分类问题，线性模型可以通过设置阈值来达成判别。阈值选择有一点困难，因为线性模型值域 R 太广，逻辑斯特回归则希望预测函数值限制在[0,1]，$0 \le h_{\theta} (x) \le 1$。</p><h2 id="Sigmoid-函数的性质"><a href="#Sigmoid-函数的性质" class="headerlink" title="Sigmoid 函数的性质"></a>Sigmoid 函数的性质</h2><script type="math/tex; mode=display">g(z) = \frac{1}{1+ e^{-z}}</script><script type="math/tex; mode=display">g'(z) = g(z) (1 - g(z))</script><h2 id="概率解释"><a href="#概率解释" class="headerlink" title="概率解释"></a>概率解释</h2><script type="math/tex; mode=display">P(Y = 1 | x) = h_\theta(x) = g(\theta^{T}x) = \frac{1}{1+e^{-\theta^Tx}}</script><p>输入 $x$ ，输出 $y=1$ 的可能性</p><p>物理含义：对比线性模型的平滑过度，logistic 回归在分界值前后变化剧烈，希望达到理想的二值 Sigmoid 的函数，但由于需要合适的损失函数求解 $\theta$ 参数矩阵，没有使用不连续的二值 Sigmoid 函数</p><h2 id="损失函数选择"><a href="#损失函数选择" class="headerlink" title="损失函数选择"></a>损失函数选择</h2><p>回顾凸函数，线性模型带入$h_\theta(x) = \theta^Tx$入平方损失函数$J(\theta) = \frac{1}{2m} \sum_{i=1}^{m} (h_\theta (x^{(i)}) - y ^{(i)})^2$，得到的是凸函数，也可解。</p><ul><li>凸函数<ul><li>等价于 $f’’(x) \ge 0 , \forall x$</li><li>若$x$ 为矢量，则对应的条件变为 Hessian 矩阵$H$为半正定矩阵</li></ul></li><li>严格凸（小于）<ul><li>对于矢量，则对应条件变为 Hessian 矩阵$H$正定</li></ul></li></ul><p><img src="https://eddyblog.oss-cn-shenzhen.aliyuncs.com/MachineLearning/Review/Review_1.jpg" srcset="/img/loading.gif" alt="jpg"></p><p>可以通过极大似然估计$\theta$，见西瓜书 P59</p><p><img src="https://eddyblog.oss-cn-shenzhen.aliyuncs.com/MachineLearning/Review/Review_2.jpg" srcset="/img/loading.gif" alt="jpg"></p><p><img src="https://eddyblog.oss-cn-shenzhen.aliyuncs.com/MachineLearning/Review/Review_3.jpg" srcset="/img/loading.gif" alt="jpg"></p><ul><li>交叉熵损失</li></ul><p>为什么选择交叉熵而不选择平方损失，平方损失求导中间多两项，在明确分类的两端下降率接近 0，</p><p><img src="https://eddyblog.oss-cn-shenzhen.aliyuncs.com/MachineLearning/Review/Review_4.jpg" srcset="/img/loading.gif" alt="jpg"></p><p><img src="https://eddyblog.oss-cn-shenzhen.aliyuncs.com/MachineLearning/Review/Review_5.jpg" srcset="/img/loading.gif" alt="jpg"></p><p><img src="https://eddyblog.oss-cn-shenzhen.aliyuncs.com/MachineLearning/Review/Review_6.jpg" srcset="/img/loading.gif" alt="jpg"></p><h1 id="Chap4-过拟合和正则化"><a href="#Chap4-过拟合和正则化" class="headerlink" title="Chap4 过拟合和正则化"></a>Chap4 过拟合和正则化</h1><h2 id="过拟合举例"><a href="#过拟合举例" class="headerlink" title="过拟合举例"></a>过拟合举例</h2><p><img src="https://eddyblog.oss-cn-shenzhen.aliyuncs.com/MachineLearning/Review/Review_7.jpg" srcset="/img/loading.gif" alt="jpg"></p><p><img src="https://eddyblog.oss-cn-shenzhen.aliyuncs.com/MachineLearning/Review/Review_8.jpg" srcset="/img/loading.gif" alt="jpg"></p><h2 id="为什么出现过拟合"><a href="#为什么出现过拟合" class="headerlink" title="为什么出现过拟合"></a>为什么出现过拟合</h2><ul><li>最小化训练集上的损失（损失错误）</li><li>一般而言，模型越复杂（阶数高或特征多），训练得到的模型经验错误越低，但却更容易出现过拟合</li><li>选择哪个模型更合适？随机分成两部分：训练集和验证集（Validation Set）</li><li>训练误差和验证误差</li></ul><h2 id="如何判断是否出现了过拟合或者欠拟合"><a href="#如何判断是否出现了过拟合或者欠拟合" class="headerlink" title="如何判断是否出现了过拟合或者欠拟合"></a>如何判断是否出现了过拟合或者欠拟合</h2><p>根据曲线判断，bias（偏差）和 variance（方差），会有 trade off（分界分离），选择靠近该分界点的模型，从而减小整体误差。</p><p><img src="https://eddyblog.oss-cn-shenzhen.aliyuncs.com/MachineLearning/Review/Review_9.jpg" srcset="/img/loading.gif" alt="jpg"></p><h2 id="如何解决过拟合或者欠拟合问题"><a href="#如何解决过拟合或者欠拟合问题" class="headerlink" title="如何解决过拟合或者欠拟合问题"></a>如何解决过拟合或者欠拟合问题</h2><ul><li>欠拟合（Large Bias）：增加模型的附加都<ul><li>收集新的特征</li><li>增加多项式组合特征</li></ul></li><li>过拟合（Large Variance）<ul><li>增加数据（有效但是实践意义不大）</li><li>降低模型的复杂度<ul><li>减小特征：特征选择</li><li>正则化（Regularization）：增加偏差</li></ul></li></ul></li></ul><h2 id="正则化"><a href="#正则化" class="headerlink" title="正则化"></a>正则化</h2><ul><li>$\lambda$：正则化参数</li><li>问题：思考正则化参数的取值范围</li></ul><script type="math/tex; mode=display">\lambda \sum_{j=1}^{n} \theta_j^2</script><h2 id="正则化线性回归"><a href="#正则化线性回归" class="headerlink" title="正则化线性回归"></a>正则化线性回归</h2><p><img src="https://eddyblog.oss-cn-shenzhen.aliyuncs.com/MachineLearning/Review/Review_10.jpg" srcset="/img/loading.gif" alt="jpg"></p><p><img src="https://eddyblog.oss-cn-shenzhen.aliyuncs.com/MachineLearning/Review/Review_11.jpg" srcset="/img/loading.gif" alt="jpg"></p><p><img src="https://eddyblog.oss-cn-shenzhen.aliyuncs.com/MachineLearning/Review/Review_12.jpg" srcset="/img/loading.gif" alt="jpg"></p><h2 id="正则化-Logistic-回归"><a href="#正则化-Logistic-回归" class="headerlink" title="正则化 Logistic 回归"></a>正则化 Logistic 回归</h2><p><img src="https://eddyblog.oss-cn-shenzhen.aliyuncs.com/MachineLearning/Review/Review_13.jpg" srcset="/img/loading.gif" alt="jpg"></p><p><img src="https://eddyblog.oss-cn-shenzhen.aliyuncs.com/MachineLearning/Review/Review_14.jpg" srcset="/img/loading.gif" alt="jpg"></p><h2 id="模型性能评估"><a href="#模型性能评估" class="headerlink" title="模型性能评估"></a>模型性能评估</h2><ul><li>我们用训练集优化参数$\theta^{*} = arg min \frac{1}{m} \sum_{i=1}^{m} l(h_{\theta}(x^{(i)}),y^{(i)})$</li><li>用验证集选择模型</li><li>但真正关心的是模型在新的测试数据的性能（泛化能力）</li><li>训练集：训练参数</li><li>验证集（开发集，Development set）：用于调参（正规化参数、多项式阶数等）、特征选择等</li><li>测试集：仅仅用于性能评估</li></ul><p><img src="https://eddyblog.oss-cn-shenzhen.aliyuncs.com/MachineLearning/Review/Review_15.jpg" srcset="/img/loading.gif" alt="jpg"></p><p><img src="https://eddyblog.oss-cn-shenzhen.aliyuncs.com/MachineLearning/Review/Review_16.jpg" srcset="/img/loading.gif" alt="jpg"></p><h2 id="Chap5-神经网络"><a href="#Chap5-神经网络" class="headerlink" title="Chap5 神经网络"></a>Chap5 神经网络</h2><h2 id="引入原因与神经结构"><a href="#引入原因与神经结构" class="headerlink" title="引入原因与神经结构"></a>引入原因与神经结构</h2><ul><li>类比人类的学习方式，The “one learning algorithm” hypotheis。人类的学习行为都是通过神经元结构完成。</li><li>神经元模型：Logistic unit</li></ul><p><img src="https://eddyblog.oss-cn-shenzhen.aliyuncs.com/MachineLearning/Review/Review_17.jpg" srcset="/img/loading.gif" alt="jpg"></p><h2 id="神经网络结构"><a href="#神经网络结构" class="headerlink" title="神经网络结构"></a>神经网络结构</h2><p><img src="https://eddyblog.oss-cn-shenzhen.aliyuncs.com/MachineLearning/Review/Review_18.jpg" srcset="/img/loading.gif" alt="jpg"></p><h2 id="前向传播"><a href="#前向传播" class="headerlink" title="前向传播"></a>前向传播</h2><p><img src="https://eddyblog.oss-cn-shenzhen.aliyuncs.com/MachineLearning/Review/Review_19.jpg" srcset="/img/loading.gif" alt="jpg"></p><p>梁:</p><ul><li><strong>为什么要引入神经网络</strong></li><li><strong>神经网络的结构</strong></li><li><strong>会算前向传播和 BP</strong></li><li><strong>多分类，softmax，交叉熵</strong></li><li><strong>掌握标准激活函数，特点</strong></li><li><strong>掌握各种方法更新梯度</strong></li><li><strong>为什么不能用 0 初始化权重矩阵</strong></li></ul><p>李：</p><p><strong>神经网络，损失函数，表达式！</strong></p><h1 id="Chap6-SVM"><a href="#Chap6-SVM" class="headerlink" title="Chap6 SVM"></a>Chap6 SVM</h1><h2 id="Margin"><a href="#Margin" class="headerlink" title="Margin"></a>Margin</h2><ul><li>对比 Logistic 回归：在测试新样本时，当$\theta^Tx \gg 0$，或者$\ll 0$，我们可以非常自信地给出预测</li><li>按实际训练中我们不能很好的找到一个参数矩阵使得$\theta^Tx \gg 0$，当$y^{i} = 1$时以及相反时候。</li><li><p>重新定义符号</p></li><li><p>（不要求掌握优化推导和 SMO）</p></li><li>什么是支持向量，margin，分类面</li><li>给数据，算方程、画超平面</li><li>kernel，可能会有大题</li><li>基本概念：<ul><li>主问题，对偶问题，惩罚因子（分别对应对应 hard/soft SVM 去掌握）</li></ul></li><li>调节 kernel 参数能够防止 SVM 出现过拟合嘛？</li></ul><p>李:</p><ul><li>支持向量、怎样求最优超平面</li><li>核函数相关。</li></ul><h1 id="Chap6-5-决策树"><a href="#Chap6-5-决策树" class="headerlink" title="Chap6.5 决策树"></a>Chap6.5 决策树</h1><h2 id="信息增益"><a href="#信息增益" class="headerlink" title="信息增益"></a>信息增益</h2><ul><li>Shannon 1948 年提出的信息论理论</li><li>熵：信息量大小的度量，即表示随机变量不确定性的度量</li><li>事件$a_i$的信息量$I(a_i)$可如下度量：$I(a_i) = -p(a_i)\log p(a_i)$</li><li>假设$n$个两两不相容事件$a_1,a_2, \cdots ,a_n$，它们中有且仅有一个发生，则平均的信息量（熵）可以如下度量： $I(a_1, \cdots , a_n) = \sum_i I(a_i) = -\sum_i p(a_i) \log p(a_i)$</li><li>假设当前样本集 D 中第$k$类样本的比例为$p_k$，对应的信息熵为</li></ul><script type="math/tex; mode=display">Ent(D) = - \sum_k p_k \log p_k</script><ul><li>$Ent(D)$<strong>越小</strong>。表示数据越有序，纯度越高（一类是 0），分类效果越好</li><li>假设某离散属性$a$有$V$个可能值，若采用该属性对样本集划分，则会产生 V 个分支，每个分支节点包含的数据记为$D^v$</li><li>用属性$a$对样本集$D$进行划分，获得的信息增益为：</li></ul><script type="math/tex; mode=display">Gain(D,a) = Ent(D) - \sum_v \frac{|D^v|}{D} Ent(D^v)</script><ul><li>选择具有最大信息增益的属性来划分： $a^* = arg \quad max_aGain(D,a)$ （ID3 算法）</li></ul><h2 id="信息增益比"><a href="#信息增益比" class="headerlink" title="信息增益比"></a>信息增益比</h2><ul><li>ID3 算法以信息增益为选择属性，对于取值较多的属性有所偏好（带编号的显然不适合）</li><li>信息增益比</li></ul><script type="math/tex; mode=display">Gain\_ratio(D,a) =  \frac{Gain(D,a) }{ IV(a)}</script><p>其中 IV 成为属性的固有值（intrinsic value），属性可取值越多，IV 通常越大。</p><script type="math/tex; mode=display">IV(a) = - \sum_{v=1}^V \frac{|D^v|}{|D|} \log \frac{ |D^v| }{|D|}</script><ul><li>增益率准则对可取值数目较少的属性有所偏好</li><li>C4.5 并不是直接选择增益率最大的候选划分属性，而是使用了一个启发式算法，先从划分属性中找出<strong>信息增益</strong>高于平均水平的属性，再从中选择<strong>信息增益率</strong>最高的属性 a。</li></ul><h2 id="基尼指数"><a href="#基尼指数" class="headerlink" title="基尼指数"></a>基尼指数</h2><ul><li>数据集的纯度用基尼值来衡量</li></ul><script type="math/tex; mode=display">Gini(D) = \sum_{k=1}^{|y|} \sum_{k' \not ={k}} p_k p_k' = 1 - \sum_{k=1}^{|y|} p_k^2</script><ul><li>直观来说，基尼值反映了从数据集$D$中随机抽取两个样本，其类别标记不一致的概率，因此基尼值越小，数据集纯度越高</li><li>属性 a 的基尼指数定义为</li></ul><script type="math/tex; mode=display">Gini\_index(D,a) = \sum_{v=1}^{V} \frac{D^v}{D}Gini(D^v)</script><ul><li>CART vs. ID3<ul><li>二元划分：二叉树不易产生数据碎片，精确度往往也会高于多叉树</li><li>属性选择不同</li></ul></li></ul><h2 id="剪枝"><a href="#剪枝" class="headerlink" title="剪枝"></a>剪枝</h2><p>决策树的剪枝减少决策树的规模（模型复杂度），是处理“过拟合”的主要手段</p><h3 id="前剪枝"><a href="#前剪枝" class="headerlink" title="前剪枝"></a>前剪枝</h3><p>见西瓜书 P81 给出的方法，将数据集划分为训练集、测试集，每一次选出最优划分属性后，对测试集做划分前后比对，划分后精度下降的禁止划分（图 4.5 图 4.6 以及下面的文字表述）。</p><p>预剪枝基于贪心禁止分支展开，带来一定欠拟合的风险。</p><h3 id="后剪枝"><a href="#后剪枝" class="headerlink" title="后剪枝"></a>后剪枝</h3><p>生成完整树后做替换检查，见 P83</p><h2 id="连续与缺失值处理"><a href="#连续与缺失值处理" class="headerlink" title="连续与缺失值处理"></a>连续与缺失值处理</h2><h3 id="连续属性处理"><a href="#连续属性处理" class="headerlink" title="连续属性处理"></a>连续属性处理</h3><ul><li>离散化，最简单的是二分法</li><li>本质是连续的，但是对于有限采样数据是离散的</li><li>对于离散区间中取任意值产生的划分结果相同</li><li>对于包含$n-1$个元素的候选划分点集合</li></ul><script type="math/tex; mode=display">T_a = \{ \frac{a^i + a^{i+1}}{2}  |  1 \le i \le n-1 \}</script><ul><li>即把区间$[a^i,a^{i+1}]$的中位点作为候选划分点</li><li>处理时对多属性需要多一轮枚举循环，找到划分后纯度更高的划分点</li><li>CART 则将这些划分点当成多离散值处理，见后面。</li></ul><h3 id="CART-属性取值离散超过两种的处理"><a href="#CART-属性取值离散超过两种的处理" class="headerlink" title="CART 属性取值离散超过两种的处理"></a>CART 属性取值离散超过两种的处理</h3><ul><li>组合的方式转化成多个二取值问题（类似 OvR），取其中划分后 Gini_index，最小的二分情况</li></ul><h2 id="Chap7-集成学习"><a href="#Chap7-集成学习" class="headerlink" title="Chap7 集成学习"></a>Chap7 集成学习</h2><ul><li>构建多个学习器一起来结合来完成具体地学习任务</li><li>也成为多分类器系统</li><li>学习器可以是同类型地，也可以是不同类型</li><li>通过将多个学习器进行结合，常可获得比单一学习器显著优越地泛化性能，对“弱学习器”尤为明显</li><li>理论分析指出：假设<strong>各分类器地错误率相互独立</strong>，则随着集成个体分类器数目增大，集成的错误率将指数级下降</li><li>现实中个体学习器是为解决同一个问题训练出来的，不可能相互独立</li><li>如何产生并结合“好而不同”的个体学习器是集成学习研究的核心。</li></ul><h2 id="集成学习分类"><a href="#集成学习分类" class="headerlink" title="集成学习分类"></a>集成学习分类</h2><ul><li>个体学习器间存在强依赖关系，必须串行生成的序列化方法。代表：Boosting（AdaBoost，Gradient Boosting Machine）</li><li>个体学习器间不存在强依赖关系，可同时生成的并行化方法。代表：Bagging 和随机森林（Random Forest）</li></ul><h2 id="AdaBoost"><a href="#AdaBoost" class="headerlink" title="AdaBoost"></a>AdaBoost</h2><p><strong>李重点</strong></p><p><img src="https://eddyblog.oss-cn-shenzhen.aliyuncs.com/MachineLearning/Review/Review_21.jpg" srcset="/img/loading.gif" alt="jpg"></p><p><img src="https://eddyblog.oss-cn-shenzhen.aliyuncs.com/MachineLearning/Review/Review_22.jpg" srcset="/img/loading.gif" alt="jpg"></p><h2 id="GBDT"><a href="#GBDT" class="headerlink" title="GBDT"></a>GBDT</h2><p>略</p><h2 id="Bagging"><a href="#Bagging" class="headerlink" title="Bagging"></a>Bagging</h2><p><img src="https://eddyblog.oss-cn-shenzhen.aliyuncs.com/MachineLearning/Review/Review_23.jpg" srcset="/img/loading.gif" alt="jpg"></p><p><img src="https://eddyblog.oss-cn-shenzhen.aliyuncs.com/MachineLearning/Review/Review_24.jpg" srcset="/img/loading.gif" alt="jpg"></p><h2 id="随机森林（Random-Forest）"><a href="#随机森林（Random-Forest）" class="headerlink" title="随机森林（Random Forest）"></a>随机森林（Random Forest）</h2><p><img src="https://eddyblog.oss-cn-shenzhen.aliyuncs.com/MachineLearning/Review/Review_25.jpg" srcset="/img/loading.gif" alt="jpg"></p><h2 id="决策融合策略"><a href="#决策融合策略" class="headerlink" title="决策融合策略"></a>决策融合策略</h2><ul><li>平均法</li><li>加权平均法</li><li>投票法<ul><li>绝对大多数投票（Majority Voting）：超过半数，则决策，否则拒绝</li><li>少数服从多数（Plurality Voting）：得票最多的标记</li></ul></li><li>学习法<ul><li>用各学习器的输出生成新的训练数据，再去训练一个学习器（如线性 SVM 等）</li></ul></li></ul><h1 id="Chap8-聚类"><a href="#Chap8-聚类" class="headerlink" title="Chap8 聚类"></a>Chap8 聚类</h1><p>梁：</p><ul><li>GMM 不考</li><li>k-means 一定考</li><li>高斯分布和贝叶斯系列（10’）</li></ul><p>李：</p><ul><li>K-means</li><li>以及初始类簇中心点的确认</li></ul><h1 id="Chap9-降维"><a href="#Chap9-降维" class="headerlink" title="Chap9 降维"></a>Chap9 降维</h1><ul><li>（流形学习不考）</li><li>PCA/LDA 考其一</li></ul><h1 id="Chap10-应用"><a href="#Chap10-应用" class="headerlink" title="Chap10 应用"></a>Chap10 应用</h1><ul><li>各种评价指标：精度等，一级二级指标</li><li>混淆矩阵</li><li>ROC 曲线。Kappa 系数，AUC 值</li></ul><h2 id="多分类学习"><a href="#多分类学习" class="headerlink" title="多分类学习"></a>多分类学习</h2><p>多分类学习的拆解：OvO，OvR，MvM。投票机制，拆解原则。 海明距离、欧式距离。</p><p>混淆矩阵，一些指标的计算，</p><p>欠拟合的改良方法</p><h2 id="贝叶斯"><a href="#贝叶斯" class="headerlink" title="贝叶斯"></a>贝叶斯</h2><p>回顾概率公式，全概率公式，先验概率、后验概率</p>]]></content>
    
    
    <categories>
      
      <category>Computer Science</category>
      
      <category>机器学习</category>
      
    </categories>
    
    
    <tags>
      
      <tag>机器学习</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>Linux操作系统——Linux复习</title>
    <link href="/post/68340cec.html"/>
    <url>/post/68340cec.html</url>
    
    <content type="html"><![CDATA[<h1 id="Linux-重点复习题"><a href="#Linux-重点复习题" class="headerlink" title="Linux 重点复习题"></a>Linux 重点复习题</h1><h2 id="选择-填空题"><a href="#选择-填空题" class="headerlink" title="选择/填空题"></a>选择/填空题</h2><ol><li>当系统工作负载增加时，CPU 的（<strong>用户时间</strong>）将占很大比重</li><li>fsck 对文件系统的检查最先是从文件系统的（<strong>超级块</strong>）开始的。</li><li>系统交换分区的类型代号是（<strong>82</strong>）</li><li>为了得到外壳程序中命令行输入参数个数，我们可以使用变量（<strong>$#</strong>）</li><li>为了得到所有的命令行输入的参数，我们可以使用变量（<strong>$@</strong>）</li><li>Linux 启动的第一个进程 init 启动的第一个第一个脚本程序是（<strong>/etc/rc.d/rc.sysinit</strong>）</li><li>LILO 的配置文件是（<strong>/etc/lilo.conf</strong>）</li><li>哪一个命令能用来删除当前目录及其子目录下名为‘core’的文件（<strong>find . -name core -exec rm {} \ -</strong>）</li><li>所谓 LILO（LinuxLoader）是指（<strong>一种安装内核加载，开机管理的程序</strong>）</li><li>分区表示（hd 表示 IDE 硬盘，sd 表示 SCSI 硬盘，a 表示第一块硬盘，1-4 都是主分区）</li><li>为了知道谁正在注册到你的机器上可以使用命令（<strong>who</strong>）</li><li>通过文件名存取文件时，文件系统内部的操作过程是通过（<strong>文件名在目录中查找对应的 i 节点，通过 i 节点存取文件数据</strong>）（补充：创建文件时最后一步， 文件名和 i-节点号之间的对应关系将文件名和文件和文件的内容属性连接起来，找到文件名就找到文件的 i-节点号，通过 i-节点号就能找到文件的属性和内容。）</li><li>Linux 的核心代码存放于（****/usr/src/linux）</li><li>一个进程调用 fork 系统调用后，会有什么结果（<strong>‌</strong>）（补充：fork 函数将运行着的程序分成 2 个（几乎）完全一样的进程，每个进程都启动一个从代码的同一位置开始执行的线程。这两个进程中的线程继续执行，就像是两个用户同时启动了该应用程序的两个副本。）</li><li>文件系统中的（<strong>超级块</strong>）主要用来记录整个逻辑文件系统的基本管理信息。</li><li>通过 Makefile 来安装已编译过的代码的命令是（<strong>make install</strong>）（补充：configure 是用来生成 Makefile，make 用来编译，make install 用来进行安装）。</li><li>（<strong>lsmod</strong>）命令显示所有装在的模块</li><li>下面关于 inode 节点描述错误的是（<strong>i 节点和文件名是一一对应的</strong>）。（补充：其他正确的说法，i 节点能描述文件占用的块数，i 节点描述了文件大小和指向数据块的指针、通过 i 节点实现稳健的逻辑结构和物理结构的转换。inode 索引节点内容包括：文件的字节数、文件拥有者的 User ID、文件的读 rwx 权限、文件的时间戳、链接数：指多少个文件名指向这个 inode 硬链接会改变、文件数据 block 的位置）</li><li>“.Z”后缀是（<strong>compress</strong>）命令压缩的，用（<strong>uncompress</strong>）解压。</li><li>已知 Linux 系统中的唯一一块硬盘是第一个 IDE 接口的 master 设备，该硬盘按顺序有 3 个主分区和 1 个扩展分区，这个扩展分区又划分了 3 个逻辑分区，则该硬盘上的第二个逻辑分区在 Linux 中的设备名称为（<strong>/dev/hda6</strong>）（补充：在 linux 中第一块硬盘分区为 hda 分区，主分区编号为 hda1-4，逻辑分区从 5 开始。）</li><li>Redhat Linux 系统中，所有文件系统的挂载信息存放在（<strong>/etc/fstab</strong>）中。（补充：系统开机时会主动读取/etc/fstab 这个文件中的内容，根据文件里面的配置挂载磁盘。这样我们只需要将磁盘的挂载信息写入这个文件中我们就不需要每次开机启动之后手动进行挂载了。）</li><li>系统当前已经加载的所有文件系统在（<strong>/etc/mtab</strong>）文件中得到反映。（补充：/etc/fstab 开机自动挂载配置文件，在开机时起作用。/etc/mtab 是当前的分区挂载情况，记录的是当前系统已挂载的分区，每次挂载/卸载分区的时候会更新/etc/mtab）</li><li>以下哪个运行级别是管理用的单用户模式（<strong>1 为单用户模式</strong>）（补充：0 为停机模式，6 为重启模式）</li><li>如何显示 Linux 系统中注册的用户数（<strong>wc- -lines /etc/passwd</strong>）</li><li>在使用 mkdir 命令创建新的目录时，在其父目录不存在时先创建父目录的选项是（<strong>-p</strong>）</li><li>Linux 允许一个文件名有 256 个字符，但为了保证兼容性和可移植性，建议文件名长度控制在（<strong>14</strong>）个字符以内</li><li>比较重要的系统配置资料，一般来说大部分位于（<strong>/etc</strong>）目录下</li><li>大部分主要的 Linux 系统文件是存放在下面的（<strong>/bin</strong>）目录中</li><li>（<strong>du</strong>）命令用来显示文件盒目录占用的磁盘空间</li><li>（<strong>df</strong>）命令用来显示已安装的文件系统占用的磁盘空间</li></ol><h2 id="简答题"><a href="#简答题" class="headerlink" title="简答题"></a>简答题</h2><ol><li><p>简述 Linux 下虚拟文件系统的作用</p><p>Linux 通过虚拟文件系统 VFS 将不同文件系统的实现细节隐藏起来，因而从外部看上去，所有的文件系统都是一样的。</p><p>VFS 是建在具体文件系统之上的，它为用户程序提供一个统一、抽象、虚拟的文件系统界面。这个抽象的界面主要由一组标准、抽象的文件操作构成，以系统调用的形式提供给用户程序。所以 VFS 必须管理所有同时安装的文件系统。它通过使用描述整个 VFS 的数据结构和描述实际安装的文件系统的数据结构来管理这些不同的文件系统。</p></li><li><p>简述 Linux 下软连接和硬连接实现文件共享的区别。</p><p>硬链接记录的是目标的 inode，符号链接记录的是目标的 path。硬链接创建的是指向 inode 的指针，成功后，文件的索引数会加一，而软链接就像快捷方式，并不会导致该变化。符号链接可以跨分区 link，而硬链接由于 inode 的缘故，只能在本分区中做 link，所以符号链接的使用频率要高得多。</p></li><li><p>简述 Linux 的用户模式</p><ul><li>0： 系统停机（关机）模式，系统默认运行级别不能设置为 0，否则不能正常启动，一开机就自动关机。</li><li>1: 单用户模式，root 权限，用于系统维护，禁止远程登陆，就像 Windows 下的安全模式登录。</li><li>2: 多用户模式，没有 NFS 网络支持。</li><li>3: 完整的多用户文本模式，有 NFS，登陆后进入控制台命令行模式。</li><li>4: 系统未使用，保留一般不用，在一些特殊情况下可以用它来做一些事情。例如在笔记本电脑的电池用尽时，可以切换到这个模式来做一些设置。</li><li>5: 图形化模式，登陆后进入图形 GUI 模式或 GNOME、KDE 图形化界面，如 X Window 系统。</li><li>6: 重启模式，默认运行级别不能设为 6，否则不能正常启动，就会一直开机重启开机重启。</li></ul></li><li><p>简述动态优先级多级反馈循环调度算法思想及优缺点</p><p>简述: 动态优先级是指系统根据优先级 Priority 顺序分配时间片，但优先级会随着进程运行改变。</p><ol><li>系统先计算每个进程的一个优先权，该优先权反映了一个进程获取 CPU 使用权的资格</li><li>系统从处于就绪队列（状态）的进程中选择优先权最高的进程，分配时间片进入运行态。</li><li>运行过程中，优先权随时间递减。</li><li>进程时间片结束或进程运行完毕，系统动态完成一次对当前进程优先级的计算</li><li>再次进行进程调度，从处于就绪队列（状态）的进程中在选出最高优先级的进程，设置调度标志。</li><li>把那些被抢夺了占有权的进程反馈大优先级队列中，等待下一轮调度（对于抢占式而言）</li></ol><p>优点: 相较于固定优先级，减少了对低优先级的歧视，更有可能被调度。</p><p>缺点：对于高优先级的实时任务随着 CPU 占用时间增大优先级降低，对紧急任务不能保证率先完成。</p></li><li><p>Linux 进程间通信主要有哪几种形式</p><p>最常用的方式是信号、管道以及 UNIX 系统支持的 System Ⅴ IPC 机制（即消息通信、共享数据段和信号量）</p><ol><li><p>管道（Pipe）：管道可用于具有亲缘关系进程间的通信，允许一个进程和另一个与它有共同祖先的进程之间进行通信。</p></li><li><p>命名管道（named pipe）:命名管道克服了管道没有名字的限制，因此，除具有管道所具有的功能外，它还允许无亲缘关系进程间的通信。命名管道在文件系统中有对应的文件名。命名管道通过命令 mkfifo 或系统调用 mkfifo 来创建</p></li><li><p>信号（Signal）：信号是比较复杂的通信方式，用于通知接受进程有某种事件发生，除了用于进程间通信外，进程还可以发送信号给进程本身；linux 除了支持 Unix 早期信号语义函数 sigal 外，还支持语义符合 Posix.1 标准的信号函数 sigaction(实际上，该函数是基于 BSD 的，BSD 为了实现可靠信号机制，又能够统一对外接口，用 sigaction 函数重新实现了 signal 函数).</p></li><li><p>消息（Message）队列：消息队列是消息的链接表，包括 Posix 消息队列 System V 消息队列。有足够权限的进程可以向队列中添加消息，被赋予读权限的进程则可以读走队列中的消息。消息队列克服了信号承载信息量少，管道只能承载无格式字节流以及缓冲区大小受限等缺点。</p></li><li><p>共享内存：使得多个进程可以访问同一块内存空间，是最快的可用 IPC 形式。是针对其他通信机制运行效率低而设计的。往往与其他通信机制，如信号量结合使用，来达到进程间的同步互斥。</p></li><li><p>信号量（semaphore）：主要作为进程间以及同一个进程不同线程之间的同步手段。</p></li><li><p>套接字（Socket）：更为一般的进程间通信机制，可用于不同机器之间的进程间通信。起初是由 Unix 系统的 BSD 分支开发出来的，但现在一般可以移植到其它类 Unix 系统上：Linux 和 System V 的变种都支持套接字。</p></li></ol></li><li><p>简要说明面向连接和无连接两种网间进程通信方式的主要区别。</p><p>面向连接的协议，再正式手法数据前，双方必须建立可靠的连接。连接的建立要经历三次“握手”才能建立起来，建立后通信比较稳定。</p><p>面向非连接的协议，不与对方建立连接，而是直接就把数据包发送过去。</p></li></ol><h2 id="程序设计题"><a href="#程序设计题" class="headerlink" title="程序设计题"></a>程序设计题</h2><ol><li><p>定时任务</p><p>定时任务中的时间的说明，时间的格式大概是这样的* * * * * 五个 *号代表的意思分别是分，时，日，月，周的顺序来排列的</p><p>如果想每分钟都执行一次的话就采用默认的 * * * * *，如果想每五分钟执行一次可以 */5 * * * * ，如果是每两个小时执行一次的话那就是 * */2 * * *来设置;</p><p>/n 表示每 n-m 表示区间</p><p>解决方案：</p><p>crontab -e ，输入 i 添加新的定时任务。</p></li></ol>]]></content>
    
    
    <categories>
      
      <category>Computer Science</category>
      
      <category>操作系统</category>
      
    </categories>
    
    
    <tags>
      
      <tag>操作系统</tag>
      
      <tag>Linux</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>数字图像处理——章节总复习</title>
    <link href="/post/572ecb4f.html"/>
    <url>/post/572ecb4f.html</url>
    
    <content type="html"><![CDATA[<h1 id="数字图像基础"><a href="#数字图像基础" class="headerlink" title="数字图像基础"></a>数字图像基础</h1><p>对应梁老师课件第二章，着重掌握基本概念。</p><h2 id="图像的获取"><a href="#图像的获取" class="headerlink" title="图像的获取"></a>图像的获取</h2><p>略</p><h2 id="图像的采样与量化"><a href="#图像的采样与量化" class="headerlink" title="图像的采样与量化"></a>图像的采样与量化</h2><ul><li>大多数传感器的输出是连续电压波形</li><li>为了产生一幅数字图像，需要把连续的感知数据转化为数字形式</li><li>这包括两种处理：采样和量化</li></ul><h3 id="采样"><a href="#采样" class="headerlink" title="采样"></a>采样</h3><ul><li>图像空间坐标的数字化（离散化）</li><li>决定了图像的空间分辨率</li><li>行采样像素$M$个，列采样$N$个构成$M \times N$的实数矩阵</li><li>为编程方便采用矩阵坐标系</li><li><img src="https://eddyblog.oss-cn-shenzhen.aliyuncs.com/ImageProcess/Review/Review_1.JPG" srcset="/img/loading.gif" alt="1"></li></ul><h3 id="量化"><a href="#量化" class="headerlink" title="量化"></a>量化</h3><ul><li>图像像素灰度值的数字化（离散化）</li><li>从模拟量到数字量（离散量）</li><li>决定了图像的幅度（灰度级）分辨率</li></ul><h3 id="采样点数和量化级数的关系"><a href="#采样点数和量化级数的关系" class="headerlink" title="采样点数和量化级数的关系"></a>采样点数和量化级数的关系</h3><p>对一幅图像，当量化级数一定时，采样点数对图像质量有着显著的影响。采样点数越多，图像质量越好； 当采样点数减少时，图上的块状效应就逐渐明显。</p><p>同理，当图像的采样点数一定时，采用不同量化级数的图像质量也不一样。量化级数越多，图像质量越好，当量化级数越少时，图像质量越差，量化级数最小的极端情况就是二值图像，图像出现假轮廓。</p><h2 id="像素间基本关系"><a href="#像素间基本关系" class="headerlink" title="像素间基本关系"></a>像素间基本关系</h2><h3 id="通路"><a href="#通路" class="headerlink" title="通路"></a>通路</h3><p><img src="https://eddyblog.oss-cn-shenzhen.aliyuncs.com/ImageProcess/Review/Review_2.JPG" srcset="/img/loading.gif" alt="2"></p><h3 id="距离"><a href="#距离" class="headerlink" title="距离"></a>距离</h3><p><img src="https://eddyblog.oss-cn-shenzhen.aliyuncs.com/ImageProcess/Review/Review_3.JPG" srcset="/img/loading.gif" alt="3"></p><p>主要区分$D_e$欧式距离，$D_4$距离和$D_8$距离。</p><p><img src="https://eddyblog.oss-cn-shenzhen.aliyuncs.com/ImageProcess/Review/Review_4.JPG" srcset="/img/loading.gif" alt="4"></p><p><img src="https://eddyblog.oss-cn-shenzhen.aliyuncs.com/ImageProcess/Review/Review_5.JPG" srcset="/img/loading.gif" alt="5"></p><p><img src="https://eddyblog.oss-cn-shenzhen.aliyuncs.com/ImageProcess/Review/Review_6.JPG" srcset="/img/loading.gif" alt="6"></p><h2 id="图像类型"><a href="#图像类型" class="headerlink" title="图像类型"></a>图像类型</h2><ul><li><p>二值图像(Binary images)</p><ul><li>二值图像也叫黑白图像，编程实现中就指是图像象素只存在 0,1 两个值的逻辑数组。</li></ul></li><li><p>亮度图像(Intensity images)</p><ul><li>亮度图像是包含亮度级的图像，如 64 级，256 级等。</li><li>如当亮度图像像素用 unit8 或 unit16 表示时，每个像素的整数取值范围分别是[0,255]和[0,65535]。</li><li>如当亮度图像像素用 double 表示时，则像素的取值为浮点数，规定双精度归一化亮度图像的取值范围为[0,1]。</li></ul></li><li><p>索引图像(Indexed images)</p><ul><li>索引图像把像素值直接作为索引颜色的序号。</li><li>根据索引颜色的序号就可以找到该像素的实际颜色。</li><li>当把索引图像读入计算机时，索引颜色将被存储到调色板中。</li></ul></li><li><p>RGB 图像(RGB images)</p><ul><li>一副 RGB 图像就是彩色像素的一个 M×N×3 数组，其中每一个彩色像素点都是在特定空间位置的彩色图像对应的红、绿、蓝三个分量。也可视为由三幅灰度图像形成的“堆”。</li><li>这类图像不使用单独的调色板，每一个像素的颜色由存储在相应位置的红，绿，蓝颜色分量共同决定。</li><li>RGB 图像是 24 位图像，红绿蓝分量分别占用 8 位，理论上可以包含 16M 种不同的颜色。</li></ul></li></ul><a id="more"></a><h1 id="空间域图像处理"><a href="#空间域图像处理" class="headerlink" title="空间域图像处理"></a>空间域图像处理</h1><p>对应梁老师课件第三章，王老师第二、三、四单元。着重掌握二值化，gamma 矫正，直方图均衡/匹配。</p><h2 id="点运算"><a href="#点运算" class="headerlink" title="点运算"></a>点运算</h2><p>空间域增强：$g(x,y) = T [ f(x,y )]$</p><p>若将邻域限制为$1 \times 1$，则可简化为$s=T(r)$即点运算。</p><ul><li>点运算将输入图象映射为输出图象，输出图象每个象素点的灰度值仅由对应的输入象素点的值决定。<ul><li>常用于改变图象的灰度范围及分布</li><li>也称为对比度增强、对比度拉伸或灰度变换；</li></ul></li><li>点运算可以是线性的，也可以是平方的,对数的,或其它任意单调函数的灰度变换；</li><li>点运算可以利用一个 LUT（Look-up table）容易实现（或在彩色至少 R、G、B 三个 LUT）。</li></ul><h3 id="基本的变换"><a href="#基本的变换" class="headerlink" title="基本的变换"></a>基本的变换</h3><ul><li>图像反转<ul><li>$s = L-1-r$</li></ul></li><li>对数运算<ul><li>$s = c \log(1+r)$</li><li>有时原图的动态范围太大，超出某些显示设备的允许动态范围，如直接使用原图，则一部分细节可能丢失。</li><li>解决办法是对原图进行灰度压缩，如对数变换</li></ul></li><li>幂次变换<ul><li>$s = cr^\gamma$</li><li>$\gamma=1$等幂变换与原图像相同。</li><li>$\gamma&gt;1$用于过亮图像变暗。</li><li>$\gamma&lt;1$用于过暗图像变亮。</li><li>伽马矫正</li></ul></li><li>对比拉伸<ul><li>单调增函数保证灰度值变化保序。</li><li>将需要提升差值的部分拉大灰度值极差从而达到提高对比度的效果。</li></ul></li><li>灰度切割<ul><li>提高图像中特定灰度范围的亮度</li></ul></li><li>位图切割</li></ul><h3 id="gamma-矫正和二值化的代码实现"><a href="#gamma-矫正和二值化的代码实现" class="headerlink" title="gamma 矫正和二值化的代码实现"></a>gamma 矫正和二值化的代码实现</h3><ul><li><p>gamma 矫正</p><pre><code class="hljs python">  <span class="hljs-comment"># 建表以后LUT</span><span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">GammaTable</span><span class="hljs-params">(gamma)</span>:</span>  invGamma = <span class="hljs-number">1.0</span> / gamma  table = np.array([((i / <span class="hljs-number">255.0</span>) ** invGamma) * <span class="hljs-number">255</span>                    <span class="hljs-keyword">for</span> i <span class="hljs-keyword">in</span> np.arange(<span class="hljs-number">0</span>, <span class="hljs-number">256</span>)]).astype(<span class="hljs-string">"uint8"</span>)  <span class="hljs-keyword">return</span> table<span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">LUT</span><span class="hljs-params">(image , lutTable)</span>:</span>  <span class="hljs-comment"># image: grayscale or RGB color image</span>  <span class="hljs-comment"># luTable: [255,] 1D numpy array mapping 0-255 values to ohter values</span>  lut = <span class="hljs-keyword">lambda</span> x: lutTable[x]  <span class="hljs-keyword">return</span> lut(image)  <span class="hljs-comment"># 直接伽马函数映射</span><span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">DirectGammaFunc</span><span class="hljs-params">(image,gamma)</span>:</span>  invGamma = <span class="hljs-number">1.0</span>/gamma  fuc =  <span class="hljs-keyword">lambda</span> x: ((x/<span class="hljs-number">255.0</span>)**invGamma)*<span class="hljs-number">255</span>  <span class="hljs-keyword">return</span> fuc(image).astype(<span class="hljs-string">"uint8"</span>)  <span class="hljs-comment"># R为单通道灰度图</span>  <span class="hljs-comment"># 调用</span>  R_crrt = LUT(R,GammaTable(<span class="hljs-number">1.5</span>))  R_crrt = DirectGammaFunc(R,<span class="hljs-number">1.5</span>)</code></pre></li><li><p>二值化（三种写法，见注释）</p><pre><code class="hljs python"><span class="hljs-comment"># 朴素循环</span><span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">ImThresh</span><span class="hljs-params">(im, minv, maxv)</span>:</span>    BinImg = np.zeros(im.shape, dtype=im.dtype)    <span class="hljs-keyword">for</span> i <span class="hljs-keyword">in</span> range(im.shape[<span class="hljs-number">0</span>]):        <span class="hljs-keyword">for</span> j <span class="hljs-keyword">in</span> range(im.shape[<span class="hljs-number">1</span>]):            <span class="hljs-keyword">if</span> im[i,j]&gt;=minv <span class="hljs-keyword">and</span> im[i,j]&lt;=maxv:                BinImg[i,j]=<span class="hljs-number">1</span>            <span class="hljs-keyword">else</span>:                BinImg[i,j]=<span class="hljs-number">0</span>    <span class="hljs-keyword">return</span> BinImg<span class="hljs-comment"># 向量运算</span><span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">ImThreshv2</span><span class="hljs-params">(image, minv, maxv)</span>:</span>    <span class="hljs-keyword">assert</span>(len(image.shape)==<span class="hljs-number">2</span>)    <span class="hljs-comment"># 二值逻辑</span>    group1 = image &gt;= minv    group2 = image &lt;= maxv    <span class="hljs-comment"># 与操作 即要求满足 像素值&gt;=minv 又要 &lt;=maxv</span>    <span class="hljs-keyword">return</span> (group1*group2).astype(np.uint8)<span class="hljs-comment"># 杰哥的写法（也是向量运算）</span><span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">ImThreshv3</span><span class="hljs-params">(image, minv, maxv)</span>:</span>    <span class="hljs-keyword">assert</span>(len(image.shape)==<span class="hljs-number">2</span>)    <span class="hljs-comment"># 只是这里用的非逻辑值，数字化为0，1（uint8类型）</span>    newimg = np.copy(image)    newimg[newimg &gt; maxv] = <span class="hljs-number">0</span>    newimg[newimg &lt; minv] = <span class="hljs-number">0</span>    newimg[newimg != <span class="hljs-number">0</span>] = <span class="hljs-number">1</span>    <span class="hljs-keyword">return</span> newimg.astype(np.uint8)<span class="hljs-comment"># 调用</span>Threshimg = Imthresh(R,<span class="hljs-number">120</span>,<span class="hljs-number">256</span>)Threshimg2  = Imthreshv2(R,<span class="hljs-number">120</span>,<span class="hljs-number">256</span>)</code></pre></li></ul><h2 id="直方图均衡"><a href="#直方图均衡" class="headerlink" title="直方图均衡"></a>直方图均衡</h2><h3 id="直方图"><a href="#直方图" class="headerlink" title="直方图"></a>直方图</h3><ul><li>定义：将所收集的测定值或数据之全距分为几个相等的区间作为横轴,并将各区间内之测定值所出现次数累积而成的面积,用柱子排起来的图形；</li><li>表示图像中具有某种属性（如灰度、颜色等）的像素的个数,反映了图像中每种属性级出现的频率,是图像的基本统计特征之一。</li></ul><h3 id="均衡"><a href="#均衡" class="headerlink" title="均衡"></a>均衡</h3><ul><li>直方图均衡化是通过灰度变换将一幅图象转换为另一幅具有均衡直方图，即在每个灰度级上都具有相同（离散情况下是相近）的象素点数的过程。这样就增加了像素灰度值的动态范围，从而达到增强图像整体对比度的效果</li><li>使用的方法是灰度级变换：$s = T(r)$</li></ul><h3 id="为什么概率累计曲线可以用来实现直方图均衡化的效果"><a href="#为什么概率累计曲线可以用来实现直方图均衡化的效果" class="headerlink" title="为什么概率累计曲线可以用来实现直方图均衡化的效果"></a>为什么概率累计曲线可以用来实现直方图均衡化的效果</h3><h4 id="概率论基础（问题基础）"><a href="#概率论基础（问题基础）" class="headerlink" title="概率论基础（问题基础）"></a>概率论基础（问题基础）</h4><p>根据课本 P74 页，$p_r(r)$和$p_s(s)$分别表示随机变量$r$和$s$的概率密度函数，<strong>概率论的一个基本结果是，如果$p_r(r)$和$T(r)$已知且$s = T(r)$具备单调性，在感兴趣的值域上是连续且可微的，则变换后的变量$s$的概率密度函数可由下面的简单公式得到：</strong></p><script type="math/tex; mode=display">p_s(s) = p_r(r) \left| \frac{\mathrm{d}r}{\mathrm{d}s} \right|</script><p>这个式子怎么推导的呢？实际上我们就是在求一个<strong>随机变量函数的概率分布</strong>，概率论是学过的，这里回忆一下给出推导。</p><p>设$r$为随机变量，其概率分布符合$p_r(r)$，另有一单调的函数（变换）$s = T(r)$，现在求$s$的概率分布，设$r$值域均为$[0,L-1]$。</p><p>由分布函数公式</p><script type="math/tex; mode=display">F(x) = \int_{0}^{x} p(m) \mathrm{d}m</script><p>得$r$得分布函数</p><script type="math/tex; mode=display">F_r(r) = \int_{0}^{r} p_r(m) \mathrm{d}m</script><p>又因为$s = T(r)$为单调函数，存在反函数$r = T^{-1}(s)$</p><script type="math/tex; mode=display">F_s(s) = F_r(T^{-1}(s)) = \int_{0}^{ T^{-1}(s) } p_r(m) \mathrm{d}m</script><p>概率密度函数为分布函数的导数</p><script type="math/tex; mode=display">p_s(s) = \left| \frac{\mathrm{d} F_s(s)}{\mathrm{d}s} \right|</script><p>应用链式求导法则</p><script type="math/tex; mode=display">p_s(s) = \left| \frac{\mathrm{d}F_s(s)}{\mathrm{d}s} \right|</script><script type="math/tex; mode=display">p_s(s) = \frac{\mathrm{d}F_r(r)}{\mathrm{d}r} \left| \frac{ \mathrm{d} r}{ \mathrm{d}s}  \right|</script><script type="math/tex; mode=display">p_s(s) = p_r(r) \left| \frac{ \mathrm{d} r}{ \mathrm{d}s}  \right|</script><p>则得到了书本上的公式。</p><h4 id="均衡变换（回答问题）"><a href="#均衡变换（回答问题）" class="headerlink" title="均衡变换（回答问题）"></a>均衡变换（回答问题）</h4><p>问题即为，<strong>为何任何随机变量的概率分布函数，若变换为累积分布函数，则变换后的随机变量的概率分布为均匀分布</strong>？这实际上是累积分布函数的一个特殊的性质，下面给出证明。</p><ol><li><p>若$T(r)$恰为$r$的分布函数，则</p><script type="math/tex; mode=display">s = T(r) = \int_{0}^{r} p_r(m) \mathrm{d}m</script><script type="math/tex; mode=display">\frac{\mathrm{d}s}{\mathrm{d}r} = p_r(r)</script><script type="math/tex; mode=display">p_s(s) = p_r(r) \left| \frac{ \mathrm{d} r}{ \mathrm{d}s}  \right| = p_r(r) \frac{1}{p_r(r)} = 1</script><p>则$s$为均匀分布$s \in [0,1]$ 且$p_s(s)$值恒为$1$</p></li><li><p>若$T(r)$为$r$分布函数映射到$[0,L-1]$，则</p><script type="math/tex; mode=display">s = T(r) = (L-1) \int_{0}^{r} p_r(m) \mathrm{d}m</script><script type="math/tex; mode=display">p_s(s) = p_r(r) \frac{1}{(L-1) p_r(r)} = \frac{1}{L-1}</script><p>则$s$为均匀分布，且$p_s(s)=\frac{1}{L-1}$</p></li></ol><p>这便是我们想要的函数变换，<strong>无论$p_r(r)$分布如何</strong>，经过这种类分布函数的函数变换，得到的$p_s(s)$就是一个<strong>均匀分布</strong>。</p><h3 id="直方图均衡化代码实现"><a href="#直方图均衡化代码实现" class="headerlink" title="直方图均衡化代码实现"></a>直方图均衡化代码实现</h3><pre><code class="hljs python"><span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">CaculateHistogram</span><span class="hljs-params">(input_image)</span>:</span>    <span class="hljs-comment"># 参数1. 图像</span>    <span class="hljs-comment"># 输出1. 总像素值</span>    <span class="hljs-comment"># 输出2. 灰度值分布计数</span>    <span class="hljs-comment"># 输出3. 灰度值分布前缀和（用来做后续直方图平局奴化）</span>    <span class="hljs-comment"># 区分单通道还是三通道图像</span>    <span class="hljs-keyword">if</span> len(np.shape(input_image)) == <span class="hljs-number">3</span>:           height,width,level = np.shape(input_image)           summ = height*width*level    <span class="hljs-keyword">else</span> :           height,width = np.shape(input_image)           summ = height*width    caculate_num,index_x = np.histogram(input_image,np.arange(<span class="hljs-number">0</span>,<span class="hljs-number">256</span>))    caculate_num = np.append(caculate_num,<span class="hljs-number">1</span>)    <span class="hljs-comment"># 前缀和</span>    sum_num = np.copy(caculate_num)    <span class="hljs-keyword">for</span> i <span class="hljs-keyword">in</span> range(<span class="hljs-number">1</span>,<span class="hljs-number">256</span>):        sum_num[i] = sum_num[i<span class="hljs-number">-1</span>] + sum_num[i]    <span class="hljs-keyword">return</span> summ,caculate_num,sum_num<span class="hljs-comment"># 计算直方图数组</span><span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">cumsum</span><span class="hljs-params">(img, bins)</span>:</span>    histogram = np.zeros(bins)    <span class="hljs-keyword">for</span> pixel <span class="hljs-keyword">in</span> np.arange(<span class="hljs-number">0</span>, bins, <span class="hljs-number">1</span>):        <span class="hljs-comment"># 向量化计算像素值为piexel的像素数量</span>        histogram[pixel] += len(img[img==pixel])    <span class="hljs-keyword">return</span> histogram<span class="hljs-comment"># 直方图均衡接口函数，利用了LUT</span><span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">HistogramEqualizationLUT</span><span class="hljs-params">(input_image)</span>:</span>    size,data,data_sum = CaculateHistogram(input_image)    fxy  = <span class="hljs-keyword">lambda</span> x: (<span class="hljs-number">255</span>*data_sum[x])//size    table = np.array([fxy(i) <span class="hljs-keyword">for</span> i <span class="hljs-keyword">in</span> range(<span class="hljs-number">256</span>)])    lut = <span class="hljs-keyword">lambda</span> x: table[x]    <span class="hljs-keyword">return</span> lut(input_image),table</code></pre><h2 id="直方图匹配"><a href="#直方图匹配" class="headerlink" title="直方图匹配"></a>直方图匹配</h2><p>方法：求两图均衡化，有逆函数存在，可实现匹配。</p><h3 id="证明"><a href="#证明" class="headerlink" title="证明"></a>证明</h3><p>我们易知$s$服从均匀分布，我们寻找一个$z$随机变量符合另一特殊分布$p_z(z)$，易知存在一函数（变换）：</p><script type="math/tex; mode=display">s = G(z) = (L-1) \int_{0}^{z} p_z(m) \mathrm{d}m</script><p>由于$G(z)$为累积分布函数，单调，故存在反函数$G^{-1}(z)$，则有新变换 $N = G^{-1} \cdot T$，使得$r$随机变量经$N$变换后符合$z$的分布特征。</p><script type="math/tex; mode=display">z = G^{-1}(s) = G^{-1}(T(r)) = N(r)</script><p>由此，我们找到了某值域内求从<strong>某一分布</strong>随机变量$r$变换到<strong>指定分布</strong>随机变量$z$的方法。</p><h2 id="空间域滤波基础"><a href="#空间域滤波基础" class="headerlink" title="空间域滤波基础"></a>空间域滤波基础</h2><p>书本 P93 页有详细概念。</p><p><img src="https://eddyblog.oss-cn-shenzhen.aliyuncs.com/ImageProcess/Review/Review_7.PNG" srcset="/img/loading.gif" alt="7"></p><p><img src="https://eddyblog.oss-cn-shenzhen.aliyuncs.com/ImageProcess/Review/Review_8.PNG" srcset="/img/loading.gif" alt="8"></p><h2 id="平滑和锐化"><a href="#平滑和锐化" class="headerlink" title="平滑和锐化"></a>平滑和锐化</h2><p>公式太多就贴 PPT 了</p><p><img src="https://eddyblog.oss-cn-shenzhen.aliyuncs.com/ImageProcess/Review/Review_9.PNG" srcset="/img/loading.gif" alt="9"></p><p><img src="https://eddyblog.oss-cn-shenzhen.aliyuncs.com/ImageProcess/Review/Review_10.PNG" srcset="/img/loading.gif" alt="10"></p><p><img src="https://eddyblog.oss-cn-shenzhen.aliyuncs.com/ImageProcess/Review/Review_11.PNG" srcset="/img/loading.gif" alt="11"></p><p><img src="https://eddyblog.oss-cn-shenzhen.aliyuncs.com/ImageProcess/Review/Review_12.PNG" srcset="/img/loading.gif" alt="12"></p><p><img src="https://eddyblog.oss-cn-shenzhen.aliyuncs.com/ImageProcess/Review/Review_13.PNG" srcset="/img/loading.gif" alt="13"></p><p><img src="https://eddyblog.oss-cn-shenzhen.aliyuncs.com/ImageProcess/Review/Review_14.PNG" srcset="/img/loading.gif" alt="14"></p><p><img src="https://eddyblog.oss-cn-shenzhen.aliyuncs.com/ImageProcess/Review/Review_15.PNG" srcset="/img/loading.gif" alt="15"></p><p><img src="https://eddyblog.oss-cn-shenzhen.aliyuncs.com/ImageProcess/Review/Review_16.PNG" srcset="/img/loading.gif" alt="16"></p><p>梯度算子</p><p><img src="https://eddyblog.oss-cn-shenzhen.aliyuncs.com/ImageProcess/Review/Review_17.PNG" srcset="/img/loading.gif" alt="17"></p><p><img src="https://eddyblog.oss-cn-shenzhen.aliyuncs.com/ImageProcess/Review/Review_18.PNG" srcset="/img/loading.gif" alt="18"></p><h3 id="添加噪声代码实现"><a href="#添加噪声代码实现" class="headerlink" title="添加噪声代码实现"></a>添加噪声代码实现</h3><p>注意椒盐</p><pre><code class="hljs python"><span class="hljs-comment"># 参考资料上的</span><span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">noisy</span><span class="hljs-params">(noise_typ,image)</span>:</span>    <span class="hljs-keyword">if</span> noise_typ == <span class="hljs-string">"gauss"</span>:        row,col,ch= image.shape        mean = <span class="hljs-number">0</span>        var = <span class="hljs-number">0.1</span>        sigma = var**<span class="hljs-number">0.5</span>        gauss = np.random.normal(mean,sigma,(row,col,ch))        gauss = gauss.reshape(row,col,ch)        noisy = image + gauss        <span class="hljs-keyword">return</span> noisy    <span class="hljs-keyword">elif</span> noise_typ == <span class="hljs-string">"s&amp;p"</span>:        row,col,ch = image.shape        s_vs_p = <span class="hljs-number">0.5</span>        amount = <span class="hljs-number">0.004</span>        out = np.copy(image)        <span class="hljs-comment"># Salt mode</span>        num_salt = np.ceil(amount * image.size * s_vs_p)        coords = [np.random.randint(<span class="hljs-number">0</span>, i - <span class="hljs-number">1</span>, int(num_salt)) <span class="hljs-keyword">for</span> i <span class="hljs-keyword">in</span> image.shape]        out[coords] = <span class="hljs-number">1</span>        <span class="hljs-comment"># Pepper mode</span>        num_pepper = np.ceil(amount* image.size * (<span class="hljs-number">1.</span> - s_vs_p))        coords = [np.random.randint(<span class="hljs-number">0</span>, i - <span class="hljs-number">1</span>, int(num_pepper)) <span class="hljs-keyword">for</span> i <span class="hljs-keyword">in</span> image.shape]        out[coords] = <span class="hljs-number">0</span>        <span class="hljs-keyword">return</span> out    <span class="hljs-keyword">elif</span> noise_typ == <span class="hljs-string">"poisson"</span>:        vals = len(np.unique(image))        vals = <span class="hljs-number">2</span> ** np.ceil(np.log2(vals))        noisy = np.random.poisson(image * vals) / float(vals)        <span class="hljs-keyword">return</span> noisy    <span class="hljs-keyword">elif</span> noise_typ ==<span class="hljs-string">"speckle"</span>:        row,col,ch = image.shape        gauss = np.random.randn(row,col,ch)        gauss = gauss.reshape(row,col,ch)        noisy = image + image * gauss        <span class="hljs-keyword">return</span> noisy<span class="hljs-comment"># 自己写的</span><span class="hljs-comment"># 生成随机椒盐噪点</span><span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">MakeNoise</span><span class="hljs-params">(input_image,number_of_noise=<span class="hljs-number">1000</span>)</span>:</span>    res_image = np.copy(input_image)    row,column = np.shape(input_image)<span class="hljs-comment">#     还可以加对三通道的特判</span>    <span class="hljs-keyword">for</span> i <span class="hljs-keyword">in</span> range(number_of_noise):        x = np.random.randint(<span class="hljs-number">0</span>,row)        y = np.random.randint(<span class="hljs-number">0</span>,column)        borw = np.random.randint(<span class="hljs-number">0</span>,<span class="hljs-number">2</span>)        <span class="hljs-keyword">if</span> borw == <span class="hljs-number">0</span>:            res_image[x][y] = <span class="hljs-number">0</span>        <span class="hljs-keyword">else</span>:            res_image[x][y] = <span class="hljs-number">255</span>    <span class="hljs-keyword">return</span> res_image</code></pre><h3 id="均值滤波代码实现"><a href="#均值滤波代码实现" class="headerlink" title="均值滤波代码实现"></a>均值滤波代码实现</h3><pre><code class="hljs python"><span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">Smooth</span><span class="hljs-params">(input_image,kernal_size = <span class="hljs-number">3</span>)</span>:</span>    ans = input_image.copy()    border = np.uint8(kernal_size/<span class="hljs-number">2</span>)    <span class="hljs-comment"># 根据核大小扩充边界</span>    addBorder = cv2.copyMakeBorder(input_image,border,border,border,border,cv2.BORDER_REFLECT_101)    filWin = np.ones((kernal_size,kernal_size),dtype=np.int64)    row,column = np.shape(addBorder)    <span class="hljs-keyword">for</span> i <span class="hljs-keyword">in</span> range(border,row-border):        <span class="hljs-keyword">for</span> j <span class="hljs-keyword">in</span> range(border,column-border):            <span class="hljs-comment"># 以图像i,j为中心，大小为2border+1的区域</span>            temp = addBorder[i-border:i+border+<span class="hljs-number">1</span>,j-border:j+border+<span class="hljs-number">1</span>]            temp_sum = np.sum(temp*filWin)            ans[i-border][j-border] = temp_sum/(kernal_size**<span class="hljs-number">2</span>)    <span class="hljs-keyword">return</span> ans</code></pre><h3 id="Laplace-锐化滤波代码实现"><a href="#Laplace-锐化滤波代码实现" class="headerlink" title="Laplace 锐化滤波代码实现"></a>Laplace 锐化滤波代码实现</h3><pre><code class="hljs python"><span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">Laplace</span><span class="hljs-params">(input_image,lap_template)</span>:</span>    x,y = np.shape(lap_template)    <span class="hljs-keyword">if</span>(x!=y):        print(<span class="hljs-string">"Shape of Laplace template wrong!"</span>)        <span class="hljs-keyword">pass</span>    print(<span class="hljs-string">"The Laplace template is: "</span>)    print(lap_template)    border = x//<span class="hljs-number">2</span>    ans = np.zeros(np.shape(input_image), dtype = np.int64)    <span class="hljs-comment"># 扩充边界</span>    addBorder = cv2.copyMakeBorder(input_image,border,border,border,border,cv2.BORDER_REFLECT_101)    row,column = np.shape(addBorder)    <span class="hljs-keyword">for</span> i <span class="hljs-keyword">in</span> range(border,row-border):        <span class="hljs-keyword">for</span> j <span class="hljs-keyword">in</span> range(border,column-border):            ans[i-border][j-border] = np.sum(lap_template*addBorder[i-border:i+border+<span class="hljs-number">1</span> , j-border: j+border+<span class="hljs-number">1</span>])    <span class="hljs-keyword">return</span> ans<span class="hljs-comment"># Laplace 常用算子 [[-1,-1,-1],[-1,8,-1],[-1,-1,-1]]</span>laplace_template_4 = np.array([[<span class="hljs-number">0</span>,<span class="hljs-number">-1</span>,<span class="hljs-number">0</span>],[<span class="hljs-number">-1</span>,<span class="hljs-number">4</span>,<span class="hljs-number">-1</span>],[<span class="hljs-number">0</span>,<span class="hljs-number">-1</span>,<span class="hljs-number">0</span>]])laplace_template_8 = np.array([[<span class="hljs-number">-1</span>,<span class="hljs-number">-1</span>,<span class="hljs-number">-1</span>],[<span class="hljs-number">-1</span>,<span class="hljs-number">8</span>,<span class="hljs-number">-1</span>],[<span class="hljs-number">-1</span>,<span class="hljs-number">-1</span>,<span class="hljs-number">-1</span>]])lap_img_4 = Laplace(im,laplace_template_4)</code></pre><h1 id="频率域图像处理"><a href="#频率域图像处理" class="headerlink" title="频率域图像处理"></a>频率域图像处理</h1><h2 id="频率域分析基础"><a href="#频率域分析基础" class="headerlink" title="频率域分析基础"></a>频率域分析基础</h2><p>这次课，我们首次接触了“频率域分析”方法。我们从高数中学习过的“无穷级数”概念切入，讲到基于三角函数的傅里叶级数。其中的关键思路是：任意周期函数都可以用傅里叶级数展开，而傅里叶级数的基函数是频率各异的三角函数；也就是说任意周期函数都可以用一组频率各异的三角函数的线性组合来表示。而线性组合系数，即基函数的加权系数，就可以解读为原函数在基函数上的“投影系数”（或坐标，或两者的相似度）。</p><p>如果能够求出傅里叶级数中的加权系数，那么就可以实现对原函数的“频域分解”，即原函数主要可以由哪些频率的三角函数叠加而成，也可以解读为原函数主要包含哪些频率的分量。而“频率”对于图像而言是有直观意义的。一般而言，低频成分对应图像中的总体形状和总体色彩和明暗分布；而高频成分对应图像中的细节和边缘信息。如果我们把图像看作是二维函数，并能够将其进行频域分解，那么增强其低频分量就是相当于平滑操作，增强其高频分量就相当于锐化操作。这就是我们除了前几章学习的“空间域分析”方法之外，又多了一个全新的视角和全新的方法。</p><p>傅里叶变换就是求解傅里叶级数中的加权系数的方法。其思路很简单，由于加权系数对应原函数与基函数的相似程度，我们可以用两者的离散采样点组成的向量的点积来估计二者的相似程度。因为向量的点积与向量的夹角的余弦成正比，夹角越小代表两个向量越相似，其余弦值就越大。工程上有一种名为“快速傅里叶变换”（FFT）的数值运算方法，可以快速求解傅里叶变换。但对于图像而言，它要求图像的长宽为 2 的整数次幂。</p><p>傅里叶逆变换是运用傅里叶级数来重构原函数的方法。其表达式就是傅里叶级数的表达式。有了基函数和加权系数，进行傅里叶逆变换是很直接的。</p><p>在工程上，傅里叶变换（FT）一般是对离散数据进行处理的，故名为离散傅里叶变换(DFT)。又因为常用快速傅里叶变换算法来求解，所以常用快速傅里叶变换(FFT)表示，其逆变换为 iFFT。无论是 FFT 还是 iFFT 都有现成的高度优化过的软件包使用，一般不用你自己实现。在 Python 语言中的 Numpy 包中就有相关实现，在 C++语言中也有 OpenCV 包中的对应实现。</p><p>我们在讲解了上述原理后，就尝试对一张图像（黑色背景的中央有个白色长方形）进行了傅里叶变换，对变换系数矩阵组成的图像进行了对数化（压缩值的分布，以便看清楚微弱的分布细节），观察了图像的频率域分解效果。然后我们分别演示了基于频率域分析的图像平滑（将 FFT 系数矩阵的边缘区域置零，再逆变换回空间域）和图像锐化（将 FFT 系数矩阵的中央区域置零，再逆变换回空间域，得到边缘图，再与原图进行叠加以便锐化图像）。这部分的演示，请看附件中的代码。</p><h2 id="使用-OpenCV-实现-DFT"><a href="#使用-OpenCV-实现-DFT" class="headerlink" title="使用 OpenCV 实现 DFT"></a>使用 OpenCV 实现 DFT</h2><p>OpenCV 也提供的工具用于实现离散傅里叶变换，分别是<code>cv2.dft()</code>和<code>cv2.idft()</code>函数。返回有两个通道，第一个通道是结果的实部，第二个通道是结果的虚部。所以在计算其幅度的时候需要先手动转化一次。</p><pre><code class="hljs python"><span class="hljs-comment">## Magnitude spectrum</span><span class="hljs-comment">## 使用Numpy实现DFT</span><span class="hljs-comment">## 进行二维DFT变换</span>f_img1 = np.fft.fft2(img1)<span class="hljs-comment">## 对换象限</span>fshift_img1 = np.fft.fftshift(f_img1)<span class="hljs-comment">## 幅度谱 对数化？</span>manitude_img1 = <span class="hljs-number">20</span>*np.log(np.abs(fshift_img1))<span class="hljs-comment">## img2图像也做相同的处理</span>f_img2 = np.fft.fft2(img2)fshift_img2 = np.fft.fftshift(f_img2)manitude_img2 = <span class="hljs-number">20</span>*np.log(np.abs(fshift_img2))<span class="hljs-comment">## 使用OpenCV实现DFT</span>f_img3 = cv2.dft(np.float32(img3), flags = cv2.DFT_COMPLEX_OUTPUT)fshift_img3 = np.fft.fftshift(f_img3)<span class="hljs-comment"># manitude_img3 = 20*np.log(np.abs(fshift_img3))</span><span class="hljs-comment"># 手动转化计算magnitude</span>manitude_img3 = <span class="hljs-number">20</span>*np.log(cv2.magnitude(fshift_img3[:,:,<span class="hljs-number">0</span>],fshift_img3[:,:,<span class="hljs-number">1</span>])+<span class="hljs-number">1e-15</span>)<span class="hljs-comment">## 使用OpenCV实现DFT</span>f_img4 = cv2.dft(np.float32(img4), flags = cv2.DFT_COMPLEX_OUTPUT)fshift_img4 = np.fft.fftshift(f_img4)manitude_img4 = <span class="hljs-number">20</span>*np.log(cv2.magnitude(fshift_img4[:,:,<span class="hljs-number">0</span>],fshift_img4[:,:,<span class="hljs-number">1</span>]))</code></pre><h2 id="理想滤波器"><a href="#理想滤波器" class="headerlink" title="理想滤波器"></a>理想滤波器</h2><p>所谓”理想”是指无法通过硬件实现的硬截断</p><h3 id="理想低通滤波器-ILPF"><a href="#理想低通滤波器-ILPF" class="headerlink" title="理想低通滤波器 ILPF"></a>理想低通滤波器 ILPF</h3><p>在圆外“阻断”所有频率，而在圆内无衰减的通过所有频率，这种二维低通滤波器称为理想低通滤波器（ILPF），由下面的函数确定</p><script type="math/tex; mode=display">H_{ILPF}(u,v) = \left \{\begin{aligned}1, & D(u,v) \le D_0 \\0, & D(u,b) > D_0\end{aligned}\right.</script><p>其中$D_0$是一个正常数，$D(u,v)$表示频率域中的点$(u,v)$距离频率域中心$(\frac{P}{2},\frac{Q}{2})$的距离。</p><h3 id="理想高通滤波器-IHPF"><a href="#理想高通滤波器-IHPF" class="headerlink" title="理想高通滤波器 IHPF"></a>理想高通滤波器 IHPF</h3><p>与低通类似，高通是将阈值的圆内“阻断”所有频率，而在圆外无衰减的通过所有频率，描述如下</p><script type="math/tex; mode=display">H_{IHPF}(u,v) = \left \{\begin{aligned}0, & D(u,v) \le D_0 \\1, & D(u,b) > D_0\end{aligned}\right.</script><h3 id="代码实现"><a href="#代码实现" class="headerlink" title="代码实现"></a>代码实现</h3><p>代码实现低通滤波器并展示其频率域透视图、频率域图像显示、空间域图像显示和径向剖面图。</p><pre><code class="hljs python"><span class="hljs-comment"># 获得指定大小的理想滤波器</span><span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">getIdealMask</span><span class="hljs-params">(mask_shape, filter_d0,hl_type)</span>:</span>    <span class="hljs-keyword">assert</span> hl_type <span class="hljs-keyword">in</span> (<span class="hljs-string">"lpf"</span>,<span class="hljs-string">"hpf"</span>)    rows,cols = mask_shape[<span class="hljs-number">0</span>],mask_shape[<span class="hljs-number">1</span>]    crow = rows/<span class="hljs-number">2</span>    ccol = cols/<span class="hljs-number">2</span>    mask = np.zeros((rows,cols))    <span class="hljs-keyword">for</span> i <span class="hljs-keyword">in</span> range(rows):        <span class="hljs-keyword">for</span> j <span class="hljs-keyword">in</span> range(cols):            dis = sqrt((i-crow)**<span class="hljs-number">2</span> + (j-ccol)**<span class="hljs-number">2</span>)            <span class="hljs-keyword">if</span> hl_type == <span class="hljs-string">"lpf"</span>:                <span class="hljs-keyword">if</span> dis &lt;= filter_d0:                    mask[i,j] = <span class="hljs-number">1</span>                <span class="hljs-keyword">else</span>:                    mask[i,j] = <span class="hljs-number">0</span>            <span class="hljs-keyword">elif</span> hl_type == <span class="hljs-string">"hpf"</span>:                <span class="hljs-keyword">if</span> dis &lt;= filter_d0:                    mask[i,j] = <span class="hljs-number">0</span>                <span class="hljs-keyword">else</span>:                    mask[i,j] = <span class="hljs-number">1</span>    <span class="hljs-keyword">return</span> mask<span class="hljs-comment"># 测试ILPF</span><span class="hljs-comment"># 参数设置</span>mask_shape = (<span class="hljs-number">100</span>,<span class="hljs-number">100</span>)d = <span class="hljs-number">20</span>filter_type = <span class="hljs-string">"lpf"</span><span class="hljs-comment"># 获得滤波器</span>myfilter = getIdealMask(mask_shape,d,filter_type)<span class="hljs-comment"># 绘图</span>plt.figure(figsize=(<span class="hljs-number">12</span>,<span class="hljs-number">12</span>))ax1=plt.subplot(<span class="hljs-number">221</span>,projection = <span class="hljs-string">"3d"</span>)ax2=plt.subplot(<span class="hljs-number">222</span>)ax3=plt.subplot(<span class="hljs-number">223</span>)ax4=plt.subplot(<span class="hljs-number">224</span>)drawPerspective(ax1,myfilter,title = <span class="hljs-string">"ILPF Perspective Axes3D"</span>, cmap = <span class="hljs-string">"gray"</span>)<span class="hljs-comment"># 不想进行列表解析,需要调用frompyfunc构建np可以用的分段函数</span>ufunc1 = np.frompyfunc(<span class="hljs-keyword">lambda</span> x: <span class="hljs-number">0</span> <span class="hljs-keyword">if</span> (x-d)&gt;<span class="hljs-number">0</span> <span class="hljs-keyword">else</span> <span class="hljs-number">1</span>, <span class="hljs-number">1</span>, <span class="hljs-number">1</span>)drawCurv(ax2,[ufunc1],[<span class="hljs-string">"ILPF"</span>],d,title = <span class="hljs-string">"ILPF Curv"</span>)drawPanel(ax3,myfilter,title = <span class="hljs-string">"ILPF Frequency Panel Axes2D"</span>)spatial_myfilter = frequencyToSpatial(myfilter)drawPanel(ax4,spatial_myfilter,title = <span class="hljs-string">"ILPF Spatial Panel Axes2D"</span>)plt.show()<span class="hljs-comment"># 测试IHPF</span>d = <span class="hljs-number">20</span>filter_type = <span class="hljs-string">"hpf"</span>myfilter = getIdealMask(mask_shape,d,filter_type)plt.figure(figsize=(<span class="hljs-number">12</span>,<span class="hljs-number">12</span>))ax1=plt.subplot(<span class="hljs-number">221</span>,projection = <span class="hljs-string">"3d"</span>)ax2=plt.subplot(<span class="hljs-number">222</span>)ax3=plt.subplot(<span class="hljs-number">223</span>)ax4=plt.subplot(<span class="hljs-number">224</span>)drawPerspective(ax1,myfilter,title = <span class="hljs-string">"IHPF Perspective Axes3D"</span>, cmap = <span class="hljs-string">"gray"</span>)<span class="hljs-comment"># 不想进行列表解析,需要调用frompyfunc构建np可以用的分段函数</span>ufunc1 = np.frompyfunc(<span class="hljs-keyword">lambda</span> x: <span class="hljs-number">1</span> <span class="hljs-keyword">if</span> (x-d)&gt;<span class="hljs-number">0</span> <span class="hljs-keyword">else</span> <span class="hljs-number">0</span>, <span class="hljs-number">1</span>, <span class="hljs-number">1</span>)drawCurv(ax2,[ufunc1],[<span class="hljs-string">"IHPF"</span>],d,title = <span class="hljs-string">"Curv"</span>)drawPanel(ax3,myfilter,title = <span class="hljs-string">"IHPF Frequency Panel Axes2D"</span>)spatial_myfilter = frequencyToSpatial(myfilter)drawPanel(ax4,spatial_myfilter,title = <span class="hljs-string">"IHPF Spatial Panel Axes2D"</span>)plt.show()</code></pre><p>理想低通 ILPF 结果四图</p><p><img src="https://eddyblog.oss-cn-shenzhen.aliyuncs.com/ImageProcess/TypeOfFilter/3.png" srcset="/img/loading.gif" alt="png"></p><p>理想高通 IHPF 结果四图</p><p><img src="https://eddyblog.oss-cn-shenzhen.aliyuncs.com/ImageProcess/TypeOfFilter/4.png" srcset="/img/loading.gif" alt="png"></p><h2 id="布特沃斯滤波器"><a href="#布特沃斯滤波器" class="headerlink" title="布特沃斯滤波器"></a>布特沃斯滤波器</h2><p>可通过硬件实现，可以通过阶数进行控制，一些资料中又称之为“巴特沃斯滤波器”。</p><h3 id="布特沃斯低通滤波器-BLPF"><a href="#布特沃斯低通滤波器-BLPF" class="headerlink" title="布特沃斯低通滤波器 BLPF"></a>布特沃斯低通滤波器 BLPF</h3><p>截止频率位于距原点$D_0$的$n$阶布特沃斯滤波器（BLPF）的传递函数定义为：</p><script type="math/tex; mode=display">H_{BLPF}(u,v) = \dfrac{1}{ 1 + {[ \dfrac {D(u,v)}{D_0} ]}^{2n} }</script><h3 id="布特沃斯高通滤波器-BHPF"><a href="#布特沃斯高通滤波器-BHPF" class="headerlink" title="布特沃斯高通滤波器 BHPF"></a>布特沃斯高通滤波器 BHPF</h3><p>对应的传递函数定义为：</p><script type="math/tex; mode=display">H_{BHPF}(u,v) = \dfrac{1}{ 1 + {[ \dfrac {D_0}{D_(u,v)} ]}^{2n} }</script><p>（分母分子颠倒）</p><p>两式中$n$对应了即阶参数，下面的代码给出巴特沃斯滤波器的实现，其频率域透视图、频率域图像显示、空间域图像显示和径向剖面图，曲线图绘制出不同阶下的取值。</p><h3 id="代码实现-1"><a href="#代码实现-1" class="headerlink" title="代码实现"></a>代码实现</h3><pre><code class="hljs python"><span class="hljs-comment"># 获得指定大小的布特沃斯滤波器</span><span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">getButterworthMask</span><span class="hljs-params">(mask_shape,filter_d0,hl_type,butter_n = <span class="hljs-number">1</span>)</span>:</span>    <span class="hljs-keyword">assert</span> hl_type <span class="hljs-keyword">in</span> (<span class="hljs-string">"lpf"</span>,<span class="hljs-string">"hpf"</span>)    rows,cols = mask_shape[<span class="hljs-number">0</span>],mask_shape[<span class="hljs-number">1</span>]    crow = rows/<span class="hljs-number">2</span>    ccol = cols/<span class="hljs-number">2</span>    mask = np.zeros((rows,cols))    <span class="hljs-keyword">for</span> i <span class="hljs-keyword">in</span> range(rows):        <span class="hljs-keyword">for</span> j <span class="hljs-keyword">in</span> range(cols):            dis = sqrt((i-crow)**<span class="hljs-number">2</span> + (j-ccol)**<span class="hljs-number">2</span>)            <span class="hljs-keyword">if</span> hl_type == <span class="hljs-string">"lpf"</span>:                mask[i,j] = <span class="hljs-number">1.0</span>/(<span class="hljs-number">1</span>+(dis/filter_d0)**(<span class="hljs-number">2</span>*butter_n))            <span class="hljs-keyword">elif</span> hl_type == <span class="hljs-string">"hpf"</span>:                <span class="hljs-comment"># 除以0情况特判一下</span>                <span class="hljs-keyword">if</span> np.abs(dis)&lt;eps:                    mask[i,j] = <span class="hljs-number">0</span>                <span class="hljs-keyword">else</span>:                    mask[i,j] = <span class="hljs-number">1.0</span>/(<span class="hljs-number">1</span>+(filter_d0/dis)**(<span class="hljs-number">2</span>*butter_n))    <span class="hljs-keyword">return</span> mask<span class="hljs-comment"># 测试BLPF</span><span class="hljs-comment"># 参数设置</span>mask_shape = (<span class="hljs-number">100</span>,<span class="hljs-number">100</span>)d = <span class="hljs-number">20</span>filter_type = <span class="hljs-string">"lpf"</span><span class="hljs-comment"># 获得滤波器</span>myfilter = getButterworthMask(mask_shape,d,filter_type, butter_n=<span class="hljs-number">2</span>)<span class="hljs-comment"># 绘图</span>plt.figure(figsize=(<span class="hljs-number">12</span>,<span class="hljs-number">12</span>))ax1=plt.subplot(<span class="hljs-number">221</span>,projection = <span class="hljs-string">"3d"</span>)ax2=plt.subplot(<span class="hljs-number">222</span>)ax3=plt.subplot(<span class="hljs-number">223</span>)ax4=plt.subplot(<span class="hljs-number">224</span>)drawPerspective(ax1,myfilter,title = <span class="hljs-string">"BLPF(n=2) Perspective Axes3D"</span>, cmap = <span class="hljs-string">"gray"</span>)funcs = []labels = []<span class="hljs-keyword">for</span> i <span class="hljs-keyword">in</span> range(<span class="hljs-number">1</span>,<span class="hljs-number">6</span>):    labels.append(<span class="hljs-string">"BLPF "</span>+<span class="hljs-string">"n="</span>+str(i))funcs.append(<span class="hljs-keyword">lambda</span> x:<span class="hljs-number">1.0</span>/(<span class="hljs-number">1</span>+(x/d)**(<span class="hljs-number">2</span>*<span class="hljs-number">1</span>)))funcs.append(<span class="hljs-keyword">lambda</span> x:<span class="hljs-number">1.0</span>/(<span class="hljs-number">1</span>+(x/d)**(<span class="hljs-number">2</span>*<span class="hljs-number">2</span>)))funcs.append(<span class="hljs-keyword">lambda</span> x:<span class="hljs-number">1.0</span>/(<span class="hljs-number">1</span>+(x/d)**(<span class="hljs-number">2</span>*<span class="hljs-number">3</span>)))funcs.append(<span class="hljs-keyword">lambda</span> x:<span class="hljs-number">1.0</span>/(<span class="hljs-number">1</span>+(x/d)**(<span class="hljs-number">2</span>*<span class="hljs-number">4</span>)))funcs.append(<span class="hljs-keyword">lambda</span> x:<span class="hljs-number">1.0</span>/(<span class="hljs-number">1</span>+(x/d)**(<span class="hljs-number">2</span>*<span class="hljs-number">5</span>)))drawCurv(ax2,funcs,labels,d,title = <span class="hljs-string">"BLPF(n=1,2,3,4,5) Curv"</span>)drawPanel(ax3,myfilter,title = <span class="hljs-string">"BLPF(n=2) Frequency Panel Axes2D"</span>)spatial_myfilter = frequencyToSpatial(myfilter)drawPanel(ax4,spatial_myfilter,title = <span class="hljs-string">"BLPF(n=2) Spatial Panel Axes2D"</span>)plt.show()<span class="hljs-comment"># 测试BHPF</span>d = <span class="hljs-number">20</span>filter_type = <span class="hljs-string">"hpf"</span>myfilter = getButterworthMask(mask_shape,d,filter_type, butter_n=<span class="hljs-number">1</span>)plt.figure(figsize=(<span class="hljs-number">12</span>,<span class="hljs-number">12</span>))ax1=plt.subplot(<span class="hljs-number">221</span>,projection = <span class="hljs-string">"3d"</span>)ax2=plt.subplot(<span class="hljs-number">222</span>)ax3=plt.subplot(<span class="hljs-number">223</span>)ax4=plt.subplot(<span class="hljs-number">224</span>)drawPerspective(ax1,myfilter,title = <span class="hljs-string">"BHPF(n=2) Perspective Axes3D"</span>, cmap = <span class="hljs-string">"gray"</span>)funcs = []labels = []<span class="hljs-keyword">for</span> i <span class="hljs-keyword">in</span> range(<span class="hljs-number">1</span>,<span class="hljs-number">6</span>):<span class="hljs-comment">#     funcs.append(lambda x:1.0/(1+(d/x)**(2*i)))</span><span class="hljs-comment">#     ufunc = np.frompyfunc(lambda x: 0 if np.abs(x)&lt;eps else 1.0/(1+(d/x)**(2*i)), 1, 1)</span><span class="hljs-comment">#     funcs.append(ufunc)</span>    labels.append(<span class="hljs-string">"BHPF "</span>+<span class="hljs-string">"n="</span>+str(i))ufunc1 = np.frompyfunc(<span class="hljs-keyword">lambda</span> x: <span class="hljs-number">0</span> <span class="hljs-keyword">if</span> np.abs(x)&lt;eps <span class="hljs-keyword">else</span> <span class="hljs-number">1.0</span>/(<span class="hljs-number">1</span>+(d/x)**(<span class="hljs-number">2</span>*<span class="hljs-number">1</span>)), <span class="hljs-number">1</span>, <span class="hljs-number">1</span>)ufunc2 = np.frompyfunc(<span class="hljs-keyword">lambda</span> x: <span class="hljs-number">0</span> <span class="hljs-keyword">if</span> np.abs(x)&lt;eps <span class="hljs-keyword">else</span> <span class="hljs-number">1.0</span>/(<span class="hljs-number">1</span>+(d/x)**(<span class="hljs-number">2</span>*<span class="hljs-number">2</span>)), <span class="hljs-number">1</span>, <span class="hljs-number">1</span>)ufunc3 = np.frompyfunc(<span class="hljs-keyword">lambda</span> x: <span class="hljs-number">0</span> <span class="hljs-keyword">if</span> np.abs(x)&lt;eps <span class="hljs-keyword">else</span> <span class="hljs-number">1.0</span>/(<span class="hljs-number">1</span>+(d/x)**(<span class="hljs-number">2</span>*<span class="hljs-number">3</span>)), <span class="hljs-number">1</span>, <span class="hljs-number">1</span>)ufunc4 = np.frompyfunc(<span class="hljs-keyword">lambda</span> x: <span class="hljs-number">0</span> <span class="hljs-keyword">if</span> np.abs(x)&lt;eps <span class="hljs-keyword">else</span> <span class="hljs-number">1.0</span>/(<span class="hljs-number">1</span>+(d/x)**(<span class="hljs-number">2</span>*<span class="hljs-number">4</span>)), <span class="hljs-number">1</span>, <span class="hljs-number">1</span>)ufunc5 = np.frompyfunc(<span class="hljs-keyword">lambda</span> x: <span class="hljs-number">0</span> <span class="hljs-keyword">if</span> np.abs(x)&lt;eps <span class="hljs-keyword">else</span> <span class="hljs-number">1.0</span>/(<span class="hljs-number">1</span>+(d/x)**(<span class="hljs-number">2</span>*<span class="hljs-number">5</span>)), <span class="hljs-number">1</span>, <span class="hljs-number">1</span>)funcs.append(ufunc1)funcs.append(ufunc2)funcs.append(ufunc3)funcs.append(ufunc4)funcs.append(ufunc5)drawCurv(ax2,funcs,labels,d,title = <span class="hljs-string">"BHPF(n=1,2,3,4,5) Curv"</span>)drawPanel(ax3,myfilter,title = <span class="hljs-string">"BHPF(n=2) Frequency Panel Axes2D"</span>)spatial_myfilter = frequencyToSpatial(myfilter)drawPanel(ax4,spatial_myfilter,title = <span class="hljs-string">"BHPF(n=2) Spatial Panel Axes2D"</span>)plt.show()</code></pre><p>布特沃斯低通 BLPF 结果四图</p><p><img src="https://eddyblog.oss-cn-shenzhen.aliyuncs.com/ImageProcess/TypeOfFilter/5.png" srcset="/img/loading.gif" alt="png"></p><p>布特沃斯高通 BHPF 结果四图</p><p><img src="https://eddyblog.oss-cn-shenzhen.aliyuncs.com/ImageProcess/TypeOfFilter/6.png" srcset="/img/loading.gif" alt="png"></p><!--more--><h3 id="高斯低通滤波器-GLPF"><a href="#高斯低通滤波器-GLPF" class="headerlink" title="高斯低通滤波器 GLPF"></a>高斯低通滤波器 GLPF</h3><p>高斯低通滤波器二维形式由下式给处：</p><script type="math/tex; mode=display">H_{GLPF}(u,v) = e^{\dfrac{-D^2(u,v)}{2 \sigma^2}}</script><p>$\sigma$描述了中心的扩散速度，和其他滤波器描述式统一，通过令$\sigma = D_0$，可以用表示其他滤波器的方法表示高斯滤波器。</p><script type="math/tex; mode=display">H_{GLPF}(u,v) = e^{\dfrac{-D^2(u,v)}{2 D_0^2}}</script><h3 id="高斯高通滤波器-GHPF"><a href="#高斯高通滤波器-GHPF" class="headerlink" title="高斯高通滤波器 GHPF"></a>高斯高通滤波器 GHPF</h3><p>如下：</p><script type="math/tex; mode=display">H_{GHPF}(u,v) =1 - e^{\dfrac{-D^2(u,v)}{2 D_0^2}}</script><h3 id="代码实现-2"><a href="#代码实现-2" class="headerlink" title="代码实现"></a>代码实现</h3><pre><code class="hljs python"><span class="hljs-comment"># 获得指定大小的高斯滤波器</span><span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">getGaussianMask</span><span class="hljs-params">(mask_shape,filter_d0,hl_type)</span>:</span>    <span class="hljs-keyword">assert</span> hl_type <span class="hljs-keyword">in</span> (<span class="hljs-string">"lpf"</span>,<span class="hljs-string">"hpf"</span>)    rows,cols = mask_shape[<span class="hljs-number">0</span>],mask_shape[<span class="hljs-number">1</span>]    crow = rows/<span class="hljs-number">2</span>    ccol = cols/<span class="hljs-number">2</span>    mask = np.zeros((rows,cols))    <span class="hljs-keyword">for</span> i <span class="hljs-keyword">in</span> range(rows):        <span class="hljs-keyword">for</span> j <span class="hljs-keyword">in</span> range(cols):            dis = sqrt((i-crow)**<span class="hljs-number">2</span> + (j-ccol)**<span class="hljs-number">2</span>)            <span class="hljs-keyword">if</span> hl_type == <span class="hljs-string">"hpf"</span>:                mask[i,j] = <span class="hljs-number">1</span>-np.exp(-(dis**<span class="hljs-number">2</span>) / (<span class="hljs-number">2</span>*(filter_d0**<span class="hljs-number">2</span>)))            <span class="hljs-keyword">elif</span> hl_type == <span class="hljs-string">"lpf"</span>:                mask[i,j] = np.exp(-(dis**<span class="hljs-number">2</span>)/(<span class="hljs-number">2</span>*(filter_d0**<span class="hljs-number">2</span>)))    <span class="hljs-keyword">return</span> mask<span class="hljs-comment"># 测试GLPF</span><span class="hljs-comment"># 参数设置</span>mask_shape = (<span class="hljs-number">200</span>,<span class="hljs-number">200</span>)d = <span class="hljs-number">20</span>filter_type = <span class="hljs-string">"lpf"</span><span class="hljs-comment"># 获得滤波器</span>myfilter = getGaussianMask(mask_shape,d,filter_type)<span class="hljs-comment"># 绘图</span>plt.figure(figsize=(<span class="hljs-number">12</span>,<span class="hljs-number">12</span>))ax1=plt.subplot(<span class="hljs-number">221</span>,projection = <span class="hljs-string">"3d"</span>)ax2=plt.subplot(<span class="hljs-number">222</span>)ax3=plt.subplot(<span class="hljs-number">223</span>)ax4=plt.subplot(<span class="hljs-number">224</span>)drawPerspective(ax1,myfilter,title = <span class="hljs-string">"GLPF Perspective Axes3D"</span>, cmap = <span class="hljs-string">"gray"</span>)drawCurv(ax2,[<span class="hljs-keyword">lambda</span> x:np.exp(-(x**<span class="hljs-number">2</span>)/(<span class="hljs-number">2</span>*(d**<span class="hljs-number">2</span>)))],[<span class="hljs-string">"GLPF"</span>],d,title = <span class="hljs-string">"GLPF Curv"</span>)drawPanel(ax3,myfilter,title = <span class="hljs-string">"GLPF Frequency Panel Axes2D"</span>)spatial_myfilter = frequencyToSpatial(myfilter)drawPanel(ax4,spatial_myfilter,title = <span class="hljs-string">"GLPF Spatial Panel Axes2D"</span>)plt.show()<span class="hljs-comment"># 测试GHPF</span>d = <span class="hljs-number">20</span>filter_type = <span class="hljs-string">"hpf"</span>myfilter = getGaussianMask(mask_shape,d,filter_type)plt.figure(figsize=(<span class="hljs-number">12</span>,<span class="hljs-number">12</span>))ax1=plt.subplot(<span class="hljs-number">221</span>,projection = <span class="hljs-string">"3d"</span>)ax2=plt.subplot(<span class="hljs-number">222</span>)ax3=plt.subplot(<span class="hljs-number">223</span>)ax4=plt.subplot(<span class="hljs-number">224</span>)drawPerspective(ax1,myfilter,title = <span class="hljs-string">"GLPF Perspective Axes3D"</span>, cmap = <span class="hljs-string">"gray"</span>)drawCurv(ax2,[<span class="hljs-keyword">lambda</span> x:<span class="hljs-number">1</span>-np.exp(-(x**<span class="hljs-number">2</span>)/(<span class="hljs-number">2</span>*(d**<span class="hljs-number">2</span>)))],[<span class="hljs-string">"GHPF"</span>],d,title = <span class="hljs-string">"GLPF Curv"</span>)drawPanel(ax3,myfilter,title = <span class="hljs-string">"GLPF Frequency Panel Axes2D"</span>)spatial_myfilter = frequencyToSpatial(myfilter)drawPanel(ax4,spatial_myfilter,title = <span class="hljs-string">"GLPF Spatial Panel Axes2D"</span>)plt.show()</code></pre><p>高斯低通 GLPF 结果四图</p><p><img src="https://eddyblog.oss-cn-shenzhen.aliyuncs.com/ImageProcess/TypeOfFilter/7.png" srcset="/img/loading.gif" alt="png"></p><p>高斯高通 GHPF 结果四图</p><p><img src="https://eddyblog.oss-cn-shenzhen.aliyuncs.com/ImageProcess/TypeOfFilter/8.png" srcset="/img/loading.gif" alt="png"></p><h2 id="滤波器对比总结"><a href="#滤波器对比总结" class="headerlink" title="滤波器对比总结"></a>滤波器对比总结</h2><p>在规定滤波器为 100x100，阈值为 20 时，可以明显观察到，理想滤波器-&gt;高阶布特沃斯滤波器-&gt;低阶布特沃斯滤波器-&gt;高斯滤波器，可以由函数 Curv 看出对应的过渡。</p><p>我们同时也发现理想滤波器确实会存在<strong>振铃特性</strong>，这个将在后面的文章中再做分析学习。</p><h2 id="振铃特性"><a href="#振铃特性" class="headerlink" title="振铃特性"></a>振铃特性</h2><p>理想低通滤波器实验中，我们也可以很明显的发现<strong>振铃现象</strong>，间隙处原本统一的纹理由于模糊变得有明暗起伏。而随着被滤去的高频内容的数量的减少，图像的纹理变得越来越好，甚至我们仔细看第三幅图，也能发现振铃现象的纹理，课本是这么评价振铃现象和 ILPF 的。</p><blockquote><p>这种振铃现象是理想滤波器的一种特性，从这个例子我们可以清楚地看到，理想低通滤波器并不是非常实用。然而，作为滤波概念发展的一部分，研究这种滤波器的特性非常有用。</p></blockquote><h3 id="振铃现象的一些见解"><a href="#振铃现象的一些见解" class="headerlink" title="振铃现象的一些见解"></a>振铃现象的一些见解</h3><pre><code class="hljs python"><span class="hljs-comment"># 绘制空间域表示图和水平线灰度剖面图</span><span class="hljs-keyword">for</span> d <span class="hljs-keyword">in</span> d_list:    fre_mask=getIdealMask((<span class="hljs-number">688</span>,<span class="hljs-number">688</span>),d,<span class="hljs-string">"lpf"</span>)    spa_mask=frequencyToSpatial(fre_mask)    X = [i <span class="hljs-keyword">for</span> i <span class="hljs-keyword">in</span> range(spa_mask.shape[<span class="hljs-number">0</span>])]    Y = spa_mask[spa_mask.shape[<span class="hljs-number">0</span>]//<span class="hljs-number">2</span>]    plt.figure(figsize=(<span class="hljs-number">8</span>,<span class="hljs-number">4</span>))    ax1 = plt.subplot(<span class="hljs-number">121</span>)    ax2 = plt.subplot(<span class="hljs-number">122</span>)    ax1.set_title(<span class="hljs-string">f"Spatial Img with $D_0 = <span class="hljs-subst">&#123;d&#125;</span>$"</span>)    ax2.set_title(<span class="hljs-string">f"Grayscale with $D_0 = <span class="hljs-subst">&#123;d&#125;</span>$"</span>)    ax1.imshow(spa_mask,cmap = <span class="hljs-string">"gray"</span>)    ax2.plot(X,Y)    ax2.spines[<span class="hljs-string">'left'</span>].set_color(<span class="hljs-string">'none'</span>)    ax2.spines[<span class="hljs-string">'top'</span>].set_color(<span class="hljs-string">'none'</span>)    ax2.spines[<span class="hljs-string">'right'</span>].set_color(<span class="hljs-string">'none'</span>)    ax2.set_yticks([])    ax2.set_yticklabels([])</code></pre><p><img src="https://eddyblog.oss-cn-shenzhen.aliyuncs.com/ImageProcess/IdealFilter/6.png" srcset="/img/loading.gif" alt="png"></p><p><img src="https://eddyblog.oss-cn-shenzhen.aliyuncs.com/ImageProcess/IdealFilter/7.png" srcset="/img/loading.gif" alt="png"></p><p><img src="https://eddyblog.oss-cn-shenzhen.aliyuncs.com/ImageProcess/IdealFilter/8.png" srcset="/img/loading.gif" alt="png"></p><p><img src="https://eddyblog.oss-cn-shenzhen.aliyuncs.com/ImageProcess/IdealFilter/9.png" srcset="/img/loading.gif" alt="png"></p><p><img src="https://eddyblog.oss-cn-shenzhen.aliyuncs.com/ImageProcess/IdealFilter/10.png" srcset="/img/loading.gif" alt="png"></p><p>分别对应了上面的阈值，观察其滤波器的空间与表示，在$D_0$较小的时候有很明显的波动函数形状。</p><blockquote><p>ILPF 的模糊和振铃特性可用卷积定理来解释。由于 ILPF 在频率域的剖面图类似于盒状滤波器，因此可以预料相应空间滤波器具有 sinc 函数形状。空间域滤波可通过$h(x,y)$于图像卷积来实现。讲图像中的每个像素想象为一个离散冲击，它的强度与所在位置的灰度成正比。一个 sinc 函数与一个冲激卷积就是在冲激处复制这个 sinc 函数。<strong>sinc 函数的中心波瓣是引起模糊的主因，而外侧较小的波瓣是造成振铃的主要原因。sinc 函数“展开度”与$H(u,v)$半径成反比，所以$D_0$越大，空间 sinc 函数就趋近于一个卷积时不会导致模糊但也不会产生振铃的冲激</strong>。</p></blockquote><h1 id="图像去模糊（图像复原）"><a href="#图像去模糊（图像复原）" class="headerlink" title="图像去模糊（图像复原）"></a>图像去模糊（图像复原）</h1><h2 id="引言"><a href="#引言" class="headerlink" title="引言"></a>引言</h2><p>前面所接触的图像增强是一个，已知原图像，经处理后，得到增强图像的一个过程，而这一章将要深入的图像复原（重建），则是希望从（被污染）过的图像，经处理后，得到原图像的过程，是以<strong>预先确定的目标</strong>来改善图像。图像复原试图利用退化现象的某种<strong>先验知识</strong>来复原被退化的图像。因而，复原技术时面向退化模型的，并且采用相反的过程进行处理，以便恢复出原图像。虽然图像增强和图像复原两者在覆盖的领域和使用的技术栈有所重叠，其中还是有几点区别我们还是要提起注意的。</p><ul><li><p>形象化的描述</p><p>图像增强主要是一个主观的过程，而图像复原大部分是一个客观的过程。</p></li><li><p>已知与未知的区别</p><p>图像增强已知原始图像与变换（卷积核或者其频率域的谱），对于增强效果是未知且非预先确定的（只有一个大概方向，比如模糊还是锐化），而图像复原则已知污染图像，且对原始图像是预先确定的（测试条件下甚至是有标准比对的原始图像，是已知的），对于复原变换（污染变换的逆）常常是未知的，这就要求我们在做图像处理时常常需要“估计”我们的复原变换。</p></li><li><p>期望与探索的区别<br>由于两者已知和未知上的差距，这就导致图像复原通常会涉及设立一个<strong>最佳准则</strong>来产生期望结果的最佳估计。相比之下，图像增强技术基本上是一个<strong>探索性过程</strong>，即根据人类视觉系统的生理特点来设计改善图像的方法。</p></li></ul><h2 id="背景知识"><a href="#背景知识" class="headerlink" title="背景知识"></a>背景知识</h2><h3 id="线性系统"><a href="#线性系统" class="headerlink" title="线性系统"></a>线性系统</h3><p>可加性，$x_1(t)+x_2(t) = y_1(t)+y_2(t)$，从而有$a \times x_1(t) = a \times y_1(t)$</p><p>平移不变性</p><h3 id="卷积"><a href="#卷积" class="headerlink" title="卷积"></a>卷积</h3><p>卷积、离散二维卷积</p><p>从而可以利用卷积这个工具。</p><p>冲激响应：输入为一个脉冲信号，输出是一个冲激响应$h(x)$，实际上可以就是之前接触过的卷积核。</p><h3 id="图形复原"><a href="#图形复原" class="headerlink" title="图形复原"></a>图形复原</h3><p>复原</p><ul><li>试图利用退化过程的先验知识使已退化的图像恢复本来面目</li><li>根据退化的原因，分析引起退化的环境因素</li><li>建立相应的数学模型</li><li>沿着使图像降质的逆过程回复图像</li></ul><p>原因</p><ul><li>由于对焦不准导致的图像模糊是很常见的</li><li>此时，物体的外观信息并未丢失，而是被分散叠加显示了</li><li>如果能够把分散叠加的信息彼此分离，就可能去除模糊</li></ul><p>目的</p><ul><li>在于消除或减轻退化的影响</li></ul><p>方法</p><ul><li>由于退化系统是黑盒的，盲复原往往很困难，噪声干扰也为复原过程带来了困难和不确定性</li><li>图像复原是寻求在一定优化准则下的原始图象的最有估计。因此，不同的优化准则会获得不同的图像复原。评价指标的选择目前也是研究的方向之一，如峰值信号比等。</li></ul><h2 id="图像退化-复原过程模型"><a href="#图像退化-复原过程模型" class="headerlink" title="图像退化/复原过程模型"></a>图像退化/复原过程模型</h2><p>退化过程（污染过程）的描述：建模为一个退化函数和一个加性噪声项，对于输入图像（原图像）$f(x,y)$进行处理，产生一副退化后的图像$g(x,y)$，图像复原目的就是已知$g(x,y)$的前提下，希望得到原图像的一个估计，这个估计越接近原始输入图像越好。空间域中的退化图像可由下式给出：</p><script type="math/tex; mode=display">g(x,y) = h(x,y)  \star f(x,y) + \eta(x,y)</script><p>上式中$h(x,y)$是退化函数的空间表示，由第四章内容，我们可以将上式的模型写成等价的频率域表示：</p><script type="math/tex; mode=display">g(u,v) = H(u,v) F(u,v) + N(u,v)</script><p>这两个式子是本章后面大部分复原内容的基础。</p><h2 id="采用频率域滤波图像复原的原因"><a href="#采用频率域滤波图像复原的原因" class="headerlink" title="采用频率域滤波图像复原的原因"></a>采用频率域滤波图像复原的原因</h2><p>在频率域滤波进行图像复原主要在两个方面效果较好，其一是利用频率域滤波消除周期噪声，另一个是利用频率域做退化函数的逆滤波。</p><p>为什么要在频率域做逆滤波？观察之前退化模型的两个式子，我们不难发现：</p><script type="math/tex; mode=display">g(x,y) = h(x,y) \star f(x,y) + \eta(x,y) \tag 1</script><script type="math/tex; mode=display">g(u,v) = H(u,v) F(u,v) + N(u,v) \tag 2</script><p>对(1)式空间域来说，想要从$g(x,y)$恢复$f(x,y)$，避不开的是“卷积”的逆运算，这在定义和实现的复杂上都比较困难，而转化到频率域，从(2)式我们或许可以通过一个“除法”来实现逆滤波，结合之前噪声模型相关内容，我们尝试在频率域上对仅退化函数影响的图像，和更复杂一些的，退化函数和加性噪声双重影响的图像进行复原。</p><h2 id="逆滤波"><a href="#逆滤波" class="headerlink" title="逆滤波"></a>逆滤波</h2><p>退化函数已给出，或者由上面退化函数的估计方法获得后，最简单的复原方法是直接做逆滤波，即：</p><script type="math/tex; mode=display">\hat{F}(u,v) = \dfrac{G(u,v)}{H(u,v)}</script><p>然而根据前述我们知道，在噪声的影响下，$\hat{F}(u,v)$和$F(u,v)$仍有差别，即</p><script type="math/tex; mode=display">\hat{F}(u,v) = F(u,v) \dfrac{N(u,v)}{H(u,v)}</script><p>这个式子两点启发：</p><ol><li>知道退化函数也不能完全复原未退化图像，因为噪声函数未知。</li><li>如果退化函数是零或是非常小的值，那么噪声影响会被放大</li></ol><h2 id="最小均方误差（维纳）滤波"><a href="#最小均方误差（维纳）滤波" class="headerlink" title="最小均方误差（维纳）滤波"></a>最小均方误差（维纳）滤波</h2><p>实际上维纳滤波是在这里是相对逆滤波来说的，而并非指特别的滤波函数，且不仅应用在运动模糊滤波中。</p><script type="math/tex; mode=display">\hat{F}(u,v) =[\dfrac{1}{H(u,v)} \dfrac{ {|H(u,v)|}^2 }{ {|H(u,v)|}^2+ S_{\eta}(u,v)/S_f(u,v) }] G(u,v)</script><p>$S_{\eta}(u,v)$为噪声的功率谱而$S_f(u,v)$是未退化图像的功率谱，比值为噪信比。而由于谱${|N(u,v)|}^2$是一个常数，这大大简化了处理。我们常用下面的表达式来近似。</p><script type="math/tex; mode=display">\hat{F}(u,v) =[\dfrac{1}{H(u,v)} \dfrac{ {|H(u,v)|}^2 }{ {|H(u,v)|}^2+ K }] G(u,v)</script><p>理解与启发：</p><ul><li>当频域某处没有噪声时， 𝑁/𝑆 的值为 0，方括号中表达式的值为 1，表示此时不需要对 𝐺/𝐻 修正。（回到逆滤波）</li><li>当频域某处噪声大时， 𝑁/𝑆 的值比较大，方括号表达式的值小于 1，相当于对此处 𝐺/𝐻 的值进行抑制，以降低噪声的影响。</li></ul><p>实现：</p><pre><code class="hljs python"><span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">wienerFiltering</span><span class="hljs-params">(input_img, h, NSR ,htype = <span class="hljs-string">"frequency"</span>)</span>:</span>    <span class="hljs-keyword">assert</span> htype <span class="hljs-keyword">in</span> (<span class="hljs-string">"frequency"</span>,<span class="hljs-string">"spatial"</span>)    <span class="hljs-comment"># 输入图像的傅里叶变换</span>    input_img_fft = np.fft.fft2(input_img)    input_img_fft = np.fft.ifftshift(input_img_fft)    <span class="hljs-keyword">if</span>(htype == <span class="hljs-string">"spatial"</span>):        <span class="hljs-comment"># 模糊化函数的傅里叶变换</span>        h_fft = np.fft.fft2(h)    <span class="hljs-keyword">else</span> :        h_fft = h    <span class="hljs-comment"># 退化函数模值的平方</span>    h_abs_square = np.abs(h_fft)**<span class="hljs-number">2</span>    <span class="hljs-comment"># 维纳滤波</span>    <span class="hljs-comment"># 使用的是 共轭/模方+NSR的形式，并非 9 10 式</span>    output_image_fft = np.conj(h_fft) / (h_abs_square + NSR)    <span class="hljs-comment"># 输出图像傅里叶反变换</span>    output_image = np.fft.ifft2(output_image_fft * input_img_fft)    output_image = np.abs(np.fft.fftshift(output_image))    <span class="hljs-keyword">return</span> output_image</code></pre><h1 id="多重曝光融合"><a href="#多重曝光融合" class="headerlink" title="多重曝光融合"></a>多重曝光融合</h1><ul><li>曝光程度对照片质量有影响</li><li>不同曝光程度的照片中都包含有用场景信息</li></ul><h2 id="成像质量计算"><a href="#成像质量计算" class="headerlink" title="成像质量计算"></a>成像质量计算</h2><p><img src="https://eddyblog.oss-cn-shenzhen.aliyuncs.com/ImageProcess/Review/Review_19.PNG" srcset="/img/loading.gif" alt="19"></p><h2 id="为什么不直接用直方图均衡化来解决过曝光和欠曝光问题"><a href="#为什么不直接用直方图均衡化来解决过曝光和欠曝光问题" class="headerlink" title="为什么不直接用直方图均衡化来解决过曝光和欠曝光问题"></a>为什么不直接用直方图均衡化来解决过曝光和欠曝光问题</h2><p>过曝光和曝光不足是完全丧失了信息，而多重曝光得到的多幅图像则保留了这部分信息。举曝光不足的例子。比如黑色背景和灰色城堡，在曝光不足的情况下灰度值均为 0，显示为相同的黑色，实际上已经丢失了城堡和背景区分的信息，即便使用直方图均衡，可预知的结果是城堡和背景灰度值增加但是仍保持相同，无法区分两者。所以直方图均衡无法解决此类信息彻底丢失的问题。多重曝光则有多幅原始图像，可以对局部选择信息保留的部分进行融合。过曝光同理</p><h2 id="计算问题"><a href="#计算问题" class="headerlink" title="计算问题"></a>计算问题</h2><p>直接按下式进行加权融合会出现问题</p><p>$𝒑=𝒘^′∗𝒑^′+𝒘^{′′}∗𝒑^{′′}+𝒘^{′′′}∗𝒑^{′′′}$</p><p>解决办法</p><ul><li><p>基于原图边缘信息的图像融合</p><ul><li>用照片的边缘图把质量系数矩阵中的边缘过滤掉</li><li>Laplace 边缘图*成像系数矩阵</li></ul></li><li><p>基于多尺度边缘信息的图像融合</p><ul><li>单个 Laplacian 边缘图只包含图像中某个尺度的边缘信息</li><li>所以将图像缩放，计算多尺度的边缘图，进行融合</li></ul></li></ul><h1 id="图像压缩"><a href="#图像压缩" class="headerlink" title="图像压缩"></a>图像压缩</h1><h2 id="三种冗余"><a href="#三种冗余" class="headerlink" title="三种冗余"></a>三种冗余</h2><p>P335，编码冗余、空间和时间冗余、不相关信息</p><h2 id="一些基本的压缩方法"><a href="#一些基本的压缩方法" class="headerlink" title="一些基本的压缩方法"></a>一些基本的压缩方法</h2><p>哈夫曼编码、算术编码、LZW 编码（课本 P348-P350）</p><h2 id="LZW-编码步骤"><a href="#LZW-编码步骤" class="headerlink" title="LZW 编码步骤"></a>LZW 编码步骤</h2><ul><li>在词典中搜索与输入字符串的当前位置形成最大匹配的词汇 w；</li><li>输出 w 的索引值；</li><li>把 wa 输入词典，其中 a 是最大匹配后面的字符</li><li>可用字典树加速查询最大匹配</li></ul><h3 id="代码实现-3"><a href="#代码实现-3" class="headerlink" title="代码实现"></a>代码实现</h3><pre><code class="hljs Go"><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-params">(c *Encoder)</span> <span class="hljs-title">Circle</span><span class="hljs-params">()</span></span> &#123;fmt.Println(<span class="hljs-string">"Start Encode Circle!"</span>)<span class="hljs-keyword">for</span> key, char := <span class="hljs-keyword">range</span> c.befComp &#123;outIndex, addflag, _ := c.Digest(char)<span class="hljs-keyword">if</span> addflag == <span class="hljs-literal">true</span> &#123;c.preString = []<span class="hljs-keyword">byte</span>&#123;&#125;c.preString = <span class="hljs-built_in">append</span>(c.preString, char)c.aftComp = <span class="hljs-built_in">append</span>(c.aftComp, outIndex)<span class="hljs-keyword">if</span> key == <span class="hljs-built_in">len</span>(c.befComp)<span class="hljs-number">-1</span> &#123;c.aftComp = <span class="hljs-built_in">append</span>(c.aftComp, char)&#125;&#125; <span class="hljs-keyword">else</span> &#123;<span class="hljs-comment">// 在末尾的时候特判</span><span class="hljs-keyword">if</span> key == <span class="hljs-built_in">len</span>(c.befComp)<span class="hljs-number">-1</span> &#123;<span class="hljs-comment">// c.preString = []byte&#123;&#125;</span>c.aftComp = <span class="hljs-built_in">append</span>(c.aftComp, outIndex)&#125;&#125;&#125;<span class="hljs-comment">// fmt.Println("Test print:")</span><span class="hljs-comment">// fmt.Println("before compression: ", c.befComp)</span><span class="hljs-comment">// fmt.Println("after compression: ", c.aftComp)</span>&#125;<span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-params">(c *Encoder)</span> <span class="hljs-title">Digest</span><span class="hljs-params">(scanChar <span class="hljs-keyword">byte</span>)</span> <span class="hljs-params">(outIndex <span class="hljs-keyword">byte</span>, flag <span class="hljs-keyword">bool</span>, err error)</span></span> &#123;<span class="hljs-comment">// 将Pre字符串和扫描的字符组合成为checkString</span>checkString := <span class="hljs-built_in">append</span>(c.preString, scanChar)<span class="hljs-comment">// 这列可以换成 lastroot 有待改进</span>nowPtr, isFind := c.FindTreeptr(checkString, c.root)<span class="hljs-keyword">if</span> isFind == <span class="hljs-literal">true</span> &#123;<span class="hljs-comment">// 变更pre continue</span><span class="hljs-comment">// 不做输出</span>c.preString = checkString<span class="hljs-keyword">return</span> <span class="hljs-keyword">byte</span>(nowPtr.index), <span class="hljs-literal">false</span>, <span class="hljs-literal">nil</span>&#125; <span class="hljs-keyword">else</span> &#123;<span class="hljs-comment">// 加入新结点</span>outIndex, err := c.AddTreeptr(nowPtr, scanChar)<span class="hljs-comment">// 先输出</span><span class="hljs-keyword">return</span> outIndex, <span class="hljs-literal">true</span>, err&#125;&#125;<span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-params">(c *Encoder)</span> <span class="hljs-title">FindTreeptr</span><span class="hljs-params">(leftString []<span class="hljs-keyword">byte</span>, treeRoot *TreeNode)</span> <span class="hljs-params">(addptr *TreeNode, flag <span class="hljs-keyword">bool</span>)</span></span> &#123;tempChar := leftString[<span class="hljs-number">0</span>]<span class="hljs-keyword">if</span> treeRoot.childNode[tempChar] != <span class="hljs-literal">nil</span> &#123;<span class="hljs-comment">// 已经有节点</span><span class="hljs-keyword">if</span> <span class="hljs-built_in">len</span>(leftString) == <span class="hljs-number">1</span> &#123;<span class="hljs-comment">// 返回本结点</span><span class="hljs-keyword">return</span> treeRoot.childNode[tempChar], <span class="hljs-literal">true</span>&#125; <span class="hljs-keyword">else</span> &#123;<span class="hljs-comment">// 递归</span><span class="hljs-keyword">return</span> c.FindTreeptr(leftString[<span class="hljs-number">1</span>:], treeRoot.childNode[tempChar])&#125;&#125; <span class="hljs-keyword">else</span> &#123;<span class="hljs-comment">// 未有节点</span><span class="hljs-comment">// 返回父亲结点（输出过程需要知道index）</span><span class="hljs-keyword">return</span> treeRoot, <span class="hljs-literal">false</span>&#125;&#125;<span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-params">(c *Encoder)</span> <span class="hljs-title">AddTreeptr</span><span class="hljs-params">(faptr *TreeNode, addchar <span class="hljs-keyword">byte</span>)</span> <span class="hljs-params">(outIndex <span class="hljs-keyword">byte</span>, err error)</span></span> &#123;outIndex = <span class="hljs-keyword">byte</span>(faptr.index)<span class="hljs-keyword">if</span> c.capacity &gt;= <span class="hljs-number">256</span> &#123;<span class="hljs-keyword">return</span> outIndex, errors.New(<span class="hljs-string">"Dictionary Full!"</span>)&#125;<span class="hljs-comment">// 由于获取父结点index需要所以这么操作</span>faptr.childNode[addchar] = <span class="hljs-built_in">new</span>(TreeNode)faptr.childNode[addchar].index = <span class="hljs-keyword">int</span>(c.capacity)c.capacity++<span class="hljs-comment">// c.dict[newIndex] =</span><span class="hljs-keyword">return</span> outIndex, <span class="hljs-literal">nil</span>&#125;</code></pre><h2 id="LZW-解码步骤"><a href="#LZW-解码步骤" class="headerlink" title="LZW 解码步骤"></a>LZW 解码步骤</h2><ul><li>解码步骤</li><li>初始化词典；</li><li>翻译首个索引值为 w，输出 w；</li><li>把 w？放入词典，其中？为待定字符；</li></ul><h3 id="代码实现-4"><a href="#代码实现-4" class="headerlink" title="代码实现"></a>代码实现</h3><pre><code class="hljs Go"><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-params">(c *Decoder)</span> <span class="hljs-title">Circle</span><span class="hljs-params">()</span></span> &#123;fmt.Println(<span class="hljs-string">"Start Decoder Circle!"</span>)<span class="hljs-keyword">for</span> _, value := <span class="hljs-keyword">range</span> c.befComp &#123;<span class="hljs-keyword">if</span> <span class="hljs-built_in">len</span>(c.storeString) == <span class="hljs-number">0</span> &#123;c.aftComp = <span class="hljs-built_in">append</span>(c.aftComp, value)<span class="hljs-comment">// 第一个 特判 变更storeString</span>c.storeString = <span class="hljs-built_in">append</span>(c.storeString, value)<span class="hljs-keyword">continue</span>&#125;<span class="hljs-comment">// 其他情况</span><span class="hljs-comment">// (错误)写： aftComp是byte切片   storeString 也是byte切片</span><span class="hljs-comment">// 先从字典获取现在值对应的字符串</span>lookUpString := c.dict[value]<span class="hljs-comment">// 加入输出</span>c.aftComp = <span class="hljs-built_in">append</span>(c.aftComp, []<span class="hljs-keyword">byte</span>(lookUpString)...)<span class="hljs-comment">// XX? 变成XXX</span><span class="hljs-comment">// 把查到的字典加进来</span><span class="hljs-keyword">if</span> flag := c.CheckDicFull(); flag == <span class="hljs-literal">true</span> &#123;<span class="hljs-keyword">continue</span>&#125; <span class="hljs-keyword">else</span> &#123;c.StoreDic(c.storeString, lookUpString)<span class="hljs-comment">// 将storeString 转化为当前 XX？</span>c.storeString = []<span class="hljs-keyword">byte</span>(lookUpString)&#125;&#125;&#125;<span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-params">(c *Decoder)</span> <span class="hljs-title">CheckDicFull</span><span class="hljs-params">()</span> <span class="hljs-params">(flag <span class="hljs-keyword">bool</span>)</span></span> &#123;<span class="hljs-keyword">if</span> <span class="hljs-built_in">len</span>(c.dict) == <span class="hljs-number">256</span> &#123;<span class="hljs-keyword">return</span> <span class="hljs-literal">true</span>&#125;<span class="hljs-keyword">return</span> <span class="hljs-literal">false</span>&#125;<span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-params">(c *Decoder)</span> <span class="hljs-title">StoreDic</span><span class="hljs-params">(original []<span class="hljs-keyword">byte</span>, prefix <span class="hljs-keyword">string</span>)</span></span> &#123;<span class="hljs-comment">// 原始+这次扫描的第一个byte（）</span>newcontent := <span class="hljs-built_in">append</span>(original, prefix[<span class="hljs-number">0</span>])length := <span class="hljs-built_in">len</span>(c.dict)fmt.Println(length, <span class="hljs-keyword">string</span>(newcontent))c.dict[<span class="hljs-keyword">byte</span>(length)] = <span class="hljs-keyword">string</span>(newcontent)&#125;</code></pre><h3 id="阶段总结"><a href="#阶段总结" class="headerlink" title="阶段总结"></a>阶段总结</h3><ul><li>行程编码是利用数据的稀疏分布特点进行编码</li><li>词典编码是根据词典将输入字符转换为对应词条的索引输出</li><li>LZW 方法在编码时根据输入的字符串动态生成词典</li><li>LZW 方法在解码时根据编码值和待定字符法进行词典的复原</li></ul><h2 id="LZ77-编码图解"><a href="#LZ77-编码图解" class="headerlink" title="LZ77 编码图解"></a>LZ77 编码图解</h2><p><img src="https://eddyblog.oss-cn-shenzhen.aliyuncs.com/ImageProcess/Review/Review_20.png" srcset="/img/loading.gif" alt="20"></p><ul><li>搜索缓存区远大于编码缓存区(32KB v.s. 258 Bytes)</li><li>成块地读取字符以减轻 I/O 负担</li><li>编码完成后采用哈夫曼法对三元组进行再编码</li><li>编码质量一般优于 LZW 法<ul><li>LZW 法的词典中存在没有使用的词汇</li><li>在 LZW 法中已经扫描过的字符不能重组为词汇</li></ul></li><li>应用非常广泛(zip, rar, gzip, png, arj)</li></ul><h3 id="阶段总结-1"><a href="#阶段总结-1" class="headerlink" title="阶段总结"></a>阶段总结</h3><ul><li>LZ77 是隐式词典法</li><li>LZ77 存储隐式词典增大后，编码效率降低的问题</li><li>窗口 LZ77 编码法同时限制隐式词典的大小和搜索缓冲区的大小，进而保证编码效率</li><li>LZ77 法的编码值是三元组，具有不随着词典增大而增大的优点</li><li>窗口 LZ77 编码的三元组定义具有特殊性</li></ul><h2 id="其他课件内容"><a href="#其他课件内容" class="headerlink" title="其他课件内容"></a>其他课件内容</h2><h3 id="DCT-相关"><a href="#DCT-相关" class="headerlink" title="DCT 相关"></a>DCT 相关</h3><p><img src="https://eddyblog.oss-cn-shenzhen.aliyuncs.com/ImageProcess/Review/Review_21.PNG" srcset="/img/loading.gif" alt="21"></p><p><img src="https://eddyblog.oss-cn-shenzhen.aliyuncs.com/ImageProcess/Review/Review_22.PNG" srcset="/img/loading.gif" alt="22"></p><p><img src="https://eddyblog.oss-cn-shenzhen.aliyuncs.com/ImageProcess/Review/Review_23.PNG" srcset="/img/loading.gif" alt="23"></p><p><img src="https://eddyblog.oss-cn-shenzhen.aliyuncs.com/ImageProcess/Review/Review_24.PNG" srcset="/img/loading.gif" alt="24"></p><p><img src="https://eddyblog.oss-cn-shenzhen.aliyuncs.com/ImageProcess/Review/Review_25.PNG" srcset="/img/loading.gif" alt="25"></p><p><img src="https://eddyblog.oss-cn-shenzhen.aliyuncs.com/ImageProcess/Review/Review_26.PNG" srcset="/img/loading.gif" alt="26"></p><p><img src="https://eddyblog.oss-cn-shenzhen.aliyuncs.com/ImageProcess/Review/Review_27.PNG" srcset="/img/loading.gif" alt="27"></p><p><img src="https://eddyblog.oss-cn-shenzhen.aliyuncs.com/ImageProcess/Review/Review_28.PNG" srcset="/img/loading.gif" alt="28"></p><h3 id="常见压缩思路"><a href="#常见压缩思路" class="headerlink" title="常见压缩思路"></a>常见压缩思路</h3><ul><li>二值图像压缩思路：行程编码</li><li>灰度值图像压缩思路：<ul><li>设置阈值转换为 n 幅二值图像，分别用游程编码压缩</li><li>用预测编码法，降低图像的信息熵，如简单的 yt+1=yt</li><li>变换编码法（如离散余弦变换 DCT）</li></ul></li><li>真彩色图像的压缩思路：RGB 分为三幅灰度图像转灰度图像压缩。</li></ul><h3 id="常见图片压缩格式实现思路"><a href="#常见图片压缩格式实现思路" class="headerlink" title="常见图片压缩格式实现思路"></a>常见图片压缩格式实现思路</h3><p><img src="https://eddyblog.oss-cn-shenzhen.aliyuncs.com/ImageProcess/Review/Review_29.PNG" srcset="/img/loading.gif" alt="29"></p><p><img src="https://eddyblog.oss-cn-shenzhen.aliyuncs.com/ImageProcess/Review/Review_30.PNG" srcset="/img/loading.gif" alt="30"></p><p><img src="https://eddyblog.oss-cn-shenzhen.aliyuncs.com/ImageProcess/Review/Review_31.PNG" srcset="/img/loading.gif" alt="31"></p><p><img src="https://eddyblog.oss-cn-shenzhen.aliyuncs.com/ImageProcess/Review/Review_32.PNG" srcset="/img/loading.gif" alt="32"></p><p><img src="https://eddyblog.oss-cn-shenzhen.aliyuncs.com/ImageProcess/Review/Review_33.PNG" srcset="/img/loading.gif" alt="33"></p><p><img src="https://eddyblog.oss-cn-shenzhen.aliyuncs.com/ImageProcess/Review/Review_34.PNG" srcset="/img/loading.gif" alt="34"></p><p><img src="https://eddyblog.oss-cn-shenzhen.aliyuncs.com/ImageProcess/Review/Review_35.PNG" srcset="/img/loading.gif" alt="35"></p><h1 id="图像形态学"><a href="#图像形态学" class="headerlink" title="图像形态学"></a>图像形态学</h1><h2 id="概述"><a href="#概述" class="headerlink" title="概述"></a>概述</h2><ul><li>形态学一般指生物学中研究动物和植物结构的一个分支</li><li>用数学形态学（也称图像代数）表示以形态为基础对图像进行分析的数学工具</li><li>基本思想是用具有一定形态的结构元素去度量和提取图像中的对应形状以达到对图像分析和识别的目的</li><li>形态学图像处理的数学基础和所用语言是集合论</li><li>形态学图像处理的应用可以简化图像数据，保持它们基本的形状特性，并除去不相干的结构</li><li>形态学图像处理的主要运算有 4 个：膨胀、腐蚀、开操作和闭操作</li></ul><h2 id="四种运算"><a href="#四种运算" class="headerlink" title="四种运算"></a>四种运算</h2><p><img src="https://eddyblog.oss-cn-shenzhen.aliyuncs.com/ImageProcess/Review/Review_36.PNG" srcset="/img/loading.gif" alt="36"></p><p><img src="https://eddyblog.oss-cn-shenzhen.aliyuncs.com/ImageProcess/Review/Review_37.PNG" srcset="/img/loading.gif" alt="37"></p><p><img src="https://eddyblog.oss-cn-shenzhen.aliyuncs.com/ImageProcess/Review/Review_38.PNG" srcset="/img/loading.gif" alt="38"></p><p><img src="https://eddyblog.oss-cn-shenzhen.aliyuncs.com/ImageProcess/Review/Review_39.PNG" srcset="/img/loading.gif" alt="39"></p><p><img src="https://eddyblog.oss-cn-shenzhen.aliyuncs.com/ImageProcess/Review/Review_40.PNG" srcset="/img/loading.gif" alt="40"></p><ul><li>开操作的 3 条性质<ul><li>AoB 是 A 的子集合</li><li>如果 C 是 D 的子集，则 CoB 是 DoB 的子集</li><li>(AoB)oB= AoB</li></ul></li><li>闭操作的 3 条性质<ul><li>A 是 A•B 的子集合</li><li>如果 C 是 D 的子集，则 C•B 是 D•B 的子集</li><li>(A•B)•B= A•B</li></ul></li></ul><h2 id="形态学主要应用"><a href="#形态学主要应用" class="headerlink" title="形态学主要应用"></a>形态学主要应用</h2><p>边界提取：B 先对 A 腐蚀，A 减去腐蚀得到边界</p><p>区域填充：</p><p>联通分量提取</p><h1 id="图像分割"><a href="#图像分割" class="headerlink" title="图像分割"></a>图像分割</h1><h2 id="概述-1"><a href="#概述-1" class="headerlink" title="概述"></a>概述</h2><p>分割的目的：将图像<strong>划分</strong>为不同<strong>区域</strong>。</p><p>三大类方法：</p><ul><li>根据区域间灰度不连续搜寻区域之间的边界，在间断检测、边缘连接和边界检测介绍</li><li>以像素性质的分布进行阈值处理，在阈值处理介绍</li><li>直接搜寻区域进行分割，在基于区域的分割中介绍</li></ul><p>Q&amp;A：多尺度的边缘检测仍然需要选择确定的尺度，不能智能辨识。</p><h3 id="间断检测类型"><a href="#间断检测类型" class="headerlink" title="间断检测类型"></a>间断检测类型</h3><p>点检测、线检测、边缘检测</p><p>差分、数值微分：$\partial$ 一阶对应线检测、二阶对应点检测</p><h3 id="间断检测：拉普拉斯算子"><a href="#间断检测：拉普拉斯算子" class="headerlink" title="间断检测：拉普拉斯算子"></a>间断检测：拉普拉斯算子</h3><script type="math/tex; mode=display">∇^2f ＝4z_5 - (z_2 + z_4 + z_6 + z_8)</script><script type="math/tex; mode=display">∇^2f ＝8z_5 - (z_1 + z_2 + z_3 + z_4 + z_5 + z_6 + z_7 + z_8 + z_9)</script><ul><li>缺点：<ul><li>拉普拉斯算子对噪声具有敏感性</li><li>拉普拉斯算子的幅值产生双边缘</li><li>拉普拉斯算子不能检测边缘的方向</li></ul></li><li>优点：<ul><li>可以利用零交叉的性质进行边缘定位</li><li>可以确定一个像素是在边缘暗的一边还是亮的一边</li></ul></li></ul><p>Derivative of Gaussian Filter</p><p>根据交换律，先进性高斯模糊核与边缘提取核先计算，从而减少整体的计算量。</p><p>课后探索：边缘提取：Canny 算法 Mask-RCNN</p><h1 id="彩色图像"><a href="#彩色图像" class="headerlink" title="彩色图像"></a>彩色图像</h1><h2 id="色彩的本质"><a href="#色彩的本质" class="headerlink" title="色彩的本质"></a>色彩的本质</h2><p>人对色彩的感知：视杆细胞，视锥细胞</p><p>色彩空间（英语：Color space）是对色彩的组织方式。借助色彩空间和针对物理设备的测试，可以得到色彩的固定模拟和数字表示。色彩空间可以只通过任意挑选一些颜色来定义，比如像彩通系统就只是把一组特定的颜色作为样本，然后给每个颜色定义名字和代码；也可以是基于严谨的数学定义，比如 Adobe RGB、sRGB。</p><p>CIE 1931 xyz 是第一次人眼对色彩感知度量建立色彩空间的尝试，几乎所有其它色彩空间的基础。有一些变体。</p><ul><li>CIELUV</li><li>CIE L*A*B* 基于人眼</li></ul><p>RGB 加法混色法，从暗处叠加产生颜色（sRGB，Adobe RGB）</p><p>CMYK 减法混色法</p><p>HSV 艺术家们常用，使用色相饱和度和明度<br>HSL 用亮度（Lightness）代替明度（Value/Brightness）</p><h1 id="其他讨论区问题"><a href="#其他讨论区问题" class="headerlink" title="其他讨论区问题"></a>其他讨论区问题</h1><h2 id="调研-C-C-语言中-main-函数的两个常见参数的意义和用法，将调研结果写在下面的讨论区"><a href="#调研-C-C-语言中-main-函数的两个常见参数的意义和用法，将调研结果写在下面的讨论区" class="headerlink" title="调研 C/C++语言中 main 函数的两个常见参数的意义和用法，将调研结果写在下面的讨论区"></a>调研 C/C++语言中 main 函数的两个常见参数的意义和用法，将调研结果写在下面的讨论区</h2><p>主函数程序应当含有一个名为 main 的全局函数，它被指定为程序的启动点。它应当有下列形式之一：</p><pre><code class="hljs C++"><span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">main</span> <span class="hljs-params">()</span> </span>&#123; body &#125; (<span class="hljs-number">1</span>)<span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">main</span> <span class="hljs-params">(<span class="hljs-keyword">int</span> argc, <span class="hljs-keyword">char</span> _argv[])</span> </span>&#123; body &#125; (<span class="hljs-number">2</span>)<span class="hljs-comment">// 其他由实现定义的形式，返回类型为 int (3)</span></code></pre><ul><li>argc - 非负数，表示从程序运行的环境传递给程序的实参个数。</li><li><p>argv - 指针，指向包含 argc + 1 个指针的数组的首元素。数组末元素为空指针，若其前面有任何元素，则它们指向空终止多字节字符串，表示从执行环境传递给程序的若干参数。若 argv[0] 不是空指针，或等价地 argc &gt; 0 ，则它指向表示用于调用程序的名称的字符串，或空字符串。</p></li><li><p>body - 主函数的函数体<br>名字 argc 和 argv 是任取的，而且形参的类型的表示方式也是：int main(int ac, char** av) 同样合法。</p></li></ul><p>main() 的一种常见的由实现定义的形式还有（除 argc 和 argv 之外的）第三个参数，类型为 char*[] ，指向指向执行环境变量的指针数组。</p>]]></content>
    
    
    <categories>
      
      <category>Computer Science</category>
      
      <category>数字图像处理</category>
      
    </categories>
    
    
    <tags>
      
      <tag>数字图像处理</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>数字图像处理——色彩</title>
    <link href="/post/2af9aa70.html"/>
    <url>/post/2af9aa70.html</url>
    
    <content type="html"><![CDATA[<h1 id="彩色图像"><a href="#彩色图像" class="headerlink" title="彩色图像"></a>彩色图像</h1><h2 id="色彩的本质"><a href="#色彩的本质" class="headerlink" title="色彩的本质"></a>色彩的本质</h2><p>人对色彩的感知：视杆细胞，视锥细胞</p><p>色彩空间（英语：Color space）是对色彩的组织方式。借助色彩空间和针对物理设备的测试，可以得到色彩的固定模拟和数字表示。色彩空间可以只通过任意挑选一些颜色来定义，比如像彩通系统就只是把一组特定的颜色作为样本，然后给每个颜色定义名字和代码；也可以是基于严谨的数学定义，比如 Adobe RGB、sRGB。</p><p>CIE 1931 xyz 是第一次人眼对色彩感知度量建立色彩空间的尝试，几乎所有其它色彩空间的基础。有一些变体。</p><ul><li>CIELUV</li><li>CIE L*A*B* 基于人眼</li></ul><p>RGB 加法混色法，从暗处叠加产生颜色（sRGB，Adobe RGB）</p><p>CMYK 减法混色法</p><p>HSV 艺术家们常用，使用色相饱和度和明度<br>HSL 用亮度（Lightness）代替明度（Value/Brightness）</p><h1 id="数字图像处理考试安排"><a href="#数字图像处理考试安排" class="headerlink" title="数字图像处理考试安排"></a>数字图像处理考试安排</h1><ul><li>选择题 10/20 分</li><li>填空题 5/10 分</li><li>简答题 5/20 分</li><li>分析设计题 2/10 分<ul><li>主要来源：学习平台上的代码</li></ul></li></ul><p>18 周周三 12.25 下午考</p>]]></content>
    
    
    <categories>
      
      <category>Computer Science</category>
      
      <category>数字图像处理</category>
      
    </categories>
    
    
    <tags>
      
      <tag>数字图像处理</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>数字图像处理——图像分割</title>
    <link href="/post/fe69cba9.html"/>
    <url>/post/fe69cba9.html</url>
    
    <content type="html"><![CDATA[<h1 id="图像分割"><a href="#图像分割" class="headerlink" title="图像分割"></a>图像分割</h1><p>科研的主要方向：<strong>分割</strong>、识别、跟踪</p><p>主要期刊会议：ICIP（数字图像向）、CVPR（计算机视觉）、ICCV（计算机视觉）</p><p>数字图像处理（Image Process）与计算机视觉（Computer Vision）存在大量的交叠。</p><p>本章要点：概述、边缘连接和边界检测、阈值处理（前述提到）、基于区域的分割（较新）、分割中运动的应用（较新）。</p><h2 id="概述"><a href="#概述" class="headerlink" title="概述"></a>概述</h2><p>分割的目的：将图像<strong>划分</strong>为不同<strong>区域</strong>。</p><p>三大类方法：</p><ol><li>根据区域间灰度不连续搜寻区域之间的边界，在边缘检测、边缘连接和边界检测介绍</li><li>以像素性质分布进行阈值处理，在阈值处理介绍</li><li>直接搜寻区域进行分割，在基于区域的分割中介绍</li></ol><p>Q&amp;A：多尺度的边缘检测仍然需要选择确定的尺度，不能智能辨识。</p><h3 id="间断检测"><a href="#间断检测" class="headerlink" title="间断检测"></a>间断检测</h3><p>点检测、线检测、边缘检测</p><p>差分、数值微分：$\partial$ 一阶对应线检测、二阶对应点检测</p><p>Derivative of Gaussian Filter</p><p>根据交换律，先进性高斯模糊核与边缘提取核先计算，从而减少整体的计算量。</p><p>课后探索：边缘提取：Canny 算法 Mask-RCNN</p>]]></content>
    
    
    <categories>
      
      <category>Computer Science</category>
      
      <category>数字图像处理</category>
      
    </categories>
    
    
    <tags>
      
      <tag>数字图像处理</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>机器学习——PCA原理研究</title>
    <link href="/post/b17c259a.html"/>
    <url>/post/b17c259a.html</url>
    
    <content type="html"><![CDATA[<h1 id="PCA-原理研究"><a href="#PCA-原理研究" class="headerlink" title="PCA 原理研究"></a>PCA 原理研究</h1><p>前两次课介绍 PCA，大家应该对主成分分析降维有了一定的了解，我还有两个问题没有解决，课下自己查阅了些资料。</p><ol><li>主成分分析步骤是如何推导出来的？</li><li>协方差矩阵的 n-1 如何了解？</li></ol><h2 id="主成分分析步骤的推导"><a href="#主成分分析步骤的推导" class="headerlink" title="主成分分析步骤的推导"></a>主成分分析步骤的推导</h2><p>PPT 上和老师分享的视频实际上在开头都有描述，较为简略。由于我们更关注 PCA 的实际操作步骤，更容易如何求矩阵的特征值和特征向量，不过这样，容易忽略：<strong>我们为什么要做矩阵正交化</strong>？我们需要回到优化目标上。</p><p>思路梳理</p><p>降维 -&gt; 基变换、投影</p><p>分散-&gt; 投影的方差最大</p><p>保留特征-&gt; 基重叠最少-&gt; 基正交（如果能找到）</p><p>引入优化目标：寻找 K 维的新正交基，使得数据变换到这组基上后方差值最大。</p><p>优化目标的实现：</p><p>上面我们导出了优化目标，但是这个目标似乎不能直接作为操作指南（或者说算法），因为它只说要什么，但根本没有说怎么做。所以我们要继续在数学上研究计算方案。</p><p>我们发现最终要达到的目的与字段内方差及字段间协方差有密切关系。</p><p>用<strong>协方差矩阵</strong>来描述我们的优化目标：</p><p>优化目标矩阵对角化等价</p><p>寻找矩阵对角化方式</p><p>求特征值，特征向量。</p><h3 id="协方差矩阵对角化"><a href="#协方差矩阵对角化" class="headerlink" title="协方差矩阵对角化"></a>协方差矩阵对角化</h3><p>根据上述推导，我们发现要达到优化目前，等价于将协方差矩阵对角化：即除对角线外的其它元素化为 0，并且在对角线上将元素按大小从上到下排列，这样我们就达到了优化目的。这样说可能还不是很明晰，我们进一步看下原矩阵与基变换后矩阵协方差矩阵的关系：</p>]]></content>
    
    
    <categories>
      
      <category>Computer Science</category>
      
      <category>机器学习</category>
      
    </categories>
    
    
    <tags>
      
      <tag>机器学习</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>计算机图形学——复习</title>
    <link href="/post/1cc3e298.html"/>
    <url>/post/1cc3e298.html</url>
    
    <content type="html"><![CDATA[<h1 id="第一讲-绪论"><a href="#第一讲-绪论" class="headerlink" title="第一讲 绪论"></a>第一讲 绪论</h1><h2 id="什么是计算机图形学"><a href="#什么是计算机图形学" class="headerlink" title="什么是计算机图形学"></a>什么是计算机图形学</h2><p>计算机图形学(Computer Graphics，简称CG)的内容比较丰富，与很多学科都有交叉，因此笔者认为是无法严格定义的。</p><p>在“Wiki百科”和“百度百科”上，对“计算机图形学”的解释为：计算机图形学是一种使用数学算法将二维或三维图形转化为计算机显示器的栅格形式的科学。简单地说，计算机图形学的主要研究内容就是研究如何在计算机中表示图形、以及利用计算机进行图形的计算、处理和显示的相关原理与算法。狭义地理解，计算机图形学是数字图象处理或计算机视觉的逆过程。</p><h2 id="图形学的研究对象"><a href="#图形学的研究对象" class="headerlink" title="图形学的研究对象"></a>图形学的研究对象</h2><p>图形：能在人的视觉系统中产生视觉印象的客观对象</p><h2 id="图形学的目的"><a href="#图形学的目的" class="headerlink" title="图形学的目的"></a>图形学的目的</h2><p>在计算机中表示、生成、处理和显示图形</p><h2 id="和其他学科交叉"><a href="#和其他学科交叉" class="headerlink" title="和其他学科交叉"></a>和其他学科交叉</h2><ul><li>数字图像处理：利用计算机对数字图像处理进行底层信息处理</li><li>计算机视觉：从数字图像中提取高层次信息</li><li>计算机图形学：将各层次信息表达为视觉元素</li><li>趋势：这些学科方向不断的交叉融入，形成一个更大的学科方向，可称之为“可视计算”(Visual Computing)</li></ul><h2 id="计算机图形学的主要研究内容"><a href="#计算机图形学的主要研究内容" class="headerlink" title="计算机图形学的主要研究内容"></a>计算机图形学的主要研究内容</h2><h3 id="建模（Modeling）"><a href="#建模（Modeling）" class="headerlink" title="建模（Modeling）"></a>建模（Modeling）</h3><ul><li>在计算机中表达、生成与处理三维模型的数据结构与算法</li><li>三维模型的生成方法是当前的热点问题，图形学大众化应用的关键技术难题</li><li>主要采取的方法：<ul><li>计算机辅助设计（CAD）中的主流方法是采用NURBS方法，存在如非正规曲面光滑拼合，复杂曲面表达等问题仍未解决</li><li>戏份曲面造型方法，离散迭代曲面构造方法，过程朴素简单实现容易。</li></ul></li></ul><h3 id="渲染（Rendering）"><a href="#渲染（Rendering）" class="headerlink" title="渲染（Rendering）"></a>渲染（Rendering）</h3><ul><li>有了模型场景，怎么画出来产生图像，这个核心任务就是渲染要解决的。</li><li>常用的真实感绘制方法：光线追踪方法和辐射度方法。</li><li>各种渲染技术：全局光照模型、Photo mapping、BTF、BRDF、基于GPU的渲染技术</li></ul><h3 id="动画（Animation）"><a href="#动画（Animation）" class="headerlink" title="动画（Animation）"></a>动画（Animation）</h3><ul><li>讲义中pass了，也非课程重点</li><li>中科大教授解释：连续播放静止图像产生物体运动的效果，制作景物动画，高度物理真实感动态模拟（如各种形变、燃烧爆炸老化等）</li></ul><h3 id="人机交互"><a href="#人机交互" class="headerlink" title="人机交互"></a>人机交互</h3><p>HCI，人与计算机之间以一定的交互方式活交互界面，来完成确定任务的人与计算机之间的信息交换过程。</p><p>其他：渲染只讲了光线追踪相关，额外的没有拓展、GAMS</p><h1 id="第二讲-三维模型"><a href="#第二讲-三维模型" class="headerlink" title="第二讲 三维模型"></a>第二讲 三维模型</h1><h2 id="几何建模"><a href="#几何建模" class="headerlink" title="几何建模"></a>几何建模</h2><p>在计算机中表达一个真实世界的三维对象或虚拟三维形象，就必须先描述其形状。</p><p>几何建模：三维对象的表达、构造和处理的计算机算法和过程。</p><p>离散化数字化几何数据：</p><ul><li>易于表达和传输</li><li>渲染硬件和软件的基础数据</li><li>大多数获取设备的输出格式</li><li>大多数模拟/分析工具需要的输入</li></ul><p>走样（aliasing）：用离散数量像素表示连续的量而引起的失真，称为走样。</p><p>反走样（在图形显示过程中，用于减少或消除走样的方法），方法：提高分辨率、非加权区域采样、加权区域采样。和某个像素求交，计算相交区域面积，确定像素值。</p><p>OpenGL反走样：glEnable(GL_BLEND) //启用混合 glEnable(GL_LINE_SMOOTH) //启用线段反走样</p><h2 id="3D模型表达"><a href="#3D模型表达" class="headerlink" title="3D模型表达"></a>3D模型表达</h2><ul><li>原始数据：体素、点云、深度图像、多边形</li><li>实体模型：八叉树、BSP树、CSG、Sweep</li><li>曲面：曲面王哥、细分曲面、参数曲面、隐式曲面</li><li>高层次语义结构：Scene Graph</li></ul><h2 id="什么是网格（Mesh）"><a href="#什么是网格（Mesh）" class="headerlink" title="什么是网格（Mesh）"></a>什么是网格（Mesh）</h2><ul><li>图形学中最常用的表达</li><li>简单</li><li>可表达复杂形状</li><li>图形硬件支持</li><li>一般为三角网格</li></ul><p>为什么是三角网格</p><ul><li>其他多边形网格可以容易剖分为三角形</li><li>三点共面：保证平面性</li><li><p>可以容易地定义内外方向、插值操作等</p><p>一些概念</p></li><li><p>边界边：只与一个面相邻</p></li><li>正则边：与且仅与两个面相邻</li><li>奇异边：与多于两个面相邻</li><li>流行网络：没有奇异边的网格</li><li>封闭网络：没有边界边的网格</li></ul><p>v+f-e = 2(c-g) - b</p><h2 id="网格的数据结构表达"><a href="#网格的数据结构表达" class="headerlink" title="网格的数据结构表达"></a>网格的数据结构表达</h2><p>应用：渲染、几何查询（点面关系）、几何操作。大部分网格难以支持高效的上述操作，一般采用三角流行网格。</p><p>判断网格的数据结构是否优秀：</p><ul><li>构建数据结构的时间复杂度（建立时间复杂度）</li><li>进行一个查询操作的时间复杂度（查询时间复杂度）</li><li>进行一个网格编辑操作的时间复杂度（更新时间复杂度）</li><li>空间复杂度</li></ul><p>数据结构表示举例</p><ul><li>面列表：<ul><li>顶点列表：（x,y,z坐标）</li><li>面列表：逆时针顶点三元组（v1，v2，v3）</li><li>查询复杂度：面包含顶点O(1),顶点相邻O(n)</li><li>优点：方便紧凑、可表达非流形网络</li><li>缺点：不能有效地支持点、面之间的邻接关查询</li></ul></li><li>邻接矩阵<ul><li>顶点列表+表示顶点相邻的邻接矩阵</li><li>查询复杂度：面包含顶点O(1),顶点相邻O(1),顶点与面相邻O(n)</li><li>优点：支持vv的高效查询、支持非流形网络</li><li>缺点：没有边的显示逼到啊，不支持如vf，ve，ev等的快速查询</li></ul></li><li>半边结构<ul><li>流行于大部分几何建模应用</li><li>优点：所有查询操作时间复杂度均为O(1)，所有编辑操作时间复杂度均为O(1)</li><li>缺点：只能表达流形网络</li></ul></li></ul><p><strong>面列表、邻接表（矩阵）、半边结构。 仔细了解，明白优劣，能写代码。</strong></p><p>细分曲面</p><p>虽然理论上可以手动地设定每一个顶点、边、面，但这是异常繁琐的。理想的情况：手工构造一个低分辨率的网格，然后逐渐地用自动化算法光滑化，添加更多细节。</p><p>细分曲线、NURBS、隐式曲面、实体建模（CSG）</p><h2 id="几何建模经典方法（常用的建模方法）"><a href="#几何建模经典方法（常用的建模方法）" class="headerlink" title="几何建模经典方法（常用的建模方法）"></a>几何建模经典方法（常用的建模方法）</h2><ul><li><p>扫描</p><ul><li>构造一个对象的三维模型需要一张或多张深度图像</li><li>距离扫描仪测量的是物体表面的三维坐标，并以m*n的距离网格形式返回测量值， 这个网格称作深度图像</li><li>如果有多张深度图像，对每张图像需要计算出一个刚性变换，以与其他深度图像对齐</li><li>使用改进版本ICP算法来计算合适的刚性变换，使得两张深度图像之间点对的最小二乘距离最小</li></ul></li><li><p>基于图像的建模</p><ul><li>从海量图片中构造三维模型</li><li>利用计算机诗句的方法来估计每张照片的相对摄影机位置与朝向，同时得到对象的稀疏点云表达</li><li>基本的思想：一个点的位置可以通过多张不同位置拍摄的照片确定</li><li>给定了这些相机参数和稀疏的点云，有许多致密的重建算法可以用来重建致密的模型</li></ul></li><li><p>过程式建模</p><ul><li>使用算法创建模型</li><li>可容易地构造多样化的模型</li><li>一般用来构造复杂的、规则性强的模型（地形、植物、建筑、城市）</li><li>用一个小的数据集或规则来描述目标模型的高层次语义信息</li><li>用算法来生成全部的模型（加入随机性，递归算法）</li><li>L-system 用来进行植物建模典型系统<ul><li>递归的形式化语法（符号字母表、生成规则集、非端点富豪递归地生成新的符号或符号序列）</li><li>整个过程从一个初符号开始，最后由一个解释器将生成的符号解释为几何结构。</li></ul></li><li>分形<ul><li>从一个形状开始，用缩放的初始形状来替换形状的一部分</li><li>递归地进行替换</li></ul></li></ul></li></ul><h2 id="几何建模应用举例"><a href="#几何建模应用举例" class="headerlink" title="几何建模应用举例"></a>几何建模应用举例</h2><ul><li>去燥/光滑化<ul><li>输入一个带有噪声的网格，输出一个光滑的网格</li><li>目标是去掉高频信息</li></ul></li><li>网格简化<ul><li>网格常常包含了比需要显示质量更多的面片（一些网格生成算法的分辨率是固定的，不考虑曲面细节，网格可能会在不同的设备上使用）</li><li>因此，网格简化的目的是在保持视觉准确性的前提下减少面片的数量</li></ul></li><li>网格编辑</li><li>网格分割（将网格分割成有意义的部分）</li></ul><p>网格、网格的典型数据结构、几何建模典型方法、几何建模典型应用。</p><p>重点讲网格，网格的重要属性。</p><p>半边结构只能表达流形网格。</p><p>NERBS 曲线 曲面。</p><h1 id="第三讲-OpenGL-编程"><a href="#第三讲-OpenGL-编程" class="headerlink" title="第三讲 OpenGL 编程"></a>第三讲 OpenGL 编程</h1><p>OpenGL 绘制几何图元</p><p>改变状态、指定绘图元素</p><h1 id="第四讲-数学基础回顾"><a href="#第四讲-数学基础回顾" class="headerlink" title="第四讲 数学基础回顾"></a>第四讲 数学基础回顾</h1><p>重心坐标、插值</p><p>线性代数：向量变换，矩阵板换</p><h1 id="第五讲"><a href="#第五讲" class="headerlink" title="第五讲"></a>第五讲</h1><h2 id="照相机与OpenGL渲染管线"><a href="#照相机与OpenGL渲染管线" class="headerlink" title="照相机与OpenGL渲染管线"></a>照相机与OpenGL渲染管线</h2><p>模型变换-摆放物体——从物体坐标系到世界坐标系</p><p>视图变换-摆放相机——从世界坐标系到相机坐标系</p><p>投影变换-调整焦距——确定放大倍数</p><p>视口变换-选择底片——确定照片大小</p><p>视图变换——相当于把照相机固定在三脚架上，并使它对准场景。模型变换——设置模型的位置和方向。如何选择？本质上是一致的，把这两种变换割裂开来是没有意义的，有时候使用一种变换要比使用另外一种变换要方便得多。</p><h2 id="变换"><a href="#变换" class="headerlink" title="变换"></a>变换</h2><p>模型变换-摆放物体</p><p>二维变换变换的矩阵表示，矩阵蕴含表达式（图 ）</p><p><strong>旋转的矩阵表达（图）</strong></p><p><strong>缩放的矩阵表达（图）</strong></p><p><strong>平移的矩阵表达（图）</strong></p><p><strong>齐次坐标</strong>：扩展一维，看上去不自然，但是使得图形学中的变换操作更简便</p><h2 id="为什么要用采用齐次坐标"><a href="#为什么要用采用齐次坐标" class="headerlink" title="为什么要用采用齐次坐标"></a>为什么要用采用齐次坐标</h2><ul><li>将平移、旋转和缩放等仿射变换统一为矩阵乘法操作</li><li>在软硬件实现上更简单</li><li>注意顺序</li><li>齐次坐标 1 和 0 表示什么（区分坐标和向量0向量1坐标）</li></ul><h2 id="视图变换与模型变换"><a href="#视图变换与模型变换" class="headerlink" title="视图变换与模型变换"></a>视图变换与模型变换</h2><ul><li>三维齐次坐标下三维旋转与缩放（图，隔一层右上-sin，隔两层左下-sin）</li><li>绕任意轴进行旋转（图）<ul><li>v旋转（绕x轴）旋转到xz平面（Rx）</li><li>v旋转（绕y轴）旋转到z轴（Ry）</li><li>绕v旋转一角度 </li><li>前面变换坐标的逆（旋转矩阵的转置是旋转矩阵的逆）</li></ul></li></ul><h2 id="投影变换"><a href="#投影变换" class="headerlink" title="投影变换"></a>投影变换</h2><ul><li>投影变换定义了一个视景体（视景体决定了一个物体是如何映射到屏幕上的，视景体定义了场景中的哪些部分被裁剪到最终的图像之外）</li><li>正交投影 glOrtho()<ul><li>成像尺寸不随深度改变</li><li>正交投影将z方向坐标变换为0</li></ul></li><li>透视投影 glPerspective()<ul><li>z方向坐标对x、y方向坐标剪向形变的影响</li></ul></li></ul><h2 id="齐次坐标系"><a href="#齐次坐标系" class="headerlink" title="齐次坐标系"></a>齐次坐标系</h2><ul><li>齐次坐标的第四维可以是任意非零值</li><li>齐次坐标的四个维度同时乘以一个非零值，所表达的对象（点）不变</li><li>当齐次坐标等于0<ul><li>表达无穷远处的“点”</li><li>表达一个向量</li><li>不受平移影响<h2 id="直线透视（透视除法）"><a href="#直线透视（透视除法）" class="headerlink" title="直线透视（透视除法）"></a>直线透视（透视除法）</h2></li></ul></li></ul><h2 id="视口变换"><a href="#视口变换" class="headerlink" title="视口变换"></a>视口变换</h2><ul><li>选择窗口中的绘图区域</li><li>对应于选择被冲洗照片的大小</li></ul><p>glViewport</p><ul><li>注意视口的纵横比与视景体的纵横比保持一致</li></ul><h2 id="操纵矩阵堆栈"><a href="#操纵矩阵堆栈" class="headerlink" title="操纵矩阵堆栈"></a>操纵矩阵堆栈</h2><p>矩阵的操作还需要复习</p><p>void glPushMatrix 复制栈顶矩阵<br>void glPopMatrix 丢弃栈顶矩阵</p><pre><code class="hljs C++">draw_car_body();glPushMatrix();    glTranslate();    draw_wheel_and_bolte_1();glPopMatrix();glPushMatrix();    glTranslate();    draw_wheel_and_bolte_2();glPopMatrix();</code></pre><h1 id="第六讲-纹理贴图（Texture）"><a href="#第六讲-纹理贴图（Texture）" class="headerlink" title="第六讲 纹理贴图（Texture）"></a>第六讲 纹理贴图（Texture）</h1><h2 id="为什么要纹理贴图"><a href="#为什么要纹理贴图" class="headerlink" title="为什么要纹理贴图"></a>为什么要纹理贴图</h2><p>我们如何给模型添加更多的细节？</p><ul><li>添加更多的几何元素：更多的三角面片<ul><li>优点：在光照和其它表面交互中具有真实的表现</li><li>缺点：难以生成，并消耗更多的存储和计算资源</li></ul></li><li>将纹理映射到模型上<ul><li>优点：使用简单、方便，消耗的资源少，可重用</li><li>缺点：过于简化、表面几何仍然是光滑的</li></ul></li></ul><h2 id="什么是纹理"><a href="#什么是纹理" class="headerlink" title="什么是纹理"></a>什么是纹理</h2><ul><li>计算机图形学的定义（广义）：以图像（包括二维和三维）方式存储的资源，如位图等。</li><li>纹理合成的定义（狭义）：具有某种重复模式的图像</li></ul><h2 id="纹理贴图的形式化描述"><a href="#纹理贴图的形式化描述" class="headerlink" title="纹理贴图的形式化描述"></a>纹理贴图的形式化描述</h2><ul><li>从模型表面S到二维参数域U的映射函数</li><li>$f: S \rightarrow U$</li><li>给定模型表面S上任一点p，均有f(p)属于U</li><li>这个映射称为纹理映射</li><li>S上的顶点在U中的坐标称为纹理坐标</li><li>纹理图像与参数域U之间存在自然的映射</li></ul><p>几何图形表面材质，表达方法。</p><p>从模型表面到二维参数的映射函数</p><p><strong>球面全局参数化。</strong></p><h2 id="启用纹理贴图功能"><a href="#启用纹理贴图功能" class="headerlink" title="启用纹理贴图功能"></a>启用纹理贴图功能</h2><pre><code class="hljs C++"><span class="hljs-comment">//清理缓存</span>glClear(GL_COLOR_BUFFER_BIT|GL_DEPTH_BUFFER_BIT);<span class="hljs-comment">//启用纹理贴图</span>glEnable(GL_TEXTURE_2D);<span class="hljs-comment">//指定纹理贴图与材质的混合模式</span>glTexEnvf(GL_TEXTURE_ENV, AGL_TEXTURE_ENV_MODE,GL_DECAL);<span class="hljs-comment">//绑定纹理</span>glBindTexture(GL_TEXTURE_2D, texName);<span class="hljs-comment">//绘制场景 提供纹理坐标和几何坐标</span>glBegin(GL_QUADS);   glTexCoord2f(<span class="hljs-number">0.0</span>, <span class="hljs-number">0.0</span>); glVertex3f(<span class="hljs-number">-2.0</span>, <span class="hljs-number">-1.0</span>, <span class="hljs-number">0.0</span>);   glTexCoord2f(<span class="hljs-number">0.0</span>, <span class="hljs-number">1.0</span>); glVertex3f(<span class="hljs-number">-2.0</span>, <span class="hljs-number">1.0</span>, <span class="hljs-number">0.0</span>);   glTexCoord2f(<span class="hljs-number">1.0</span>, <span class="hljs-number">1.0</span>); glVertex3f(<span class="hljs-number">0.0</span>, <span class="hljs-number">1.0</span>, <span class="hljs-number">0.0</span>);   glTexCoord2f(<span class="hljs-number">1.0</span>, <span class="hljs-number">0.0</span>); glVertex3f(<span class="hljs-number">0.0</span>, <span class="hljs-number">-1.0</span>, <span class="hljs-number">0.0</span>);   glTexCoord2f(<span class="hljs-number">0.0</span>, <span class="hljs-number">0.0</span>); glVertex3f(<span class="hljs-number">1.0</span>, <span class="hljs-number">-1.0</span>, <span class="hljs-number">0.0</span>);   glTexCoord2f(<span class="hljs-number">0.0</span>, <span class="hljs-number">1.0</span>); glVertex3f(<span class="hljs-number">1.0</span>, <span class="hljs-number">1.0</span>, <span class="hljs-number">0.0</span>);   glTexCoord2f(<span class="hljs-number">1.0</span>, <span class="hljs-number">1.0</span>); glVertex3f(<span class="hljs-number">2.41421</span>, <span class="hljs-number">1.0</span>, <span class="hljs-number">-1.41421</span>);   glTexCoord2f(<span class="hljs-number">1.0</span>, <span class="hljs-number">0.0</span>); glVertex3f(<span class="hljs-number">2.41421</span>, <span class="hljs-number">-1.0</span>, <span class="hljs-number">-1.41421</span>);glEnd();glFlush();glDisable(GL_TEXTURE_2D);</code></pre><p>其他映射方法：</p><ul><li>凹凸映射</li><li>环境映射</li><li>法向贴图</li><li>置换贴图</li></ul><p>GL固定流水线过程（图）</p><p>固定流水线，回顾</p><h1 id="第七讲-自由曲线和自由曲面"><a href="#第七讲-自由曲线和自由曲面" class="headerlink" title="第七讲 自由曲线和自由曲面"></a>第七讲 自由曲线和自由曲面</h1><h2 id="曲线曲面造型概论"><a href="#曲线曲面造型概论" class="headerlink" title="曲线曲面造型概论"></a>曲线曲面造型概论</h2><ul><li>平面模型：用多边形网格描述形体表面</li><li>曲面模型：由曲面片代替平面模型中的小平面片</li></ul><p>自由曲线和曲面因不能由画法几何与机械制图方法表清楚，称为工程师们首要解决的问题。人们一直在寻找用数学方法唯一定义自由曲线和曲面的形状</p><p>对形状数学描述的要求</p><ul><li>从计算机处理的角度<ul><li>唯一性</li><li>几何不变形（形状跟坐标系无关）</li><li>易于定界</li><li>统一性（统一的数学表达，便于建立统一的数据库）</li></ul></li><li>从形状表示与设计的角度来看<ul><li>丰富的表单能力：表达两类曲线曲面</li><li>易于实现光滑连接</li><li>形状易于预测、控制和修改</li></ul></li><li>从其他角度来看<ul><li>导数易计算</li><li>易渲染</li><li>易碰撞检测</li></ul></li></ul><p>发展过程：1971 Bazier曲线、1974 B样条曲线和曲面、1975 有理B样条方法 80年代后期 发展成非均匀有理B样条（NURBS）方法，NURBS称为当前大多数商用CAD软件系统的内部表达技术（Solid Edge、CATIA、Inventor等）</p><h2 id="曲线曲面的一般参数样条表达"><a href="#曲线曲面的一般参数样条表达" class="headerlink" title="曲线曲面的一般参数样条表达"></a>曲线曲面的一般参数样条表达</h2><p>略</p><h2 id="Bezier曲线"><a href="#Bezier曲线" class="headerlink" title="Bezier曲线"></a>Bezier曲线</h2><p>为什么用参数曲线？</p><ul><li>一条曲线可用多边形、折线段来金丝<ul><li>不能缩放</li><li>需要较多的点使曲线变得光滑</li></ul></li><li>阴式曲线 制定。难于制图</li><li>参数曲线可以指明运动的点在时刻t时的位置</li></ul><p>多项式曲线的优点：容易计算、可微</p><p>不用标准多项式来设计的原因：参数对于曲线没有直观意义，不容易调整。</p><p>Bezier曲线：用$\}(1-t)^2,2(1-t),t^2\}$，而不是幂函数$\{1,t,t^2\}$作为基函数，使得系数有了某种直观意义，控制点。</p><ul><li>Bezier曲线由一条折线决定<ul><li>称为控制多边形，多边形的顶点称为控制点</li><li>控制点按顺序形成一条折线</li></ul></li><li>控制顶点可以为任意数量，3个或者4个是最常见的<ul><li>曲线的阶 = 控制点的数量</li><li>曲线的次数= 曲线的阶- 1</li></ul></li><li>Bézier 曲线逼近控制多边形，通过第一个和最后一个顶点，但一般不通过其它的顶点</li></ul><p>用样条曲线而不用多项式曲线的原因。</p><p>图：Bernserin多项式</p><p>要求根据公式画形状。</p><p>性质</p><ul><li>端点性质：曲线通过首末顶点。带入参数可验证</li><li>切矢性质：曲线在首末亮点相切于多边形的起、止边。对三次Bezier曲线求一阶导数：首为3(P1-P0)、末为3(P3-P2)。</li><li>对称性：对称点反序仍然可以得到相同的形状</li><li>凸包性：Bezier曲线不会越出特征多边形顶点围成的凸包。</li></ul><p>插值</p><p>在参数空间[0,1]进行均匀茶汁，计算对应的坐标点，然后连接成线，就是折线逼近Bezier曲线</p><p>不足：Bezier曲线有三点不足</p><ul><li>一是特征多边形顶点数决定了Bezier曲线的阶次，n很大时，特征多边形对形状的控制将减弱。</li><li>二是Bezier曲线不能作局部修改，改变任一控制点将波及整条曲线。</li><li>三是绘制复杂曲线需要拼接，比较繁琐。</li></ul><p>因此发展了B样条曲线，1972年Gordon等用B样条基代替Bernstein基函数，从而改进上述缺点。</p><p>后面补充B样条曲线内容</p><h1 id="第八讲-真实感绘制"><a href="#第八讲-真实感绘制" class="headerlink" title="第八讲 真实感绘制"></a>第八讲 真实感绘制</h1><p>真实感绘制，逐个逐个添加，要素：明暗、阴影、高光</p><p>光线跟踪基本实现的伪代码，理解，掌握。</p><p>两个关键技术</p><ul><li>光照明模型</li><li>求交加速算法</li></ul><h1 id="第九讲-光照明模型"><a href="#第九讲-光照明模型" class="headerlink" title="第九讲 光照明模型"></a>第九讲 光照明模型</h1><p>熟记，入射光，法线如何计算反射光</p><p>Phong 照明模型</p><p>Blim-Phong</p><p>I 那个公式</p><p>明暗处理 shading</p><h1 id="第十讲-光线求交"><a href="#第十讲-光线求交" class="headerlink" title="第十讲 光线求交"></a>第十讲 光线求交</h1><p>发现计算 M^T的问题</p><p>包围盒、层次包围盒、均匀网格、八叉树、K-DTree  需要了解四种数据结构构造方法。</p><p>题目设置：选择、填空、判断，证明/程序实现/问答题</p>]]></content>
    
    
    <categories>
      
      <category>Computer Science</category>
      
      <category>计算机图形学</category>
      
    </categories>
    
    
    <tags>
      
      <tag>计算机图形学</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>数据分析与融合——粗糙集理论算法优化</title>
    <link href="/post/295036cf.html"/>
    <url>/post/295036cf.html</url>
    
    <content type="html"><![CDATA[<h1 id="粗糙集理论算法优化研究"><a href="#粗糙集理论算法优化研究" class="headerlink" title="粗糙集理论算法优化研究"></a>粗糙集理论算法优化研究</h1><h2 id="摘要"><a href="#摘要" class="headerlink" title="摘要"></a>摘要</h2><p>本文回顾了 Pawlak 粗糙集理论的基础知识，对该理论框架下如等价类划分，相对正域计算，约简过程等问题朴素算法的复杂度进行分析，介绍并总结了前人针对上述问题提出的各种优化算法。</p><h2 id="引言"><a href="#引言" class="headerlink" title="引言"></a>引言</h2><p>20 世纪 80 年代，波兰的 Pawlak 教授提出了粗糙集的概念，并用数学形式明确了粗糙集的定义以及计算规则[@Pawlak]，为描述系统的不确定性并计算规约相关决策规则提供了一项新的工具。粗糙集理论引起了许多数学家、逻辑学家和计算机学家的兴趣，在过去的二十年中，他们在 Pawlak 提出的粗糙集理论基础上进行了大量的研究工作。主要包括粗糙集数学性质[@]、基于其他关系的粗糙集拓展模型、多属性决策分析理论和应用[@安利平]、粗糙集理论与其他不确定方法的关系和结合[@]、粗糙集上的高效算法等。其中《基于粗集理论的多属性决策分析》[@安利平]</p><p>相较于 Zadeh 于 1965 年提出的模糊集理论[@Zadeh]，粗糙集给出了可计算的，更准确的描述模糊边界的方式以及量化边界模糊元素的方法。在智能计算、数据挖掘领域，有效且可行的数学描述带来的一大便利便是可以通过计算的方式从数据中抽取有效的经验和知识，粗糙集理论也因此成为数据科学家的有效工具。对于多属性决策分析，粗糙集理论引入了集合近似、约简、核、确定性和可能性规则等新型概念及计算方法，不仅对决策分析问题提供了解释机制，如发现重要的事实和关系，而且利用决策规则形式的偏好模型可以表示决策者的决策政策，提供决策支持。</p><p>《数据分析与融合》课程中对粗糙集进行了较为系统的讲解，但是课程避开了粗糙集相关算法的具体实现和复杂度分析。事实上，现有粗糙集算法计算的低效性在一定程度上限制了粗糙集理论的广泛应用，因此寻求高效的粗糙集算法具有重要的意义，也自然成为粗糙集理论研究的一个主要研究分支。</p><p>本文首先对粗糙集理论主要内容及其相关数学性质进行回顾，总结前人的相关文献成果，分析了算法低效性的根源 ，解释并实现一种高效的粗糙集基本算法。</p><h2 id="粗糙集的基本概念"><a href="#粗糙集的基本概念" class="headerlink" title="粗糙集的基本概念"></a>粗糙集的基本概念</h2><p>经典粗集理论是基于不可分辨关系的，下面首先介绍粗糙集的基本概念。</p><h3 id="信息表和不可分辨关系"><a href="#信息表和不可分辨关系" class="headerlink" title="信息表和不可分辨关系"></a>信息表和不可分辨关系</h3><p>定义 2.1 一个信息系统可以表示为</p><script type="math/tex; mode=display">S = \langle U,A,V,f \rangle \tag{2-1}</script><p>其中, $U$ 是一非空有限对象集（即论域），$U = \{ x_1,x_2, \cdots , x_n  \}$ ，$A$ 是非空有限属性集 ，$A = \{  a_1,a_2,a_3 \}$，$V_a$表示属性 $a$ 的值域 ，$V = \bigcup_{a \in A} V_a$ ，$f : U \times A \rightarrow V$ 是信息函数。它指定 $U$ 中每一个对象 $x$ 的属性值, 即对 $x \in U , a \in A$ ，有 $f(x , a) \in  V_a$。</p><p>在粗集理论中，信息系统也被称为信息表、属性值表、数据表，可简记为$S = \langle U,A\rangle$，或者$S = \langle U,A,V \rangle$。粗集理论利用信息表（决策表）来描述论域对象及其属性，它是一个二维表，每一行表示一个对象，每一列表示对象的一个属性。与数据库的“表”概念不同，粗集理论所研究的表并不要求两个对象可完全区分，即至少存在一个属性列使得两个对象对应的属性值不同。粗糙集关注的是粒度，而非单个元素。</p><a id="more"></a><p>定义 2.2 在信息系统 S 中 ,对于每个属性子集$B \subseteq A$ ,可以定义一个不可分辨关系 $IND(B)$（在不引起歧义的情况下可简写为$I_B$）:</p><script type="math/tex; mode=display">IND(B) = \{ (x,y) \in U \times U : f(x,a) = f(y,a) , \forall a \in B \} \tag{2-2}</script><p>如果$(x,y) \in I_B$，则$x$和$y$称为$B$不可分辨，显然$I_B$满足自反性、对称性和传递性，根据离散数学的内容我们知道，$I_B$是以等价关系，$I_B$的所有等价类族，即由$B$决定的划分，用$U/I_B$表示，包含元素$x$的等价类用$I_B(x)$ 表示</p><!-- ，或者 $[ x ]_{I(B)}$。 --><h3 id="相容关系表述和转化探究"><a href="#相容关系表述和转化探究" class="headerlink" title="相容关系表述和转化探究"></a>相容关系表述和转化探究</h3><p>在考虑决策表时，常常会考虑是否有如下情况出现：决策表元素出现属性相同（即具备不可分辨关系）的多个元素，却有不同的决策属性值。我们常常将这样类似的性质描述为决策表的相容性。若要通过决策表为自动化程序或者固定流程提供指导，我们希望决策表是相容的，在不断约简决策表过程中，我们也希望决策表保持原有的相容性，否则，具备不可分辨关系的两元素就会出现决策差异，这与程序设计与工业流程中要求的“确定性”产生了根本的对立。当然，若是考虑引入新的知识项（属性）、关联上下文等方法，我们或许可以将不相容的决策表转化为新的相容决策表且决策能力不变，但这已经超出了基本粗糙集和决策表约简的讨论范围，在此也不考虑这种拓展情形。</p><p>相容性的刻画有很多方法，从定义上划分可以在不同资料</p><p>设$S = \langle U,C \cup D \rangle$为一决策表，不可分辨关系$I_C$将论域划分为$U/C$，称为条件分类（条件粒度），不可分辨关系$I_D$将论域划分为$U/D$，称为决策分类（决策粒度）。对于单属性决策，则$D = {d}$，若非单属性决策，则$D$表示所有决策属性列的集合，决策表的相容关系有如下两种表述。</p><p>定义 2.3 设$S = \langle U,C \cup D \rangle$为一决策表，对于其条件分类$U/C$与决策分类$U/D$，若有$U/C$细分$U/D$，则称$S$为相容决策表，否则成$S$为不相容决策表。</p><p>相关文献讨论了通过决策值归纳函数来描述决策表相容性的方法，不过讨论局限在$D = {d}$，即决策属性单一的情况。为了与定义 2.3 保持等价性，这里给出拓展$D$不仅为单属性列情况下的定义。</p><p>定义 2.4 设$S = \langle U,C \cup D \rangle$为一决策表，$B \subseteq C$，定义$S$的$B$决策值归纳函数为</p><script type="math/tex; mode=display">\partial_B : U \times D \rightarrow P(V_d) \tag{2-3}</script><script type="math/tex; mode=display">\partial_B (x,d) = \{ i: \exists x_0 \in I_B(x) , f(x,d) = i \} \tag{2-4}</script><p>其中$P(V_d))$表示对应属性列取值$V_d$的幂集。</p><p>如果$\forall x \in U, \forall d \in D ,|\partial_C (x,d)| = 1$，则$S$称为相容决策表，否则，$S$称为不相容决策表。</p><p>下面证明两定义的等价性，即证$U/C$细分$U/D$是$\forall x \in U, \forall d \in D ,|\partial_C (x,d)| = 1$的充要条件</p><p>证明 2.1 充分性</p><p>应用反证法：</p><p>假设$\exists x_0 \in U, \exists d_0 \in D, | \partial_C (x_0,d_0) | \geq 2$。由细分关系$I_C \subseteq I_D$。因为$|\partial_C (x_0,d_0) | \geq 2$，不妨设$\partial_C (x_0,d_0) = \{r_0,r_1, \cdots \}$，同时我们假设$r_0$表示为$x_0$在属性$d_0$上的值（即信息函数值），$f(x_0,d_0) = r_0$，则由决策归纳函数定义，必然$\exists x_1 \in I_C(X_0), f(x_1,d_0) = r_1$。</p><p>因为$f(x_1,d_0)$不等于$f(x_0,d_0)$，所以明显$x_0$不等于$x_1$，即表示两个论域元素。又因为决策归纳函数的限制，$(x_0,x_1)\in I_C$也即（$x_0 I_C x_1$）。而根据定义 2.2，因为$f(x_1,d_0)$不等于$f(x_0,d_0)$，则对于$I_D$，$(x_0,x_1) \notin I_D$，与$I_C \subseteq I_D$相矛盾，充分性得证。</p><p>所以$U/C$细分$U/D$是$\forall x \in U, \forall d \in D ,|\partial_C (x,d)| = 1$的充分条件。</p><p>证明 2.2 必要性</p><p>因为$\forall x \in U, \forall d \in D, |\partial_C(x,d)| = 1$，那么对于$\forall (x_0,x_1) \in I_C$，我们可以得到，$\forall d \in D, |\partial_C(x_0,d)| = |\partial_C(x_1,D)| = 1$。</p><p>对于决策属性族的任意属性$d$，不妨设此时$f(x_0,d) = r, f(x_1,d) = r’$，因为$\partial_C(x_0,d) = \{ r \}$，根据决策归纳函数定义，应有$f(x_1,d) = r$，故$r = r’$。综合前述，即$\forall (x_0,x_1) \in I_C, \forall d \in D, f(x_0,d) = f(x_1,d)$，根据定义 2.2，则$(x_0,x_1) \in I_D$。即退出$I_C \subseteq I_D$，由等价关系性质可得$U/C$细分$U/D$，必要性得证，证毕。</p><p>不相容决策表可以通过决策值归纳函数转化为相容决策表$S = \langle U, C\cup (\bigcup_{d \in D} \partial(d))$。</p><h3 id="集合的近似和相关性质"><a href="#集合的近似和相关性质" class="headerlink" title="集合的近似和相关性质"></a>集合的近似和相关性质</h3><p>由于不同文献中所用的习惯表示方法不尽相同，所以这里我们用原作者 Pawlak 在[@Pawlak1982]使用的定义方式来表示集合的近似及其相关性质，并根据原文献补充部分课上未涉及的概念。</p><p>定义 2.5 设$S$未信息表,$X$为$U$的非空子集，属性$A$下$X$包含的最大粒度集合被称为$X$的$A$下近似$\underline{\mathrm{Apr}_A}(X)$，属性$A$下包含$X$的最小粒度集合被称为$X$的$A$上近似$\overline{\mathrm{Apr}_A}(X)$，当$A$均已知的时候可以省略。</p><script type="math/tex; mode=display">\underline{\mathrm{Apr}_A}(X) = \{ x\in U: I_A(x) \subseteq X \} \tag{2-5}</script><script type="math/tex; mode=display">\overline{\mathrm{Apr}_A}(X) = \{ x\in U: I_A(x) \cap X \not ={\emptyset} \tag{2-6}</script><p>在集合近似的基础上，我们可以给出拓展的论域元素与集合近似成员关系的定义，$\underline{\in}_{A}$与$\overline{\in}_{A}$，具体定义如下：</p><p>定义 2.6</p><script type="math/tex; mode=display">x \underline{\in}_{A} X \quad \mathrm{iff} \quad x \in \underline{\mathrm{Apr}_A}(X) \tag{2-7}</script><script type="math/tex; mode=display">x \overline{\in}_{A} X \quad \mathrm{iff} \quad x \in \overline{\mathrm{Apr}_A}(X) \tag{2-8}</script><p>如果$x \underline{\in}_{A} X$，我们称“在属性$A$下$x$ <strong>必然</strong> 属于$X$”，而如果$x \overline{\in}_{A} X$，我们称“在属性$A$下$x$，<strong>可能</strong> 属于$X$”。如此通过模态逻辑中的必然性和可能性来解释近似性。</p><p>在集合近似的基础上，我们还可以根据属性$B$，将论域$U$中的所有元素针对给定的集合$X$划分到不同域中。$\underline{\mathrm{Apr}_A}(X)$实际上是由根据已知的属性划分出的知识粒度，判断肯定属于$X$的论域元素所构成的最大集合，所以也被称为$X$的$A$正域，记为$POS_A(X)$。而根据已有知识推断的必然不属于$X$的论域元素称为$X$的$A$负域，记为$NEG_A(X)$，$\overline{\mathrm{Apr}_A}(X)$应为可能属于$X$的论域元素构成的最大集合。根据当前已有知识，既不能推断属于$POS_A(X)$也不能推断属于$NEG_A(X)$的元素则属于边界域（可域）$BND_A(X)$（部分资料上写为$Bn_A(X)$），不能肯定其中的元素是否属于$X$，具体定义如下：</p><p>定义 2.7</p><script type="math/tex; mode=display">POS_A(X) = \underline{\mathrm{Apr}_A}(X) \tag{2-9}</script><script type="math/tex; mode=display">NEG_A(X) = U - \overline{\mathrm{Apr}_A}(X) \tag{2-10}</script><script type="math/tex; mode=display">BND_A(X) =  \overline{\mathrm{Apr}_A}(X) - \underline{\mathrm{Apr}_A}(X) \tag{2-11}</script><p>容易得出在各属性域限制下，论域元素集合$X,Y \subseteq U$，符合下述性质：</p><script type="math/tex; mode=display">\underline{\mathrm{Apr}}(X) \subseteq X \subseteq \overline{\mathrm{Apr}}(X) \tag{2-12}</script><script type="math/tex; mode=display">\underline{\mathrm{Apr}}(\emptyset) = \overline{\mathrm{Apr}}(\emptyset) = \emptyset \tag{2-13}</script><script type="math/tex; mode=display">\underline{\mathrm{Apr}}(U) = \overline{\mathrm{Apr}}(U) = U \tag{2-14}</script><script type="math/tex; mode=display">\underline{\mathrm{Apr}}(X \cap Y) = \underline{\mathrm{Apr}}(X) \cap \underline{\mathrm{Apr}}(Y)  \tag{2-15}</script><script type="math/tex; mode=display">\overline{\mathrm{Apr}}(X \cup Y) = \overline{\mathrm{Apr}}(X) \cup \overline{\mathrm{Apr}}(Y)  \tag{2-16}</script><script type="math/tex; mode=display">\underline{\mathrm{Apr}}(X \cup Y) \supseteq \underline{\mathrm{Apr}}(X) \cup \underline{\mathrm{Apr}}(Y)  \tag{2-17}</script><script type="math/tex; mode=display">\overline{\mathrm{Apr}}(X \cap Y) \subseteq \overline{\mathrm{Apr}}(X) \cap \overline{\mathrm{Apr}}(Y) \tag{2-18}</script><script type="math/tex; mode=display">\underline{\mathrm{Apr}}(-X) = - \overline{\mathrm{Apr}}(X) \tag{2-19}</script><script type="math/tex; mode=display">\overline{\mathrm{Apr}}(-X) = - \underline{\mathrm{Apr}}(X) \tag{2-20}</script><script type="math/tex; mode=display">\underline{\mathrm{Apr}}(\underline{\mathrm{Apr}}(X)) = \overline{\mathrm{Apr}}(\underline{\mathrm{Apr}}(X)) = \underline{\mathrm{Apr}}(X)  \tag{2-21}</script><script type="math/tex; mode=display">\overline{\mathrm{Apr}}(\overline{\mathrm{Apr}}(X)) = \underline{\mathrm{Apr}}(\overline{\mathrm{Apr}}(X)) = \overline{\mathrm{Apr}}(X)  \tag{2-22}</script><p>其中$-X$ 表示$U - X$，即以论域元素集合为全集得补集。</p><p>上述列出为常见的性质，其中性质$\tag{2-12}$表示，如果严肃$x$属于$\underline{\mathrm{Apr}}(X)$时，则$x$一定属于$X$，而当$x$属于$\overline{\mathrm{Apr}}(X)$时，$x$可能属于$X$，而性质$\tag{2-17}$与性质$\tag{2-18}$则表明，不同集合近似的分布计算要慎重，并集的上近似等于上近似的并集，交集的下近似等于下近似的交集，但是如果考虑交集的上近似、并集的下近似，则会出现忽略粒度和过度包含粒度的情况出现，等式关系不再成立，转而变为包含与被包含的关系，证明这里从略。在实际应用中，这提醒我们如果信息表被分成几个部分先行计算近似与整体计算近似，可能得到不同的结果。</p><p>当然，由近似引出的性质还可以继续深入研究，比如满足德摩根定律形式的一些性质，以及不同集合差集近似的性质，</p>]]></content>
    
    
    <categories>
      
      <category>Computer Science</category>
      
      <category>数据分析与融合</category>
      
    </categories>
    
    
    <tags>
      
      <tag>数据分析与融合</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>人机交互——总结笔记</title>
    <link href="/post/bba0ae0d.html"/>
    <url>/post/bba0ae0d.html</url>
    
    <content type="html"><![CDATA[<h1 id="第一章-绪论"><a href="#第一章-绪论" class="headerlink" title="第一章 绪论"></a>第一章 绪论</h1><h2 id="什么是人机交互（Human-Computer-Interection）"><a href="#什么是人机交互（Human-Computer-Interection）" class="headerlink" title="什么是人机交互（Human-Computer Interection）"></a>什么是人机交互（Human-Computer Interection）</h2><p>是关于设计、评价和实现供人们使用的交互式计算机系统，并围绕相关的主要现象进行研究的学科。——ACM SIGCHI</p><p>狭义的讲，人机交互主要研究<strong>人</strong>与<strong>计算机</strong>之间的信息交换。</p><p>综合学科，与<strong>认知心理学、人机工程学（理论基础）</strong>、<strong>多媒体技术、虚拟现实技术（相互交叉渗透）</strong>等密切相关。</p><h2 id="人机交互研究内容"><a href="#人机交互研究内容" class="headerlink" title="人机交互研究内容"></a>人机交互研究内容</h2><ul><li><p>人机交互界面的表示模型与设计方法（Model and Methodology）</p><p>交互界面好坏影响软件开发的成败，研究表示模型与设计方法是 HCI 研究的重要内容</p></li><li><p>可用性分析与评估（Usability and Evaluation）</p><p>关系到 HCI 是否能达到用户期待目标。主要涉及到支持可用性的设计原则和可用性的评估方法。</p></li><li><p>多通道技术（Multi-Modal）</p><p>多通道交互界面的表示模型、多通道交互界面的评估方法以及多通道信息融合。</p></li><li><p>认知与智能用户界面（Intelligent User Interface, IUI）</p><p>目标：自然方便、上下文感知、三维输入、语音识别、手写识别、自然语言理解。</p></li><li><p>群件（Groupware）</p><p>群件指为群组协同工作提供计算机支持的协作环境。与 HCI 相关的研究内容主要包括群件系统的体系结构、计算机支持交流与共享信息的方式、交流中的决策支持工具、应用程序共享以及同步实现方法等内容。</p></li><li><p>Web 设计（Web-Interection）</p><p>Web 界面模型结构、设计基本思想和原则、设计工具和技术、可用性分析和评估方法。</p></li><li><p>移动界面设计（Mobile and Ubicomp）</p><p>移动界面设计方法、可用性与评估原则、开发工具和实现技术。</p></li></ul><h2 id="HCI-发展历史"><a href="#HCI-发展历史" class="headerlink" title="HCI 发展历史"></a>HCI 发展历史</h2><p>命令行界面交互阶段-&gt;图形用户界面交互阶段-&gt;自然和谐的人机交互阶段</p><ul><li><p>命令行</p><p>第一代人机交互界面，操作员，被动反应，缺乏自然性</p></li><li><p>GUI</p><p>主要特点：桌面隐喻、WIMP、直接操纵、所见即所得</p><p>单一通道（手）、占用较多屏幕空间、难以表达支持非空间性的抽象信息交互。</p><ul><li><p>Window,Icon,Menu,Pointing Device</p><p>" srcset="/img/loading.gif<img src="" alt=""></p></li></ul></li><li><p>自然和谐</p><p>多通道交互（并行、非精确）、情感计算（上下文理解）、虚拟现实、智能用户界面、自然语言理解。</p></li></ul><a id="more"></a><h1 id="第二章-感知和认知基础"><a href="#第二章-感知和认知基础" class="headerlink" title="第二章 感知和认知基础"></a>第二章 感知和认知基础</h1><h2 id="人的感知"><a href="#人的感知" class="headerlink" title="人的感知"></a>人的感知</h2><ul><li><p>视觉</p><p>背景：人类从中为世界获取的信息约有 80%是通过视觉得到的，因此视觉显示是人机交互系统中应用的最多的人机界面</p><p><strong>视觉感知可以分为两个阶段：受到外部刺激接收信息阶段和解释信息阶段。</strong></p><p>视觉感知特点：一方面，眼睛和视觉系统的物理特性决定了人类无法看到某些事物；另一方面，视觉系统进行解释处理信息时可对不完全信息发挥一定的想象力。</p><p>大小、距离、深度、视敏度、视错觉、亮度、色彩（波长 400μm-700μm）、</p></li><li><p>阅读</p><p>过程：感知形状-&gt;编码为内部语言表示-&gt;解释语义</p><p>过程与交互标准：成年人阅读是通过字的特征加以识别。改变字的显示方式，会影响到阅读的速度和准确性。9 ～ 12 号的标准字体（英文）更易于识别，页面的宽度在 58 ～ 132mm 之间阅读效果最佳。在明亮的背景下显示灰暗的文字比在灰暗的背景下显示明亮的文字更能提高人的视敏度，增强文字的可读性。</p></li><li><p>听觉</p><p>能够听到的频率：16/20Hz~20kHz（高感 1000Hz~4000Hz，可辨识语音 260~5600Hz）</p><p>听觉系统就像视觉系统一样，利用以前的经验来解释输入。</p><p>输入划分：噪声和可以忽略的不重要声音、赋予意义的非语言声音、组成语言的有意义声音。</p></li><li><p>触觉</p><p>重要性：可以反馈多种信号，对于能力缺陷的人更加重要，有助于基于触觉的交互设备的设计，</p><p>不同：触觉的感知机理与视觉和听觉的最大不同在于它的非局部性（感受器遍布全身）。但不同部位对察觉的敏感度差异很大，如人的手指的触觉敏感度是前臂的触觉敏感度的 10 倍。</p></li><li><p>内部感觉</p></li></ul><h2 id="知觉的特性"><a href="#知觉的特性" class="headerlink" title="知觉的特性"></a>知觉的特性</h2><p>选择性、整体性、理解性和恒常性。</p><ul><li><p>选择性</p><p>（在某一瞬间，选择某一事物为知觉对象，而把其他事物作为知觉背景，这就是知觉选择性，与注意的选择性有关）。分化对象和背景的选择性是知觉最基本的特性，背景往往衬托着、弥漫着、扩展着，对象往往轮廓分明、结构完整。</p></li><li><p>整体性</p><p>（人不会把知觉的对象感知为个别的孤立部分，而总是把它感知为一个统一的整体，这种特性叫做知觉的整体性）当一个残缺不全的部分呈现到眼前时，人脑中的神经联系马上被激活，从而把知觉对象补充完整。</p></li><li><p>知觉的理解性</p><p>（理解性指人利用过去所获得的有关知识经验，对感知对象进行加工理解。）实质是旧经验与新刺激建立多维度、多层次的联系，以保证理解的全面和深刻。</p></li><li><p>知觉的恒常性</p><p>客观条件一定范围改变时，人的知觉映像相当程度上保持稳定性。</p></li></ul><h3 id="认知过程和交互式设计原则"><a href="#认知过程和交互式设计原则" class="headerlink" title="认知过程和交互式设计原则"></a>认知过程和交互式设计原则</h3><h3 id="概念模型及对概念模型的认知"><a href="#概念模型及对概念模型的认知" class="headerlink" title="概念模型及对概念模型的认知"></a>概念模型及对概念模型的认知</h3><h3 id="分布式认知"><a href="#分布式认知" class="headerlink" title="分布式认知"></a>分布式认知</h3><h1 id="第三章-交互设备"><a href="#第三章-交互设备" class="headerlink" title="第三章 交互设备"></a>第三章 交互设备</h1><h2 id="人机工程学大纲"><a href="#人机工程学大纲" class="headerlink" title="人机工程学大纲"></a>人机工程学大纲</h2><p>从本身和系统本身的角度，研究人机关系<br>专门的一门课程</p><ul><li><p>定义</p><p>（研究人和机器、环境的相互作用及其合理结合，使设计的机器和环境系统适合人的生理、心理等特征，达到在工作、生活中提高效率、安全、健康和舒适的目的。）</p><p><strong>人机工程学可定义为：按照人的特性设计和改善人——机环境系统的科学。</strong></p></li></ul><h2 id="人机工程学相关问题"><a href="#人机工程学相关问题" class="headerlink" title="人机工程学相关问题"></a>人机工程学相关问题</h2><ul><li>控制装置和显示布局<br>在逻辑上分组布局，组织形式包括：<strong>功能的</strong>：相关功能放在一起；<strong>顺序的</strong>：按照执行的顺序放在一起；<strong>经常性</strong>：根据使用频率排序。</li><li><p>交互的物理环境</p><p>考虑工作环境：使用地点、使用人、使用方式（姿势）</p></li><li><p>健康问题</p><p>身体姿势（舒适的触及所有控制装置，可以看见所有的显示）、<strong>温度</strong>（高温低温环境下用户反应恶化，精神无法集中）、<strong>光线</strong>（能看见屏幕，舒适，不疲劳）、<strong>噪声</strong>（有害健康，使用户烦躁）、<strong>时间</strong></p></li><li><p>颜色的使用问题</p></li></ul><h2 id="输入设备"><a href="#输入设备" class="headerlink" title="输入设备"></a>输入设备</h2><h3 id="文字输入设备"><a href="#文字输入设备" class="headerlink" title="文字输入设备"></a>文字输入设备</h3><ul><li><p>手写输入设备</p><p>从社会科学、认知科学的角度来看，手写输入更符合人的认知习惯，是一种自然高效的交互方式。</p><p>手写板是一种常见的支持手写输入的交互设备，分为电阻式、电磁式、电容式三类，除了压感级数，精度和手写面积也是手写板的通用评测指标</p></li><li><p>手写识别</p><p>手写识别经过多年的发展已经产业化，广泛应用在触屏手机、GPS 等。提供了一种输入选择方式。</p><p>优点：方便、直观：适合没有键盘的情况；缺点：速度慢</p><p>举例：中科院自动化所“汉王笔”</p></li><li><p>语音识别</p><p>作为另一种文字输入设备，代替键盘。很有前途（和机器对话交谈是人们的理想），存在问题：识别率问题、模糊性、不确定性、口音、周围噪声</p><p>应用场景：在键盘是不现实或不可能的地方使用：电话信息系统、辅助残疾人、双手不方便（军事、无重力）</p><p>举例：IBM/Via Voice 微软语音识别系统</p></li></ul><h3 id="图像输入设备"><a href="#图像输入设备" class="headerlink" title="图像输入设备"></a>图像输入设备</h3><ul><li><p>二维扫描仪<br>已经成为计算机不可缺少的图文输入工具之一，由光学系统和步进电机组成。性能指标包括：扫描速度、分辨率等。扫描速度决定了扫描仪的工作效率，分辨率决定了最高扫描精度。</p></li><li><p>数字摄像头</p><p>作为一种视频输入设备，被广泛应用在视频聊天、实时监控等方面。数字摄像头可以直接捕捉影响，然后通过计算机的串口、并口或者 USB 接口传送到计算机。解析度是数字摄像头比较重要的技术指标，又有照相解析度和视频解析度之分。</p></li></ul><h3 id="三维信息输入设备"><a href="#三维信息输入设备" class="headerlink" title="三维信息输入设备"></a>三维信息输入设备</h3><p>在许多领域：如机器视觉、面形检测、实物仿形、自动加工、产品质量控制、生物医学等，物体的三维信息必不可少。</p><ul><li><p>三维扫描仪</p><p>根据传感方式分类：接触式和非接触式</p><p>接触式的三维扫描仪采用探测头直接接触物体表面，痛殴探测头反馈回来的光电信号转化为物体表面形状的数字信息，以三维坐标测量机伟代表。优点：校稿准确性和可靠性。缺点：测量速度慢、费用高、探头易磨损、误差修正。</p><p>非接触式的三维扫描仪主要有三维激光扫描仪，照相式三维扫描仪等，分别是基于激光扫描测量和结构光测量等技术设计的。优点：扫描速度快，易于操作，不需要直接接触。</p><ul><li><p>三维激光扫描仪</p><p>三维激光扫描仪通过高速激光扫描测量技术，获取被测对象表面的空间坐标数据。常采用 TOF（Time-of-Flight，飞行时间）测量发或者三角测量法进行深度数据获取</p></li><li><p>结构光三维扫描仪</p><p>这是一种面扫描技术，通过投影仪向被测物体投射光栅模版图像，如正弦条纹光栅图像，正弦光栅在物体表面发生调制变形，其周期与相位的变化反映了物体表面的三维信息。通过相机拍摄物体表面的正弦光栅图像，检测出相位变化值，再利用双目视觉法计算出三维数据。</p></li></ul></li></ul><h3 id="虚拟现实和三维交互设备"><a href="#虚拟现实和三维交互设备" class="headerlink" title="虚拟现实和三维交互设备"></a>虚拟现实和三维交互设备</h3><ul><li><p>动作（运动）捕捉设备</p><p>机械式：利用可伸缩机械安装于捕捉物体上，以取得各部分的运动量。优点：成本低廉。缺点：限制物体自由运动，由于机械设备尺寸重量等问题，限制了其应用范围。</p><p>电磁式：若干低频磁场感应器安装在捕捉物体上，根据感应器接收到的磁场，可以计算出接收器相对于发射器的位置和方向。易受电磁干扰影响捕捉数据的精度和稳定性，对于作业场地的要求也十分严格。</p><p>光学式：利用计算机视觉原理。利用两台摄像机摆设图像和参数确定一点的位置。摄像机以足够高的速率连续拍摄时，从图像序列中就可以取得该点的运动轨迹。利用这一点通过对特定光电的监视和跟踪来完成运动捕捉的任务。</p></li></ul><h3 id="体感输入设备"><a href="#体感输入设备" class="headerlink" title="体感输入设备"></a>体感输入设备</h3><p>与光学式动作捕捉设备基本原理相似，体感输入设备牺牲了一定的捕捉精度，但可以更简易、快捷的实现动作捕捉，支持用户通过肢体动作控制计算机应用，如体感游戏。<br>举例：Leap 公司的 Leap Motion，微软公司 Kinect</p><h3 id="指点输入设备"><a href="#指点输入设备" class="headerlink" title="指点输入设备"></a>指点输入设备</h3><p>常用于完成定位，选择物体的交互任务。一维、二维、三维或更高维空间。</p><ul><li><p>鼠标</p><p>机械鼠标：轮子滚动把 x-y 坐标传递给计算机。三按钮，进行选择或者点击。容易磨损、堵塞。</p><p>光电鼠标：通过感应红色光反射强度变动来获得 x-y 坐标。容易保持干净。需要粗糙纹理表面，不能放置在光滑表面。</p><p>脚鼠：</p><p>轨迹球：原理与内部结构与机械鼠标相似，不同点是轨迹球工作时球在上面，直接用手拨动。优点：占用空间小，不需要大幅度平动，节省空间，减少手腕疲劳，多用于笔记本电脑等小型便携机。</p></li><li><p>操纵杆/键盘触头</p><p>间接输入设备，占用空间小。绝对操纵杆：通过运动来操纵位置（游戏中常用，与飞机汽车等操纵杆相似）。等度操纵杆：通过感知压力来控制光标（IBM 笔记本的小红点）</p></li><li><p>触摸屏</p><p>工作方式：手指终端一个光线阵列。屏幕既是输入也是输出，不存在其他的硬件损坏。</p><p>优点：速度快、适合恶劣复杂环境、大众信息系统界面。缺点：手指的油污，很难精细选择，最佳倾斜角 15。</p></li><li><p>尖笔</p><p>精确定位，不使屏幕受油污污染，可以使用尖笔，一般 PDA 附带。</p><p>优点：精细操作、绘图。缺点：一会儿提起、一会儿放下、麻烦。</p></li><li><p>数字化画板</p><p>专业设备，用来画画代替鼠标，分辨率高，可以用手/尖笔/需要一定的空间</p></li><li><p>眼睛凝视</p><p>工作原理：带上眼镜/头盔，低能量激光摄入眼镜，然后从视网膜反射出去，随着眼睛角度改变，反射也发生改变。</p><p>优点：速度快，精度高，应用于军事和残障事业。缺点：精度越高价格越贵。可以做选择但是不能拖拽。</p></li></ul><h2 id="输出设备"><a href="#输出设备" class="headerlink" title="输出设备"></a>输出设备</h2><h3 id="显示器"><a href="#显示器" class="headerlink" title="显示器"></a>显示器</h3><p>显示器是计算机的重要输出设备，是人机对话的重要工具。它的主要功能是接收主机发出的信息，经过一系列的变换，最后以光的形式将文字和图形显示出来。</p><ul><li><p>阴极射线管显示器</p><p>构成：由阴极、电平控制器（即控制极）、聚焦系统、加速系统、偏转系统和阳极荧光粉涂层组成，这六部分都在真空管内。其中，阴极、电平控制器（即控制极）、聚焦系统、加速系统等统称为电子枪。</p><p>工作原理：当显像管内部的电子枪阴极发出的电子束，经强度控制、聚焦和加速后变成细小的电子流，再经过偏转线圈的作用向正确目标偏离，穿越荫罩的小孔或栅栏，轰击到荧光屏上的荧光粉发出光线。彩色 CRT 光栅扫描显示器有三个电子枪，它的荧光屏上涂有三种荧光物质，分别能发红、绿、蓝三种颜色的光</p></li><li><p>液晶显示器</p><p>在充电条件下，液晶能改变分子排列，继而造成光线的扭曲或折射。</p><p>液晶显示器工作原理是通过能阻塞或传递光的液晶材料，传递来自周围的或内部光源的偏振光。以电流刺激液晶分子产生点、线、面配合背部灯管构成画面。</p><p>LCD 比 CRT 显示器具有更好的图像清晰度，画面稳定性和更低的功率消耗，但液晶材质粘滞性比较大，图像更新需要较长响应时间，因此不适合显示动态图象。</p></li><li><p>等离子显示器</p><p>等离子显示器诞生于二十世纪 60 年代，它采用等离子管作为发光材料，1 个等离子管负责一个像素的显示：等离子管内的氖氙混合气体在高压电极的刺激下产生紫外线，紫外线照射涂有三色荧光粉的玻璃板，荧光粉受激发出可见光 。</p><p>优点：重量较轻、完全无 X 射线辐射，而且屏幕亮度非常均匀，不存在明显的亮区和暗区；由于各个发光单元的结构完全相同，因此不会出现 CRT 显示器那样存在某些区域聚焦不良或因使用时间过长出现散焦的毛病。</p><p>缺点：是价格较高，由于显示屏上的玻璃较薄使屏幕较脆弱。</p></li></ul><h4 id="投影仪"><a href="#投影仪" class="headerlink" title="投影仪"></a>投影仪</h4><p>投影仪，又称投影机，是一种可以将数字图像或视频投射到幕布上的设备。</p><p>根据投影仪的工作方式不同，主要分为 CRT 型、LCD 型及 DLP 型三种不同类型的投影仪，而其中 LCD 投影仪与 DLP 投影仪又是目前商用投影仪中的主流。</p><h4 id="打印机"><a href="#打印机" class="headerlink" title="打印机"></a>打印机</h4><p>打印机是目前非常通用的一种输出设备，其结构可分为机械装置和控制电路两部分。</p><p>常见的有针式、喷墨、激光打印机三类。</p><p>打印分辨率、速度、幅面、最大打印能力等是衡量打印机性能的重要指标。</p><p>3D 打印机</p><p>3D 打印机又称三维打印机，它以数字模型文件为输入，运用特殊蜡材、粉末状金属或塑料等可粘合材料，通过打印一层层的粘合材料来制造三维的物体。</p><p>3D 打印机与传统打印机最大的区别在于它使用的“墨水”是实实在在的原材料，可用于打印的介质种类多样，从繁多的塑料到金属、陶瓷以及橡胶类物质。有些打印机还能结合不同介质，令打印出来的物体一头坚硬而另一头柔软。</p><p>分为喷墨式，熔积成型，激光烧结三种类型的 3D 打印机</p><p>一个桌面尺寸的三维打印机可以满足设计者或概念开发小组制造模型的需要。</p><h4 id="语音交互设备"><a href="#语音交互设备" class="headerlink" title="语音交互设备"></a>语音交互设备</h4><p>语音作为一种重要的交互手段，日益受到人们的重视。</p><p>基本的语音交互设备：耳机、麦克风、声卡</p><h1 id="第四章-交互技术"><a href="#第四章-交互技术" class="headerlink" title="第四章 交互技术"></a>第四章 交互技术</h1><h2 id="人机交互输入模式"><a href="#人机交互输入模式" class="headerlink" title="人机交互输入模式"></a>人机交互输入模式</h2><p>背景：由于输入设备是多种多样的，而且对一个应用程序而言，可以有多个输入设备，同一个设备又可能为多个任务服务，这就要求对输入过程的处理要有合理的模式。</p><p>分类：请求模式、采样模式、事件模式</p><p>重点概念：<strong>一个应用程序可以同时再几种输入模式下使用几个不同的输入设备来进行工作，提供各种不同的交互功能，使用户能方便、高效地完成工作。</strong></p><ul><li><p>请求模式</p><p><strong>在请求模式下，输入设备的启动是在应用程序中设置的</strong>。应用程序执行过程中需要输入数据时，暂停程序的执行，直到从输入设备接受到请求的输入数据后，才继续执行程序。</p><p>一般是指在高级语言的应用程序执行时需要输入一个数据，可以在应用程序中设置一条输入命令。该命令初始化输入数倍并等待用户输入。直到用户输入了一个信息，控制返回给应用程序，再继续执行应用程序</p><p>图</p></li><li><p>采样模式</p><p>输入设备和应用程序独立地工作。输入设备连续不断地把信息输入进来，<strong>信息的输入和应用程序中的输入命令无关。应用程序在处理其它数据的同时，输入设备也在工作（加入缓冲，可以并行）</strong>，新的输入数据替换以前的输入数据。当应用程序遇到取样命令时，读取当前保存的输入设备数据。</p><p>优点：这种模式对连续的信息流输入比较方便，也可同时处理多个输入设备的输入信息。</p><p>缺点：当应用程序的处理时间较长时，可能会失掉某些输入信息。</p><p>图</p></li><li><p>事件模式</p><p>输入设备和程序并行工作。输入设备把数据保存到一个输入队列，也称为事件队列，所有的输入数据都保存起来，不会遗失。应用程序随时可以检查这个事件队列，处理队列中的事件，或删除队列中的事件。</p><p>图</p></li></ul><h2 id="基本交互技术"><a href="#基本交互技术" class="headerlink" title="基本交互技术"></a>基本交互技术</h2><ul><li><p>定位</p><p>确定平面或空间的一个点的坐标，是交互中最基本的输入技术之一。</p><p>直接定位：用定位设备直接指定某个对象的位置，是一种精确定位方式。</p><p>间接定位：通过定位设备的运动控制屏幕上的映射光标进行定位，是一种非精确定位方式。其允许指定的点位于一个坐标范围内，一般用鼠标等指点设备配合光标来实现。</p></li><li><p>笔划</p><p>笔划输入用于输入一组顺序的坐标点。<strong>它相当于多次调用定位输入</strong>，输入的一组点常用于显示折线或作为曲线的控制点。</p></li><li><p>定值</p><p>定值（或数值）输入用于设置物体旋转角度、缩放比例因子等。（键盘输入、比例尺调整）</p></li><li><p>选择</p><p>单个元素选择：单个元素选择是在某个选择集中选出一个元素，通过注视、指点或接触一个对象，使对象成为后续行为的焦点，是操作对象时不可缺少的一部分。操作：键盘 Ctrl+A 全选、鼠标点击。</p><p>区域选择：区域选择是在选择集中选出一组元素或者选择一个区域，通过使用区域选择工具完成该交互操作。常用：选框工具、套索工具、快速选择工具、懒惰选择工具</p><p>选框工具：目前常用的选框工具有矩形选框工具和椭圆选框工具，<strong>凡是和选框工具选择区域相交的元素均会被选择</strong>。该方法交互简单，但是选择对象往往不够精确</p><p>套索工具：为了使得选择区域更加精确，<strong>套索工具所勾画的封闭区域范围内的所有元素均被选中</strong>，该方法需要用户进行精细选择才能得到较为精确的选择结果，交互量比较大。</p><p>快速选择工具：为了提高选择精度且减少交互量，目前软件系统提供快速选择工具，这些工具采用快速选择算法，通过<strong>选择和选择点颜色相近的区域作为选择元素。</strong></p><p>懒惰选择工具：懒惰选择方法，可以依据选择对象的形状、位置等关系信息，对用户手指划过的区域对象进行智能选择，但是这种交互技术<strong>尚不成熟</strong>，目前尚未广泛应用。</p></li><li><p>字符串</p><p>键盘是目前输入字符串最常用的方式，现在用写字板输入字符也已经很流行。</p><p>语音输入也是字符串输入以及功能选择的一种输入方法，语音输入需要使用语音识别技术。</p></li></ul><h2 id="二维图形交互技术"><a href="#二维图形交互技术" class="headerlink" title="二维图形交互技术"></a>二维图形交互技术</h2><p>图形用户界面又称为 WIMP 界面——是第二代人机界面，是基于图形方式的人机界面。</p><p><strong>图形用户界面由窗口(windows)、图标(icons)、菜单(meum)、指点设备(pointing device)四位一体，形成桌面(desktop)</strong>，输出可以为静态或动态的二维图形或图像。</p><p>图</p><ul><li><p>几何约束</p><p>可以用于对图形的方向、对齐方式等进行规定和校准。</p><p>定位约束：网格吸附。方向约束：检测夹角。</p></li><li><p>引力场</p><p>引力场也可以看作是一种定位约束，通过在特定图素（如直线段）周围假想有一个区域，当光标中心落在这个区域内时，就自动地被直线上最近的一个点所代替，就好像一个质点进入了直线周围的引力场，被吸引到这条直线上去一样。</p><p>引力场的大小要适中，太小了不易进入引力区，太大了线和线的引力区相交，光标在进入引力区相交部分时可能会被吸引到不希望选的线段上去，增大误接的概率。</p></li><li><p>拖动</p><p>要把一个对象移动到一个新的位置时，如果我们不是简单地用光标指定新位置的一个点，而是当光标移动时拖动着被移动的对象，这样会使用户感到更直观，并可使对象放置的位置更恰当。</p></li><li><p>橡皮筋技术</p><p>被拖动对象的形状和位置随着光标位置的不同而变化。</p><p>不断地进行画图－擦除－画图的过程（从开始到(x,y)绘图，擦除，从开始到(x,y) 加偏移量绘图）。</p></li><li><p>操作柄技术</p></li></ul><p>可以用来对图形对象进行缩放、旋转、错切等几何变换。先选择要处理的图形对象，该图形对象的周围会出现操作柄，移动或旋转操作柄就可以实现相应的变换。</p><h2 id="三维图形交互技术"><a href="#三维图形交互技术" class="headerlink" title="三维图形交互技术"></a>三维图形交互技术</h2><ul><li><p>面临问题：</p><p>三维交互技术采用六自由度输入设备。所谓六自由度，指沿三维空间 X、Y、Z 轴平移和绕 X、Y、Z 轴旋转，而现在流行的用于桌面型图形界面的交互设备，如鼠标、轨迹球、触摸屏等只有两个自由度(沿平面 X、Y 轴平移)。</p><p>窗口、菜单、图符和传统的二维光标在三维交互环境中会破坏空间感，用户难以区分屏幕上光标选择到对象的深度值和其他显示对象的深度值，使交互过程非常不自然。</p></li><li><p>直接操纵</p><p><strong>通过三维光标，用户可以选择并直接操作虚拟对象。三维光标可以是人手的三维模型，输入设备的位置和方向被映射为虚拟手的位置和方向</strong>。</p><p>三维光标必须有深度感，即必须考虑光标与观察者距离，离观察者近的时候较大，离观察者远的时候较小。</p><p>为保持三维用户界面的空间感，光标在遇到物体时不能进入到或穿过物体内部。</p><p>为了增加额外的深度线索，辅助三维对象的选择，可以采用半透明三维光标。</p><p>三维光标可以是人手的三维模型</p></li><li><p>三维 Widgets</p><p>三维交互界面中的一些小工具：三维空间中漂浮的菜单、用于拾取物体的手的三维图标、平移和旋转指示器等。</p><p>1992 年美国 Brown 大学计算机系提出三维 Widget 设计原则</p></li><li><p>三视图输入<br>用二维输入设备在一定程度上实现三维的输入。</p></li></ul><h2 id="自然交互技术"><a href="#自然交互技术" class="headerlink" title="自然交互技术"></a>自然交互技术</h2><p>Bill Gates 提出自然用户界面（Nature User Interface）</p><ul><li><p>多点触控技术</p><p>多点触控技术是指借助光学和材料学技术，构建能同时检测多个触点的触控平台，使得用户能够运用多个手指同时操作实现基于手势的交互，甚至可以让多个用户同时操作实现基于协同手势的交互。</p><p>多点触控技术由硬件和软件两部分组成。</p><p>多点触控软件技术：触点检测和定位、手指触点跟踪、触摸手势识别。</p><ul><li><p>触点检测和定位</p><p>图像预处理过程包括：灰度变换、平滑去噪、去除背景、图像分割等。</p><p>手指触点分割，如背景减除法。即将当前帧图像与背景图像相减，若差分图像中某个像素的灰度值大于某个阈值，则判断该像素点属于运动目标区域，即触点，否则属于背景区域。</p><p>触点定位：1）对所有分割后的触点区域提取出其外轮廓，并对轮廓图进行筛选，把面积小于一定大小和外形不是凸包的触点轮廓去掉，保留真正的触点目标；2）基于触点轮廓计算手指触摸点的信息，如重心坐标等，完成触点定位。</p></li><li><p>手指触点跟踪</p><p>多点触控系统检测和定位出多个触点后，需要对每个触点进行跟踪，记录每个触点的轨迹信息，再做基于轨迹的动态手势识别，才能实现基于手势的自由交互。触点跟踪方法有 Meanshift 算法、Kalman 滤波、Kuhn-Munkres 算法及 CamShift 算法等。</p></li><li><p>触摸手势识别</p><p>多点触控交互桌面上使用的多为单手多指手势，或者双手对称手势等。单手多指手势和双手对称手势识别，是在触点检测与稳定跟踪的基础上，通过标记、分析触点轨迹，识别手势含义。</p><p>常用的手势识别方法采用隐马尔科夫模型（HMM，Hidden Markov Model）或神经网络的统计模式识别方法进行识别。基本思想是：提取手指触点特征 ，采用手势样本训练分类器，输出手势识别概率。</p></li></ul></li><li><p>手势识别技术</p><ul><li><p>手势分割</p><p>三类分割方法：一是基于直方图的分割，即阈值法；二是基于局部区域信息的分割；三是基于颜色等物理特征的分割方法。</p></li><li><p>特征提取和选择</p><p>常用的手势特征有：轮廓、边缘、图像矩、图像特征向量以及区域直方图特征等。</p></li><li><p>手势识别</p><p>模板匹配技术：它将待识别手势的特征参数与预先存储的模板特征参数进行匹配，通过测量两者之间的相似度来完成识别任务。</p><p>统计分析技术：通过统计样本特征向量来确定分类器的基于概率统计理论的分类方法。</p><p>神经网络技术：该技术具有自组织和自学习能力，具有分布性特点，能有效的抗噪声和处理不完整模式以及具有模式推广能力。</p></li></ul></li><li><p>表情识别技术</p><p>从表情识别过程来看，表情识别可分为三部分：人脸图像的获取与预处理、表情特征提取和表情分类。</p><p>人脸面部表情识别特征主要方法：</p><p>灰度特征：从表情图像的灰度值上提取的，利用不同表情用不同灰度值来得到识别的依据。</p><p>运动特征：利用了不同表情情况下人脸的主要表情点的运动信息来进行识别。</p><p>频率特征：利用了表情图像在不同的频率分解下的差别进行识别，速度快是其显著特点。</p></li><li><p>语音交互技术</p><p>语音识别（Speech Recognition）是计算机通过识别和理解过程把语音信号转变为相应的文本文件或命令的技术，其所涉及的领域包括：信号处理、模式识别、概率论和信息论、发声机理和听觉机理、人工智能等。<br>一个完整的语音识别系统大致可分为语音特征提取，声学模型与模式匹配，以及语言模型与语义理解三部分。</p></li></ul>]]></content>
    
    
    <categories>
      
      <category>Computer Science</category>
      
      <category>人机交互</category>
      
    </categories>
    
    
    <tags>
      
      <tag>人机交互</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>FPGA学习——Week1</title>
    <link href="/post/cfbb3381.html"/>
    <url>/post/cfbb3381.html</url>
    
    <content type="html"><![CDATA[<h1 id="Week-1"><a href="#Week-1" class="headerlink" title="Week 1"></a>Week 1</h1><p>第一周内容主要为后续 FPGA 学习奠定基础，主要包含三部分内容</p><ol><li><p>History of Programmable Logic</p><p>用以介绍可编程逻辑器件的历史，引入 FPGA 发展的背景。</p></li><li><p>CPLD, its architecture and performance</p><p>研究第一个可重变成期间，其架构以及对性能的影响。</p></li><li><p>Introduce FPGA, contrast with CPLD, and LUT makeup</p><p>介绍 FPGA，对比 CPLD。</p></li></ol><p>什么是 FPGA？</p><blockquote><p>What is an FPGA? Generally, it is an integrated circuit consisting of an array of programmable logic blocks with programmable routing between the blocks, that allows the device to be configured to perform complex digital logic functions.</p></blockquote><p>资料</p><blockquote><p>FPGAs for Dummies, Altera Version, available here: <a href="http://design.altera.com/New2FPGAeBook" target="_blank" rel="noopener">link</a>, Chapters 1, 2, and 5 (27 pages)<br>Rapid Prototyping of Digital Systems: SOPC Edition, by Hamblen, Hall and Furman; ISBN 9780387726700, Chapter 3 (14 pages)<br>Design Recipes for FPGAs Using Verilog and VHDL, 2nd Edition, by Peter Wilson, Chapter 2 (7 pages)</p></blockquote><h2 id="A-Brief-History-of-Programmable-Logic"><a href="#A-Brief-History-of-Programmable-Logic" class="headerlink" title="A Brief History of Programmable Logic"></a>A Brief History of Programmable Logic</h2><p>FPGA 是可编程器件的一个子集</p><p>发展历程</p><ul><li>1956 PROM Invented （Programmable Read Only Memory）</li><li>1971 EPROM （Eraseable Programmable Read-only Memory）</li><li>1975 PLAs （Programmable Logic Arrays）</li><li>1978 PALs （Programmable Array Logic）</li></ul><p>图示：硬连接、可编程连接、无连接</p><p>PAL，PLA 区别貌似是在与门可编程还是或门可编程上，而 CPLD 和 FPGA 更像是两个框架，不同公司会给出不同的优劣评判。</p>]]></content>
    
    
    <categories>
      
      <category>Computer Science</category>
      
      <category>FPGA</category>
      
    </categories>
    
    
    <tags>
      
      <tag>FPGA</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>投资银行学——Lec4</title>
    <link href="/post/4cf23916.html"/>
    <url>/post/4cf23916.html</url>
    
    <content type="html"><![CDATA[<p>CAPM 模型作为理论和实践的桥梁</p><p>理论与实践的差异和关联</p><ul><li>成功得投资是未来收回的现金流现值远大于当前透出的现金流限制</li><li>DCF 从理论而言是最准确的估值方法，基于未来预期收益额</li><li>CAPM 模型实际上是起到了一个“行路靠右”规范的作用</li></ul><h1 id="现金流折现方法-DCF"><a href="#现金流折现方法-DCF" class="headerlink" title="现金流折现方法 DCF"></a>现金流折现方法 DCF</h1><p>销售额、XXXXXX</p><p>在不知道折现率的情况下如何算 NPV 衡量两家公司的状况</p><p>套用市场无风险利率?</p><p>ANS：IRR，NPV 为 0 的时候计算内部收益率。</p><p>持续经营的投资定价模型</p><p>投资于经营活动产生红利，因此：股权价值=期望股利的现值</p><p>持续经营预期下：股权价值=期望股利的现值+期望到期价值的现值</p><p>永续年金/增长型永续年金</p>]]></content>
    
    
    <categories>
      
      <category>Finance</category>
      
      <category>投资银行学</category>
      
    </categories>
    
    
    <tags>
      
      <tag>投资银行学</tag>
      
      <tag>辅修</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>数据分析与融合——幂集格角度分析证据计算与粗糙集的关系</title>
    <link href="/post/83759fa6.html"/>
    <url>/post/83759fa6.html</url>
    
    <content type="html"><![CDATA[<h1 id="引言"><a href="#引言" class="headerlink" title="引言"></a>引言</h1><p>在前述的课程中，我们学习了粗糙集理论以及其应用：决策系统代数约简。在上一篇相关文章《<a href="https://www.edwardzcn98yx.com/post/be292322.html">数据分析与融合——偏序格角度看决策系统代数约简</a>》，我也总结了课程的相关内容，其中，有一个明显而又重要的结论：<strong>决策系统的约简实际上是在论域元素$U$的细分偏序格上的寻优过程</strong>。</p><p>随着课程深入，我们又接连学习了分辨矩阵、证据理论、证据计算等，在学习证据计算这一章节时，由证据理论，我们引入了<code>证据空间</code>，<code>基元</code>等概念，从知识粒度的角度思考，其理论框架和前述学习的粗糙集及其所应用的决策系统约简有一定的相似性。</p><p>本文主要从一个基本问题——有限集合的幂集上的包含关系是否构成格，来研究<code>粗糙集</code>与<code>证据理论</code>这两套框架的相似性。</p><h1 id="离散数学基础"><a href="#离散数学基础" class="headerlink" title="离散数学基础"></a>离散数学基础</h1><ul><li><p><code>集合</code>、<code>关系</code>：</p><p>按照离散数学中学习的定义（虽然我不大清楚所学是朴素集合论还是康托尔公理化集合论）。</p></li><li><p><code>偏序关系</code>：</p><p>$R$是集合$S$上的一个二元关系，且$R$满足：自反性、反对称性、传递性，则$R$为集合$S$上的偏序关系，记作$\preceq$</p></li><li><p><code>偏序集</code>：</p><p>若在集合$S$上给定一个偏序关系$\preceq$，则称集合$S$按偏序关系 $\preceq$ 构成一个偏序集合，集合 $S$ 和偏序 $\preceq$ 一起称为偏序集，记作$(S,\preceq)$</p></li><li><p><code>哈塞图</code>：</p><p>解释略</p></li><li><p><code>极大元素与极小元素</code>：</p><ul><li>$a$在偏序集$(S,\preceq)$中是极大的，当不存在$b \in S$使得$a \preceq b$</li><li>$a$在偏序集$(S,\preceq)$中是极小的，当不存在$b \in S$使得$b \preceq a$</li></ul></li><li><p><code>上界与下界</code>：</p><ul><li>$\exists u \in S$使得$\forall a \in A, a \preceq u$，即$u$偏序大于偏序集$(S, \preceq)$的子集$A$中所有元素。那么$u$叫做$A$的一个上界。</li><li>$\exists l \in S$使得$\forall a \in A, l \preceq a$，即$l$偏序小于偏序集$(S, \preceq)$的子集$A$中所有元素。那么$l$叫做$A$的一个下界。</li><li>若$S$的子集$A$存在一个上界$u_0$，偏序小于所有其他$A$的上界，则称为$A$的最小上界。</li><li>若$S$的子集$A$存在一个下界$l_0$，偏序大于所有其他$A$的下界，则称为$A$的最大上界。</li></ul></li><li><p><code>偏序格定义</code>（格的集合定义）：<br>如果一个偏序集的<strong>每对</strong>元素（构成的子集）都有最小上界和最大下界，就称这个偏序集为格。</p></li><li><p><code>代数格定义</code>（格的代数定义）：<br>在集合 $L$ 中定义两个代数运算 $∨$ 和 $∧$，这两个代数运算满足：幂等律、交换律、结合律、吸收率，则称该代数系统为格。</p></li></ul><p>温习离散数学相关知识，我们知道一个子集$A$可能有上界但无最小上界，有下界但无最大下界，“有界”是“有最界”的必要而非充分条件。</p><p>格，则是偏序集加上了对“最界”存在的限制，由于单元素集合上下最界就是其集合所含的唯一元素，显然成立，那么要求每对元素都有最界，那么任意子集就是有最界的（易证，略），从格的代数定义理解，实际上就是满足了<code>交</code>和<code>并</code>代数运算的完备性。</p><a id="more"></a><h1 id="幂格"><a href="#幂格" class="headerlink" title="幂格"></a>幂格</h1><p>回到课堂上那个问题，<strong>集合的幂集与其上的包含关系构成格吗</strong>？</p><p>答案是肯定的。</p><p>我在机械工业出版社《离散数学及其应用》（Knneth H.Rosen 著）上找到了例题说明，而且，证明幂格存在也是简单的。</p><p><img src="https://eddyblog.oss-cn-shenzhen.aliyuncs.com/RoughSet/Lattice_1.jpg" srcset="/img/loading.gif" alt="jpg"></p><p>证明正如图所给，我写完整一些，$S$为集合，$P(S)$（有些习惯写为$2^{S}$）为$S$的幂集，证明过程如下：</p><p>首先证明$(P(S), \subseteq)$是偏序集：</p><ul><li>自反性，对于任意$A \subseteq S$（也即$A \in P(S)$），$A \subseteq A$，满足自反性。</li><li>反对称性：由$A \subseteq B$，$B \subseteq A$可推出$A = B$，满足反对称性。</li><li>传递性：$A \subseteq B$，$B \subseteq C$可推出$A \subseteq C$，满足传递性</li></ul><p>所以$(P(S), \subseteq)$是偏序集。</p><p>接着再构造性证明$(P(S), \subseteq)$是格，从序理论证明有点困难（我确实没想到证交、并为最小上界和最大下界的方法），所以应用<a href="https://en.wikipedia.org/wiki/Lattice_(order" target="_blank" rel="noopener">格的两个定义的等价性</a>&gt;)，我们尝试证明$(P(S),\cup,\cap)$为代数格。</p><p>$A,B \in P(S)$，即 $A,B$ 为原集合$S$的任意两个子集，则必为幂集的两个元素，构造$C = A \cup B, D = A \cap B$，显然$C,D \in P(S)$。</p><ul><li>交换律：$A \cap B = B \cap A$，$A \cup B = B \cup A$</li><li>结合律：$A  \cap (B \cap C) = (A \cap B) \cap C$，$A \cup (B \cup C) = (A \cup B) \cup C$</li><li>吸收律：$A \cup (A \cap B) = A$，$A \cap (A \cup B) = A$</li><li>幂等律：$A \cap A = A$，$A \cup A = A$</li></ul><p>所以$(P(S), \subseteq)$（代数表示为$(P(S),\cup,\cap)$）是格。</p><p>举一个简单的幂格的例子，并用哈斯图形式表示出来，即《离散数学及其应用》430 页所给的$(P({a,b,c}), \subseteq)$的哈斯图。</p><p>显然，由图我们也可以直观看出，三元素集合的幂集是一个格，它有底和顶。</p><p><img src="https://eddyblog.oss-cn-shenzhen.aliyuncs.com/RoughSet/Lattice_2.png" srcset="/img/loading.gif" alt="png"></p><p>那么我自己绘制了一个四元素集合幂集的格图，如下</p><p><img src="https://eddyblog.oss-cn-shenzhen.aliyuncs.com/RoughSet/Lattice_3.png" srcset="/img/loading.gif" alt="png"></p><h1 id="两种粒度"><a href="#两种粒度" class="headerlink" title="两种粒度"></a>两种粒度</h1><p>我自己的理解，粗糙集理论的粒度模型是<strong>不可分辨关系</strong>（等价关系）确定的划分构成的，而证据计算的粒度模型是对于有限集幂集构成的证据空间讨论的，由于$2^{U}$包含了所有的粒度（从空到完整）。</p><p>简单的数学表述：</p><p>问题$X$的所有可能取值构成非空有限集$U = \{ x_1,x_2, \cdots ,x_{n-1}, x_n \}$。</p><ul><li><p>粗糙集模型：</p><p>（这里按照《基于粗集理论的多属性决策分析》（后文简称《粗集理论》）一书的习惯性表述来写）</p><p>粗糙集一般应用在决策表中，引入全属性集$A$，则$B$属性集族定义一个不可分辨关系$I_B = \{ (x,y) \in U \times U : f(x,a) = f(y,a), \forall a \in B \}$，这个定义是针对决策表属性讲的（直观表述即两论域元素$x,y$对$B$属性集中任意属性列取值均相同，所以不可分辨）。</p><p>讨论空间：集合上的所有划分形成的空间</p><p>原子集（信息基本粒子）：等价类$I_B(X)$</p><p>复合集：原子集的<strong>任意并集</strong></p></li><li><p>证据计算模型</p><p>讨论空间：集合的幂集空间</p><p>原子集/复合集（信息的各种粒度）：所有可能子集，其中单点集对应确定命题，复合集对应不确定命题</p><p>所以实际上证据计算模型我的理解是是给了从最细粒度（单点集）到最粗粒度（原命题）所有的粒度，并给不同粒度独立进行赋值。</p></li></ul><h1 id="粗糙集中近似与证据理论信度函数的关系"><a href="#粗糙集中近似与证据理论信度函数的关系" class="headerlink" title="粗糙集中近似与证据理论信度函数的关系"></a>粗糙集中近似与证据理论信度函数的关系</h1><p>我们先来看定义</p><ul><li><p>粗糙集的近似：</p><p>课件中：</p><ul><li>下近似： $\underline{apr}(X) = \{ x | [x]_R \subseteq X \}$</li><li>上近似：$\overline{apr}(X) = \{ x| [x]_R \cap X \not ={\emptyset} \}$</li></ul><p>《粗集理论》中：</p><p>设$S$为信息表，$X$为$U$的非空子集，$B \subseteq A$且$B \not ={\emptyset}$，集合$X$的$B$下近似和$B$上近似为：</p><ul><li>下近似：$\underline{B}(X) = \{x \in U : I_B(x) \subseteq X\}$</li><li>上近似：$\overline{B}(X) = \{x \in U : I_B(x) \cap X \not ={\emptyset}\}$</li></ul><p>实际上老师课件中给出的$R$实际上就是属性族$B$所定义的不可分辨关系（等价关系$I_B$），所以两种表述实际上只是形式不同而已。</p><p>我们不难发现，近似的结果仍为$U$的一个子集，近似运算实际上是定义在$U \times U$的</p></li><li><p>证据理论的信度函数</p><p>那我们再来看信度函数(信任函数和似然函数)，按照老师的课件上来，为了和上面对应把$X$，$A$表示调换了一下，没有实际影响。</p><ul><li>信任函数：$BEL(X) = \sum_{A \subseteq X} m(A)$</li><li>似然函数：$PL(X) = \sum_{A \cap X \not ={\emptyset}} m(A)$</li></ul><p>实际上我们已经发现其形式和粗糙集的“近似”有了相关性，为了方便进一步思考，我们将信度函数的计算拆分成两步——1. 找集合 2.概率累加。首先寻找满足条件的子集$A$，然后将其基本概率分配（bpa）$m_S$累加起来。</p></li></ul><h2 id="联系与区别"><a href="#联系与区别" class="headerlink" title="联系与区别"></a>联系与区别</h2><p>联系</p><ul><li>X 均表示当前命题</li><li>下近似/信任函数表示命题完全包含的知识粒度（或其对应的取值）</li><li>上近似/似然函数表示与命题相交的所有知识粒度（或其对应的取值）</li></ul><p>区别</p><ul><li><p>粒度表示不同</p><ul><li>粗糙集粒度是等价关系决定的等价类，划分的等价类两两不相交，而一个属性子集就确定了一个等价关系。</li><li>证据计算的粒度是所有可能子集，子集间还有包含、相交等关系，不需要由属性确定等价关系，所有子集的空间（幂格）本身就是完备的。</li></ul></li><li><p>格对应的层级不同</p><p>虽然“格”的概念在粗糙集和证据理论中都有出现，但是其表征的含义，和所在的层级确是不同的。</p><ul><li>粗糙集中，“格”出现在决策表约简过程中，不同属性集对应不同的等价关系$I_B$从而决定了细分偏序格中的位置，而不同的划分实际上表示了不同的“知识粒度”的不同。</li><li>证据计算中，“格”出现在粒度本身的定义中，由于该框架下知识粒度本身就有粗细结构（虽然基本概率独立赋值），其知识本身就呈现“格”结构。</li></ul></li></ul><h2 id="图示"><a href="#图示" class="headerlink" title="图示"></a>图示</h2><p>下面举出一个四元素集合$\{ x_1,x_2,x_3,x_4 \}$的例子，来表示上述的分析结果。</p><p><img src="https://eddyblog.oss-cn-shenzhen.aliyuncs.com/RoughSet/Lattice_4.png" srcset="/img/loading.gif" alt="png"></p><p><img src="https://eddyblog.oss-cn-shenzhen.aliyuncs.com/RoughSet/Lattice_5.png" srcset="/img/loading.gif" alt="png"></p><p><img src="https://eddyblog.oss-cn-shenzhen.aliyuncs.com/RoughSet/Lattice_6.png" srcset="/img/loading.gif" alt="png"></p><p><img src="https://eddyblog.oss-cn-shenzhen.aliyuncs.com/RoughSet/Lattice_7.png" srcset="/img/loading.gif" alt="png"></p><h1 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h1><p>经过查阅相关资料以及自己动手实践，我确信了以下几个结论：</p><ol><li>有限集合的幂集确实是格</li><li>证据理论幂集格与决策表约简的细分偏序格虽有相似，但是格结构描述层级不一样，幂集格描述的是粒度本身的关系，而细分偏序格描述的是不同粒度描述之间的关系</li></ol><h1 id="拓展"><a href="#拓展" class="headerlink" title="拓展"></a>拓展</h1><p>我在查阅《粗集理论》这本参考书时，发现作者在绪论章节描述“粗集理论与其他不确定性理论的融合”这部分时提到了粗集理论和证据理论的关系，在此摘录，日后可深入学习。</p><p>粗集和 Dempster-Shafer 的证据理论</p><p><img src="https://eddyblog.oss-cn-shenzhen.aliyuncs.com/RoughSet/Lattice_8.JPG" srcset="/img/loading.gif" alt="jpg"></p><p><img src="https://eddyblog.oss-cn-shenzhen.aliyuncs.com/RoughSet/Lattice_9.JPG" srcset="/img/loading.gif" alt="jpg"></p>]]></content>
    
    
    <categories>
      
      <category>Computer Science</category>
      
      <category>数据分析与融合</category>
      
    </categories>
    
    
    <tags>
      
      <tag>数据分析与融合</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>投资银行学——Lec3</title>
    <link href="/post/d296acb5.html"/>
    <url>/post/d296acb5.html</url>
    
    <content type="html"><![CDATA[<p>上一周，主要讨论了的是 IPO 相关内容，由于政策的非确定性，粗略将了一下。</p><p>提问环节</p><p>监管机构，证监会（财务部-&gt;中国人民银行-&gt;证监会监管管理的改变）</p><p>招股说明书，和金融学同学写过的报告哪个最为相似？</p><p>从某种程度讲，<strong>招股说明书</strong>有点像<strong>商业项目书</strong></p><p>什么是买壳上市</p><p>买壳方：未上市</p><p>壳公司：债务情况不够良好</p><p>反向收购？被收购方的控制人，成了实际上的控制人</p><p>买壳风险：需要承担壳公司先前的债务负担，需要清壳，注入资产的过程，业务关联性较大的公司会降低一定的买壳风险（对债务的评估以及轻壳以后的业务发展有较好的帮助。</p><h1 id="上市公司再融资"><a href="#上市公司再融资" class="headerlink" title="上市公司再融资"></a>上市公司再融资</h1><p>有时候 IPO 并不赋予融资功能，不如开始的新三板，就有相关的业务。公司上市有了融资的平台，配股增发等举措。</p><p>从大的方面来讲，主要有三种方法：<strong>银行贷款融资</strong>、<strong>债券融资</strong>、<strong>股票融资等</strong>。</p><p>公司IPO有一种“财富放大器”的效用。</p><h2 id="上市公司发行新股"><a href="#上市公司发行新股" class="headerlink" title="上市公司发行新股"></a>上市公司发行新股</h2><p>分<strong>增发</strong>和<strong>配股</strong></p><p>增发与配股的比较：</p><ul><li>在发行条件和程序方面：配股是向原有股东按一定比例配售，<strong>不涉及引入新的股东</strong>,因此发行条件要低于增发（以现行股价一定折扣来配售），发行程序也较为甲东南，成为上市公司最常规的再融资方式</li><li>从定价方式看，配股价格由承销商和上市公司根据市场预期，采用现行估价折扣法确定，而增发的定价方式更为<strong>市场化</strong>（公募增发采用询价方式，相比配股的定价方式，与IPO询价大同小异，更具市场化）</li><li>公募增发原则上没有数量的限制，可能是倍数关系（而非配股的10配3），从而在市场上可以募集到更多的资金。这笔资金可以成为处于高速成长阶段，一般涉及大规模的资产重组。</li><li>一些细微差别，配股是定向的，而增发则根据募集方式而不一定是定向的，它分为公募增发和定向增发；配股不需要项目支持，可以用于补充公司资本，增发则需要配套项目支持。（香港市场比A股市场管制要松一些，对于增发限制更低，A股市场需要报批证监会）（配股不吃会由中介机构吃下）</li></ul><p>在我国，1998年5月以前，配股基本上是我国上市公司再融资的唯一方式。</p><p>课下思考，为何？</p><p>2001年，证监会发布《上市公司发行可转债实施办法》，（老师评：发行可转债要求要比增发、配股更低，配股要求是三年平均下来净资产收益率不低于7%，当时的怪现象，公司伪造业绩低迷来避免7%的迫近导致人们警觉“圈钱”）。</p><p>2007年之后，定向增发成为了上市公司再融资的重要方式，同时，转摘亦由传统方式转变为可分离债的方式。</p><h2 id="上市公司发行可转换公司债券"><a href="#上市公司发行可转换公司债券" class="headerlink" title="上市公司发行可转换公司债券"></a>上市公司发行可转换公司债券</h2><h2 id="再融资的承销风险"><a href="#再融资的承销风险" class="headerlink" title="再融资的承销风险"></a>再融资的承销风险</h2>]]></content>
    
    
    <categories>
      
      <category>Finance</category>
      
      <category>投资银行学</category>
      
    </categories>
    
    
    <tags>
      
      <tag>投资银行学</tag>
      
      <tag>辅修</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>Go学习——《Go语言程序设计》Chap5</title>
    <link href="/post/e99105ce.html"/>
    <url>/post/e99105ce.html</url>
    
    <content type="html"><![CDATA[<h1 id="过程式编程"><a href="#过程式编程" class="headerlink" title="过程式编程"></a>过程式编程</h1><p>我学习的主要关注点是 Go 语言的并发编程，而过程式编程是并发编成和面向对象编程的基础，这一节主要细致探究过程式编程中的一些问题（语句控制结构、自定义类型和函数等）</p><h2 id="语句基础"><a href="#语句基础" class="headerlink" title="语句基础"></a>语句基础</h2><p>形式上 Go 语言语法需要分号，但是编译器帮我们完成了这项任务，在以<strong>字母字面量、字符串字面量、右括号系列、一些特定关键字和增建操作符</strong>结尾的<strong>非空行末尾</strong>自动加上了分号。</p><p>两个地方必须使用分号：</p><ul><li>一行中放入一条或者多条语句</li><li>原始 for 循环</li></ul><p>自动插入分号的一个重要结果是<strong>一个左大括号不能单独成行</strong>（变相限制了代码风格），比如下面这个就是不可通过编译的</p><pre><code class="hljs Go"><span class="hljs-comment">// 错误代码</span><span class="hljs-keyword">for</span> i := <span class="hljs-number">0</span>; i &lt; <span class="hljs-number">5</span>; i++&#123;    fmt.Println(i)&#125;</code></pre><p>内置函数</p><p>除了之前见到较多的<code>append()</code>，<code>len()</code>，<code>cap()</code>，<code>make()</code>等，要着重关注学习异常相关的两个内置函数：</p><ul><li><code>panic(x)</code> 抛出一个运行时异常，其值为 x。</li><li><code>recover()</code> 捕获一个运行时异常。</li></ul><h3 id="快速声明操作符"><a href="#快速声明操作符" class="headerlink" title="快速声明操作符"></a>快速声明操作符</h3><p>快速声明操作符号<code>:=</code>用于同时在一个语句中声明和赋值一个变量。多个逗号分割的用法和<code>=</code>赋值操作符一样，需要强调的是，其本身不会新建作用域，即<strong>除了必须至少有一个非空变量为新的，如果变量已经存在了，它就会被直接赋值，而不会新建一个变量，除非该<code>:=</code>操作符位于作用域的起始处，如<code>if</code>或者<code>for</code>语句中的初始化语句</strong>。</p><p><code>:=</code>可以创建“影子”变量覆盖外层同名变量的值，这很方便，但在有些地方可能会引起失误和问题。</p><p>我们可以在有<strong>一到多个命名返回值</strong>的函数中写<strong>无需返回值的裸 return</strong>。这种情况下，返回值将是命名的返回值，它们在函数入口被初始化为其类型零值。</p><p>如果出现了返回值同名“影子”变量且涉及到 return，好在 Go 编译器会给出一个错误消息，正如下面这个样子。</p><p><img src="https://eddyblog.oss-cn-shenzhen.aliyuncs.com/Go/Go_Ch5_1.png" srcset="/img/loading.gif" alt="png"></p><h3 id="类型转换"><a href="#类型转换" class="headerlink" title="类型转换"></a>类型转换</h3><p>转换语法</p><pre><code class="hljs Go">resultOfType := Type(expression)</code></pre><p>非数值类型之间的转换不会丢失精度，但是数值类型之间可能会。</p><h3 id="类型断言"><a href="#类型断言" class="headerlink" title="类型断言"></a>类型断言</h3><p>方式有安全/非安全（抛出异常）两种</p><pre><code class="hljs Go">resultOfType, boolean := expression.(Type) <span class="hljs-comment">// 安全类型断言</span>resultOfType := expression.(Type) <span class="hljs-comment">//非安全类型断言，失败时panic()</span></code></pre><p>if+类型断言赋值给同名变量（影子变量）很常见，如果目标类型可以是很多类型之一，我们可以使用类型开关。</p><h2 id="分支"><a href="#分支" class="headerlink" title="分支"></a>分支</h2><h3 id="if-语句"><a href="#if-语句" class="headerlink" title="if 语句"></a>if 语句</h3><p>Go 里面的经典用法：</p><pre><code class="hljs Go"><span class="hljs-keyword">if</span> optionalSatement1; booleanExpression1&#123;    block1&#125;<span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> optionalStatement2; booleanExpression2&#123;    block2&#125;<span class="hljs-keyword">else</span> &#123;    block3&#125;</code></pre><p>放在 if 语句中的<code>optionalStatement</code>作用于整个 if…else…if 语句，也限制于其中。</p><h3 id="switch-语句"><a href="#switch-语句" class="headerlink" title="switch 语句"></a>switch 语句</h3><p>Go 语言中有两种类型的 switch 语句：表达式开关（expression switch）和类型开关（type switch）。表达式开关语句对于 C/C++/Java 程序员来说比较熟悉，然而类型开关语句是 Go<strong>专有的</strong>。</p><p>需要强调的是，不同于 C/C++/Java，Go 语言的 switch 语句不会自动地乡下贯穿（因此不用每个 case 后面都加 break），相反，我们可以在需要的时候通过显式地调用 fallthrough 语句来这样做。</p><ul><li><p>表达式开关<br>紧凑经典实用举例：</p><p>只使用一个表达式，一个带返回类型的函数，然后用逗号分割相同操作的不同 case（而舍弃用 fallthrough 贯穿写）。</p><pre><code class="hljs Go"><span class="hljs-keyword">switch</span> Suffix(file)&#123;    <span class="hljs-keyword">case</span> <span class="hljs-string">".gz"</span>:        <span class="hljs-keyword">return</span> GzipFileList(file)    <span class="hljs-keyword">case</span> <span class="hljs-string">".tar"</span>, <span class="hljs-string">".tar.gz"</span>, <span class="hljs-string">"tgz"</span>:        <span class="hljs-keyword">return</span> TarFileList(file)    <span class="hljs-keyword">case</span> <span class="hljs-string">".zip"</span>:        <span class="hljs-keyword">return</span> ZipFileList(file)&#125;</code></pre></li><li><p>字符开关<br>与类型断言相似，但是使用<code>type</code>关键字代替实际类型，以用于表示任意类型</p><pre><code class="hljs Go"><span class="hljs-keyword">switch</span> x.(<span class="hljs-keyword">type</span>)&#123;    <span class="hljs-keyword">case</span> <span class="hljs-keyword">bool</span>:        block1    <span class="hljs-keyword">case</span> <span class="hljs-keyword">float64</span>:        block2    <span class="hljs-keyword">case</span> <span class="hljs-keyword">int</span>,<span class="hljs-keyword">int8</span>,<span class="hljs-keyword">int16</span>,<span class="hljs-keyword">int32</span>,<span class="hljs-keyword">int64</span>:        block3    <span class="hljs-keyword">case</span> <span class="hljs-literal">nil</span>:        block4    <span class="hljs-keyword">case</span> <span class="hljs-keyword">string</span>:        block5    <span class="hljs-keyword">default</span>:        block6&#125;</code></pre><p>经典应用，反序列化一个内部结构未知的原始 JSON 对象，并创建和打印 JSON 对象的字符串表示。</p></li></ul><a id="more"></a><h3 id="for-循环语句"><a href="#for-循环语句" class="headerlink" title="for 循环语句"></a>for 循环语句</h3><p>for 和 for…range，记住 Go 的循环全是 for，包括但不限于</p><ul><li>for{} -&gt; while(1)</li><li>for Expression -&gt; while(expression)</li><li>for k,v := range() -&gt; for k,v in …</li></ul><h3 id="通信和并发语句"><a href="#通信和并发语句" class="headerlink" title="通信和并发语句"></a>通信和并发语句</h3><p>通信与并发特性在第 7 章详讲，这里描述基本语法。</p><ul><li><p><code>goroutine</code></p><p><code>goroutine</code>是程序中与其他<code>goroutine</code>完全相互独立而并发执行的函数或者方法调用。每一个 Go 程序都至少有一个，即 main 函数中运行的。</p><p><code>goroutine</code>非常像轻量级的线程或者协程。它们可以被大批量地创建。所有的<code>goroutine</code>共享相同的地址空间。同时 Go 语言提供了锁原语 🔓 来保证数据能够安全地跨<code>goroutine</code>共享。然而，Go 语言推荐的并发编程方式是通信，而非共享数据。</p><p>创建方式</p><pre><code class="hljs Go"><span class="hljs-keyword">go</span> function(argu) <span class="hljs-comment">// 调用已有的函数</span><span class="hljs-keyword">go</span> <span class="hljs-function"><span class="hljs-keyword">func</span><span class="hljs-params">(parameters)</span></span> &#123; block &#125; (argu) <span class="hljs-comment">// 调用一个临时创建的匿名函数</span></code></pre><p>被调用函数执行会立即进行，但是是在另一个<code>goroutine</code>上执行，并且当前<code>goroutine</code>（包含 go 语句的）会从下一条语句中恢复。</p></li><li><p>通信</p><p>通过通信管道实现多个<code>goroutine</code>之间通信（发送接受数据）。发送分为阻塞发送 （<code>channeel &lt;- value</code>）和非阻塞发送（<code>select</code>实现）</p><p>创建通道的方式</p><pre><code class="hljs Go"><span class="hljs-built_in">make</span>(<span class="hljs-keyword">chan</span> Type) <span class="hljs-comment">//未指定容量，同步</span><span class="hljs-built_in">make</span>(<span class="hljs-keyword">chan</span> Type, capacity)  <span class="hljs-comment">//指定容量，异步。</span></code></pre><p>我的实验代码，实验结果输出至 testoutput.txt，发现每次运行，输出顺序不一致，可以体现不同<code>goroutine</code>的相对独立。</p><pre><code class="hljs Go"><span class="hljs-comment">// createChannel 接受一个int类型的参数，返回一个int类型的通道</span><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">createChannel</span><span class="hljs-params">(startInt <span class="hljs-keyword">int</span>, chanName <span class="hljs-keyword">string</span>)</span> <span class="hljs-title">chan</span> <span class="hljs-title">int</span></span> &#123;    next := <span class="hljs-built_in">make</span>(<span class="hljs-keyword">chan</span> <span class="hljs-keyword">int</span>)    <span class="hljs-comment">// 建立新的goruntime</span>    <span class="hljs-keyword">go</span> <span class="hljs-function"><span class="hljs-keyword">func</span><span class="hljs-params">(i <span class="hljs-keyword">int</span>, name <span class="hljs-keyword">string</span>)</span></span> &#123;        <span class="hljs-keyword">for</span> &#123;            next &lt;- i            fmt.Printf(<span class="hljs-string">"Channel %8s is now adding number %d\n"</span>, name, i)            i++        &#125;    &#125;(startInt, chanName)    <span class="hljs-comment">// 由于chan是引用类型，所以返回以后在子goruntime还会继续运行</span>    <span class="hljs-keyword">return</span> next&#125;<span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span> &#123;  counterA := createChannel(<span class="hljs-number">8</span>, <span class="hljs-string">"ChannelA"</span>)  counterB := createChannel(<span class="hljs-number">108</span>, <span class="hljs-string">"ChannelB"</span>)  <span class="hljs-keyword">for</span> i := <span class="hljs-number">0</span>; i &lt; <span class="hljs-number">20</span>; i++ &#123;      a := &lt;-counterA      fmt.Printf(<span class="hljs-string">"(A-&gt;%d, B-&gt;%d)\n"</span>, a, &lt;-counterB)  &#125;&#125;</code></pre><p><code>select</code>语句，在一个<code>select</code>语句中，如果发现任意一句可以继续执行（没有被阻塞），则选择。如果全部通道都被阻塞，有 default 则执行并从<code>select</code>后恢复，否则整个语句阻塞，直到一一句可以继续执行。</p></li></ul><h3 id="defer、panic-和-recover"><a href="#defer、panic-和-recover" class="headerlink" title="defer、panic 和 recover"></a>defer、panic 和 recover</h3><p>defer 语句用于延迟一个函数或者方法（或者当前所创建的匿名函数）的执行，它会再外围函数或者方法返回之前但是其返回值计算之后执行。这样就有可能在一个<strong>延迟执行</strong>的函数内部<strong>修改函数的命名返回值</strong>。多个 defer 语句按 LIFO 顺序执行。</p><p>defer 最常用是保证一个文件使用完以后关闭<code>defer file.Close()</code></p><p>panic 和 revover，前文已经阐述过 Go 语言将错误和异常区分对待，错误（可预期的）常通过函数的返回值形式实现，而对于“不可能发生”的情况（异常）我们使用内置的<code>panic()</code>函数。</p><p>当内置的<code>panic()</code>函数被调用时，外围函数或者方法的执行会立即中止。然后，任何延迟执行的函数或者方法都会被调用，就像返回一样。最后，调用返回到该外围函数的调用者，就像该外围调用函数或者方法调用了<code>panic()</code>一样，该过程在调用栈中重复发生：函数停止执行，调用延迟执行函数等。当到达<code>main()</code>函数时不再有可以返回的调用者，因此这时程序会中止，并将包含传入原始<code>panic()</code>函数中的值的调用栈信息输出到<code>os.Stderr</code>。</p><p>上面所描述的只是一个异常发生时正常情况下所展开的。然而，如果其中有个延迟执行的函数或者方法包含一个对内值的<code>recover()</code>函数（可能值在一个延迟执行的函数或者方法中调用），该异常展开就会中止（被捕获）。这种情况下，我们就能够以任何我们想要的方式相应该异常（忽略，转错误等）。</p><h3 id="异常和错误的使用规范"><a href="#异常和错误的使用规范" class="headerlink" title="异常和错误的使用规范"></a>异常和错误的使用规范</h3><p><strong>绝大多数情况下，Go 语言标准库实验嗯 error 值而非异常。</strong>（标准库的规范），对于我们手写的自定义的包，尽量不要使用<code>panic()</code>，如果要使用，也要避免异常离开这个自定义包的边界，可以用<code>recover()</code>捕获异常并返回一个相应的错误值，就像标准库中所作的那样。</p><p>作为一个程序员，如果程序中有逻辑错误，我们希望程序能够立马崩溃，以便我们可以发现并修改该问题。但一旦程序部署好了，我们就不想让我们的程序崩溃。</p><p>对于任何特殊情况下可能运行也G可能不运行的函数或者方法，如果调用了<code>panic()</code>函数或者调用了发生异常的函数或者方法，我们应该使用<code>recover()</code>以保证将异常转换成错误。理想情况下，<code>recover()</code>函数应该在尽可能接近于<code>panic()</code>的地方背调用，并在设置其外围函数 error 返回值之前尽可能合理的将程序恢复到健康状态。对于 main 包的<code>main()</code>函数，我们可以放入一个<strong>“捕获一切”的<code>recover</code>函数</strong>，用于记录任何捕获的异常。</p><h2 id="自定义函数"><a href="#自定义函数" class="headerlink" title="自定义函数"></a>自定义函数</h2><p>这里内容有点繁杂，需要自己多动手实践体会</p><p>关于返回值：如果函数有返回值，则函数必须至少有一个 return 语句或者<code>panic()</code>调用，如果返回值不是命名的，则 return 语句必须指定和返回值列表一样多的值。如果有命名，也尽量写全 return（空 return 语句虽然合法，但是被认为是一种拙劣的写法。）</p><h3 id="函数参数"><a href="#函数参数" class="headerlink" title="函数参数"></a>函数参数</h3><ul><li><p>函数调用可以作为函数参数</p><p>需要类型和数量匹配，如<code>Heron(a,b,c)</code>与<code>Heron(PythagoreanTriple(i,i+1))</code>，其中<code>PythagoreanTriple(i,i+1)</code>返回三个整数值。</p></li><li><p>可变函数参数</p><p>最后一个类型前面加一个省略号，在函数里面这个参数实际上变成了一个对应参数类型的切片。如我们有一个签名是<code>Join(first string, xs ...String)</code>的函数，<code>xs</code>类型实际上是<code>[]string</code></p><p>常见的可变参数设置是：完全任意（可空参），至少一参，至少两参（前面单独列出即可）。</p></li><li><p>可选参数</p><p>Go 没有直接支持可选参数，要实现也不难，只需增加一个额外的结构体即可，而且 Go 语言能保证所有值都会被初始化为零值。</p></li></ul><p>一个比较优雅的做法是这样定义函数 <code>ProcessItems(items Items, options Options)</code>，其中 Options 结构体保存了所有其他参数的值，其结构为：</p><pre><code class="hljs Go"><span class="hljs-keyword">type</span> Options <span class="hljs-keyword">struct</span>&#123;    First <span class="hljs-keyword">int</span> <span class="hljs-comment">//要处理的第一项</span>    Last <span class="hljs-keyword">int</span> <span class="hljs-comment">//要处理的最后一项</span>    Audit <span class="hljs-keyword">bool</span> <span class="hljs-comment">//如果为true，所有动作都被记录</span>    ErrorHandler <span class="hljs-function"><span class="hljs-keyword">func</span><span class="hljs-params">(item Item)</span>&#125;</span></code></pre><p>Go 保证结构体传入初始化为零值，大部分需要默认场合（全零值的情况），调用很简单，如果需要制定一个或者多个，则填入对应的字段名即可，如下：</p><pre><code class="hljs Go">ProcessItems(items, Options&#123;&#125;)ProcessItems(items, Options&#123;Audit: <span class="hljs-literal">true</span>, ErrorHandler: errorHandler&#125;)</code></pre><h3 id="init-函数和-main-函数"><a href="#init-函数和-main-函数" class="headerlink" title="init()函数和 main()函数"></a>init()函数和 main()函数</h3><p>Go 语言保留两个函数名：<code>init()</code>函数用来导入包后执行，全<code>main()</code>函数，作为入口，这两个函数不显示调用，也不可接受任何参数，不返回任何结果。建议一个包最多只用一个<code>init()</code>函数。</p><p>程序启动顺序如下：</p><p><img src="https://eddyblog.oss-cn-shenzhen.aliyuncs.com/Go/Go_Ch5_2.png" srcset="/img/loading.gif" alt="png"></p><h3 id="闭包"><a href="#闭包" class="headerlink" title="闭包"></a>闭包</h3><p>这是个重要的概念，所谓闭包就是一个函数“捕获”了和它在同意作用域地其他常量和变量（或许可以理解成声明时就调用了在这个作用域地其他常量和变量），闭包使用这些捕获的量且不关心它们是否已经超出作用域，所以只要闭包还在使用它，这些变量就还会存在。在 Go 语言里，<strong>所有的匿名函数（Go 语言规范中称之为函数字面量）</strong>都是<strong>闭包</strong>。</p><p>闭包没有名字，通常使用方法时赋值给一个变量或者将它放在一个数据结构里（如映射/切片）。</p><p>另外，工厂函数（装饰函数）返回的也常为一个函数闭包，函数闭包也常出现在一些函数参数中</p><h3 id="运行时选择函数"><a href="#运行时选择函数" class="headerlink" title="运行时选择函数"></a>运行时选择函数</h3><p>在 Go 语言里，函数属于第一类值（first-class value），也就是说，你可以将它保存到一个变量（实际上是一个引用）里，这样我们就可以在运行时决定要执行哪一个函数（比 if-else 运行时选择来的快）。</p><p>根据书上写的实验</p>]]></content>
    
    
    <categories>
      
      <category>Computer Science</category>
      
      <category>Go</category>
      
    </categories>
    
    
    <tags>
      
      <tag>Go</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>IOS——IOS系统使用Google服务</title>
    <link href="/post/bb820b96.html"/>
    <url>/post/bb820b96.html</url>
    
    <content type="html"><![CDATA[<p>今天在 PC 整理 Timetable 时使用的是 Google Calendar，觉得颇为好用，就想在移动端上进行同步，不过 Google 同步由于一些不可抗力因素无法进行。直接的不行，就曲线救国吧。</p><h1 id="Apple-美区"><a href="#Apple-美区" class="headerlink" title="Apple 美区"></a>Apple 美区</h1><p>自行寻找方法，淘也好，注册也好，在此不再赘述。购买完成后记得改密码换问题答案。</p><h2 id="Kits…😈-软件"><a href="#Kits…😈-软件" class="headerlink" title="Kits…😈 软件"></a>Kits…😈 软件</h2><p>由于阴影小火箭等软件在国内都被搜索屏蔽，我从官方网站上只找到了 Kits…😈（全程自行官网搜索）的软件，支持 v-core 可自定义配置。</p><p>TB 上可以搜到美区的兑换码，购入，切美区，填码，下载。</p><p>然后从指定位置导入<code>config.json</code>即可，配置文件可以从 PC 端正在使用的客户端导出。</p><p>BTW，Kits…😈也有安卓端。</p>]]></content>
    
    
    <categories>
      
      <category>Computer Science</category>
      
      <category>工具</category>
      
    </categories>
    
    
    <tags>
      
      <tag>工具</tag>
      
      <tag>IOS</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>Go学习——《Go语言程序设计》Chap4</title>
    <link href="/post/9e963558.html"/>
    <url>/post/9e963558.html</url>
    
    <content type="html"><![CDATA[<h1 id="集合类型"><a href="#集合类型" class="headerlink" title="集合类型"></a>集合类型</h1><p>Go 语言的指针与 C/C++中的之后怎类似，无论是语法上还是语意上。但是 Go 语言的指针不支持指针运算，这样就消除了在 C/C++程序中一类潜在的 bug。Go 语言也不用 free()函数或者 delete 操作符号，因为 Go 语言有垃圾回收器，并且自动管理内存。</p><h2 id="值、指针和引用类型"><a href="#值、指针和引用类型" class="headerlink" title="值、指针和引用类型"></a>值、指针和引用类型</h2><p>通常情况下 Go 语言的变量持有相应的值。也就是说，我们可以将一个变量想象成它所持有的值来使用。其中有些例外是对于通道、函数、方法、映射以及切片的引用变量。它们持有的都是<strong>引用</strong>，也即<strong>保存指针的变量</strong>。</p><p>对于字符串，如果修改一个传入的字符串（例如，使用<code>+=</code>操作符），Go 语言必须创建一个新的字符串，并且复制原始的字符串，并将其加到该字符串之后，这对于大字符串来说很可能代价非常大。（实际上，如<a href="https://www.edwardzcn98yx.com/post/f2a0fb.html">Chap3</a>里面讲的，更多时候我们会准备一个字符切片<code>[]string</code>,或者用<code>bytes.Buffer</code>对应方法实现）</p><p>剩下的指针与 C/C++及其类似，在此不再赘述，需要特别了解的是，虽然 Go 编译器可能在内部将栈和堆的内存区分对待，但是 Go 程序员从不需要担心这些，因为 Go 语言自己会在内部处理好内存管理的事情。</p><p>我的测试</p><pre><code class="hljs Go">z := <span class="hljs-number">37</span>pi := &amp;zppi := &amp;pifmt.Println(z, *pi, **ppi)**ppi++fmt.Println(z, *pi, **ppi)fmt.Println(reflect.TypeOf(pi))fmt.Println(reflect.TypeOf(ppi))</code></pre><p>测试结果</p><pre><code class="hljs Go"><span class="hljs-number">37</span> <span class="hljs-number">37</span> <span class="hljs-number">37</span><span class="hljs-number">38</span> <span class="hljs-number">38</span> <span class="hljs-number">38</span>*<span class="hljs-keyword">int</span>**<span class="hljs-keyword">int</span></code></pre><p>对于 swap 等操作（需要对变量本身而非变量的副本进行操作），C/C++的常见思路是将需要操作的原始变量的指针以参数形式传入函数并进行修改，而 Go 提供了一个更人性化的方法，一般而言，对于少量这样的变量，我们仍采用按值传递的方式，然后通过<strong>多返回值</strong>的设计完成需要，或者，对于大量的，我们会传入一个切片来达到效果。</p><p>表示成功与失败，C/C++中习惯传入一个布尔类型指针，Go 语言中直接以最后一个返回值的形式返回一个布尔型的成功标志（或者最好是一个 error 值）的写法更好用。</p><a id="more"></a><h2 id="数组和切片"><a href="#数组和切片" class="headerlink" title="数组和切片"></a>数组和切片</h2><h3 id="数组的创建方法"><a href="#数组的创建方法" class="headerlink" title="数组的创建方法"></a>数组的创建方法</h3><pre><code class="hljs Go">[length]Type[N]Type&#123;v1,v2,v3,...,vn&#125;[...]Type&#123;v1,v2,v3,...,vn&#125;</code></pre><p><code>...</code>在这种场景下使用，Go 会自动补全，我们可以理解为定长度的（与后面切片的变长相对应）。</p><p>一般而言，Go 语言的切片比数组更加灵活、强大且方便。数组是按值传递的（即传递副本，虽然可以通过传递指针来避免，PS 这么操作的话 Go 比 C/C++还反人类）。</p><p>虽然数组和切片所保存的元素类型相同，但<strong>在实际使用中并不受此限</strong>。这是因为其类型也可以是一个接口。因此<strong>我们可以保存任意满足</strong>所声明的接口的元素（即它们定义了该接口所需的方法）。然后我们可以让一个数组或者切片为空接口 <code>interface{}</code>，这意味着我们可以存储任意类型的元素，不过这导致我们在获取一个元素时需要使用<strong>类型断言</strong>或者<strong>类型转变</strong>，或者两者配合使用。</p><h3 id="切片的创建方法"><a href="#切片的创建方法" class="headerlink" title="切片的创建方法"></a>切片的创建方法</h3><pre><code class="hljs Go"><span class="hljs-built_in">make</span>([]Type, length, capacity)<span class="hljs-built_in">make</span>([]Type, length)[]Type&#123;&#125;[]Type&#123;value1,value2,...,valueN&#125;</code></pre><p>切片创建时会创建一个<strong>隐藏的</strong>初始化为零值的数组（如果使用第四种方法则是有初始值的）。一个切片的容量即为其隐藏数组的长度，而其长度为不超过容量的任意值。</p><p>实际中使用空切片，<code>make()</code>创建会更实用，只需将长度设为 0，并且将容量设为一个我们估计需要保存元素的个数。</p><p><strong>切片再切片是引用</strong>，<strong>切片参数也是引用</strong>，都是对同一底层数组的引用，其中一个<strong>改变</strong>会影响到其他所有指向该相同数组的任何其他引用。</p><p>二维切片的实验：</p><p>使用长度为 3（即包含三个切片和容量为 3（默认容量为其长度）来创建一个切片的切片 grid），我们尝试让内层切片长度不一样。</p><pre><code class="hljs Go"><span class="hljs-keyword">package</span> main<span class="hljs-keyword">import</span> (    <span class="hljs-string">"fmt"</span>    <span class="hljs-string">"os"</span>    <span class="hljs-string">"strconv"</span>)<span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span> &#123;    <span class="hljs-comment">// debug参数设定为 ["3","4","5"]</span>    <span class="hljs-keyword">if</span> <span class="hljs-built_in">len</span>(os.Args) &lt; <span class="hljs-number">4</span> &#123;    fmt.Println(<span class="hljs-string">"This program needs three int:"</span>)    os.Exit(<span class="hljs-number">1</span>)    &#125;    grid1 := <span class="hljs-built_in">make</span>([][]<span class="hljs-keyword">int</span>, <span class="hljs-number">3</span>)    <span class="hljs-keyword">for</span> index := <span class="hljs-number">0</span>; index &lt; <span class="hljs-number">3</span>; index++ &#123;        parint, _ := strconv.ParseInt(os.Args[index+<span class="hljs-number">1</span>], <span class="hljs-number">10</span>, <span class="hljs-number">0</span>)        grid1[index] = <span class="hljs-built_in">make</span>([]<span class="hljs-keyword">int</span>, parint)    &#125;    fmt.Println(grid1)    grid1[<span class="hljs-number">0</span>][<span class="hljs-number">0</span>], grid1[<span class="hljs-number">1</span>][<span class="hljs-number">1</span>], grid1[<span class="hljs-number">2</span>][<span class="hljs-number">2</span>] = <span class="hljs-number">1</span>, <span class="hljs-number">2</span>, <span class="hljs-number">3</span>    fmt.Println(grid1)    <span class="hljs-comment">// [[0 0 0] [0 0 0 0] [0 0 0 0 0]]</span>    <span class="hljs-comment">// [[1 0 0] [0 2 0 0] [0 0 3 0 0]]</span>    <span class="hljs-comment">// 符合预期</span>&#125;</code></pre><h3 id="遍历切片"><a href="#遍历切片" class="headerlink" title="遍历切片"></a>遍历切片</h3><p>for…range 循化，带循环计数器的循环，（”_“）表示丢弃该值</p><p>我的实验：</p><pre><code class="hljs Go">grid2 := <span class="hljs-built_in">make</span>([]<span class="hljs-keyword">int</span>, <span class="hljs-number">5</span>)<span class="hljs-keyword">for</span> _, i := <span class="hljs-keyword">range</span> grid2 &#123;    fmt.Println(i)    i = <span class="hljs-number">2</span>&#125;fmt.Println(grid2)<span class="hljs-keyword">for</span> k, _ := <span class="hljs-keyword">range</span> grid2 &#123;    grid2[k] = <span class="hljs-number">2</span>&#125;fmt.Println(grid2)</code></pre><p>输出为</p><pre><code class="hljs Go"><span class="hljs-number">0</span><span class="hljs-number">0</span><span class="hljs-number">0</span><span class="hljs-number">0</span><span class="hljs-number">0</span>[<span class="hljs-number">0</span> <span class="hljs-number">0</span> <span class="hljs-number">0</span> <span class="hljs-number">0</span> <span class="hljs-number">0</span>][<span class="hljs-number">2</span> <span class="hljs-number">2</span> <span class="hljs-number">2</span> <span class="hljs-number">2</span> <span class="hljs-number">2</span>]</code></pre><p>发现取到的值是值，改变并不会引起切片的改变，<strong>如果我们想要修改切片中的项，我们必须使用可以提供有效切片索引而非仅仅是元素副本的 for 循环</strong>，需要区分切片本身引用与 for 循环取值副本的差别。</p><h3 id="切片的修改"><a href="#切片的修改" class="headerlink" title="切片的修改"></a>切片的修改</h3><pre><code class="hljs Go">s = []<span class="hljs-keyword">string</span>&#123;&#125;t = []<span class="hljs-keyword">string</span>&#123;<span class="hljs-string">"a"</span>,<span class="hljs-string">"b"</span>,<span class="hljs-string">"c"</span>,<span class="hljs-string">"d"</span>&#125;s = <span class="hljs-built_in">append</span>(s,<span class="hljs-string">"h"</span>,<span class="hljs-string">"i"</span>,<span class="hljs-string">"j"</span>) <span class="hljs-comment">//添加多个单一值</span>s = <span class="hljs-built_in">append</span>(s, t...) <span class="hljs-comment">//添加t整个切片中所有值</span>s = <span class="hljs-built_in">append</span>(s, t[<span class="hljs-number">1</span>:<span class="hljs-number">3</span>]...) <span class="hljs-comment">// 添加一个子切片所有值</span>b := []<span class="hljs-keyword">byte</span>&#123;<span class="hljs-string">'U'</span>,<span class="hljs-string">'V'</span>&#125;letters := <span class="hljs-string">"WXY"</span>b = <span class="hljs-built_in">append</span>(b, letters...) <span class="hljs-comment">//将字符串字节添加到字节且片中</span></code></pre><p><code>...</code>这时候很像<code>解包</code>，把切片拆解为底层构成元素然后统一放入。</p><h3 id="排序和搜索切片"><a href="#排序和搜索切片" class="headerlink" title="排序和搜索切片"></a>排序和搜索切片</h3><p>一些常用方法：<code>sort.Float64s()</code>,<code>sort.Ints()</code>,<code>sort.IntsAreSorted()</code>等等。</p><p><code>sort.Sort()</code>函数能够对任意类型进行排序，只需其类型提供了<code>sort.Int结果义的方法，**即只要这些类型根据相应的签名实现了</code>Len(结果 Swap()`**等方法，便可以使用函数排序，下面是自己对结果</p><pre><code class="hljs Go"><span class="hljs-keyword">package</span> m结果<span class="hljs-keyword">import</span> (    <span class="hljs-string">"fmt"</span>结果    <span class="hljs-string">"sort"</span>    <span class="hljs-string">"strings"</span>)<span class="hljs-keyword">type</span> FoldedString []<span class="hljs-keyword">string</span><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-params">(slice FoldedString)</span> <span class="hljs-title">Len</span><span class="hljs-params">()</span> <span class="hljs-title">int</span></span> &#123;    <span class="hljs-keyword">return</span> <span class="hljs-built_in">len</span>(slice)&#125;<span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-params">(slice FoldedString)</span> <span class="hljs-title">Less</span><span class="hljs-params">(i <span class="hljs-keyword">int</span>, j <span class="hljs-keyword">int</span>)</span> <span class="hljs-title">bool</span></span> &#123;    <span class="hljs-keyword">return</span> strings.ToLower(slice[i]) &lt; strings.ToLower(slice[j])&#125;<span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-params">(slice FoldedString)</span> <span class="hljs-title">Swap</span><span class="hljs-params">(i <span class="hljs-keyword">int</span>, j <span class="hljs-keyword">int</span>)</span></span> &#123;    slice[i], slice[j] = slice[j], slice[i]&#125;<span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span> &#123;    test1 := <span class="hljs-built_in">make</span>(FoldedString, <span class="hljs-number">2</span>)    test1 = <span class="hljs-built_in">append</span>(test1, <span class="hljs-string">"who"</span>)    test1 = <span class="hljs-built_in">append</span>(test1, <span class="hljs-string">"What"</span>)    test1 = <span class="hljs-built_in">append</span>(test1, <span class="hljs-string">"Answer"</span>)    fmt.Println(test1)    sort.Sort(test1)    fmt.Println(test1)&#125;</code></pre><p><code>sort.Search()</code>提供了一个二分搜索算法的函数。该函数两个参数：长度、与元素比较的函数（必须为闭包，闭包在下一节涉及）。</p><h2 id="映射"><a href="#映射" class="headerlink" title="映射"></a>映射</h2><p>某些场合也成为散列映射、散列表、无序映射、字典。</p><h3 id="映射的操作"><a href="#映射的操作" class="headerlink" title="映射的操作"></a>映射的操作</h3><div class="table-container"><table><thead><tr><th style="text-align:left">语法</th><th style="text-align:left">含义/结果</th></tr></thead><tbody><tr><td style="text-align:left"><code>make[k] = v</code></td><td style="text-align:left">用键 k 将值 v 赋给映射 m。如果映射中存在，抛弃原先值。</td></tr><tr><td style="text-align:left"><code>Delete(m,k)</code></td><td style="text-align:left">将键 k 及其值从映射 m 删除，如果不存在则安全地不进行任何操作。</td></tr><tr><td style="text-align:left"><code>v:= m[k]</code></td><td style="text-align:left">从映射 m 中取得键 k 的值赋给 v，如果不存在则赋<strong>类型 0 值</strong></td></tr><tr><td style="text-align:left"><code>v,found := m[k]</code></td><td style="text-align:left">v 同上，存在则 found 为 true，否则为 false</td></tr><tr><td style="text-align:left"><code>len(m)</code></td><td style="text-align:left">返回映射 m 中的项数</td></tr></tbody></table></div><p>创建删除等过程和切片很类似（make 方式），时间复杂度直接索引要比切片慢两个数量级（非正式数据）</p><h2 id="例子：猜测分割符"><a href="#例子：猜测分割符" class="headerlink" title="例子：猜测分割符"></a>例子：猜测分割符</h2><p>例子很简单，二维切片<code>counts [][]int</code>，外层是<code>sepIndex</code>（分割符的 index），内层是<code>lineIndex</code>行数，统计一下内层全相同且不为 0 的就可以了。</p><h2 id="例子：词频统计"><a href="#例子：词频统计" class="headerlink" title="例子：词频统计"></a>例子：词频统计</h2><p>这个例子里面涉及到 UTF 编码文件的分割和映射反转（多值），所以详细看了下。</p><h3 id="处理文件"><a href="#处理文件" class="headerlink" title="处理文件"></a>处理文件</h3><ul><li><p>主函数</p><pre><code class="hljs Go"><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span> &#123;    <span class="hljs-keyword">if</span> <span class="hljs-built_in">len</span>(os.Args) == <span class="hljs-number">1</span> || os.Args[<span class="hljs-number">1</span>] == <span class="hljs-string">"-h"</span> || os.Args[<span class="hljs-number">1</span>] == <span class="hljs-string">"--help"</span> &#123;        fmt.Printf(<span class="hljs-string">"usage: %s &lt;file1&gt; [&lt;file2&gt; [... &lt;fileN&gt;]]\n"</span>,            filepath.Base(os.Args[<span class="hljs-number">0</span>]))        os.Exit(<span class="hljs-number">1</span>)    &#125;    frequencyForWord := <span class="hljs-keyword">map</span>[<span class="hljs-keyword">string</span>]<span class="hljs-keyword">int</span>&#123;&#125; <span class="hljs-comment">// Same as: make(map[string]int)</span>    <span class="hljs-keyword">for</span> _, filename := <span class="hljs-keyword">range</span> commandLineFiles(os.Args[<span class="hljs-number">1</span>:]) &#123;        updateFrequencies(filename, frequencyForWord)    &#125;    reportByWords(frequencyForWord)    wordsForFrequency := invertStringIntMap(frequencyForWord)    reportByFrequency(wordsForFrequency)&#125;</code></pre><p>主函数描述了基本流程，建立空映射，便利文件处理更新映射。得到第一个映射后就输出第一份报告<code>reportByWords()</code>这是以字符为键的，然后进行映射反转构建以频数为键的多值映射，并输出第二份报告<code>reportByFrequency()</code>。</p></li><li><p>Windows 通配符处理函数</p><pre><code class="hljs Go"><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">commandLineFiles</span><span class="hljs-params">(files []<span class="hljs-keyword">string</span>)</span> []<span class="hljs-title">string</span></span> &#123;    <span class="hljs-keyword">if</span> runtime.GOOS == <span class="hljs-string">"windows"</span> &#123;        args := <span class="hljs-built_in">make</span>([]<span class="hljs-keyword">string</span>, <span class="hljs-number">0</span>, <span class="hljs-built_in">len</span>(files))        <span class="hljs-keyword">for</span> _, name := <span class="hljs-keyword">range</span> files &#123;            <span class="hljs-keyword">if</span> matches, err := filepath.Glob(name); err != <span class="hljs-literal">nil</span> &#123;                args = <span class="hljs-built_in">append</span>(args, name) <span class="hljs-comment">// Invalid pattern</span>            &#125; <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> matches != <span class="hljs-literal">nil</span> &#123; <span class="hljs-comment">// At least one match</span>                args = <span class="hljs-built_in">append</span>(args, matches...)            &#125;        &#125;        <span class="hljs-keyword">return</span> args    &#125;    <span class="hljs-keyword">return</span> files&#125;</code></pre><p>由于 cmd 不支持通配符，对传入参数（文件名）进行预处理</p></li><li><p>文件处理函数</p><pre><code class="hljs Go"><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">updateFrequencies</span><span class="hljs-params">(filename <span class="hljs-keyword">string</span>, frequencyForWord <span class="hljs-keyword">map</span>[<span class="hljs-keyword">string</span>]<span class="hljs-keyword">int</span>)</span></span> &#123;    <span class="hljs-keyword">var</span> file *os.File    <span class="hljs-keyword">var</span> err error    <span class="hljs-keyword">if</span> file, err = os.Open(filename); err != <span class="hljs-literal">nil</span> &#123;        log.Println(<span class="hljs-string">"failed to open the file: "</span>, err)        <span class="hljs-keyword">return</span>    &#125;    <span class="hljs-keyword">defer</span> file.Close()    readAndUpdateFrequencies(bufio.NewReader(file), frequencyForWord)&#125;</code></pre><p>打开文件，并用<code>defer</code>让函数返回时关闭文件句柄，并将文件作为<code>*bufferio.Reader</code>传给实际工作函数，实际工作函数<code>readAndUpdateFrequencies()</code><strong>按行读取而不是读取</strong>字节流。</p></li><li><p>实际工作函数</p><pre><code class="hljs Go"><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">readAndUpdateFrequencies</span><span class="hljs-params">(reader *bufio.Reader,    frequencyForWord <span class="hljs-keyword">map</span>[<span class="hljs-keyword">string</span>]<span class="hljs-keyword">int</span>)</span></span> &#123;    <span class="hljs-keyword">for</span> &#123;        line, err := reader.ReadString(<span class="hljs-string">'\n'</span>)        <span class="hljs-keyword">for</span> _, word := <span class="hljs-keyword">range</span> SplitOnNonLetters(strings.TrimSpace(line)) &#123;            <span class="hljs-keyword">if</span> <span class="hljs-built_in">len</span>(word) &gt; utf8.UTFMax ||                utf8.RuneCountInString(word) &gt; <span class="hljs-number">1</span> &#123;                frequencyForWord[strings.ToLower(word)] += <span class="hljs-number">1</span>            &#125;        &#125;        <span class="hljs-keyword">if</span> err != <span class="hljs-literal">nil</span> &#123;            <span class="hljs-keyword">if</span> err != io.EOF &#123;                log.Println(<span class="hljs-string">"failed to finish reading the file: "</span>, err)            &#125;            <span class="hljs-keyword">break</span>        &#125;    &#125;&#125;</code></pre><p>一个无限循环一行一行读取文件，出现错误的时候报告并给 log，但不直接退出程序（因为还有其他文件需要处理）。</p><p>按行读取<code>reader.ReadString(&#39;\n&#39;)</code>，然后内循环处理每行，对单词进行分割并忽略掉非单词的字符。一开始使用<code>strings.TrimeSpace(line)</code>去除行开头和结束的空白。</p><p>为了快速检查，使用 if 的两个分句，首先检查其长度是否大于 UTF 最多需要的字节，如果多，则必为符合要求的 word（因为分割是按照非 unicode 的 letter 分割的），如果少，那么再特判断，检查 rune 的个数。</p><ul><li><p>分割函数</p><pre><code class="hljs Go"><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">SplitOnNonLetters</span><span class="hljs-params">(s <span class="hljs-keyword">string</span>)</span> []<span class="hljs-title">string</span></span> &#123;    notALetter := <span class="hljs-function"><span class="hljs-keyword">func</span><span class="hljs-params">(char <span class="hljs-keyword">rune</span>)</span> <span class="hljs-title">bool</span></span> &#123; <span class="hljs-keyword">return</span> !unicode.IsLetter(char) &#125;    <span class="hljs-keyword">return</span> strings.FieldsFunc(s, notALetter)&#125;</code></pre><p>用于对行进行字符切分，应用的是<code>strings.FieldsFunc</code>，传入原始字符串和 bool 类型返回值的函数，进行多字符切分（字符串一节有涉及），<code>strings.Split</code>和<code>strings.FieldsFunc</code>详细解释，可以看着一篇<a href="https://medium.com/@mlowicki/strings-fieldsfunc-vs-strings-split-96c667912f78" target="_blank" rel="noopener">Medium:strings.FieldsFunc vs strings.Split</a>。</p></li></ul></li><li><p>统计、反映射与输出函数</p><p>给出实现，不再分析</p><pre><code class="hljs Go"><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">reportByWords</span><span class="hljs-params">(frequencyForWord <span class="hljs-keyword">map</span>[<span class="hljs-keyword">string</span>]<span class="hljs-keyword">int</span>)</span></span> &#123;    words := <span class="hljs-built_in">make</span>([]<span class="hljs-keyword">string</span>, <span class="hljs-number">0</span>, <span class="hljs-built_in">len</span>(frequencyForWord))    wordWidth, frequencyWidth := <span class="hljs-number">0</span>, <span class="hljs-number">0</span>    <span class="hljs-keyword">for</span> word, frequency := <span class="hljs-keyword">range</span> frequencyForWord &#123;        words = <span class="hljs-built_in">append</span>(words, word)        <span class="hljs-keyword">if</span> width := utf8.RuneCountInString(word); width &gt; wordWidth &#123;            wordWidth = width        &#125;        <span class="hljs-keyword">if</span> width := <span class="hljs-built_in">len</span>(fmt.Sprint(frequency)); width &gt; frequencyWidth &#123;            frequencyWidth = width        &#125;    &#125;    sort.Strings(words)    gap := wordWidth + frequencyWidth - <span class="hljs-built_in">len</span>(<span class="hljs-string">"Word"</span>) - <span class="hljs-built_in">len</span>(<span class="hljs-string">"Frequency"</span>)    fmt.Printf(<span class="hljs-string">"Word %*s%s\n"</span>, gap, <span class="hljs-string">" "</span>, <span class="hljs-string">"Frequency"</span>)    <span class="hljs-keyword">for</span> _, word := <span class="hljs-keyword">range</span> words &#123;        fmt.Printf(<span class="hljs-string">"%-*s %*d\n"</span>, wordWidth, word, frequencyWidth,            frequencyForWord[word])    &#125;&#125;<span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">reportByFrequency</span><span class="hljs-params">(wordsForFrequency <span class="hljs-keyword">map</span>[<span class="hljs-keyword">int</span>][]<span class="hljs-keyword">string</span>)</span></span> &#123;    frequencies := <span class="hljs-built_in">make</span>([]<span class="hljs-keyword">int</span>, <span class="hljs-number">0</span>, <span class="hljs-built_in">len</span>(wordsForFrequency))    <span class="hljs-keyword">for</span> frequency := <span class="hljs-keyword">range</span> wordsForFrequency &#123;        frequencies = <span class="hljs-built_in">append</span>(frequencies, frequency)    &#125;    sort.Ints(frequencies)    width := <span class="hljs-built_in">len</span>(fmt.Sprint(frequencies[<span class="hljs-built_in">len</span>(frequencies)<span class="hljs-number">-1</span>]))    fmt.Println(<span class="hljs-string">"Frequency → Words"</span>)    <span class="hljs-keyword">for</span> _, frequency := <span class="hljs-keyword">range</span> frequencies &#123;        words := wordsForFrequency[frequency]        sort.Strings(words)        fmt.Printf(<span class="hljs-string">"%*d %s\n"</span>, width, frequency, strings.Join(words, <span class="hljs-string">", "</span>))    &#125;&#125;</code></pre></li></ul>]]></content>
    
    
    <categories>
      
      <category>Computer Science</category>
      
      <category>Go</category>
      
    </categories>
    
    
    <tags>
      
      <tag>Go</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>投资银行学——Lec2</title>
    <link href="/post/a5919c23.html"/>
    <url>/post/a5919c23.html</url>
    
    <content type="html"><![CDATA[<h1 id="股份有限公司"><a href="#股份有限公司" class="headerlink" title="股份有限公司"></a>股份有限公司</h1><h3 id="公司的概念和类别"><a href="#公司的概念和类别" class="headerlink" title="公司的概念和类别"></a>公司的概念和类别</h3><p><strong>公司</strong>是企业法人组织的一种重要形式（法人，经营主体）。（老师讲评：国内 IPO 前一些公司特有的“改制”，将一部分资产进行股份制改造，改造过程中会涉及一些资产的剥离等，国外资本主义环境，基本上都是自负盈亏的经营主体，IPO 前不会涉及这一特殊过程。）</p><h3 id="公司的类别"><a href="#公司的类别" class="headerlink" title="公司的类别"></a>公司的类别</h3><p>依照不同的标准，可以对公司做不同分类。</p><p>根据股东承担责任的大小划分为：有限责任公司、无限责任公司、股份有限公司、两合公司（有限合伙制）</p><ol><li><p>有限责任公司</p><p>股份公司一定是有限责任的，但是有限责任不一定为股份公司</p><p>有限责任公司股东人数既有最低限也有最高限，我国为 1 人以上 50 人以下。</p></li><li><p>股份有限公司</p><ul><li><p>我国对股份有限公司的股东人数有最低限制，要求有二人以上二百人以下发起</p></li><li><p>由于股份公司是公开向社会发股筹资的股东人数多，因此各国法律都要求股份有限公司应将其财务公开。（我国特殊规定，我国股份有限公司成立需要报批省级以上国资委）</p></li></ul><p>股份有限公司的优点</p></li><li><p>两合公司（有限合伙制）</p><ul><li>指由负责有限责任的股东和负无限责任的股东两种成员组成的公司，也成为有限合伙制。</li><li>在这类公司中，无限责任股东除负债</li></ul></li></ol><a id="more"></a><h3 id="股份有限公司的设立"><a href="#股份有限公司的设立" class="headerlink" title="股份有限公司的设立"></a>股份有限公司的设立</h3><ul><li><p>xx 设立</p></li><li><p>募集设立</p><ul><li>也叫“渐次设立”，</li></ul></li></ul><h3 id="公众公司和非公众公司"><a href="#公众公司和非公众公司" class="headerlink" title="公众公司和非公众公司"></a>公众公司和非公众公司</h3><ul><li><p>公众公司</p></li><li><p>非公众公司</p><p>经历天使人、AB 轮，都是非公众公司</p></li></ul><h2 id="公开上市"><a href="#公开上市" class="headerlink" title="公开上市"></a>公开上市</h2><h3 id="公开上市的好处"><a href="#公开上市的好处" class="headerlink" title="公开上市的好处"></a>公开上市的好处</h3><ol><li>持续融资的便利</li><li><p>公司形象的改善</p><p>比如一些投资公司有投资上的洁癖，烟草等公司就不投资，迫使一些公司做形象上的改善</p></li><li><p>提供相对合理的定价</p><p>比如国有资产的评估，可以根据市值来看，使一些评价标准化，也更加合理。</p></li><li><p>股权的流动性</p><p>管理权、控制权，相对控股（20%），就可以获得一个控制的权力，而非上市前需要达到绝对控股（51%）</p></li><li><p>股权激励计划</p><p>提供给员工的股权激励计划，高新技术</p></li></ol>]]></content>
    
    
    <categories>
      
      <category>Finance</category>
      
      <category>投资银行学</category>
      
    </categories>
    
    
    <tags>
      
      <tag>投资银行学</tag>
      
      <tag>辅修</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>投资银行学——Lec1</title>
    <link href="/post/3c98cd99.html"/>
    <url>/post/3c98cd99.html</url>
    
    <content type="html"><![CDATA[<p>有证券交易市场开始约 5-10 年后才出现了《证券法》</p><p>2000 年出现的问题：</p><p>由于评估是一种倒推的现象，国有股和法人股原本每股价 0.5/0.7，经过评估以后接近 1，所以产生了溢价，市场上恐慌情绪蔓延。</p><p>998 股改 股权分置改革</p><h3 id="我国投资银行的发展特点"><a href="#我国投资银行的发展特点" class="headerlink" title="我国投资银行的发展特点"></a>我国投资银行的发展特点</h3><ul><li><p>监管模式</p><p>集中监管模式经历了早期的：财政部独立管理阶段（1981-1985）、中国人民银行主管阶段（1986-1992）、国务院证券委员会主管阶段（1992-1998）和中国证监会主管阶段（1998 年至今）</p><p>监管方式：分业监管。不过随着金融机构边界逐渐模糊，分业向各机构协调监管靠拢</p><p>根据证券公司评价计分的高地，将证券公司分为 A（AAA、AA、A）、B（BBB、BB、B）、C（CCC、CC、C）、D、E 等五个大类十一个级别。</p></li><li><p>抗风险能力</p><p>证券公司的主要风险体现在证券市场的系统性风险方面，<strong>盈利结构单一</strong>、<strong>业务单向操作</strong>是我国证券公司目前最大的风险。</p><p>与美国的投资银行相比，我国证券公司的长期以来主要靠<strong>资本金</strong>运作，较少利用贷款融资和债券融资，<strong>杠杆比率</strong>普遍较低。（老师的观点：证券公司主要是中介的服务，应较少在市场里实际投入资金，实际投入大头应该为投资公司，证券公司主要做各种证券的承销。）</p><p>较低的杠杆率降低了政权公司的盈利能力，提高杠杆率成为未来我国证券公司发展年的一个特点，同时也带来了高杠杆率之下的风险控制要求。</p><p>（老师的观点：过去上市发行股票，股票定价是被忽视的一点，常由证监会给出建议，定价在市盈率 10 倍-20 倍，现在来说，股票估值越发被看重。）</p></li></ul><a id="more"></a>]]></content>
    
    
    <categories>
      
      <category>Finance</category>
      
      <category>投资银行学</category>
      
    </categories>
    
    
    <tags>
      
      <tag>投资银行学</tag>
      
      <tag>辅修</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>Python学习——Anaconda使用相关</title>
    <link href="/post/2e186184.html"/>
    <url>/post/2e186184.html</url>
    
    <content type="html"><![CDATA[<h1 id="Anaconda"><a href="#Anaconda" class="headerlink" title="Anaconda"></a>Anaconda</h1><h2 id="环境克隆"><a href="#环境克隆" class="headerlink" title="环境克隆"></a>环境克隆</h2><p>我已经在 A 服务器上配置好了一套我的 conda 环境，但是我现在又多出来了几台服务器，我想配置一模一样的，又不想一个一个包地重装一遍，能不能 conda 的环境直接移植到新的计算机上呢？</p><p>答案肯定是能的。只是中文的网站资料上基本没人提过这个东西。</p><p>conda 本身的命令里是有移植这个选项的。<br>假如前提是，在本地的 conda 里已经有一个 AAA 的环境，我想创建一个新环境跟它一模一样的叫 BBB，那么这样一句就搞定了：</p><pre><code class="hljs Shell">conda create -n BBB --clone AAA</code></pre><p>但是如果是跨计算机呢。</p><p>其实是一样的，查询 conda create 命令的说明：</p><blockquote><p>–clone ENV</p><p>Path to (or name of) existing local environment.</p></blockquote><p>所以</p><pre><code class="hljs Shell">conda create -n BBB --clone ~/path</code></pre><a id="more"></a>]]></content>
    
    
    <categories>
      
      <category>Computer Science</category>
      
      <category>Python</category>
      
    </categories>
    
    
    <tags>
      
      <tag>Python</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>Go学习——《Go语言程序设计》Chap3</title>
    <link href="/post/f2a0fb.html"/>
    <url>/post/f2a0fb.html</url>
    
    <content type="html"><![CDATA[<h1 id="字符串"><a href="#字符串" class="headerlink" title="字符串"></a>字符串</h1><p>本章讲解 Go 语言的字符串类型</p><p>一个 Go 语言字符串是一个任意字节的常量序列。大部分情况下，一个字符串的字节使用 UTF-8 编码表示 Unicode 文本。</p><h2 id="字面量、操作符和转义"><a href="#字面量、操作符和转义" class="headerlink" title="字面量、操作符和转义"></a>字面量、操作符和转义</h2><p>字符串字面量使用双引号（”）或者反引号（’）来创建，主要区别如下</p><ul><li><p><code>&quot;</code></p><p>双引号创建<strong>可解析的字符串字面量</strong>，比如带转义，但不能用来引用多行。</p></li><li><p><code>&#39;</code></p><p>反引号创建<strong>原生的子字符串字面量</strong>，这些字符串可能由多行组成，不支持任何转义序列，并且可以包含除了反引号之外的任何字符。</p></li></ul><p>可解析的字符串使用得最广泛，而原生的字符串字面量则用于书写多行消息、HTML 以及正则表达式，这里有一些例子。</p><p>如果想创建一个长的可解析字符串字面量，但又不想在代码中写同样长的一行（想要换为多行），我们可以考虑使用<code>+</code>级联，或者<code>+=</code>追加。（当然这不是来追加的更好的方式，见下一节）</p><pre><code class="hljs Go">book := <span class="hljs-string">"The Spirit Level"</span> +        <span class="hljs-string">" by Richard Wilkinson"</span>book += <span class="hljs-string">" and Kate Pickett"</span>fmt.Print(book)</code></pre><h2 id="字符和字符串"><a href="#字符和字符串" class="headerlink" title="字符和字符串"></a>字符和字符串</h2><p>一个字符串可以使用语法<code>chars := []rune(s)</code>转换成一个<code>rune</code>（即码点）切片，其中<code>s</code>是一个字符串类型的值。变量<code>chars</code>的类型为<code>[]int32</code>，因为<code>rune</code>是<code>int32</code>的同义词（基本数据类型处解释过）。这在我们需要<strong>逐个字符解析字符串</strong>，<strong>同时需要在解析过程中能产看前一个或后一个字符时会有用</strong>。相反的转换也同样简单，其语法为<code>s := string(chars)</code>。两个转化时间代价都是$O(n)$</p><p>虽然方便，但是使用<code>+=</code>操作符并不是一个循环中往字符串末尾追加字符串最有效的方式。一个更好的方式（Python 程序员熟悉）是准备好一个字符串切片（[]string），然后使用<code>strings.Join()</code>函数一次性将其中所有字符串串连起来。但在 Go 语言中还有一个更好的方法，其原理类似 Java 中的<code>StringBuilder</code>，例子如下：</p><pre><code class="hljs Go"><span class="hljs-keyword">var</span> buffer bytes.Buffer<span class="hljs-keyword">for</span> &#123;    <span class="hljs-keyword">if</span> piece, ok := getNextValidString(); ok&#123;        buffer.WriteString(piece)    &#125; <span class="hljs-keyword">else</span> &#123;        <span class="hljs-keyword">break</span>    &#125;&#125;</code></pre><p>将一个<code>bytes.Buffer</code>类型中的字符串累加起来可能比<code>+=</code>操作符在节省内存和操作符方面高效得多，特别当级联的字符串数量很大时。</p><a id="more"></a><h2 id="字符串索引与切片"><a href="#字符串索引与切片" class="headerlink" title="字符串索引与切片"></a>字符串索引与切片</h2><p>切片并不是万能的，对于字符全是 7 位 ASCII 编码的字符情况下切片简单又方便，因为<code>字节</code>与<code>索引位置</code>是一一对应的，而这种情况下<code>字节</code>和<code>字符</code>也是一一对应的。</p><p>然而当处理非 ASCII 码文本则更有挑战，因为这些字符可能用一个或者多个字节表示，如下图展示。</p><p><img src="https://eddyblog.oss-cn-shenzhen.aliyuncs.com/Go/Go_Ch3_1.png" srcset="/img/loading.gif" alt="png"></p><p>通常我们完全不需要切片一个字符串，只需要<code>for...range</code>循环将其一个字符一个字符的迭代（注意这里是按字符），但是有些情况下我们确实需要使用切片来获得一个子字符串，精确得到切片索引的方法<code>strings.Index()</code>、<code>strings.LastIndex()</code>。</p><p>下面是一个自己写的例子</p><pre><code class="hljs Go"><span class="hljs-comment">// 我的测试</span>s := <span class="hljs-string">"What ever you input 👿"</span><span class="hljs-comment">// for ... range 循环输出</span><span class="hljs-keyword">for</span> _, x := <span class="hljs-keyword">range</span> s &#123;    fmt.Printf(<span class="hljs-string">"-%c-"</span>, x)&#125;fmt.Println(s)fmt.Print(<span class="hljs-string">"Last index of ' ' = "</span>)<span class="hljs-comment">// LastIndex 说明</span><span class="hljs-comment">// LastIndex returns the index of the last instance of substr in s, or -1 if substr is not present in s.</span><span class="hljs-comment">// LastIndex 输出的是末尾，也即不包含值，对于单个字节应为该字节后面一个索引</span>fmt.Println(strings.LastIndex(s, <span class="hljs-string">" "</span>))<span class="hljs-comment">// 👿最后的index实验以及输出</span>evilBeginIndex := strings.LastIndex(s, <span class="hljs-string">" "</span>)evilLastIndex := strings.LastIndex(s, <span class="hljs-string">""</span>)fmt.Print(<span class="hljs-string">"Begin index of 👿: "</span>)fmt.Println(evilBeginIndex)fmt.Print(<span class="hljs-string">"Last index of 👿: "</span>)fmt.Println(evilLastIndex)fmt.Println(<span class="hljs-string">""</span>)fmt.Print(<span class="hljs-string">"Differ of the two index: "</span>)fmt.Println(evilLastIndex - evilBeginIndex)fmt.Print(<span class="hljs-string">"Print the evil: "</span>)fmt.Println(s[evilBeginIndex:evilLastIndex])<span class="hljs-comment">// 输出长度</span><span class="hljs-built_in">len</span> := <span class="hljs-built_in">len</span>(s)fmt.Println(<span class="hljs-built_in">len</span>)<span class="hljs-comment">// 一个切片 恒等式  i \in [0,len(s)]</span>i := <span class="hljs-built_in">len</span> / <span class="hljs-number">2</span>fmt.Println(s == s[:i]+s[i:])<span class="hljs-comment">// 一个实际的切片例子</span></code></pre><p><img src="https://eddyblog.oss-cn-shenzhen.aliyuncs.com/Go/Go_Ch3_2.png" srcset="/img/loading.gif" alt="png"></p><h2 id="使用-fmt-包来格式化字符串"><a href="#使用-fmt-包来格式化字符串" class="headerlink" title="使用 fmt 包来格式化字符串"></a>使用 fmt 包来格式化字符串</h2><p>一些常见的方法，注意区分带<code>F</code>前缀为，写入到指定 writer 的（不带则是输出到<code>os.Stdout</code>），带<code>f</code>后缀的则是按字符串格式<code>format</code>填入参数（不带则是按格式<code>%v</code>以空格分割、换行结尾写），这样举一反三一下就大体知道输出函数的类别了。</p><div class="table-container"><table><thead><tr><th style="text-align:left">格式指令</th><th style="text-align:left">含义</th></tr></thead><tbody><tr><td style="text-align:left">%%</td><td style="text-align:left">一个%字面量</td></tr><tr><td style="text-align:left">%b</td><td style="text-align:left">一个二进制整数值（基数为 2），或者是一个（高级的）用科学技术法表示的指数为 2 的浮点数</td></tr><tr><td style="text-align:left">%c</td><td style="text-align:left"><strong>一个 Unicode 字符的码点值</strong>（rune 类型输出）</td></tr><tr><td style="text-align:left">%d</td><td style="text-align:left">一个十进制数值（基数为 10）</td></tr><tr><td style="text-align:left">%e</td><td style="text-align:left">以科学计数法 e 表示的浮点数或者复数值</td></tr><tr><td style="text-align:left">%E</td><td style="text-align:left">以科学计数法 E 表示的浮点数或者复数值</td></tr><tr><td style="text-align:left">%f</td><td style="text-align:left">以标准计数法表示的浮点数或者复数值</td></tr><tr><td style="text-align:left">%g</td><td style="text-align:left">略</td></tr><tr><td style="text-align:left">%G</td><td style="text-align:left">略</td></tr><tr><td style="text-align:left">%o</td><td style="text-align:left">一个以八进制表示的数字（基数为 8）</td></tr><tr><td style="text-align:left">%p</td><td style="text-align:left">以十六进制（基数为 16）表示的一个值的<strong>地址</strong>，前缀为 0x，字母使用小写的 a~f 表示（用于调试）</td></tr><tr><td style="text-align:left">%q</td><td style="text-align:left">使用 Go 语法以及必要时使用转义，以双引号括起来的字符串或者字节切片[]byte，或者单引号括起来的数字</td></tr><tr><td style="text-align:left">%s</td><td style="text-align:left">以原生的 UTF-8 字节表示的字符串或者[]byte 切片，对于一个给定的文本文件或者一个能够显示 UTF-8 编码的控制台，<strong>它会产生正确的 Unicode 输出</strong></td></tr><tr><td style="text-align:left">%t</td><td style="text-align:left">布尔值</td></tr><tr><td style="text-align:left">%T</td><td style="text-align:left"><strong>使用 Go 语法输出值的类型</strong></td></tr><tr><td style="text-align:left">%U</td><td style="text-align:left">使用 Unicode 表示法表示整形码点</td></tr><tr><td style="text-align:left">%v</td><td style="text-align:left">使用默认格式输出的内置或者自定义类型的值，或者是使用类型的 String()方法输出的自定义值</td></tr><tr><td style="text-align:left">%x</td><td style="text-align:left">以十六进制表示的整形值（基数为 16）、字符串或者[]byte 数组，a~f 表示</td></tr><tr><td style="text-align:left">%X</td><td style="text-align:left">以十六进制表示的整形值（基数为 16）、字符串或者[]byte 数组，A~F 表示</td></tr></tbody></table></div><p>需要注意的是，和 C/C++的 format 输出非常相似，但是存在一些细微的差别。例如。Go 语言的%d 可以用于任何整数，无论它的大小如何和有无符号（完美～）。</p><h2 id="例子：m3u2pls"><a href="#例子：m3u2pls" class="headerlink" title="例子：m3u2pls"></a>例子：m3u2pls</h2>]]></content>
    
    
    <categories>
      
      <category>Computer Science</category>
      
      <category>Go</category>
      
    </categories>
    
    
    <tags>
      
      <tag>Go</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>UbuntuToGo——Ubuntu系统便捷设置</title>
    <link href="/post/c8194796.html"/>
    <url>/post/c8194796.html</url>
    
    <content type="html"><![CDATA[<h1 id="合盖休眠更改"><a href="#合盖休眠更改" class="headerlink" title="合盖休眠更改"></a>合盖休眠更改</h1><p>由于笔者经常中午带着🎧趴在电脑上睡觉，Windows上面电源设置可以更改合盖休眠的默认设定，所以想在Ubuntu上也作相同设置（不然一合上盖子就休眠了），方法如下：</p><ul><li>root账户编辑<code>/etc/systemd/logind.conf</code>，修改<code>HandleLidSwitch=suspend</code>为<code>HandleLidSwitch=ignore</code></li><li>保存修改后<code>systemctl restart systemd-logind</code>，重启服务生效。（我的机子卡住了，要不就重启好了。。）</li></ul><p>输入 sudo vim /etc/systemd/logind.conf , 摁 i 编辑 去掉如下的行前面的 “#”，最后一个”HandleLidSwitch” 的值改为Lock ，如下图：</p><p><img src="https://eddyblog.oss-cn-shenzhen.aliyuncs.com/UbuntuToGo/Convinience_1.png" srcset="/img/loading.gif" alt="png"></p><p><img src="https://eddyblog.oss-cn-shenzhen.aliyuncs.com/UbuntuToGo/Convinience_2.png" srcset="/img/loading.gif" alt="png"></p><p>这样关上盖子就不会休眠了。（享受音乐，午休～）</p><h1 id="截屏快捷键"><a href="#截屏快捷键" class="headerlink" title="截屏快捷键"></a>截屏快捷键</h1><p><code>Screenshot</code>是个很好的工具，截图用来插图片或者分享给朋友都很好用。不过<strong>每次</strong>都要通过功能键找应用未免太麻烦了。</p><p><img src="https://eddyblog.oss-cn-shenzhen.aliyuncs.com/UbuntuToGo/Convinience_3.png" srcset="/img/loading.gif" alt="png"></p><p>虽然也可以命令行<code>gnome-screenshot -a</code>，不过好像更麻烦了？搜索了一下发现可以自定义<code>快捷键+命令</code>，如此便可一键截图，还可以自定义方式，方法如下：</p><ul><li><code>Settings</code>-&gt;<code>Keyboard</code>找到<code>Keyboard Shortcuts</code>，点击最下方”+”，增加快捷键设置。</li><li>编辑快捷键名，快捷键命令，以及按键</li><li>保存测试即可</li></ul><a id="more"></a><p><img src="https://eddyblog.oss-cn-shenzhen.aliyuncs.com/UbuntuToGo/Convinience_4.png" srcset="/img/loading.gif" alt="png"></p><p><img src="https://eddyblog.oss-cn-shenzhen.aliyuncs.com/UbuntuToGo/Convinience_6.png" srcset="/img/loading.gif" alt="png"></p><p><code>Screenshot</code>命令行详情参见<code>gnome-screenshot -h</code>，如下：</p><p><img src="https://eddyblog.oss-cn-shenzhen.aliyuncs.com/UbuntuToGo/Convinience_5.png" srcset="/img/loading.gif" alt="png"></p><p>所以我自己根据需要设置了两个：</p><ul><li><p>交互式截屏：<code>Ctrl</code>+<code>Alt</code>+<code>I</code></p><p>  代替命令为<code>gnome-screenshot -i</code></p><p>  效果等同于点击应用，出现UI，可选择截屏方式、储存位置，是我在Ubuntu图形界面的主要截屏方式。</p></li><li><p>快捷截屏：<code>Ctrl</code>+<code>Alt</code>+<code>A</code></p><p>  代替命令为<code>gnome-screenshot -a</code></p><p>  效果等同于窗口截屏，选定窗口即截屏并放置在默认路径（Picture)。</p></li></ul><h1 id="阿里云OSS-Linux版客户端"><a href="#阿里云OSS-Linux版客户端" class="headerlink" title="阿里云OSS Linux版客户端"></a>阿里云OSS Linux版客户端</h1><p>下载安装阿里云OSS Linux版客户端（ossbrowser），方便管理资源。</p><p><a href="https://help.aliyun.com/document_detail/61872.html?spm=5176.8465980.0.0.4e701450Mb8UMB" target="_blank" rel="noopener">下载网址</a></p><p><img src="https://eddyblog.oss-cn-shenzhen.aliyuncs.com/UbuntuToGo/Convinience_7.png" srcset="/img/loading.gif" alt="png"></p>]]></content>
    
    
    <categories>
      
      <category>Computer Science</category>
      
      <category>操作系统</category>
      
    </categories>
    
    
    <tags>
      
      <tag>操作系统</tag>
      
      <tag>Linux</tag>
      
      <tag>UbuntuToGo</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>Go学习——《Go语言程序设计》Chap2</title>
    <link href="/post/77f5906d.html"/>
    <url>/post/77f5906d.html</url>
    
    <content type="html"><![CDATA[<h1 id="布尔与数值类型"><a href="#布尔与数值类型" class="headerlink" title="布尔与数值类型"></a>布尔与数值类型</h1><h2 id="注释"><a href="#注释" class="headerlink" title="注释"></a>注释</h2><p><code>//</code>单行注释被编译器当作一个换行符，<code>/* */</code>多行注释划定同行被当作一个空格，多行被当作换行符。</p><h2 id="常量和变量"><a href="#常量和变量" class="headerlink" title="常量和变量"></a>常量和变量</h2><pre><code class="hljs Go"><span class="hljs-keyword">const</span> limit = <span class="hljs-number">512</span>       <span class="hljs-comment">// 常量，其类型兼容任何数字</span><span class="hljs-keyword">const</span> top <span class="hljs-keyword">uint16</span> = <span class="hljs-number">1421</span>  <span class="hljs-comment">// 常量，类型，uint16</span>start := <span class="hljs-number">-19</span>              <span class="hljs-comment">// 变量，推断类型，int</span>end := <span class="hljs-keyword">int64</span>(<span class="hljs-number">9876543210</span>)    <span class="hljs-comment">// 变量。类型，int64</span><span class="hljs-keyword">var</span> i <span class="hljs-keyword">int</span>                   <span class="hljs-comment">// 变量，类型，int</span><span class="hljs-keyword">var</span> debug = <span class="hljs-literal">false</span>           <span class="hljs-comment">// 变量，推断类型，bool</span></code></pre><p>多个常量，用一个<code>const</code>组合</p><pre><code class="hljs Go"><span class="hljs-keyword">const</span> &#123;    Cyan = <span class="hljs-number">0</span>    Magenta = <span class="hljs-number">1</span>    Yellow = <span class="hljs-number">2</span>&#125;</code></pre><p><code>iota</code>预定义的标识符表示连续的无类型整数常量。每次关键字<code>const</code>出现时，它的值重设为 0（因此，每次都会定义一组新的常量），而每个常量的声明的增量为 1。</p><a id="more"></a><h2 id="布尔与布尔表达式"><a href="#布尔与布尔表达式" class="headerlink" title="布尔与布尔表达式"></a>布尔与布尔表达式</h2><p>布尔类型：<code>ture</code>,<code>false</code></p><p>布尔操作符：与 C 常见（除了位运算）相同。</p><p>注意<code>&amp;&amp;</code>,<code>||</code>仍然是短路规则的。</p><p>用于比较操作符（小于大于等）进行比较的值，Go 会严格筛选，两个值必须是相通类型的，或者如果它们是接口，就必须实现了相同的接口类型。如果有一个值是常量，那么他的类型必须与另一个类型兼容。这意味着一个无类型的数值常量可以跟另一个任意数值类型的值进行比较，但是不同类型且非常量的数值不能直接比较。</p><h2 id="数值类型"><a href="#数值类型" class="headerlink" title="数值类型"></a>数值类型</h2><p>类型转换用<code>type(value)</code>的形式。</p><p>大整数的用法（Machin 公式），一些方法会再返回时将结果保存回其接收器中，也即<code>big.Int</code>类型大部分方法会修改他的接收器（这样做是为了节省创建大量临时<code>big.Int</code>值的开销）。</p><pre><code class="hljs Go"><span class="hljs-function"><span class="hljs-keyword">func</span> π<span class="hljs-params">(places <span class="hljs-keyword">int</span>)</span> *<span class="hljs-title">big</span>.<span class="hljs-title">Int</span></span> &#123;    digits := big.NewInt(<span class="hljs-keyword">int64</span>(places))    unity := big.NewInt(<span class="hljs-number">0</span>)    ten := big.NewInt(<span class="hljs-number">10</span>)    exponent := big.NewInt(<span class="hljs-number">0</span>)    unity.Exp(ten, exponent.Add(digits, ten), <span class="hljs-literal">nil</span>)    pi := big.NewInt(<span class="hljs-number">4</span>)    left := arccot(big.NewInt(<span class="hljs-number">5</span>), unity)    left.Mul(left, big.NewInt(<span class="hljs-number">4</span>))    right := arccot(big.NewInt(<span class="hljs-number">239</span>), unity)    left.Sub(left, right)    pi.Mul(pi, left)    <span class="hljs-keyword">return</span> pi.Div(pi, big.NewInt(<span class="hljs-number">0</span>).Exp(ten, ten, <span class="hljs-literal">nil</span>))&#125;</code></pre><h2 id="浮点类型"><a href="#浮点类型" class="headerlink" title="浮点类型"></a>浮点类型</h2><p>Go 内置的浮点类型：<code>float32</code>,<code>float64</code>,<code>complex64</code>（实部虚部都是一个 float32）,<code>complex128</code>（实部虚部都是一个 float64）。</p><p>介绍了一些 math 包中的常量与函数</p><h2 id="例子：statistics"><a href="#例子：statistics" class="headerlink" title="例子：statistics"></a>例子：statistics</h2><p>一个 Web 服务器统计工具</p><h3 id="实现一个简单的统计函数"><a href="#实现一个简单的统计函数" class="headerlink" title="实现一个简单的统计函数"></a>实现一个简单的统计函数</h3><p>定义类型</p><pre><code class="hljs Go"><span class="hljs-keyword">type</span> statistics <span class="hljs-keyword">struct</span> &#123;    numbers []<span class="hljs-keyword">float64</span>    mean    <span class="hljs-keyword">float64</span>    median  <span class="hljs-keyword">float64</span>&#125;</code></pre><pre><code class="hljs Go"><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">getStats</span><span class="hljs-params">(numbers []<span class="hljs-keyword">float64</span>)</span> <span class="hljs-params">(stats statistics)</span></span> &#123;    <span class="hljs-comment">// 切片赋值</span>    stats.numbers = numbers    <span class="hljs-comment">// 修改了</span>    sort.Float64s(stats.numbers)    stats.mean = sum(numbers) / <span class="hljs-keyword">float64</span>(<span class="hljs-built_in">len</span>(numbers))    stats.median = median(numbers)    <span class="hljs-keyword">return</span> stats&#125;</code></pre><p>getStatus 函数作用就是传入<code>[]float64</code>切片，然后统计，返回制定类型（带切片、统计数据的 statistics 聚合类型）。</p><p>其中计算中位数使用了<code>sort</code>包里的<code>Float64s()</code>函数对原数组进行排序，也就是说<code>getStatus</code>修改了切片参数，这种情况在传切片、引用或者指针到函数时很常见。<strong>如果要保留</strong>原始切片，可以使用 Go 语言内置的<code>copy()</code>函数，将它赋值到一个临时变量，使用临时变量来工作。</p><h3 id="实现一个基本的-HTTP-服务器"><a href="#实现一个基本的-HTTP-服务器" class="headerlink" title="实现一个基本的 HTTP 服务器"></a>实现一个基本的 HTTP 服务器</h3><pre><code class="hljs Go"><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span> &#123;    http.HandleFunc(<span class="hljs-string">"/"</span>, homePage)    <span class="hljs-keyword">if</span> err := http.ListenAndServ    (<span class="hljs-string">":9002"</span>, <span class="hljs-literal">nil</span>); err != <span class="hljs-literal">nil</span> &#123;        log.Fatal(<span class="hljs-string">"failed to start  server"</span>, err)    &#125;&#125;</code></pre><p><code>http.HandleFunc()</code>函数用来注册“路径-函数”，两个参数：一个路径，一个当这个路径被请求时会被执行的函数的引用。</p><p><code>http.ListenAndServe()</code>函数使用给定的 TCP 地址启动一个 Web 服务器，第二个参数支持自定义服务器，为空的花表示使用默认的类型。</p>]]></content>
    
    
    <categories>
      
      <category>Computer Science</category>
      
      <category>Go</category>
      
    </categories>
    
    
    <tags>
      
      <tag>Go</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>机器学习——支持向量机</title>
    <link href="/post/7ac02bb8.html"/>
    <url>/post/7ac02bb8.html</url>
    
    <content type="html"><![CDATA[<h1 id="支持向量机-Support-Vector-Machine"><a href="#支持向量机-Support-Vector-Machine" class="headerlink" title="支持向量机 Support Vector Machine"></a>支持向量机 Support Vector Machine</h1><h2 id="前情提要"><a href="#前情提要" class="headerlink" title="前情提要"></a>前情提要</h2><ul><li>95 年首先提出</li><li>是一种统计识别方法，二分类问题上有很大应用。</li></ul><p>过学习问题</p><p>根据统计学习理论，学习机器的实际风险<strong>由经验风险值和置信风险值</strong>两部分组成。而基于经验风险最小化准则的学习方法<strong>只强调了训练样本的经验风险最小误差，没有最小化置信范围值</strong>，因此其泛化能力较差。</p><p>支持向量机是一种基于统计学习理论的模式识别方法，主要应用于模式识别领域。</p><p>基本思想是在样本空间或特征空间构造出<strong>最优超平面</strong>，使得超平面与不同类样本集之间的距离最大，从而达到最大的泛化能力。</p><h2 id="支持向量机可以做什么"><a href="#支持向量机可以做什么" class="headerlink" title="支持向量机可以做什么"></a>支持向量机可以做什么</h2><p>手写体的识别 LeNe 、多项式 SVM</p><p>性别判断</p><p>（温习机器学习一般流程）</p><p>（温习评价指标：查全率、查重率、ROC 曲线）</p><h2 id="支持向量机基本原理"><a href="#支持向量机基本原理" class="headerlink" title="支持向量机基本原理"></a>支持向量机基本原理</h2><p>SVM 是在两类线性可分情况下，获得<strong>最优分类面</strong>问题中提出的。</p><ul><li>分类间隔：假设$H$表示分类线，$H_1,H_2$使两条平行于分类线$H$的支线，并且他们分别过每类离分类线$H$最近的样本，$H1$和$H2$之间的距离叫<strong>做分类间隔（margin）</strong>。 Margin 越大，对新样本的分类（抗干扰）能力越强。</li></ul><h3 id="线性判别函数和判别面"><a href="#线性判别函数和判别面" class="headerlink" title="线性判别函数和判别面"></a>线性判别函数和判别面</h3><ul><li><p>一个线性判别函数是指由$x$的各个分量的线性组合而成的函数</p><script type="math/tex; mode=display">g(x) = w^T x + w_0</script></li><li><p>两类情况：对于两类问题 的决策规则为：</p><ul><li>$g(x)&gt;0$，判定为$C_1$</li><li>$g(x)&lt;0$，判定为$C_2$</li><li>$g(x)==0$，边界拒绝分类。</li></ul></li><li><p>方程$g(x)= 0$定义了一个判别面，把归类于$C_1$的点与$C_2$的点分开来。</p></li><li>当$g(x)$是线性函数时，这个平面被称为<strong>“超平面”</strong>（hyperplane）</li><li><p>当$x_1,x_2$都在判定面上时</p><script type="math/tex; mode=display">w^Tx_1 = w^Tx_2</script><script type="math/tex; mode=display">w^T(x_1 - x_2) = 0</script><p>说明超平面上任意向量均与法向量正交。</p></li></ul><h3 id="硬间隔和支持向量"><a href="#硬间隔和支持向量" class="headerlink" title="硬间隔和支持向量"></a>硬间隔和支持向量</h3><p>SVM 分类问题大致有三种：线性可分问题、近似线性可分问题、线性不可分问题。</p><p>对应支持向量机包含由简至繁的三种模型：</p><ul><li>线性可分支持向量机：当数据线性可分时，通过硬间隔最大化，学习一个线性的分类器，也称<strong>硬间隔支持向量机</strong></li><li>线性支持向量机：当数据近似线性可分，通过软间隔使</li><li>非线性支持向量机：</li></ul><p>关键点</p><p>$\min \dfrac{1}{2} | w^2 | ,  y^{(i)}(w^T+ b ) \ge 1$</p><h2 id="对偶问题"><a href="#对偶问题" class="headerlink" title="对偶问题"></a>对偶问题</h2><ul><li>函数间隔</li><li>几何间隔</li></ul><p>相差是一个I2范式</p><p>基本想法，找到一个超平面使几何间隔最大化</p><p>几何间隔最大化确定的超平面是唯一的，在此不做证明。</p><p>求法：</p><p>变换几何间隔到函数间隔，最大化转最小化</p>]]></content>
    
    
    <categories>
      
      <category>Computer Science</category>
      
      <category>机器学习</category>
      
    </categories>
    
    
    <tags>
      
      <tag>机器学习</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>Go学习——《Go语言程序设计》Chap1</title>
    <link href="/post/eefcc1d7.html"/>
    <url>/post/eefcc1d7.html</url>
    
    <content type="html"><![CDATA[<h1 id="开始"><a href="#开始" class="headerlink" title="开始"></a>开始</h1><h2 id="编辑、编译与运行"><a href="#编辑、编译与运行" class="headerlink" title="编辑、编译与运行"></a>编辑、编译与运行</h2><p>Go 语言的官方编译器被称为 gc，包括编译工具<code>5g</code>、<code>6g</code>和<code>8g</code>，链接工具<code>5l</code>、<code>6l</code>和<code>8l</code>，以及文档查看工具<code>godoc</code>，这些古怪的命名习惯源自 Plan 9 操作系统，例如用数字来表示处理器的架构（5 代表 ARM，6 代表包括 Intel 64 位处理器在内的 AMD64 架构，而 8 则代表 Intel 386）</p><p>Go 语言针对的处理单元是包而非文件，这意味着我们可以将包拆分成任意数量的文件。在 Go 编译器看来，如果所有这些文件的包声明都是一样的，那么它们就同样属于一个包，这跟把所有内容放在一个单一的文件里是一样的。</p><p>执行顺序：init()-&gt;main()，如果一个包里包含了一个或多个 init()函数，那么它们会在 main()函数之前被自动执行，而且 init()函数不能被显示调用。</p><p><code>:=</code>操作符，在 Go 语言中叫做快速变量声明，这条语句同时声明并初始化了一个变量，也就是说我们不必声明一个<strong>具体类型</strong>的变量，因为 Go 语言可以从其初始化值中推导出其类型，但需要强调的是，<strong>Go 是强类型的语言</strong>，即便使用了快速变量声明，后续也只能将对应识别类型的值赋给该变量。</p><h2 id="切片"><a href="#切片" class="headerlink" title="切片"></a>切片</h2><pre><code class="hljs Go"><span class="hljs-keyword">var</span> lowPrimes = []<span class="hljs-keyword">int</span>&#123;<span class="hljs-number">2</span>,<span class="hljs-number">3</span>,<span class="hljs-number">5</span>,<span class="hljs-number">7</span>,<span class="hljs-number">11</span>,<span class="hljs-number">13</span>,<span class="hljs-number">17</span>,<span class="hljs-number">19</span>&#125;</code></pre><h2 id="循环"><a href="#循环" class="headerlink" title="循环"></a>循环</h2><p>C、C++、Java 习惯的<code>for row := 0; row&lt; len; row++</code>可以，同时也提供<code>for ... range</code>的语法，与 P<br>ython 类似，更短更方便。(<code>++</code>在 Go 中只可用于语句而非表达式，更进一步，只可用做后缀操作符而非前缀操作府）</p><h2 id="自定义类型及其方法"><a href="#自定义类型及其方法" class="headerlink" title="自定义类型及其方法"></a>自定义类型及其方法</h2><h3 id="一些-7788"><a href="#一些-7788" class="headerlink" title="一些 7788"></a>一些 7788</h3><p>虽然 Go 语言支持面向对象变成，但它既没有类也没有继承（is-a 关系）这样的概念。但是 Go 语言支持创建自定义类型，而且很容易创建聚合（has-a 关系）结构。Go 语言也支持将其数据和行为完全分离，同时也支持鸭子类型（一种抽象机制）。</p><p>所有这些一起，提供了一种游离于类和继承之外的更加灵活强大的选择，但如果要从 Go 语言的面向对象特性中获益，习惯于传统方法的我们必须在概念上做一些重大调整。</p><p>Go 语言使用内置的基础类型如 bool、int 和 string 等类型来表示数据，或者使用 struct 来对基本类型进行聚合 （不同于 C++，Go 的 struct 不是伪类）。</p><p>接口也是一种类型，可以通过指定一组方法的方式定义。接口是抽象的，因此不可以实例化。如果某个具体类型实现了某个接口所有的方法，那么这个类型就被认为实现了该接口。</p><p>空接口（没有定义方法的接口）用<code>interfae{}</code>来表示，可以用来表示任意值（效果上相当于一个指向任意类型的指针，类似 Java 中的<code>Object</code>或者 C/C++中的<code>void*</code>）。</p><a id="more"></a><h3 id="自定义类型的导入"><a href="#自定义类型的导入" class="headerlink" title="自定义类型的导入"></a>自定义类型的导入</h3><p>一个 Go 语言程序或者包的导入语句会首先搜索<code>GOPATH</code>定义的路径，然后再搜索<code>GOROOT</code>定义的路径。</p><p>包导入路径使用 Unix 风格的“/”来声明。</p><pre><code class="hljs Go"><span class="hljs-keyword">import</span> &#123;    <span class="hljs-string">"fmt"</span>    <span class="hljs-string">"stacker/stack"</span>&#125;</code></pre><h3 id="自定义类型的定义使用"><a href="#自定义类型的定义使用" class="headerlink" title="自定义类型的定义使用"></a>自定义类型的定义使用</h3><p>按照管理，该文件开始处生命包，然后导入使用的包</p><pre><code class="hljs Go"><span class="hljs-keyword">package</span> stack<span class="hljs-keyword">import</span> <span class="hljs-string">"errors"</span><span class="hljs-comment">// 下面每个export的类型或者方法按照VScode golint的要求需要附上注释说明，以方法/类型名开头</span><span class="hljs-comment">// Stack is a type</span><span class="hljs-keyword">type</span> Stack []<span class="hljs-keyword">interface</span>()<span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-params">(stack Stack)</span> <span class="hljs-title">Len</span><span class="hljs-params">()</span> <span class="hljs-title">int</span></span> &#123;    <span class="hljs-keyword">return</span> <span class="hljs-built_in">len</span>(stack)&#125;</code></pre><p>函数和方法都用关键字<code>func</code>定义。但是，定义方法的时候，方法所作用的值的类型需写在<code>func</code>关键字之后方法名之前，并用圆括号包围起来（如上面代码段的<code>stack Stack</code>）。函数或方法名之后，则是小括号包围起来的参数列表，每个参数用逗号分隔（每个参数以<code>variableName type</code>这种形式命名，和 C/C++/Java 类型在前的形式有差别）。参数后面，可以直接是左大括号，或者一个单一返回之，也可以是一对圆括号包围起来的返回值列表之后再紧跟一个作大括号。</p><p>调用该方法的值命名，Go 术语为“接收器”，<strong>接收器命名与包名并不冲突</strong>，区分按值（对原接收器不作改变）、按地址、按引用传递。</p><p>Go 语言使用<code>nil</code>来表示空指针（以及空引用），与 C/C++中的 NULL 或 0，Java 中的 null，Objective-C 中的 nil 是等价的。</p><h2 id="文件、映射和闭包"><a href="#文件、映射和闭包" class="headerlink" title="文件、映射和闭包"></a>文件、映射和闭包</h2><h3 id="I-O-处理包"><a href="#I-O-处理包" class="headerlink" title="I/O 处理包"></a>I/O 处理包</h3><ul><li><code>buffio</code>包提供了带缓冲的 I/O 处理的功能，包括从 UTF-8 编码文件中读写字符串的能力。</li><li><code>io</code>包提供了底层的 I/O 功能</li><li><code>io/ioutil</code>包提供了一系列高级文件处理函数</li><li><code>regexp</code>包提供了强大的正则表达式支持</li></ul><h3 id="panic-异常"><a href="#panic-异常" class="headerlink" title="panic 异常"></a>panic 异常</h3><p>在 Go 语言中，<code>panic</code>是一个运行时错误（很像其他语言中的异常，本书将<code>panic</code>直接翻译为“异常”）。我们可以使用内置的<code>panic()</code>函数来触发一个异常，还可以使用<code>recover()</code>函数来在其调用栈上阻止该异常的传播。理论上，Go 语言的<code>panic/recover</code>功能可以用于多用途的错误处理机制，但我们并不推荐这么用。更合理的错误处理方式是让函数或者方法返回一个<code>error</code>值作为其最后或者唯一的返回值（如果没错就返回<code>nil</code>），并让其他调用方式来检查所收到的错误值。<code>panic/recover</code>机制的目的是用来处理<strong>真正的异常</strong>（即不可预料的异常）而非常规错误。</p><h2 id="并发简述"><a href="#并发简述" class="headerlink" title="并发简述"></a>并发简述</h2><p>Go 语言的一个关键特性在于其充分利用现代计算机的多处理器和多核的功能，且无需给程序员带来太大负担。完全无需任何显式锁 🔓 就可写出许多并发程序（虽然 Go 语言也提供了锁原语以便在底层代码需要用到时使用，我们将在第 7 章中详细阐述）。</p><p>Go 语言有两个特性使得用它座并发编程非常轻松。</p><ul><li>无需继承什么“线程”（thread）类，就可创建 goroutine（实际上是非常轻量级的县城或者协程）。</li><li>通道（channel）为 goroutine 之间提供了类型安全的单项或者双向通信，这也可以用来同步 goroutine。</li></ul><p>示例：极坐标到笛卡尔坐标交互程序</p><p>引入的包</p><pre><code class="hljs Go"><span class="hljs-keyword">import</span> (    <span class="hljs-string">"bufio"</span>    <span class="hljs-string">"fmt"</span>    <span class="hljs-string">"math"</span>    <span class="hljs-string">"os"</span>    <span class="hljs-string">"runtime"</span>)</code></pre><ul><li><code>math</code>包提供了操作浮点数的数学函数</li><li><code>runtime</code>包提供了一些运行时控制</li></ul><pre><code class="hljs Go"><span class="hljs-keyword">type</span> polar <span class="hljs-keyword">struct</span> &#123;    radius <span class="hljs-keyword">float64</span>    θ      <span class="hljs-keyword">float64</span>&#125;<span class="hljs-keyword">type</span> cartesian <span class="hljs-keyword">struct</span> &#123;    x   <span class="hljs-keyword">float64</span>    y   <span class="hljs-keyword">float64</span>&#125;</code></pre><p>聚合两个内置类型 float64 来构建自定义类型，Go 语言的结构体是一种能够用来保存（聚合或者嵌入）一个或者多个通道据字段的类型。</p><blockquote><p>需要注意通道是，虽然这两个结构体恰好包含了<strong>完全相同</strong>的通道段类型，但它们仍属不同类型，两者之间也不能自通道地相互转换（这符合我们对强类型语言的印象）。通道</p></blockquote><h3 id="通道"><a href="#通道" class="headerlink" title="通道"></a>通道</h3><p>基于 Unix 上管道思想被设计出来的，FIFO 队列行为，保序，通道内数据不可被删除。</p><p>通道创建</p><pre><code class="hljs Go">msessages := <span class="hljs-built_in">make</span>(<span class="hljs-keyword">chan</span> <span class="hljs-keyword">string</span>, <span class="hljs-number">10</span>)</code></pre><p>利用<code>make()</code>创建通道，语法为<code>chan Type, num</code>，表示通道接受的数据类型和缓冲区大小。</p><ul><li><p>向通道发送</p><p><code>&lt;-</code>做二元运算符，左操作数必须是一个通道，右操作数必须是发往该通道的数据。I</p><pre><code class="hljs Go">messages &lt;- <span class="hljs-string">"Leader"</span></code></pre></li><li><p>从通道接受</p><p><code>&lt;-</code>做一元运算符，左操作数必须是一个通道，是一个接收器，一直阻塞知道获得一个可以返回的数据。</p></li></ul><pre><code class="hljs Go"><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span> &#123;    questions := <span class="hljs-built_in">make</span>(<span class="hljs-keyword">chan</span> polar)    <span class="hljs-keyword">defer</span> <span class="hljs-built_in">close</span>(questions)    answers := createSolver(questions)    <span class="hljs-keyword">defer</span> <span class="hljs-built_in">close</span>(answers)    interact(questions, answers)&#125;<span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">createSolver</span><span class="hljs-params">(questions <span class="hljs-keyword">chan</span> polar)</span> <span class="hljs-title">chan</span> <span class="hljs-title">cartesian</span></span> &#123;    answers := <span class="hljs-built_in">make</span>(<span class="hljs-keyword">chan</span> cartesian)    <span class="hljs-keyword">go</span> <span class="hljs-function"><span class="hljs-keyword">func</span><span class="hljs-params">()</span></span> &#123;        <span class="hljs-keyword">for</span> &#123;            polarCoord := &lt;-questions            θ := polarCoord.θ * math.Pi / <span class="hljs-number">180.0</span> <span class="hljs-comment">// degrees to radians</span>            x := polarCoord.radius * math.Cos(θ)            y := polarCoord.radius * math.Sin(θ)            answers &lt;- cartesian&#123;x, y&#125;        &#125;    &#125;()    <span class="hljs-keyword">return</span> answers&#125;<span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">interact</span><span class="hljs-params">(questions <span class="hljs-keyword">chan</span> polar, answers <span class="hljs-keyword">chan</span> cartesian)</span></span> &#123;    reader := bufio.NewReader(os.Stdin)    fmt.Println(prompt)    <span class="hljs-keyword">for</span> &#123;        fmt.Printf(<span class="hljs-string">"Radius and angle: "</span>)        line, err := reader.ReadString(<span class="hljs-string">'\n'</span>)        <span class="hljs-keyword">if</span> err != <span class="hljs-literal">nil</span> &#123;            <span class="hljs-keyword">break</span>        &#125;        <span class="hljs-keyword">var</span> radius, θ <span class="hljs-keyword">float64</span>        <span class="hljs-keyword">if</span> _, err := fmt.Sscanf(line, <span class="hljs-string">"%f %f"</span>, &amp;radius, &amp;θ); err != <span class="hljs-literal">nil</span> &#123;            fmt.Fprintln(os.Stderr, <span class="hljs-string">"invalid input"</span>)            <span class="hljs-keyword">continue</span>        &#125;        questions &lt;- polar&#123;radius, θ&#125;        coord := &lt;-answers        fmt.Printf(result, radius, θ, coord.x, coord.y)    &#125;    fmt.Println()&#125;</code></pre><p>原理解释：</p><blockquote><p>用户输入了合法数字并已经以<code>polar</code>结构体的格式发送到<code>questions</code>通道，那么就会阻塞主<code>goroutine</code>，等待 answers 通道的响应。<code>createSolver()</code>函数额外创建的一个<code>goroutine</code>会阻塞等待<code>questions</code>通道接收到一个<code>polar</code>类型的数据，因此当我们发送<code>polar</code>数据后，这个<code>goroutine</code>将会执行计算，并将计算结果发送会<code>answer</code>通道，然后等待另一个问题的输入（在开始阻塞自身），而一旦<code>interact()</code>函数在<code>answers</code>通道上接收到<code>cartesian</code>，就不再阻塞，这样就会打印出相关信息。</p></blockquote>]]></content>
    
    
    <categories>
      
      <category>Computer Science</category>
      
      <category>Go</category>
      
    </categories>
    
    
    <tags>
      
      <tag>Go</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>记第二次百里毅行</title>
    <link href="/post/8278c2d3.html"/>
    <url>/post/8278c2d3.html</url>
    
    <content type="html"><![CDATA[<h1 id="前面"><a href="#前面" class="headerlink" title="前面"></a>前面</h1><p>九月份看到今年秋季百里毅行开始报名时，基本没怎么犹豫。点开“幺零零”，看了一眼价钱可以接受，便填信息、付款、短信确认，没有拖泥带水，没有呼朋引伴，没有犹豫迟疑，仿佛早就做好了打算要参加一样。事后回想，我好像只是想再去“体验”一下那种感觉，那种可以卸下所有思想的负担，聚焦所有精神到眼前与脚下的感觉。</p><p>准备工作是简单的，毅行前的一周每天还是早七点半到图书馆放下资料，上课时间去两百米外的教学楼上个课，该吃饭了就去后湖或者 B 座食堂填饱肚子，只是由于九月和十月落下的脚伤还没有好利索，不时还得穿着洞洞鞋度日，晚上洗完澡要用碘酒擦拭伤口。到了前一天，我采购了一下必要的护膝和热量补充食品，打理好包裹，调整了作息。虽然说最后一天晚上怎样都没有睡着，无梦，但或许是这些天休息的太过充足了，五点钟下了床，拿了包跟舍友说了声再见就出发了（他还没睡）。</p><h1 id="我的毅行"><a href="#我的毅行" class="headerlink" title="我的毅行"></a>我的毅行</h1><blockquote><p>“我绝对忘不了可以张开双臂，闭上眼，听着歌，坦荡走的感觉”</p></blockquote><p>只有走在毅行的路上，每个人才能找到行走下去的意义。</p>]]></content>
    
    
    <categories>
      
      <category>Life</category>
      
      <category>随笔</category>
      
    </categories>
    
    
    <tags>
      
      <tag>随笔</tag>
      
      <tag>百里毅行</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>行为金融学——禀赋效应</title>
    <link href="/post/2c8cec8f.html"/>
    <url>/post/2c8cec8f.html</url>
    
    <content type="html"><![CDATA[<h1 id="问题-1-请列举现实生活中或金融决策中禀赋效应的例子"><a href="#问题-1-请列举现实生活中或金融决策中禀赋效应的例子" class="headerlink" title="问题 1. 请列举现实生活中或金融决策中禀赋效应的例子"></a>问题 1. 请列举现实生活中或金融决策中禀赋效应的例子</h1><p>禀赋效应重点是发现了人在不同的环境下，对同一个东西的偏好(preference)出现了偏差 (偏好是通过出价，也就是”人愿意付出的最高买价”和”人愿意接受的最低卖价”，来衡量的。</p><h2 id="现实生活中"><a href="#现实生活中" class="headerlink" title="现实生活中"></a>现实生活中</h2><p>只要满足 “当一个人拥有某个东西的时候，他对该物品的估价(或者说偏好)要大于没有拥有该物品的时候（的偏好）”，都可以被说成是“禀赋效应”。</p><p>人们对自己的工作、学习成果要比观摩他人的学习、工作成果觉得更有成就感。</p><p>“不满意七天可以退货”的商品，或许真的可以退货，但当人把一件商品带回家试用时，“禀赋效应”就已经开始在身上起作用了。人们不太可能把已经拥有的东西退回去。</p><h2 id="金融决策中"><a href="#金融决策中" class="headerlink" title="金融决策中"></a>金融决策中</h2><p>一旦买入某一只股票，立刻对这家公司产生好感。如果股票涨了，舍不得卖。总觉得这只股票非常好，会一直上涨，其实不舍得卖，一方面是贪婪，另一方面是，个人喜爱。下跌时也一样，更多的人看到 5%的亏损，不会立刻出手。他们总是相信自己最初的选择，认为这只股票比其他的强，会莫名其妙的产生好感，不愿意卖出。</p><h1 id="问题-2-假设一个地区正在分配产权，将矿山分给了善于打鱼的渔夫，将渔场分给了擅长采矿的矿工，你觉得他们会怎么做"><a href="#问题-2-假设一个地区正在分配产权，将矿山分给了善于打鱼的渔夫，将渔场分给了擅长采矿的矿工，你觉得他们会怎么做" class="headerlink" title="问题 2. 假设一个地区正在分配产权，将矿山分给了善于打鱼的渔夫，将渔场分给了擅长采矿的矿工，你觉得他们会怎么做"></a>问题 2. 假设一个地区正在分配产权，将矿山分给了善于打鱼的渔夫，将渔场分给了擅长采矿的矿工，你觉得他们会怎么做</h1><p>渔夫和矿工都对自己已分配的资源更加珍视，而且考虑到自己已有资源对对方来说利用率更高，且对方占据的资源状况缺少相关信息。</p><p>两人都会要求对方除了现有资源外还要附加其他条件来交换自己手里占据的资源，即，渔夫要求矿工用渔场+现金（或者其他补偿）来交换自己手里的矿山，矿工则相反，最终两人难以达成平等高效的贸易交换。</p>]]></content>
    
    
    <categories>
      
      <category>Finance</category>
      
      <category>投资银行学</category>
      
    </categories>
    
    
    <tags>
      
      <tag>投资银行学</tag>
      
      <tag>辅修</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>分布式系统学习——MIT6.824-Lecture1课堂笔记</title>
    <link href="/post/8df28acc.html"/>
    <url>/post/8df28acc.html</url>
    
    <content type="html"><![CDATA[<h1 id="Lecture-1-Introduction"><a href="#Lecture-1-Introduction" class="headerlink" title="Lecture 1: Introduction"></a>Lecture 1: Introduction</h1><h2 id="什么是分布式系统"><a href="#什么是分布式系统" class="headerlink" title="什么是分布式系统"></a>什么是分布式系统</h2><ul><li>多台机器共同协作</li><li>大型网站的存储，MapReduce，P2P 文件共享，&amp;c</li><li>许多关键基础设施是分布式的</li></ul><h2 id="为什么需要（选择）分布式"><a href="#为什么需要（选择）分布式" class="headerlink" title="为什么需要（选择）分布式"></a>为什么需要（选择）分布式</h2><ul><li>为了连接，组织物理上分离的实体</li><li>为了通过隔离（isolation）实现安全性</li><li>为了通过备份（replication）实现容错性</li><li>为了通过并行的 CPUs，内存，硬盘，网络，实现扩容</li></ul><h2 id="担心的地方"><a href="#担心的地方" class="headerlink" title="担心的地方"></a>担心的地方</h2><ul><li>多个并发部分导致的复杂性问题</li><li>必须处理部分部分失败的情况</li><li>难以发挥性能潜力</li></ul><h2 id="为什么选择这门课"><a href="#为什么选择这门课" class="headerlink" title="为什么选择这门课"></a>为什么选择这门课</h2><ul><li>有趣 — hard problems, powerful solutions</li><li>应用在实际系统中 — 被大网站的崛起驱动</li><li>活跃的研究领域 — 许多进展产生，同时又有很多待解决的问题</li><li>上手做 — 在 labs 实验中会自己动手建立严密的系统</li></ul><h2 id="课程组成"><a href="#课程组成" class="headerlink" title="课程组成"></a>课程组成</h2><ul><li><p>课程</p><p>大的想法，论文讨论和实验</p></li><li><p>阅读</p><p>研究文献包含经典的和新颖的，文章描述了主要思想和重要的细节。许多 Lec 关注点都放在论文上。<strong>请课前阅读研究论文</strong>，否则你会觉得上课内容很无聊，而且你无法不费力地学会， 每篇论文都有为你准备的小问题，请务必给我们发送你阅读论文的时候存在的疑问， 晚上十点前给我们发送<strong>问题和答案</strong>。</p></li><li><p>两次考试</p><p>期中期末考试</p></li><li><p>实验</p><p>实验目标：</p><ul><li>深入理解一些重要的技术</li><li>掌握分布式编程经验</li><li>每周一个</li></ul><p>实验安排：</p><ul><li>Lab 1: MapReduce</li><li>Lab 2: replication for fault-tolerance using Raft</li><li>Lab 3: fault-tolerant key/value store</li><li>Lab 4: sharded key/value</li></ul></li></ul><h2 id="主题"><a href="#主题" class="headerlink" title="主题"></a>主题</h2><p>这是一门关于会被应用程序抵用的基础设施的课程，它会对应用程序隐藏分布式系统的复杂性而进行抽象，包括下面的三个抽象</p><ul><li>存储（Storage）</li><li>通讯（Communication）</li><li>计算（Computation）。</li></ul><p>上述主题会被重复提及。</p><h3 id="主题：实现（implementation）"><a href="#主题：实现（implementation）" class="headerlink" title="主题：实现（implementation）"></a>主题：实现（implementation）</h3><ul><li>RPC 技术, 线程 threads, 并发控制 concurrency control</li></ul><h3 id="主题：性能（performance）"><a href="#主题：性能（performance）" class="headerlink" title="主题：性能（performance）"></a>主题：性能（performance）</h3><ul><li><p>理想目标：可伸缩的吞吐量。</p><p>通过购买更多的机器就可以实现更大的负载。</p></li><li><p>随着数量增长，扩展变得困难</p><p>负载不均衡，straggler 问题。</p><p>不可并行的代码段：如初始化 initialization， 交互 interaction。</p><p>由共享资源引起的 Bottleneck，比如网络。</p></li><li><p>一些无法通过扩展解决的新跟那个问题</p><p>比如降低用户相应耗时，可能更需要编程人员的工作而非更多的机器。</p></li></ul><h3 id="主题：容错（fault-tolerance）"><a href="#主题：容错（fault-tolerance）" class="headerlink" title="主题：容错（fault tolerance）"></a>主题：容错（fault tolerance）</h3><ul><li>数千台机器加上复杂网络，总会 something broken，我们希望对应用程序掩藏这些故障，同时我们还希望：<ul><li>高可用性（Availability）——即便出现故障，应用程序仍能工作。</li><li>暂时性（Durability）——故障修复后应用会回归到正常状态。</li></ul></li><li><p>重要理念：复制服务器。</p><p>如果一个服务器崩溃了，客户可以转而使用其他复制的服务器。</p></li></ul><h3 id="主题：一致性（Consistency）"><a href="#主题：一致性（Consistency）" class="headerlink" title="主题：一致性（Consistency）"></a>主题：一致性（Consistency）</h3><ul><li>多用途的底层设施需要良定义的行为。例如： Get(k) 获取到的值应该是最近的 Put(k,v)设置的。</li><li>但实现良好行为是很困难的<ul><li>复制的服务端难一实现完全统一。</li><li>客户端在进行多步更新的中途崩溃。</li><li>服务端在尴尬时刻崩溃，比如执行完成但没来得及反馈信息。</li><li>网络可能会使存活的服务器看起来跟挂了一样;存在“脑裂的风险“</li></ul></li></ul><h2 id="案例学习：-MapReduce"><a href="#案例学习：-MapReduce" class="headerlink" title="案例学习： MapReduce"></a>案例学习： MapReduce</h2><p>让我们将 MR 作为一个案例进行讨论。 MR 是课程 6.284 主题的一个很好的例子，也是实验 1 的主要关注点。</p><h3 id="MapReduce-概要"><a href="#MapReduce-概要" class="headerlink" title="MapReduce 概要"></a>MapReduce 概要</h3><p>背景: 几个小时处理完 TB 基本的数据集 例如：实验分析爬行网页的结构，通常不是由分布式系统开发的爱好者开发的这就会非常痛苦，如如何处理错误。<br>总体目标: 非专业程序员可以轻松的在合理的效率下解决的巨大的数据处理问题。程序员定义 Map 函数和 Reduce 函数、顺序代码一般都比较简单。 MR 在成千的机器上面运行处理大量的数据输入，隐藏全部分布式的细节。</p><h3 id="MapReduce-的抽象视图"><a href="#MapReduce-的抽象视图" class="headerlink" title="MapReduce 的抽象视图"></a>MapReduce 的抽象视图</h3><ul><li>输入原始数据集为 <code>&lt;k1,v1&gt;</code></li><li>MR 调用在每个分片上调用 Map()函数，产生中间数据集<code>&lt;k2,v2&gt;</code>（每日此 Map()调用称为一个 Map 任务），并且聚集相同<code>k2</code>值的<code>v2</code>，并将它们传送给 Reduce()函数调用。</li><li>最后的输出是数据集<code>&lt;k2,v3&gt;</code></li><li>MapReduce API — map(k1,v1) -&gt; list(k2,v2) -&gt; reduce(k2, list(v2)) -&gt; list(k2, v3)</li></ul><h3 id="MapReduce-举例"><a href="#MapReduce-举例" class="headerlink" title="MapReduce 举例"></a>MapReduce 举例</h3><pre><code class="hljs python">Map(k,v)    split v into words    <span class="hljs-keyword">for</span> each word w        emit(w,<span class="hljs-string">"1"</span>)Reduce(k,v)    emit(len(v))</code></pre><h3 id="MapReduce-隐藏的细节"><a href="#MapReduce-隐藏的细节" class="headerlink" title="MapReduce 隐藏的细节"></a>MapReduce 隐藏的细节</h3><p>MR 隐藏了很多让人痛苦的细节</p><ul><li>如何在 server 上启动 s/w 任务</li><li>如何跟踪哪个任务是完成的</li><li>数据传输（data movement）</li><li>错误恢复</li></ul><h3 id="MapReduce-易实现扩展"><a href="#MapReduce-易实现扩展" class="headerlink" title="MapReduce 易实现扩展"></a>MapReduce 易实现扩展</h3><p>N 台计算机可以同时执行 Nx 个 Map 函数和 Reduce 函数，Map()可以并行执行，因为他们不需要交互（相互等待或共享数据）。Reduce()工作也一样</p><p>他们之间的交互仅有 maps 和 reduces 之间的数据传送（”shuffle”）。</p><p>因此你可以通过购买更多的计算机来获得更大的吞吐量，而非应用专用的高效并行，计算机要比程序员便宜得多。</p><h3 id="什么限制了性能"><a href="#什么限制了性能" class="headerlink" title="什么限制了性能"></a>什么限制了性能</h3><p>We care since that’s the thing to optimize.</p><p>CPU？内存？硬盘？网络？</p><p>MR 的数据传输都是通过网络进行的，而网络的全内容量通常远小于主机网络链接速度，因此更加关心减少通过网络传输的数据。</p><h3 id="更多细节（文章图-1）"><a href="#更多细节（文章图-1）" class="headerlink" title="更多细节（文章图 1）"></a>更多细节（文章图 1）</h3><p><img src="https://eddyblog.oss-cn-shenzhen.aliyuncs.com/%E8%AE%BA%E6%96%87%E6%88%AA%E5%9B%BE/OS_3_1.png" srcset="/img/loading.gif" alt="OS_3_1"></p><ul><li>master：给 workers 分配工作，记录中间输出的位置。</li><li><p>M/R task：<br>输入分割，输入存储在 GFS，每个拷贝三份，全部电脑都运行 GFS 和 MR workers，对于输入的分片远远多于 worker 的数量，master 会让每台机器上面均执行 Map 任务，并在当原来的任务完成之后会处理新的任务，</p><p>worker 按中间输出的 key 哈希（hash）输出到对应 R 分区保存在本地硬盘上，（提问：这样的实现有什么优势？） 当全部 Maps 任务完成时， Reduces 任务将会开始执行。master 告诉 Reducers 去获取 Map workers 产生的中间数据分区，Reduce worker 将最终的结果输出到 GFS。</p></li></ul><h3 id="有哪些详细的设计帮助提示网络性能"><a href="#有哪些详细的设计帮助提示网络性能" class="headerlink" title="有哪些详细的设计帮助提示网络性能"></a>有哪些详细的设计帮助提示网络性能</h3><ul><li>Map 的输入来自建立在本地硬盘上的 GFS 副本而非网络。</li><li>中间数据只在网络上面传输一次，<strong>Map worker 产生的中间输出保存在本地硬盘，而不是 GFS</strong>（不会传 1 备 3）。</li><li>中间数据通过 key 被划分到多个文件，”大网络传输“更加有效。（问题：为什么中间数据不通过 TCP 以流的方式传输 reducer）</li></ul><h3 id="如何处理负载均衡"><a href="#如何处理负载均衡" class="headerlink" title="如何处理负载均衡"></a>如何处理负载均衡</h3><ul><li>对扩展来说至关重要——最坏情况：剩余 N-1 个 server 等待 1 个 server 完成工作。而一些任务很有可能会比其他任务耗时更长。</li><li>解决方案：使任务数（task）远大于工作机（worker）的数量，根据不断完成、不断供给的方式使工作机持续工作，这样的分片不会使哪一片任务是过大的以至于影响到总的完成时间，这样快的工作机就会比慢的处理更多任务，最后一同完成整体 MR 工作。</li></ul><h3 id="如何处理容错"><a href="#如何处理容错" class="headerlink" title="如何处理容错"></a>如何处理容错</h3><p>比如：如果服务器在执行 MR 工作时崩溃怎么办？隐藏这个错误非常困难（问题：为什么不重新执行整个工作呢？）</p><p>MR 只重新执行失败的 Map 函数和 Reduce 函数,他们是纯函数——他们不会改变数据输入、不会保持状态、不共享内存、不存在 map 和 map，或者 reduce 和 reduce 之间的联系，</p><p>所以重新执行也会产生相同的输出。纯函数的这个需求是 MR 相对于其他并行编程方案的主要限制，但它同时也对 MR 的简洁性起到了至关重要的作用。</p><h4 id="处理-worker-崩溃的细节"><a href="#处理-worker-崩溃的细节" class="headerlink" title="处理 worker 崩溃的细节"></a>处理 worker 崩溃的细节</h4><ul><li><p>Map worker 崩溃</p><ul><li>如何发现 worker 崩溃：maskter 发现无法 ping 通 worker，崩溃导致崩溃的 worker 本地储存的中间输出丢失。</li><li>Reduce workers 已经获取全部的中间数据，那么 master 不需要重启 Map 函数。</li><li>Reduce workers 并未获取全部的中间数据，出发了 reduce 任务的崩溃，那么会前置重新执行依赖的失败的 map 任务。</li></ul></li><li><p>Reduce worker 崩溃</p><ul><li>输出任务是正常的 — 储存在 GFS，伴随副本，master 必须在其他 worker 上面重新开始该任务。</li><li>输出过程中崩溃，GFS 会自动进行原子重命名输出，然后使其保持不可见直到 Reduce 完成，所以 master 在其他地方再次运行 Reduce worker 将会是安全的。</li></ul></li></ul><h4 id="其他错误和问题"><a href="#其他错误和问题" class="headerlink" title="其他错误和问题"></a>其他错误和问题</h4><ul><li><p>假如 master 意外的开启两个 Map worker 处理同一个输入（进行相同的 Map 任务）会怎么样？</p><p>它只会告诉 Reduce worker 其中的一个。</p></li><li><p>假如两个 Reduce worker 　处理中间数据的同一个分区会怎么样？</p><p>它们都会将同一份数据写到 GFS 上面，GFS 的原子重命名操作会触发，避免混淆，先完成的获胜将使结果可见。</p></li><li><p>假如一个 worker 非常慢怎么办（掉队者）？</p><p>产生原因可能是非常糟糕的硬件设施。 master 会对这些最后的任务创建第二份拷贝任务执行（见原文 Backup Tasks），</p></li><li><p>假如一个 worker 因为软件或者硬件的问题导致计算结果错误怎么办？</p><p>太糟糕了！MR 假设是建立在”fail-stop”（而非拜占庭故障）的 cpu 和软件之上。</p></li><li><p>假如 master 崩溃怎么办？</p><p>从 check-point 点恢复，或放弃整个 job，（原文章意思是直接重启整个任务）。</p></li></ul><h3 id="MapReduce-模式适用性"><a href="#MapReduce-模式适用性" class="headerlink" title="MapReduce 模式适用性"></a>MapReduce 模式适用性</h3><p>并不是所以工作都适合 map/shuffle/reduce 这种模式</p><ul><li>小的数据，因为管理成本太高,如非网站后端</li><li>大数据中的小更新，比如添加一些文件到大的索引</li><li>不可预知的读（Map 和 Reduce 都不能选择输入）</li><li>多重传输（Multiple shuffles）, e.g. page-rank (can use multiple MR but not very efficient)</li></ul><h3 id="实际-Web-公司如何应用-MapReduce"><a href="#实际-Web-公司如何应用-MapReduce" class="headerlink" title="实际 Web 公司如何应用 MapReduce"></a>实际 Web 公司如何应用 MapReduce</h3><h3 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h3><p>Conclusion MapReduce single-handedly made big cluster computation popular.</p><ul><li>$\times$ 不是最高效灵活的。Not the most efficient or flexible.</li><li>$\checkmark$ 易于拓展。Scales well.</li><li>$\checkmark$ 易于编程。Easy to program — failures and data movement are hidden.</li></ul><p>上述几点是很好的权衡，在后续课程我们可以看到更多高级、成功的例子。</p>]]></content>
    
    
    <categories>
      
      <category>Computer Science</category>
      
      <category>分布式系统</category>
      
    </categories>
    
    
    <tags>
      
      <tag>分布式系统</tag>
      
      <tag>6.824</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>数字图像处理——图像复原（频率域）</title>
    <link href="/post/8809c911.html"/>
    <url>/post/8809c911.html</url>
    
    <content type="html"><![CDATA[<h1 id="频率域滤波图像复原"><a href="#频率域滤波图像复原" class="headerlink" title="频率域滤波图像复原"></a>频率域滤波图像复原</h1><p>在频率域滤波进行图像复原主要在两个方面效果较好，其一是利用频率域滤波消除周期噪声，另一个是利用频率域做退化函数的逆滤波，周期噪声还没有细致研究，这篇文章主要关注其逆滤波相关的问题。</p><p>为什么要在频率域做逆滤波？观察之前退化模型的两个式子，我们不难发现：</p><script type="math/tex; mode=display">g(x,y) = h(x,y) \star f(x,y) + \eta(x,y) \tag 1</script><script type="math/tex; mode=display">g(u,v) = H(u,v) F(u,v) + N(u,v) \tag 2</script><p>对(1)式空间域来说，想要从$g(x,y)$恢复$f(x,y)$，避不开的是“卷积”的逆运算，这在定义和实现的复杂上都比较困难，而转化到频率域，从(2)式我们或许可以通过一个“除法”来实现逆滤波，结合之前噪声模型相关内容，我们尝试在频率域上对仅退化函数影响的图像，和更复杂一些的，退化函数和加性噪声双重影响的图像进行复原。</p><h2 id="估计退化函数"><a href="#估计退化函数" class="headerlink" title="估计退化函数"></a>估计退化函数</h2><p>在图像复原时，主要有 3 种用于估计退化函数的方法：（1）观察法，（2）试验法，（3）数学建模法。这里我们着重讲建模估计。</p><ul><li><p>湍流模糊</p><p>Hufnagel and Stanley[1964]根据大气湍流的物理特性提出了一个退化模型，其通式为：</p><script type="math/tex; mode=display">H(u,v) = e^{-k{(u^2+v^2)}^{5/6}}</script><p>式中，$k$是与湍流性质有关的常熟。除了指数为$5/6$之外，该式与高斯低通极其相似。</p><p>实现：</p></li></ul><pre><code class="hljs python"><span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">getVesMask</span><span class="hljs-params">(mask_shape,k)</span>:</span>    rows,cols = mask_shape[<span class="hljs-number">0</span>],mask_shape[<span class="hljs-number">1</span>]    crow = rows/<span class="hljs-number">2</span>    ccol = cols/<span class="hljs-number">2</span>    mask = np.zeros((rows,cols))    <span class="hljs-keyword">for</span> i <span class="hljs-keyword">in</span> range(rows):        <span class="hljs-keyword">for</span> j <span class="hljs-keyword">in</span> range(cols):            dis = (i-crow)**<span class="hljs-number">2</span> + (j-ccol)**<span class="hljs-number">2</span>            mask[i,j] = np.exp(-k*(dis**(<span class="hljs-number">5</span>/<span class="hljs-number">6</span>)))    <span class="hljs-keyword">return</span> mask<span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">getVesFilterPassImg</span><span class="hljs-params">(input_img : np.array, k  , size = None)</span>:</span>    f_img = np.fft.fft2(input_img , s = size)    shift_img = np.fft.fftshift(f_img)    mask_shift_img = getVesMask(f_img.shape,k)    new_shift_img = mask_shift_img*shift_img    new_manitude_img = <span class="hljs-number">20</span>*np.log(np.abs(new_shift_img+eps))    new_f_img = np.fft.ifftshift(new_shift_img)    new_img = np.fft.ifft2(new_f_img)    new_img = np.abs(new_img)    <span class="hljs-keyword">return</span> new_img<span class="hljs-comment"># 测试</span><span class="hljs-comment"># 参数设置</span>mask_shape = (<span class="hljs-number">480</span>,<span class="hljs-number">480</span>)k = [<span class="hljs-number">0</span>,<span class="hljs-number">0.0025</span>,<span class="hljs-number">0.001</span>,<span class="hljs-number">0.00025</span>]plt.figure(figsize=(<span class="hljs-number">12</span>,<span class="hljs-number">12</span>))ax = [plt.subplot(<span class="hljs-number">221</span>,projection = <span class="hljs-string">"3d"</span>),plt.subplot(<span class="hljs-number">222</span>,projection = <span class="hljs-string">"3d"</span>),plt.subplot(<span class="hljs-number">223</span>,projection = <span class="hljs-string">"3d"</span>),plt.subplot(<span class="hljs-number">224</span>,projection = <span class="hljs-string">"3d"</span>)]<span class="hljs-comment"># 获得滤波器</span><span class="hljs-keyword">for</span> i <span class="hljs-keyword">in</span> range(<span class="hljs-number">4</span>):    <span class="hljs-keyword">if</span> i == <span class="hljs-number">0</span>:        drawPerspective(ax[i],np.ones(mask_shape),title =<span class="hljs-string">"Original Img"</span>,cmap = <span class="hljs-string">"gray"</span>)    <span class="hljs-keyword">else</span>:        myfilter = getVesMask(mask_shape,k[i])        drawPerspective(ax[i],myfilter,title = <span class="hljs-string">f"Ves Mask with $k=<span class="hljs-subst">&#123;k[i]&#125;</span>$"</span>, cmap = <span class="hljs-string">"gray"</span>)plt.show()test_img = cv2.imread(<span class="hljs-string">"./5_3Photo/Fig0525(a).tif"</span>,<span class="hljs-number">0</span>)plt.figure(figsize=(<span class="hljs-number">12</span>,<span class="hljs-number">12</span>))ax = [plt.subplot(<span class="hljs-number">221</span>),plt.subplot(<span class="hljs-number">222</span>),plt.subplot(<span class="hljs-number">223</span>),plt.subplot(<span class="hljs-number">224</span>)]<span class="hljs-keyword">for</span> i <span class="hljs-keyword">in</span> range(<span class="hljs-number">4</span>):    <span class="hljs-keyword">if</span> i == <span class="hljs-number">0</span>:        ax[i].imshow(test_img,cmap = <span class="hljs-string">"gray"</span>)        ax[i].set_title(<span class="hljs-string">"Original Img"</span>)    <span class="hljs-keyword">else</span>:        out_img = getVesFilterPassImg(test_img,k[i])        ax[i].imshow(out_img,cmap = <span class="hljs-string">"gray"</span>)        ax[i].set_title(<span class="hljs-string">f"Ves Mask with $k=<span class="hljs-subst">&#123;k[i]&#125;</span>$"</span>)</code></pre><p><img src="https://eddyblog.oss-cn-shenzhen.aliyuncs.com/ImageProcess/ImageRestoration/5_3_1.png" srcset="/img/loading.gif" alt="png"></p><p><img src="https://eddyblog.oss-cn-shenzhen.aliyuncs.com/ImageProcess/ImageRestoration/5_3_2.png" srcset="/img/loading.gif" alt="png"></p><a id="more"></a><ul><li><p>运动模糊</p><p>是从基本原理开始推导的一个数学模型，光学成像图像获取时被被图像与传感器之间的均匀线性运动模糊了，最终$g(x,y)$反映为$f(x,y)$不同时间间隔内瞬时曝光量叠加形成的，（空间域）数学表达为：</p><script type="math/tex; mode=display">g(x,y) = \int_0^{T}{ f [x-x_0(t),y-y_0(t)] } \mathrm{d}t</script><p>频率域中的操作，应用傅里叶变换，中间省略，最后根据$F(u,v)$与$t$无关得出，我们想要的频率域退化函数表达：</p><script type="math/tex; mode=display">H(u,v) = \int_0^T {e^{-j2\pi[ux_0(t)+vy_0(t)]}} \mathrm{d}t</script><p>满足 x,y 方向做匀速直线运动$x_0(t) = at/T$和$y_0(t) = bt/T$，则退化函数可以直接由上式得。</p><script type="math/tex; mode=display">H(u,v) =  \dfrac{T}{\pi (ua+vb)} sin[\pi(ua+vb)]   e^{-j\pi[ua+vb]}</script><p>那么我们用$(u,v)$对该式取样，就可以生成一个离散滤波器，我的实现是（这个实现 bug 了）：</p></li></ul><pre><code class="hljs python"><span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">getMoveMask</span><span class="hljs-params">(mask_shape,param_a,param_b,param_T)</span>:</span>    rows,cols = mask_shape[<span class="hljs-number">0</span>],mask_shape[<span class="hljs-number">1</span>]    crow = rows/<span class="hljs-number">2</span>    ccol = cols/<span class="hljs-number">2</span>    mask = np.zeros((rows,cols), dtype = np.complex)    <span class="hljs-keyword">for</span> i <span class="hljs-keyword">in</span> range(rows):        <span class="hljs-keyword">for</span> j <span class="hljs-keyword">in</span> range(cols):            <span class="hljs-keyword">if</span> i == <span class="hljs-number">0</span> <span class="hljs-keyword">and</span> j== <span class="hljs-number">0</span>:                <span class="hljs-keyword">continue</span>            <span class="hljs-keyword">else</span>:                temp = i*param_a+j*param_b                temp2 = np.exp(np.complex(<span class="hljs-number">0</span>,-np.pi*temp))                mask[i,j] = temp2*np.sin(np.pi*temp)*param_T/(np.pi*temp)    <span class="hljs-keyword">return</span> mask<span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">getMoveFilterPassImg</span><span class="hljs-params">(input_img : np.array, a,b,T , size = None)</span>:</span>    f_img = np.fft.fft2(input_img , s = size)    shift_img = np.fft.fftshift(f_img)    mask_shift_img = getMoveMask(f_img.shape,a,b,T)    new_shift_img = mask_shift_img*shift_img    new_manitude_img = <span class="hljs-number">20</span>*np.log(np.abs(new_shift_img+eps))    new_f_img = np.fft.ifftshift(new_shift_img)    new_img = np.fft.ifft2(new_f_img)    new_img = np.abs(new_img)    <span class="hljs-keyword">return</span> new_img,new_manitude_imgtest_img = cv2.imread(<span class="hljs-string">"./5_3Photo/Fig0526.tif"</span>,<span class="hljs-number">0</span>)a = <span class="hljs-number">0.2</span>b = <span class="hljs-number">0.15</span>T = <span class="hljs-number">1</span>plt.figure(figsize=(<span class="hljs-number">12</span>,<span class="hljs-number">6</span>))ax1 = plt.subplot(<span class="hljs-number">121</span>)ax2 = plt.subplot(<span class="hljs-number">122</span>)ax1.imshow(test_img,cmap = <span class="hljs-string">"gray"</span>)ax1.set_title(<span class="hljs-string">"Original Img2"</span>)out_img,test = getMoveFilterPassImg(test_img,a,b,T)ax2.imshow(out_img,cmap=<span class="hljs-string">"gray"</span>)plt.show()</code></pre><p><img src="https://eddyblog.oss-cn-shenzhen.aliyuncs.com/ImageProcess/ImageRestoration/5_3_3.png" srcset="/img/loading.gif" alt="png"></p><pre><code class="hljs python"><span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">getMotionMask</span><span class="hljs-params">(mask_shape,param_len,param_theta)</span>:</span>    rows,cols = mask_shape[<span class="hljs-number">0</span>],mask_shape[<span class="hljs-number">1</span>]    crow = (rows<span class="hljs-number">-1</span>)/<span class="hljs-number">2</span>    ccol = (cols<span class="hljs-number">-1</span>)/<span class="hljs-number">2</span>    mask = np.zeros((rows,cols))    sin_val = np.sin(param_theta*np.pi/<span class="hljs-number">180</span>)    cos_val = np.cos(param_theta*np.pi/<span class="hljs-number">180</span>)    <span class="hljs-keyword">for</span> i <span class="hljs-keyword">in</span> range(param_len):        x_offset = round(sin_val*i)        y_offset = round(cos_val*i)        mask[int(crow+x_offset),int(ccol+y_offset)] =<span class="hljs-number">1</span>    mask = mask/mask.sum()    <span class="hljs-keyword">return</span> np.fft.fft2(mask)<span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">getMotionFilterPassImg</span><span class="hljs-params">(input_img : np.array, l,t , size = None)</span>:</span>    f_img = np.fft.fft2(input_img , s = size)    mask_img = getMotionMask(f_img.shape,l,t)    new_img = f_img*mask_img    new_img = np.fft.ifft2(new_img)    output_img = np.fft.ifftshift(new_img)    output_img = np.abs(output_img)    <span class="hljs-keyword">return</span> output_imgtest_img = cv2.imread(<span class="hljs-string">"./5_3Photo/Fig0526.tif"</span>,<span class="hljs-number">0</span>)l = <span class="hljs-number">50</span>t = <span class="hljs-number">30</span>plt.figure(figsize=(<span class="hljs-number">12</span>,<span class="hljs-number">6</span>))ax1 = plt.subplot(<span class="hljs-number">121</span>)ax2 = plt.subplot(<span class="hljs-number">122</span>)ax1.imshow(test_img,cmap = <span class="hljs-string">"gray"</span>)ax1.set_title(<span class="hljs-string">"Original Img2"</span>)out_img = getMotionFilterPassImg(test_img,l,t)ax2.imshow(out_img,cmap=<span class="hljs-string">"gray"</span>)plt.show()</code></pre><p><img src="https://eddyblog.oss-cn-shenzhen.aliyuncs.com/ImageProcess/ImageRestoration/5_3_4.png" srcset="/img/loading.gif" alt="png"></p><h2 id="逆滤波"><a href="#逆滤波" class="headerlink" title="逆滤波"></a>逆滤波</h2><p>退化函数已给出，或者由上面退化函数的估计方法获得后，最简单的复原方法是直接做逆滤波，即：</p><script type="math/tex; mode=display">\hat{F}(u,v) = \dfrac{G(u,v)}{H(u,v)}</script><p>然而根据前述我们知道，在噪声的影响下，$\hat{F}(u,v)$和$F(u,v)$仍有差别，即</p><script type="math/tex; mode=display">\hat{F}(u,v) = F(u,v) \dfrac{N(u,v)}{H(u,v)}</script><p>这个式子两点启发：</p><ol><li>知道退化函数也不能完全复原未退化图像，因为噪声函数未知。</li><li>如果退化函数是零或是非常小的之，那么噪声影响会被放大</li></ol><h2 id="最小均方误差（维纳）滤波"><a href="#最小均方误差（维纳）滤波" class="headerlink" title="最小均方误差（维纳）滤波"></a>最小均方误差（维纳）滤波</h2><p>实际上维纳滤波是在这里是相对逆滤波来说的，而并非指特别的滤波函数，且不仅应用在运动模糊滤波中。</p><script type="math/tex; mode=display">\hat{F}(u,v) =[\dfrac{1}{H(u,v)} \dfrac{ {|H(u,v)|}^2 }{ {|H(u,v)|}^2+ S_{\eta}(u,v)/S_f(u,v) }] G(u,v)</script><p>$S_{\eta}(u,v)$为噪声的功率谱而$S_f(u,v)$是未退化图像的功率谱，比值为噪信比。而由于谱${|N(u,v)|}^2$是一个常数，这大大简化了处理。我们常用下面的表达式来近似。</p><script type="math/tex; mode=display">\hat{F}(u,v) =[\dfrac{1}{H(u,v)} \dfrac{ {|H(u,v)|}^2 }{ {|H(u,v)|}^2+ K }] G(u,v)</script><pre><code class="hljs python"><span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">wienerFiltering</span><span class="hljs-params">(input_img, h, NSR ,htype = <span class="hljs-string">"frequency"</span>)</span>:</span>    <span class="hljs-keyword">assert</span> htype <span class="hljs-keyword">in</span> (<span class="hljs-string">"frequency"</span>,<span class="hljs-string">"spatial"</span>)    <span class="hljs-comment"># 输入图像的傅里叶变换</span>    input_img_fft = np.fft.fft2(input_img)    input_img_fft = np.fft.ifftshift(input_img_fft)    <span class="hljs-keyword">if</span>(htype == <span class="hljs-string">"spatial"</span>):        <span class="hljs-comment"># 模糊化函数的傅里叶变换</span>        h_fft = np.fft.fft2(h)    <span class="hljs-keyword">else</span> :        h_fft = h    <span class="hljs-comment"># 退化函数模值的平方</span>    h_abs_square = np.abs(h_fft)**<span class="hljs-number">2</span>    <span class="hljs-comment"># 维纳滤波</span>    <span class="hljs-comment"># 使用的是 共轭/模方+NSR的形式，并非 9 10 式</span>    output_image_fft = np.conj(h_fft) / (h_abs_square + NSR)    <span class="hljs-comment"># 输出图像傅里叶反变换</span>    output_image = np.fft.ifft2(output_image_fft * input_img_fft)    output_image = np.abs(np.fft.fftshift(output_image))    <span class="hljs-keyword">return</span> output_image<span class="hljs-comment"># 测试 逆滤波</span>nsr = <span class="hljs-number">0</span>h = getMotionMask(test_img.shape,l,t)output_img= getMotionFilterPassImg(test_img,l,t)plt.figure(figsize=(<span class="hljs-number">12</span>,<span class="hljs-number">6</span>))ax1 = plt.subplot(<span class="hljs-number">121</span>)ax2 = plt.subplot(<span class="hljs-number">122</span>)ax1.imshow(output_img,cmap = <span class="hljs-string">"gray"</span>)ax1.set_title(<span class="hljs-string">"Original Img2"</span>)inverse_img = wienerFiltering(out_img,h,nsr,<span class="hljs-string">"frequency"</span>)ax2.imshow(inverse_img,cmap=<span class="hljs-string">"gray"</span>)plt.show()nsr = <span class="hljs-number">0.01</span>h = getMotionMask(test_img.shape,l,t)output_img = getMotionFilterPassImg(test_img,l,t)plt.figure(figsize=(<span class="hljs-number">12</span>,<span class="hljs-number">6</span>))ax1 = plt.subplot(<span class="hljs-number">121</span>)ax2 = plt.subplot(<span class="hljs-number">122</span>)ax1.imshow(output_img,cmap = <span class="hljs-string">"gray"</span>)ax1.set_title(<span class="hljs-string">"Original Img2"</span>)inverse_img = wienerFiltering(out_img,h,nsr,<span class="hljs-string">"frequency"</span>)ax2.imshow(inverse_img,cmap=<span class="hljs-string">"gray"</span>)plt.show()</code></pre><p><img src="https://eddyblog.oss-cn-shenzhen.aliyuncs.com/ImageProcess/ImageRestoration/5_3_5.png" srcset="/img/loading.gif" alt="png"></p><p><img src="https://eddyblog.oss-cn-shenzhen.aliyuncs.com/ImageProcess/ImageRestoration/5_3_6.png" srcset="/img/loading.gif" alt="png"></p>]]></content>
    
    
    <categories>
      
      <category>Computer Science</category>
      
      <category>数字图像处理</category>
      
    </categories>
    
    
    <tags>
      
      <tag>数字图像处理</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>数字图像处理——图像复原（空间域）</title>
    <link href="/post/c7192b31.html"/>
    <url>/post/c7192b31.html</url>
    
    <content type="html"><![CDATA[<h1 id="空间域滤波图像复原"><a href="#空间域滤波图像复原" class="headerlink" title="空间域滤波图像复原"></a>空间域滤波图像复原</h1><p>在<a href="https://www.edwardzcn98yx.com/post/199b3bb2.html">5_1 图像复原与重建初步</a>中，我们研究了图像的噪声退化模型，以及常见的噪声模型及其实现，实际上这些噪声模型帮我们解决了前一篇文章(1)式中$\eta(x,y)$的取值问题，同时再观察(1)式我们也能发现，当一幅图像中唯一存在的退化是噪声时，式(1)和式(2)会变成（简化）如下：</p><script type="math/tex; mode=display">g(x,y) = f(x,y) + \eta (x,y)</script><p>和</p><script type="math/tex; mode=display">G(u,v) = F(u,v) + N(u,v)</script><p>我们发现没了“退化函数”，复原在空间域和频率域都是一个可加形式，估计噪声情况后，便可得到原图像的一个估计，故在仅存在加性噪声的情况下，可以选择空间滤波方法。</p><p>一些简单实现在前面第三章已经讨论过，比如算数均值滤波器，这一章节主要是做更深入的研究。</p><h2 id="均值滤波器"><a href="#均值滤波器" class="headerlink" title="均值滤波器"></a>均值滤波器</h2><h2 id="统计排序滤波器"><a href="#统计排序滤波器" class="headerlink" title="统计排序滤波器"></a>统计排序滤波器</h2><h2 id="自适应滤波器"><a href="#自适应滤波器" class="headerlink" title="自适应滤波器"></a>自适应滤波器</h2><p>有待后续学习补充。</p>]]></content>
    
    
    <categories>
      
      <category>Computer Science</category>
      
      <category>数字图像处理</category>
      
    </categories>
    
    
    <tags>
      
      <tag>数字图像处理</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>数字图像处理——图像复原与重建初步</title>
    <link href="/post/199b3bb2.html"/>
    <url>/post/199b3bb2.html</url>
    
    <content type="html"><![CDATA[<h1 id="图像复原与重建初步"><a href="#图像复原与重建初步" class="headerlink" title="图像复原与重建初步"></a>图像复原与重建初步</h1><p>梳理所学重点知识</p><h2 id="引言"><a href="#引言" class="headerlink" title="引言"></a>引言</h2><p>前面所接触的图像增强是一个，已知原图像，经处理后，得到增强图像的一个过程，而这一章将要深入的图像复原（重建），则是希望从（被污染）过的图像，经处理后，得到原图像的过程，是以<strong>预先确定的目标</strong>来改善图像。图像复原试图利用退化现象的某种<strong>先验知识</strong>来复原被退化的图像。因而，复原技术时面向退化模型的，并且采用相反的过程进行处理，以便恢复出原图像。虽然图像增强和图像复原两者在覆盖的领域和使用的技术栈有所重叠，其中还是有几点区别我们还是要提起注意的。</p><ul><li><p>形象化的描述</p><p>图像增强主要是一个主观的过程，而图像复原大部分是一个客观的过程。</p></li><li><p>已知与未知的区别</p><p>图像增强已知原始图像与变换（卷积核或者其频率域的谱），对于增强效果是未知且非预先确定的（只有一个大概方向，比如模糊还是锐化），而图像复原则已知污染图像，且对原始图像是预先确定的（测试条件下甚至是有标准比对的原始图像，是已知的），对于复原变换（污染变换的逆）常常是未知的，这就要求我们在做图像处理时常常需要“估计”我们的复原变换。</p></li><li><p>期望与探索的区别<br>由于两者已知和未知上的差距，这就导致图像复原通常会涉及设立一个<strong>最佳准则</strong>来产生期望结果的最佳估计。相比之下，图像增强技术基本上是一个<strong>探索性过程</strong>，即根据人类视觉系统的生理特点来设计改善图像的方法。</p></li></ul><h2 id="背景知识"><a href="#背景知识" class="headerlink" title="背景知识"></a>背景知识</h2><h3 id="线性系统"><a href="#线性系统" class="headerlink" title="线性系统"></a>线性系统</h3><p>可加性，$x_1(t)+x_2(t) = y_1(t)+y_2(t)$，从而有$a \times x_1(t) = a \times y_1(t)$</p><p>平移不变性</p><h3 id="卷积"><a href="#卷积" class="headerlink" title="卷积"></a>卷积</h3><p>卷积、离散二维卷积</p><p>从而可以利用卷积这个工具。</p><p>冲激响应：输入为一个脉冲信号，输出是一个冲激响应$h(x)$，实际上可以就是之前接触过的卷积核。</p><h3 id="图形复原"><a href="#图形复原" class="headerlink" title="图形复原"></a>图形复原</h3><p>复原</p><ul><li>试图利用退化过程的先验知识使已退化的图像恢复本来面目</li><li>根据退化的原因，分析引起退化的环境因素</li><li>建立相应的数学模型</li><li>沿着使图像降质的逆过程回复图像</li></ul><p>目的</p><ul><li>在于消除或减轻退化的影响</li></ul><p>方法</p><ul><li>由于退化系统是黑盒的，盲复原往往很困难，噪声干扰也为复原过程带来了困难和不确定性</li><li>图像复原是寻求在一定优化准则下的原始图象的最有估计。因此，不同的优化准则会获得不同的图像复原。评价指标的选择目前也是研究的方向之一，如峰值信号比等。</li></ul><h2 id="图像退化-复原过程模型"><a href="#图像退化-复原过程模型" class="headerlink" title="图像退化/复原过程模型"></a>图像退化/复原过程模型</h2><p>退化过程（污染过程）的描述：建模为一个退化函数和一个加性噪声项，对于输入图像（原图像）$f(x,y)$进行处理，产生一副退化后的图像$g(x,y)$，图像复原目的就是已知$g(x,y)$的前提下，希望得到原图像的一个估计，这个估计越接近原始输入图像越好。空间域中的退化图像可由下式给出：</p><script type="math/tex; mode=display">g(x,y) = h(x,y)  \star f(x,y) + \eta(x,y)</script><p>上式中$h(x,y)$是退化函数的空间表示，由第四章内容，我们可以将上式的模型写成等价的频率域表示：</p><script type="math/tex; mode=display">g(u,v) = H(u,v) F(u,v) + N(u,v)</script><p>这两个式子是本章后面大部分复原内容的基础。</p><h2 id="噪声模型"><a href="#噪声模型" class="headerlink" title="噪声模型"></a>噪声模型</h2><h3 id="噪声的空间和频率特性"><a href="#噪声的空间和频率特性" class="headerlink" title="噪声的空间和频率特性"></a>噪声的空间和频率特性</h3><p>一些重要概念：</p><p>当噪声的傅里叶谱是常量时，噪声通常成为<strong>白噪声</strong>，这个术语是从白光的物理特性派生出来的，它以相等的比例包含可见光谱中的几乎所有频率。</p><p>除了空间周期噪声之外，本章假设其他噪声与空间坐标无关，并且噪声与图像本身不想管（即像素值与噪声成分的值之间不相关）。虽然这些假设至少在某些应用中（例如 X 射线和医学成像的有限量子成像就是一个很好的例子）是无效的，但处理空间相关和相关性噪声的复杂性超出了我们讨论的范围。</p><h3 id="一些重要的噪声概率密度函数"><a href="#一些重要的噪声概率密度函数" class="headerlink" title="一些重要的噪声概率密度函数"></a>一些重要的噪声概率密度函数</h3><p>概率论回顾</p><ol><li><p>高斯（正态）噪声</p><p>其 PDF 由下式给出：</p><script type="math/tex; mode=display">p(z) = \dfrac{1}{\sqrt{2 \pi} \sigma} e^{ \frac{ {(z- \overline{z})}^2 }{2 \sigma^2} }</script><p>$\overline{z}$表示$z$的均值，$\sigma$表示$z$的标准差。</p></li><li><p>瑞利噪声</p><p>其 PDF 由下式给出：</p></li></ol>$$p(z)=\left \{\begin{aligned}\frac{2}{b}(z-a)e^{ \frac{-{(z-a)}^2}{b} }  & , &   z  \ge a \\0 & , & z < a\end{aligned}\right.$$<p>概率密度的均值与方差的给出：$\overline{z} = a + \sqrt{ \pi b / 4}$，$\sigma ^2 = \dfrac{b(4-\pi)}{4}$</p><ol><li><p>爱尔兰（伽马）噪声</p><p>其 PDF 由下式给出：</p></li></ol>$$p(z)=\left \{\begin{aligned}\dfrac{a^b z^ {b-1} } { (b-1)!}e^{ -az}  & , &   z  \ge a \\0 & , & z < a\end{aligned}\right.$$<p>概率密度的均值与方差的给出：$\overline{z} = \dfrac{b}{a}$ ，$\sigma ^2 = \dfrac{b}{a^2}$</p><ol><li><p>指数噪声</p><p>其 PDF 由下式给出：</p></li></ol><script type="math/tex; mode=display">p(z)=\left \{\begin{aligned}ae^{ -az}  & , &   z  \ge a \\0 & , & z < a\end{aligned}\right.</script><p>可以看作是$b=1$时爱尔兰 PDF 的特殊情况。概率密度的均值和方差是：$\overline{z} = \dfrac{1}{a}$，$\sigma^2 = \dfrac{1}{a^2}$</p><ol><li><p>均匀噪声</p><p>其 PDF 由下式给出：</p></li></ol><script type="math/tex; mode=display">p(z)=\left \{\begin{aligned}\dfrac{1}{b-a}  & , &   a \le z \le b \\0 & , & 其他\end{aligned}\right.</script><p>概率密度的均值与方差的给出：$\overline{z} = \dfrac{a+b}{2}$，$\sigma^2 = \dfrac {  {  (b-a)}^2}{12}$</p><ol><li><p>脉冲（椒盐）噪声</p><p>其 PDF 由下式给出：</p></li></ol><script type="math/tex; mode=display">p(z)=\left \{\begin{aligned}P_a  & , &   z = a \\P_b & , &  z = b \\1-P_a-P_b & , & 其他\end{aligned}\right.</script><a id="more"></a><pre><code class="hljs python"><span class="hljs-comment"># 编写 添加噪声函数 并显示噪声情况</span><span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">getGaussianNoise</span><span class="hljs-params">(loc,scale,size = None)</span>:</span>    <span class="hljs-keyword">return</span> np.random.normal(loc,scale,size)<span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">getRayleighNoise</span><span class="hljs-params">(scale,size = None)</span>:</span>    <span class="hljs-comment"># b = 2 scle^2 这里统一根据使用 scale</span>    <span class="hljs-keyword">return</span> np.random.rayleigh(scale,size)<span class="hljs-comment"># 测试，展示高斯和瑞利的分布直方图</span>mu = <span class="hljs-number">0.5</span>sigma = <span class="hljs-number">0.1</span>sigma2 = <span class="hljs-number">0.2</span>gnoise = getGaussianNoise(mu,sigma,<span class="hljs-number">1000</span>)rnoise = getRayleighNoise(sigma2,<span class="hljs-number">1000</span>)plt.figure(figsize=(<span class="hljs-number">10</span>,<span class="hljs-number">7</span>))ax1 = plt.subplot(<span class="hljs-number">111</span>)ax1.hist(gnoise,<span class="hljs-number">80</span>,density = <span class="hljs-keyword">True</span>,histtype = <span class="hljs-string">'stepfilled'</span>,edgecolor = <span class="hljs-string">"white"</span>,label = <span class="hljs-string">"Gaussian Noise"</span>,alpha = <span class="hljs-number">0.7</span>)ax1.hist(rnoise,<span class="hljs-number">80</span>,density = <span class="hljs-keyword">True</span>,histtype = <span class="hljs-string">'stepfilled'</span>,edgecolor = <span class="hljs-string">"white"</span>, label = <span class="hljs-string">"Rayleigh Noise"</span> , alpha = <span class="hljs-number">0.7</span>)ax1.legend()plt.show()</code></pre><p><img src="https://eddyblog.oss-cn-shenzhen.aliyuncs.com/ImageProcess/ImageRestoration/5_1_1.png" srcset="/img/loading.gif" alt="png"></p><pre><code class="hljs python"><span class="hljs-comment"># 给图像加噪声</span><span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">getGaussianNoiseImg</span><span class="hljs-params">(input_img, loc, scale,rate = <span class="hljs-number">1</span>)</span>:</span>    <span class="hljs-string">"""    getGaussianNoiseImg 获得被高斯白噪声污染的图像    :param input_img: 输入原始图像    :param loc: 高斯分布均值    :param scale: 高斯分布标准差    :return: 加噪的图像    """</span>    float_img = np.array(input_img/<span class="hljs-number">255</span>, dtype = np.float64)    noise = np.random.normal(loc,scale,float_img.shape)    output_img = float_img+noise*rate    output_img = np.clip(output_img,<span class="hljs-number">0</span>,<span class="hljs-number">1.0</span>)    output_img = np.uint8(output_img*<span class="hljs-number">255</span>)    <span class="hljs-keyword">return</span> output_img<span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">getRayleighNoiseImg</span><span class="hljs-params">(input_img, scale,rate = <span class="hljs-number">1</span>)</span>:</span>    <span class="hljs-string">"""    getRayleighNoiseImg 获得被瑞利白噪声污染的图像    :param input_img: 输入原始图像    :param scale: 瑞利分布的scale 与b相关 a为0（没找到调整方法）    :return: 加噪的图像    """</span>    float_img = np.array(input_img/<span class="hljs-number">255</span>, dtype = np.float64)    noise = np.random.rayleigh(scale,float_img.shape)    output_img = float_img+noise*rate    output_img = np.clip(output_img,<span class="hljs-number">0</span>,<span class="hljs-number">1.0</span>)    output_img = np.uint8(output_img*<span class="hljs-number">255</span>)    <span class="hljs-keyword">return</span> output_imgmu = <span class="hljs-number">0.5</span>sigma1 = <span class="hljs-number">0.1</span>sigma2 = <span class="hljs-number">0.2</span>img1 = cv2.imread(<span class="hljs-string">'./5_1Photo/Fig0503.tif'</span>,<span class="hljs-number">0</span>)gnoise_img1 = getGaussianNoiseImg(img1,mu,sigma1,<span class="hljs-number">0.3</span>)rnoise_img1 = getRayleighNoiseImg(img1,sigma2,<span class="hljs-number">0.5</span>)img2 = getRGB(<span class="hljs-string">'./5_1Photo/4.tif'</span>)gnoise_img2 = getGaussianNoiseImg(img2,mu,sigma1,<span class="hljs-number">0.3</span>)rnoise_img2 = getRayleighNoiseImg(img2,sigma2,<span class="hljs-number">0.5</span>)showThreeImg(img1,gnoise_img1,rnoise_img1,<span class="hljs-string">"Original Img1"</span>,<span class="hljs-string">"Gaussian Noise with rate = 0.3"</span>,<span class="hljs-string">"Rayleigh Noise with rate = 0.5"</span>)showThreeImg(img2,gnoise_img2,rnoise_img2,<span class="hljs-string">"Original Img2"</span>,<span class="hljs-string">"Gaussian Noise with rate = 0.3"</span>,<span class="hljs-string">"Rayleigh Noise with rate = 0.5"</span>)</code></pre><p><img src="https://eddyblog.oss-cn-shenzhen.aliyuncs.com/ImageProcess/ImageRestoration/5_1_2.png" srcset="/img/loading.gif" alt="png"></p><p><img src="https://eddyblog.oss-cn-shenzhen.aliyuncs.com/ImageProcess/ImageRestoration/5_1_3.png" srcset="/img/loading.gif" alt="png"></p>]]></content>
    
    
    <categories>
      
      <category>Computer Science</category>
      
      <category>数字图像处理</category>
      
    </categories>
    
    
    <tags>
      
      <tag>数字图像处理</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>数据分析与融合——偏序格角度看决策系统代数约简</title>
    <link href="/post/be292322.html"/>
    <url>/post/be292322.html</url>
    
    <content type="html"><![CDATA[<h1 id="偏序格角度看决策系统代数约简"><a href="#偏序格角度看决策系统代数约简" class="headerlink" title="偏序格角度看决策系统代数约简"></a>偏序格角度看决策系统代数约简</h1><p>基本知识：</p><ul><li>一个集合的所有划分构成一个<strong>细分偏序格</strong>。</li><li>决策系统约简始终保持决策系统的一致性（不存在条件相同，决策不同）。</li><li>对于一个决策系统来说，约简是条件分类$U/C → U/A$的过程，而条件分类$U/C$<strong>细分</strong>$U/A$。</li></ul><p>引发思考：</p><p>课程的结尾老师提到我们的决策系统约见过程，其<strong>条件分类</strong>可以看作是在一个论语元素的全部划分构成的细分偏序格上<strong>寻优</strong>的过程。</p><p>直观上给人的感觉是这样的，这篇文章主要是想回过头来，从偏序格角度回看这一寻优过程，并解决以下疑惑：</p><ul><li>Q1.为什么可以看做是细分偏序格上的寻优？</li><li>Q2.寻优的终点（极小值）对应的是哪个（些）结点，有没有什么特征？</li><li>Q3.寻优的路径是怎样的，有没有什么特征，是否会与“偏序”产生关系？</li></ul><p>带着这些疑问，我开始了自己的琢磨。</p><p>由于里面一些很数学的东西并没有细致详尽的证明，我只能从数学角度看待，还不算科学的证明，有待于后面复习时巩固数学部分的证明。</p><h2 id="Q1-寻优的解释"><a href="#Q1-寻优的解释" class="headerlink" title="Q1.寻优的解释"></a>Q1.寻优的解释</h2><p>为方便描述，我们使用老师所给出的决策系统样例。</p><p><img src="https://eddyblog.oss-cn-shenzhen.aliyuncs.com/DataAnalysis/1.jpg" srcset="/img/loading.gif" alt="png"></p><p>同时做以下约定，与一些教材（包括老师提供的讲稿）中有些许不同：</p><ul><li>$U$为论域元素集合</li><li>$Road_1,Road_2 \cdots$ 表示约简路径 1，2 等等。</li><li>$C$为最初的属性集合，为方便约见过程中属性集的变换，我们再做以下规定。<ul><li>$C_{i1}$表示约简路径$Road_i$上的第$1$次约简后的属性集，及初始状态，所以易知，$C_{i0} = C$</li><li>$C_{ij},j \not ={0}$表示约简路径$i$上的第$j$次约简后的属性集。</li></ul></li><li>$D$为决策值集合</li></ul><p>约定都完成了，我们该如何解释“约简”<strong>可以看做</strong>是细分偏序格上的寻优过程呢？我想可以从细分偏序格上<strong>结点</strong>，和<strong>路径</strong>两点与我们约简不同阶段的<strong>状态</strong>和<strong>转移过程</strong>对应起来</p><a id="more"></a><h3 id="结点-and-状态"><a href="#结点-and-状态" class="headerlink" title="结点 and 状态"></a>结点 and 状态</h3><p>细分偏序格图示上每个结点对应一个划分，而我们决策系统约简过程中，每一个约简前后的状态实际上也是一个论域的划分。</p><p>举例 1，根结点，未分类状态。</p><p>此时也未进行决策系统一致性检测，这么说的原因是，我们还未用$C_{i1}$进行任何一次属性集上的等价类划分，此时每个元素都是相互分开的，</p><p><img src="https://eddyblog.oss-cn-shenzhen.aliyuncs.com/DataAnalysis/2.png" srcset="/img/loading.gif" alt="png"></p><p>举例 2，初始决策系统检测结点，由于我们这个表中没有重复项，所以应用$C_{i1} = C$（对于任意一条路径都一样，所以用了$i$表示），得到的划分仍然是原来的划分（对于带重复项的则不然）。</p><p><img src="https://eddyblog.oss-cn-shenzhen.aliyuncs.com/DataAnalysis/3.png" srcset="/img/loading.gif" alt="png"></p><p>举例 3，$C_{01} = C_{00}- a_1$，约简$a_1$后，划分$U/C_{11} = \{   \{ x_1, x_6 \} , \{ x_2, x_8 \} , \{ x_3 \} , \{ x_4 \} ,\{ x_5 \} , \{ x_7 \}  \}$。</p><p><img src="https://eddyblog.oss-cn-shenzhen.aliyuncs.com/DataAnalysis/3.jpg" srcset="/img/loading.gif" alt="jpg"></p><p>其对应的结点为</p><p><img src="https://eddyblog.oss-cn-shenzhen.aliyuncs.com/DataAnalysis/4.png" srcset="/img/loading.gif" alt="png"></p><h3 id="路径-and-转移过程"><a href="#路径-and-转移过程" class="headerlink" title="路径 and 转移过程"></a>路径 and 转移过程</h3><p>在最前面的基本知识已经提到了：</p><blockquote><p>对于一个决策系统来说，约简是条件分类$U/C → U/A$的过程，而条件分类$U/C$<strong>细分</strong>$U/A$。</p></blockquote><p>换言之，我们一条路径上约简的结点状态变化应该为$U/C_{i1} \rightarrow U/C_{i2} \rightarrow U/C_{i3} \cdots$，而前者都是<strong>细分</strong>后者的，所以必然是细分偏序格<strong>向上</strong>的方向。</p><blockquote><p>一点数学解释：由于是约简，我们可以确定一条路径上 $C_{ij}\subseteq C_{ik}$对任意$j&lt;k$，故其确定的等价关系 $R_{ij} \subseteq C_{ik}$，而由商集的性质易知其细分关系。</p></blockquote><p>举例，如约简两次达到最终的不可约简状态，转移图。</p><p><img src="https://eddyblog.oss-cn-shenzhen.aliyuncs.com/DataAnalysis/5.png" srcset="/img/loading.gif" alt="png"></p><p>需要提起注意的是，<strong>箭头并非只代表细分偏序格 Hasse 图中的那些边，而是代表 precede，可能是多条 Hasse 图中边（即跨越了一些状态）</strong>，这也是我后面探索的问题的来源。</p><h2 id="Q2-最终状态点与极小属性集"><a href="#Q2-最终状态点与极小属性集" class="headerlink" title="Q2.最终状态点与极小属性集"></a>Q2.最终状态点与极小属性集</h2><p>在课上我也问到了老师这样一个问题，我们找到的约见后条件属性集是“极小”而非最小，因而有可能会存在多个。</p><p><img src="https://eddyblog.oss-cn-shenzhen.aliyuncs.com/DataAnalysis/6.jpg" srcset="/img/loading.gif" alt="jpg"></p><p>而这个样例中确实存在两个“极小”。分别应该是：</p><ul><li>$C_{13} = \{a_2,a_3 \}$ 即刚刚演示的路径和最终状态</li><li>$C_{23} = \{a_2,a_4 \}$</li></ul><p>进一步观察，<strong>他们对应细分偏序格上的状态是不同的（路径也是不同的）</strong>，<strong>也即$U/C_{13} \not ={ U/C_{23}}$</strong>，相同特征是，他们必位于他们各自寻优路径</p><p>他们对应的划分如下：</p><script type="math/tex; mode=display">U/C_{13} = \{   \{ x_1, x_6 \} , \{ x_2, x_8 \} , \{ x_3 \} , \{ x_4 ,x_5 \} , \{ x_7 \}  \}</script><script type="math/tex; mode=display">U/C_{23} = \{   \{ x_1, x_6 \} , \{ x_2, x_8 \} , \{ x_3 \} , \{ x_4 ,x_7 \} , \{ x_5 \}  \}</script><p>路径图示如下：</p><p><img src="https://eddyblog.oss-cn-shenzhen.aliyuncs.com/DataAnalysis/7.png" srcset="/img/loading.gif" alt="png"></p><p>发现改变在$x_4,x_5,x_7$上，试图寻找一些关联性。我回去复查了以下原始的表。</p><p><img src="https://eddyblog.oss-cn-shenzhen.aliyuncs.com/DataAnalysis/1.jpg" srcset="/img/loading.gif" alt="png"></p><p>发现在决策列$x_4,x_5,x_7$均为$1$，这其中有什么相关性吗？联想上图下面给出的决策划分：</p><script type="math/tex; mode=display">U/D = \{   \{ x_1, x_3 ,x_6 \} , \{ x_2, x_4,x_G5 ,x_7, x_8 \}  \}</script><p>同时联想到我们约简过程，相对正域，<strong>始终</strong>都必须要满足我们的条件划分元素$X_i$被决策划分的元素$Y_j$包含，所以我们的约简过程最初就存在一个上界，就是$U/D$，图示如下。</p><p><img src="https://eddyblog.oss-cn-shenzhen.aliyuncs.com/DataAnalysis/8.png" srcset="/img/loading.gif" alt="png"></p><p>还是数学上的解释，<strong>唯有当</strong>我们的划分$U/C = U/D$即条件划分与决策划分相等时，这时就存在寻优后的“最小”集了，而且是唯一的，<strong>除此之外</strong>，都有可能出现多条路径多种划分方式，而且不同路径上的划分状态一般是不可比的（除非是“分叉”路径，后面会举例），如下面$U/C_{23}$和$U/C_{12}$就不具备可比性。</p><p>还有一些其他性质，比如我们发现的$x_4,x_5,x_7$决策值相等，我们实际上时可以证明的。当两个极小划分满足下列情况时有相关结论：</p><ul><li>划分$U/C_p$有如下元素$\{ x_i,x_k , \cdots \}$</li><li>划分$U/C_q$有如下元素$\{ x_i,x_l , \cdots \}$</li><li>则可证$x_i[d] = x_k[d] = x_l[d]$ ，其中$[d]$表示元素对应的决策值。</li></ul><p>证明：可用上述上界证明，由于$U/D$的存在，而$U/C_p \le U/D$，$U/C_q \le U/D$，则$U/D$中必存在一集合$A$，满足$x_i,x_k,x_l \in A$，因而三者的决策值相等。</p><h2 id="Q3-寻优路径相关"><a href="#Q3-寻优路径相关" class="headerlink" title="Q3 寻优路径相关"></a>Q3 寻优路径相关</h2><p>根据前述，我已经解释过，我们<strong>一次约简并不对应 Hasse</strong>图中的一条短边，而可能是多条边的集合，上面的手绘图已经给出了，从根节点到原属性划分时的跳跃情况。</p><p>这里，我关心的心问题是，对于$Road_1$来说，由偏序关系，当我确定我一条路径的最终状态$U/C_{13}$，这个划分后，易知其必定被其他$U/C_p$细分，$C_p$满足$C_p \subseteq C_{13},C_{13} = \{a_2,a_3\}$ ，而与我去掉属性的先后顺序无关，简言之，对于我们实验的这个表，实际上还有很多路径，现在尝试手绘描述以下。</p><p><img src="https://eddyblog.oss-cn-shenzhen.aliyuncs.com/DataAnalysis/9.png" srcset="/img/loading.gif" alt="png"></p><p>绿色框特殊标注，因其在后面可以产生到两个极小的状态。</p><p>这也实验直观感受了，即便我们的寻优是多条 Hasse 图边的组合，其路径依然在最终状态确定后反推时具备多样性。</p>]]></content>
    
    
    <categories>
      
      <category>Computer Science</category>
      
      <category>数据分析与融合</category>
      
    </categories>
    
    
    <tags>
      
      <tag>数据分析与融合</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>人机交互——中南大学计算机学院主页Web交互设计文档</title>
    <link href="/post/a793738.html"/>
    <url>/post/a793738.html</url>
    
    <content type="html"><![CDATA[<h1 id="全局说明"><a href="#全局说明" class="headerlink" title="全局说明"></a>全局说明</h1><h2 id="权限说明"><a href="#权限说明" class="headerlink" title="权限说明"></a>权限说明</h2><h3 id="访问权限"><a href="#访问权限" class="headerlink" title="访问权限"></a>访问权限</h3><p>由指定 URL 均可访问本网站。</p><p>访问者均以游客身份访问，主页上没有“登录”或注册等功能引导，主要以学院内容展示为主。</p><h2 id="交互说明"><a href="#交互说明" class="headerlink" title="交互说明"></a>交互说明</h2><h3 id="键盘交互"><a href="#键盘交互" class="headerlink" title="键盘交互"></a>键盘交互</h3><p>针对 PC 端和 iPad（平板电脑）设备端，进行内容搜索时不上浮出底部的字母键盘，而是直接交由键盘进行交互。</p><h3 id="页面交互"><a href="#页面交互" class="headerlink" title="页面交互"></a>页面交互</h3><ul><li><strong>图标</strong>：通过点击指定图标显示下拉菜单、唤醒弹窗或实现页面跳转。</li><li><strong>图片</strong>：概览界面图片点击会进入对应的详情界面，详情界面图片不再设计其他交互细节。</li><li><strong>文字</strong>：概览界面文字标题点击会进入对应的详情界面，文字导航也同样实现该效果，对应页面内的正文不再设计其他交互细节。</li></ul><h2 id="其他机制与规则"><a href="#其他机制与规则" class="headerlink" title="其他机制与规则"></a>其他机制与规则</h2><h3 id="排序规则"><a href="#排序规则" class="headerlink" title="排序规则"></a>排序规则</h3><p>通知按发布的时间先后顺序，降序排列展示</p><h3 id="搜索规则"><a href="#搜索规则" class="headerlink" title="搜索规则"></a>搜索规则</h3><p>搜索结果按匹配度和相关度综合排序，降序排列展示</p><h1 id="页面功能详细说明"><a href="#页面功能详细说明" class="headerlink" title="页面功能详细说明"></a>页面功能详细说明</h1><h2 id="主页"><a href="#主页" class="headerlink" title="主页"></a>主页</h2><p>颜色：#0d5690</p><ul><li><p>校徽院徽</p><p>校徽院徽部分设计保持不变，并保持整体底色为中南蓝。</p></li><li><p>导航按钮</p><p>增加按钮样式，触发导航栏时更改其图标样式。</p></li><li><p>导航栏</p><p>移动端导航栏参考清华大学、北京大学、上海交通大学移动端主页的设计，发现导航栏动态隐藏、显示的模式常会出现以下问题：</p><ul><li><p>布局与便捷性冲突</p><p>点击导航按钮后触发弹出的数个菜单栏，对于一般学院网站，导航栏栏数并不少，这样就导致了，导航栏使用便捷性与保护原有页面布局两难问题的出现。以中南大学计算机学院现有移动端主页和北京大学现有移动端主页为例：</p><p>点击导航栏图标后，中南计算机院采取的策略是从顶栏（包含校徽院徽）下面插入多条导航栏目，每一条所占空间为一行。保证了一定的便捷性（不同栏目不大会误触），但是不得已把所有主体内容推到下方，略微给人一种“脖子长”的感受，难以保证原有的布局风格与内容。</p><p>北大的策略类似，只是整体的导航部分都抬到了头部，且每个导航项目不再占完整一行，而是三个占据一行，牺牲了一定的便捷性（栏目更加聚集，误触易，区分难），虽然还是可以展示一些主体内容，布局还是受到了一定程度的影响，给人一种“顶部重压”的感觉。</p><p>个人觉得清华的移动端</p></li></ul></li><li><p>滚动图片</p></li></ul><ul><li>新闻烂</li><li>通知公告分栏</li><li>学术信息分栏</li><li>科研动态分栏</li><li>学工动态分栏</li><li>备案联系栏</li></ul>]]></content>
    
    
    <categories>
      
      <category>Computer Science</category>
      
      <category>人机交互</category>
      
    </categories>
    
    
    <tags>
      
      <tag>人机交互</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>数字图像处理——理想滤波器与振铃特性</title>
    <link href="/post/430a4378.html"/>
    <url>/post/430a4378.html</url>
    
    <content type="html"><![CDATA[<h1 id="理想滤波器"><a href="#理想滤波器" class="headerlink" title="理想滤波器"></a>理想滤波器</h1><p>频率域平滑锐化常用的几个滤波器的数学表达和实现都已经在<a href="https://www.edwardzcn98yx.com/post/e371c683.html">数字图像处理——频率域平滑锐化图像常用滤波器</a>一文中实现。</p><p>之前我们讨论到了振铃现象，本文中的实验主要是动手实现测试了 ILPF 对图片的模糊效果及其振铃现象，并且跟随课本尝试解释 ILPF 在空间域的振铃特性。</p><h2 id="理想低通滤波器-ILPF"><a href="#理想低通滤波器-ILPF" class="headerlink" title="理想低通滤波器 ILPF"></a>理想低通滤波器 ILPF</h2><p>描述如下</p><script type="math/tex; mode=display">H_{ILPF}(u,v) = \left \{\begin{aligned}1, & D(u,v) \le D_0 \\0, & D(u,b) > D_0\end{aligned}\right.</script><p>其中$D_0$是一个正常数，$D(u,v)$表示频率域中的点$(u,v)$距离频率域中心$(\frac{P}{2},\frac{Q}{2})$的距离。</p><h2 id="理想高通滤波器-IHPF"><a href="#理想高通滤波器-IHPF" class="headerlink" title="理想高通滤波器 IHPF"></a>理想高通滤波器 IHPF</h2><p>描述如下</p><script type="math/tex; mode=display">H_{IHPF}(u,v) = \left \{\begin{aligned}0, & D(u,v) \le D_0 \\1, & D(u,b) > D_0\end{aligned}\right.</script><h2 id="代码实现"><a href="#代码实现" class="headerlink" title="代码实现"></a>代码实现</h2><p>代码实现<code>getIdealMask()</code>也在<a href="https://www.edwardzcn98yx.com/post/e371c683.html">数字图像处理——频率域平滑锐化图像常用滤波器</a>给出，在此不再转述。</p><p>两组测试均为 100x100 大小，截至半径为 20 的低通和高通滤波器实验结果。</p><p><img src="https://eddyblog.oss-cn-shenzhen.aliyuncs.com/ImageProcess/TypeOfFilter/3.png" srcset="/img/loading.gif" alt="png"></p><p><img src="https://eddyblog.oss-cn-shenzhen.aliyuncs.com/ImageProcess/TypeOfFilter/4.png" srcset="/img/loading.gif" alt="png"></p><h2 id="使用一个-ILPF-平滑图像"><a href="#使用一个-ILPF-平滑图像" class="headerlink" title="使用一个 ILPF 平滑图像"></a>使用一个 ILPF 平滑图像</h2><pre><code class="hljs python"><span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">getIdealFilterPassImg</span><span class="hljs-params">(input_img : np.array, filter_type : str , filter_d0, size = None)</span>:</span>    <span class="hljs-keyword">assert</span> filter_type <span class="hljs-keyword">in</span> (<span class="hljs-string">"lpf"</span>,<span class="hljs-string">"hpf"</span>)    <span class="hljs-comment"># 内部进行填充 （mask大小与原图相等 进行2K-1的0填充）</span>    pad_img = getPaddingImg(input_img,input_img.shape,<span class="hljs-string">"corner"</span>)    f_img = np.fft.fft2(input_img , s = size)    shift_img = np.fft.fftshift(f_img)    mask_shift_img = getIdealMask(f_img.shape,filter_d0,filter_type)    new_shift_img = mask_shift_img*shift_img    new_manitude_img = <span class="hljs-number">20</span>*np.log(np.abs(new_shift_img+eps))    new_f_img = np.fft.ifftshift(new_shift_img)    new_img = np.fft.ifft2(new_f_img)    new_img = np.abs(new_img)    <span class="hljs-comment"># 内部进行裁剪</span>    new_img = cutOriginalImg(new_img, input_img.shape, <span class="hljs-string">"corner"</span>)    <span class="hljs-keyword">return</span> new_img,new_manitude_img,mask_shift_img<span class="hljs-comment"># 使用书上例子，cv库读取图像</span>original_img = cv2.imread(<span class="hljs-string">'./DIP3E_Original_Images_CH04/Fig0441(a)(characters_test_pattern).tif'</span>,<span class="hljs-number">0</span>)<span class="hljs-comment"># 设定截止半径</span>d_list = [<span class="hljs-number">10</span>,<span class="hljs-number">30</span>,<span class="hljs-number">60</span>,<span class="hljs-number">160</span>,<span class="hljs-number">460</span>]<span class="hljs-keyword">for</span> d <span class="hljs-keyword">in</span> d_list:    smmoth_img,manitude_img,mask_img = getIdealFilterPassImg(original_img, <span class="hljs-string">"lpf"</span> , d)    showTwoImg(smmoth_img,manitude_img,<span class="hljs-string">f"Smooth Img with $D_0$ = <span class="hljs-subst">&#123;d&#125;</span>"</span>, <span class="hljs-string">f"Manitude with $D_0$ = <span class="hljs-subst">&#123;d&#125;</span>"</span>)</code></pre><p><img src="https://eddyblog.oss-cn-shenzhen.aliyuncs.com/ImageProcess/IdealFilter/1.png" srcset="/img/loading.gif" alt="png"></p><a id="more"></a><p><img src="https://eddyblog.oss-cn-shenzhen.aliyuncs.com/ImageProcess/IdealFilter/2.png" srcset="/img/loading.gif" alt="png"></p><p><img src="https://eddyblog.oss-cn-shenzhen.aliyuncs.com/ImageProcess/IdealFilter/3.png" srcset="/img/loading.gif" alt="png"></p><p><img src="https://eddyblog.oss-cn-shenzhen.aliyuncs.com/ImageProcess/IdealFilter/4.png" srcset="/img/loading.gif" alt="png"></p><p><img src="https://eddyblog.oss-cn-shenzhen.aliyuncs.com/ImageProcess/IdealFilter/5.png" srcset="/img/loading.gif" alt="png"></p><h1 id="振铃现象"><a href="#振铃现象" class="headerlink" title="振铃现象"></a>振铃现象</h1><p>由上图可以看出随着阈值增大，频谱中保留功率的增大，图像细节逐渐明晰，模糊效果越来越差。这说明我们的滤波器是成功的（不过这里与课本 P171 图比较会清晰一些，不清楚原因）</p><p>另外，我们也可以很明显的发现<strong>振铃现象</strong>，间隙处原本统一的纹理由于模糊变得有明暗起伏。而随着被滤去的高频内容的数量的减少，图像的纹理变得越来越好，甚至我们仔细看第三幅图，也能发现振铃现象的纹理，课本是这么评价振铃现象和 ILPF 的。</p><blockquote><p>这种振铃现象是理想滤波器的一种特性，从这个例子我们可以清楚地看到，理想低通滤波器并不是非常实用。然而，作为滤波概念发展的一部分，研究这种滤波器的特性非常有用。</p></blockquote><h2 id="振铃现象的一些见解"><a href="#振铃现象的一些见解" class="headerlink" title="振铃现象的一些见解"></a>振铃现象的一些见解</h2><pre><code class="hljs python"><span class="hljs-comment"># 绘制空间域表示图和水平线灰度剖面图</span><span class="hljs-keyword">for</span> d <span class="hljs-keyword">in</span> d_list:    fre_mask=getIdealMask((<span class="hljs-number">688</span>,<span class="hljs-number">688</span>),d,<span class="hljs-string">"lpf"</span>)    spa_mask=frequencyToSpatial(fre_mask)    X = [i <span class="hljs-keyword">for</span> i <span class="hljs-keyword">in</span> range(spa_mask.shape[<span class="hljs-number">0</span>])]    Y = spa_mask[spa_mask.shape[<span class="hljs-number">0</span>]//<span class="hljs-number">2</span>]    plt.figure(figsize=(<span class="hljs-number">8</span>,<span class="hljs-number">4</span>))    ax1 = plt.subplot(<span class="hljs-number">121</span>)    ax2 = plt.subplot(<span class="hljs-number">122</span>)    ax1.set_title(<span class="hljs-string">f"Spatial Img with $D_0 = <span class="hljs-subst">&#123;d&#125;</span>$"</span>)    ax2.set_title(<span class="hljs-string">f"Grayscale with $D_0 = <span class="hljs-subst">&#123;d&#125;</span>$"</span>)    ax1.imshow(spa_mask,cmap = <span class="hljs-string">"gray"</span>)    ax2.plot(X,Y)    ax2.spines[<span class="hljs-string">'left'</span>].set_color(<span class="hljs-string">'none'</span>)    ax2.spines[<span class="hljs-string">'top'</span>].set_color(<span class="hljs-string">'none'</span>)    ax2.spines[<span class="hljs-string">'right'</span>].set_color(<span class="hljs-string">'none'</span>)    ax2.set_yticks([])    ax2.set_yticklabels([])</code></pre><p><img src="https://eddyblog.oss-cn-shenzhen.aliyuncs.com/ImageProcess/IdealFilter/6.png" srcset="/img/loading.gif" alt="png"></p><p><img src="https://eddyblog.oss-cn-shenzhen.aliyuncs.com/ImageProcess/IdealFilter/7.png" srcset="/img/loading.gif" alt="png"></p><p><img src="https://eddyblog.oss-cn-shenzhen.aliyuncs.com/ImageProcess/IdealFilter/8.png" srcset="/img/loading.gif" alt="png"></p><p><img src="https://eddyblog.oss-cn-shenzhen.aliyuncs.com/ImageProcess/IdealFilter/9.png" srcset="/img/loading.gif" alt="png"></p><p><img src="https://eddyblog.oss-cn-shenzhen.aliyuncs.com/ImageProcess/IdealFilter/10.png" srcset="/img/loading.gif" alt="png"></p><p>分别对应了上面的阈值，观察其滤波器的空间与表示，在$D_0$较小的时候有很明显的波动函数形状。</p><blockquote><p>ILPF 的模糊和振铃特性可用卷积定理来解释。由于 ILPF 在频率域的剖面图类似于盒状滤波器，因此可以预料相应空间滤波器具有 sinc 函数形状。空间域滤波可通过$h(x,y)$于图像卷积来实现。讲图像中的每个像素想象为一个离散冲击，它的强度与所在位置的灰度成正比。一个 sinc 函数与一个冲激卷积就是在冲激处复制这个 sinc 函数。<strong>sinc 函数的中心波瓣是引起模糊的主因，而外侧较小的波瓣是造成振铃的主要原因。sinc 函数“展开度”与$H(u,v)$半径成反比，所以$D_0$越大，空间 sinc 函数就趋近于一个卷积时不会导致模糊但也不会产生振铃的冲激</strong></p></blockquote>]]></content>
    
    
    <categories>
      
      <category>Computer Science</category>
      
      <category>数字图像处理</category>
      
    </categories>
    
    
    <tags>
      
      <tag>数字图像处理</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>数字图像处理——高斯滤波器与零填充避免DFT固有周期性影响</title>
    <link href="/post/d140a694.html"/>
    <url>/post/d140a694.html</url>
    
    <content type="html"><![CDATA[<p>2019.10.24 更新，与<a href="https://www.edwardzcn98yx.com/post/e371c683.html">数字图像处理——频率域平滑锐化图像常用滤波器</a>中滤波器公式保持一致，并更新填充函数的写法。</p><h1 id="高斯滤波"><a href="#高斯滤波" class="headerlink" title="高斯滤波"></a>高斯滤波</h1><h2 id="高斯高通滤波-GaussianHPF"><a href="#高斯高通滤波-GaussianHPF" class="headerlink" title="高斯高通滤波 GaussianHPF"></a>高斯高通滤波 GaussianHPF</h2><p>频率域高斯高通滤波公式如下，注意公式$D$和$D_0$的区别</p><script type="math/tex; mode=display">H(u,v) = 1-e^{\dfrac{-D^2(u,v)}{2D_0^2}}</script><h2 id="高斯低通滤波-GaussianLPF"><a href="#高斯低通滤波-GaussianLPF" class="headerlink" title="高斯低通滤波 GaussianLPF"></a>高斯低通滤波 GaussianLPF</h2><p>频率域高斯低通滤波公式如下</p><script type="math/tex; mode=display">H(u,v) = e^{\dfrac{-D^2(u,v)}{2D_0^2}}</script><pre><code class="hljs python"><span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">getGaussianMask</span><span class="hljs-params">(mask_shape,filter_d0,hl_type)</span>:</span>    <span class="hljs-keyword">assert</span> hl_type <span class="hljs-keyword">in</span> (<span class="hljs-string">"lpf"</span>,<span class="hljs-string">"hpf"</span>)    rows,cols = mask_shape[<span class="hljs-number">0</span>],mask_shape[<span class="hljs-number">1</span>]    crow = rows/<span class="hljs-number">2</span>    ccol = cols/<span class="hljs-number">2</span>    mask = np.zeros((rows,cols))    <span class="hljs-keyword">for</span> i <span class="hljs-keyword">in</span> range(rows):        <span class="hljs-keyword">for</span> j <span class="hljs-keyword">in</span> range(cols):            dis = sqrt((i-crow)**<span class="hljs-number">2</span> + (j-ccol)**<span class="hljs-number">2</span>)            <span class="hljs-keyword">if</span> hl_type == <span class="hljs-string">"hpf"</span>:                mask[i,j] = <span class="hljs-number">1</span>-np.exp(-(dis**<span class="hljs-number">2</span>) / (<span class="hljs-number">2</span>*(filter_d0**<span class="hljs-number">2</span>)))            <span class="hljs-keyword">elif</span> hl_type == <span class="hljs-string">"lpf"</span>:                mask[i,j] = np.exp(-(dis**<span class="hljs-number">2</span>)/(<span class="hljs-number">2</span>*(filter_d0**<span class="hljs-number">2</span>)))    <span class="hljs-keyword">return</span> mask<span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">getGaussianFilterPassImg</span><span class="hljs-params">(input_img : np.array, filter_type : str , filter_d0  , size = None)</span>:</span>    <span class="hljs-keyword">assert</span> filter_type <span class="hljs-keyword">in</span> (<span class="hljs-string">"lpf"</span>,<span class="hljs-string">"hpf"</span>)    f_img = np.fft.fft2(input_img , s = size)    shift_img = np.fft.fftshift(f_img)    mask_shift_img = getGaussianMask(f_img.shape,filter_d0,filter_type)    new_shift_img = mask_shift_img*shift_img    new_manitude_img = <span class="hljs-number">20</span>*np.log(np.abs(new_shift_img+eps))    new_f_img = np.fft.ifftshift(new_shift_img)    new_img = np.fft.ifft2(new_f_img)    new_img = np.abs(new_img)    <span class="hljs-keyword">return</span> new_img,new_manitude_img,mask_shift_img</code></pre><h1 id="DFT-固有周期影响"><a href="#DFT-固有周期影响" class="headerlink" title="DFT 固有周期影响"></a>DFT 固有周期影响</h1><p>实现方法，由于 numpy.fft.fft2 方法参数中可以指定输出图像的大小，官方描述如下：</p><blockquote><p>s : sequence of ints, optional</p><p>_Shape (length of each transformed axis) of the output (s[0] refers to axis 0, s[1] to axis 1, etc.). This corresponds to n for fft(x, n). Along each axis, if the given shape is smaller than that of the input, the input is cropped. If it is larger, the input is padded with zeros. if s is not given, the shape of the input along the axes specified by axes is used._</p></blockquote><p>该参数默认为 DFT 变换后大小为原图大小，若指定输出大小大于原图大小，则进行 0 填充，我们可以利用该参数实现我们的测试。</p><h2 id="不经填充裁剪"><a href="#不经填充裁剪" class="headerlink" title="不经填充裁剪"></a>不经填充裁剪</h2><p>直接以 s 的默认值（None）调用 numpy.fft.fft2 实际上就是进行的非 0 填充</p><p>调用我之前写的方法，实现如下</p><pre><code class="hljs python">lpf_cycle_img, manitude_cycle_img,mask_img = getGaussianFilterPassImg(cycle_img , <span class="hljs-string">"lpf"</span> , <span class="hljs-number">5</span> )</code></pre><p>或者如下</p><pre><code class="hljs python">lpf_cycle_img, manitude_cycle_img,mask_img = getGaussianFilterPassImg(cycle_img , <span class="hljs-string">"lpf"</span> , <span class="hljs-number">5</span> ,size = <span class="hljs-keyword">None</span>)</code></pre><h2 id="进行填充裁剪"><a href="#进行填充裁剪" class="headerlink" title="进行填充裁剪"></a>进行填充裁剪</h2><p>根据教材 P157 解释以及 P159、P163 页，二维零填充避免缠绕错误的结论与一维相同，令$f(x)$和$h(x)$分别是大小为$A \times B$和$C \times D$像素的图像阵列。循环卷积中的缠绕错误可以通过下面函数进行零填充来避免，方法如下：</p><script type="math/tex; mode=display">f_p(x,y)=\left \{\begin{aligned}f(x,y)  & , &  0 \le x \le A-1 和  0 \le y\le B-1 \\0 & , & A \le x \le P 或 B \le y \le Q\end{aligned}\right.</script><p>和</p><script type="math/tex; mode=display">h_p(x,y)=\left \{\begin{aligned}h(x,y) & , & 0 \le x \le C-1 和 0 \le y\le D-1 \\0 & , & C \le x \le P 或 D \le y \le Q\end{aligned}\right.</script><p>其中，</p><script type="math/tex; mode=display">P \ge A+C -1</script><p>和</p><script type="math/tex; mode=display">Q \ge B+D-1</script><p>那么实现方法就有两种：</p><ol><li>通过其他方法进行补 0 后调用 s 为 None 的 DFT</li><li>通过调整 s 为(P,Q)大小调用 DFT</li></ol><a id="more"></a><p>填充的代码实现：</p><pre><code class="hljs python"><span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">getPaddingSize</span><span class="hljs-params">(shape1,shape2)</span>:</span>    <span class="hljs-keyword">return</span> shape1[<span class="hljs-number">0</span>]+shape2[<span class="hljs-number">0</span>]<span class="hljs-number">-1</span>,shape1[<span class="hljs-number">1</span>]+shape2[<span class="hljs-number">1</span>]<span class="hljs-number">-1</span><span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">getPaddingImg</span><span class="hljs-params">(fimg,himg_shape, position = <span class="hljs-string">"corner"</span>)</span>:</span>    fimg = np.array(fimg)    himg = np.array(himg_shape)    <span class="hljs-keyword">assert</span> position <span class="hljs-keyword">in</span> (<span class="hljs-string">"corner"</span>,<span class="hljs-string">"middle"</span>)    fimg = np.array(fimg)    rows,cols = fimg.shape    prows,pcols = getPaddingSize(fimg.shape,himg_shape)    <span class="hljs-keyword">if</span> position == <span class="hljs-string">"corner"</span>:        new_img = np.pad(fimg,((<span class="hljs-number">0</span>,prows-rows),(<span class="hljs-number">0</span>,pcols-cols)),<span class="hljs-string">'constant'</span>, constant_values = <span class="hljs-number">0</span>)    <span class="hljs-keyword">else</span>:        cal = <span class="hljs-keyword">lambda</span> x,y: ((x-y)//<span class="hljs-number">2</span> , x-y-(x-y)//<span class="hljs-number">2</span>)        new_img = np.pad(fimg,(cal(prows,rows),cal(pcols,cols)),<span class="hljs-string">'constant'</span>, constant_values = <span class="hljs-number">0</span>)    <span class="hljs-keyword">return</span> new_img<span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">cutOriginalImg</span><span class="hljs-params">(pad_img,originalsize,position = <span class="hljs-string">"corner"</span>)</span>:</span>    <span class="hljs-keyword">assert</span> position <span class="hljs-keyword">in</span> (<span class="hljs-string">"corner"</span>,<span class="hljs-string">"middle"</span>)    <span class="hljs-keyword">if</span>(position == <span class="hljs-string">"corner"</span>):        <span class="hljs-keyword">return</span> pad_img[<span class="hljs-number">0</span>:originalsize[<span class="hljs-number">0</span>],<span class="hljs-number">0</span>:originalsize[<span class="hljs-number">1</span>]]    <span class="hljs-keyword">else</span>:        padsizer = pad_img.shape[<span class="hljs-number">0</span>]-originalsize[<span class="hljs-number">0</span>]        padsizec = pad_img.shape[<span class="hljs-number">1</span>]-originalsize[<span class="hljs-number">1</span>]        <span class="hljs-keyword">return</span> pad_img[padsizer//<span class="hljs-number">2</span>:padsizer//<span class="hljs-number">2</span>+originalsize[<span class="hljs-number">0</span>],padsizec//<span class="hljs-number">2</span>:padsizec//<span class="hljs-number">2</span>+originalsize[<span class="hljs-number">1</span>]]</code></pre><pre><code class="hljs python">cycle_img = cv2.imread(<span class="hljs-string">'./DIP3E_Original_Images_CH04/Fig0432(a)(square_original).tif'</span>,<span class="hljs-number">0</span>)cycle_img_corner = getPaddingImg(cycle_img,(<span class="hljs-number">1000</span>,<span class="hljs-number">1000</span>),position = <span class="hljs-string">"corner"</span>)cycle_img_middle = getPaddingImg(cycle_img,(<span class="hljs-number">1000</span>,<span class="hljs-number">1000</span>),position = <span class="hljs-string">"middle"</span>)plt.figure(figsize=(<span class="hljs-number">12</span>,<span class="hljs-number">8</span>))ax1 = plt.subplot(<span class="hljs-number">131</span>)ax1.imshow(cycle_img, cmap = <span class="hljs-string">"gray"</span>)ax1.set_title(<span class="hljs-string">"Original Test Img"</span>)ax2 = plt.subplot(<span class="hljs-number">132</span>)ax2.imshow(cycle_img_corner, cmap = <span class="hljs-string">"gray"</span>)ax2.set_title(<span class="hljs-string">"After Padding Img (Corner)"</span>)ax3 = plt.subplot(<span class="hljs-number">133</span>)ax3.imshow(cycle_img_middle, cmap = <span class="hljs-string">"gray"</span> )ax3.set_title(<span class="hljs-string">"After Padding Img (Middle)"</span>)plt.show()</code></pre><p><img src="https://eddyblog.oss-cn-shenzhen.aliyuncs.com/ImageProcess/GaussianFilterAndDFTCycle/1.png" srcset="/img/loading.gif" alt="png"></p><pre><code class="hljs python"><span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">showThreeImg</span><span class="hljs-params">(img1,img2,img3,img_name1 = None,img_name2 = None,img_name3 = None)</span>:</span>    plt.figure(figsize=(<span class="hljs-number">12</span>,<span class="hljs-number">4</span>))    ax1 = plt.subplot(<span class="hljs-number">131</span>)    ax1.set_title(img_name1)    ax1.imshow(img1  , cmap = <span class="hljs-string">"gray"</span>)    ax2 = plt.subplot(<span class="hljs-number">132</span>)    ax2.imshow(img2, cmap = <span class="hljs-string">"gray"</span>)    ax2.set_title(img_name2)    ax3 = plt.subplot(<span class="hljs-number">133</span>)    ax3.imshow(img3,cmap = <span class="hljs-string">"gray"</span>)    ax3.set_title(img_name3)    plt.show()mfilter_size = <span class="hljs-number">8</span><span class="hljs-comment"># 先构建mask</span><span class="hljs-comment"># 尝试方法零（不填充）</span><span class="hljs-comment"># 通过自编写方法补零后再进行DFT加高斯低通滤波</span>lpf_cycle_img_nopadding, manitude_cycle_img,mask_img = getGaussianFilterPassImg(cycle_img , <span class="hljs-string">"lpf"</span> , mfilter_size)showThreeImg(lpf_cycle_img_nopadding,manitude_cycle_img,mask_img,<span class="hljs-string">"Original Img Without Padding"</span>,<span class="hljs-string">"Manitude"</span>,<span class="hljs-string">"Mask"</span>)<span class="hljs-comment"># 尝试方法1 （预填充）</span><span class="hljs-comment">## Corner</span>pad_cycle_img_corner = getPaddingImg(cycle_img,(mfilter_size,mfilter_size),<span class="hljs-string">"corner"</span>)lpf_cycle_img_padcorner_m1, manitude_cycle_img,mask_img = getGaussianFilterPassImg(pad_cycle_img_corner , <span class="hljs-string">"lpf"</span> , mfilter_size)cut_lpf_cycle_img_padcorner_m1 = cutOriginalImg(lpf_cycle_img_padcorner_m1,cycle_img.shape,<span class="hljs-string">"corner"</span>)showThreeImg(cut_lpf_cycle_img_padcorner_m1,manitude_cycle_img,mask_img,<span class="hljs-string">"Corner Padding Method 1 (After Cut)"</span>,<span class="hljs-string">"Manitude (No Cut)"</span>,<span class="hljs-string">"Mask (No Cut)"</span>)<span class="hljs-comment">## Middle</span>pad_cycle_img_middle = getPaddingImg(cycle_img,(mfilter_size,mfilter_size),<span class="hljs-string">"middle"</span>)lpf_cycle_img_padmiddle_m1, manitude_cycle_img,mask_img = getGaussianFilterPassImg(pad_cycle_img_middle , <span class="hljs-string">"lpf"</span> , mfilter_size)cut_lpf_cycle_img_padmiddle_m1 = cutOriginalImg(lpf_cycle_img_padmiddle_m1,cycle_img.shape,<span class="hljs-string">"middle"</span>)showThreeImg(cut_lpf_cycle_img_padmiddle_m1,manitude_cycle_img,mask_img,<span class="hljs-string">"Middle Padding Method 1 (After Cut)"</span>,<span class="hljs-string">"Manitude (No Cut)"</span>,<span class="hljs-string">"Mask (No Cut)"</span>)<span class="hljs-comment"># 尝试方法2 （限定s自动零填充）</span><span class="hljs-comment">## 实现了相同的效果</span>lpf_cycle_img_padcorner_m2, manitude_cycle_img,mask_img = getGaussianFilterPassImg(cycle_img , <span class="hljs-string">"lpf"</span> , mfilter_size , size = getPaddingSize(cycle_img.shape,np.array([mfilter_size,mfilter_size])))cut_lpf_cycle_img_padcorner_m2 = cutOriginalImg(lpf_cycle_img_padcorner_m2,cycle_img.shape,<span class="hljs-string">"corner"</span>)showThreeImg(cut_lpf_cycle_img_padcorner_m2,manitude_cycle_img,mask_img,<span class="hljs-string">"Corner Padding Method 2 (After Cut)"</span>,<span class="hljs-string">"Manitude (No Cut)"</span>,<span class="hljs-string">"Mask (No Cut)"</span>)</code></pre><p><img src="https://eddyblog.oss-cn-shenzhen.aliyuncs.com/ImageProcess/GaussianFilterAndDFTCycle/2.png" srcset="/img/loading.gif" alt="png"></p><p><img src="https://eddyblog.oss-cn-shenzhen.aliyuncs.com/ImageProcess/GaussianFilterAndDFTCycle/3.png" srcset="/img/loading.gif" alt="png"></p><p><img src="https://eddyblog.oss-cn-shenzhen.aliyuncs.com/ImageProcess/GaussianFilterAndDFTCycle/4.png" srcset="/img/loading.gif" alt="png"></p><p><img src="https://eddyblog.oss-cn-shenzhen.aliyuncs.com/ImageProcess/GaussianFilterAndDFTCycle/5.png" srcset="/img/loading.gif" alt="png"></p><pre><code class="hljs python">print(lpf_cycle_img_padmiddle_m1.shape)print(cut_lpf_cycle_img_padmiddle_m1.shape)print(<span class="hljs-string">"Really Cut"</span>)print((cut_lpf_cycle_img_padcorner_m1==cut_lpf_cycle_img_padcorner_m2).all())print(<span class="hljs-string">"Method 2 has the same effect as Method 1 and generalize the same img."</span>)</code></pre><pre><code class="hljs python">(<span class="hljs-number">775</span>, <span class="hljs-number">775</span>)(<span class="hljs-number">768</span>, <span class="hljs-number">768</span>)Really Cut<span class="hljs-keyword">True</span>Method <span class="hljs-number">2</span> has the same effect <span class="hljs-keyword">as</span> Method <span class="hljs-number">1</span> <span class="hljs-keyword">and</span> generalize the same img.</code></pre><p>上述实验证明了 DFT 固有周期带来的一些影响，未进行零填充的 Original Img 由于固有周期亮色部分左右仍旧是亮色部分，所以使滤波器丧失了能力，在一些情况下我们希望避免这种固有周期带来的影响，因而才引入了零填充的方式。</p><p>正如课本 P163 以及 P164 所讲：</p><blockquote><p>用 0 填充图像后，在周期序列的周围建立了一个平坦的边界。</p><p>从这个例子可以看到，错误地填充一幅图像会导致错误的结果。</p></blockquote><p>当然，这种错误只存在于“ 边界”</p><blockquote><p>如果滤波的目的仅是粗糙的视觉分析，那么有时可以跳过填充步骤。</p></blockquote><p>根据两种方式 Padding 得到的最终裁减后图像的比较（All True），也证明了我使用的两种方法，Method 1：手动填充 0 金和 Method 2：利用<code>numpy.fft.fft2()</code>中自动 0 填充的方式确实都得到了相同的结果。</p>]]></content>
    
    
    <categories>
      
      <category>Computer Science</category>
      
      <category>数字图像处理</category>
      
    </categories>
    
    
    <tags>
      
      <tag>数字图像处理</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>数字图像处理——频率域平滑锐化图像常用滤波器</title>
    <link href="/post/e371c683.html"/>
    <url>/post/e371c683.html</url>
    
    <content type="html"><![CDATA[<h1 id="频率域滤波器"><a href="#频率域滤波器" class="headerlink" title="频率域滤波器"></a>频率域滤波器</h1><p>本文主要是动手实现一些常见的滤波器，并展示其频率域和空间域图像。</p><p>这里介绍的常见滤波器为：（高通/低通）理想滤波、布特沃斯滤波器和高斯滤波器，根据书本 P169 页，他们的区别与联系如下：</p><blockquote><p>这三种滤波器涵盖了从非常急剧（理想）的滤波到非常平滑（高斯）的滤波范围。布特沃斯滤波器有一个参数，它成为滤波器的“阶数”。当阶数较高时，布特沃斯滤波器接近于理想滤波器。对于较低的阶数值，布特沃斯滤波器更像高斯滤波器。这样，布特沃斯滤波器可视为两种“极端”滤波器的过渡。</p></blockquote><p>为了方便后续实验，对一些辅助代码模块化编写，主要以可视化部分为主，见文末附录部分。</p><h2 id="理想滤波器"><a href="#理想滤波器" class="headerlink" title="理想滤波器"></a>理想滤波器</h2><p>所谓”理想”是指无法通过硬件实现的硬截断</p><h3 id="理想低通滤波器-ILPF"><a href="#理想低通滤波器-ILPF" class="headerlink" title="理想低通滤波器 ILPF"></a>理想低通滤波器 ILPF</h3><p>在圆外“阻断”所有频率，而在圆内无衰减的通过所有频率，这种二维低通滤波器称为理想低通滤波器（ILPF），由下面的函数确定</p><script type="math/tex; mode=display">H_{ILPF}(u,v) = \left \{\begin{aligned}1, & D(u,v) \le D_0 \\0, & D(u,b) > D_0\end{aligned}\right.</script><p>其中$D_0$是一个正常数，$D(u,v)$表示频率域中的点$(u,v)$距离频率域中心$(\frac{P}{2},\frac{Q}{2})$的距离。</p><h3 id="理想高通滤波器-IHPF"><a href="#理想高通滤波器-IHPF" class="headerlink" title="理想高通滤波器 IHPF"></a>理想高通滤波器 IHPF</h3><p>与低通类似，高通是将阈值的圆内“阻断”所有频率，而在圆外无衰减的通过所有频率，描述如下</p><script type="math/tex; mode=display">H_{IHPF}(u,v) = \left \{\begin{aligned}0, & D(u,v) \le D_0 \\1, & D(u,b) > D_0\end{aligned}\right.</script><h3 id="代码实现"><a href="#代码实现" class="headerlink" title="代码实现"></a>代码实现</h3><p>代码实现低通滤波器并展示其频率域透视图、频率域图像显示、空间域图像显示和径向剖面图。</p><pre><code class="hljs python"><span class="hljs-comment"># 获得指定大小的理想滤波器</span><span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">getIdealMask</span><span class="hljs-params">(mask_shape, filter_d0,hl_type)</span>:</span>    <span class="hljs-keyword">assert</span> hl_type <span class="hljs-keyword">in</span> (<span class="hljs-string">"lpf"</span>,<span class="hljs-string">"hpf"</span>)    rows,cols = mask_shape[<span class="hljs-number">0</span>],mask_shape[<span class="hljs-number">1</span>]    crow = rows/<span class="hljs-number">2</span>    ccol = cols/<span class="hljs-number">2</span>    mask = np.zeros((rows,cols))    <span class="hljs-keyword">for</span> i <span class="hljs-keyword">in</span> range(rows):        <span class="hljs-keyword">for</span> j <span class="hljs-keyword">in</span> range(cols):            dis = sqrt((i-crow)**<span class="hljs-number">2</span> + (j-ccol)**<span class="hljs-number">2</span>)            <span class="hljs-keyword">if</span> hl_type == <span class="hljs-string">"lpf"</span>:                <span class="hljs-keyword">if</span> dis &lt;= filter_d0:                    mask[i,j] = <span class="hljs-number">1</span>                <span class="hljs-keyword">else</span>:                    mask[i,j] = <span class="hljs-number">0</span>            <span class="hljs-keyword">elif</span> hl_type == <span class="hljs-string">"hpf"</span>:                <span class="hljs-keyword">if</span> dis &lt;= filter_d0:                    mask[i,j] = <span class="hljs-number">0</span>                <span class="hljs-keyword">else</span>:                    mask[i,j] = <span class="hljs-number">1</span>    <span class="hljs-keyword">return</span> mask<span class="hljs-comment"># 测试ILPF</span><span class="hljs-comment"># 参数设置</span>mask_shape = (<span class="hljs-number">100</span>,<span class="hljs-number">100</span>)d = <span class="hljs-number">20</span>filter_type = <span class="hljs-string">"lpf"</span><span class="hljs-comment"># 获得滤波器</span>myfilter = getIdealMask(mask_shape,d,filter_type)<span class="hljs-comment"># 绘图</span>plt.figure(figsize=(<span class="hljs-number">12</span>,<span class="hljs-number">12</span>))ax1=plt.subplot(<span class="hljs-number">221</span>,projection = <span class="hljs-string">"3d"</span>)ax2=plt.subplot(<span class="hljs-number">222</span>)ax3=plt.subplot(<span class="hljs-number">223</span>)ax4=plt.subplot(<span class="hljs-number">224</span>)drawPerspective(ax1,myfilter,title = <span class="hljs-string">"ILPF Perspective Axes3D"</span>, cmap = <span class="hljs-string">"gray"</span>)<span class="hljs-comment"># 不想进行列表解析,需要调用frompyfunc构建np可以用的分段函数</span>ufunc1 = np.frompyfunc(<span class="hljs-keyword">lambda</span> x: <span class="hljs-number">0</span> <span class="hljs-keyword">if</span> (x-d)&gt;<span class="hljs-number">0</span> <span class="hljs-keyword">else</span> <span class="hljs-number">1</span>, <span class="hljs-number">1</span>, <span class="hljs-number">1</span>)drawCurv(ax2,[ufunc1],[<span class="hljs-string">"ILPF"</span>],d,title = <span class="hljs-string">"ILPF Curv"</span>)drawPanel(ax3,myfilter,title = <span class="hljs-string">"ILPF Frequency Panel Axes2D"</span>)spatial_myfilter = frequencyToSpatial(myfilter)drawPanel(ax4,spatial_myfilter,title = <span class="hljs-string">"ILPF Spatial Panel Axes2D"</span>)plt.show()<span class="hljs-comment"># 测试IHPF</span>d = <span class="hljs-number">20</span>filter_type = <span class="hljs-string">"hpf"</span>myfilter = getIdealMask(mask_shape,d,filter_type)plt.figure(figsize=(<span class="hljs-number">12</span>,<span class="hljs-number">12</span>))ax1=plt.subplot(<span class="hljs-number">221</span>,projection = <span class="hljs-string">"3d"</span>)ax2=plt.subplot(<span class="hljs-number">222</span>)ax3=plt.subplot(<span class="hljs-number">223</span>)ax4=plt.subplot(<span class="hljs-number">224</span>)drawPerspective(ax1,myfilter,title = <span class="hljs-string">"IHPF Perspective Axes3D"</span>, cmap = <span class="hljs-string">"gray"</span>)<span class="hljs-comment"># 不想进行列表解析,需要调用frompyfunc构建np可以用的分段函数</span>ufunc1 = np.frompyfunc(<span class="hljs-keyword">lambda</span> x: <span class="hljs-number">1</span> <span class="hljs-keyword">if</span> (x-d)&gt;<span class="hljs-number">0</span> <span class="hljs-keyword">else</span> <span class="hljs-number">0</span>, <span class="hljs-number">1</span>, <span class="hljs-number">1</span>)drawCurv(ax2,[ufunc1],[<span class="hljs-string">"IHPF"</span>],d,title = <span class="hljs-string">"Curv"</span>)drawPanel(ax3,myfilter,title = <span class="hljs-string">"IHPF Frequency Panel Axes2D"</span>)spatial_myfilter = frequencyToSpatial(myfilter)drawPanel(ax4,spatial_myfilter,title = <span class="hljs-string">"IHPF Spatial Panel Axes2D"</span>)plt.show()</code></pre><p>理想低通 ILPF 结果四图</p><p><img src="https://eddyblog.oss-cn-shenzhen.aliyuncs.com/ImageProcess/TypeOfFilter/3.png" srcset="/img/loading.gif" alt="png"></p><p>理想高通 IHPF 结果四图</p><p><img src="https://eddyblog.oss-cn-shenzhen.aliyuncs.com/ImageProcess/TypeOfFilter/4.png" srcset="/img/loading.gif" alt="png"></p><h2 id="布特沃斯滤波器"><a href="#布特沃斯滤波器" class="headerlink" title="布特沃斯滤波器"></a>布特沃斯滤波器</h2><p>可通过硬件实现，可以通过阶数进行控制，一些资料中又称之为“巴特沃斯滤波器”。</p><h3 id="布特沃斯低通滤波器-BLPF"><a href="#布特沃斯低通滤波器-BLPF" class="headerlink" title="布特沃斯低通滤波器 BLPF"></a>布特沃斯低通滤波器 BLPF</h3><p>截止频率位于距原点$D_0$的$n$阶布特沃斯滤波器（BLPF）的传递函数定义为：</p><script type="math/tex; mode=display">H_{BLPF}(u,v) = \dfrac{1}{ 1 + {[ \dfrac {D(u,v)}{D_0} ]}^{2n} }</script><h3 id="布特沃斯高通滤波器-BHPF"><a href="#布特沃斯高通滤波器-BHPF" class="headerlink" title="布特沃斯高通滤波器 BHPF"></a>布特沃斯高通滤波器 BHPF</h3><p>对应的传递函数定义为：</p><script type="math/tex; mode=display">H_{BHPF}(u,v) = \dfrac{1}{ 1 + {[ \dfrac {D_0}{D_(u,v)} ]}^{2n} }</script><p>（分母分子颠倒）</p><p>两式中$n$对应了即阶参数，下面的代码给出巴特沃斯滤波器的实现，其频率域透视图、频率域图像显示、空间域图像显示和径向剖面图，曲线图绘制出不同阶下的取值。</p><h3 id="代码实现-1"><a href="#代码实现-1" class="headerlink" title="代码实现"></a>代码实现</h3><pre><code class="hljs python"><span class="hljs-comment"># 获得指定大小的布特沃斯滤波器</span><span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">getButterworthMask</span><span class="hljs-params">(mask_shape,filter_d0,hl_type,butter_n = <span class="hljs-number">1</span>)</span>:</span>    <span class="hljs-keyword">assert</span> hl_type <span class="hljs-keyword">in</span> (<span class="hljs-string">"lpf"</span>,<span class="hljs-string">"hpf"</span>)    rows,cols = mask_shape[<span class="hljs-number">0</span>],mask_shape[<span class="hljs-number">1</span>]    crow = rows/<span class="hljs-number">2</span>    ccol = cols/<span class="hljs-number">2</span>    mask = np.zeros((rows,cols))    <span class="hljs-keyword">for</span> i <span class="hljs-keyword">in</span> range(rows):        <span class="hljs-keyword">for</span> j <span class="hljs-keyword">in</span> range(cols):            dis = sqrt((i-crow)**<span class="hljs-number">2</span> + (j-ccol)**<span class="hljs-number">2</span>)            <span class="hljs-keyword">if</span> hl_type == <span class="hljs-string">"lpf"</span>:                mask[i,j] = <span class="hljs-number">1.0</span>/(<span class="hljs-number">1</span>+(dis/filter_d0)**(<span class="hljs-number">2</span>*butter_n))            <span class="hljs-keyword">elif</span> hl_type == <span class="hljs-string">"hpf"</span>:                <span class="hljs-comment"># 除以0情况特判一下</span>                <span class="hljs-keyword">if</span> np.abs(dis)&lt;eps:                    mask[i,j] = <span class="hljs-number">0</span>                <span class="hljs-keyword">else</span>:                    mask[i,j] = <span class="hljs-number">1.0</span>/(<span class="hljs-number">1</span>+(filter_d0/dis)**(<span class="hljs-number">2</span>*butter_n))    <span class="hljs-keyword">return</span> mask<span class="hljs-comment"># 测试BLPF</span><span class="hljs-comment"># 参数设置</span>mask_shape = (<span class="hljs-number">100</span>,<span class="hljs-number">100</span>)d = <span class="hljs-number">20</span>filter_type = <span class="hljs-string">"lpf"</span><span class="hljs-comment"># 获得滤波器</span>myfilter = getButterworthMask(mask_shape,d,filter_type, butter_n=<span class="hljs-number">2</span>)<span class="hljs-comment"># 绘图</span>plt.figure(figsize=(<span class="hljs-number">12</span>,<span class="hljs-number">12</span>))ax1=plt.subplot(<span class="hljs-number">221</span>,projection = <span class="hljs-string">"3d"</span>)ax2=plt.subplot(<span class="hljs-number">222</span>)ax3=plt.subplot(<span class="hljs-number">223</span>)ax4=plt.subplot(<span class="hljs-number">224</span>)drawPerspective(ax1,myfilter,title = <span class="hljs-string">"BLPF(n=2) Perspective Axes3D"</span>, cmap = <span class="hljs-string">"gray"</span>)funcs = []labels = []<span class="hljs-keyword">for</span> i <span class="hljs-keyword">in</span> range(<span class="hljs-number">1</span>,<span class="hljs-number">6</span>):    labels.append(<span class="hljs-string">"BLPF "</span>+<span class="hljs-string">"n="</span>+str(i))funcs.append(<span class="hljs-keyword">lambda</span> x:<span class="hljs-number">1.0</span>/(<span class="hljs-number">1</span>+(x/d)**(<span class="hljs-number">2</span>*<span class="hljs-number">1</span>)))funcs.append(<span class="hljs-keyword">lambda</span> x:<span class="hljs-number">1.0</span>/(<span class="hljs-number">1</span>+(x/d)**(<span class="hljs-number">2</span>*<span class="hljs-number">2</span>)))funcs.append(<span class="hljs-keyword">lambda</span> x:<span class="hljs-number">1.0</span>/(<span class="hljs-number">1</span>+(x/d)**(<span class="hljs-number">2</span>*<span class="hljs-number">3</span>)))funcs.append(<span class="hljs-keyword">lambda</span> x:<span class="hljs-number">1.0</span>/(<span class="hljs-number">1</span>+(x/d)**(<span class="hljs-number">2</span>*<span class="hljs-number">4</span>)))funcs.append(<span class="hljs-keyword">lambda</span> x:<span class="hljs-number">1.0</span>/(<span class="hljs-number">1</span>+(x/d)**(<span class="hljs-number">2</span>*<span class="hljs-number">5</span>)))drawCurv(ax2,funcs,labels,d,title = <span class="hljs-string">"BLPF(n=1,2,3,4,5) Curv"</span>)drawPanel(ax3,myfilter,title = <span class="hljs-string">"BLPF(n=2) Frequency Panel Axes2D"</span>)spatial_myfilter = frequencyToSpatial(myfilter)drawPanel(ax4,spatial_myfilter,title = <span class="hljs-string">"BLPF(n=2) Spatial Panel Axes2D"</span>)plt.show()<span class="hljs-comment"># 测试BHPF</span>d = <span class="hljs-number">20</span>filter_type = <span class="hljs-string">"hpf"</span>myfilter = getButterworthMask(mask_shape,d,filter_type, butter_n=<span class="hljs-number">1</span>)plt.figure(figsize=(<span class="hljs-number">12</span>,<span class="hljs-number">12</span>))ax1=plt.subplot(<span class="hljs-number">221</span>,projection = <span class="hljs-string">"3d"</span>)ax2=plt.subplot(<span class="hljs-number">222</span>)ax3=plt.subplot(<span class="hljs-number">223</span>)ax4=plt.subplot(<span class="hljs-number">224</span>)drawPerspective(ax1,myfilter,title = <span class="hljs-string">"BHPF(n=2) Perspective Axes3D"</span>, cmap = <span class="hljs-string">"gray"</span>)funcs = []labels = []<span class="hljs-keyword">for</span> i <span class="hljs-keyword">in</span> range(<span class="hljs-number">1</span>,<span class="hljs-number">6</span>):<span class="hljs-comment">#     funcs.append(lambda x:1.0/(1+(d/x)**(2*i)))</span><span class="hljs-comment">#     ufunc = np.frompyfunc(lambda x: 0 if np.abs(x)&lt;eps else 1.0/(1+(d/x)**(2*i)), 1, 1)</span><span class="hljs-comment">#     funcs.append(ufunc)</span>    labels.append(<span class="hljs-string">"BHPF "</span>+<span class="hljs-string">"n="</span>+str(i))ufunc1 = np.frompyfunc(<span class="hljs-keyword">lambda</span> x: <span class="hljs-number">0</span> <span class="hljs-keyword">if</span> np.abs(x)&lt;eps <span class="hljs-keyword">else</span> <span class="hljs-number">1.0</span>/(<span class="hljs-number">1</span>+(d/x)**(<span class="hljs-number">2</span>*<span class="hljs-number">1</span>)), <span class="hljs-number">1</span>, <span class="hljs-number">1</span>)ufunc2 = np.frompyfunc(<span class="hljs-keyword">lambda</span> x: <span class="hljs-number">0</span> <span class="hljs-keyword">if</span> np.abs(x)&lt;eps <span class="hljs-keyword">else</span> <span class="hljs-number">1.0</span>/(<span class="hljs-number">1</span>+(d/x)**(<span class="hljs-number">2</span>*<span class="hljs-number">2</span>)), <span class="hljs-number">1</span>, <span class="hljs-number">1</span>)ufunc3 = np.frompyfunc(<span class="hljs-keyword">lambda</span> x: <span class="hljs-number">0</span> <span class="hljs-keyword">if</span> np.abs(x)&lt;eps <span class="hljs-keyword">else</span> <span class="hljs-number">1.0</span>/(<span class="hljs-number">1</span>+(d/x)**(<span class="hljs-number">2</span>*<span class="hljs-number">3</span>)), <span class="hljs-number">1</span>, <span class="hljs-number">1</span>)ufunc4 = np.frompyfunc(<span class="hljs-keyword">lambda</span> x: <span class="hljs-number">0</span> <span class="hljs-keyword">if</span> np.abs(x)&lt;eps <span class="hljs-keyword">else</span> <span class="hljs-number">1.0</span>/(<span class="hljs-number">1</span>+(d/x)**(<span class="hljs-number">2</span>*<span class="hljs-number">4</span>)), <span class="hljs-number">1</span>, <span class="hljs-number">1</span>)ufunc5 = np.frompyfunc(<span class="hljs-keyword">lambda</span> x: <span class="hljs-number">0</span> <span class="hljs-keyword">if</span> np.abs(x)&lt;eps <span class="hljs-keyword">else</span> <span class="hljs-number">1.0</span>/(<span class="hljs-number">1</span>+(d/x)**(<span class="hljs-number">2</span>*<span class="hljs-number">5</span>)), <span class="hljs-number">1</span>, <span class="hljs-number">1</span>)funcs.append(ufunc1)funcs.append(ufunc2)funcs.append(ufunc3)funcs.append(ufunc4)funcs.append(ufunc5)drawCurv(ax2,funcs,labels,d,title = <span class="hljs-string">"BHPF(n=1,2,3,4,5) Curv"</span>)drawPanel(ax3,myfilter,title = <span class="hljs-string">"BHPF(n=2) Frequency Panel Axes2D"</span>)spatial_myfilter = frequencyToSpatial(myfilter)drawPanel(ax4,spatial_myfilter,title = <span class="hljs-string">"BHPF(n=2) Spatial Panel Axes2D"</span>)plt.show()</code></pre><p>布特沃斯低通 BLPF 结果四图</p><p><img src="https://eddyblog.oss-cn-shenzhen.aliyuncs.com/ImageProcess/TypeOfFilter/5.png" srcset="/img/loading.gif" alt="png"></p><p>布特沃斯高通 BHPF 结果四图</p><p><img src="https://eddyblog.oss-cn-shenzhen.aliyuncs.com/ImageProcess/TypeOfFilter/6.png" srcset="/img/loading.gif" alt="png"></p><a id="more"></a><h3 id="高斯低通滤波器-GLPF"><a href="#高斯低通滤波器-GLPF" class="headerlink" title="高斯低通滤波器 GLPF"></a>高斯低通滤波器 GLPF</h3><p>高斯低通滤波器二维形式由下式给处：</p><script type="math/tex; mode=display">H_{GLPF}(u,v) = e^{\dfrac{-D^2(u,v)}{2 \sigma^2}}</script><p>$\sigma$描述了中心的扩散速度，和其他滤波器描述式统一，通过令$\sigma = D_0$，可以用表示其他滤波器的方法表示高斯滤波器。</p><script type="math/tex; mode=display">H_{GLPF}(u,v) = e^{\dfrac{-D^2(u,v)}{2 D_0^2}}</script><h3 id="高斯高通滤波器-GHPF"><a href="#高斯高通滤波器-GHPF" class="headerlink" title="高斯高通滤波器 GHPF"></a>高斯高通滤波器 GHPF</h3><p>如下：</p><script type="math/tex; mode=display">H_{GHPF}(u,v) =1 - e^{\dfrac{-D^2(u,v)}{2 D_0^2}}</script><h3 id="代码实现-2"><a href="#代码实现-2" class="headerlink" title="代码实现"></a>代码实现</h3><pre><code class="hljs python"><span class="hljs-comment"># 获得指定大小的高斯滤波器</span><span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">getGaussianMask</span><span class="hljs-params">(mask_shape,filter_d0,hl_type)</span>:</span>    <span class="hljs-keyword">assert</span> hl_type <span class="hljs-keyword">in</span> (<span class="hljs-string">"lpf"</span>,<span class="hljs-string">"hpf"</span>)    rows,cols = mask_shape[<span class="hljs-number">0</span>],mask_shape[<span class="hljs-number">1</span>]    crow = rows/<span class="hljs-number">2</span>    ccol = cols/<span class="hljs-number">2</span>    mask = np.zeros((rows,cols))    <span class="hljs-keyword">for</span> i <span class="hljs-keyword">in</span> range(rows):        <span class="hljs-keyword">for</span> j <span class="hljs-keyword">in</span> range(cols):            dis = sqrt((i-crow)**<span class="hljs-number">2</span> + (j-ccol)**<span class="hljs-number">2</span>)            <span class="hljs-keyword">if</span> hl_type == <span class="hljs-string">"hpf"</span>:                mask[i,j] = <span class="hljs-number">1</span>-np.exp(-(dis**<span class="hljs-number">2</span>) / (<span class="hljs-number">2</span>*(filter_d0**<span class="hljs-number">2</span>)))            <span class="hljs-keyword">elif</span> hl_type == <span class="hljs-string">"lpf"</span>:                mask[i,j] = np.exp(-(dis**<span class="hljs-number">2</span>)/(<span class="hljs-number">2</span>*(filter_d0**<span class="hljs-number">2</span>)))    <span class="hljs-keyword">return</span> mask<span class="hljs-comment"># 测试GLPF</span><span class="hljs-comment"># 参数设置</span>mask_shape = (<span class="hljs-number">200</span>,<span class="hljs-number">200</span>)d = <span class="hljs-number">20</span>filter_type = <span class="hljs-string">"lpf"</span><span class="hljs-comment"># 获得滤波器</span>myfilter = getGaussianMask(mask_shape,d,filter_type)<span class="hljs-comment"># 绘图</span>plt.figure(figsize=(<span class="hljs-number">12</span>,<span class="hljs-number">12</span>))ax1=plt.subplot(<span class="hljs-number">221</span>,projection = <span class="hljs-string">"3d"</span>)ax2=plt.subplot(<span class="hljs-number">222</span>)ax3=plt.subplot(<span class="hljs-number">223</span>)ax4=plt.subplot(<span class="hljs-number">224</span>)drawPerspective(ax1,myfilter,title = <span class="hljs-string">"GLPF Perspective Axes3D"</span>, cmap = <span class="hljs-string">"gray"</span>)drawCurv(ax2,[<span class="hljs-keyword">lambda</span> x:np.exp(-(x**<span class="hljs-number">2</span>)/(<span class="hljs-number">2</span>*(d**<span class="hljs-number">2</span>)))],[<span class="hljs-string">"GLPF"</span>],d,title = <span class="hljs-string">"GLPF Curv"</span>)drawPanel(ax3,myfilter,title = <span class="hljs-string">"GLPF Frequency Panel Axes2D"</span>)spatial_myfilter = frequencyToSpatial(myfilter)drawPanel(ax4,spatial_myfilter,title = <span class="hljs-string">"GLPF Spatial Panel Axes2D"</span>)plt.show()<span class="hljs-comment"># 测试GHPF</span>d = <span class="hljs-number">20</span>filter_type = <span class="hljs-string">"hpf"</span>myfilter = getGaussianMask(mask_shape,d,filter_type)plt.figure(figsize=(<span class="hljs-number">12</span>,<span class="hljs-number">12</span>))ax1=plt.subplot(<span class="hljs-number">221</span>,projection = <span class="hljs-string">"3d"</span>)ax2=plt.subplot(<span class="hljs-number">222</span>)ax3=plt.subplot(<span class="hljs-number">223</span>)ax4=plt.subplot(<span class="hljs-number">224</span>)drawPerspective(ax1,myfilter,title = <span class="hljs-string">"GLPF Perspective Axes3D"</span>, cmap = <span class="hljs-string">"gray"</span>)drawCurv(ax2,[<span class="hljs-keyword">lambda</span> x:<span class="hljs-number">1</span>-np.exp(-(x**<span class="hljs-number">2</span>)/(<span class="hljs-number">2</span>*(d**<span class="hljs-number">2</span>)))],[<span class="hljs-string">"GHPF"</span>],d,title = <span class="hljs-string">"GLPF Curv"</span>)drawPanel(ax3,myfilter,title = <span class="hljs-string">"GLPF Frequency Panel Axes2D"</span>)spatial_myfilter = frequencyToSpatial(myfilter)drawPanel(ax4,spatial_myfilter,title = <span class="hljs-string">"GLPF Spatial Panel Axes2D"</span>)plt.show()</code></pre><p>高斯低通 GLPF 结果四图</p><p><img src="https://eddyblog.oss-cn-shenzhen.aliyuncs.com/ImageProcess/TypeOfFilter/7.png" srcset="/img/loading.gif" alt="png"></p><p>高斯高通 GHPF 结果四图</p><p><img src="https://eddyblog.oss-cn-shenzhen.aliyuncs.com/ImageProcess/TypeOfFilter/8.png" srcset="/img/loading.gif" alt="png"></p><h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><p>在规定滤波器为 100x100，阈值为 20 时，可以明显观察到，理想滤波器-&gt;高阶布特沃斯滤波器-&gt;低阶布特沃斯滤波器-&gt;高斯滤波器，可以由函数 Curv 看出对应的过渡。</p><p>我们同时也发现理想滤波器确实会存在<strong>振铃特性</strong>，这个将在后面的文章中再做分析学习。</p><h2 id="附录"><a href="#附录" class="headerlink" title="附录"></a>附录</h2><p>辅助代码</p><pre><code class="hljs python"><span class="hljs-keyword">import</span> numpy <span class="hljs-keyword">as</span> np<span class="hljs-keyword">import</span> cv2<span class="hljs-keyword">import</span> imageio<span class="hljs-keyword">import</span> matplotlib.pyplot <span class="hljs-keyword">as</span> plt<span class="hljs-keyword">from</span> math <span class="hljs-keyword">import</span> sqrt<span class="hljs-keyword">from</span> mpl_toolkits.mplot3d <span class="hljs-keyword">import</span> Axes3Deps = np.finfo(float).eps</code></pre><h3 id="绘制三维透视图"><a href="#绘制三维透视图" class="headerlink" title="绘制三维透视图"></a>绘制三维透视图</h3><pre><code class="hljs python"><span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">drawPerspective</span><span class="hljs-params">(handleax,input_matrix,title=None,cmap = <span class="hljs-string">"gray"</span>)</span>:</span>    handleax.set_title(title)    handleax.set_zlabel(<span class="hljs-string">'Z'</span>)  <span class="hljs-comment"># 坐标轴</span>    handleax.set_ylabel(<span class="hljs-string">'Y'</span>)    handleax.set_xlabel(<span class="hljs-string">'X'</span>)    x,y = input_matrix.shape    X = np.arange(<span class="hljs-number">0</span>,x,<span class="hljs-number">1</span>)    Y = np.arange(<span class="hljs-number">0</span>,y,<span class="hljs-number">1</span>)    <span class="hljs-comment"># 由于图像x,y坐标和 meshigrid出来是互反的</span>    <span class="hljs-comment"># 这里需要调转一下</span>    <span class="hljs-comment"># 否则会出现mismatch的现象</span>    X,Y = np.meshgrid(Y, X)    handleax.plot_surface(Y, X, input_matrix, cmap=cmap)<span class="hljs-comment">#     handleax.plot_wireframe(Y, X, input_matrix, cmap=cmap)</span></code></pre><h3 id="绘制平面图"><a href="#绘制平面图" class="headerlink" title="绘制平面图"></a>绘制平面图</h3><pre><code class="hljs python"><span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">drawPanel</span><span class="hljs-params">(handleax,input_matrix,title=None,cmap = <span class="hljs-string">"gray"</span>)</span>:</span>    handleax.set_title(title)    handleax.set_ylabel(<span class="hljs-string">'Y'</span>)    handleax.set_xlabel(<span class="hljs-string">'X'</span>)    handleax.imshow(input_matrix,cmap = cmap)</code></pre><h3 id="绘制曲线图"><a href="#绘制曲线图" class="headerlink" title="绘制曲线图"></a>绘制曲线图</h3><pre><code class="hljs python"><span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">drawCurv</span><span class="hljs-params">(handleax,functions,labels,filter_d0,title=None,cmap = <span class="hljs-string">"gray"</span>)</span>:</span>    <span class="hljs-comment"># 绘制从0到 3D_0的函数剖面图</span>    handleax.set_title(title)    handleax.set_xlabel(<span class="hljs-string">"$D(u,v)$"</span>)    handleax.set_ylabel(<span class="hljs-string">"$H(u,v)$"</span>)    <span class="hljs-comment"># 标出D_0点</span>    <span class="hljs-comment"># handleax.annotate(r"$D_0$", xy = (filter_d0,0) , weight='heavy')</span>    <span class="hljs-keyword">for</span> func,lab <span class="hljs-keyword">in</span> zip(functions,labels):        <span class="hljs-comment"># 对每一对func和label绘图 （针对需要画多条线的情况）</span>        X = np.arange(<span class="hljs-number">0</span>,<span class="hljs-number">3</span>*filter_d0+<span class="hljs-number">1</span>,<span class="hljs-number">0.1</span>)        Y = func(X)        handleax.plot(X,Y,label = lab)    handleax.set_xticks([<span class="hljs-number">0</span>,filter_d0])    handleax.set_xticklabels([<span class="hljs-string">"$0$"</span>,<span class="hljs-string">"$D_0$"</span>])    handleax.legend()</code></pre><h3 id="频率域转空间域"><a href="#频率域转空间域" class="headerlink" title="频率域转空间域"></a>频率域转空间域</h3><pre><code class="hljs python"><span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">frequencyToSpatial</span><span class="hljs-params">(input_matrix)</span>:</span>    <span class="hljs-comment"># 这里不太明白为什么shift与否最后都需要添加一个fftshift来得到想要的空间域图像</span>    shift_input_matrix = np.fft.ifftshift(input_matrix)<span class="hljs-comment">#     shift_input_matrix = input_matrix</span>    spatial_img = np.abs(np.fft.ifft2(shift_input_matrix))    spatial_img = np.fft.fftshift(spatial_img)    <span class="hljs-keyword">return</span> spatial_img</code></pre><p>对三维透视可视化代码进行测试</p><pre><code class="hljs python"><span class="hljs-comment"># 测试1</span>test_img1 = cv2.imread(<span class="hljs-string">'./DIP3E_Original_Images_CH02/Fig0207(a)(gray level band).tif'</span>,<span class="hljs-number">0</span>)test_img2 = cv2.imread(<span class="hljs-string">'./DIP3E_CH07_Original_Images/Fig0726(a).tif'</span>,<span class="hljs-number">0</span>)plt.figure(figsize=(<span class="hljs-number">16</span>,<span class="hljs-number">12</span>))ax1 = plt.subplot(<span class="hljs-number">221</span>,projection = <span class="hljs-string">"3d"</span>)ax2 = plt.subplot(<span class="hljs-number">222</span>)ax3 = plt.subplot(<span class="hljs-number">223</span>,projection = <span class="hljs-string">"3d"</span>)ax4 = plt.subplot(<span class="hljs-number">224</span>)drawPerspective(ax1,test_img1,<span class="hljs-string">"Test Fig0726(a) Axes3D"</span>,<span class="hljs-string">"rainbow"</span>)drawPanel(ax2,test_img1,<span class="hljs-string">"Test Fig0726(a) Axes2D"</span>,<span class="hljs-string">"rainbow"</span>)drawPerspective(ax3,test_img2,<span class="hljs-string">"Test Fig0726(a) Axes3D"</span>,<span class="hljs-string">"rainbow"</span>)drawPanel(ax4,test_img2,<span class="hljs-string">"Test Fig0726(a) Axes2D"</span>,<span class="hljs-string">"rainbow"</span>)plt.show()</code></pre><p>测试结果</p><p><img src="https://eddyblog.oss-cn-shenzhen.aliyuncs.com/ImageProcess/TypeOfFilter/1.png" srcset="/img/loading.gif" alt="png"></p><p>对绘制函数曲线代码进行测试</p><pre><code class="hljs python"><span class="hljs-comment"># 测试2</span>test_d0 = <span class="hljs-number">10</span>test_funcs1 = []test_funcs1.append(<span class="hljs-keyword">lambda</span> x: np.sin(x))test_funcs1.append(<span class="hljs-keyword">lambda</span> x: np.cos(x))test_labels1 = [<span class="hljs-string">"$sin(x)$"</span>,<span class="hljs-string">"$cos(x)$"</span>]test_funcs2 = []test_funcs2.append(<span class="hljs-keyword">lambda</span> x: np.sqrt(x))test_funcs2.append(<span class="hljs-keyword">lambda</span> x: np.exp(-(x**<span class="hljs-number">2</span>)/(<span class="hljs-number">2</span>*(test_d0)**<span class="hljs-number">2</span>)))test_labels2 = [<span class="hljs-string">"$x$"</span>,<span class="hljs-string">"$e^&#123;\dfrac&#123;-D^2(u,v)&#125;&#123;2 D_0^2&#125;&#125;$"</span>]plt.figure(figsize=(<span class="hljs-number">14</span>,<span class="hljs-number">7</span>))ax1 = plt.subplot(<span class="hljs-number">121</span>)ax2 = plt.subplot(<span class="hljs-number">122</span>)drawCurv(ax1,test_funcs1,test_labels1,test_d0,title=<span class="hljs-string">"Test sin(x) and cos(x)"</span>)drawCurv(ax2,test_funcs2,test_labels2,test_d0,title=<span class="hljs-string">"Test x and gaussian"</span>)plt.show()</code></pre><p>测试结果</p><p><img src="https://eddyblog.oss-cn-shenzhen.aliyuncs.com/ImageProcess/TypeOfFilter/2.png" srcset="/img/loading.gif" alt="png"></p>]]></content>
    
    
    <categories>
      
      <category>Computer Science</category>
      
      <category>数字图像处理</category>
      
    </categories>
    
    
    <tags>
      
      <tag>数字图像处理</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>行为金融学——线性成长与指数成长</title>
    <link href="/post/684a8ddc.html"/>
    <url>/post/684a8ddc.html</url>
    
    <content type="html"><![CDATA[<h1 id="请描绘线性成长与指数成长的规律，你从中得到了什么启示"><a href="#请描绘线性成长与指数成长的规律，你从中得到了什么启示" class="headerlink" title="请描绘线性成长与指数成长的规律，你从中得到了什么启示"></a>请描绘线性成长与指数成长的规律，你从中得到了什么启示</h1><p>用数学公式描述两种成长模式</p><h2 id="线性成长"><a href="#线性成长" class="headerlink" title="线性成长"></a>线性成长</h2><p>狭义：一次线性</p><script type="math/tex; mode=display">Q(t) = a_1 t + a_0</script><p>广义：多项式线性</p><script type="math/tex; mode=display">Q(t) = a_n t^n + a_{n-1} t^{n-1} + \cdots + a_1 t + a_0</script><p>理解性描述：线性成长是一种可按差值描述“成长度”的成长模式，稍微数学解释一下应该是在某个阶差分为 0（则在上一阶是个等差变化），属于增长<strong>值</strong>“固定”的一种增长模式。</p><h2 id="指数成长"><a href="#指数成长" class="headerlink" title="指数成长"></a>指数成长</h2><script type="math/tex; mode=display">Q(t) = a r^t</script><p>理解性描述：指数成长则是一种按比率描述“成长度”的成长模式，最基本的指数成长实际上就是我们高中所学的一个首项为正，公比为正的等比数列通项公式，这种成长模式是不能用差分来描述的，而需要比率描述，属于增长<strong>率</strong>“固定”的一张增长模式。</p><h2 id="启示"><a href="#启示" class="headerlink" title="启示"></a>启示</h2><p>看了网上一段话，将两种增长模式与人的自身发展联系起来，他是这么说的：</p><blockquote><p>_线性成长可以让一个人变得优秀，但是要成为人中的佼佼者，让自己变得卓越，则一定是指数式的成长。指数式成长其实就是一种复利的作用，每一天的努力、坚持可以产生复利效应。_</p></blockquote><p>这段话有点结语结论的味道，话虽不错，但是没有给出一定程度的解释，我自己补充了一些。</p><p>首先，对于一个大多数活着的人来说，每天都有各式各样的“新”知识通过人的各种感官进入脑部中枢，清洗，筛选，分析，学习。所以对于这些大多数，成长是必然的，相较于前一天必然有数值的增大。</p><p>但要解释大多数中的那些小部分“枭雄”，我们不仅要看到增长，还要区分增长的模式。接纳新事物，学习新知识，若是做的好的话，在较长时间跨度内都能保持稳定的（某个阶恒差）的增长，这就体现了所谓的<strong>线性成长</strong>，而那小部分人，则可以调动起过去所有的资源（包括自己的基本能力和过去刚学习到的知识），全部用来转化吸收新的知识，类似于一种<strong>复利</strong>的计算，这种增长是可怕的，因为他每接收一分知识，就会在下一个瞬间加速（或者加大）下一份知识的吸收。</p>]]></content>
    
    
    <categories>
      
      <category>Finance</category>
      
      <category>投资银行学</category>
      
    </categories>
    
    
    <tags>
      
      <tag>投资银行学</tag>
      
      <tag>辅修</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>数字图像处理——频率域滤波初步</title>
    <link href="/post/d5cc0f91.html"/>
    <url>/post/d5cc0f91.html</url>
    
    <content type="html"><![CDATA[<h1 id="频率域滤波基础"><a href="#频率域滤波基础" class="headerlink" title="频率域滤波基础"></a>频率域滤波基础</h1><h2 id="傅里叶变换"><a href="#傅里叶变换" class="headerlink" title="傅里叶变换"></a>傅里叶变换</h2><p>复习傅里叶级数、傅里叶变换（说实话这么久只知道个大概没有推过数学公式很丢人。。）</p><p>待补充</p><h2 id="参考资料"><a href="#参考资料" class="headerlink" title="参考资料"></a>参考资料</h2><p>主要使用 OpenCV、Numpy 以及提供的对应方法。</p><p>图片来源为冈萨雷斯数字图像处理提供的图像。</p><p><a href="https://docs.opencv.org/3.0-beta/doc/py_tutorials/py_imgproc/py_transforms/py_fourier_transform/py_fourier_transform.html#fourier-transform" target="_blank" rel="noopener">OpenCV 关于 Fourier Transform 应用的示例</a></p><pre><code class="hljs python"><span class="hljs-keyword">import</span> numpy <span class="hljs-keyword">as</span> np<span class="hljs-keyword">import</span> cv2<span class="hljs-keyword">import</span> imageio<span class="hljs-keyword">import</span> matplotlib.pyplot <span class="hljs-keyword">as</span> plt</code></pre><pre><code class="hljs python"><span class="hljs-comment"># 选取部分测试照片并显示</span>img1 = cv2.imread(<span class="hljs-string">'./DIP3E_CH07_Original_Images/Fig0723(a).tif'</span>,<span class="hljs-number">0</span>)img2 = cv2.imread(<span class="hljs-string">'./DIP3E_Original_Images_CH04/Fig0429(a)(blown_ic).tif'</span>,<span class="hljs-number">0</span>)img3 = cv2.imread(<span class="hljs-string">'./DIP3E_Original_Images_CH04/Fig0431(d)(blown_ic_crop).tif'</span>,<span class="hljs-number">0</span>)img4 = cv2.imread(<span class="hljs-string">'./DIP3E_Original_Images_CH04/Fig0438(a)(bld_600by600).tif'</span>,<span class="hljs-number">0</span>)plt.figure(figsize=(<span class="hljs-number">8</span>,<span class="hljs-number">8</span>))ax1 = plt.subplot(<span class="hljs-number">221</span>)ax1.set_title(<span class="hljs-string">"Image1 Original Image"</span>)ax1.imshow(img1,cmap = <span class="hljs-string">"gray"</span>)ax2 = plt.subplot(<span class="hljs-number">222</span>)ax2.set_title(<span class="hljs-string">"Image2 Original Image"</span>)ax2.imshow(img2,cmap = <span class="hljs-string">"gray"</span>)ax3 = plt.subplot(<span class="hljs-number">223</span>)ax3.set_title(<span class="hljs-string">"Image3 Original Image"</span>)ax3.imshow(img3,cmap = <span class="hljs-string">"gray"</span>)ax4 = plt.subplot(<span class="hljs-number">224</span>)ax4.set_title(<span class="hljs-string">"Image4 Original Image"</span>)ax4.imshow(img4,cmap = <span class="hljs-string">"gray"</span>)plt.show()</code></pre><p><img src="https://eddyblog.oss-cn-shenzhen.aliyuncs.com/ImageProcess/FFTFilter/FFT_1.png" srcset="/img/loading.gif" alt="png"></p><a id="more"></a><h2 id="原理概述"><a href="#原理概述" class="headerlink" title="原理概述"></a>原理概述</h2><blockquote><p>For a sinusoidal signal, $x(t) = A \sin(2 \pi ft)$, we can say $f$ is the frequency of signal, and if its frequency domain is taken, we can see a spike at $f$. If signal is sampled to form a discrete signal, we get the same frequency domain, but is periodic in the range $[- \pi, \pi]$ or $[0,2\pi]$ (or $[0,N]$ for N-point DFT). You can consider an image as a signal which is sampled in two directions. So taking fourier transform in both X and Y directions gives you the frequency representation of image</p></blockquote><p>中文翻译：对于正弦信号$x(t) = A \sin(2 \pi ft)$，$f$是信号的频率，如果我们考虑它的频域，我们则可以再$f$处看到一个峰值，如果信号采样形成离散信号，我们得到了相同的频域，但是频域在 $[- \pi, \pi]$ 或者 $[0,2\pi]$ （又或者 $[0,N]$ 对于一个$N$点 DFT）。<del>划重点！！</del><strong>你可以把一幅图像看作是在两个方向上采样的信号。在 X 和 Y 方向上进行傅里叶变换就得到了图像的频率表示。</strong></p><h2 id="使用-Numpy-实现-DFT"><a href="#使用-Numpy-实现-DFT" class="headerlink" title="使用 Numpy 实现 DFT"></a>使用 Numpy 实现 DFT</h2><p>首先使用 Numpy 提供的工具实现傅里叶变换，Numpy 提供了一个 FFT 包<code>numpy.fft</code>来做这些。</p><ul><li><code>numpy.fft.fft2(a, s=None, axes=(-2, -1), norm=None)</code> 提供了计算二维 DFT 的方法，参数描述：<ul><li><code>a : array_like</code> 输入数组，可以为复数，灰度图。</li><li><code>s : sequence of ints, optional</code> 决定输出数组的大小，如果输入图像的大小大于输入图像的大小，则在计算 FFT 之前用零填充输入图像。如果它小于输入图像，输入图像将被裁剪。</li><li><code>axes : sequence of ints, optional</code> 没看懂，原始这么写的：Axes over which to compute the FFT. If not given, the last two axes are used. A repeated index in axes means the transform over that axis is performed multiple times. A one-element sequence means that a one-dimensional FFT is performed.</li><li><code>norm : {None, &quot;ortho&quot;}, optional</code> 1.10.0.新加入，归一化方式，默认为 None。</li></ul></li></ul><p>当获得了频域的结果，由于图像直流分量（DC component）在图片的左上角，如果要使其居中，则需要在两个方向上移动结果，Nuumpy 也提供了对应的函数。</p><ul><li><code>numpy.fft.fftshift(x, axes=None)</code> 提供了将零频率分量移到频谱的中心的方法，对于二维输入，交换第一和第三象限，第二和第四象限，参数描述：<ul><li><code>x : array_like</code> 输入数组</li><li><code>axes : int or shape tuple, optional</code> 要移动的轴。 默认值为 None</li></ul></li></ul><p>这样在频率变换后，我们也可找到幅度谱（magnitude spectrum）</p><h2 id="使用-OpenCV-实现-DFT"><a href="#使用-OpenCV-实现-DFT" class="headerlink" title="使用 OpenCV 实现 DFT"></a>使用 OpenCV 实现 DFT</h2><p>OpenCV 也提供的工具用于实现傅里叶变换，分别是<code>cv2.dft()</code>和<code>cv2.idft()</code>函数。返回有两个通道，第一个通道是结果的实部，第二个通道是结果的虚部。所以在计算其幅度的时候需要先手动转化一次。</p><pre><code class="hljs python"><span class="hljs-comment">## Magnitude spectrum</span><span class="hljs-comment">## 使用Numpy实现DFT</span><span class="hljs-comment">## 进行二维DFT变换</span>f_img1 = np.fft.fft2(img1)<span class="hljs-comment">## 对换象限</span>fshift_img1 = np.fft.fftshift(f_img1)<span class="hljs-comment">## 幅度谱 对数化？</span>manitude_img1 = <span class="hljs-number">20</span>*np.log(np.abs(fshift_img1))<span class="hljs-comment">## img2图像也做相同的处理</span>f_img2 = np.fft.fft2(img2)fshift_img2 = np.fft.fftshift(f_img2)manitude_img2 = <span class="hljs-number">20</span>*np.log(np.abs(fshift_img2))<span class="hljs-comment">## 使用OpenCV实现DFT</span>f_img3 = cv2.dft(np.float32(img3), flags = cv2.DFT_COMPLEX_OUTPUT)fshift_img3 = np.fft.fftshift(f_img3)<span class="hljs-comment"># manitude_img3 = 20*np.log(np.abs(fshift_img3))</span><span class="hljs-comment"># 手动转化计算magnitude</span>manitude_img3 = <span class="hljs-number">20</span>*np.log(cv2.magnitude(fshift_img3[:,:,<span class="hljs-number">0</span>],fshift_img3[:,:,<span class="hljs-number">1</span>])+<span class="hljs-number">1e-15</span>)<span class="hljs-comment">## 使用OpenCV实现DFT</span>f_img4 = cv2.dft(np.float32(img4), flags = cv2.DFT_COMPLEX_OUTPUT)fshift_img4 = np.fft.fftshift(f_img4)manitude_img4 = <span class="hljs-number">20</span>*np.log(cv2.magnitude(fshift_img4[:,:,<span class="hljs-number">0</span>],fshift_img4[:,:,<span class="hljs-number">1</span>]))print(<span class="hljs-string">"显示各图像对应的频谱"</span>)print(<span class="hljs-string">"其中图三的频谱有些奇怪"</span>)plt.figure(figsize=(<span class="hljs-number">16</span>,<span class="hljs-number">16</span>))ax1 = plt.subplot(<span class="hljs-number">421</span>)ax1.set_title(<span class="hljs-string">"Image1 Original Image"</span>)ax1.imshow(img1, cmap = <span class="hljs-string">"gray"</span>)ax2 = plt.subplot(<span class="hljs-number">422</span>)ax2.set_title(<span class="hljs-string">"Image1 Magnitude Spectrum"</span>)ax2.imshow(manitude_img1, cmap = <span class="hljs-string">"gray"</span>)ax3 = plt.subplot(<span class="hljs-number">423</span>)ax3.set_title(<span class="hljs-string">"Image2 Original Image"</span>)ax3.imshow(img2, cmap = <span class="hljs-string">"gray"</span>)ax4 = plt.subplot(<span class="hljs-number">424</span>)ax4.set_title(<span class="hljs-string">"Image2 Magnitude Spectrum"</span>)ax4.imshow(manitude_img2, cmap = <span class="hljs-string">"gray"</span>)ax5 = plt.subplot(<span class="hljs-number">425</span>)ax5.set_title(<span class="hljs-string">"Image3 Original Image"</span>)ax5.imshow(img3, cmap = <span class="hljs-string">"gray"</span>)ax6 = plt.subplot(<span class="hljs-number">426</span>)ax6.set_title(<span class="hljs-string">"Image3 Magnitude Spectrum"</span>)ax6.imshow(manitude_img3, cmap = <span class="hljs-string">"gray"</span>)ax7 = plt.subplot(<span class="hljs-number">427</span>)ax7.set_title(<span class="hljs-string">"Image4 Original Image"</span>)ax7.imshow(img4, cmap = <span class="hljs-string">"gray"</span>)ax8 = plt.subplot(<span class="hljs-number">428</span>)ax8.set_title(<span class="hljs-string">"Image4 Magnitude Spectrum"</span>)ax8.imshow(manitude_img4, cmap = <span class="hljs-string">"gray"</span>)plt.show()</code></pre><p>显示各图像对应的频谱</p><p><img src="https://eddyblog.oss-cn-shenzhen.aliyuncs.com/ImageProcess/FFTFilter/FFT_2.png" srcset="/img/loading.gif" alt="png"></p><pre><code class="hljs python">print(np.shape(fshift_img3))</code></pre><pre><code class="hljs txt">(1026, 1026, 2)</code></pre><p>根据运行结果不难验证 OpenCV 提供的 cv.dft()确实返回结果为表示实部和虚部的双通道，np 就没有这些顾虑，毕竟科学计算专门的库，复数支持很自然。</p><p>教程中也给了 Numpy 和 OpenCV 各自速度的解释，以及一些性能优化上的问题（比如 2 的整数此幂的时候速度会加快，自动填充等）：</p><blockquote><p><strong>Note</strong>: As usual, OpenCV functions cv2.dft() and cv2.idft() are faster than Numpy counterparts. But Numpy functions are more user-friendly. For more details about performance issues, see below section.</p></blockquote><p>这个 Note 就已经说明了 cv 的方法会更快一些，但是 numpy 的方法更加 friendly</p><h2 id="性能测试"><a href="#性能测试" class="headerlink" title="性能测试"></a>性能测试</h2><p>针对前述的性能测试，以及教程上所给出的方法，可以利用 IPython 上的一个 magic command <code>%timeit</code></p><p>用同一张图片 img2 来测试，下面是测试结果</p><ul><li><p>测试使用 OpenCV 进行 DFT 变换</p><pre><code class="hljs python">%timeit cv2.dft(np.float32(img2), flags = cv2.DFT_COMPLEX_OUTPUT)</code></pre><p>测试结果：10.3 ms ± 105 µs per loop (mean ± std. dev. of 7 runs, 100 loops each)</p></li><li><p>测试使用 Numpy 进行 DFT 变换</p><pre><code class="hljs python">%timeit np.fft.fft2(img2)</code></pre><p>测试结果：100 ms ± 1.4 ms per loop (mean ± std. dev. of 7 runs, 10 loops each)</p></li></ul><p>通过测试比较，竟然有 10x 的速度差距，还是很明显的。</p><h2 id="频率域滤波"><a href="#频率域滤波" class="headerlink" title="频率域滤波"></a>频率域滤波</h2><h3 id="高通滤波-HPF"><a href="#高通滤波-HPF" class="headerlink" title="高通滤波 HPF"></a>高通滤波 HPF</h3><p>对于给定的图片对频域中心（低频部分）赋值为 0，通过这种掩膜方式（masking）过滤掉低频部分从而实现 HPF。这里实验的只是粗略的滤波，频率域中心为方形，并非理想高通滤波器（IHPF）。</p><h3 id="低通滤波-LPF"><a href="#低通滤波-LPF" class="headerlink" title="低通滤波 LPF"></a>低通滤波 LPF</h3><p>同理，给定图片保留频率中心部分（低频部分）赋值为 1，剩下的通过掩膜过滤掉，从而实现 LPF。同前述，这里实验也只是粗略的滤波，频率域中心为方形，并非理想低通滤波器（ILPF）。</p><h2 id="频率域滤波-1"><a href="#频率域滤波-1" class="headerlink" title="频率域滤波"></a>频率域滤波</h2><h3 id="高通滤波-HPF-1"><a href="#高通滤波-HPF-1" class="headerlink" title="高通滤波 HPF"></a>高通滤波 HPF</h3><p>对于给定的图片对频域中心（低频部分）赋值为 0，通过这种掩膜方式（masking）过滤掉低频部分从而实现 HPF。</p><h3 id="低通滤波-LPF-1"><a href="#低通滤波-LPF-1" class="headerlink" title="低通滤波 LPF"></a>低通滤波 LPF</h3><p>同理，给定图片保留频率中心部分（低频部分）赋值为 1，剩下的通过掩膜过滤掉，从而实现 LPF。</p><pre><code class="hljs python"><span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">getFilterPassImg</span><span class="hljs-params">(input_img : np.array, filter_type : str , filter_size = <span class="hljs-number">20</span>)</span>:</span>    <span class="hljs-keyword">assert</span> filter_type <span class="hljs-keyword">in</span> (<span class="hljs-string">"lpf"</span>,<span class="hljs-string">"hpf"</span>)    f_img = np.fft.fft2(input_img)    shift_img = np.fft.fftshift(f_img)    <span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">getMask</span><span class="hljs-params">(input_shift_img : np.array , mask_type , mask_size)</span>:</span>        rows,cols = input_shift_img.shape        crow,ccol = rows//<span class="hljs-number">2</span>,cols//<span class="hljs-number">2</span>        <span class="hljs-keyword">if</span>(mask_type == <span class="hljs-string">"hpf"</span>):            mask = np.ones(input_shift_img.shape)            mask[crow - mask_size:crow+mask_size, ccol-mask_size:ccol+mask_size] = <span class="hljs-number">0.0</span>        <span class="hljs-keyword">else</span> :            mask = np.zeros(input_shift_img.shape)            mask[crow - mask_size:crow+mask_size, ccol-mask_size:ccol+mask_size] = <span class="hljs-number">1.0</span>        <span class="hljs-keyword">return</span> mask    mask_shift_img = getMask(shift_img, filter_type ,filter_size)    new_shift_img = mask_shift_img*shift_img    new_manitude_img = <span class="hljs-number">20</span>*np.log(np.abs(new_shift_img)+eps)    new_f_img = np.fft.ifftshift(new_shift_img)    new_img = np.fft.ifft2(new_f_img)    new_img = np.abs(new_img)    <span class="hljs-keyword">return</span> new_img,new_manitude_img</code></pre><pre><code class="hljs python">hpf_img2,hpf_manitude_img2 = getFilterPassImg(img2,<span class="hljs-string">"hpf"</span>,<span class="hljs-number">30</span>)lpf_img2,lpf_manitude_img2 = getFilterPassImg(img2,<span class="hljs-string">"lpf"</span>,<span class="hljs-number">30</span>)plt.figure(figsize=(<span class="hljs-number">8</span>,<span class="hljs-number">12</span>))ax1 = plt.subplot(<span class="hljs-number">321</span>)ax1.set_title(<span class="hljs-string">"Original Image"</span>)ax1.imshow(img2, cmap = <span class="hljs-string">"gray"</span>)ax2 = plt.subplot(<span class="hljs-number">322</span>)ax2.set_title(<span class="hljs-string">"Magnitude Spectrum"</span>)ax2.imshow(manitude_img2, cmap = <span class="hljs-string">"gray"</span>)ax3 = plt.subplot(<span class="hljs-number">323</span>)ax3.set_title(<span class="hljs-string">"With HPF(Size=30x30)"</span>)ax3.imshow(hpf_img2,cmap = <span class="hljs-string">"gray"</span>)ax4 = plt.subplot(<span class="hljs-number">324</span>)ax4.set_title(<span class="hljs-string">"With HPF(Size=30x30) Magnitude Spectrum"</span>)ax4.imshow(hpf_manitude_img2,cmap = <span class="hljs-string">"gray"</span>)ax5 = plt.subplot(<span class="hljs-number">325</span>)ax5.set_title(<span class="hljs-string">"With LPF(Size=30x30)"</span>)ax5.imshow(lpf_img2,cmap = <span class="hljs-string">"gray"</span>)ax6 = plt.subplot(<span class="hljs-number">326</span>)ax6.set_title(<span class="hljs-string">"With LPF(Size=30x30) Magnitude Spectrum"</span>)ax6.imshow(lpf_manitude_img2,cmap = <span class="hljs-string">"gray"</span>)plt.show()</code></pre><p><img src="https://eddyblog.oss-cn-shenzhen.aliyuncs.com/ImageProcess/FFTFilter/FFT_3.png" srcset="/img/loading.gif" alt="png"></p>]]></content>
    
    
    <categories>
      
      <category>Computer Science</category>
      
      <category>数字图像处理</category>
      
    </categories>
    
    
    <tags>
      
      <tag>数字图像处理</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>行为金融学——博弈论一些经典实验</title>
    <link href="/post/73209085.html"/>
    <url>/post/73209085.html</url>
    
    <content type="html"><![CDATA[<div class="table-container"><table><thead><tr><th style="text-align:center">实验类型</th><th style="text-align:center">实验描述</th><th style="text-align:center">现实举例</th><th style="text-align:center">经济人模型的均衡解</th><th style="text-align:center">实验结果</th><th style="text-align:center">社会偏好</th></tr></thead><tbody><tr><td style="text-align:center">囚徒博弈实验</td><td style="text-align:center">两个实验对象进行囚徒博弈分别有合作和不合作两个决策，双方博弈的收益支付矩阵为合作不合作合作 H，H S，T 不合作 T，S L，L 其中，H ＞ L，T ＞ H，L ＞ S</td><td style="text-align:center">负外部性产品比如环境污染、噪音等的生产</td><td style="text-align:center">双方均选择不合作</td><td style="text-align:center">50%的人选择合作，而且互相交流机制能有效增强合作的频率</td><td style="text-align:center">互惠偏好</td></tr><tr><td style="text-align:center">最后通牒实验</td><td style="text-align:center">双人或多人分别扮演提议者和响应者角色对一财富 S 进行分配方案的选择博弈，提议者分配 x 个筹码给对方，如果响应者拒绝则双方受益为 0，如果响应者接受，则提议者获得 S-x，响应者获得 x</td><td style="text-align:center">易腐烂商品的垄断定价</td><td style="text-align:center">提议者分配 x ＝ ε，其中 ε 为任意小的一个正数，响应者接受该分配额</td><td style="text-align:center">平均分配额在 0.3S 和 0.5S 之间，当 x ＜ 0.2S 时大约一半的人会拒绝</td><td style="text-align:center">互惠偏好、利他偏好、差异厌恶偏好</td></tr><tr><td style="text-align:center">独裁者实验</td><td style="text-align:center">在最后通牒博弈基础上取消了响应者的拒绝权利，即独裁者决定对 S 财富的分配，若独裁者分配 x 个筹码给对方，双方收益即决定为(S-x，x)</td><td style="text-align:center">慈善的捐赠行为</td><td style="text-align:center">独裁者分配给接收者 x ＝ 0</td><td style="text-align:center">平均来看独裁者会分配给接收者 x ＝ 0.2S</td><td style="text-align:center">利他偏好</td></tr><tr><td style="text-align:center">第三方惩罚实验</td><td style="text-align:center">在独裁者基础上加入了一个局外者即第三方，该第三方可以对独裁者的分配行为进行带有成本的惩罚</td><td style="text-align:center">对不公现象的社会谴责和批评</td><td style="text-align:center">独裁者照样分配给接受者 x ＝ 0，而第三方不会选择惩罚</td><td style="text-align:center">当独裁者给接收者的分配额小于一定数目时，第三方会对独裁者进行惩罚而且分配数目越小惩罚越大</td><td style="text-align:center">利他偏好</td></tr><tr><td style="text-align:center">公共品博弈实验</td><td style="text-align:center">拥有初始禀赋 y 的 n 个实验对象同时对一个公共项目进行投资，投资额为 gi(0≤gi≤y)，此时每人收益为 πi ＝ y－gi ＋ mG，其中 G 为各实验对象的投资总额，m 为公共品投资回报率</td><td style="text-align:center">团队合作，小型社会中的公共产出，共有资源的过度使用等</td><td style="text-align:center">每个实验对象投资额为 gi ＝ 0</td><td style="text-align:center">在一次性匿名实验中人们会投资 50%的初始禀赋，如果实验次数增加，则投资额为越来越小，交流机制和惩罚机制可以有效提升合作水平</td><td style="text-align:center">互惠偏好，利他偏好，差异厌恶偏好</td></tr><tr><td style="text-align:center">信任博弈实验</td><td style="text-align:center">双人分别扮演委托人和代理人角色并拥有初始禀赋 S，委托人可以从初始禀赋 S 中选择投资 y(0≤y≤S)给代理人，代理人自动获得 3y 后可以选择返还一个 x(0≤x≤3y)给委托人。此时委托人收益为 S－y+x，而代理人收益为 S+3y－x</td><td style="text-align:center">没有法律合同的买卖行为</td><td style="text-align:center">委托人选择投资 y ＝ 0；代理人选择返还 x ＝ 0.</td><td style="text-align:center">平均上来看实验者会选择 y ＝ 0.5S 投资给代理人，而代理人会选择返还一个略小于 0.5S 的值给委托人，而且 x 与 y 成正比</td><td style="text-align:center">互惠偏好，利他偏好</td></tr><tr><td style="text-align:center">礼物交换实验</td><td style="text-align:center">雇主提供给一个工资 w 给雇员，雇员选择一个工作努力程度 e(1≤e≤10)，并付出成本 c(e)，此时雇员工作产出效益为 10e，雇主收益为 10e-w，雇员收益为 w-c(e)</td><td style="text-align:center">雇主和雇员的上下关系</td><td style="text-align:center">雇员选择最小努力程度即 e ＝ 0，而雇主提供最小工资</td><td style="text-align:center">雇员的努力程度和雇主的工资水平成正比。</td><td style="text-align:center">互惠偏好，利他偏好</td></tr></tbody></table></div>]]></content>
    
    
    <categories>
      
      <category>Finance</category>
      
      <category>投资银行学</category>
      
    </categories>
    
    
    <tags>
      
      <tag>投资银行学</tag>
      
      <tag>辅修</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>计算机图形学——曲面表达</title>
    <link href="/post/e3de1605.html"/>
    <url>/post/e3de1605.html</url>
    
    <content type="html"><![CDATA[<h1 id="曲面造型发展背景"><a href="#曲面造型发展背景" class="headerlink" title="曲面造型发展背景"></a>曲面造型发展背景</h1><h1 id="插值与逼近"><a href="#插值与逼近" class="headerlink" title="插值与逼近"></a>插值与逼近</h1><h1 id="使用参数曲面的优势"><a href="#使用参数曲面的优势" class="headerlink" title="使用参数曲面的优势"></a>使用参数曲面的优势</h1><ol><li>基于满足集合不变性（指他们不依赖于）</li></ol><h1 id="曲线曲面的一般参数样条表达"><a href="#曲线曲面的一般参数样条表达" class="headerlink" title="曲线曲面的一般参数样条表达"></a>曲线曲面的一般参数样条表达</h1><p>位置矢量、切矢。。</p><p>我们如何有效、快速地设计、表达和绘制自由曲线？</p><ul><li>灵活的模型</li></ul><p>Bezier 曲线</p><h1 id="连续与光滑"><a href="#连续与光滑" class="headerlink" title="连续与光滑"></a>连续与光滑</h1><p>C1 连续、几何连续（只要求方向，不要求大小值相同）</p><p>B 样条曲线</p><p>k 取值 2 到 n+1</p><a id="more"></a>]]></content>
    
    
    <categories>
      
      <category>Computer Science</category>
      
      <category>计算机图形学</category>
      
    </categories>
    
    
    <tags>
      
      <tag>计算机图形学</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>机器学习——决策树实现（Python版）</title>
    <link href="/post/efa709aa.html"/>
    <url>/post/efa709aa.html</url>
    
    <content type="html"><![CDATA[<p>完成 ID3、C4.5、CART 决策树构建，阈值限制，连续属性划分，剪枝，缺省值处理。</p><h1 id="什么是决策树"><a href="#什么是决策树" class="headerlink" title="什么是决策树"></a>什么是决策树</h1><p><strong>直观理解</strong>：通过自顶向下的方式，构造一棵数据不断被纯化的树，可用来分类、回归，有监督学习的一种。</p><p><strong>构造过程</strong>：递归构造</p><p><strong>核心问题</strong>：划分的选择（决策依据）</p><p>来自<a href="https://shuwoom.com/?p=1452" target="_blank" rel="noopener">SGUWOOM 的博客</a><br>`</p><blockquote><p>决策树学习采用的是自顶向下的递归方法，其基本思想是以信息熵为度量构造一颗熵值下降最快的树，到叶子节点处，熵值为 $0$。其具有可读性、分类速度快的优点，是一种有监督学习。最早提及决策树思想的是 Quinlan 在 1986 年提出的 ID3 算法和 1993 年提出的 C4.5 算法，以及 Breiman 等人在 1984 年提出的 CART 算法</p></blockquote><p>随着划分不断进行，决策树的分支节点应趋向于属于同一类别，样本集合属于同一类别的程度用“纯度”（purity）表示。</p><h1 id="基本概念"><a href="#基本概念" class="headerlink" title="基本概念"></a>基本概念</h1><h2 id="信息熵"><a href="#信息熵" class="headerlink" title="信息熵"></a>信息熵</h2><p>“信息熵”（Information entropy），衡量样本集合纯度最常用的一种方法，公式：</p><script type="math/tex; mode=display">Ent(D) = - \sum_{k=1}^{ |y|} p_k \log_2 p_k</script><p>其中$p_k$ 为第$k$ 类样本占该样本集的比例。</p><p><del>甚至可以联想热学熵</del>，熵值越低应该越好（纯度越高），从公式易知熵值范围应是$[ 0 , \log_2 |D|]$。</p><h2 id="信息增益"><a href="#信息增益" class="headerlink" title="信息增益"></a>信息增益</h2><p>对于该集合的一种划分（实践上我们尝试通过对某一列属性是否相同，即该属性上的等价关系，对集合进行划分），我们会产生一个<strong>商集</strong>。</p><p>如西瓜书上所假设，离散属性$a$有$V$个可能的取值$\{ a^1,a^2, \cdots , a^n \}$，用该属性对样本集进行划分，会产生$V$个分支节点，属性值与分支节点对应关系为$a^v \rightarrow D^v$，对这$V$个分支节点分别计算信息熵并赋予权重$\frac{ |D^v| }{ | D | }$，与原样本集合的信息熵作比较我们就可以得出<strong>信息增益</strong>，公式：</p><script type="math/tex; mode=display">Gain(D,a) = Ent(D) - \sum_{v=1}^{V} \frac{ |D^v| }{ | D | } Ent(D^v)</script><p>ID3 决策树学习算法采用<strong>信息增益</strong>为准则决定划分属性。</p><h2 id="信息增益率"><a href="#信息增益率" class="headerlink" title="信息增益率"></a>信息增益率</h2><p>对于信息增益，我们很容易发现其偏好属性值可取值较多的属性有偏好（因为分后各分支节点样本都趋近于完全纯和），在一些数据集中会丧失泛化能力。</p><p>信息增益率在信息增益的基础上，增加了“固有值”（Intrinsic Value）的概念，可取值越多的属性，其固有值 IV 常常会越大，计算增益率的公式为：</p><script type="math/tex; mode=display">Gain\_radio(D,a) = \frac{Gain(D,a)}{IV(a)}</script><script type="math/tex; mode=display">IV(a) = - \sum_{v=1}^{V} \frac{ |D^v| }{ | D | } \log_2 \frac{ |D^v| }{ | D | }</script><p>C4.5 决策树算法采用<strong>信息增益率</strong>来选择最优的划分属性，不过由于增益率准则对可取数目较少的属性有所偏好<del>反过来了</del>，因此，C4.5 算法并不是直接选择增益率最大的候选划分属性，而是使用了一个启发式算法，<strong>先从候选划分属性中找出信息增益高于平均水平的属性，再从中选择增益率最高的</strong>。</p><a id="more"></a><h2 id="基尼指数"><a href="#基尼指数" class="headerlink" title="基尼指数"></a>基尼指数</h2><p>CART 决策树使用“基尼指数”来选择划分属性，公式：</p><script type="math/tex; mode=display">Gini(D) = \sum_{ k=1 }^{ |y| } \sum_{ k' k }  p_k p_{k'}</script><p>概率公式，更常用的是下面：</p><script type="math/tex; mode=display">Gini(D) = 1- \sum_{k=1}^{|y|} p_k^2</script><p>通过某一属性进行划分，则属性$a$的基尼指数定义为：</p><script type="math/tex; mode=display">Gini\_index(D,a) =  \sum_{v=1}^{V} \frac{ |D^v| }{ | D | } Gini(D^v)</script><p>我们选择所有属性中使得划分后基尼指数最小的属性作为最优划分属性。</p><p>需要说明的是 CART 决策树是从属性集中抽取两个相互对立的集合（即$V=2$），离散型属性应为等于和不等于，连续型属性应是小于和大于等于，利用上式计算$Gini_index$，对每个可能可能取得值均取一遍，选取最小得$Gini_index$值作为该属性的代表值。</p><h1 id="程序流程图"><a href="#程序流程图" class="headerlink" title="程序流程图"></a>程序流程图</h1><p><img src="https://eddyblog.oss-cn-shenzhen.aliyuncs.com/MachineLearning/DecisionTree/decisiontree1.png" srcset="/img/loading.gif" alt="tree1"></p><h1 id="整体代码"><a href="#整体代码" class="headerlink" title="整体代码"></a>整体代码</h1><pre><code class="hljs python"><span class="hljs-comment">#!/usr/bin/env python</span><span class="hljs-comment"># coding: utf-8</span><span class="hljs-comment"># In[1]:</span><span class="hljs-keyword">from</span> math <span class="hljs-keyword">import</span> log<span class="hljs-keyword">import</span> numpy <span class="hljs-keyword">as</span> np<span class="hljs-keyword">import</span> pandas <span class="hljs-keyword">as</span> pd<span class="hljs-keyword">import</span> matplotlib.pyplot <span class="hljs-keyword">as</span> plt<span class="hljs-keyword">import</span> matplotlib<span class="hljs-keyword">from</span> sklearn.datasets <span class="hljs-keyword">import</span> load_iris<span class="hljs-keyword">from</span> sklearn.model_selection <span class="hljs-keyword">import</span> train_test_splitmatplotlib.rcParams[<span class="hljs-string">'font.family'</span>] = <span class="hljs-string">'SimHei'</span><span class="hljs-comment"># In[99]:</span><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">DecisionTree</span>:</span>    <span class="hljs-string">"""    DecisionTree 决策树类    详情见API文档    """</span>    label_name = []    raw_data = []    raw_label = []    train_data = []    train_label = []    test_data = []    test_label = []    tree = []    <span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">__init__</span><span class="hljs-params">(self, input_data, input_label, input_name)</span>:</span>        <span class="hljs-string">"""        __init__ 构造函数初始化决策树对象        :param self: 类方法自带        :param input_data: 输入数据集        :param input_label: 输入标签集        :param input_name: 输入属性名称        """</span>        self.raw_data = np.array(input_data, dtype=object)        self.raw_label = np.array(input_label, dtype=object)        self.label_name = np.array(input_name, dtype=object)    <span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">loadTrainData</span><span class="hljs-params">(self, type=<span class="hljs-number">0</span>)</span>:</span>        <span class="hljs-string">"""        loadTrainData 构建训练集        :param self: 类方法自带        :param type: 加载方法        """</span>        <span class="hljs-keyword">if</span>(type == <span class="hljs-number">0</span>):            self.train_data = np.array(self.raw_data, dtype=object)            self.train_label = np.array(self.raw_label, dtype=object)    <span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">calcGini</span><span class="hljs-params">(self, labels)</span>:</span>        <span class="hljs-string">"""        calcGini 计算给定数据集的基尼指数Gini(D)        :param self: 类方法自带        :param labels: 输入的标签集或属性集        :return: 计算的基尼指数        """</span>        label_values = set(labels)        ans = <span class="hljs-number">1.0</span>        <span class="hljs-keyword">for</span> value <span class="hljs-keyword">in</span> label_values:            p = labels[labels == value].size / labels.size            ans -= p**<span class="hljs-number">2</span>        <span class="hljs-keyword">return</span> ans    <span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">calcEntropy</span><span class="hljs-params">(self, labels)</span>:</span>        <span class="hljs-string">"""        calcEntropy 计算给定数据集的经验熵Ent(D)        :param self: 类方法自带        :param labels: 输入的标签集或属性集        :return: 计算的Ent熵        """</span>        label_values = set(labels)        ans = <span class="hljs-number">0.0</span>        <span class="hljs-keyword">for</span> value <span class="hljs-keyword">in</span> label_values:            p = labels[labels == value].size / labels.size            ans -= p*log(p, <span class="hljs-number">2</span>)        <span class="hljs-keyword">return</span> ans    <span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">calcSumEnt</span><span class="hljs-params">(self, data, labels)</span>:</span>        <span class="hljs-string">"""        calcSumEnt 计算给定数据集的经验熵Ent(D)        :param self: 类方法自带        :param data: 输入的数据集        :param labels: 输入的标签集        :return: sum_ent: 计算的Ent熵        :return: max_point: 对于连续型属性 最佳分割点        """</span>        features = np.array(data, dtype=object)        labels = np.array(labels, dtype=object)        feature_values = list(set(features))        num = features.size        max_point = -float(<span class="hljs-string">'inf'</span>)        sum_ent = <span class="hljs-number">0.0</span>        <span class="hljs-keyword">if</span> type(features[<span class="hljs-number">0</span>]) != float <span class="hljs-keyword">and</span> type(features[<span class="hljs-number">0</span>]) != int:            <span class="hljs-comment"># 对于离散值属性，分类方向确定，计算Gain即可</span>            <span class="hljs-keyword">for</span> value <span class="hljs-keyword">in</span> feature_values:                p = features[features == value].size/num                sum_ent += p*self.calcEntropy(labels[features == value])        <span class="hljs-keyword">else</span>:            <span class="hljs-comment"># 对于连续性属性，分类方向不确定，还需要多做一次分割点确认</span>            sum_ent = float(<span class="hljs-string">'inf'</span>)            <span class="hljs-comment"># 排序</span>            feature_values.sort()            cnt = len(feature_values)            <span class="hljs-comment"># 寻找最合适的划分中点</span>            <span class="hljs-keyword">for</span> j <span class="hljs-keyword">in</span> range(cnt<span class="hljs-number">-1</span>):                point_ent = <span class="hljs-number">0</span>                point = float(feature_values[j] + feature_values[j+<span class="hljs-number">1</span>])/<span class="hljs-number">2</span>                <span class="hljs-comment"># 划分成小于和大于等于两个子集</span>                p1 = features[features &lt; point].size / num                p2 = features[features &gt;= point].size / num                point_ent += p1*self.calcEntropy(labels[features &lt; point])                point_ent += p2*self.calcEntropy(labels[features &gt;= point])                <span class="hljs-keyword">if</span> point_ent &lt; sum_ent:                    sum_ent = point_ent                    max_point = point        <span class="hljs-keyword">return</span> sum_ent, max_point    <span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">calcInfoGain</span><span class="hljs-params">(self, data, labels)</span>:</span>        <span class="hljs-string">"""        calcInfoGain 计算指定数据集选定属性的信息熵增益（ID3）        :param self: 类方法自带        :param data: 输入的数据集（选定指定属性）        :param labels: 输入的标签集或属性集        :return: 信息熵增益        """</span>        sum_ent, max_point = self.calcSumEnt(data, labels)        <span class="hljs-keyword">return</span> self.calcEntropy(labels) - sum_ent, max_point    <span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">calcInfoGainRatio</span><span class="hljs-params">(self, data, labels)</span>:</span>        <span class="hljs-string">"""        calcInfoGainRatio 计算指定数据集选定属性的信息熵增益率（C4.5）        :param self: 类方法自带        :param data: 输入的数据集（选定指定属性）        :param labels: 输入的标签集或属性集        :return: 信息熵增益率        """</span>        iv = self.calcEntropy(data)        <span class="hljs-keyword">if</span> iv == <span class="hljs-number">0</span>:            <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>, <span class="hljs-number">0</span>        <span class="hljs-keyword">else</span>:            info_gain, max_point = self.calcInfoGain(data, labels)            <span class="hljs-keyword">return</span> info_gain/iv, max_point    <span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">calcInfoGini</span><span class="hljs-params">(self, data, labels)</span>:</span>        <span class="hljs-string">"""        calcInfoGini 计算指定数据集选定属性的基尼指数（CART）        :param self: 类方法自带        :param data: 输入的数据集（选定指定属性）        :param labels: 输入的标签集或属性集        :return: sum_gini: 指定属性的基尼指数和        :return: 最佳分割点        """</span>        features = np.array(data, dtype=object)        labels = np.array(labels, dtype=object)        feature_values = list(set(features))        num = features.size        max_point = -float(<span class="hljs-string">'inf'</span>)        best_gini = float(<span class="hljs-string">'inf'</span>)        best_value = <span class="hljs-string">""</span>        <span class="hljs-keyword">if</span> type(features[<span class="hljs-number">0</span>]) != float <span class="hljs-keyword">and</span> type(features[<span class="hljs-number">0</span>]) != int:            <span class="hljs-comment"># 对于离散值属性，分类方向确定，计算Gain即可</span>            <span class="hljs-keyword">for</span> value <span class="hljs-keyword">in</span> feature_values:                p1 = features[features == value].size / num                p2 = features[features != value].size / num                tmp_gini = p1 * \                    self.calcGini(labels[features == value]) + \                    p2*self.calcGini(labels[features != value])                <span class="hljs-keyword">if</span> tmp_gini &lt; best_gini:                    best_gini = tmp_gini                    best_value = value        <span class="hljs-keyword">else</span>:            <span class="hljs-comment"># 对于连续性属性，分类方向不确定，还需要多做一次分割点确认</span>            best_gini = float(<span class="hljs-string">'inf'</span>)            <span class="hljs-comment"># 排序</span>            feature_values.sort()            cnt = len(feature_values)            <span class="hljs-comment"># 寻找最合适的划分中点</span>            <span class="hljs-keyword">for</span> j <span class="hljs-keyword">in</span> range(cnt<span class="hljs-number">-1</span>):                point_gini = <span class="hljs-number">0</span>                point = float(feature_values[j] + feature_values[j+<span class="hljs-number">1</span>])/<span class="hljs-number">2</span>                <span class="hljs-comment"># 划分成小于和大于等于两个子集</span>                p1 = features[features &lt; point].size / num                p2 = features[features &gt;= point].size / num                point_gini += p1*self.calcGini(labels[features &lt; point])                point_gini += p2*self.calcGini(labels[features &gt;= point])                <span class="hljs-keyword">if</span> point_gini &lt; best_gini:                    best_gini = point_gini                    max_point = point        <span class="hljs-keyword">return</span> best_gini, best_value, max_point    <span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">chooseBest</span><span class="hljs-params">(self, data, labels, names, method=<span class="hljs-string">'id3'</span>)</span>:</span>        <span class="hljs-string">"""        chooseBest 选择最佳分割属性        :param self: 类方法自带        :param data: 当前数据集        :param labels: 当前标签集合        :param names: 当前数据集的属性名集合        :param method: 信息增益计算方法（ID3/C4.5）        :return: best_feature_index 最佳分割属性索引        :return: best_feature_name: 最佳分割属性名        :return: best_info_improve: 最佳分割后信息增益值        :return: best_point: 对于连续值最佳分割点        """</span>        data = np.array(data, dtype=object)        labels = np.array(labels, dtype=object)        names = np.array(names, dtype=object)        feature_num = data.shape[<span class="hljs-number">1</span>]        <span class="hljs-comment"># 筛选最优特征</span>        <span class="hljs-keyword">if</span> method == <span class="hljs-string">'id3'</span> <span class="hljs-keyword">or</span> method == <span class="hljs-string">'c4.5'</span>:            best_info_improve = -float(<span class="hljs-string">'inf'</span>)        <span class="hljs-keyword">elif</span> method == <span class="hljs-string">'cart'</span>:            best_info_improve = float(<span class="hljs-string">'inf'</span>)        best_feature_index = <span class="hljs-number">-1</span>        best_point = -float(<span class="hljs-string">'inf'</span>)        best_value = <span class="hljs-string">""</span>        <span class="hljs-keyword">for</span> feature_index <span class="hljs-keyword">in</span> range(feature_num):            <span class="hljs-keyword">if</span> method == <span class="hljs-string">'id3'</span>:                now_info_improve, now_point = self.calcInfoGain(                    data[:, feature_index], labels)                <span class="hljs-keyword">if</span> now_info_improve &gt; best_info_improve:                    best_info_improve = now_info_improve                    best_point = now_point                    best_feature_index = feature_index            <span class="hljs-keyword">elif</span> method == <span class="hljs-string">'c4.5'</span>:                now_info_improve, now_point = self.calcInfoGainRatio(                    data[:, feature_index], labels)                <span class="hljs-keyword">if</span> now_info_improve &gt; best_info_improve:                    best_info_improve = now_info_improve                    best_point = now_point                    best_feature_index = feature_index            <span class="hljs-keyword">elif</span> method == <span class="hljs-string">'cart'</span>:                now_info_improve, now_value, now_point = self.calcInfoGini(                    data[:, feature_index], labels)                <span class="hljs-keyword">if</span> now_info_improve &lt; best_info_improve:                    best_info_improve = now_info_improve                    best_point = now_point                    best_feature_index = feature_index                    best_value = now_value        best_feature_name = names[best_feature_index]        <span class="hljs-keyword">return</span> best_feature_index, best_feature_name, best_value, best_info_improve, best_point    <span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">splitData</span><span class="hljs-params">(self, data, labels, names, feature_index, feature_name, cart_value, point, method)</span>:</span>        <span class="hljs-string">"""        splitData 根据最佳分割，讲数据集标签集划分为不同子集        :param self: 类方法自带        :param data: 当前数据集        :param labels: 当前标签集合        :param names: 当前数据集的属性名集合        :param feature_index: 分割属性索引        :param point: 对于连续属性的分割点        :return: data_set: 不同属性对应的子数据集的集合        :return: label_set: 不同属性对应的子标签集的集合        :return: name_set: 子集属性名集合        """</span>        data = np.array(data, dtype=object)        labels = np.array(labels, dtype=object)        names = np.array(names, dtype=object)        <span class="hljs-comment"># 取特征列预备向量运算</span>        features_col = data[:, feature_index]        data_set = &#123;&#125;        label_set = &#123;&#125;        <span class="hljs-keyword">if</span> method == <span class="hljs-string">'id3'</span> <span class="hljs-keyword">or</span> method == <span class="hljs-string">'c4.5'</span>:            <span class="hljs-comment"># 删除特征列</span>            data = np.delete(data, feature_index, <span class="hljs-number">1</span>)            name_set = np.delete(names, feature_index)            <span class="hljs-keyword">if</span>(type(features_col[<span class="hljs-number">0</span>]) != float <span class="hljs-keyword">and</span> type(features_col[<span class="hljs-number">0</span>] != int)):                <span class="hljs-comment"># 统计所有出现的特征值 按特征名称为键值储存在 data_set中</span>                features_values = set(features_col)                <span class="hljs-keyword">for</span> value <span class="hljs-keyword">in</span> features_values:                    data_set[value] = data[features_col == value]                    label_set[value] = labels[features_col == value]            <span class="hljs-keyword">else</span>:                data_set[(<span class="hljs-string">'&lt;'</span>, point)] = data[features_col &lt; point]                label_set[(<span class="hljs-string">'&lt;'</span>, point)] = labels[features_col &lt; point]                data_set[(<span class="hljs-string">'&gt;='</span>, point)] = data[features_col &gt;= point]                label_set[(<span class="hljs-string">'&gt;='</span>, point)] = labels[features_col &gt;= point]        <span class="hljs-keyword">elif</span> method == <span class="hljs-string">'cart'</span>:            name_set = names            <span class="hljs-keyword">if</span>(type(features_col[<span class="hljs-number">0</span>]) != float <span class="hljs-keyword">and</span> type(features_col[<span class="hljs-number">0</span>] != int)):                <span class="hljs-comment"># 离散值分等于与不等于</span>                <span class="hljs-comment"># 等于集合</span>                data_set[(<span class="hljs-string">'='</span>, cart_value)] = data[features_col == cart_value]                label_set[(<span class="hljs-string">'='</span>, cart_value)                          ] = labels[features_col == cart_value]                <span class="hljs-comment"># 不等于集合</span>                data_set[(<span class="hljs-string">'!='</span>, cart_value)] = data[features_col != cart_value]                label_set[(<span class="hljs-string">'!='</span>, cart_value)                          ] = labels[features_col != cart_value]            <span class="hljs-keyword">else</span>:                <span class="hljs-comment"># 小于指定点</span>                data_set[(<span class="hljs-string">'&lt;'</span>, point)] = data[features_col &lt; point]                label_set[(<span class="hljs-string">'&lt;'</span>, point)] = labels[features_col &lt; point]                <span class="hljs-comment"># 大于指定点</span>                data_set[(<span class="hljs-string">'&gt;='</span>, point)] = data[features_col &gt;= point]                label_set[(<span class="hljs-string">'&gt;='</span>, point)] = labels[features_col &gt;= point]        <span class="hljs-keyword">return</span> data_set, label_set, name_set    <span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">startCreateTree</span><span class="hljs-params">(self, method=<span class="hljs-string">'id3'</span>, min_sample=<span class="hljs-number">1</span>)</span>:</span>        <span class="hljs-string">"""        startCreateTree 根据设定的信息增益标准以及阈值限制，构建决策树        :param self: 类方法自带        :param method: 选定方法，默认为ID3        :param min_sample: 最少样本数阈值，默认为1        """</span>        self.tree = self.createTree(            self.train_data, self.train_label, self.label_name, method, min_sample)    <span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">majLabel</span><span class="hljs-params">(self, labels)</span>:</span>        <span class="hljs-string">"""        majLabel 当前标签集的选择主要类别        :param self: 类方法自带        :param labels: 输入标签集        :return: 主要类别名        """</span>        labels = np.array(labels, dtype=object)        label_values = set(labels)        label_map = &#123;&#125;        <span class="hljs-keyword">for</span> value <span class="hljs-keyword">in</span> label_values:            label_map[value] = labels[labels == value].size        <span class="hljs-keyword">return</span> max(label_map, key=label_map.get)    <span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">createTree</span><span class="hljs-params">(self, data, labels, names, method, min_sample)</span>:</span>        <span class="hljs-string">"""        createTree 构建当前树结点        :param self: 类方法自带        :param data: 输入数据集        :param labels: 输入标签集        :param names: 输入属性名集合        :param min_sample: 最小样本数量阈值        :return: 返回建立的节点        """</span>        data = np.array(data, dtype=object)        labels = np.array(labels, dtype=object)        names = np.array(names, dtype=object)        <span class="hljs-comment"># 相同类别</span>        <span class="hljs-keyword">if</span> len(set(labels)) == <span class="hljs-number">1</span>:            <span class="hljs-keyword">return</span> labels[<span class="hljs-number">0</span>]        <span class="hljs-comment"># 剩余样本量小于阈值</span>        <span class="hljs-keyword">if</span> data.size == <span class="hljs-number">0</span> <span class="hljs-keyword">or</span> labels.size &lt;= min_sample:            <span class="hljs-keyword">return</span> self.majLabel(labels)        <span class="hljs-comment"># 选取最优特征</span>        best_feature_index, best_feature_name, best_value, best_ent, best_point = self.chooseBest(            data, labels, names, method)        <span class="hljs-comment"># 建立节点</span>        node = &#123;<span class="hljs-string">"feature_name"</span>: best_feature_name&#125;        <span class="hljs-comment"># 函数内删除不会影响外部情况，所以不会造成回溯时改变</span>        child_data_set, child_label_set, child_name_set = self.splitData(            data, labels, names, best_feature_index, best_feature_name, best_value, best_point, method)<span class="hljs-comment">#         print(child_data_set)</span><span class="hljs-comment">#         print(child_label_set)</span>        <span class="hljs-keyword">for</span> feature_value <span class="hljs-keyword">in</span> child_data_set.keys():            node[feature_value] = self.createTree(                child_data_set[feature_value], child_label_set[feature_value], child_name_set, method, min_sample)        <span class="hljs-keyword">return</span> node<span class="hljs-comment"># In[84]:</span><span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">createDataSet</span><span class="hljs-params">(type=<span class="hljs-number">0</span>)</span>:</span>    <span class="hljs-string">"""    createTree 构建数据集    :param type: 选择数据集类型（默认为0）    :return: data: 数据集    :return: label: 标签集    :return: label_names: 属性名集合    """</span>    <span class="hljs-keyword">if</span> type == <span class="hljs-number">0</span>:        data = [            [<span class="hljs-string">'青绿'</span>, <span class="hljs-string">'蜷缩'</span>, <span class="hljs-string">'浊响'</span>, <span class="hljs-string">'清晰'</span>, <span class="hljs-string">'凹陷'</span>, <span class="hljs-string">'硬滑'</span>],            [<span class="hljs-string">'乌黑'</span>, <span class="hljs-string">'蜷缩'</span>, <span class="hljs-string">'沉闷'</span>, <span class="hljs-string">'清晰'</span>, <span class="hljs-string">'凹陷'</span>, <span class="hljs-string">'硬滑'</span>],            [<span class="hljs-string">'乌黑'</span>, <span class="hljs-string">'蜷缩'</span>, <span class="hljs-string">'浊响'</span>, <span class="hljs-string">'清晰'</span>, <span class="hljs-string">'凹陷'</span>, <span class="hljs-string">'硬滑'</span>],            [<span class="hljs-string">'青绿'</span>, <span class="hljs-string">'蜷缩'</span>, <span class="hljs-string">'沉闷'</span>, <span class="hljs-string">'清晰'</span>, <span class="hljs-string">'凹陷'</span>, <span class="hljs-string">'硬滑'</span>],            [<span class="hljs-string">'浅白'</span>, <span class="hljs-string">'蜷缩'</span>, <span class="hljs-string">'浊响'</span>, <span class="hljs-string">'清晰'</span>, <span class="hljs-string">'凹陷'</span>, <span class="hljs-string">'硬滑'</span>],            [<span class="hljs-string">'青绿'</span>, <span class="hljs-string">'稍蜷'</span>, <span class="hljs-string">'浊响'</span>, <span class="hljs-string">'清晰'</span>, <span class="hljs-string">'稍凹'</span>, <span class="hljs-string">'软粘'</span>],            [<span class="hljs-string">'乌黑'</span>, <span class="hljs-string">'稍蜷'</span>, <span class="hljs-string">'浊响'</span>, <span class="hljs-string">'稍糊'</span>, <span class="hljs-string">'稍凹'</span>, <span class="hljs-string">'软粘'</span>],            [<span class="hljs-string">'乌黑'</span>, <span class="hljs-string">'稍蜷'</span>, <span class="hljs-string">'浊响'</span>, <span class="hljs-string">'清晰'</span>, <span class="hljs-string">'稍凹'</span>, <span class="hljs-string">'硬滑'</span>],            [<span class="hljs-string">'乌黑'</span>, <span class="hljs-string">'稍蜷'</span>, <span class="hljs-string">'沉闷'</span>, <span class="hljs-string">'稍糊'</span>, <span class="hljs-string">'稍凹'</span>, <span class="hljs-string">'硬滑'</span>],            [<span class="hljs-string">'青绿'</span>, <span class="hljs-string">'硬挺'</span>, <span class="hljs-string">'清脆'</span>, <span class="hljs-string">'清晰'</span>, <span class="hljs-string">'平坦'</span>, <span class="hljs-string">'软粘'</span>],            [<span class="hljs-string">'浅白'</span>, <span class="hljs-string">'硬挺'</span>, <span class="hljs-string">'清脆'</span>, <span class="hljs-string">'模糊'</span>, <span class="hljs-string">'平坦'</span>, <span class="hljs-string">'硬滑'</span>],            [<span class="hljs-string">'浅白'</span>, <span class="hljs-string">'蜷缩'</span>, <span class="hljs-string">'浊响'</span>, <span class="hljs-string">'模糊'</span>, <span class="hljs-string">'平坦'</span>, <span class="hljs-string">'软粘'</span>],            [<span class="hljs-string">'青绿'</span>, <span class="hljs-string">'稍蜷'</span>, <span class="hljs-string">'浊响'</span>, <span class="hljs-string">'稍糊'</span>, <span class="hljs-string">'凹陷'</span>, <span class="hljs-string">'硬滑'</span>],            [<span class="hljs-string">'浅白'</span>, <span class="hljs-string">'稍蜷'</span>, <span class="hljs-string">'沉闷'</span>, <span class="hljs-string">'稍糊'</span>, <span class="hljs-string">'凹陷'</span>, <span class="hljs-string">'硬滑'</span>],            [<span class="hljs-string">'乌黑'</span>, <span class="hljs-string">'稍蜷'</span>, <span class="hljs-string">'浊响'</span>, <span class="hljs-string">'清晰'</span>, <span class="hljs-string">'稍凹'</span>, <span class="hljs-string">'软粘'</span>],            [<span class="hljs-string">'浅白'</span>, <span class="hljs-string">'蜷缩'</span>, <span class="hljs-string">'浊响'</span>, <span class="hljs-string">'模糊'</span>, <span class="hljs-string">'平坦'</span>, <span class="hljs-string">'硬滑'</span>],            [<span class="hljs-string">'青绿'</span>, <span class="hljs-string">'蜷缩'</span>, <span class="hljs-string">'沉闷'</span>, <span class="hljs-string">'稍糊'</span>, <span class="hljs-string">'稍凹'</span>, <span class="hljs-string">'硬滑'</span>]        ]        <span class="hljs-comment"># labels记录样本标签</span>        labels = [<span class="hljs-string">'是'</span>, <span class="hljs-string">'是'</span>, <span class="hljs-string">'是'</span>, <span class="hljs-string">'是'</span>, <span class="hljs-string">'是'</span>, <span class="hljs-string">'是'</span>, <span class="hljs-string">'是'</span>, <span class="hljs-string">'是'</span>,                  <span class="hljs-string">'否'</span>, <span class="hljs-string">'否'</span>, <span class="hljs-string">'否'</span>, <span class="hljs-string">'否'</span>, <span class="hljs-string">'否'</span>, <span class="hljs-string">'否'</span>, <span class="hljs-string">'否'</span>, <span class="hljs-string">'否'</span>, <span class="hljs-string">'否'</span>]        <span class="hljs-comment"># label_names中记录的是特征的名称</span>        label_names = [<span class="hljs-string">'色泽'</span>, <span class="hljs-string">'根蒂'</span>, <span class="hljs-string">'敲声'</span>, <span class="hljs-string">'纹理'</span>, <span class="hljs-string">'脐部'</span>, <span class="hljs-string">'触感'</span>]    <span class="hljs-keyword">elif</span> type == <span class="hljs-number">1</span>:        data = np.array([[<span class="hljs-number">0.697</span>, <span class="hljs-number">0.46</span>],                         [<span class="hljs-number">0.774</span>, <span class="hljs-number">0.376</span>],                         [<span class="hljs-number">0.634</span>, <span class="hljs-number">0.264</span>],                         [<span class="hljs-number">0.608</span>, <span class="hljs-number">0.318</span>],                         [<span class="hljs-number">0.556</span>, <span class="hljs-number">0.215</span>],                         [<span class="hljs-number">0.403</span>, <span class="hljs-number">0.237</span>],                         [<span class="hljs-number">0.481</span>, <span class="hljs-number">0.149</span>],                         [<span class="hljs-number">0.437</span>, <span class="hljs-number">0.211</span>],                         [<span class="hljs-number">0.666</span>, <span class="hljs-number">0.091</span>],                         [<span class="hljs-number">0.243</span>, <span class="hljs-number">0.267</span>],                         [<span class="hljs-number">0.245</span>, <span class="hljs-number">0.057</span>],                         [<span class="hljs-number">0.343</span>, <span class="hljs-number">0.099</span>],                         [<span class="hljs-number">0.639</span>, <span class="hljs-number">0.161</span>],                         [<span class="hljs-number">0.657</span>, <span class="hljs-number">0.198</span>],                         [<span class="hljs-number">0.36</span>, <span class="hljs-number">0.37</span>],                         [<span class="hljs-number">0.593</span>, <span class="hljs-number">0.042</span>],                         [<span class="hljs-number">0.719</span>, <span class="hljs-number">0.103</span>, ]], dtype=object)        labels = np.array([<span class="hljs-string">'是'</span>, <span class="hljs-string">'是'</span>, <span class="hljs-string">'是'</span>, <span class="hljs-string">'是'</span>, <span class="hljs-string">'是'</span>, <span class="hljs-string">'是'</span>, <span class="hljs-string">'是'</span>, <span class="hljs-string">'是'</span>,                           <span class="hljs-string">'否'</span>, <span class="hljs-string">'否'</span>, <span class="hljs-string">'否'</span>, <span class="hljs-string">'否'</span>, <span class="hljs-string">'否'</span>, <span class="hljs-string">'否'</span>, <span class="hljs-string">'否'</span>, <span class="hljs-string">'否'</span>, <span class="hljs-string">'否'</span>], dtype=object)        label_names = np.array([<span class="hljs-string">"密度"</span>, <span class="hljs-string">"含糖率"</span>], dtype=object)    <span class="hljs-keyword">if</span> type == <span class="hljs-number">2</span>:        data = np.array([[<span class="hljs-string">'1'</span>, <span class="hljs-string">'青绿'</span>, <span class="hljs-string">'蜷缩'</span>, <span class="hljs-string">'浊响'</span>, <span class="hljs-string">'清晰'</span>, <span class="hljs-string">'凹陷'</span>, <span class="hljs-string">'硬滑'</span>],                         [<span class="hljs-string">'2'</span>, <span class="hljs-string">'乌黑'</span>, <span class="hljs-string">'蜷缩'</span>, <span class="hljs-string">'沉闷'</span>, <span class="hljs-string">'清晰'</span>, <span class="hljs-string">'凹陷'</span>, <span class="hljs-string">'硬滑'</span>],                         [<span class="hljs-string">'3'</span>, <span class="hljs-string">'乌黑'</span>, <span class="hljs-string">'蜷缩'</span>, <span class="hljs-string">'浊响'</span>, <span class="hljs-string">'清晰'</span>, <span class="hljs-string">'凹陷'</span>, <span class="hljs-string">'硬滑'</span>],                         [<span class="hljs-string">'4'</span>, <span class="hljs-string">'青绿'</span>, <span class="hljs-string">'蜷缩'</span>, <span class="hljs-string">'沉闷'</span>, <span class="hljs-string">'清晰'</span>, <span class="hljs-string">'凹陷'</span>, <span class="hljs-string">'硬滑'</span>],                         [<span class="hljs-string">'5'</span>, <span class="hljs-string">'浅白'</span>, <span class="hljs-string">'蜷缩'</span>, <span class="hljs-string">'浊响'</span>, <span class="hljs-string">'清晰'</span>, <span class="hljs-string">'凹陷'</span>, <span class="hljs-string">'硬滑'</span>],                         [<span class="hljs-string">'6'</span>, <span class="hljs-string">'青绿'</span>, <span class="hljs-string">'稍蜷'</span>, <span class="hljs-string">'浊响'</span>, <span class="hljs-string">'清晰'</span>, <span class="hljs-string">'稍凹'</span>, <span class="hljs-string">'软粘'</span>],                         [<span class="hljs-string">'7'</span>, <span class="hljs-string">'乌黑'</span>, <span class="hljs-string">'稍蜷'</span>, <span class="hljs-string">'浊响'</span>, <span class="hljs-string">'稍糊'</span>, <span class="hljs-string">'稍凹'</span>, <span class="hljs-string">'软粘'</span>],                         [<span class="hljs-string">'8'</span>, <span class="hljs-string">'乌黑'</span>, <span class="hljs-string">'稍蜷'</span>, <span class="hljs-string">'浊响'</span>, <span class="hljs-string">'清晰'</span>, <span class="hljs-string">'稍凹'</span>, <span class="hljs-string">'硬滑'</span>],                         [<span class="hljs-string">'9'</span>, <span class="hljs-string">'乌黑'</span>, <span class="hljs-string">'稍蜷'</span>, <span class="hljs-string">'沉闷'</span>, <span class="hljs-string">'稍糊'</span>, <span class="hljs-string">'稍凹'</span>, <span class="hljs-string">'硬滑'</span>],                         [<span class="hljs-string">'10'</span>, <span class="hljs-string">'青绿'</span>, <span class="hljs-string">'硬挺'</span>, <span class="hljs-string">'清脆'</span>, <span class="hljs-string">'清晰'</span>, <span class="hljs-string">'平坦'</span>, <span class="hljs-string">'软粘'</span>],                         [<span class="hljs-string">'11'</span>, <span class="hljs-string">'浅白'</span>, <span class="hljs-string">'硬挺'</span>, <span class="hljs-string">'清脆'</span>, <span class="hljs-string">'模糊'</span>, <span class="hljs-string">'平坦'</span>, <span class="hljs-string">'硬滑'</span>],                         [<span class="hljs-string">'12'</span>, <span class="hljs-string">'浅白'</span>, <span class="hljs-string">'蜷缩'</span>, <span class="hljs-string">'浊响'</span>, <span class="hljs-string">'模糊'</span>, <span class="hljs-string">'平坦'</span>, <span class="hljs-string">'软粘'</span>],                         [<span class="hljs-string">'13'</span>, <span class="hljs-string">'青绿'</span>, <span class="hljs-string">'稍蜷'</span>, <span class="hljs-string">'浊响'</span>, <span class="hljs-string">'稍糊'</span>, <span class="hljs-string">'凹陷'</span>, <span class="hljs-string">'硬滑'</span>],                         [<span class="hljs-string">'14'</span>, <span class="hljs-string">'浅白'</span>, <span class="hljs-string">'稍蜷'</span>, <span class="hljs-string">'沉闷'</span>, <span class="hljs-string">'稍糊'</span>, <span class="hljs-string">'凹陷'</span>, <span class="hljs-string">'硬滑'</span>],                         [<span class="hljs-string">'15'</span>, <span class="hljs-string">'乌黑'</span>, <span class="hljs-string">'稍蜷'</span>, <span class="hljs-string">'浊响'</span>, <span class="hljs-string">'清晰'</span>, <span class="hljs-string">'稍凹'</span>, <span class="hljs-string">'软粘'</span>],                         [<span class="hljs-string">'16'</span>, <span class="hljs-string">'浅白'</span>, <span class="hljs-string">'蜷缩'</span>, <span class="hljs-string">'浊响'</span>, <span class="hljs-string">'模糊'</span>, <span class="hljs-string">'平坦'</span>, <span class="hljs-string">'硬滑'</span>],                         [<span class="hljs-string">'17'</span>, <span class="hljs-string">'青绿'</span>, <span class="hljs-string">'蜷缩'</span>, <span class="hljs-string">'沉闷'</span>, <span class="hljs-string">'稍糊'</span>, <span class="hljs-string">'稍凹'</span>, <span class="hljs-string">'硬滑'</span>]], dtype=object)        labels = np.array([<span class="hljs-string">'是'</span>, <span class="hljs-string">'是'</span>, <span class="hljs-string">'是'</span>, <span class="hljs-string">'是'</span>, <span class="hljs-string">'是'</span>, <span class="hljs-string">'是'</span>, <span class="hljs-string">'是'</span>, <span class="hljs-string">'是'</span>,                           <span class="hljs-string">'否'</span>, <span class="hljs-string">'否'</span>, <span class="hljs-string">'否'</span>, <span class="hljs-string">'否'</span>, <span class="hljs-string">'否'</span>, <span class="hljs-string">'否'</span>, <span class="hljs-string">'否'</span>, <span class="hljs-string">'否'</span>, <span class="hljs-string">'否'</span>], dtype=object)        label_names = np.array(            [<span class="hljs-string">'ID'</span>, <span class="hljs-string">'色泽'</span>, <span class="hljs-string">'根蒂'</span>, <span class="hljs-string">'敲声'</span>, <span class="hljs-string">'纹理'</span>, <span class="hljs-string">'脐部'</span>, <span class="hljs-string">'触感'</span>], dtype=object)    <span class="hljs-keyword">return</span> data, labels, label_names<span class="hljs-comment"># In[36]:</span><span class="hljs-comment"># 定义判断结点形状,其中boxstyle表示文本框类型,fc指的是注释框颜色的深度</span>decisionNode = dict(boxstyle=<span class="hljs-string">"round4"</span>, color=<span class="hljs-string">'r'</span>, fc=<span class="hljs-string">'0.9'</span>)<span class="hljs-comment"># 定义叶结点形状</span>leafNode = dict(boxstyle=<span class="hljs-string">"circle"</span>, color=<span class="hljs-string">'m'</span>)<span class="hljs-comment"># 定义父节点指向子节点或叶子的箭头形状</span>arrow_args = dict(arrowstyle=<span class="hljs-string">"&lt;-"</span>, color=<span class="hljs-string">'g'</span>)<span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">plot_node</span><span class="hljs-params">(node_txt, center_point, parent_point, node_style)</span>:</span>    <span class="hljs-string">"""    plot_node 绘制父子节点，节点间的箭头，并填充箭头中间上的文本    :param node_txt: 文本内容    :param center_point: 文本中心点    :param parent_point: 指向文本中心的点    """</span>    createPlot.ax1.annotate(node_txt,                            xy=parent_point,                            xycoords=<span class="hljs-string">'axes fraction'</span>,                            xytext=center_point,                            textcoords=<span class="hljs-string">'axes fraction'</span>,                            va=<span class="hljs-string">"center"</span>,                            ha=<span class="hljs-string">"center"</span>,                            bbox=node_style,                            arrowprops=arrow_args,                            weight=<span class="hljs-string">'demi'</span>)<span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">get_leafs_num</span><span class="hljs-params">(tree_dict)</span>:</span>    <span class="hljs-string">"""    get_leafs_num 递归计算叶节点的个数    :param tree_dict: 决策树的字典形式    :return: tree_dict: 叶节点总个数    """</span>    <span class="hljs-comment"># tree_dict的叶节点总数</span>    leafs_num = <span class="hljs-number">0</span>    <span class="hljs-keyword">for</span> key, value <span class="hljs-keyword">in</span> tree_dict.items():        <span class="hljs-keyword">if</span> key == <span class="hljs-string">'feature_name'</span>:            <span class="hljs-keyword">continue</span>        <span class="hljs-comment"># 检测子树是否字典型</span>        <span class="hljs-keyword">elif</span> type(value).__name__ == <span class="hljs-string">'dict'</span>:            <span class="hljs-comment"># 子树是字典型，则当前树的叶节点数加上此子树的叶节点数</span>            leafs_num += get_leafs_num(value)        <span class="hljs-keyword">else</span>:            <span class="hljs-comment"># 子树不是字典型，则当前树的叶节点数加1</span>            leafs_num += <span class="hljs-number">1</span>    <span class="hljs-comment"># 返回tree_dict的叶节点总数</span>    <span class="hljs-keyword">return</span> leafs_num<span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">get_tree_max_depth</span><span class="hljs-params">(tree_dict)</span>:</span>    <span class="hljs-string">"""    get_tree_max_depth 求树的最深层数    :param tree_dict: 树的字典存储    :return: tree_dict: 最深层数    """</span>    <span class="hljs-comment"># tree_dict的最深层数</span>    max_depth = <span class="hljs-number">0</span>    <span class="hljs-keyword">for</span> key, value <span class="hljs-keyword">in</span> tree_dict.items():        <span class="hljs-comment"># 树的当前分支的层数</span>        this_path_depth = <span class="hljs-number">0</span>        <span class="hljs-comment"># 检测子树是否字典型</span>        <span class="hljs-keyword">if</span> type(value).__name__ == <span class="hljs-string">'dict'</span>:            <span class="hljs-comment"># 如果子树是字典型，则当前分支的层数需要加上子树的最深层数</span>            this_path_depth = <span class="hljs-number">1</span> + get_tree_max_depth(value)        <span class="hljs-keyword">else</span>:            <span class="hljs-comment"># 如果子树不是字典型，则是叶节点，则当前分支的层数为1</span>            this_path_depth = <span class="hljs-number">1</span>        <span class="hljs-keyword">if</span> this_path_depth &gt; max_depth:            max_depth = this_path_depth    <span class="hljs-keyword">return</span> max_depth<span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">plot_mid_text</span><span class="hljs-params">(center_point, parent_point, txt_str)</span>:</span>    <span class="hljs-string">"""    plot_mid_text 计算父节点和子节点的中间位置，并在父子节点间填充文本信息    :param center_point: 文本中心点    :param parent_point: 指向文本中心点的点    """</span>    x_mid = (parent_point[<span class="hljs-number">0</span>] - center_point[<span class="hljs-number">0</span>])/<span class="hljs-number">2.0</span> + center_point[<span class="hljs-number">0</span>]    y_mid = (parent_point[<span class="hljs-number">1</span>] - center_point[<span class="hljs-number">1</span>])/<span class="hljs-number">2.0</span> + center_point[<span class="hljs-number">1</span>]    createPlot.ax1.text(x_mid, y_mid, txt_str)    <span class="hljs-keyword">return</span><span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">plotTree</span><span class="hljs-params">(tree_dict, parent_point, node_txt)</span>:</span>    <span class="hljs-string">"""    plotTree 绘制树    :param tree_dict: 树    :param parent_point: 父节点位置    :param node_txt: 节点内容    """</span>    leafs_num = get_leafs_num(tree_dict)    <span class="hljs-comment"># root = list(tree_dict.keys())[0]</span>    root = tree_dict[<span class="hljs-string">'feature_name'</span>]    <span class="hljs-comment"># plotTree.totalW表示树的深度</span>    center_point = (plotTree.xOff+(<span class="hljs-number">1.0</span>+float(leafs_num)) /                    <span class="hljs-number">2.0</span>/plotTree.totalW, plotTree.yOff)    <span class="hljs-comment"># 填充node_txt内容</span>    plot_mid_text(center_point, parent_point, node_txt)    <span class="hljs-comment"># 绘制箭头上的内容</span>    plot_node(root, center_point, parent_point, decisionNode)    plotTree.yOff = plotTree.yOff<span class="hljs-number">-1.0</span>/plotTree.totalD    <span class="hljs-comment"># 因从上往下画，所以需要依次递减y的坐标值，plotTree.totalD表示存储树的深度</span>    <span class="hljs-keyword">for</span> key, value <span class="hljs-keyword">in</span> tree_dict.items():        <span class="hljs-keyword">if</span> key == <span class="hljs-string">'feature_name'</span>:            <span class="hljs-keyword">continue</span>        <span class="hljs-keyword">elif</span> type(value).__name__ == <span class="hljs-string">'dict'</span>:            plotTree(value, center_point, str(key))        <span class="hljs-keyword">else</span>:            plotTree.xOff = plotTree.xOff+<span class="hljs-number">1.0</span>/plotTree.totalW            plot_node(value, (plotTree.xOff, plotTree.yOff),                      center_point, leafNode)            plot_mid_text((plotTree.xOff, plotTree.yOff),                          center_point, str(key))    <span class="hljs-comment"># h绘制完所有子节点后，增加全局变量Y的偏移</span>    plotTree.yOff = plotTree.yOff+<span class="hljs-number">1.0</span>/plotTree.totalD    <span class="hljs-keyword">return</span><span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">createPlot</span><span class="hljs-params">(tree_dict)</span>:</span>    <span class="hljs-string">"""    createPlot 绘制决策树图形    :param tree_dict: 决策树的字典形式    """</span>    <span class="hljs-comment"># 设置绘图区域的背景色</span>    fig = plt.figure(figsize=(<span class="hljs-number">8</span>, <span class="hljs-number">8</span>), facecolor=<span class="hljs-string">'white'</span>)    <span class="hljs-comment"># 清空绘图区域</span>    fig.clf()    <span class="hljs-comment"># 定义横纵坐标轴,注意不要设置xticks和yticks的值!!!</span>    axprops = dict(xticks=[], yticks=[])    createPlot.ax1 = plt.subplot(<span class="hljs-number">111</span>, frameon=<span class="hljs-keyword">False</span>, **axprops)    <span class="hljs-comment"># 由全局变量createPlot.ax1定义一个绘图区，111表示一行一列的第一个，frameon表示边框,**axprops不显示刻度</span>    plotTree.totalW = float(get_leafs_num(tree_dict))    plotTree.totalD = float(get_tree_max_depth(tree_dict))    plotTree.xOff = <span class="hljs-number">-0.5</span>/plotTree.totalW    plotTree.yOff = <span class="hljs-number">1.0</span>    plotTree(tree_dict, (<span class="hljs-number">0.5</span>, <span class="hljs-number">1.0</span>), <span class="hljs-string">''</span>)    plt.show()</code></pre><h1 id="测试效果"><a href="#测试效果" class="headerlink" title="测试效果"></a>测试效果</h1><h2 id="ID3、C4-5、CART-决策树显示"><a href="#ID3、C4-5、CART-决策树显示" class="headerlink" title="ID3、C4.5、CART 决策树显示"></a>ID3、C4.5、CART 决策树显示</h2><p>使用课本 P76 西瓜数据集（不带序号）</p><h3 id="测试代码"><a href="#测试代码" class="headerlink" title="测试代码"></a>测试代码</h3><pre><code class="hljs python"><span class="hljs-keyword">from</span> DecisionTree <span class="hljs-keyword">import</span> createDataSet, DecisionTree, createPlotdata, label, names = createDataSet(<span class="hljs-number">0</span>)mtree = DecisionTree(data, label, names)mtree.loadTrainData()print(<span class="hljs-string">"打印ID3决策树字典形式"</span>)mtree.startCreateTree(method=<span class="hljs-string">'id3'</span>)print(mtree.tree)createPlot(mtree.tree)print(<span class="hljs-string">"打印C4.5决策树字典形式"</span>)mtree.startCreateTree(method=<span class="hljs-string">'c4.5'</span>)print(mtree.tree)createPlot(mtree.tree)print(<span class="hljs-string">"打印CART决策树字典形式"</span>)mtree.startCreateTree(method=<span class="hljs-string">'cart'</span>)print(mtree.tree)createPlot(mtree.tree)</code></pre><h3 id="测试结果"><a href="#测试结果" class="headerlink" title="测试结果"></a>测试结果</h3><pre><code class="hljs txt">打印ID3决策树字典形式&#123;&apos;feature_name&apos;: &apos;纹理&apos;, &apos;清晰&apos;: &#123;&apos;feature_name&apos;: &apos;根蒂&apos;, &apos;蜷缩&apos;: &apos;是&apos;, &apos;硬挺&apos;: &apos;否&apos;, &apos;稍蜷&apos;: &#123;&apos;feature_name&apos;: &apos;色泽&apos;, &apos;乌黑&apos;: &#123;&apos;feature_name&apos;: &apos;触感&apos;, &apos;软粘&apos;: &apos;否&apos;, &apos;硬滑&apos;: &apos;是&apos;&#125;, &apos;青绿&apos;: &apos;是&apos;&#125;&#125;, &apos;模糊&apos;: &apos;否&apos;, &apos;稍糊&apos;: &#123;&apos;feature_name&apos;: &apos;触感&apos;, &apos;软粘&apos;: &apos;是&apos;, &apos;硬滑&apos;: &apos;否&apos;&#125;&#125;</code></pre><p><img src="https://eddyblog.oss-cn-shenzhen.aliyuncs.com/MachineLearning/DecisionTree/decisiontree2.png" srcset="/img/loading.gif" alt="tree2"></p><pre><code class="hljs txt">打印C4.5决策树字典形式&#123;&apos;feature_name&apos;: &apos;纹理&apos;, &apos;清晰&apos;: &#123;&apos;feature_name&apos;: &apos;触感&apos;, &apos;软粘&apos;: &#123;&apos;feature_name&apos;: &apos;色泽&apos;, &apos;乌黑&apos;: &apos;否&apos;, &apos;青绿&apos;: &#123;&apos;feature_name&apos;: &apos;根蒂&apos;, &apos;硬挺&apos;: &apos;否&apos;, &apos;稍蜷&apos;: &apos;是&apos;&#125;&#125;, &apos;硬滑&apos;: &apos;是&apos;&#125;, &apos;模糊&apos;: &apos;否&apos;, &apos;稍糊&apos;: &#123;&apos;feature_name&apos;: &apos;触感&apos;, &apos;软粘&apos;: &apos;是&apos;, &apos;硬滑&apos;: &apos;否&apos;&#125;&#125;</code></pre><p><img src="https://eddyblog.oss-cn-shenzhen.aliyuncs.com/MachineLearning/DecisionTree/decisiontree3.png" srcset="/img/loading.gif" alt="tree3"></p><pre><code class="hljs txt">打印CART决策树字典形式&#123;&apos;feature_name&apos;: &apos;纹理&apos;, (&apos;=&apos;, &apos;清晰&apos;): &#123;&apos;feature_name&apos;: &apos;触感&apos;, (&apos;=&apos;, &apos;软粘&apos;): &#123;&apos;feature_name&apos;: &apos;色泽&apos;, (&apos;=&apos;, &apos;乌黑&apos;): &apos;否&apos;, (&apos;!=&apos;, &apos;乌黑&apos;): &#123;&apos;feature_name&apos;: &apos;根蒂&apos;, (&apos;=&apos;, &apos;硬挺&apos;): &apos;否&apos;, (&apos;!=&apos;, &apos;硬挺&apos;): &apos;是&apos;&#125;&#125;, (&apos;!=&apos;, &apos;软粘&apos;): &apos;是&apos;&#125;, (&apos;!=&apos;, &apos;清晰&apos;): &#123;&apos;feature_name&apos;: &apos;色泽&apos;, (&apos;=&apos;, &apos;乌黑&apos;): &#123;&apos;feature_name&apos;: &apos;敲声&apos;, (&apos;=&apos;, &apos;浊响&apos;): &apos;是&apos;, (&apos;!=&apos;, &apos;浊响&apos;): &apos;否&apos;&#125;, (&apos;!=&apos;, &apos;乌黑&apos;): &apos;否&apos;&#125;&#125;</code></pre><p><img src="https://eddyblog.oss-cn-shenzhen.aliyuncs.com/MachineLearning/DecisionTree/decisiontree4.png" srcset="/img/loading.gif" alt="tree4"></p><h3 id="结果分析"><a href="#结果分析" class="headerlink" title="结果分析"></a>结果分析</h3><p>如图，均成功构建了不同的决策树。</p><h2 id="ID3、C4-5-的属性偏好"><a href="#ID3、C4-5-的属性偏好" class="headerlink" title="ID3、C4.5 的属性偏好"></a>ID3、C4.5 的属性偏好</h2><p>使用课本 P76 西瓜数据集（带序号），尝试反应 ID3 和 C4.5 使用信息增益对于属性值取值多少的偏好</p><h3 id="测试代码-1"><a href="#测试代码-1" class="headerlink" title="测试代码"></a>测试代码</h3><pre><code class="hljs python"><span class="hljs-keyword">from</span> DecisionTree <span class="hljs-keyword">import</span> createDataSet, DecisionTree, createPlotdata, label, names = createDataSet(<span class="hljs-number">2</span>)mtree = DecisionTree(data, label, names)mtree.loadTrainData()mtree.startCreateTree(method=<span class="hljs-string">'id3'</span>)createPlot(mtree.tree)mtree.startCreateTree(method=<span class="hljs-string">'c4.5'</span>)createPlot(mtree.tree)</code></pre><h3 id="测试结果-1"><a href="#测试结果-1" class="headerlink" title="测试结果"></a>测试结果</h3><p><img src="https://eddyblog.oss-cn-shenzhen.aliyuncs.com/MachineLearning/DecisionTree/decisiontree5.png" srcset="/img/loading.gif" alt="tree5"></p><p><img src="https://eddyblog.oss-cn-shenzhen.aliyuncs.com/MachineLearning/DecisionTree/decisiontree6.png" srcset="/img/loading.gif" alt="tree6"></p><h3 id="结果分析-1"><a href="#结果分析-1" class="headerlink" title="结果分析"></a>结果分析</h3><p>如预测，ID3 划分依据喜好多属性值的属性，在一些情况下会导致泛化性过差，C4.5 采用的信息增益率对属性值少的更偏好，我的代码并没有完整复现 C4.5 的思想，正如课本 P78 所说。</p><blockquote><p>需注意的是，增益率准则对可取值数目较少的属性有所偏好，因此，C4.5 算法并不是直接选择增益率最大的候选划分属性，而是使用了一个启发式：<strong>先从候选划分属性中找到信息增益高于平均水平的属性，再从中选择增益率最高的。</strong></p></blockquote><h2 id="阈值限制测试"><a href="#阈值限制测试" class="headerlink" title="阈值限制测试"></a>阈值限制测试</h2><p>使用不带 id 的西瓜数据集，生成 ID3 决策树，代码中加入了 min_sample 的限制，当样本数量小于一定时选择里面的 major 类别代表该集合的类别，不再进一步划分。</p><h3 id="测试代码-2"><a href="#测试代码-2" class="headerlink" title="测试代码"></a>测试代码</h3><pre><code class="hljs python"><span class="hljs-keyword">from</span> DecisionTree <span class="hljs-keyword">import</span> createDataSet, DecisionTree, createPlotdata, label, names = createDataSet(<span class="hljs-number">2</span>)mtree = DecisionTree(data, label, names)mtree.loadTrainData()mtree.startCreateTree(method=<span class="hljs-string">'id3'</span>, min_sample=<span class="hljs-number">2</span>)createPlot(mtree.tree)mtree.startCreateTree(method=<span class="hljs-string">'id3'</span>, min_sample=<span class="hljs-number">3</span>)createPlot(mtree.tree)</code></pre><h3 id="测试结果-2"><a href="#测试结果-2" class="headerlink" title="测试结果"></a>测试结果</h3><p><img src="https://eddyblog.oss-cn-shenzhen.aliyuncs.com/MachineLearning/DecisionTree/decisiontree7.png" srcset="/img/loading.gif" alt="tree7"></p><p><img src="https://eddyblog.oss-cn-shenzhen.aliyuncs.com/MachineLearning/DecisionTree/decisiontree8.png" srcset="/img/loading.gif" alt="tree8"></p><h3 id="结果分析-2"><a href="#结果分析-2" class="headerlink" title="结果分析"></a>结果分析</h3><p>确实实现了一定程度上的简化</p><h2 id="连续值处理实现"><a href="#连续值处理实现" class="headerlink" title="连续值处理实现"></a>连续值处理实现</h2><p>对于现有集合的该连续值属性排序，然后枚举相邻两值的中点作为分界 point，属性值小于 point 的为一个集合，属性值大于 point 的为一个集合。然后计算两部分的信息增益（率），取该值最高的分界 point 作为该属性的分界 point 并返回。</p><p>数据集采用密度，含糖量集合，使用 ID3 决策树。</p><h3 id="测试代码-3"><a href="#测试代码-3" class="headerlink" title="测试代码"></a>测试代码</h3><pre><code class="hljs python"><span class="hljs-keyword">from</span> DecisionTree <span class="hljs-keyword">import</span> createDataSet, DecisionTree, createPlotdata, label, names = createDataSet(<span class="hljs-number">1</span>)mtree = DecisionTree(data, label, names)mtree.loadTrainData()mtree.startCreateTree(method=<span class="hljs-string">'id3'</span>)createPlot(mtree.tree)</code></pre><h3 id="测试结果-3"><a href="#测试结果-3" class="headerlink" title="测试结果"></a>测试结果</h3><p><img src="https://eddyblog.oss-cn-shenzhen.aliyuncs.com/MachineLearning/DecisionTree/decisiontree9.png" srcset="/img/loading.gif" alt="tree9"></p><h3 id="结果分析-3"><a href="#结果分析-3" class="headerlink" title="结果分析"></a>结果分析</h3><p>可以看到对连续值属性也做了分割，通过间值选择了最佳的分割位置。</p><h1 id="拓展"><a href="#拓展" class="headerlink" title="拓展"></a>拓展</h1><h2 id="预剪枝"><a href="#预剪枝" class="headerlink" title="预剪枝"></a>预剪枝</h2><h3 id="实现代码"><a href="#实现代码" class="headerlink" title="实现代码"></a>实现代码</h3><pre><code class="hljs python"><span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">createPrecutTree</span><span class="hljs-params">(self, train_data, train_label, test_data, test_label, names, method, min_sample)</span>:</span>    <span class="hljs-string">"""    createPrecutTree 构建当前预剪枝树结点    :param self: 类方法自带    :param train_data: 输入训练数据集    :param train_label: 输入训练标签集    :param test_data: 输入测试数据集    :param test_label: 输入测试标签集    :param names: 输入属性名集合    :param min_sample: 最小样本数量阈值    :return: 返回建立的节点    """</span>    train_data = np.array(train_data, dtype=object)    train_label = np.array(train_label, dtype=object)    test_data = np.array(test_data, dtype=object)    test_label = np.array(test_label, dtype=object)    names = np.array(names, dtype=object)    <span class="hljs-comment"># 相同类别</span>    <span class="hljs-keyword">if</span> len(set(train_label)) == <span class="hljs-number">1</span>:        <span class="hljs-keyword">return</span> train_label[<span class="hljs-number">0</span>]    <span class="hljs-comment"># 剩余样本量小于阈值</span>    <span class="hljs-keyword">if</span> train_data.size == <span class="hljs-number">0</span> <span class="hljs-keyword">or</span> train_label.size &lt;= min_sample:        <span class="hljs-keyword">return</span> self.majLabel(train_label)    <span class="hljs-comment"># 选取最优特征</span>    best_feature_index, best_feature_name, best_value, best_ent, best_point = self.chooseBest(        train_data, train_label, names, method)    <span class="hljs-comment"># 建立节点</span>    node = &#123;<span class="hljs-string">"feature_name"</span>: best_feature_name&#125;    child_train_data_set, child_train_label_set, child_name_set = self.splitData(        train_data, train_label, names, best_feature_index, best_feature_name, best_value, best_point, method)    main_train_label = self.majLabel(train_label)    <span class="hljs-comment"># 预剪枝衡量</span>    <span class="hljs-keyword">if</span> test_data <span class="hljs-keyword">is</span> <span class="hljs-keyword">None</span>:        <span class="hljs-keyword">for</span> feature_value <span class="hljs-keyword">in</span> child_train_data_set.keys():            <span class="hljs-comment"># 注意这里也要修改，不然后面节点都是无剪枝的</span>            node[feature_value] = self.createPrecutTree(                child_train_data_set[feature_value], child_train_label_set[feature_value], <span class="hljs-keyword">None</span>, <span class="hljs-keyword">None</span>, child_name_set, method, min_sample)    <span class="hljs-keyword">else</span>:        child_test_data_set, child_test_label_set, child_name_set = self.splitData(            test_data, test_label, names, best_feature_index, best_feature_name, best_value, best_point, method)        <span class="hljs-comment"># 划分前比率</span>        pre_cut_ratio = test_label[test_label ==                                   main_train_label].size/test_label.size        pos_cut_num = <span class="hljs-number">0</span>        <span class="hljs-keyword">for</span> feature <span class="hljs-keyword">in</span> child_train_label_set.keys():            <span class="hljs-keyword">if</span> feature <span class="hljs-keyword">not</span> <span class="hljs-keyword">in</span> child_test_label_set.keys():                <span class="hljs-keyword">continue</span>            now_test_label = child_test_label_set[feature]            now_majority_label = self.majLabel(now_test_label)            pos_cut_num += now_test_label[now_test_label ==                                          now_majority_label].size        pos_cut_ratio = pos_cut_num / test_label.size        print(<span class="hljs-string">"pre:  "</span>+str(pre_cut_ratio) +              <span class="hljs-string">"   post:   "</span>+str(pos_cut_ratio))        <span class="hljs-keyword">if</span>(pre_cut_ratio &gt;= pos_cut_ratio):            <span class="hljs-comment"># 验证机精确度没有提升</span>            <span class="hljs-keyword">return</span> main_train_label    <span class="hljs-keyword">for</span> feature_value <span class="hljs-keyword">in</span> child_train_data_set.keys():        <span class="hljs-comment"># 注意这里也要修改，不然后面节点都是无剪枝的</span>        node[feature_value] = self.createPrecutTree(            child_train_data_set[feature_value], child_train_label_set[feature_value], child_test_data_set[feature_value], child_test_label_set[feature_value], child_name_set, method, min_sample)    <span class="hljs-keyword">return</span> node</code></pre><h3 id="测试代码-4"><a href="#测试代码-4" class="headerlink" title="测试代码"></a>测试代码</h3><pre><code class="hljs python"><span class="hljs-keyword">from</span> DecisionTree <span class="hljs-keyword">import</span> createDataSet, DecisionTree, createPlotdata, label, names = createDataSet(<span class="hljs-number">0</span>)mtree = DecisionTree(data, label, names)mtree.loadTrainData(type=<span class="hljs-number">1</span>, sz=<span class="hljs-number">0.4</span>)mtree.startCreateTree(cut_type=<span class="hljs-number">0</span>, method=<span class="hljs-string">'id3'</span>)createPlot(mtree.tree)mtree.startCreateTree(cut_type=<span class="hljs-number">1</span>, method=<span class="hljs-string">'id3'</span>)createPlot(mtree.tree)</code></pre><h3 id="测试结果-4"><a href="#测试结果-4" class="headerlink" title="测试结果"></a>测试结果</h3><p><img src="https://eddyblog.oss-cn-shenzhen.aliyuncs.com/MachineLearning/DecisionTree/decisiontree11.png" srcset="/img/loading.gif" alt="tree10"></p><p><img src="https://eddyblog.oss-cn-shenzhen.aliyuncs.com/MachineLearning/DecisionTree/decisiontree11.png" srcset="/img/loading.gif" alt="tree11"></p>]]></content>
    
    
    <categories>
      
      <category>Computer Science</category>
      
      <category>机器学习</category>
      
    </categories>
    
    
    <tags>
      
      <tag>机器学习</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>WordPress——Hexo导出xml并迁移</title>
    <link href="/post/44da4894.html"/>
    <url>/post/44da4894.html</url>
    
    <content type="html"><![CDATA[<h1 id="Hexo-导出-xml"><a href="#Hexo-导出-xml" class="headerlink" title="Hexo 导出 xml"></a>Hexo 导出 xml</h1><h2 id="安装-feed-插件"><a href="#安装-feed-插件" class="headerlink" title="安装 feed 插件"></a>安装 feed 插件</h2><p>安装插件<code>hexo-generator-feed</code>。</p><pre><code class="hljs npm">npm install hexo-generator-feed</code></pre><h2 id="使用插件"><a href="#使用插件" class="headerlink" title="使用插件"></a>使用插件</h2><p>在<code>_config.yml</code>文件添加以下内容</p><pre><code class="hljs yaml"><span class="hljs-attr">plugins:</span>    <span class="hljs-string">hexo-generator-feed</span><span class="hljs-comment">#Feed Atom</span><span class="hljs-attr">feed:</span>    <span class="hljs-comment">#type: atom</span>    <span class="hljs-comment">#path: atom.xml</span>    <span class="hljs-comment">#limit: 20</span>    <span class="hljs-comment">#改为RSS2.0标准</span><span class="hljs-attr">    type:</span> <span class="hljs-string">rss2</span><span class="hljs-attr">    path:</span> <span class="hljs-string">rss2.xml</span><span class="hljs-attr">    limit:</span> <span class="hljs-literal">false</span><span class="hljs-attr">    hub:</span></code></pre><p><code>hexo g</code>完成后从<code>public</code>文件夹中找对应的文件<code>rss2.xml</code>。这个 xml 就可以用来做订阅或者导入 WP 了。</p><h1 id="WordPress-导入-xml"><a href="#WordPress-导入-xml" class="headerlink" title="WordPress 导入 xml"></a>WordPress 导入 xml</h1><p>登录到 WP 仪表盘（控制台），选择工具-&gt;导入-&gt;WordPress-&gt;现在安装-&gt;运行导入器</p><h1 id="解决单次导入限制-2M-问题"><a href="#解决单次导入限制-2M-问题" class="headerlink" title="解决单次导入限制 2M 问题"></a>解决单次导入限制 2M 问题</h1><p>根据官方解释，可能是 php 和 nginx 两方面原因</p><ol><li><p>php<br><a href="https://blog.csdn.net/Mike_Roger/article/details/80711299" target="_blank" rel="noopener">解除 wordpress 上传最大限制</a></p><p>访问 vps，找到 WP 根目录（很多 wp-xxx.php 的那个），编写文件<code>.user.ini</code>，写入如下内容：</p><pre><code class="hljs txt">; Memory and file sizes memory_limit = 64M upload_max_filesize = 5M post_max_size = 5M file_uploads = On max_execution_time = 300 ; End Upload Restrictions</code></pre></li><li><p>nginx</p><p>打开 nginx 服务的配置文件<code>nginx.conf</code>,http 块中加入<code>client_max_body_size xxm</code>, <code>xx</code>根据需求改动。</p></li></ol>]]></content>
    
    
    <categories>
      
      <category>Computer Science</category>
      
      <category>工具</category>
      
    </categories>
    
    
    <tags>
      
      <tag>工具</tag>
      
      <tag>WordPress</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>WordPress——网站搭建常见问题</title>
    <link href="/post/785396af.html"/>
    <url>/post/785396af.html</url>
    
    <content type="html"><![CDATA[<h2 id="安装-删除主题或者插件时需要-FTP-用户名密码"><a href="#安装-删除主题或者插件时需要-FTP-用户名密码" class="headerlink" title="安装/删除主题或者插件时需要 FTP 用户名密码"></a>安装/删除主题或者插件时需要 FTP 用户名密码</h2><p>安装好 WP 后，无论是安装插件还是安装主题都会弹出框：权限缺失，需要 FTP 用户名和密码。实际上时服务器权限设置的问题。</p><p><strong>解决方法 1：修改配置文件</strong></p><p>修改<code>wordpress</code>目录下的<code>wp-config.php</code>，加上如下三行：</p><pre><code class="hljs php">define(<span class="hljs-string">"FS_METHOD"</span>, <span class="hljs-string">"direct"</span>);define(<span class="hljs-string">"FS_CHMOD_DIR"</span>, <span class="hljs-number">0777</span>);define(<span class="hljs-string">"FS_CHMOD_FILE"</span>, <span class="hljs-number">0777</span>);</code></pre><p>实际上是在上传时候修改权限。</p><p><strong>解决方法 2：修改文件夹权限</strong></p><p>如果你的 WP 按默认方式或者大多数教程方式，则<code>/var/www/html/wordpress</code>应是你的根目录，修改根目录权限</p><pre><code class="hljs bash">sudo chmod -R 775 /var/www/html/wordpress</code></pre><h2 id="安装-删除主题或者插件时提示安装失败，无法创建目录"><a href="#安装-删除主题或者插件时提示安装失败，无法创建目录" class="headerlink" title="安装/删除主题或者插件时提示安装失败，无法创建目录"></a>安装/删除主题或者插件时提示安装失败，无法创建目录</h2><p>源自<a href="https://blog.csdn.net/qq_32846595/article/details/54766833" target="_blank" rel="noopener">解决 wordpress 下载插件，安装失败，无法创建目录问题</a></p><blockquote><p>其实，出现无法创建目录的确是权限的问题，但是，不是目录读写的权限，而是用户组的问题。想要下载插件的用户组为 web 用户组，用户名组名为 www（大家可能不太一样，如果是按照我之前的方式装 lnmp 环境的同学，就是 www，可以在 ngnix.conf 中第一行查看，至于 nginx.conf 的位置就用 locate nginx.conf 搜索一下） ，而此时 wordpress 用户组为 root，这样就不能创建目录了，具体原因大家可以查阅 linux 相关知识。</p></blockquote><p>查阅自己的<code>nginx.conf</code>文件确定用户，我的是<code>www-data</code>，所以在<code>/var/www/html</code>路径下修改<code>wordpress</code>文件夹的用户组就可以了。</p><pre><code class="hljs bash">sudo chown -R www-data:www-data wordpress</code></pre>]]></content>
    
    
    <categories>
      
      <category>Computer Science</category>
      
      <category>工具</category>
      
    </categories>
    
    
    <tags>
      
      <tag>工具</tag>
      
      <tag>WordPress</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>建国七十周年，我在思考什么</title>
    <link href="/post/360c9b8d.html"/>
    <url>/post/360c9b8d.html</url>
    
    <content type="html"><![CDATA[<p>本文写于<a href="https://www.edwardzcn98yx.com/post/8bb234ab.html">我的 UbuntuToGo 系统</a>，VScode 编辑器。</p><h1 id="建国七十周年，我在思考什么"><a href="#建国七十周年，我在思考什么" class="headerlink" title="建国七十周年，我在思考什么"></a>建国七十周年，我在思考什么</h1><p>2019 年的夏天，注定是个不平凡的夏天。</p><p>退出校队，濒临失学，再度分手，或许多年以后再看此时遭遇的这些挫折，都算不了什么，但是后来人说今日事未免有了些时间对伤口的消毒处理，虽然缓慢，总是愈合了些的。</p><p>人不仅软弱，而且健忘，但是文字不同，日久弥新，越发坚实可靠。或许就是因为对文字这样的印象（或许是德池老师给的？），我才会扛着这从高中就不被人看好的文字功力，坚持经营着自己的博客吧。</p><p>仅以文字祭奠过去的种种。</p><h2 id="意外相遇"><a href="#意外相遇" class="headerlink" title="意外相遇"></a>意外相遇</h2><p>建国七十周年，我既没有选择和国旗和张影，也没有选择给头像一见生成一面国旗，相反，我的社交平台上对“国庆”二字丝毫没有提及，甚至对铺天盖地而来的“祖国万岁”等呼声有一些嗤之以鼻。</p><p>我开始质问自己：</p><ul><li><strong>为什么你对国庆看似无动于衷？</strong></li><li><strong>为什么你对这些行为嗤之以鼻？</strong></li></ul><p>以及由这些问题引出的一些深层次的问题</p><ul><li><strong>什么是爱国主义（Patriotism）？</strong></li><li><strong>怎样算爱国行为？</strong></li><li><strong>我爱国吗？</strong></li></ul><hr><p>  无论我曾经有没有回答过自己，那些答案都没能给我留下足够深刻的印象以至我现在一九迷茫</p><p>我开始从自己反映的表象螺旋盘问自己，希望弄清点什么。</p><p>现在是 10 月 2 号晚上 8 点 42 分。</p><p>最后还是没能摆脱自己的拖延症，已经返程，目的与结果相差甚远的一场旅行，虽有收获，遗憾也留下很多。</p>]]></content>
    
    
    <categories>
      
      <category>Life</category>
      
      <category>随笔</category>
      
    </categories>
    
    
    <tags>
      
      <tag>随笔</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>UbuntuToGo——Ubuntu系统配置与UI美化</title>
    <link href="/post/f9c435a6.html"/>
    <url>/post/f9c435a6.html</url>
    
    <content type="html"><![CDATA[<p>本文写于<a href="https://www.edwardzcn98yx.com/post/8bb234ab.html">我的 UbuntuToGo 系统</a>，VScode 编辑器。</p><h1 id="系统配置"><a href="#系统配置" class="headerlink" title="系统配置"></a>系统配置</h1><p>如果想把手上做的这个 UbuntuToGo 做成随时随地插电脑就可以工作的 OS，首先不能忍的是软件包的下载速度。</p><p>我们需要把默认源更换为国内源。</p><h2 id="更换源"><a href="#更换源" class="headerlink" title="更换源"></a>更换源</h2><h3 id="阿里源"><a href="#阿里源" class="headerlink" title="阿里源"></a>阿里源</h3><pre><code class="hljs bash">deb http://mirrors.aliyun.com/ubuntu/ bionic main restricted universe multiversedeb http://mirrors.aliyun.com/ubuntu/ bionic-security main restricted universe multiversedeb http://mirrors.aliyun.com/ubuntu/ bionic-updates main restricted universe multiversedeb http://mirrors.aliyun.com/ubuntu/ bionic-proposed main restricted universe multiversedeb http://mirrors.aliyun.com/ubuntu/ bionic-backports main restricted universe multiversedeb-src http://mirrors.aliyun.com/ubuntu/ bionic main restricted universe multiversedeb-src http://mirrors.aliyun.com/ubuntu/ bionic-security main restricted universe multiversedeb-src http://mirrors.aliyun.com/ubuntu/ bionic-updates main restricted universe multiversedeb-src http://mirrors.aliyun.com/ubuntu/ bionic-proposed main restricted universe multiversedeb-src http://mirrors.aliyun.com/ubuntu/ bionic-backports main restricted universe multiverse</code></pre><a id="more"></a><h3 id="清华源"><a href="#清华源" class="headerlink" title="清华源"></a>清华源</h3><pre><code class="hljs bash">deb https://mirrors.tuna.tsinghua.edu.cn/ubuntu/ bionic main restricted universe multiversedeb-src https://mirrors.tuna.tsinghua.edu.cn/ubuntu/ bionic main restricted universe multiversedeb https://mirrors.tuna.tsinghua.edu.cn/ubuntu/ bionic-updates main restricted universe multiversedeb-src https://mirrors.tuna.tsinghua.edu.cn/ubuntu/ bionic-updates main restricted universe multiversedeb https://mirrors.tuna.tsinghua.edu.cn/ubuntu/ bionic-backports main restricted universe multiversedeb-src https://mirrors.tuna.tsinghua.edu.cn/ubuntu/ bionic-backports main restricted universe multiversedeb https://mirrors.tuna.tsinghua.edu.cn/ubuntu/ bionic-security main restricted universe multiversedeb-src https://mirrors.tuna.tsinghua.edu.cn/ubuntu/ bionic-security main restricted universe multiversedeb https://mirrors.tuna.tsinghua.edu.cn/ubuntu/ bionic-proposed main restricted universe multiversedeb-src https://mirrors.tuna.tsinghua.edu.cn/ubuntu/ bionic-proposed main restricted universe multiverse</code></pre><h3 id="更新-apt-get"><a href="#更新-apt-get" class="headerlink" title="更新 apt-get"></a>更新 apt-get</h3><pre><code class="hljs bash">sudo apt-get updatesudo apt-get upgrade</code></pre><h2 id="更换-shell-为-zsh"><a href="#更换-shell-为-zsh" class="headerlink" title="更换 shell 为 zsh"></a>更换 shell 为 zsh</h2><p><del>其实我只是为了好看一些</del>，网传 zsh 是最好用<del>究极</del>的 shell，顺手安了一波，而且配上 oh-my-zsh，简直不要太好看。</p><h3 id="zsh-的下载与安装"><a href="#zsh-的下载与安装" class="headerlink" title="zsh 的下载与安装"></a>zsh 的下载与安装</h3><p>我使用的是<code>apt-get install</code>的方法，Ubuntu18.04 换源更新完以后安装 zsh 版本为 5.4.2，也不算很久，主要是安装起来方便一些。</p><pre><code class="hljs bash">sudo apt-get install zsh</code></pre><p><img src="https://eddyblog.oss-cn-shenzhen.aliyuncs.com/UbuntuToGo/UI_1.png" srcset="/img/loading.gif" alt="UI_1"></p><h3 id="更换默认-Shell"><a href="#更换默认-Shell" class="headerlink" title="更换默认 Shell"></a>更换默认 Shell</h3><p>安装完成后，我们需要把默认 shell 改为 zsh。</p><pre><code class="hljs bash">chsh -s /bin/zsh</code></pre><p><strong>注意</strong>：这里不要使用 sudo</p><p>这样 zsh 就安装完成了～，还没有深入研究 zsh，不过一个快捷的地方就是数字 1，2，3 可以使你访问到最近常去的目录，还是比较方便的。</p><h2 id="美化-zsh"><a href="#美化-zsh" class="headerlink" title="美化 zsh"></a>美化 zsh</h2><p>当初吸引我去安装 zsh 就是因为它的美化可以显示 git 目录的分支、提交状态，真的炫到我了，就像下面这张图一样：</p><p><img src="https://eddyblog.oss-cn-shenzhen.aliyuncs.com/UbuntuToGo/UI_2.png" srcset="/img/loading.gif" alt="UI_2"></p><h3 id="安装-oh-my-zsh"><a href="#安装-oh-my-zsh" class="headerlink" title="安装 oh-my-zsh"></a>安装 oh-my-zsh</h3><p>使用命令</p><pre><code class="hljs bash">sh -c <span class="hljs-string">"<span class="hljs-variable">$(wget -O- https://raw.githubusercontent.com/robbyrussell/oh-my-zsh/master/tools/install.sh)</span>"</span></code></pre><h3 id="主题配置"><a href="#主题配置" class="headerlink" title="主题配置"></a>主题配置</h3><p>_Note: many themes require installing the Powerline Fonts in order to render properly._</p><p>注意：许多主题要求安装 Powerline Fonts，缺少字体而产生的乱码请安装字体后再做尝试。</p><p>我们需要编辑<code>~/.zshrc</code>文件：</p><p>修改其中的<code>ZSH_THEME=&quot;robbyrussell&quot;</code>为指定的样式</p><pre><code class="hljs bash">sudo vim ~/.zshrc</code></pre><p><img src="https://eddyblog.oss-cn-shenzhen.aliyuncs.com/UbuntuToGo/UI_3.png" srcset="/img/loading.gif" alt="UI_3"></p><p>当然，根据官网教程，你也可以来个随即 RP 主题：</p><p><img src="https://eddyblog.oss-cn-shenzhen.aliyuncs.com/UbuntuToGo/UI_4.png" srcset="/img/loading.gif" alt="UI_4"></p><p>然后<code>source ~/.zshrc</code>即可。</p><h2 id="美化-Grub"><a href="#美化-Grub" class="headerlink" title="美化 Grub"></a>美化 Grub</h2><p>根据这篇文章：<a href="https://blog.csdn.net/GenuineMonster/article/details/83685479" target="_blank" rel="noopener">Grub2 主题修改和美化</a></p><p>学习了一下引导界面的美化。</p><h3 id="下载-grub-主题包"><a href="#下载-grub-主题包" class="headerlink" title="下载 grub 主题包"></a>下载 grub 主题包</h3><p>从<a href="https://www.gnome-look.org/browse/cat/109/" target="_blank" rel="noopener">gnome-look.org</a>选择自己喜欢的主题下载。</p><p><img src="https://eddyblog.oss-cn-shenzhen.aliyuncs.com/UbuntuToGo/UI_5.png" srcset="/img/loading.gif" alt="UI_5"></p><p>发现了一个宝藏设计师：<a href="https://github.com/vinceliuice" target="_blank" rel="noopener">Vince 刘</a>。他设计的几款我觉得都蛮好看的。</p><p>费话不多说，开始美化我们的 grub 界面。</p><h3 id="创建-themes-文件夹"><a href="#创建-themes-文件夹" class="headerlink" title="创建 themes 文件夹"></a>创建 themes 文件夹</h3><p><code>ctrl</code>+<code>alt</code>+<code>T</code>打开终端，输入以下命令：</p><pre><code class="hljs bash">sudo mkdir /boot/grub/themes</code></pre><h3 id="解压主题包"><a href="#解压主题包" class="headerlink" title="解压主题包"></a>解压主题包</h3><p>在主题包压缩文件所在位置（我的是<code>~/Downloads</code>）使用对应命令解压主题包：</p><pre><code class="hljs bash">sudo tar -xf xxx.tar.gz</code></pre><p>或者</p><pre><code class="hljs bash">sudo unzip xxx.zip</code></pre><h3 id="移动主题包至指定目录"><a href="#移动主题包至指定目录" class="headerlink" title="移动主题包至指定目录"></a>移动主题包至指定目录</h3><p>执行命令</p><pre><code class="hljs bash">sudo cp -rf 主题包名 /boot/grub/themes</code></pre><p><strong>注意</strong>： -rf 是递归强制强目录里所有文件也拷贝至目标位置，没有参数会报错。</p><h3 id="执行脚本-配置文件"><a href="#执行脚本-配置文件" class="headerlink" title="执行脚本/配置文件"></a>执行脚本/配置文件</h3><ol><li><p>针对包内已经有 theme.txt 文件的主题</p><p>比如<code>poly-light-master</code>主题，cp 文件后，直接修改配置文件：</p><pre><code class="hljs bash">sudo vim /etc/grub.d/00_header</code></pre><p>在首页注释后添加</p><pre><code class="hljs bash">GRUB_THEME=<span class="hljs-string">"/boot/grub/themes/主题包名/theme.txt"</span>GRUB_GFXMODE=<span class="hljs-string">"1920x1080x32"</span></code></pre></li><li><p>针对包内无 theme.txt 文件的主题</p><p>比如 Vince 设计的几款，需要在进入文件目录内执行脚本</p><pre><code class="hljs bash">udo ./install-xxx.sh</code></pre><p>具体看文件名，完成后会在 themes 出现一个新的目录，如下图：</p><p><img src="https://eddyblog.oss-cn-shenzhen.aliyuncs.com/UbuntuToGo/UI_6.png" srcset="/img/loading.gif" alt="UI_6"></p><p>再根据 1 修改配置文件即可。</p></li></ol><h3 id="效果展示"><a href="#效果展示" class="headerlink" title="效果展示"></a>效果展示</h3><p>示意图</p><p><img src="https://eddyblog.oss-cn-shenzhen.aliyuncs.com/UbuntuToGo/UI_7.jpg" srcset="/img/loading.gif" alt="UI_7"></p>]]></content>
    
    
    <categories>
      
      <category>Computer Science</category>
      
      <category>操作系统</category>
      
    </categories>
    
    
    <tags>
      
      <tag>操作系统</tag>
      
      <tag>Linux</tag>
      
      <tag>UbuntuToGo</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>UbuntuToGo——打造属于自己的移动固态热插拔Liniux操作系统</title>
    <link href="/post/8bb234ab.html"/>
    <url>/post/8bb234ab.html</url>
    
    <content type="html"><![CDATA[<p>本文写于<a href="https://www.edwardzcn98yx.com/post/8bb234ab.html">我的 UbuntuToGo 系统</a>，VScode 编辑器。</p><h1 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h1><p>暑假末期给自己的戴尔游匣老本子换了西数固态，退役下来的一块 Toshiba 128G 的老固态成了闲置，拿来当移动硬盘总觉得有些浪费。恰好这时候一个室友做了个 WinToGo，“移动硬盘，移动系统，即插即用”，听起来很美妙的样子，便想着可否做个 Ubuntu 的移动版。</p><p>网上找了几篇资料给了我不小的启发，也算是顺着上面的教程<del>加上自己的摸爬滚打</del>完成的。</p><p><a href="https://mzz.pub/2017/12/22/justplay/mobileubuntu/" target="_blank" rel="noopener">把 Ubuntu16.04 装进移动硬盘的惨痛实战</a></p><p>感谢先驱者的宝贵经验。</p><h1 id="准备工作"><a href="#准备工作" class="headerlink" title="准备工作"></a>准备工作</h1><p>本文采用 U 盘引导 UEFI 安装的方式，希望虚拟机安装或者<del>想用</del>需要用 Legancy 启动的童鞋请参见这两篇文章：<a href="https://www.ithome.com/html/win10/316637.htm" target="_blank" rel="noopener">IT 之家学院：制作同时适用于 Legacy/UEFI 的 Ubuntu To Go 启动盘</a>，<a href="https://www.littleqiu.net/archives/771#]" target="_blank" rel="noopener">Ubuntu To Go | 制作属于你的随身 Ubuntu 系统盘</a></p><ol><li><strong>启动 U 盘</strong>：一个 32G 的 Ubuntu 系统启动盘（需格式化）</li><li><strong>移动 SSD</strong>：一个 128G 东芝的 SSD+硬盘盒（买壳子注意 M.2 接口类型以及支持协议，老的 SSD 并不是 NVMe 协议的，原理上只需要盘中有未分配空间即可，实操中建议先行备份以防杯具）</li><li><strong>Ubuntu 系统镜像</strong>文件：<a href="https://cn.ubuntu.com/download" target="_blank" rel="noopener">Ubuntu 桌面下载 18.04.3 LTS</a></li><li><strong>启动盘制作软件 Rufus</strong>：官网下载<a href="http://rufus.ie" target="_blank" rel="noopener">Rufus3.8</a></li><li><strong>你的脑子</strong></li></ol><p><img src="https://eddyblog.oss-cn-shenzhen.aliyuncs.com/UbuntuToGo/Ubuntu_1.png" srcset="/img/loading.gif" alt="Ubuntu_1"></p><p><img src="https://eddyblog.oss-cn-shenzhen.aliyuncs.com/UbuntuToGo/Ubuntu_2.png" srcset="/img/loading.gif" alt="Ubuntu_2"></p><a id="more"></a><h1 id="制作启动盘"><a href="#制作启动盘" class="headerlink" title="制作启动盘"></a>制作启动盘</h1><p>下载好我们需要的镜像文件后，插入 U 盘，进行刻录（下图中是以硬盘为例，具体使用时无需点选显示外接硬盘，选择对应 U 盘即可）</p><p><img src="https://eddyblog.oss-cn-shenzhen.aliyuncs.com/UbuntuToGo/Ubuntu_3.gif" srcset="/img/loading.gif" alt="Ubuntu_3"></p><h1 id="安装-Ubuntu"><a href="#安装-Ubuntu" class="headerlink" title="安装 Ubuntu"></a>安装 Ubuntu</h1><h2 id="选择试用-Ubuntu-系统"><a href="#选择试用-Ubuntu-系统" class="headerlink" title="选择试用 Ubuntu 系统"></a>选择试用 Ubuntu 系统</h2><p>完成启动 U 盘制作后重启，进入 BIOS 界面（品牌机子 logo 处按对应键，一般为 F2，F9，F12 等，自行查手册），然后选择引导为 UEFI 并选择 Secure Off。</p><p>然后选择 U 盘启动项，grub 菜单选择 Try Ubuntu（试用 Ubuntu），进入试用的 Ubuntu 18.04 主界面。桌面上应该有一个 Install，这样操作的原因是为了避免直接安装 Ubuntu 过程中采用默认方案与原 Windows 整合 EFI 导致拔出硬盘后无法启动，且分区无法调整。</p><p><img src="https://eddyblog.oss-cn-shenzhen.aliyuncs.com/UbuntuToGo/Ubuntu_4.png" srcset="/img/loading.gif" alt="Ubuntu_4"></p><h2 id="Gparted-分区调整确认"><a href="#Gparted-分区调整确认" class="headerlink" title="Gparted 分区调整确认"></a>Gparted 分区调整确认</h2><p>建议使用试用系统上自带的分区调整工具：Gparted 进行分区的调整，如对 SSD 移动硬盘划分空闲区域与分区，确认设备名称等（sdx/nvmex）。</p><p>已经安装完成的系统好像并不能启动 Gparted（<del>实际上是我不会</del>），就不放图了。</p><h2 id="自定义安装-Ubuntu"><a href="#自定义安装-Ubuntu" class="headerlink" title="自定义安装 Ubuntu"></a>自定义安装 Ubuntu</h2><p>双机桌面的 Install Ubuntu，进入安装，网速差的建议不联 Wifi 进行安装，后续换源后提速再安装其他必要包（比如语言包）。</p><p>建议选择英文，避免命令行、文件路径出现一些迷之错误。</p><p><img src="https://eddyblog.oss-cn-shenzhen.aliyuncs.com/UbuntuToGo/Ubuntu_5.png" srcset="/img/loading.gif" alt="Ubuntu_5"></p><p><img src="https://eddyblog.oss-cn-shenzhen.aliyuncs.com/UbuntuToGo/Ubuntu_6.png" srcset="/img/loading.gif" alt="Ubuntu_6"></p><p>记得选择其他方式安装，不与现有系统（Windows）整合或者格式化当前系统盘。</p><p>（后面几张图来源于网络）</p><p><img src="https://eddyblog.oss-cn-shenzhen.aliyuncs.com/UbuntuToGo/Ubuntu_7.jpg" srcset="/img/loading.gif" alt="Ubuntu_7"></p><h2 id="挂载分区"><a href="#挂载分区" class="headerlink" title="挂载分区"></a>挂载分区</h2><p>由于我们不需要通过 Legency 模式启动，无需考虑/boot，在安装过程中直接挂在分区即可。</p><p>在随后的这个界面中，假设/dev/sda 是你的想要安装系统的移动盘，选中其下的所有盘符，点击下面的“－”删去不需要的分区（相当于格式化），然后点击 free space，点击下面的“＋”，按下图挂载三个 partition：</p><ol><li><p>交换分区（建议 8G 与内存大小相同）</p><p>swap，主分区</p><p>操作系统里面讲的留在硬盘里换入换出的交换区。</p><p><img src="https://eddyblog.oss-cn-shenzhen.aliyuncs.com/UbuntuToGo/Ubuntu_9.jpg" srcset="/img/loading.gif" alt="Ubuntu_9"></p></li><li><p>根目录（“/”，建议 10-50GB）</p><p>ext4，主分区</p><p>空间有充分盈余的话可以考虑多给一些，毕竟是 SSD 固态速度不会很慢，<del>而且 10G 装软件真的不够用</del>，如果后续还需要添加空间只能通过外置硬盘引导开机然后重新调整分区方式了</p><p><img src="https://eddyblog.oss-cn-shenzhen.aliyuncs.com/UbuntuToGo/Ubuntu_8.jpg" srcset="/img/loading.gif" alt="Ubuntu_8"></p></li><li><p>home（“/home”，建议 30-50GB）</p><p>ext4</p><p>储存各种用户文件，建议分配较多空间。</p><p><img src="https://eddyblog.oss-cn-shenzhen.aliyuncs.com/UbuntuToGo/Ubuntu_10.jpg" srcset="/img/loading.gif" alt="Ubuntu_10"></p></li></ol><p>由于介质是固态硬盘，除了交换分区外，格式均无需拘泥于 FAT32，建议选择 ext4，亲测可行。</p><p><strong>注意点</strong>：</p><ol><li>最下方“Device for boot loader installation”，选择你的移动硬盘（不要误选，且不要选择成后面的分区）</li></ol><h1 id="启动引导修复"><a href="#启动引导修复" class="headerlink" title="启动引导修复"></a>启动引导修复</h1><p>安装完后重启进入 BIOS，启动项多了 ubuntu 一项，点选后正常进入 ubuntu 系统，但是插在其他电脑上并不能像 U 盘一样被检测识别。</p><p>用 DiskGenuis 观察 U 盘启动盘与移动硬盘系统不同，发现移动硬盘并无 EFI 分区（如果分区时分了 EFI，应该会发现该分区为空）。</p><h2 id="启动盘启动"><a href="#启动盘启动" class="headerlink" title="启动盘启动"></a>启动盘启动</h2><p>在本系统运行下无法修复引导，老样子通过 U 盘启动盘选择 Try Ubuntu 进入系统。</p><p><code>ctrl</code>+<code>alt</code>+<code>T</code>打开终端，输入以下命令：</p><pre><code class="hljs bash">sudo add-apt-repository 最上方ppa:yannubuntu/boot-repair最上方sudo apt-get update最上方sudo apt-get install boot-repair</code></pre><p>安装 boot-repair 工具（由于源的问题下载可能会很慢）</p><p>安装后打开 boot-repair</p><p><img src="https://eddyblog.oss-cn-shenzhen.aliyuncs.com/UbuntuToGo/Ubuntu_11.png" srcset="/img/loading.gif" alt="Ubuntu_11"></p><p>选择 Recommended repair，修复完成即可。</p><p>这时候关机拔下硬盘就可以在其他机器的 BIOS 识别并运行了。返回 Windows 系统使用 DiskGenius 分析发现 EFI 分区填充部分内容。</p><h1 id="其他常见问题"><a href="#其他常见问题" class="headerlink" title="其他常见问题"></a>其他常见问题</h1><h2 id="显卡驱动问题"><a href="#显卡驱动问题" class="headerlink" title="显卡驱动问题"></a>显卡驱动问题</h2><p>在使用两次后发现插入现在用的 Dell 笔记本和部分笔记本，进入用户登陆密码界面输入密码正确后，鼠标卡住，短暂黑屏后自动关机，无法进入系统。</p><p>查阅部分资料后发现大概率为显卡驱动（主要是 Nvida 笔记本独显与原装的开源驱动不适配导致的）。</p><p>修复方法如下</p><h3 id="Ubuntu高级模式启动"><a href="#Ubuntu高级模式启动" class="headerlink" title="Ubuntu高级模式启动"></a>Ubuntu高级模式启动</h3><p>这个模式貌似可以忽略显卡驱动的问题（怪不得分辨率小的可怜），BIOS选择ubuntu启动后，进入界面按ESC（或者默认情况）进入grub界面，选择Ubuntu高级模式（常为第二个）。</p><p>正常输入密码后进入系统，若此方法行不通请自行查找单用户模式等进入方法。</p><h3 id="更换驱动"><a href="#更换驱动" class="headerlink" title="更换驱动"></a>更换驱动</h3><p>软件和更新（Software &amp; Updates）-&gt;<br>附加驱动（Additional Drivers）</p><p>改用nvidia-driver-390驱动。</p><p><img src="https://eddyblog.oss-cn-shenzhen.aliyuncs.com/UbuntuToGo/Ubuntu_12.png" srcset="/img/loading.gif" alt="Ubuntu_12"></p><p>更新后重启进入ubuntu系统，输入密码后正常进入系统</p><h2 id="Terminal乱码问题"><a href="#Terminal乱码问题" class="headerlink" title="Terminal乱码问题"></a>Terminal乱码问题</h2><p>常发生在换用zsh和oh-my-zsh后乱码。</p><p>安装必须字体，从设置（Setting）-&gt; 地区和语言（Region &amp; Language）更改一下language和formats然后改回来即可。</p><h2 id="拔出硬盘后默认系统不能启动"><a href="#拔出硬盘后默认系统不能启动" class="headerlink" title="拔出硬盘后默认系统不能启动"></a>拔出硬盘后默认系统不能启动</h2><p>从BIOS修改启动顺序，将Windows（原系统）调整到最上方。</p>]]></content>
    
    
    <categories>
      
      <category>Computer Science</category>
      
      <category>操作系统</category>
      
    </categories>
    
    
    <tags>
      
      <tag>操作系统</tag>
      
      <tag>Linux</tag>
      
      <tag>UbuntuToGo</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>数字图像处理——直方图匹配</title>
    <link href="/post/973eccf1.html"/>
    <url>/post/973eccf1.html</url>
    
    <content type="html"><![CDATA[<h1 id="基本概念"><a href="#基本概念" class="headerlink" title="基本概念"></a>基本概念</h1><p>上一篇文章讲了<a href="https://www.edwardzcn98yx.com/post/b44049c5.html">直方图均衡</a>相关内容，从实际应用中我们发现，只能对直方图做均衡操作并不能完全满足我们的需要，有时我们更希望调整概率分布（直方图）为<strong>指定形状</strong>，这就是<strong>直方图匹配</strong>。</p><p>比如下图图一猫咪的直方图较为集中在中间，我们希望它的分布贴近第二幅文字图的分布（集中在暗区域）</p><p><img src="https://eddyblog.oss-cn-shenzhen.aliyuncs.com/ImageProcess/HistogramMatch/output_2_0.png" srcset="/img/loading.gif" alt="im1"></p><h1 id="数学基础"><a href="#数学基础" class="headerlink" title="数学基础"></a>数学基础</h1><p>从上一篇文章的介绍中我们发现，对于<strong>任何图像</strong>（$r$的概率密度分布），我们都可以通过其累积分布函数将其函数变换到随机变量$s$，而$s$是均匀分布的。那我们反过来想，能否将均匀分布的随机变量逆变换到某个特定的分布呢？</p><h2 id="公式推导"><a href="#公式推导" class="headerlink" title="公式推导"></a>公式推导</h2><p>设$r$为随机变量值域为$[0,255]$，其概率密度函数为$p_r(r)$。一函数（变换为）：</p><script type="math/tex; mode=display">s = T(r) = (L-1) \int_{0}^{r} p_r(m) \mathrm{d}m</script><p>由上一篇文章我们易知$s$服从均匀分布，我们寻找一个$z$随机变量符合另一特殊分布$p_z(z)$，易知存在一函数（变换）：</p><script type="math/tex; mode=display">s = G(z) = (L-1) \int_{0}^{z} p_z(m) \mathrm{d}m</script><p>由于$G(z)$为累积分布函数，单调，故存在反函数$G^{-1}(z)$，则有新变换 $N = G^{-1} \cdot T$，使得$r$随机变量经$N$变换后符合$z$的分布特征。</p><script type="math/tex; mode=display">z = G^{-1}(s) = G^{-1}(T(r)) = N(r)</script><p>由此，我们找到了某值域内求从<strong>某一分布</strong>随机变量$r$变换到<strong>指定分布</strong>随机变量$z$的方法。</p><h2 id="个人理解"><a href="#个人理解" class="headerlink" title="个人理解"></a>个人理解</h2><p>直方图均衡，均匀分布，实际上在中间做了桥接。</p><a id="more"></a><h1 id="实验效果"><a href="#实验效果" class="headerlink" title="实验效果"></a>实验效果</h1><h2 id="均衡化"><a href="#均衡化" class="headerlink" title="均衡化"></a>均衡化</h2><p>输出两幅图原图以及均衡化后的图片，直方图。</p><p><img src="https://eddyblog.oss-cn-shenzhen.aliyuncs.com/ImageProcess/HistogramMatch/output_3_0.png" srcset="/img/loading.gif" alt="im1"></p><p>直观对比两图的累积分布函数与直方图</p><p>$T(r)$表示$r$的累积分布函数，本样例中为小猫图像的累积分布函数，图示为淡蓝色曲线。<br>$G(z)$表示为$z$的累积分布函数，本样例中为文字图片的累积分布函数，图示为橙黄色曲线。</p><p><img src="https://eddyblog.oss-cn-shenzhen.aliyuncs.com/ImageProcess/HistogramMatch/output_4_0.png" srcset="/img/loading.gif" alt="im1"></p><h2 id="求反函数"><a href="#求反函数" class="headerlink" title="求反函数"></a>求反函数</h2><p>反函数的计算，并没有按照课本上所说，搜索找最近值，对于一张$m \times n$图像，对于每个搜索需要$O(log(L))$，总复杂度是相乘的关系$O(MNlog(L))$，而通过一个二重循环实现打表计算则可以优化到$O(MN)+O(L)$，对于实际图片$MN$远大于$L$，所以这种优化是值得的</p><pre><code class="hljs python">cnt = <span class="hljs-number">0</span><span class="hljs-keyword">for</span> i <span class="hljs-keyword">in</span> range(<span class="hljs-number">256</span>):    <span class="hljs-keyword">while</span> cnt&lt;=raw_table[i]:        new_table[cnt] = i        cnt+=<span class="hljs-number">1</span><span class="hljs-keyword">return</span> new_table</code></pre><p>计算反函数表方便后面对图像进行变换。</p><pre><code class="hljs python">reverse_imtest1_table = GetReverseTable(imtest1_tabel)match_imtest0_table = reverse_imtest1_table[imtest0_tabel]match_imtest0 = match_imtest0_table[imtest0]</code></pre><p>输出结果如下</p><p><img src="https://eddyblog.oss-cn-shenzhen.aliyuncs.com/ImageProcess/HistogramMatch/output_6_0.png" srcset="/img/loading.gif" alt="im2"></p><p>直方图对比表示了 image0，image1，匹配后的 image0 三图，由图可以看出匹配后的 image0 直方图分布已经很贴近 image1 了。</p><h2 id="图片效果"><a href="#图片效果" class="headerlink" title="图片效果"></a>图片效果</h2><p>（小猫被玩的有点可怜）</p><p><img src="https://eddyblog.oss-cn-shenzhen.aliyuncs.com/ImageProcess/HistogramMatch/output_7_0.png" srcset="/img/loading.gif" alt="im2"></p><h1 id="核心代码"><a href="#核心代码" class="headerlink" title="核心代码"></a>核心代码</h1><h2 id="图像直方图展示"><a href="#图像直方图展示" class="headerlink" title="图像直方图展示"></a>图像直方图展示</h2><pre><code class="hljs python"><span class="hljs-comment"># 展示直方图</span><span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">DrawHist</span><span class="hljs-params">(input_img,pic_handle,histogram_handle)</span>:</span>    kwargs = dict(bins = <span class="hljs-number">50</span>, histtype=<span class="hljs-string">'bar'</span>, edgecolor = <span class="hljs-string">"white"</span>,alpha=<span class="hljs-number">0.5</span>, density  = <span class="hljs-keyword">True</span>)    pic_handle.set_title(<span class="hljs-string">"The image"</span>)    pic_handle.imshow(input_img)    histogram_handle.set_title(<span class="hljs-string">"The histogram"</span>)    histogram_handle.hist(input_img.flatten(),**kwargs)imtest0 = imageio.imread(<span class="hljs-string">'imageio:chelsea.png'</span>)imtest1 = GetRGB(<span class="hljs-string">'./3_3Photo/3.jpg'</span>)plt.figure(figsize=(<span class="hljs-number">20</span>,<span class="hljs-number">10</span>))DrawHist(imtest0,plt.subplot(<span class="hljs-number">221</span>),plt.subplot(<span class="hljs-number">222</span>))DrawHist(imtest1,plt.subplot(<span class="hljs-number">223</span>),plt.subplot(<span class="hljs-number">224</span>))plt.show()</code></pre><h2 id="直方图匹配"><a href="#直方图匹配" class="headerlink" title="直方图匹配"></a>直方图匹配</h2><pre><code class="hljs python"><span class="hljs-comment"># 获取目标图像累积分布函数的反函数lut表（离散）</span><span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">GetReverseTable</span><span class="hljs-params">(raw_table)</span>:</span>    new_table = np.zeros(<span class="hljs-number">256</span>,dtype = np.int64)    cnt = <span class="hljs-number">0</span>    <span class="hljs-keyword">for</span> i <span class="hljs-keyword">in</span> range(<span class="hljs-number">256</span>):        <span class="hljs-keyword">while</span> cnt&lt;=raw_table[i]:            new_table[cnt] = i            cnt+=<span class="hljs-number">1</span>    <span class="hljs-keyword">return</span> new_table</code></pre><h2 id="加入反函数输出"><a href="#加入反函数输出" class="headerlink" title="加入反函数输出"></a>加入反函数输出</h2><pre><code class="hljs python"><span class="hljs-comment"># 加入反函数，再绘图</span>plt.figure(figsize=(<span class="hljs-number">15</span>,<span class="hljs-number">5</span>))plotline = plt.subplot(<span class="hljs-number">121</span>)plotline.set_title(<span class="hljs-string">"The function"</span>)plotline.plot(np.arange(<span class="hljs-number">256</span>),imtest0_tabel,label = <span class="hljs-string">"$T(r)$"</span>)plotline.plot(np.arange(<span class="hljs-number">256</span>),np.arange(<span class="hljs-number">256</span>),color = <span class="hljs-string">"black"</span>,label = <span class="hljs-string">"$r$"</span>)plotline.plot(np.arange(<span class="hljs-number">256</span>),imtest1_tabel,label = <span class="hljs-string">"$G(z)$"</span>)plotline.plot(np.arange(<span class="hljs-number">256</span>),reverse_imtest1_table, label = <span class="hljs-string">"$G^&#123;-1&#125;(z)$"</span>)plotline.plot(np.arange(<span class="hljs-number">256</span>),match_imtest0_table, label= <span class="hljs-string">"$G^&#123;-1&#125;(T(r)), N(r)$"</span>)plotline.legend()<span class="hljs-comment"># 设置直方图参数 分割块 叠加模式 边界颜色 透明度 正则化（映射到0~1）</span>kwargs = dict(bins = <span class="hljs-number">50</span>, histtype=<span class="hljs-string">'bar'</span>, edgecolor = <span class="hljs-string">"white"</span>,alpha=<span class="hljs-number">0.5</span>, density  = <span class="hljs-keyword">True</span>)histogram1 = plt.subplot(<span class="hljs-number">122</span>)histogram1.set_title(<span class="hljs-string">"The histogram"</span>)histogram1.hist(imtest0.flatten(),color = <span class="hljs-string">"black"</span>,label = <span class="hljs-string">"imtest0 original"</span>,**kwargs )histogram1.hist(imtest1.flatten(),label = <span class="hljs-string">"imtest1 original"</span>,**kwargs)histogram1.hist(match_imtest0.flatten(),label = <span class="hljs-string">"imtest0 after match"</span>,**kwargs)histogram1.legend()plt.show()</code></pre><h1 id="完整代码"><a href="#完整代码" class="headerlink" title="完整代码"></a>完整代码</h1><pre><code class="hljs python"><span class="hljs-keyword">import</span> numpy <span class="hljs-keyword">as</span> np<span class="hljs-keyword">import</span> imageio<span class="hljs-keyword">import</span> cv2<span class="hljs-keyword">import</span> matplotlib.pyplot <span class="hljs-keyword">as</span> pltim = imageio.imread(<span class="hljs-string">'photo2.jpg'</span>)</code></pre><pre><code class="hljs python"><span class="hljs-comment"># 获取RGB图像</span><span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">GetRGB</span><span class="hljs-params">(path)</span>:</span>    im_BGR = cv2.imread(path,cv2.COLOR_GRAY2RGB)    im = cv2.cvtColor(im_BGR,cv2.COLOR_BGR2RGB)    <span class="hljs-keyword">return</span> im</code></pre><pre><code class="hljs python"><span class="hljs-comment"># 展示直方图</span><span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">DrawHist</span><span class="hljs-params">(input_img,pic_handle,histogram_handle)</span>:</span>    kwargs = dict(bins = <span class="hljs-number">50</span>, histtype=<span class="hljs-string">'bar'</span>, edgecolor = <span class="hljs-string">"white"</span>,alpha=<span class="hljs-number">0.5</span>, density  = <span class="hljs-keyword">True</span>)    pic_handle.set_title(<span class="hljs-string">"The image"</span>)    pic_handle.imshow(input_img)    histogram_handle.set_title(<span class="hljs-string">"The histogram"</span>)    histogram_handle.hist(input_img.flatten(),**kwargs)imtest0 = imageio.imread(<span class="hljs-string">'imageio:chelsea.png'</span>)imtest1 = GetRGB(<span class="hljs-string">'./3_3Photo/3.jpg'</span>)plt.figure(figsize=(<span class="hljs-number">20</span>,<span class="hljs-number">10</span>))DrawHist(imtest0,plt.subplot(<span class="hljs-number">221</span>),plt.subplot(<span class="hljs-number">222</span>))DrawHist(imtest1,plt.subplot(<span class="hljs-number">223</span>),plt.subplot(<span class="hljs-number">224</span>))plt.show()</code></pre><pre><code class="hljs python"><span class="hljs-comment"># 尝试直方图均衡化，</span><span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">CaculateHistogram</span><span class="hljs-params">(input_image)</span>:</span>    <span class="hljs-comment"># 参数1. 单通道8位灰度图像</span>    <span class="hljs-comment"># 输出1. 总像素值</span>    <span class="hljs-comment"># 输出2. 灰度值分布计数</span>    <span class="hljs-comment"># 输出3. 灰度值分布前缀和（用来做后续直方图平局奴化）</span>    <span class="hljs-comment"># 区分通道</span>    <span class="hljs-keyword">if</span> len(np.shape(input_image)) == <span class="hljs-number">3</span>:           height,width,level = np.shape(input_image)           summ = height*width*level    <span class="hljs-keyword">else</span> :           height,width = np.shape(input_image)           summ = height*width<span class="hljs-comment">#     第一种 通过访问指定位置像素  耗时executed in 7m 9s</span><span class="hljs-comment">#     巨慢无比</span><span class="hljs-comment">#     for i in range(height):</span><span class="hljs-comment">#         for j in range(width):</span><span class="hljs-comment">#             caculate_num[input_image[i][j]] += 1</span><span class="hljs-comment">#     第二种 直接拆分行，像素获取像素值  耗时executed in 14.4s</span><span class="hljs-comment">#     for line in input_image:</span><span class="hljs-comment">#         for px in line:</span><span class="hljs-comment">#             caculate_num[px] +=1</span><span class="hljs-comment">#     第三种 调用np.histogram()方法  耗时executed in 644ms</span>    caculate_num,index_x = GetHistogramArray(input_image)    caculate_num = np.append(caculate_num,<span class="hljs-number">1</span>)<span class="hljs-comment">#     print(np.shape(caculate_num))</span>    <span class="hljs-comment">#     第四种 吕少推荐的方法(还没看懂)</span><span class="hljs-comment">#     caculate_num = cumsum(input_image,256)</span><span class="hljs-comment">#     print(np.shape(caculate_num))</span>    sum_num = np.copy(caculate_num)    <span class="hljs-keyword">for</span> i <span class="hljs-keyword">in</span> range(<span class="hljs-number">1</span>,<span class="hljs-number">256</span>):<span class="hljs-comment">#         print(sum_num[i-1],caculate_num[i])</span>        sum_num[i] = sum_num[i<span class="hljs-number">-1</span>] + sum_num[i]    <span class="hljs-keyword">return</span> summ,caculate_num,sum_num<span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">GetHistogramArray</span><span class="hljs-params">(image)</span>:</span>    <span class="hljs-keyword">return</span> np.histogram(image,np.arange(<span class="hljs-number">0</span>,<span class="hljs-number">256</span>));<span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">cumsum</span><span class="hljs-params">(img, bins)</span>:</span>    histogram = np.zeros(bins)    <span class="hljs-keyword">for</span> pixel <span class="hljs-keyword">in</span> np.arange(<span class="hljs-number">0</span>, bins, <span class="hljs-number">1</span>):        histogram[pixel] += len(img[img==pixel])    <span class="hljs-keyword">return</span> histogram<span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">HistogramEqualizationLUT</span><span class="hljs-params">(input_image)</span>:</span>    <span class="hljs-comment"># 参数1, 单通道8位灰度图像</span>    <span class="hljs-comment"># 输出1. 单通道8位灰度图像（直方图均衡化后）</span>    size,data,data_sum = CaculateHistogram(input_image)    fxy  = <span class="hljs-keyword">lambda</span> x: (<span class="hljs-number">255</span>*data_sum[x])//size    table = np.array([fxy(i) <span class="hljs-keyword">for</span> i <span class="hljs-keyword">in</span> range(<span class="hljs-number">256</span>)])<span class="hljs-comment">#     print(table)</span><span class="hljs-comment">#     不可以这样</span><span class="hljs-comment">#     image_new = table[input_image]</span>    lut = <span class="hljs-keyword">lambda</span> x: table[x]    <span class="hljs-keyword">return</span> lut(input_image),tableimtest0_he,imtest0_tabel = HistogramEqualizationLUT(imtest0)imtest1_he,imtest1_tabel = HistogramEqualizationLUT(imtest1)plt.figure(figsize=(<span class="hljs-number">20</span>,<span class="hljs-number">20</span>))DrawHist(imtest0,plt.subplot(<span class="hljs-number">421</span>),plt.subplot(<span class="hljs-number">422</span>))DrawHist(imtest0_he,plt.subplot(<span class="hljs-number">423</span>),plt.subplot(<span class="hljs-number">424</span>))DrawHist(imtest1,plt.subplot(<span class="hljs-number">425</span>),plt.subplot(<span class="hljs-number">426</span>))DrawHist(imtest1_he,plt.subplot(<span class="hljs-number">427</span>),plt.subplot(<span class="hljs-number">428</span>))</code></pre><pre><code class="hljs python">plt.figure(figsize=(<span class="hljs-number">15</span>,<span class="hljs-number">5</span>))plotline = plt.subplot(<span class="hljs-number">121</span>)plotline.set_title(<span class="hljs-string">"The function"</span>)plotline.plot(np.arange(<span class="hljs-number">256</span>),np.arange(<span class="hljs-number">256</span>),color = <span class="hljs-string">'black'</span>,label = <span class="hljs-string">"$r$"</span>)plotline.plot(np.arange(<span class="hljs-number">256</span>),imtest0_tabel,label = <span class="hljs-string">"$T(r)$"</span>)plotline.plot(np.arange(<span class="hljs-number">256</span>),imtest1_tabel,label = <span class="hljs-string">"$G(z)$"</span>)plotline.legend()kwargs = dict(bins = <span class="hljs-number">50</span>, histtype=<span class="hljs-string">'bar'</span>, edgecolor = <span class="hljs-string">"white"</span>,alpha=<span class="hljs-number">0.6</span>, density  = <span class="hljs-keyword">True</span>)histogram = plt.subplot(<span class="hljs-number">122</span>)histogram.set_title(<span class="hljs-string">"The histogram"</span>)histogram.hist(imtest0.flatten(),**kwargs, label = <span class="hljs-string">"imtest0 $p_r(r)$"</span> )histogram.hist(imtest1.flatten(), **kwargs, label = <span class="hljs-string">"imtest1 $p_z(z)$"</span>)histogram.legend()plt.show()</code></pre><pre><code class="hljs python"><span class="hljs-comment"># 获取目标图像累积分布函数的反函数lut表（离散）</span><span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">GetReverseTable</span><span class="hljs-params">(raw_table)</span>:</span>    new_table = np.zeros(<span class="hljs-number">256</span>,dtype = np.int64)    cnt = <span class="hljs-number">0</span>    <span class="hljs-keyword">for</span> i <span class="hljs-keyword">in</span> range(<span class="hljs-number">256</span>):        <span class="hljs-keyword">while</span> cnt&lt;=raw_table[i]:            new_table[cnt] = i            cnt+=<span class="hljs-number">1</span>    <span class="hljs-keyword">return</span> new_tablereverse_imtest1_table = GetReverseTable(imtest1_tabel)match_imtest0_table = reverse_imtest1_table[imtest0_tabel]match_imtest0 = match_imtest0_table[imtest0]</code></pre><pre><code class="hljs python"><span class="hljs-comment"># 加入反函数，再绘图</span>plt.figure(figsize=(<span class="hljs-number">15</span>,<span class="hljs-number">5</span>))plotline = plt.subplot(<span class="hljs-number">121</span>)plotline.set_title(<span class="hljs-string">"The function"</span>)plotline.plot(np.arange(<span class="hljs-number">256</span>),imtest0_tabel,label = <span class="hljs-string">"$T(r)$"</span>)plotline.plot(np.arange(<span class="hljs-number">256</span>),np.arange(<span class="hljs-number">256</span>),color = <span class="hljs-string">"black"</span>,label = <span class="hljs-string">"$r$"</span>)plotline.plot(np.arange(<span class="hljs-number">256</span>),imtest1_tabel,label = <span class="hljs-string">"$G(z)$"</span>)plotline.plot(np.arange(<span class="hljs-number">256</span>),reverse_imtest1_table, label = <span class="hljs-string">"$G^&#123;-1&#125;(z)$"</span>)plotline.plot(np.arange(<span class="hljs-number">256</span>),match_imtest0_table, label= <span class="hljs-string">"$G^&#123;-1&#125;(T(r)), N(r)$"</span>)plotline.legend()<span class="hljs-comment"># 设置直方图参数 分割块 叠加模式 边界颜色 透明度 正则化（映射到0~1）</span>kwargs = dict(bins = <span class="hljs-number">50</span>, histtype=<span class="hljs-string">'bar'</span>, edgecolor = <span class="hljs-string">"white"</span>,alpha=<span class="hljs-number">0.5</span>, density  = <span class="hljs-keyword">True</span>)histogram1 = plt.subplot(<span class="hljs-number">122</span>)histogram1.set_title(<span class="hljs-string">"The histogram"</span>)histogram1.hist(imtest0.flatten(),color = <span class="hljs-string">"black"</span>,label = <span class="hljs-string">"imtest0 original"</span>,**kwargs )histogram1.hist(imtest1.flatten(),label = <span class="hljs-string">"imtest1 original"</span>,**kwargs)histogram1.hist(match_imtest0.flatten(),label = <span class="hljs-string">"imtest0 after match"</span>,**kwargs)histogram1.legend()plt.show()</code></pre><pre><code class="hljs python"><span class="hljs-comment"># 输出三种图像</span>plt.figure(figsize=(<span class="hljs-number">20</span>,<span class="hljs-number">15</span>))DrawHist(imtest0,plt.subplot(<span class="hljs-number">321</span>),plt.subplot(<span class="hljs-number">322</span>))DrawHist(imtest0_he,plt.subplot(<span class="hljs-number">323</span>),plt.subplot(<span class="hljs-number">324</span>))DrawHist(match_imtest0,plt.subplot(<span class="hljs-number">325</span>),plt.subplot(<span class="hljs-number">326</span>))plt.show()</code></pre>]]></content>
    
    
    <categories>
      
      <category>Computer Science</category>
      
      <category>数字图像处理</category>
      
    </categories>
    
    
    <tags>
      
      <tag>数字图像处理</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>数字图像处理——直方图均衡</title>
    <link href="/post/b44049c5.html"/>
    <url>/post/b44049c5.html</url>
    
    <content type="html"><![CDATA[<h1 id="基本概念"><a href="#基本概念" class="headerlink" title="基本概念"></a>基本概念</h1><p>对于一张$8$位灰度图像，像素灰度值$r \in [0,256), r \in Z$，必然满足一特定的概率分布$p(x)$，直方图可理解为分块显示的概率密度函数。</p><p>以下面几图为例（彩色图取 R 通道）</p><p><img src="https://eddyblog.oss-cn-shenzhen.aliyuncs.com/ImageProcess/HistogramEqualization/output_6_0.png" srcset="/img/loading.gif" alt="Sample0"></p><p>(代码见附录)</p><p>由图片可以看出来，图一小猫亮度高的地方更多，所以直方图上显示出在灰度级高端分布更密集，而图二的风景图相反，图三的阿童木则明显亮暗区分较为明显，所以在直方图上体现为两极化。</p><p>在某些情况下，我们希望通过某种函数变换$s = T(r)$，使变换后的函数概率分布均匀化（或贴近均匀），这就是<strong>直方图均衡</strong></p><a id="more"></a><h1 id="概率论基础"><a href="#概率论基础" class="headerlink" title="概率论基础"></a>概率论基础</h1><p>根据课本 P74 页，$p_r(r)$和$p_s(s)$分别表示随机变量$r$和$s$的概率密度函数，<strong>概率论的一个基本结果是，如果$p_r(r)$和$T(r)$已知且$s = T(r)$具备单调性，在感兴趣的值域上是连续且可微的，则变换后的变量$s$的概率密度函数可由下面的简单公式得到：</strong></p><script type="math/tex; mode=display">p_s(s) = p_r(r) \left| \frac{\mathrm{d}r}{\mathrm{d}s} \right|</script><p>这个式子怎么推导的呢？实际上我们就是在求一个<strong>随机变量函数的概率分布</strong>，概率论是学过的，这里回忆一下给出推导。</p><p>设$r$为随机变量，其概率分布符合$p_r(r)$，另有一单调的函数（变换）$s = T(r)$，现在求$s$的概率分布，设$r$值域均为$[0,L-1]$。</p><p>由分布函数公式</p><script type="math/tex; mode=display">F(x) = \int_{0}^{x} p(m) \mathrm{d}m</script><p>得$r$得分布函数</p><script type="math/tex; mode=display">F_r(r) = \int_{0}^{r} p_r(m) \mathrm{d}m</script><p>又因为$s = T(r)$为单调函数，存在反函数$r = T^{-1}(s)$</p><script type="math/tex; mode=display">F_s(s) = F_r(T^{-1}(s)) = \int_{0}^{ T^{-1}(s) } p_r(m) \mathrm{d}m</script><p>概率密度函数为分布函数的导数</p><script type="math/tex; mode=display">p_s(s) = \left| \frac{\mathrm{d} F_s(s)}{\mathrm{d}s} \right|</script><p>应用链式求导法则</p><script type="math/tex; mode=display">p_s(s) = \left| \frac{\mathrm{d}F_s(s)}{\mathrm{d}s} \right|</script><script type="math/tex; mode=display">p_s(s) = \frac{\mathrm{d}F_r(r)}{\mathrm{d}r} \left| \frac{ \mathrm{d} r}{ \mathrm{d}s}  \right|</script><script type="math/tex; mode=display">p_s(s) = p_r(r) \left| \frac{ \mathrm{d} r}{ \mathrm{d}s}  \right|</script><p>则得到了书本上的公式。</p><h1 id="均衡变换"><a href="#均衡变换" class="headerlink" title="均衡变换"></a>均衡变换</h1><p>有了上述式子，我们会发现特殊的性质</p><ol><li><p>若$T(r)$恰为$r$的分布函数，则</p><script type="math/tex; mode=display">s = T(r) = \int_{0}^{r} p_r(m) \mathrm{d}m</script><script type="math/tex; mode=display">\frac{\mathrm{d}s}{\mathrm{d}r} = p_r(r)</script><script type="math/tex; mode=display">p_s(s) = p_r(r) \left| \frac{ \mathrm{d} r}{ \mathrm{d}s}  \right| = p_r(r) \frac{1}{p_r(r)} = 1</script><p>则$s$为均匀分布$s \in [0,1]$ 且$p_s(s)$值恒为$1$</p></li><li><p>若$T(r)$为$r$分布函数映射到$[0,L-1]$，则</p><script type="math/tex; mode=display">s = T(r) = (L-1) \int_{0}^{r} p_r(m) \mathrm{d}m</script><script type="math/tex; mode=display">p_s(s) = p_r(r) \frac{1}{(L-1) p_r(r)} = \frac{1}{L-1}</script><p>则$s$为均匀分布，且$p_s(s)=\frac{1}{L-1}$</p></li></ol><p>这便是我们想要的函数变换，<strong>无论$p_r(r)$分布如何</strong>，经过这种类分布函数的函数变换，得到的$p_s(s)$就是一个<strong>均匀分布</strong>。</p><h1 id="三通道混合均衡-vs-分别均衡"><a href="#三通道混合均衡-vs-分别均衡" class="headerlink" title="三通道混合均衡 vs. 分别均衡"></a>三通道混合均衡 vs. 分别均衡</h1><p>平台的讨论区里留下了一个有趣的问题：<strong>对于三通道 RGB 图像，对每个通道均衡后合并的图像有时会产生严重的色彩失真。</strong></p><p>我的一点理解：</p><h2 id="何为失真"><a href="#何为失真" class="headerlink" title="何为失真"></a>何为失真</h2><p>在我们的处理过程中，色彩失真（与实际偏差过大），我们可以简单理解为显色偏向与原图产生较大差异，产生新的偏色甚至反向偏色。</p><h2 id="我的实验"><a href="#我的实验" class="headerlink" title="我的实验"></a>我的实验</h2><p>我将一张自己原来拍摄的风景图，R，G，B 三个通道分别进行了直方图均衡，但是没有一同合并，而是与当前未变换的剩下两通道叠加后的图片。</p><p><img src="https://eddyblog.oss-cn-shenzhen.aliyuncs.com/ImageProcess/HistogramEqualization/output_3_0.png" srcset="/img/loading.gif" alt="ThreeChannels1"></p><p>下图是原图，分离的红色通道均衡化图（灰度），均衡化红色通道与原剩余通道叠加图</p><p><img src="https://eddyblog.oss-cn-shenzhen.aliyuncs.com/ImageProcess/HistogramEqualization/output_2_0.png" srcset="/img/loading.gif" alt="ThreeChannels2"></p><p>结合原图与与直方图我们不难看出，由于是夜晚照的风景照，整体画面大部分偏暗，所以三个通道的直方图都集中在灰度较低的地方（分布略有偏差）。</p><p>当我只均衡一个通道时，该通道直方图中高灰度区域很明显会被提拉上来。</p><p><img src="https://eddyblog.oss-cn-shenzhen.aliyuncs.com/ImageProcess/HistogramEqualization/output_3_1.png" srcset="/img/loading.gif" alt="ThreeChannels3"></p><p>而相较于其他两通道的中高灰度，被均衡的通道明显概率分布更大。</p><p><img src="https://eddyblog.oss-cn-shenzhen.aliyuncs.com/ImageProcess/HistogramEqualization/output_3_2.png" srcset="/img/loading.gif" alt="ThreeChannels4"></p><p>所以整体画面会偏向均衡的通道的颜色，如最下面三张合并后的效果所示。</p><p><img src="https://eddyblog.oss-cn-shenzhen.aliyuncs.com/ImageProcess/HistogramEqualization/output_3_3.png" srcset="/img/loading.gif" alt="ThreeChannels5"></p><h2 id="进一步思考"><a href="#进一步思考" class="headerlink" title="进一步思考"></a>进一步思考</h2><p>这种均衡的变换同时也会牺牲掉原本通道高亮的部分，上图蓝色通道的变换最容易看出这种效果。</p><p><img src="https://eddyblog.oss-cn-shenzhen.aliyuncs.com/ImageProcess/HistogramEqualization/output_3_4.png" srcset="/img/loading.gif" alt="ThreeChannels6"></p><p>均衡化的蓝色通道和剩余两通道合并后的图像中，道路灯光周围较暗的区域更偏向红橙色，这是因为牺牲了原本蓝色在这一灰度范围分布密度的优势，均摊到其他灰度区域后，红绿通道便更加凸显。</p><h2 id="进两步思考"><a href="#进两步思考" class="headerlink" title="进两步思考"></a>进两步思考</h2><p>无论是从数学推导，还是上述直方图，函数曲线都可以看出来，不同通道颜色的概率密度函数还有累积分布函数都是不同的，则<strong>不同通道像素值的相对大小</strong>就可能发生改变。</p><p>举个例子，若红色通道$T_{red}(2) = 8$，而蓝色通道${T_{blue}(5) = 6}$，绿色通道假定不变，则原来像素点$a = (2,4,5)$ 变换后为$a’ = (8,4,6)$由偏向蓝色变为偏向红色。</p><p>不同通道值对变换后不保序（相同通道由于同一函数单调性确定，必然保序），导致了失真的可能性变大。</p><p>因而，若采用三通道合并计算灰度的概率分布然后计算累积分布函数的话，由于使用相同的函数变换，<strong>无论是相同通道还是不同通道的两个值$i$,$j$，经函数变换后保留其大小关系，如$i&lt;j \to T(i) &lt; T(j)$</strong>。</p><p>这样，虽然在一定程度上牺牲了逐个通道的均衡化效果，但整体上避免了颜色的失真。</p><h2 id="进三步思考"><a href="#进三步思考" class="headerlink" title="进三步思考"></a>进三步思考</h2><h3 id="实验"><a href="#实验" class="headerlink" title="实验"></a>实验</h3><p>我使用了一些图片做验证，左中右分别对应原图、三通道分别均衡化、整体均衡化的函数曲线和图像。</p><p><img src="https://eddyblog.oss-cn-shenzhen.aliyuncs.com/ImageProcess/HistogramEqualization/output_5_0.png" srcset="/img/loading.gif" alt="Compare0"></p><p><img src="https://eddyblog.oss-cn-shenzhen.aliyuncs.com/ImageProcess/HistogramEqualization/output_5_1.png" srcset="/img/loading.gif" alt="Compare1"></p><p><img src="https://eddyblog.oss-cn-shenzhen.aliyuncs.com/ImageProcess/HistogramEqualization/output_5_2.png" srcset="/img/loading.gif" alt="Compare2"></p><h3 id="结论"><a href="#结论" class="headerlink" title="结论"></a>结论</h3><p>基本符合预期，整体均衡可以最大程度保留颜色的保真度，三通道虽然在各颜色通道都可以达到均衡效果，但是会造成一定的颜色失真。</p><h1 id="核心代码"><a href="#核心代码" class="headerlink" title="核心代码"></a>核心代码</h1><h2 id="获取-RGB-三通道图像"><a href="#获取-RGB-三通道图像" class="headerlink" title="获取 RGB 三通道图像"></a>获取 RGB 三通道图像</h2><p>需要注意的是，cv2 读取图像为 BGR，需要转换成 RGB。</p><pre><code class="hljs python"><span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">GetRGB</span><span class="hljs-params">(path)</span>:</span>    im_BGR = cv2.imread(path,cv2.COLOR_GRAY2RGB)    im = cv2.cvtColor(im_BGR,cv2.COLOR_BGR2RGB)    <span class="hljs-keyword">return</span> im</code></pre><h2 id="获取不同灰度值计数值"><a href="#获取不同灰度值计数值" class="headerlink" title="获取不同灰度值计数值"></a>获取不同灰度值计数值</h2><ol><li><p>通过访问指定位置像素</p><p>相同测试环境，耗时 7m9s（最慢）</p><pre><code class="hljs python"><span class="hljs-keyword">for</span> i <span class="hljs-keyword">in</span> range(height):    <span class="hljs-keyword">for</span> j <span class="hljs-keyword">in</span> range(width):        caculate_num[input_image[i][j]] += <span class="hljs-number">1</span></code></pre></li><li><p>遍历元素</p><p>相同测试环境，耗时 14.4s（较慢）</p><pre><code class="hljs python"><span class="hljs-keyword">for</span> line <span class="hljs-keyword">in</span> input_image:    <span class="hljs-keyword">for</span> px <span class="hljs-keyword">in</span> line:        caculate_num[px] +=<span class="hljs-number">1</span></code></pre></li><li><p>向量化比较</p><p>相同测试环境，耗时小于 10s（较快）</p><p>解释加速原理，img==pixel 得到一个 bool 数组，而 img[]则取出数组为真值的 index 数组，然后就可以用 len()计数了。比较产生 bool 数组是向量操作，底层优化，所以加速效果明显。</p><pre><code class="hljs python"><span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">cumsum</span><span class="hljs-params">(img, bins)</span>:</span>    histogram = np.zeros(bins)    <span class="hljs-keyword">for</span> pixel <span class="hljs-keyword">in</span> np.arange(<span class="hljs-number">0</span>, bins, <span class="hljs-number">1</span>):        histogram[pixel] += len(img[img==pixel])<span class="hljs-keyword">return</span> histogramcaculate_num = cumsum(input_image,<span class="hljs-number">256</span>)print(np.shape(caculate_num))</code></pre></li><li><p>调用 np.histogram()的方法</p><p>相同测试环境，耗时 644ms（最快）</p><p>快的原因不了解，有时间看看源码</p><pre><code class="hljs python">caculate_num,index_x = np.histogram(input_image,np.arange(<span class="hljs-number">0</span>,<span class="hljs-number">256</span>)) caculate_num = np.append(caculate_num,<span class="hljs-number">1</span>)</code></pre></li></ol><h2 id="直方图均衡化"><a href="#直方图均衡化" class="headerlink" title="直方图均衡化"></a>直方图均衡化</h2><p>输入三通/单通道图像，返回均衡化后的图像和查找表</p><pre><code class="hljs python"><span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">CaculateHistogram</span><span class="hljs-params">(input_image)</span>:</span>    <span class="hljs-comment"># 参数1. 图像</span>    <span class="hljs-comment"># 输出1. 总像素值</span>    <span class="hljs-comment"># 输出2. 灰度值分布计数</span>    <span class="hljs-comment"># 输出3. 灰度值分布前缀和（用来做后续直方图平局奴化）</span>    <span class="hljs-comment"># 区分单通道还是三通道图像</span>    <span class="hljs-keyword">if</span> len(np.shape(input_image)) == <span class="hljs-number">3</span>:           height,width,level = np.shape(input_image)           summ = height*width*level    <span class="hljs-keyword">else</span> :           height,width = np.shape(input_image)           summ = height*width    caculate_num,index_x = np.histogram(input_image,np.arange(<span class="hljs-number">0</span>,<span class="hljs-number">256</span>))    caculate_num = np.append(caculate_num,<span class="hljs-number">1</span>)    sum_num = np.copy(caculate_num)    <span class="hljs-keyword">for</span> i <span class="hljs-keyword">in</span> range(<span class="hljs-number">1</span>,<span class="hljs-number">256</span>):        sum_num[i] = sum_num[i<span class="hljs-number">-1</span>] + sum_num[i]    <span class="hljs-keyword">return</span> summ,caculate_num,sum_num<span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">cumsum</span><span class="hljs-params">(img, bins)</span>:</span>    histogram = np.zeros(bins)    <span class="hljs-keyword">for</span> pixel <span class="hljs-keyword">in</span> np.arange(<span class="hljs-number">0</span>, bins, <span class="hljs-number">1</span>):        histogram[pixel] += len(img[img==pixel])    <span class="hljs-keyword">return</span> histogram<span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">HistogramEqualizationLUT</span><span class="hljs-params">(input_image)</span>:</span>    size,data,data_sum = CaculateHistogram(input_image)    fxy  = <span class="hljs-keyword">lambda</span> x: (<span class="hljs-number">255</span>*data_sum[x])//size    table = np.array([fxy(i) <span class="hljs-keyword">for</span> i <span class="hljs-keyword">in</span> range(<span class="hljs-number">256</span>)])    lut = <span class="hljs-keyword">lambda</span> x: table[x]    <span class="hljs-keyword">return</span> lut(input_image),table</code></pre><p>注意要用 lambda，不可以直接 input_new = table[input_image]</p><h2 id="绘图函数"><a href="#绘图函数" class="headerlink" title="绘图函数"></a>绘图函数</h2><pre><code class="hljs python"><span class="hljs-comment"># OK, Do something interesting!</span><span class="hljs-comment"># 写一个整合函数，对每个输入图像的三通道都画出其三通道的函数变换图像和</span><span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">DrawPerChannel</span><span class="hljs-params">(input_img,split_channel : int, channel_color ,plotline = None, histogram = None, pic = None)</span>:</span><span class="hljs-comment">#     该通道的均衡曲线（分布函数曲线）</span><span class="hljs-comment">#     获取分离的通道</span>    input_channel = input_img[:,:,split_channel]    temp_he,temp_table = HistogramEqualizationLUT(input_channel)    <span class="hljs-keyword">if</span> plotline != <span class="hljs-keyword">None</span>:        plotline.set_title(<span class="hljs-string">"The function of "</span>+channel_color+<span class="hljs-string">" channel"</span>)        plotline.plot(np.arange(<span class="hljs-number">256</span>),np.arange(<span class="hljs-number">256</span>),color = <span class="hljs-string">"black"</span>,label = <span class="hljs-string">"$r_&#123;"</span> + channel_color +<span class="hljs-string">"&#125;$"</span>)        plotline.plot(np.arange(<span class="hljs-number">256</span>),temp_table,color = channel_color ,label = <span class="hljs-string">"$T(r_&#123;"</span>+ channel_color +<span class="hljs-string">"&#125;)$"</span>)        plotline.legend()<span class="hljs-comment">#     该通道的灰度分布直方图</span>    <span class="hljs-keyword">if</span> histogram != <span class="hljs-keyword">None</span>:        kwargs = dict(bins = <span class="hljs-number">25</span>, histtype=<span class="hljs-string">'bar'</span>, edgecolor = <span class="hljs-string">"white"</span>,alpha=<span class="hljs-number">0.5</span>, density  = <span class="hljs-keyword">True</span>)        histogram.set_title(<span class="hljs-string">"The histogram of "</span>+channel_color+<span class="hljs-string">" channel"</span>)        histogram.hist(input_channel.flatten(), color = <span class="hljs-string">"black"</span>,**kwargs, label = channel_color +<span class="hljs-string">" original"</span>)        histogram.hist(temp_he.flatten(), color = channel_color , **kwargs, label = channel_color +<span class="hljs-string">" after he"</span>)        histogram.legend()<span class="hljs-comment">#     该通道均匀后叠加到原图像的效果</span>    <span class="hljs-keyword">if</span> pic != <span class="hljs-keyword">None</span>:        show_img = input_img.copy()        show_img[:,:,split_channel] = temp_he        pic.imshow(show_img)<span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">DrawChannelsEqualization</span><span class="hljs-params">(img_with_3channels)</span>:</span>    plt.figure(figsize=(<span class="hljs-number">30</span>,<span class="hljs-number">30</span>))<span class="hljs-comment">#     调用库函数</span><span class="hljs-comment">#     r,g,b = cv2.split(im)</span><span class="hljs-comment">#     直接分离</span><span class="hljs-comment">#     r,g,b = img_with_3channels[:,:,0],img_with_3channels[:,:,1],img_with_3channels[:,:,2]</span>    DrawPerChannel(img_with_3channels,<span class="hljs-number">0</span>,<span class="hljs-string">"red"</span>,plt.subplot(<span class="hljs-number">331</span>),plt.subplot(<span class="hljs-number">334</span>),plt.subplot(<span class="hljs-number">337</span>))    DrawPerChannel(img_with_3channels,<span class="hljs-number">1</span>,<span class="hljs-string">"green"</span>,plt.subplot(<span class="hljs-number">332</span>),plt.subplot(<span class="hljs-number">335</span>),plt.subplot(<span class="hljs-number">338</span>))    DrawPerChannel(img_with_3channels,<span class="hljs-number">2</span>,<span class="hljs-string">"blue"</span>,plt.subplot(<span class="hljs-number">333</span>),plt.subplot(<span class="hljs-number">336</span>),plt.subplot(<span class="hljs-number">339</span>))    plt.show()</code></pre><pre><code class="hljs python"><span class="hljs-comment"># 测试三通道分别做均衡化后效果和采取统一函数做均衡化的效果</span><span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">DrawCompareEqualization</span><span class="hljs-params">(im_with_3_channel)</span>:</span>    together_img,together_table = HistogramEqualizationLUT(im_with_3_channel)    seperate_img = im_with_3_channel.copy()    seperate_table = np.array([together_table,together_table,together_table])    <span class="hljs-keyword">for</span> i <span class="hljs-keyword">in</span> range(<span class="hljs-number">3</span>):        seperate_img[:,:,i],seperate_table[i] = HistogramEqualizationLUT(im_with_3_channel[:,:,i])    plt.figure(figsize=(<span class="hljs-number">15</span>,<span class="hljs-number">10</span>))    plotline0 = plt.subplot(<span class="hljs-number">231</span>)    plotline0.set_title(<span class="hljs-string">"No Change"</span>)    plotline0.plot(np.arange(<span class="hljs-number">256</span>),np.arange(<span class="hljs-number">256</span>),color = <span class="hljs-string">"black"</span>,label = <span class="hljs-string">"$r$"</span>)    plotline1 = plt.subplot(<span class="hljs-number">232</span>)    plotline1.set_title(<span class="hljs-string">"Seperate Change"</span>)    plotline1.plot(np.arange(<span class="hljs-number">256</span>),np.arange(<span class="hljs-number">256</span>),color = <span class="hljs-string">"black"</span>,label = <span class="hljs-string">"$r$"</span>)    plotline1.plot(np.arange(<span class="hljs-number">256</span>),seperate_table[<span class="hljs-number">0</span>],color = <span class="hljs-string">"red"</span> ,label = <span class="hljs-string">"$T(r_&#123;red&#125;)$"</span>)    plotline1.plot(np.arange(<span class="hljs-number">256</span>),seperate_table[<span class="hljs-number">1</span>],color = <span class="hljs-string">"green"</span> ,label = <span class="hljs-string">"$T(r_&#123;green&#125;)$"</span>)    plotline1.plot(np.arange(<span class="hljs-number">256</span>),seperate_table[<span class="hljs-number">2</span>],color = <span class="hljs-string">"blue"</span> ,label = <span class="hljs-string">"$T(r_&#123;blue&#125;)$"</span>)    plotline1.legend()    plotline2 = plt.subplot(<span class="hljs-number">233</span>)    plotline2.set_title(<span class="hljs-string">"Together Change"</span>)    plotline2.plot(np.arange(<span class="hljs-number">256</span>),np.arange(<span class="hljs-number">256</span>),color = <span class="hljs-string">"black"</span>,label = <span class="hljs-string">"$r$"</span>)    plotline2.plot(np.arange(<span class="hljs-number">256</span>),together_table,color = <span class="hljs-string">"orange"</span> ,label = <span class="hljs-string">"$T(r_&#123;together&#125;)$"</span>)    plotline2.legend()    pic0 = plt.subplot(<span class="hljs-number">234</span>)    pic0.imshow(im_with_3_channel)    pic1 = plt.subplot(<span class="hljs-number">235</span>)    pic1.imshow(seperate_img)    pic2 = plt.subplot(<span class="hljs-number">236</span>)    pic2.imshow(together_img)    plt.show()</code></pre><h1 id="完整代码"><a href="#完整代码" class="headerlink" title="完整代码"></a>完整代码</h1><pre><code class="hljs python"><span class="hljs-keyword">import</span> numpy <span class="hljs-keyword">as</span> np<span class="hljs-keyword">import</span> cv2<span class="hljs-keyword">import</span> imageio<span class="hljs-keyword">import</span> matplotlib.pyplot <span class="hljs-keyword">as</span> plt</code></pre><pre><code class="hljs python"><span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">GetRGB</span><span class="hljs-params">(path)</span>:</span>    im_BGR = cv2.imread(path,cv2.COLOR_GRAY2RGB)    im = cv2.cvtColor(im_BGR,cv2.COLOR_BGR2RGB)    <span class="hljs-keyword">return</span> imim = GetRGB(<span class="hljs-string">'./3_2Photo/1.jpg'</span>)</code></pre><pre><code class="hljs python"><span class="hljs-comment"># 尝试直方图均衡化，</span><span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">CaculateHistogram</span><span class="hljs-params">(input_image)</span>:</span>    <span class="hljs-comment"># 参数1. 单通道8位灰度图像</span>    <span class="hljs-comment"># 输出1. 总像素值</span>    <span class="hljs-comment"># 输出2. 灰度值分布计数</span>    <span class="hljs-comment"># 输出3. 灰度值分布前缀和（用来做后续直方图平局奴化）</span>    <span class="hljs-comment"># 区分通道</span>    <span class="hljs-keyword">if</span> len(np.shape(input_image)) == <span class="hljs-number">3</span>:           height,width,level = np.shape(input_image)           summ = height*width*level    <span class="hljs-keyword">else</span> :           height,width = np.shape(input_image)           summ = height*width<span class="hljs-comment">#     第一种 通过访问指定位置像素  耗时executed in 7m 9s</span><span class="hljs-comment">#     巨慢无比</span><span class="hljs-comment">#     for i in range(height):</span><span class="hljs-comment">#         for j in range(width):</span><span class="hljs-comment">#             caculate_num[input_image[i][j]] += 1</span><span class="hljs-comment">#     第二种 直接拆分行，像素获取像素值  耗时executed in 14.4s</span><span class="hljs-comment">#     for line in input_image:</span><span class="hljs-comment">#         for px in line:</span><span class="hljs-comment">#             caculate_num[px] +=1</span><span class="hljs-comment">#     第三种 调用np.histogram()方法  耗时executed in 644ms</span>    caculate_num,index_x = GetHistogramArray(input_image)    caculate_num = np.append(caculate_num,<span class="hljs-number">1</span>)<span class="hljs-comment">#     print(np.shape(caculate_num))</span>    <span class="hljs-comment">#     第四种 吕少推荐的方法(还没看懂)</span><span class="hljs-comment">#     caculate_num = cumsum(input_image,256)</span><span class="hljs-comment">#     print(np.shape(caculate_num))</span>    sum_num = np.copy(caculate_num)    <span class="hljs-keyword">for</span> i <span class="hljs-keyword">in</span> range(<span class="hljs-number">1</span>,<span class="hljs-number">256</span>):<span class="hljs-comment">#         print(sum_num[i-1],caculate_num[i])</span>        sum_num[i] = sum_num[i<span class="hljs-number">-1</span>] + sum_num[i]    <span class="hljs-keyword">return</span> summ,caculate_num,sum_num<span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">GetHistogramArray</span><span class="hljs-params">(image)</span>:</span>    <span class="hljs-keyword">return</span> np.histogram(image,np.arange(<span class="hljs-number">0</span>,<span class="hljs-number">256</span>));<span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">cumsum</span><span class="hljs-params">(img, bins)</span>:</span>    histogram = np.zeros(bins)    <span class="hljs-keyword">for</span> pixel <span class="hljs-keyword">in</span> np.arange(<span class="hljs-number">0</span>, bins, <span class="hljs-number">1</span>):        histogram[pixel] += len(img[img==pixel])    <span class="hljs-keyword">return</span> histogram<span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">HistogramEqualizationLUT</span><span class="hljs-params">(input_image)</span>:</span>    <span class="hljs-comment"># 参数1, 单通道8位灰度图像</span>    <span class="hljs-comment"># 输出1. 单通道8位灰度图像（直方图均衡化后）</span>    size,data,data_sum = CaculateHistogram(input_image)    fxy  = <span class="hljs-keyword">lambda</span> x: (<span class="hljs-number">255</span>*data_sum[x])//size    table = np.array([fxy(i) <span class="hljs-keyword">for</span> i <span class="hljs-keyword">in</span> range(<span class="hljs-number">256</span>)])<span class="hljs-comment">#     print(table)</span><span class="hljs-comment">#     不可以这样</span><span class="hljs-comment">#     image_new = table[input_image]</span>    lut = <span class="hljs-keyword">lambda</span> x: table[x]    <span class="hljs-keyword">return</span> lut(input_image),tablered_channel_he,red_lut_table = HistogramEqualizationLUT(im[:,:,<span class="hljs-number">0</span>])all_he,lut_table = HistogramEqualizationLUT(im)plt.figure(figsize=(<span class="hljs-number">20</span>,<span class="hljs-number">10</span>))ax1 = plt.subplot(<span class="hljs-number">231</span>)ax1.set_title(<span class="hljs-string">"Original"</span>)ax1.imshow(im)ax2 = plt.subplot(<span class="hljs-number">232</span>)ax2.set_title(<span class="hljs-string">"Red Channel HE"</span>)ax2.imshow(red_channel_he, cmap = <span class="hljs-string">'gray'</span>)new_im = np.copy(im)new_im[:,:,<span class="hljs-number">0</span>] = red_channel_heax3 = plt.subplot(<span class="hljs-number">233</span>)ax3.set_title(<span class="hljs-string">"Image With Red Channel HE"</span>)ax3.imshow(new_im)ax4 = plt.subplot(<span class="hljs-number">234</span>)ax4.set_title(<span class="hljs-string">"Original"</span>)ax4.imshow(im)ax5 = plt.subplot(<span class="hljs-number">235</span>)ax5.set_title(<span class="hljs-string">"All Channel Together HE"</span>)ax5.imshow(all_he,cmap = <span class="hljs-string">"gray"</span>)ax6 = plt.subplot(<span class="hljs-number">236</span>)ax6.set_title(<span class="hljs-string">"All Channel Together HE"</span>)ax6.imshow(all_he)plt.show()</code></pre><pre><code class="hljs python"><span class="hljs-comment"># OK, Do something interesting!</span><span class="hljs-comment"># 写一个整合函数，对每个输入图像的三通道都画出其三通道的函数变换图像和</span><span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">DrawPerChannel</span><span class="hljs-params">(input_img,split_channel : int, channel_color ,plotline = None, histogram = None, pic = None)</span>:</span><span class="hljs-comment">#     该通道的均衡曲线（分布函数曲线）</span><span class="hljs-comment">#     获取分离的通道</span>    input_channel = input_img[:,:,split_channel]    temp_he,temp_table = HistogramEqualizationLUT(input_channel)    <span class="hljs-keyword">if</span> plotline != <span class="hljs-keyword">None</span>:        plotline.set_title(<span class="hljs-string">"The function of "</span>+channel_color+<span class="hljs-string">" channel"</span>)        plotline.plot(np.arange(<span class="hljs-number">256</span>),np.arange(<span class="hljs-number">256</span>),color = <span class="hljs-string">"black"</span>,label = <span class="hljs-string">"$r_&#123;"</span> + channel_color +<span class="hljs-string">"&#125;$"</span>)        plotline.plot(np.arange(<span class="hljs-number">256</span>),temp_table,color = channel_color ,label = <span class="hljs-string">"$T(r_&#123;"</span>+ channel_color +<span class="hljs-string">"&#125;)$"</span>)        plotline.legend()<span class="hljs-comment">#     该通道的灰度分布直方图</span>    <span class="hljs-keyword">if</span> histogram != <span class="hljs-keyword">None</span>:        kwargs = dict(bins = <span class="hljs-number">25</span>, histtype=<span class="hljs-string">'bar'</span>, edgecolor = <span class="hljs-string">"white"</span>,alpha=<span class="hljs-number">0.5</span>, density  = <span class="hljs-keyword">True</span>)        histogram.set_title(<span class="hljs-string">"The histogram of "</span>+channel_color+<span class="hljs-string">" channel"</span>)        histogram.hist(input_channel.flatten(), color = <span class="hljs-string">"black"</span>,**kwargs, label = channel_color +<span class="hljs-string">" original"</span>)        histogram.hist(temp_he.flatten(), color = channel_color , **kwargs, label = channel_color +<span class="hljs-string">" after he"</span>)        histogram.legend()<span class="hljs-comment">#     该通道均匀后叠加到原图像的效果</span>    <span class="hljs-keyword">if</span> pic != <span class="hljs-keyword">None</span>:        show_img = input_img.copy()        show_img[:,:,split_channel] = temp_he        pic.imshow(show_img)<span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">DrawChannelsEqualization</span><span class="hljs-params">(img_with_3channels)</span>:</span>    plt.figure(figsize=(<span class="hljs-number">30</span>,<span class="hljs-number">30</span>))<span class="hljs-comment">#     调用库函数</span><span class="hljs-comment">#     r,g,b = cv2.split(im)</span><span class="hljs-comment">#     直接分离</span><span class="hljs-comment">#     r,g,b = img_with_3channels[:,:,0],img_with_3channels[:,:,1],img_with_3channels[:,:,2]</span>    DrawPerChannel(img_with_3channels,<span class="hljs-number">0</span>,<span class="hljs-string">"red"</span>,plt.subplot(<span class="hljs-number">331</span>),plt.subplot(<span class="hljs-number">334</span>),plt.subplot(<span class="hljs-number">337</span>))    DrawPerChannel(img_with_3channels,<span class="hljs-number">1</span>,<span class="hljs-string">"green"</span>,plt.subplot(<span class="hljs-number">332</span>),plt.subplot(<span class="hljs-number">335</span>),plt.subplot(<span class="hljs-number">338</span>))    DrawPerChannel(img_with_3channels,<span class="hljs-number">2</span>,<span class="hljs-string">"blue"</span>,plt.subplot(<span class="hljs-number">333</span>),plt.subplot(<span class="hljs-number">336</span>),plt.subplot(<span class="hljs-number">339</span>))    plt.show()DrawChannelsEqualization(im)</code></pre><pre><code class="hljs python"><span class="hljs-comment"># 测试三通道分别做均衡化后效果和采取统一函数做均衡化的效果</span><span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">DrawCompareEqualization</span><span class="hljs-params">(im_with_3_channel)</span>:</span>    together_img,together_table = HistogramEqualizationLUT(im_with_3_channel)    seperate_img = im_with_3_channel.copy()    seperate_table = np.array([together_table,together_table,together_table])    <span class="hljs-keyword">for</span> i <span class="hljs-keyword">in</span> range(<span class="hljs-number">3</span>):        seperate_img[:,:,i],seperate_table[i] = HistogramEqualizationLUT(im_with_3_channel[:,:,i])    plt.figure(figsize=(<span class="hljs-number">15</span>,<span class="hljs-number">10</span>))    plotline0 = plt.subplot(<span class="hljs-number">231</span>)    plotline0.set_title(<span class="hljs-string">"No Change"</span>)    plotline0.plot(np.arange(<span class="hljs-number">256</span>),np.arange(<span class="hljs-number">256</span>),color = <span class="hljs-string">"black"</span>,label = <span class="hljs-string">"$r$"</span>)    plotline1 = plt.subplot(<span class="hljs-number">232</span>)    plotline1.set_title(<span class="hljs-string">"Seperate Change"</span>)    plotline1.plot(np.arange(<span class="hljs-number">256</span>),np.arange(<span class="hljs-number">256</span>),color = <span class="hljs-string">"black"</span>,label = <span class="hljs-string">"$r$"</span>)    plotline1.plot(np.arange(<span class="hljs-number">256</span>),seperate_table[<span class="hljs-number">0</span>],color = <span class="hljs-string">"red"</span> ,label = <span class="hljs-string">"$T(r_&#123;red&#125;)$"</span>)    plotline1.plot(np.arange(<span class="hljs-number">256</span>),seperate_table[<span class="hljs-number">1</span>],color = <span class="hljs-string">"green"</span> ,label = <span class="hljs-string">"$T(r_&#123;green&#125;)$"</span>)    plotline1.plot(np.arange(<span class="hljs-number">256</span>),seperate_table[<span class="hljs-number">2</span>],color = <span class="hljs-string">"blue"</span> ,label = <span class="hljs-string">"$T(r_&#123;blue&#125;)$"</span>)    plotline1.legend()    plotline2 = plt.subplot(<span class="hljs-number">233</span>)    plotline2.set_title(<span class="hljs-string">"Together Change"</span>)    plotline2.plot(np.arange(<span class="hljs-number">256</span>),np.arange(<span class="hljs-number">256</span>),color = <span class="hljs-string">"black"</span>,label = <span class="hljs-string">"$r$"</span>)    plotline2.plot(np.arange(<span class="hljs-number">256</span>),together_table,color = <span class="hljs-string">"orange"</span> ,label = <span class="hljs-string">"$T(r_&#123;together&#125;)$"</span>)    plotline2.legend()    pic0 = plt.subplot(<span class="hljs-number">234</span>)    pic0.imshow(im_with_3_channel)    pic1 = plt.subplot(<span class="hljs-number">235</span>)    pic1.imshow(seperate_img)    pic2 = plt.subplot(<span class="hljs-number">236</span>)    pic2.imshow(together_img)    plt.show()DrawCompareEqualization(im)</code></pre><pre><code class="hljs python"><span class="hljs-comment"># 多来几组样例</span>imtest1 = imageio.imread(<span class="hljs-string">'imageio:chelsea.png'</span>)imtest2 = GetRGB(<span class="hljs-string">'./3_2Photo/2.jpg'</span>)imtest3 = GetRGB(<span class="hljs-string">'./3_2Photo/3.jpg'</span>)imtest4 = GetRGB(<span class="hljs-string">'./3_2Photo/4.tif'</span>)DrawCompareEqualization(imtest1)<span class="hljs-comment"># DrawCompareEqualization(imtest2)</span>DrawCompareEqualization(imtest3)DrawCompareEqualization(imtest4)</code></pre><pre><code class="hljs python"><span class="hljs-comment"># 展示直方图</span><span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">DrawHist</span><span class="hljs-params">(input_img,pic_handle,histogram_handle)</span>:</span>    kwargs = dict(bins = <span class="hljs-number">25</span>, histtype=<span class="hljs-string">'bar'</span>, edgecolor = <span class="hljs-string">"white"</span>,alpha=<span class="hljs-number">0.5</span>, density  = <span class="hljs-keyword">True</span>)    pic_handle.set_title(<span class="hljs-string">"The Image"</span>)    pic_handle.imshow(input_img,cmap = <span class="hljs-string">"gray"</span>)    histogram_handle.set_title(<span class="hljs-string">"The histogram_handle"</span>)    histogram_handle.hist(input_img.flatten(),**kwargs)plt.figure(figsize=(<span class="hljs-number">20</span>,<span class="hljs-number">15</span>))DrawHist(imtest1[:,:,<span class="hljs-number">0</span>],plt.subplot(<span class="hljs-number">321</span>),plt.subplot(<span class="hljs-number">322</span>))DrawHist(imtest2[:,:,<span class="hljs-number">0</span>],plt.subplot(<span class="hljs-number">323</span>),plt.subplot(<span class="hljs-number">324</span>))DrawHist(imtest3[:,:,<span class="hljs-number">0</span>],plt.subplot(<span class="hljs-number">325</span>),plt.subplot(<span class="hljs-number">326</span>))plt.show()</code></pre>]]></content>
    
    
    <categories>
      
      <category>Computer Science</category>
      
      <category>数字图像处理</category>
      
    </categories>
    
    
    <tags>
      
      <tag>数字图像处理</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>数论学习——黄金分割率</title>
    <link href="/post/460fad29.html"/>
    <url>/post/460fad29.html</url>
    
    <content type="html"><![CDATA[<h1 id="简介"><a href="#简介" class="headerlink" title="简介"></a>简介</h1><p>黄金分割是指将整体一分为二，较大部分与整体部分的比值等于较小部分与较大部分的比值，其比值<strong>约</strong>为 $0.618$。这个比例被公认为是最能引起美感的比例，因此被称为<strong>黄金分割</strong>。</p><h1 id="传说"><a href="#传说" class="headerlink" title="传说"></a>传说</h1><p>在古希腊时期，有一天毕达哥拉斯走在街上，在经过铁匠铺前他听到铁匠打铁的声音非常好听，于是驻足倾听。他发现铁匠打铁节奏很有规律，这个声音的比例被毕达哥拉斯用数学的方式表达出来</p><h1 id="数学公式"><a href="#数学公式" class="headerlink" title="数学公式"></a>数学公式</h1><h2 id="直接解"><a href="#直接解" class="headerlink" title="直接解"></a>直接解</h2><p>设$x$为黄金比，便有：</p><script type="math/tex; mode=display">\frac{1}{x} = \frac{x}{1-x}</script><script type="math/tex; mode=display">x^2 = 1-x</script><script type="math/tex; mode=display">x^2 + x - 1 = 0</script><script type="math/tex; mode=display">x_1 = \frac{-1-\sqrt{5}}{2}(舍),x_2 = \frac{-1+\sqrt{5}}{2}</script><p>上述即为数值解，$0.618$只是一个近似，从数值表述易知该数为一个<strong>无理数</strong>，给出前 32 位是：<br>$0.6180339887 4989484820458683436565$</p><h2 id="无穷连分数"><a href="#无穷连分数" class="headerlink" title="无穷连分数"></a>无穷连分数</h2><p>对刚才的数学公式做变形可以得到</p><script type="math/tex; mode=display">x= \frac{1}{x+1}</script><script type="math/tex; mode=display">x = \frac{1}{ 1 + \frac{1}{x+1} }</script><script type="math/tex; mode=display">x = \frac{1}{ 1 + \frac{1}{ 1+ \frac{1}{x+1}}}</script><h2 id="数列逼近"><a href="#数列逼近" class="headerlink" title="数列逼近"></a>数列逼近</h2><p>经计算发现相邻两个斐波那契数的比值是随序号的增加而逐渐逼近黄金分割比。由于斐波那契数都是整数，两个整数相除之商是有理数，而黄金分割是无理数，所以只是不断逼近黄金分割。</p><p>Python 验证:</p>]]></content>
    
    
    <categories>
      
      <category>Mathematics</category>
      
      <category>数论</category>
      
    </categories>
    
    
    <tags>
      
      <tag>数论</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>计算机图形学——OpenGL编程基础</title>
    <link href="/post/e5459685.html"/>
    <url>/post/e5459685.html</url>
    
    <content type="html"><![CDATA[<h1 id="什么是-OpenGL"><a href="#什么是-OpenGL" class="headerlink" title="什么是 OpenGL"></a>什么是 OpenGL</h1><p>一个图形学库，用来绘制，但是不负责 IO 输出，需要搭配 GLUT，GLUI，MFC，QT。</p><p>除了 OpenGL 外，业界常用还有 DirectX，微软专用的一个图形学库。</p><h1 id="编程环境配置"><a href="#编程环境配置" class="headerlink" title="编程环境配置"></a>编程环境配置</h1><p>图形库</p><ul><li>OpenGL<ul><li>工业</li></ul></li><li>GLUT</li><li>GLUI</li></ul><h1 id="动态链接库-静态链接库的区别-查"><a href="#动态链接库-静态链接库的区别-查" class="headerlink" title="动态链接库/静态链接库的区别 查"></a>动态链接库/静态链接库的区别 查</h1><h1 id="向量"><a href="#向量" class="headerlink" title="向量"></a>向量</h1><h2 id="向量的代数表达"><a href="#向量的代数表达" class="headerlink" title="向量的代数表达"></a>向量的代数表达</h2><ul><li>图形表示不方便</li></ul><h2 id="向量操作"><a href="#向量操作" class="headerlink" title="向量操作"></a>向量操作</h2><ul><li>标量乘法</li><li>点乘</li><li>叉乘</li></ul><h1 id="坐标系统"><a href="#坐标系统" class="headerlink" title="坐标系统"></a>坐标系统</h1><ul><li>在二维平面上，给定两个基向量，可以表示整个空间（基向量，空间由这两个向量张成）</li></ul><h1 id="给定一个二维的多边形，判断它是否是凸多边形"><a href="#给定一个二维的多边形，判断它是否是凸多边形" class="headerlink" title="给定一个二维的多边形，判断它是否是凸多边形"></a>给定一个二维的多边形，判断它是否是凸多边形</h1><p>凸包算法，逆时针遍历点，计算新向量与原向量的叉积，方向一致的应为凸多边形，方向改变的是凹多边形。</p>]]></content>
    
    
    <categories>
      
      <category>Computer Science</category>
      
      <category>计算机图形学</category>
      
    </categories>
    
    
    <tags>
      
      <tag>计算机图形学</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>数论学习——Stirling数</title>
    <link href="/post/ac8faa8e.html"/>
    <url>/post/ac8faa8e.html</url>
    
    <content type="html"><![CDATA[<h1 id="问题引出"><a href="#问题引出" class="headerlink" title="问题引出"></a>问题引出</h1><p>用矩阵来表示样本属于哪类划分类别的过程中，老师提出的一个问题：从$N$个样本中分出$C$类，不同的分法一共有多少种？</p><p>抽象：$N$个数划分为$C$个集合，要求集合不能为空，方案数为？</p><p><strong>就是第二类斯特林数</strong>。</p><h1 id="解答"><a href="#解答" class="headerlink" title="解答"></a>解答</h1><h2 id="递推"><a href="#递推" class="headerlink" title="递推"></a>递推</h2><p>其实是个数学的问题，和组合数的公式有些类似，所以我们尝试求其递推式，从$N$个数划分为$C$个非空集合，如果前面各数都已经划分好到所属集合，剩下最后一个数未划分，考虑最后一个数，则有以下两种情况：</p><ol><li>前面$N-1$个数划分的集合数为$C-1$，则最后一个数必须单独属于一个新集合。</li><li>前面$N-1$个数划分的集合数为$C$，则最后一个数可以属于先前$C$个集合中的任意一个。</li></ol><p>用更数学的方式表达，$S(n,c)$表示我们所求，则有以下转移方程。</p><script type="math/tex; mode=display">S(n,c) = S(n-1,c-1)+n*S(n-1,c)</script><h2 id="容斥原理（通项公式）"><a href="#容斥原理（通项公式）" class="headerlink" title="容斥原理（通项公式）"></a>容斥原理（通项公式）</h2><p>考虑容斥的话思路尝尝是从一个大数减起，对于这个计算直觉应该是从这个大数：$c^n$（把$n$个球放进$c$个可空的不同集合的总方案数，另一个角度就是$n$位$c$进制数可表达的数的范围）</p><p>那我们应该如何计算得到我们想要的$S(n,c)$呢？（容斥思想）</p><p>考虑$c^n$中包含着可空的情况，又考虑到直接求<strong>恰</strong>有$x$个集合满的情况，我们采取曲线救国的方式（也是容斥原理中常用的），我们可以求出<strong>至少</strong>$x$个集合满的情况，实际上就是$(c-k)^{n}$。</p><p>那我们就可以容斥了，枚举空集的情况数然后求个 Sum 就行，给出公式：</p><script type="math/tex; mode=display">S(n,c) = \frac{1}{m!} \sum_{k=0}^{m} (-1)^kC(m,k)(m-k)^n</script><p>再一言以蔽之：就是枚举空集合的数目，剩下的随意放置，容斥以下就可以得到最终的答案了。</p>]]></content>
    
    
    <categories>
      
      <category>Mathematics</category>
      
      <category>数论</category>
      
    </categories>
    
    
    <tags>
      
      <tag>数论</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>CCFADL105——面向下一代计算的开源芯片与敏捷开发方法</title>
    <link href="/post/e4eb9281.html"/>
    <url>/post/e4eb9281.html</url>
    
    <content type="html"><![CDATA[<h1 id="面向下一代计算的开源芯片与敏捷开发方法"><a href="#面向下一代计算的开源芯片与敏捷开发方法" class="headerlink" title="面向下一代计算的开源芯片与敏捷开发方法"></a>面向下一代计算的开源芯片与敏捷开发方法</h1><p>主讲人：包云岗老师（中科院计算所， 先进计算机系统研究中心）</p><h1 id="Memory-Wall"><a href="#Memory-Wall" class="headerlink" title="Memory Wall"></a>Memory Wall</h1><h2 id="提出背景：System-Architecture"><a href="#提出背景：System-Architecture" class="headerlink" title="提出背景：System Architecture"></a>提出背景：System Architecture</h2><p>1995 年提出，成为体系结构研究的最重要问题之一</p><ul><li>多核处理器的流行</li><li>延迟与带宽显得更为重要</li></ul><h2 id="应对思路"><a href="#应对思路" class="headerlink" title="应对思路"></a>应对思路</h2><ul><li>工具模型：HMTT、C-MAT</li><li>预取技术：Memory Hierarchy</li><li>新型存储：3D Stack、HBM、NVM</li><li>新架构： Process-in-Memory、Domain-Specific Architecture</li></ul><h2 id="HMTT-访存监控仪器"><a href="#HMTT-访存监控仪器" class="headerlink" title="HMTT 访存监控仪器"></a>HMTT 访存监控仪器</h2><p>包老师博士期间的工作，现在已经迭代了几个版本。</p><ul><li>需求<ul><li>安捷伦等逻辑分析仪：<strong>无法检测</strong>到云计算环境下<strong>多应用混合</strong>后的数据通路中的应用访存行为（不具备对应用进行带语义的监控）</li><li>提出<strong>软硬件协同</strong>监测新方法，研制<strong>HMTT 访存监控仪</strong></li></ul></li><li>工作流程<ul><li>物理地址追踪（Physical Address Trace）：作为硬件，不影响其性能，直插在内存槽获取其物理地址</li><li>虚拟地址追踪（Virtual Address Trace）：转换成虚拟地址以了解进程相关的信息</li><li>访问对象（Object Access Pattern）：通过对虚拟地址的再分析，与变量关联起来</li></ul></li></ul><p>工作示意图如下</p><p><img src="https://eddyblog.oss-cn-shenzhen.aliyuncs.com/CCFADL105/YungangBao/%E5%8C%85%E4%BA%91%E5%B2%97-%E9%9D%A2%E5%90%91%E4%B8%8B%E4%B8%80%E4%BB%A3%E8%AE%A1%E7%AE%97%E7%9A%84%E5%BC%80%E6%BA%90%E8%8A%AF%E7%89%87%E4%B8%8E%E6%95%8F%E6%8D%B7%E5%BC%80%E5%8F%91%E8%AE%BE%E8%AE%A1_page-0007.jpg" srcset="/img/loading.gif" alt="HMTT1"></p><a id="more"></a><h3 id="软件挑战"><a href="#软件挑战" class="headerlink" title="软件挑战"></a>软件挑战</h3><p>虚拟地址到物理地址的重映射技术我们上课都学到过，可是如何从物理地址反过来获取虚拟地址呢？</p><p><strong>如何物理地址翻译为进程的虚拟地址</strong>（物理地址-&gt;软件语义信息）</p><p>解决：<strong>修改 Kernel</strong></p><ul><li>通过修改内核使得硬件可以获取到页表的 page table</li><li>在导出的页表中反查物理地址，获得进程产生的虚拟地址</li></ul><p>问题：</p><ul><li>扫描当前页表</li><li>缺页替换则对应不同进程信息</li><li>如何同步更新 HMTT 硬件信息</li></ul><h3 id="同步挑战"><a href="#同步挑战" class="headerlink" title="同步挑战"></a>同步挑战</h3><p><strong>当 OS 内核发生页表更新时，如何通知 HMTT 硬件</strong></p><p>解决：<strong>高层事件编码机制：High-Level Event Encoding Mechanism（HLE2M）</strong></p><ul><li>保留一段物理内存地址空间</li><li>将高层事件映射到该空间</li><li>侦听对该地址空间的访存请求</li><li>将访存硬件转换为高层时间</li></ul><p>理解：将高层事件多一个<strong>分支</strong>结果，访问这一小块内存空间（相对集中），就如同一段标记数组，用来记录访存情况（次数）。</p><p>图示:</p><p><img src="https://eddyblog.oss-cn-shenzhen.aliyuncs.com/CCFADL105/YungangBao/%E5%8C%85%E4%BA%91%E5%B2%97-%E9%9D%A2%E5%90%91%E4%B8%8B%E4%B8%80%E4%BB%A3%E8%AE%A1%E7%AE%97%E7%9A%84%E5%BC%80%E6%BA%90%E8%8A%AF%E7%89%87%E4%B8%8E%E6%95%8F%E6%8D%B7%E5%BC%80%E5%8F%91%E8%AE%BE%E8%AE%A1_page-0009.jpg" srcset="/img/loading.gif" alt="HMTT2"></p><p>以页表更新事件为例（举一反三，其他高层事件也可以比如 CPU/DMA 访问，加锁操作）：</p><p><img src="https://eddyblog.oss-cn-shenzhen.aliyuncs.com/CCFADL105/YungangBao/%E5%8C%85%E4%BA%91%E5%B2%97-%E9%9D%A2%E5%90%91%E4%B8%8B%E4%B8%80%E4%BB%A3%E8%AE%A1%E7%AE%97%E7%9A%84%E5%BC%80%E6%BA%90%E8%8A%AF%E7%89%87%E4%B8%8E%E6%95%8F%E6%8D%B7%E5%BC%80%E5%8F%91%E8%AE%BE%E8%AE%A1_page-0010.jpg" srcset="/img/loading.gif" alt="HMTT3"></p><h2 id="模型分析"><a href="#模型分析" class="headerlink" title="模型分析"></a>模型分析</h2><p>系统结构的并发度没有被充分利用或优化利用</p><p>更多资料来源，刘宇航副研究员，中科院计算所</p><p>基于并发的存储层间性能匹配（LPM），漏斗状，如下图</p><p><img src="https://eddyblog.oss-cn-shenzhen.aliyuncs.com/CCFADL105/YungangBao/%E5%8C%85%E4%BA%91%E5%B2%97-%E9%9D%A2%E5%90%91%E4%B8%8B%E4%B8%80%E4%BB%A3%E8%AE%A1%E7%AE%97%E7%9A%84%E5%BC%80%E6%BA%90%E8%8A%AF%E7%89%87%E4%B8%8E%E6%95%8F%E6%8D%B7%E5%BC%80%E5%8F%91%E8%AE%BE%E8%AE%A1_page-0015.jpg" srcset="/img/loading.gif" alt="LPM"></p><h2 id="数据预取"><a href="#数据预取" class="headerlink" title="数据预取"></a>数据预取</h2><p>何为数据预取？将未来所需要访问的数据提前取到更靠近处理器的 Cache 中，可以有效隐藏访存延迟</p><p>需求：</p><ul><li>手机处理器对于敏捷反应，以及其他落地应用的需求</li><li>苹果是个黑洞（闭环自研）</li><li>华为与科研机构的合作使得需求更明晰</li></ul><p>学术界的研究情况：</p><ul><li>提出了多种预取策略，如顺序预取，Stride 预取，马尔科夫预取…</li><li>主要针对 Memory Hierarchy 的某个特定层次，如 L1 Cache 或者 L2 Cache</li></ul><h2 id="领域专用体系结构-DSA"><a href="#领域专用体系结构-DSA" class="headerlink" title="领域专用体系结构 DSA"></a>领域专用体系结构 DSA</h2><p>Domain Specific Architecture（DSA，即针对应用领域做优化的处理器架构，区别于通用架构）。</p><p>从普通码农用 python，到算法工程师从数据结构算法上优化，如果懂得并行化算法的人，还可以在并行度上优化，在往上还可以做内存优化和指令级优化，<strong>整体性能提升是惊人的</strong>。</p><p><img src="https://eddyblog.oss-cn-shenzhen.aliyuncs.com/CCFADL105/YungangBao/%E5%8C%85%E4%BA%91%E5%B2%97-%E9%9D%A2%E5%90%91%E4%B8%8B%E4%B8%80%E4%BB%A3%E8%AE%A1%E7%AE%97%E7%9A%84%E5%BC%80%E6%BA%90%E8%8A%AF%E7%89%87%E4%B8%8E%E6%95%8F%E6%8D%B7%E5%BC%80%E5%8F%91%E8%AE%BE%E8%AE%A1_page-0017.jpg" srcset="/img/loading.gif" alt="DSA"></p><p>若将“人”的经验固化到芯片中去，是一件听起来很美妙的事情。</p><p>性能差异来源分析</p><ul><li>并行度挖掘不够？</li><li>数据移动开销太大？</li></ul><h2 id="DSA：是道，非术"><a href="#DSA：是道，非术" class="headerlink" title="DSA：是道，非术"></a>DSA：是道，非术</h2><ul><li>DSA 是一种理念，尚未形成通用的技术方案</li><li>DSA 未来可能的形态<ul><li>每个解决方案对应一颗 SoC 与适配软件</li><li>每颗 SoC 包括<ul><li>一个通用的基础平台，如 RISC-V + AXI</li><li>若干个领域加速器，如 APU、BPU、NPU</li></ul></li><li>芯片敏捷开发工具<ul><li>Chisel + OpenEDA + …</li></ul></li><li>低门槛开发平台与制造渠道</li></ul></li></ul><h1 id="标签化体系结构"><a href="#标签化体系结构" class="headerlink" title="标签化体系结构"></a>标签化体系结构</h1><p>研究历程，拆解核尝试（失败），MicroBlaze（非开源，受挫），开源指令集 RISC-V 基础上实现（成功）</p><p><img src="https://eddyblog.oss-cn-shenzhen.aliyuncs.com/CCFADL105/YungangBao/%E5%8C%85%E4%BA%91%E5%B2%97-%E9%9D%A2%E5%90%91%E4%B8%8B%E4%B8%80%E4%BB%A3%E8%AE%A1%E7%AE%97%E7%9A%84%E5%BC%80%E6%BA%90%E8%8A%AF%E7%89%87%E4%B8%8E%E6%95%8F%E6%8D%B7%E5%BC%80%E5%8F%91%E8%AE%BE%E8%AE%A1_page-0023.jpg" srcset="/img/loading.gif" alt="DSA"></p><h2 id="背景介绍"><a href="#背景介绍" class="headerlink" title="背景介绍"></a>背景介绍</h2><p>如之前 HMTT 的思想，希望实现新的接口，使得高层软件的信息可以传递到底层硬件中去，底层对上层有意识而采取更具针对性的解决，提高效率（而非像现在一样，底层对上层完全 unawareness）。</p><p>单任务稳定环境下性能波动与共享环境下的性能波动的两个实验：</p><p><img src="https://eddyblog.oss-cn-shenzhen.aliyuncs.com/CCFADL105/YungangBao/%E5%8C%85%E4%BA%91%E5%B2%97-%E9%9D%A2%E5%90%91%E4%B8%8B%E4%B8%80%E4%BB%A3%E8%AE%A1%E7%AE%97%E7%9A%84%E5%BC%80%E6%BA%90%E8%8A%AF%E7%89%87%E4%B8%8E%E6%95%8F%E6%8D%B7%E5%BC%80%E5%8F%91%E8%AE%BE%E8%AE%A1_page-0028.jpg" srcset="/img/loading.gif" alt="DSA"></p><p><img src="https://eddyblog.oss-cn-shenzhen.aliyuncs.com/CCFADL105/YungangBao/%E5%8C%85%E4%BA%91%E5%B2%97-%E9%9D%A2%E5%90%91%E4%B8%8B%E4%B8%80%E4%BB%A3%E8%AE%A1%E7%AE%97%E7%9A%84%E5%BC%80%E6%BA%90%E8%8A%AF%E7%89%87%E4%B8%8E%E6%95%8F%E6%8D%B7%E5%BC%80%E5%8F%91%E8%AE%BE%E8%AE%A1_page-0030.jpg" srcset="/img/loading.gif" alt="DSA"></p><h2 id="需求场景"><a href="#需求场景" class="headerlink" title="需求场景"></a>需求场景</h2><p>航空航天等实时场景</p><ul><li>机载计算机<strong>关闭多核</strong>以保证实时性</li><li>美国联邦航空管理局 FAA<strong>出台相关白皮书</strong></li></ul><p>用户体验敏感场景</p><ul><li>手机芯片内部多部件<strong>竞争冲突</strong>，<strong>操作卡顿</strong>，影响用户体验</li></ul><p>亟需体系结构的创新</p><h2 id="控制与弱化控制"><a href="#控制与弱化控制" class="headerlink" title="控制与弱化控制"></a>控制与弱化控制</h2><p>回顾历史，重新审视冯·诺依曼结构：</p><ul><li>体系结构中的控制<ul><li>1953 年，图灵奖得主 Maurice Wikes 提出<strong>微程序</strong>来设计处理器的控制单元</li></ul></li><li>控制被弱化<ul><li>1980 年，RISC 成为主流，体系结构研究主要关注<strong>部件</strong>与<strong>数据通路</strong>的设计与优化，弱化了控制</li></ul></li></ul><p>但是弱化控制随着 CPU 核数，并行度要求的提高导致的问题越来越突出：性能不稳定。</p><p>共享环境下，多应用共享硬件，弱化控制会导致硬件<strong>出现无序竞争</strong>，进而引起严重的性能波动，Data Shuffling 犹如一条无序竞争的马路。</p><p>冯诺依曼瓶颈</p><p><img src="https://eddyblog.oss-cn-shenzhen.aliyuncs.com/CCFADL105/YungangBao/%E5%8C%85%E4%BA%91%E5%B2%97-%E9%9D%A2%E5%90%91%E4%B8%8B%E4%B8%80%E4%BB%A3%E8%AE%A1%E7%AE%97%E7%9A%84%E5%BC%80%E6%BA%90%E8%8A%AF%E7%89%87%E4%B8%8E%E6%95%8F%E6%8D%B7%E5%BC%80%E5%8F%91%E8%AE%BE%E8%AE%A1_page-0038.jpg" srcset="/img/loading.gif" alt="Bottleneck1"></p><h2 id="尝试方法"><a href="#尝试方法" class="headerlink" title="尝试方法"></a>尝试方法</h2><ul><li>存储层次+多核<ul><li>多核结构存储层次分化：核内+核外</li><li>核内 L1/L2 复制多份，共享核外 L3/Mem/IO</li></ul></li></ul><h2 id="存在问题"><a href="#存在问题" class="headerlink" title="存在问题"></a>存在问题</h2><ul><li><p>无序共享导致性能无法得到保障</p><ul><li><strong>性能不确定</strong>：三级缓存（L3）共享会造成高达 3 倍以上性能下降，引起云计算“<strong>吵闹的邻居</strong>”问题。</li><li>L3 无从判断应用的紧急程度</li></ul></li></ul><p>图示：单独可以，一同使用就出问题</p><p><img src="https://eddyblog.oss-cn-shenzhen.aliyuncs.com/CCFADL105/YungangBao/%E5%8C%85%E4%BA%91%E5%B2%97-%E9%9D%A2%E5%90%91%E4%B8%8B%E4%B8%80%E4%BB%A3%E8%AE%A1%E7%AE%97%E7%9A%84%E5%BC%80%E6%BA%90%E8%8A%AF%E7%89%87%E4%B8%8E%E6%95%8F%E6%8D%B7%E5%BC%80%E5%8F%91%E8%AE%BE%E8%AE%A1_page-0041.jpg" srcset="/img/loading.gif" alt="Bottleneck2"></p><ul><li>硬件上存在大量无序竞争<ul><li>CPU、内存、网络、磁盘都会因为无序共享，造成用户体验差。</li></ul></li></ul><p>图示</p><p><img src="https://eddyblog.oss-cn-shenzhen.aliyuncs.com/CCFADL105/YungangBao/%E5%8C%85%E4%BA%91%E5%B2%97-%E9%9D%A2%E5%90%91%E4%B8%8B%E4%B8%80%E4%BB%A3%E8%AE%A1%E7%AE%97%E7%9A%84%E5%BC%80%E6%BA%90%E8%8A%AF%E7%89%87%E4%B8%8E%E6%95%8F%E6%8D%B7%E5%BC%80%E5%8F%91%E8%AE%BE%E8%AE%A1_page-0042.jpg" srcset="/img/loading.gif" alt="Bottleneck3"></p><h2 id="接口设计"><a href="#接口设计" class="headerlink" title="接口设计"></a>接口设计</h2><p>1973 年，Feustel 教授提出 Tagged Architecture</p><ul><li>核心思想是<strong>将高层语言信息传递到底层硬件</strong></li><li>替代冯诺伊曼结构</li></ul><p>设计原理：</p><ul><li>所有数据赋予一个<strong>类型标签</strong></li><li>标签<strong>存于内存</strong>中</li><li>标签<strong>触发中断</strong>进行处理</li></ul><p>问题：</p><ul><li><strong>设计太复杂，难以实现</strong></li></ul><h2 id="SDN-到计算机"><a href="#SDN-到计算机" class="headerlink" title="SDN 到计算机"></a>SDN 到计算机</h2><p>2010-2012 在普林斯顿 PARSEC 研究内容：标签化网络、frenetic（一种网络编程语言）、P4</p><p>从 SDN 网络架构借鉴思路，<strong>计算机即网络（Computer as a Network）</strong>，计算机本质上就是一个网络，内部的不同部件通过包进行通信——PCIe 包、QPI 包、NoC 包，……</p><div class="table-container"><table><thead><tr><th></th><th>SDN 核心原理</th><th>标签化冯·诺依曼体系结构</th></tr></thead><tbody><tr><td><strong>细粒度对象</strong></td><td>每个网络包增加一个标签（Label）</td><td>每个内部请求（如访存请求）增加一个标签</td></tr><tr><td><strong>关联语义</strong></td><td>标签值与用户的网络需求关联</td><td>标签值与上层 VM/进程/线程/变量等关联（高层信息）</td></tr><tr><td><strong>携带传播</strong></td><td>网络包传播过程中携带标签</td><td>标签在计算机访问各个存储层次过程中全程携带</td></tr><tr><td><strong>标签控制逻辑</strong></td><td>网络设备基于标签控制网络包转发</td><td>基于标签的请求区分处理（底层高效）</td></tr></tbody></table></div><p>从 SDN 到计算机，从标签化网络到标签化冯诺依曼体系结构</p><p>业界尝试：2016 年 Intel RDT 技术、PARD</p><h2 id="最小污染原则"><a href="#最小污染原则" class="headerlink" title="最小污染原则"></a>最小污染原则</h2><div class="table-container"><table><thead><tr><th>70 年代标签体系结构失败原因</th><th>LvNA 的三条“最小污染”规则：</th></tr></thead><tbody><tr><td>所有数据赋予一个<strong>类型标签</strong></td><td>标签应尽可能简单</td></tr><tr><td>标签<strong>存于内存</strong>中</td><td>标签存于<strong>请求</strong>中</td></tr><tr><td>标签<strong>触发中断</strong>进行处理</td><td>控制逻辑放置在数据通路上</td></tr></tbody></table></div><p>增加标签寄存器，标签关联硬件虚拟机，传播标签，可编程控制逻辑</p><h2 id="尝试与实现"><a href="#尝试与实现" class="headerlink" title="尝试与实现"></a>尝试与实现</h2><ul><li><p>尝试 1：基于 MCU（微控制单元）的控制逻辑，尝试 2：基于表的控制逻辑</p></li><li><p>尝试 2：基于表的控制逻辑</p></li><li><p>集中平台资源管理</p><ul><li>连接所有控制逻辑形成控制平面</li><li>运行基于 Linux 的固件</li><li>将控制逻辑抽象为文件</li></ul></li><li><p>实现</p><ul><li>Full-system cycle-accurate simulator</li><li>FPGA prototype on Xilinx VC709 evaluation board<ul><li>MicroBlaze version $\times$</li><li>RISC-V version $\checkmark$</li></ul></li></ul></li><li><p>演示</p></li></ul><p><img src="https://eddyblog.oss-cn-shenzhen.aliyuncs.com/CCFADL105/YungangBao/%E5%8C%85%E4%BA%91%E5%B2%97-%E9%9D%A2%E5%90%91%E4%B8%8B%E4%B8%80%E4%BB%A3%E8%AE%A1%E7%AE%97%E7%9A%84%E5%BC%80%E6%BA%90%E8%8A%AF%E7%89%87%E4%B8%8E%E6%95%8F%E6%8D%B7%E5%BC%80%E5%8F%91%E8%AE%BE%E8%AE%A1_page-0066.jpg" srcset="/img/loading.gif" alt="Show"></p><h2 id="硬件资源动态调整的共性问题"><a href="#硬件资源动态调整的共性问题" class="headerlink" title="硬件资源动态调整的共性问题"></a>硬件资源动态调整的共性问题</h2><p>本质问题：<strong>如何在混合环境下预测出应用单独运行时需要的资源？</strong></p><p><img src="https://eddyblog.oss-cn-shenzhen.aliyuncs.com/CCFADL105/YungangBao/%E5%8C%85%E4%BA%91%E5%B2%97-%E9%9D%A2%E5%90%91%E4%B8%8B%E4%B8%80%E4%BB%A3%E8%AE%A1%E7%AE%97%E7%9A%84%E5%BC%80%E6%BA%90%E8%8A%AF%E7%89%87%E4%B8%8E%E6%95%8F%E6%8D%B7%E5%BC%80%E5%8F%91%E8%AE%BE%E8%AE%A1_page-0067.jpg" srcset="/img/loading.gif" alt="Source"></p><ul><li>解决方法 1：离线分析建模，预测动态资源需求</li><li>解决方法 2：在线实时预测动态资源需求</li><li>Shadow X 机制：针对不同资源设计一套<strong>影子资源模型，模拟推断应用单独运行时所需资源</strong></li></ul><div class="table-container"><table><thead><tr><th>共享模型</th><th>Shadow X 机制</th></tr></thead><tbody><tr><td>SMT</td><td>利用<strong>Shadow Table</strong>获得 PTA 资源（ICS2019）</td></tr><tr><td>LLC</td><td>利用<strong>Shadow Tag</strong>来获得一条 hit rate 曲线</td></tr><tr><td>Mem Bandwidth</td><td>利用<strong>Shadow 感知机</strong>获得内存宽带</td></tr></tbody></table></div><p>实现自动 LLC 管理和自动访存宽带管理</p><p>芯片验证：与 771 所合作，正在开展 8 核 Labeled RISC-V 流片</p><h2 id="同行进展"><a href="#同行进展" class="headerlink" title="同行进展"></a>同行进展</h2><p>ARM 正在研究基于标签的<strong>MPAM</strong>技术：Memory Partitioning and Monitoring</p><h2 id="学习教程"><a href="#学习教程" class="headerlink" title="学习教程"></a>学习教程</h2><p><a href="http://sdc.ict.ac.cn/micro2018-tutorial/" target="_blank" rel="noopener">作者提供的教程 Labled ISC-V: A Case for Software-Defined Architecture</a></p><p><a href="https://github.com/LvNA-system/labeled-RISC-V" target="_blank" rel="noopener">开源代码 Open-Sourced Codes</a></p><h1 id="开源芯片与敏捷开发"><a href="#开源芯片与敏捷开发" class="headerlink" title="开源芯片与敏捷开发"></a>开源芯片与敏捷开发</h1><p>主要讲了当前局势和芯片开发学习的未来。</p><ul><li>中国高科技企业正面临美国技术“核打击”</li><li>优秀人才储备严重不足<ul><li>如果认为 ISCA 论文第一作者是行业专业技术佼佼者</li><li>十年来 85%选择在美国就业，仅 4%在中国就业</li></ul></li><li>芯片设计门槛高，大学无能力培养优秀人才<ul><li>时间长</li><li>成本高</li></ul></li><li>降低芯片门槛是人才危机一种破解之道<ul><li>美国经验：MISIS 项目，为大学提供流片服务。</li></ul></li></ul><h2 id="领域专用体系结构星期"><a href="#领域专用体系结构星期" class="headerlink" title="领域专用体系结构星期"></a>领域专用体系结构星期</h2><p><strong>如何弥补软硬件性能鸿沟？</strong></p><ul><li>硬件加速器</li><li>领域专用体系结构（DSA Domain Specific Architecture)</li></ul><h2 id="开源芯片，降低芯片设计门槛"><a href="#开源芯片，降低芯片设计门槛" class="headerlink" title="开源芯片，降低芯片设计门槛"></a>开源芯片，降低芯片设计门槛</h2><p><a href="http://blog.sciencenet.cn/home.php?mod=space&amp;uid=414166&amp;do=blog&amp;id=1192579" target="_blank" rel="noopener">远景研讨会纪要：面向下一代计算的开源芯片与敏捷开发</a></p><h2 id="RISC-V-国际开源实验室（RIOS）成立"><a href="#RISC-V-国际开源实验室（RIOS）成立" class="headerlink" title="RISC-V 国际开源实验室（RIOS）成立"></a>RISC-V 国际开源实验室（RIOS）成立</h2><p>大卫·帕特森（David Patternson）在瑞士宣布依托清华-伯克利深圳学院建设 RIOS（RISC-V International Open Source Laboratory）实验室，全面提升 RISC-V 生态系统至最先进水平。</p>]]></content>
    
    
    <categories>
      
      <category>Research</category>
      
      <category>讲座会议</category>
      
    </categories>
    
    
    <tags>
      
      <tag>讲座会议</tag>
      
      <tag>CCFADL</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>CCFADL105——面向非易失性存储介质的文件系统设计、实现与形式化验证</title>
    <link href="/post/f82955ec.html"/>
    <url>/post/f82955ec.html</url>
    
    <content type="html"><![CDATA[<h1 id="面向非易失性存储介质的文件系统设计、实现与形式化验证"><a href="#面向非易失性存储介质的文件系统设计、实现与形式化验证" class="headerlink" title="面向非易失性存储介质的文件系统设计、实现与形式化验证"></a>面向非易失性存储介质的文件系统设计、实现与形式化验证</h1><p>主讲人：陈海波老师（上海交通大学教授， IPAD 小组导师，华为鸿蒙系统研发）</p><h1 id="Background：How-to-Climb-Up-the-Memory-Hierarchy"><a href="#Background：How-to-Climb-Up-the-Memory-Hierarchy" class="headerlink" title="Background：How to Climb Up the Memory Hierarchy"></a>Background：How to Climb Up the Memory Hierarchy</h1><p>Jim Gray 对于存储层次（Memory Hierarchy）演进的经典论断：<strong>Tape is Dead, Disk is Tape, Flash is Disk, RAM Locality is King.</strong></p><p>JG 论断提出的背景是 06 年 SSD 刚刚出来，那么随着硬件技术的发展，JG 的论断也该有新的诠释。</p><h1 id="Non-volatile-Memory-NVM-Revolution"><a href="#Non-volatile-Memory-NVM-Revolution" class="headerlink" title="Non-volatile Memory(NVM) Revolution"></a>Non-volatile Memory(NVM) Revolution</h1><h2 id="产品化元年"><a href="#产品化元年" class="headerlink" title="产品化元年"></a>产品化元年</h2><p>非易失性存储硬件的出现，Non-volatile Memory（NVM），带来的数据可持久化是颠覆性的改变。从体系结构的角度，CPU 内部整合内存虽然还没有实际上发生，但是今年发生的一件事是，放了许多年鸽子的 NVM Memory 终于产品化了，今年三月份 Intel 开始对外出售，中文名傲腾系列。<a href="https://zh.wikipedia.org/wiki/3D_XPoint" target="_blank" rel="noopener">3D XPoint 维基百科</a></p><p>先前为了实现 Persistence（持久化），NVDIM 技术是附加电容，在断电时通过电容，将 RAM 的数据刷到硬盘中，从而达到持久化的效果。</p><p>抉择：Performance vs. Persistence，以传统结构来说，选择 Performance，我们减少写回磁盘的次数，而主要在 RAM 上操作，但是这就面临掉电丢失数据的风险，难以持久化，而若选择 Persistence，频繁写入磁盘，则在 IO 上就要耗费更多的时间，效率降低。</p><p>Intel Optane DC Persistent Memory 性能表现</p><p><img src="https://eddyblog.oss-cn-shenzhen.aliyuncs.com/CCFADL105/HaiboChen/HaiboChen_page-0006.jpg" srcset="/img/loading.gif" alt="NVM1"></p><p><img src="https://eddyblog.oss-cn-shenzhen.aliyuncs.com/CCFADL105/HaiboChen/HaiboChen_page-0007.jpg" srcset="/img/loading.gif" alt="NVM2"></p><p><img src="https://eddyblog.oss-cn-shenzhen.aliyuncs.com/CCFADL105/HaiboChen/HaiboChen_page-0008.jpg" srcset="/img/loading.gif" alt="NVM3"></p><p>在 NVM 产品化元年，真正的 Persistent Memory 到来时，如果针对其特性构建系统？</p><a id="more"></a><h2 id="改变-Memory-Hierarchy"><a href="#改变-Memory-Hierarchy" class="headerlink" title="改变 Memory Hierarchy"></a>改变 Memory Hierarchy</h2><p>改变了其中的易失/持久的边界</p><p><img src="https://eddyblog.oss-cn-shenzhen.aliyuncs.com/CCFADL105/HaiboChen/HaiboChen_page-0009.jpg" srcset="/img/loading.gif" alt="NVM4"></p><h2 id="不成比例扩展效应-Incommensurate-scaling"><a href="#不成比例扩展效应-Incommensurate-scaling" class="headerlink" title="不成比例扩展效应 Incommensurate scaling"></a>不成比例扩展效应 Incommensurate scaling</h2><p>如果计算机体系结构某个部分突然快 10 倍，便会使人们重新审视整个系统，调度、Storage 管理</p><blockquote><p>As a system increases in size or speed, not all parts of it (&amp;human factors) follow the same scaling rules. — Saltzer &amp; Kaashoek</p></blockquote><p>考虑 NVM 带来的影响，如下图，非易失性设备访问速度提升了 1000-10000 倍，不仅系统本身，评测系统的 Benchmark，思考问题的角度，都需要重新调整。</p><p><img src="https://eddyblog.oss-cn-shenzhen.aliyuncs.com/CCFADL105/HaiboChen/HaiboChen_page-0010.jpg" srcset="/img/loading.gif" alt="NVM5"></p><h2 id="启发"><a href="#启发" class="headerlink" title="启发"></a>启发</h2><p>Tape is Dead, Disk is Tape, Flash is Disk, \sout{RAM Locality is King.}\par RAM is Flash, <strong>Cache Locality/Parallelism is King?</strong></p><p>从硬件革新，重新审视系统的软件栈。</p><p><img src="https://eddyblog.oss-cn-shenzhen.aliyuncs.com/CCFADL105/HaiboChen/HaiboChen_page-0012.jpg" srcset="/img/loading.gif" alt="Opportunities"></p><h1 id="SoupFS"><a href="#SoupFS" class="headerlink" title="SoupFS"></a>SoupFS</h1><p>An NVM file system in Kernel(USENIX ATC’17)</p><h2 id="为什么在乎文件系统"><a href="#为什么在乎文件系统" class="headerlink" title="为什么在乎文件系统"></a>为什么在乎文件系统</h2><ul><li>文件系统储存我们所有的数据</li><li>文件系统的表现是系统整体表现得关键</li><li>文件系统是解决 Performance 和 Persistence 矛盾得关键</li></ul><p>现有得 NVMFS 使用日志（journaling）或者边复制边写（copy-on-write）的方式来实现崩溃时保持一致性（crash consistency），但由于 CPU cache 仍然是易失的，由此引发出明显的性能问题：</p><ul><li>同步 cache 和 NVM 导致 cache flushes 是必要的</li><li>cache flushes 代价很大</li></ul><p>思考：不适用这两种方式，其他方式实现 crash consistency？</p><p>有的，前人也做过研究：1999 年 Marshall 和 Gregory R. Ganger 在 USENIX 上发表论文介绍的方法：<strong>Soft Updates</strong></p><h2 id="Soft-Updates"><a href="#Soft-Updates" class="headerlink" title="Soft Updates"></a>Soft Updates</h2><h3 id="What-Is-Soft-Updates"><a href="#What-Is-Soft-Updates" class="headerlink" title="What Is Soft Updates"></a>What Is Soft Updates</h3><p>主要思想：在磁盘中维护一个元数据，不和 DRAM 实时同步，但保证与 DRAM 的元数据的依赖关系相同（两地元数据都需要增加依赖关系的标识，这是新的要求）。</p><p>带来的好处：异步操作、依赖关系保证一致性、无需磁盘检查。</p><p><img src="https://eddyblog.oss-cn-shenzhen.aliyuncs.com/CCFADL105/HaiboChen/HaiboChen_page-0017.jpg" srcset="/img/loading.gif" alt="Soft Updates"></p><h3 id="Soft-Updates-is-Complicated"><a href="#Soft-Updates-is-Complicated" class="headerlink" title="Soft Updates is Complicated"></a>Soft Updates is Complicated</h3><p>这一理念在学术界有所影响，但工业界影响微乎其微：依赖关系复杂，实现太过困难。</p><blockquote><p>Soft updates are, simply put, too hard to understand, implement,and maintain to be part of the mainstream of file system development — Valerie Aurora, Linux Kernel Developer</p></blockquote><p>海波老师的团队研究认为，这种复杂性的根本是：细粒度的 Cache 记录跟踪（Byte 级别）和粗粒度的磁盘读写（512K 或以上）接口之间的不匹配</p><h3 id="Soft-Updates-Meets-NVM"><a href="#Soft-Updates-Meets-NVM" class="headerlink" title="Soft Updates Meets NVM"></a>Soft Updates Meets NVM</h3><p>Soft Updates</p><ul><li>没有同步 cache flushes 的消耗</li><li>崩溃可即时恢复可用</li></ul><p>NVM</p><ul><li>Byte 级别且快速，原有粒度不匹配问题改善</li><li>直写 NVM 没有延迟</li><li>没有<a href="https://www.cnblogs.com/cyfonly/p/5800758.html" target="_blank" rel="noopener">伪共享（false sharing）</a> =&gt; no rolling back/forward</li><li>简化了跟踪依赖的操作</li></ul><p>新的挑战：由于 NVM 是 M，Memory，那就存在着用户未预料的 CPU 将 Cache 数据刷回 NVM 的过程（cache eviction），这就带来了不一致性。</p><h2 id="SoupFS-1"><a href="#SoupFS-1" class="headerlink" title="SoupFS"></a>SoupFS</h2><p>A simple and fast NVMFS derived from soft updates.</p><ul><li>哈希表目录（解决 false sharing）</li><li>依赖指针的双视图（解决同步 cache flushes 开销）</li><li>语义感知以来跟踪</li></ul><p>着重讲双视图一块的设计</p><h3 id="Dual-Views"><a href="#Dual-Views" class="headerlink" title="Dual Views"></a>Dual Views</h3><p>哪两个视图</p><ul><li>Latest view in page cache（在 DRAM 中）</li><li>Consistent view in disks</li></ul><p>为了避免两个视图两份拷贝的额外开销，进一步提高效率，通过 Pointer 指向，来复用元数据的数据结构来避免不必要的重复和刷新。</p><p><img src="https://eddyblog.oss-cn-shenzhen.aliyuncs.com/CCFADL105/HaiboChen/HaiboChen_page-0023.jpg" srcset="/img/loading.gif" alt="Pointer-based"></p><p>具体的数据结构设计不再赘述，可以参考 SoupFS 论文</p><p>一个例子，从图示看很像 Data structure 中每个结点实现了一个双指针分别指向下一个 Consistent 节点（NVM View 中）和 Latest 节点（RAM View 中）。</p><p><img src="https://eddyblog.oss-cn-shenzhen.aliyuncs.com/CCFADL105/HaiboChen/HaiboChen_page-0033.jpg" srcset="/img/loading.gif" alt="Pointer-based Example"></p><h3 id="Q-amp-A"><a href="#Q-amp-A" class="headerlink" title="Q&amp;A"></a>Q&amp;A</h3><p>Q1. 使用 NVM 为什么还要使用 File System，数据库方式可以跳过直接操作底层的 metadata？<br>A1. 当然对于 NVM 下还要不要做 File System 业界是有争论的，我的看法是系统发展要有演化路径，File System 是一个通用的“范型”，可以利用 File System 实现更多基于 File System 的上层技术。</p><p>Q2. NVMFS 有没有对垃圾回收机制带来新的要求和挑战？<br>A2. 之前学术界有相关研究比如 NV Allocate，主要研究在 NVM 上如何分配和管理空间，这样必然会涉及垃圾回收这一问题。我们这边也有涉及 Garbage Collector 的相关工作，主要关心掉电后数据流有/没有被分配</p><p>Q3. 为什么考虑文件目录使用 HashTable 而非红黑树、B+树，这样的话范围查询效率不会很低吗？<br>A3. 首先考虑到实现简单，而且对于 NVM 来说，相较于之前的 Disk 访问速度已经很快了，范围查询拆成单点查询可能都要比原有设备的范围查询快，就是拖到内存里扫一遍的过程。</p><h1 id="ZoFS"><a href="#ZoFS" class="headerlink" title="ZoFS"></a>ZoFS</h1><p>A truly user-space NVM file system (SOSP’19)</p><h2 id="User-space-File-Systems"><a href="#User-space-File-Systems" class="headerlink" title="User-space File Systems"></a>User-space File Systems</h2><p>设计在用户空间（user space）活动的文件系统，一些优势</p><ul><li>更易开发，移植和维护<ul><li>由于在用户空间，bug 不会影响整个系统</li><li>可以利用更多的库和编程语言</li></ul></li><li>灵活<ul><li>可根据应用程序定制</li></ul></li><li>由于内核旁路（kernel bypass），大多数都是高性能的<ul><li>用户空间的库可以直接通过 NVM</li></ul></li></ul><p>早期的一些工作：Aerie， Strata，NOVA（有机会查阅文献自己了解一下）</p><p>采取内核/用户空间分离强化了权限（许可？）和保护，任何文件的更改都需要经由内核同意，但是由于存储介质的改变，NVM user-space 的文件系统与 kernel 远超过去的交互频率会使得 kernel 处理权限（许可？）成为瓶颈。</p><ul><li>挑战：文件保护于隔离</li><li>思考：将相同权限（许可？）的文件分组并一同管理</li><li>再提及：<strong>抽象的重要性</strong></li></ul><h2 id="新的抽象：-Coffer"><a href="#新的抽象：-Coffer" class="headerlink" title="新的抽象： Coffer"></a>新的抽象： Coffer</h2><p>具体没有搞明白。。后续读论文吧。</p><p><img src="https://eddyblog.oss-cn-shenzhen.aliyuncs.com/CCFADL105/HaiboChen/HaiboChen_page-0051.jpg" srcset="/img/loading.gif" alt="Coffer1"></p><p><img src="https://eddyblog.oss-cn-shenzhen.aliyuncs.com/CCFADL105/HaiboChen/HaiboChen_page-0052.jpg" srcset="/img/loading.gif" alt="Coffer2"></p><h2 id="Protection-and-Isolation"><a href="#Protection-and-Isolation" class="headerlink" title="Protection and Isolation"></a>Protection and Isolation</h2><p>App code 运行可能会导致某个 Coffer 出错，如何防止错误的蔓延，实现错误隔离？方式，内核将 VM pages 划分为 16 regions，非特权寄存器控制器每次最多接入一个 region，添加一些规则（guidelines）。</p><ul><li>G1. 一个 coffer 是可访问的当且仅当 uFS 正在访问这个 coffer。</li><li>G2. 在任何时候，对于每个县城来说，用户空间中只有一个 coffer 是可访问的。</li><li>G3. 对于任何一个 cross-coffer 的 reference，uFSs 应在使 coffer 变为可用状态前检查其标记。</li></ul><p>ZoFS 实现和一些实验验证。。。这里也不太懂。</p><h1 id="AtomFS"><a href="#AtomFS" class="headerlink" title="AtomFS"></a>AtomFS</h1><p>The first verified concurrent file system (SOSP’19)</p><p>第一个验证的并行文件系统。</p><h2 id="对于并行文件系统验证的需求"><a href="#对于并行文件系统验证的需求" class="headerlink" title="对于并行文件系统验证的需求"></a>对于并行文件系统验证的需求</h2><ul><li>并发错误很难消除</li><li>应用程序需要并发执行的精确接口</li><li>应用程序代码推理（code reasoning）的基础</li></ul><p>而最关键的是：<strong>形式化验证</strong>——证明系统没有错误的唯一方法。</p><p><img src="https://eddyblog.oss-cn-shenzhen.aliyuncs.com/CCFADL105/HaiboChen/HaiboChen_page-0075.jpg" srcset="/img/loading.gif" alt="Formal verification"></p><p>到这真的是听不懂了。。。。记一些重点名词然后贴 pdf 日后慢慢研究吧</p><p>抽象化-&gt;形式化验证</p><p>Atomicity, Linearizability</p><p>Helper Mechanism（辅助机制）: Ghost state, Linearize-before relation, CRL-H</p><p><img src="https://eddyblog.oss-cn-shenzhen.aliyuncs.com/CCFADL105/HaiboChen/HaiboChen_page-0076.jpg" srcset="/img/loading.gif" alt="AtomFS1"><br><img src="https://eddyblog.oss-cn-shenzhen.aliyuncs.com/CCFADL105/HaiboChen/HaiboChen_page-0077.jpg" srcset="/img/loading.gif" alt="AtomFS2"><br><img src="https://eddyblog.oss-cn-shenzhen.aliyuncs.com/CCFADL105/HaiboChen/HaiboChen_page-0078.jpg" srcset="/img/loading.gif" alt="AtomFS3"><br><img src="https://eddyblog.oss-cn-shenzhen.aliyuncs.com/CCFADL105/HaiboChen/HaiboChen_page-0079.jpg" srcset="/img/loading.gif" alt="AtomFS4"><br><img src="https://eddyblog.oss-cn-shenzhen.aliyuncs.com/CCFADL105/HaiboChen/HaiboChen_page-0080.jpg" srcset="/img/loading.gif" alt="AtomFS5"><br><img src="https://eddyblog.oss-cn-shenzhen.aliyuncs.com/CCFADL105/HaiboChen/HaiboChen_page-0081.jpg" srcset="/img/loading.gif" alt="AtomFS6"><br><img src="https://eddyblog.oss-cn-shenzhen.aliyuncs.com/CCFADL105/HaiboChen/HaiboChen_page-0082.jpg" srcset="/img/loading.gif" alt="AtomFS7"><br><img src="https://eddyblog.oss-cn-shenzhen.aliyuncs.com/CCFADL105/HaiboChen/HaiboChen_page-0083.jpg" srcset="/img/loading.gif" alt="AtomFS8"><br><img src="https://eddyblog.oss-cn-shenzhen.aliyuncs.com/CCFADL105/HaiboChen/HaiboChen_page-0084.jpg" srcset="/img/loading.gif" alt="AtomFS9"><br><img src="https://eddyblog.oss-cn-shenzhen.aliyuncs.com/CCFADL105/HaiboChen/HaiboChen_page-0085.jpg" srcset="/img/loading.gif" alt="AtomFS10"><br><img src="https://eddyblog.oss-cn-shenzhen.aliyuncs.com/CCFADL105/HaiboChen/HaiboChen_page-0086.jpg" srcset="/img/loading.gif" alt="AtomFS11"><br><img src="https://eddyblog.oss-cn-shenzhen.aliyuncs.com/CCFADL105/HaiboChen/HaiboChen_page-0087.jpg" srcset="/img/loading.gif" alt="AtomFS12"><br><img src="https://eddyblog.oss-cn-shenzhen.aliyuncs.com/CCFADL105/HaiboChen/HaiboChen_page-0088.jpg" srcset="/img/loading.gif" alt="AtomFS13"><br><img src="https://eddyblog.oss-cn-shenzhen.aliyuncs.com/CCFADL105/HaiboChen/HaiboChen_page-0089.jpg" srcset="/img/loading.gif" alt="AtomFS14"><br><img src="https://eddyblog.oss-cn-shenzhen.aliyuncs.com/CCFADL105/HaiboChen/HaiboChen_page-0090.jpg" srcset="/img/loading.gif" alt="AtomFS15"><br><img src="https://eddyblog.oss-cn-shenzhen.aliyuncs.com/CCFADL105/HaiboChen/HaiboChen_page-0091.jpg" srcset="/img/loading.gif" alt="AtomFS16"><br><img src="https://eddyblog.oss-cn-shenzhen.aliyuncs.com/CCFADL105/HaiboChen/HaiboChen_page-0092.jpg" srcset="/img/loading.gif" alt="AtomFS17"></p><p>耗费了相当大的精力，1.5 年的努力，包括学习理论，建立框架和形式化证明。</p><p>AtomFS：2k 行代码表达，60k 行证明。</p><h1 id="Summary"><a href="#Summary" class="headerlink" title="Summary"></a>Summary</h1><p>还是如之前所说，体系结构中某个部件的突发进步，会导致整个体系设计思路的改变。</p><ul><li>NVM 为系统软件带来了极大的便利</li><li>我们需要重新思考系统软件的设计</li><li>找到对于现有软件来说真正的痛点（<strong>real pain points</strong>）</li><li>长远来看会改变整个软件栈，甚至存储层次也会被颠覆</li></ul><p><a href="https://ipads.se.sjtu.edu.cn/" target="_blank" rel="noopener">Institute of Parallel and Distributed Systems(IPADS)</a></p><p><a href="https://ipads.se.sjtu.edu.cn/zh/" target="_blank" rel="noopener">IPADS 中文主页</a></p>]]></content>
    
    
    <categories>
      
      <category>Research</category>
      
      <category>讲座会议</category>
      
    </categories>
    
    
    <tags>
      
      <tag>讲座会议</tag>
      
      <tag>CCFADL</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>CCFADL105——“智能在网计算”应用智能网卡技术加速数据中心</title>
    <link href="/post/f74c511d.html"/>
    <url>/post/f74c511d.html</url>
    
    <content type="html"><![CDATA[<h1 id="“智能在网计算”应用智能网卡技术加速数据中心"><a href="#“智能在网计算”应用智能网卡技术加速数据中心" class="headerlink" title="“智能在网计算”应用智能网卡技术加速数据中心"></a>“智能在网计算”应用智能网卡技术加速数据中心</h1><p>主讲人：谭焜（Phd，华为）</p><p><img src="https://eddyblog.oss-cn-shenzhen.aliyuncs.com/CCFADL105/KunTan/KunTan_page-0001.jpg" srcset="/img/loading.gif" alt="FirstPage"></p><h1 id="总览"><a href="#总览" class="headerlink" title="总览"></a>总览</h1><h2 id="network-stack"><a href="#network-stack" class="headerlink" title="network stack"></a>network stack</h2><p>IP 层往上，栈（协议栈）更贴近软件，IP 层往下，更贴近硬件。从软硬件均实现了 Network 的服务需求。</p><h2 id="Bottleneck-的改变"><a href="#Bottleneck-的改变" class="headerlink" title="Bottleneck 的改变"></a>Bottleneck 的改变</h2><div class="table-container"><table><thead><tr><th>过去</th><th>现在</th></tr></thead><tbody><tr><td>IP 层作为网络协议栈处在中心的位置，网络通讯速度相较于 CPU 和内存的速度来说要慢很多</td><td>网络速度以 200 倍到 2000 倍速度增长，而 CPU 计算增速却放缓，摩尔定律放缓</td></tr><tr><td>eg: at 1990, Intel 80486 32bit@33MHz vs. ETH 10Mbps</td><td>eg: CPU 10~100GHz vs. ETN 400 Gbps</td></tr></tbody></table></div><p>内存增长也遇到瓶颈</p><p>完全吃下 40G ETH， 8 TCP conns 网络数据至少需要 5 核。</p><a id="more"></a><h2 id="问题"><a href="#问题" class="headerlink" title="问题"></a>问题</h2><p><strong>Question: How to scale networking with ever growing speed?</strong></p><p>如何应对加剧增速的网络？</p><p><strong>Answer: making network smart!</strong></p><p>让网络变得“聪明”：</p><p>SmartNIC: intergrating general programmability into network interface card.</p><h3 id="SmartNIC-分类"><a href="#SmartNIC-分类" class="headerlink" title="SmartNIC 分类"></a>SmartNIC 分类</h3><p>对于 SmartNIC 的分类，可以从架构和核类型两种角度进行分类：</p><ul><li>按架构（Architecture）分类<ul><li>on-path（SmartNIC 核在路径上，网络传输必须必然经过）</li><li>off-path（SmartNIC 核在旁路上，网络传输可通过 Swith 不经由）</li></ul></li></ul><p><img src="https://eddyblog.oss-cn-shenzhen.aliyuncs.com/CCFADL105/KunTan/KunTan_page-0010.jpg" srcset="/img/loading.gif" alt="SmartNICType1"></p><ul><li>按核类型（core types）分类<ul><li>FPGA-based 基于 FPGA</li><li>NP-based 基于多核 NP</li><li>GP-based 基于通用处理器核</li></ul></li></ul><p><img src="https://eddyblog.oss-cn-shenzhen.aliyuncs.com/CCFADL105/KunTan/KunTan_page-0011.jpg" srcset="/img/loading.gif" alt="SmartNICType2"></p><p>业界多种选择</p><ul><li>Microsoft FPGA-based SmartNIC</li><li>Cavium/Marvel NP-based SmartNIC</li><li>Huawei NP-based uNIC</li><li>Mellanox ARM-based SmartNIC</li></ul><p><img src="https://eddyblog.oss-cn-shenzhen.aliyuncs.com/CCFADL105/KunTan/KunTan_page-0016.jpg" srcset="/img/loading.gif" alt="Comparison"></p><h1 id="SmartNIC-编程"><a href="#SmartNIC-编程" class="headerlink" title="SmartNIC 编程"></a>SmartNIC 编程</h1><p>硬件编程困难，需要考虑时序度、DMA 等等。</p><p>Make it easy.</p><p>ClickNP</p><ul><li>如同在多核处理器上编程</li><li>Element 单元作为单线程的 core</li></ul><p>整个体系结构，通过 ClickNP compiler 把运行库和所写程序编译，生成对应 Host 宿主机 CPU 执行的 C 代码，和在 FPGA 上执行的代码。</p><p>iPipe</p><ul><li>Actor 模型，Actor 调度</li><li>最大化 SmartNIC 的利用</li><li>调度策略：混合调度（Hybrid Scheduler）<ul><li>SmartNIC，必要时调度到 CPU</li><li>动态</li></ul></li></ul><p>eg: 根据报文大小采取的动态 SmartNIC 的策略。</p><h1 id="eVS-offloading-with-Huawei-uNIC"><a href="#eVS-offloading-with-Huawei-uNIC" class="headerlink" title="eVS offloading with Huawei uNIC"></a>eVS offloading with Huawei uNIC</h1><p>云计算中的 Private Cloud，云计算 Deloy 很多的服务器，其生意模式是将机器租用给租户，如下图（蓝、绿、红），每个用户建立一个虚拟化的网络，客户角度看就是一个私有网络（像是真正的物理网络一样）。</p><p>通过虚拟交换机，发送时 vSwitch 在原来的报文上再打一个标签，再发送到实际的物理网络上，接收的时候对应不同的报文标签再分给不同的 VM。</p><p>对于一个完整交换的过程（流表），完全让智能网卡照搬解决，1.不显示，2.和让宿主机 CPU 处理器没差别。</p><p>解决：缓存固定的流数据的结果，first pkt 与 rest of pkts 区分开，通过缓存加速 rest of pkts。</p><p>实现：在智能网卡中做个 Cache，相同报文头的固定结果缓存到 Cache，后续网络包查表加速。</p><p><img src="https://eddyblog.oss-cn-shenzhen.aliyuncs.com/CCFADL105/KunTan/KunTan_page-0044.jpg" srcset="/img/loading.gif" alt="SmartNIC Cache"></p><h1 id="Multi-path-RDMA-Design"><a href="#Multi-path-RDMA-Design" class="headerlink" title="Multi-path RDMA Design"></a>Multi-path RDMA Design</h1><ul><li>kernal bypass and transport offloading（内核旁路以及无负载传输）<ul><li>不为 CPU 增加负担，降低延迟并且提高吞吐量</li></ul></li><li>existing RDMA has only a single path transport（现有 RMDA 单路径传输）<ul><li>fail to exploit multiple paths capability of modern DCN for reliability and load-balance（未能利用现代 DCN 的多路径能力来实现可靠性和负载平衡，协议缺失）</li></ul></li></ul><p>目标：为 RDMA 构建一个 multi-path 多路径传输</p><h2 id="设计挑战"><a href="#设计挑战" class="headerlink" title="设计挑战"></a>设计挑战</h2><p>Challenge 1. 如何在不知道每个路径状态的情况下实现拥塞感知流量分割</p><p>Solution 1. <strong>multipath ack-clocking</strong></p><p>Challenge 2. 如何跟踪具有微小和恒定内存的无序数据包</p><p>Solution 2. <strong>out-of-order aware path selection</strong></p><p>Challenge 3. 如何在保序的同时通过多路实现性能增益</p><p>Solution 3. <strong>explicit sychronise operation</strong></p><h3 id="multipath-ack-clocking"><a href="#multipath-ack-clocking" class="headerlink" title="multipath ack-clocking"></a>multipath ack-clocking</h3><p>设计内涵：</p><p>返回 ACK 隐含拥塞信息</p><p>算法：</p><ul><li>$N$条路径上发送$N$个包</li><li>为所有路径保留一个拥塞窗口（cwnd）</li><li>对于每个返回的 ACK，只有当 cwnd 允许的时候，将数据包输送到路径上</li></ul><h3 id="out-of-order-aware-path-selection"><a href="#out-of-order-aware-path-selection" class="headerlink" title="out-of-order aware path selection"></a>out-of-order aware path selection</h3><p>设计内涵：</p><p>选择具有相似 延迟的路径</p><p>算法：</p><p>$snd_ooh$，人工设定一个参数$\Delta$，$snd_ool = snd_ooh - \Delta$，包落在这个时间区间内的，都是 Good Paths</p><h3 id="sychronise-operation"><a href="#sychronise-operation" class="headerlink" title="sychronise operation"></a>sychronise operation</h3><p>这个没太懂，加标签？</p><h3 id="MPTCP-vs-MPRDMA"><a href="#MPTCP-vs-MPRDMA" class="headerlink" title="MPTCP vs. MPRDMA"></a>MPTCP vs. MPRDMA</h3><p>为什么选择构建新的 MPRDMA：</p><p>对于 MPTCP 来说，对于每一个 Single Path 都要去维护一组状态，实践中导致整体状态值很大，难以实现在硬件中，所以考虑从新设置一种适合的模式，减少 State 数，使其不随 Path 的增加而增加，便于硬件实现。</p><h1 id="KV-Direct"><a href="#KV-Direct" class="headerlink" title="KV-Direct"></a>KV-Direct</h1><p><img src="https://eddyblog.oss-cn-shenzhen.aliyuncs.com/CCFADL105/KunTan/KunTan_page-0075.jpg" srcset="/img/loading.gif" alt="KV-Direct"></p><p>后续都是基于 KV-Direct 论文，讲真，谭教授讲的有些快，后续有时间再补。</p><p><a href="https://dl.acm.org/citation.cfm?id=3132756&amp;ftid=1913933&amp;dwn=1&amp;CFID=97954459&amp;CFTOKEN=a9a7a36be5470121-AB4B88E5-ED06-323B-1108CCECADA8FB7B" target="_blank" rel="noopener">KV-Direct Paper</a></p>]]></content>
    
    
    <categories>
      
      <category>Research</category>
      
      <category>讲座会议</category>
      
    </categories>
    
    
    <tags>
      
      <tag>讲座会议</tag>
      
      <tag>CCFADL</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>CCFADL105——大数据系统的演化：理论、实践和愿望</title>
    <link href="/post/3f0572b0.html"/>
    <url>/post/3f0572b0.html</url>
    
    <content type="html"><![CDATA[<h1 id="大数据系统的演化：理论、实践和展望"><a href="#大数据系统的演化：理论、实践和展望" class="headerlink" title="大数据系统的演化：理论、实践和展望"></a>大数据系统的演化：理论、实践和展望</h1><p>主讲人：周礼栋老师（微软亚洲研究院副院长，MSRA 被称为系统方向的黄埔军校，肇国老师评价其为非常 Perspective 的一位老师）</p><h1 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h1><p>作为第一个 Talker，先做一个比较宏观的演讲，整个分为两部分。<br>除了必要的知识点以外，我们更需要以系统的视角，关注方法学（重新思考）。</p><h1 id="回顾大数据系统的发展历程：Big-Data-Systems"><a href="#回顾大数据系统的发展历程：Big-Data-Systems" class="headerlink" title="回顾大数据系统的发展历程：Big Data Systems"></a>回顾大数据系统的发展历程：Big Data Systems</h1><p>强调了抽象的重要性，一个好的抽象，可以将要进行的任务很好的表达出来，同时还要具备高效性，可以被高效的实现。</p><h2 id="2010-年以前的工作：Foudation"><a href="#2010-年以前的工作：Foudation" class="headerlink" title="2010 年以前的工作：Foudation"></a>2010 年以前的工作：Foudation</h2><p><img src="https://eddyblog.oss-cn-shenzhen.aliyuncs.com/CCFADL105/LidongZhou/LidongZhou_page-0003.jpg" srcset="/img/loading.gif" alt="初期 Fundation"></p><p>对于 MapReduce 的横空出现，学界对于 MapReduce 存在一些争论，一些数据库的巨擘认为 MapReduce 是对数据库已经建立起来的一些规则也好，基石工作也好的破坏，技术上是一种倒退，而微软则在 Google MapReduce 的基础上尝试填补上述争论，微软认为数据库和 MapReduce 是存在结合点的，可以向上提供原有的 SQL relation algebra</p><ul><li>谷歌： MapReduce -&gt; 并行/分布式/优化 -&gt; 高效执行</li><li>微软：数据流 -&gt; 原有数据库接口 -&gt; MapReduce -&gt; 并行/分布式/优化 -&gt; 高效执行</li></ul><a id="more"></a><h2 id="2011-2012-的工作：Holisitic-Code-Optimization"><a href="#2011-2012-的工作：Holisitic-Code-Optimization" class="headerlink" title="2011-2012 的工作：Holisitic Code Optimization"></a>2011-2012 的工作：Holisitic Code Optimization</h2><p><img src="https://eddyblog.oss-cn-shenzhen.aliyuncs.com/CCFADL105/LidongZhou/LidongZhou_page-0005.jpg" srcset="/img/loading.gif" alt="Holisitic Code Optimization"></p><p>数据库里面的优化和编译器的优化可以结合起来，思路：最优执行，优化执行。（当然整体还是建立在数据库的思维上）</p><p><strong>PeriSCOPE 项目</strong>，出发点希望将 SQL-like code 进行编译优化。</p><ul><li>代码段是在多机器并发执行</li><li>纯编译优化只是很小的局部</li></ul><p>SQL 生命力旺盛的一个原因是其隐藏了很多优化的细节。将 SQLize 的特性深入到全局概念，全局优化。</p><p>全局优化关键是优化目标、关注点的改变：<strong>数据传输（Data Shuffling）消耗</strong>：</p><ul><li>Column Reduction：延迟产生列</li><li>Early Filtering 提前合并减少列</li><li>Smart Cut</li></ul><h3 id="Research-to-Production"><a href="#Research-to-Production" class="headerlink" title="Research to Production"></a>Research to Production</h3><p>从研究所的科研突破到是计划产品部署过程中还会存在着一些问题，不管是科研人员和业务部门人员思维上差异也好，工作环境也好，所以在转化过程中我们还需要做到以下几点：</p><ul><li>新颖与保守兼顾（考虑到业务部门的保守性）</li><li>需要适应真正的工作（而非 Benchmark 或者模拟数据）</li><li>无错、无不良影响、无不可预测行为（相较于成熟的旧技术，新技术如果以出错为代价，性能提升再多都是徒劳）</li><li>必须是收敛且低开销的（泛用性强，经得起工作集的改变）</li><li>后期维护的代价要小、复杂性低（方便迭代）</li></ul><h2 id="2013-2014-的工作：Scheduling-and-Resource"><a href="#2013-2014-的工作：Scheduling-and-Resource" class="headerlink" title="2013-2014 的工作：Scheduling and Resource"></a>2013-2014 的工作：Scheduling and Resource</h2><p><img src="https://eddyblog.oss-cn-shenzhen.aliyuncs.com/CCFADL105/LidongZhou/LidongZhou_page-0013.jpg" srcset="/img/loading.gif" alt="Scheduling and Resource"></p><p>从单一 Job 的优化到多 Jobs 的优化，引入调度优化的角度。</p><p>大规模集群的多任务调度优化已经不仅仅是一个算法上的问题，因为集群中机器状态未知是常态，而且各自完成任务的预期也是 Unpredictable 的。</p><h2 id="2015-2016-的工作：Beyond-Batch-Processing"><a href="#2015-2016-的工作：Beyond-Batch-Processing" class="headerlink" title="2015-2016 的工作：Beyond Batch Processing"></a>2015-2016 的工作：Beyond Batch Processing</h2><p><img src="https://eddyblog.oss-cn-shenzhen.aliyuncs.com/CCFADL105/LidongZhou/LidongZhou_page-0017.jpg" srcset="/img/loading.gif" alt="Beyond Batch Processing"></p><p>重新审视思考方式：图计算、机器学习、流等概念的推广。从先前的 Scope 发展衍生出 StreamScope：分布式大数据可靠流系统。</p><ul><li><p>微软内部商用大规模流系统</p><ul><li>从批处理大数据系统演化而来</li><li>源于实际应用增强实时性的需求</li><li>和批处理系统共存</li></ul></li><li><p>系统设计理念和思路</p><ul><li><strong>抽象！抽象！！抽象！！！</strong></li><li>先保证正确，再优化</li><li>通过高层语言提高可用性</li></ul></li></ul><p><img src="https://eddyblog.oss-cn-shenzhen.aliyuncs.com/CCFADL105/LidongZhou/LidongZhou_page-0019.jpg" srcset="/img/loading.gif" alt="Stream Scope"></p><p>在流处理的过程中，由于是阶段-&gt;阶段的，考虑出错的常态化，如果某个节点出错，且采取 Rebuild State（重建状态）的策略，最坏情况可能需要 Ref 的节点也处于出错状态，这样数据就在 Data Shuffling 的过程中丢失了。为了消除数据前后的<strong>空间依赖性</strong>，有必要构建新的抽象。</p><p><img src="https://eddyblog.oss-cn-shenzhen.aliyuncs.com/CCFADL105/LidongZhou/LidongZhou_page-0022.jpg" srcset="/img/loading.gif" alt="rStream1"></p><h3 id="抽象-1-可靠流管道抽象"><a href="#抽象-1-可靠流管道抽象" class="headerlink" title="抽象 1 可靠流管道抽象"></a>抽象 1 可靠流管道抽象</h3><p>可靠流管道（rStream）</p><ul><li>每个序列号码都有一个唯一值</li><li>对于相同序列号，必须成功写后才可以读</li><li>一个写操作$(seq,e)$完成后，后续对该位置读都会返回$(seq,e)$</li></ul><p><img src="https://eddyblog.oss-cn-shenzhen.aliyuncs.com/CCFADL105/LidongZhou/LidongZhou_page-0023.jpg" srcset="/img/loading.gif" alt="rStream2"><br><img src="https://eddyblog.oss-cn-shenzhen.aliyuncs.com/CCFADL105/LidongZhou/LidongZhou_page-0024.jpg" srcset="/img/loading.gif" alt="rStream3"></p><h3 id="抽象-2-可恢复节点抽象"><a href="#抽象-2-可恢复节点抽象" class="headerlink" title="抽象 2 可恢复节点抽象"></a>抽象 2 可恢复节点抽象</h3><p>可恢复节点（rVertex）</p><p>以快照形式作为状态记录，包含三个属性值：</p><ul><li>输入流序列号</li><li>输出流序列号</li><li>当前计算状态</li></ul><p><img src="https://eddyblog.oss-cn-shenzhen.aliyuncs.com/CCFADL105/LidongZhou/LidongZhou_page-0025.jpg" srcset="/img/loading.gif" alt="rVertex1"></p><p><img src="https://eddyblog.oss-cn-shenzhen.aliyuncs.com/CCFADL105/LidongZhou/LidongZhou_page-0026.jpg" srcset="/img/loading.gif" alt="rVertex2"></p><p>出错恢复：根据快照记录回到过去状态，对于输入流进行重询问，由于 rStream 抽象，先前成功得读再后续读会返回相同的值，从而使用此性质可以完成成功得重询问，实现出错恢复。</p><h3 id="抽象，抽象，抽象"><a href="#抽象，抽象，抽象" class="headerlink" title="抽象，抽象，抽象"></a>抽象，抽象，抽象</h3><p>抽象的要求：自身要简单、易于理解。</p><p>合理的抽象使复杂的数据流可靠性和容错问题变得简单</p><ul><li>一目了然的正确性</li><li>但是简单的实现是抵消的：需要同步写到高可靠存储系统</li></ul><p>保持抽象，但使用一个混合高效的实现</p><ul><li>把费时的写操作移出关键路径（critical path）</li><li>但仍保持可靠管道的性质</li></ul><p>统一的抽象，不同的恢复策略选择</p><ul><li>Recomputaion using dependency tracking at runtime</li><li>Checkpoint/log replay</li><li>Persistent state/streams</li><li>Hybrid</li></ul><p>合理的抽象简化系统开发、维护、调试和部署，分布式流处理从此变得简单。在微软的实践中，在这两个抽象的帮助下，整体业务可以达到：</p><ul><li>离线调试验证模式，无缝上线</li><li>支持在线对每个节点的单独调试</li><li>支持灵活的在线迁移和动态调整</li><li>对过去的执行片段的审计</li><li>系统维护过程中的无间断执行</li></ul><h1 id="审视人工智能系统的机会和挑战：From-Big-Data-Systems-to-AI-Systems"><a href="#审视人工智能系统的机会和挑战：From-Big-Data-Systems-to-AI-Systems" class="headerlink" title="审视人工智能系统的机会和挑战：From Big Data Systems to AI Systems"></a>审视人工智能系统的机会和挑战：From Big Data Systems to AI Systems</h1><p>系统的两大重器：<strong>编译</strong>，<strong>架构</strong></p><p>AI 蓬勃发展带来了新的方法论，比如，深度学习+：</p><ul><li>Deep Learning Compiler Optimization 深度学习编译优化</li><li>Deep Learning Training Job Scheduing 深度学习训练任务调度</li></ul><p>帮助上层应用更好的利用底层硬件技术革新的项目——卧龙计划（Project Wolong）。</p><p><img src="https://eddyblog.oss-cn-shenzhen.aliyuncs.com/CCFADL105/LidongZhou/LidongZhou_page-0043.jpg" srcset="/img/loading.gif" alt="Project Wolong"></p><h2 id="Project-Wolong-Distributed-Optimizer"><a href="#Project-Wolong-Distributed-Optimizer" class="headerlink" title="Project Wolong: Distributed Optimizer"></a>Project Wolong: Distributed Optimizer</h2><p>基于 RDMA（Remote Direct Memory Access）的快速分布式训练</p><p>基于设备和服务器的自动化计算部署。</p><p>利用 RDMA 实现 Zero-copy 设备沟通以提高效率，应用在：RPC、GPU 加速</p><h2 id="Project-Wolong：Local-Optimizer"><a href="#Project-Wolong：Local-Optimizer" class="headerlink" title="Project Wolong：Local Optimizer"></a>Project Wolong：Local Optimizer</h2><p>对比 CPU 和 GPU 的架构</p><div class="table-container"><table><thead><tr><th>CPU</th><th>GPU</th></tr></thead><tbody><tr><td>少量的复杂核心</td><td>大量的简单核心</td></tr><tr><td>单线程表现</td><td>成百上千的硬件线程</td></tr><tr><td>晶体管空间致力于复杂的指令级并行（ILP）</td><td>最大化浮点吞吐量</td></tr></tbody></table></div><p><img src="https://eddyblog.oss-cn-shenzhen.aliyuncs.com/CCFADL105/LidongZhou/LidongZhou_page-0052.jpg" srcset="/img/loading.gif" alt="CPUvsGPU"></p><p>优化方向：<strong>Operator Batching and Kernel Fusion</strong></p><p>运算符的抽象粒度较低，导致一个真实的训练模型的数据流图往往会包括数千个节点，这些节点在 GPU 上的执行就会变成数千次 GPU 上的内核执行。这些粒度较小的内核函数在提供了灵活性的同时，其频繁的调用也成为当前影响许多深度学习框架性能的一个重要因素，其带来的性能开销主要体现在：数据流图的调度开销，GPU 内核函数的启动开销，以及内核函数之间的数据传输开销。</p><p>解决这一问题的一个直接方法就是合并相同运算符操作和内核融合，以更好的利用 GPU 的并行特性。</p><p>关于内核融合的详细介绍：<a href="https://www.msra.cn/zh-cn/news/features/kernel-fusion-20170925" target="_blank" rel="noopener">内核融合：GPU 深度学习的“加速神器”,薛继龙</a></p><p>但是 操作符 Batch 的自动化，以及核的融合并非想象中简单，存在一些技术上的难题：</p><p><img src="https://eddyblog.oss-cn-shenzhen.aliyuncs.com/CCFADL105/LidongZhou/LidongZhou_page-0056.jpg" srcset="/img/loading.gif" alt="Automatic Operator Batching"><br><img src="https://eddyblog.oss-cn-shenzhen.aliyuncs.com/CCFADL105/LidongZhou/LidongZhou_page-0057.jpg" srcset="/img/loading.gif" alt="Kernel Fusion"></p><p>最后整体的工作流：</p><ul><li>图优化：硬件无关优化策略</li><li>检测融合子图：找到一些可被融合的图节点</li><li>代码生成：给定一个融合子图，生成相关内核函数代码</li><li>图修改：将融合后的内核所对应的 Operator 替换之前的子图，并插入原来的数据流图中</li><li>循环多次直至满足需求</li></ul><p>实现产品<strong>NNFusion</strong>：一个多功能深度学习编译器。</p><h2 id="Deep-Learning-Training-vs-Big-Data-Processing"><a href="#Deep-Learning-Training-vs-Big-Data-Processing" class="headerlink" title="Deep Learning Training vs. Big Data Processing"></a>Deep Learning Training vs. Big Data Processing</h2><p>不考虑现在处理的问题和原来的问题有哪些不同，而照搬过去的方法是系统改良过程中一种不负责任的行为。</p><p><img src="https://eddyblog.oss-cn-shenzhen.aliyuncs.com/CCFADL105/LidongZhou/LidongZhou_page-0062.jpg" srcset="/img/loading.gif" alt="Difference"></p><p>对比目标，过程，表现三方面的不同，我们获得的启示：</p><ul><li>更多的并行工作会更好（The More Parallel Jobs the Better）</li><li>使长期工作适应不断变化的环境（Adapt the long-running job to the changing environment）</li><li>使深度学习进行时的微批处理（mini-batches）更加高效</li></ul><h2 id="结语"><a href="#结语" class="headerlink" title="结语"></a>结语</h2><ul><li>系统创新和优化时大数据和人工智能的以打击时</li><li>以独特的视角去发现和定义新的研究问题</li><li>综合全面系统地解决方法</li><li>大系统研究和创新的黄金时代</li></ul>]]></content>
    
    
    <categories>
      
      <category>Research</category>
      
      <category>讲座会议</category>
      
    </categories>
    
    
    <tags>
      
      <tag>讲座会议</tag>
      
      <tag>CCFADL</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>CCFADL105——大数据系统实践：从MapReduce到融合计算</title>
    <link href="/post/b1db88f.html"/>
    <url>/post/b1db88f.html</url>
    
    <content type="html"><![CDATA[<h1 id="大数据系统实践：从-MapReduce-到融合计算"><a href="#大数据系统实践：从-MapReduce-到融合计算" class="headerlink" title="大数据系统实践：从 MapReduce 到融合计算"></a>大数据系统实践：从 MapReduce 到融合计算</h1><p>主讲人：郭振宇（蚂蚁金服分布式计算总监）</p><p><img src="https://eddyblog.oss-cn-shenzhen.aliyuncs.com/CCFADL105/ZhenyuGuo/ZhenyuGuo-001.jpg" srcset="/img/loading.gif" alt="FirstPage"></p><h1 id="融合计算模型"><a href="#融合计算模型" class="headerlink" title="融合计算模型"></a>融合计算模型</h1><h2 id="观察-趋势"><a href="#观察-趋势" class="headerlink" title="观察/趋势"></a>观察/趋势</h2><p>举一个蚂蚁金融一个常见的应用场景：扫码支付</p><p><img src="https://eddyblog.oss-cn-shenzhen.aliyuncs.com/CCFADL105/ZhenyuGuo/ZhenyuGuo-002.jpg" srcset="/img/loading.gif" alt="ScanPay"></p><p>审视机器学习（或者大数据分析）产品三个层面的发展：</p><ul><li><strong>计算范畴</strong>：统计-&gt;规则（专家会议沉淀）-&gt;图-&gt;AI-&gt;复杂决策</li><li><strong>计算复杂度</strong>：静态线性工作流-&gt;静态图工作流-&gt;动态工作流-&gt;多流-&gt;多流融合</li><li><strong>质量</strong>：时效、安全/隐私、数据可靠性。</li></ul><p>实际上真正的 Machine Learning Code 只是很小的一部分，图源：《Hidden Technology Google》</p><p>而应用要落地，关键的问题在：</p><ul><li><p>学习/开发/调试的成本</p><ul><li>对接很多独立的引擎/框架</li><li>Ad-hoc/碎片化的集成/联调（多机联调）</li></ul></li><li><p>运行时质量</p><ul><li>破碎的上下游衔接<ul><li>形象点说，就是：上面跑数据不确定，下面就可能接受到不对的结果，</li><li>具体在：<strong>接口</strong>/<strong>时效性</strong>/<strong>一致性</strong>/<strong>故障恢复</strong>/<strong>中间状态管理</strong></li><li>对于中间状态管理的解释：生产者（上游）通过 HDFS 存放中间状态（产品），消费者（下游）不知道什么时候可以删除而不产生危害，导致存储过载、溢出。</li></ul></li><li>盲目调度，存在很多优化的空间<ul><li><strong>资源</strong>/<strong>数据</strong>/<strong>计算</strong>/<strong>服务</strong></li></ul></li><li>冗余/低效的数据传输/拷贝/计算等</li><li>安全隐私</li><li>…</li></ul></li><li><p>运维效率</p><ul><li>多引擎/平台异构运维</li></ul></li></ul><h2 id="胶水"><a href="#胶水" class="headerlink" title="胶水"></a>胶水</h2><p>平台化，将不同工作胶合在一起，常通过 GUIWorkFlow 的形式展示出来，一些公司已经有一些相关的工作。</p><p>e.g. Azure ML Workflow， Google Kubeflow</p><ul><li><p>优点</p><ul><li>包容性好</li><li>易用</li></ul></li><li><p>局限性</p><ul><li>组件质量/接口参差不齐-&gt;接口难做</li><li>组件对于胶水来说是黑盒-&gt;跨接口优化难做</li></ul></li></ul><p>想法：<strong>胶水</strong>-&gt;<strong>统一的分布式支撑</strong></p><h2 id="目标"><a href="#目标" class="headerlink" title="目标"></a>目标</h2><p><img src="https://eddyblog.oss-cn-shenzhen.aliyuncs.com/CCFADL105/ZhenyuGuo/ZhenyuGuo-005.jpg" srcset="/img/loading.gif" alt="Fusion Computing"></p><p><strong>融合计算</strong>：本地编程、自动云化、渐进融合</p><p><strong>核心挑战 1</strong>：统一的通用编程抽象/执行模型是什么</p><p>前面的讲座中已经多次提到了抽象的重要性，抽象就意味着：</p><ul><li>抽取面对不同分布式计算模式下的共同需求</li><li>甚至混合模式下的需求。</li></ul><p><strong>核心挑战 2</strong>：如何解决通用和特定之间的固有矛盾</p><p>通用性和领域专用性常看做是不可调和的矛盾。</p><ul><li>一般情况下，<strong>越通用，解决特定场景</strong>能力越弱。</li><li>抽象是一种通用性的体现，而不同计算模式的不同需求/特定优化则体现了领域专用性</li></ul><h2 id="融合计算编程抽象"><a href="#融合计算编程抽象" class="headerlink" title="融合计算编程抽象"></a>融合计算编程抽象</h2><p>为何需要分布式计算？以 MapReduce 中使用的字符计数问题为例：</p><ul><li>对于单机：存储空间不够、计算能力不构、</li><li>分布式计算目标：提供远超的单机的存储、计算能力，包装成单机的<strong>假象</strong>使上层没有意识到改变</li></ul><p><img src="https://eddyblog.oss-cn-shenzhen.aliyuncs.com/CCFADL105/ZhenyuGuo/ZhenyuGuo-010.jpg" srcset="/img/loading.gif" alt="ComputationChanging"></p><h3 id="状态切分"><a href="#状态切分" class="headerlink" title="状态切分"></a>状态切分</h3><p>MapReduce 的启发，状态切分成 slice，两个子方案，一是不需要代码改动的方案：remote memory，file system。二是需要代码改动的：KV，database</p><h3 id="避免数据共享冲突的方法？调整架构"><a href="#避免数据共享冲突的方法？调整架构" class="headerlink" title="避免数据共享冲突的方法？调整架构"></a>避免数据共享冲突的方法？调整架构</h3><div class="table-container"><table><thead><tr><th>控制流架构（冯·诺依曼）</th><th>数据流架构</th></tr></thead><tbody><tr><td>执行由<strong>控制流</strong>驱动</td><td>执行由<strong>数据流</strong>驱动</td></tr><tr><td>控制流导致状态访问冲突</td><td>数据是无消息/无冲突问题</td></tr></tbody></table></div><p>改写代码是必要的。</p><a id="more"></a><h3 id="回到-MapReduce"><a href="#回到-MapReduce" class="headerlink" title="回到 MapReduce"></a>回到 MapReduce</h3><p>MapReduce 做的事情是将整个字符统计拆分成两个任务，Map 任务，Reduce 任务。</p><p>实际上各种计算范畴（computation paradigm）表达能力都可以通过数据流二部图（Task Object）表达出来，复现 PPT 展示的表格：</p><div class="table-container"><table><thead><tr><th>范畴（Computation paradigm）</th><th>Task</th><th>Object</th></tr></thead><tbody><tr><td>CPU Computation</td><td>instruction instance</td><td>register/memory operand</td></tr><tr><td>MapReduce</td><td>mapper, reducer instance</td><td>input &amp; output (memory/HDFS) shards/buckets</td></tr><tr><td>Graph Traversal</td><td>graph shard worker traverse instance</td><td>graph shard state snapshot, input/output messages</td></tr><tr><td>Streaming</td><td>streaming operator execution instance</td><td>messages transmitted in channels among operators</td></tr><tr><td>Tensor Computation</td><td>tenser computation operator instance</td><td>tensors</td></tr><tr><td>Parameter sever based model training</td><td>worker running for one iteration</td><td>data,model parameters</td></tr><tr><td>Actor based computation(object oriented computation)</td><td>actor method execution instance</td><td>actor method input/output, actor state snapshot</td></tr></tbody></table></div><p>但是，Master 是个 exception，Master 是有状态的，相对于 Master 和 Reduce，对于有状态的 Master，MapReduce 论文中巧妙的忽略了这一点，对于单点故障，只需重启整个任务即可，数据流框架中不可采取这种“莽撞”的方法。</p><h3 id="无状态任务-vs-有状态任务"><a href="#无状态任务-vs-有状态任务" class="headerlink" title="无状态任务 vs 有状态任务"></a>无状态任务 vs 有状态任务</h3><ul><li>无状态<ul><li>大多数数据流计算（MapReduce，Dryad，Spark）</li><li>大多数 SOA 里面的 Method Call</li><li>随便哪里都能跑</li></ul></li><li>有状态<ul><li>某些有迭代的数据流计算（Tensorflow，Grap Computation2）</li><li>存储操作</li><li>带状态的服务操作（大多数 Job Master）</li><li>执行逻辑必须和状态绑在一起</li></ul></li></ul><h3 id="编程抽象之-服务"><a href="#编程抽象之-服务" class="headerlink" title="编程抽象之 服务"></a>编程抽象之 <strong>服务</strong></h3><p>服务 vs Actor</p><ul><li>服务 = [同构 Actor]*（一组同构 Actor 的集合），Actor 是单进程的。蚂蚁金服团队认为多线程一些地方还存在相似性和优化空间，更适合作为抽象单元，所以最终选择以<strong>服务</strong>作为自己的抽象单元。</li><li>尽量隐藏分布式计算带来的复杂度<ul><li>Scale out</li><li>Elasticity 弹性，日夜差别</li><li>Load balance</li><li>Fail over</li></ul></li></ul><h3 id="小结"><a href="#小结" class="headerlink" title="小结"></a>小结</h3><p><img src="https://eddyblog.oss-cn-shenzhen.aliyuncs.com/CCFADL105/ZhenyuGuo/ZhenyuGuo-016.jpg" srcset="/img/loading.gif" alt="Summary1"></p><h3 id="静态数据流-vs-动态数据流"><a href="#静态数据流-vs-动态数据流" class="headerlink" title="静态数据流 vs 动态数据流"></a>静态数据流 vs 动态数据流</h3><p>业务的需求，动态越来越多，NLP/Reinforcement learning，Nested Graph。没办法一下子把图给全。</p><p><img src="https://eddyblog.oss-cn-shenzhen.aliyuncs.com/CCFADL105/ZhenyuGuo/ZhenyuGuo-017.jpg" srcset="/img/loading.gif" alt="Summary2"></p><p>数据流图是一边跑一边长出来的。</p><h2 id="核心编程抽象"><a href="#核心编程抽象" class="headerlink" title="核心编程抽象"></a>核心编程抽象</h2><p>本地化编程-&gt;分布式编程</p><p>三元一一对应</p><p><img src="https://eddyblog.oss-cn-shenzhen.aliyuncs.com/CCFADL105/ZhenyuGuo/ZhenyuGuo-018.jpg" srcset="/img/loading.gif" alt="Summary3"></p><p>eg</p><p><img src="https://eddyblog.oss-cn-shenzhen.aliyuncs.com/CCFADL105/ZhenyuGuo/ZhenyuGuo-021.jpg" srcset="/img/loading.gif" alt="Summary4"></p><h2 id="本地编程（On-Premise-Programming）"><a href="#本地编程（On-Premise-Programming）" class="headerlink" title="本地编程（On-Premise Programming）"></a>本地编程（On-Premise Programming）</h2><h2 id="微内核架构"><a href="#微内核架构" class="headerlink" title="微内核架构"></a>微内核架构</h2><ul><li>不仅仅是性能问题</li><li>多方面统一和特定之间的两难问题</li><li>最重要，执行统一的架构和合约，避免无序<ul><li>团队合作</li><li>简化产品化/研发效能的问题（e.g.通过 AOP）</li></ul></li></ul><h2 id="插件分类和实现"><a href="#插件分类和实现" class="headerlink" title="插件分类和实现"></a>插件分类和实现</h2><p>eg：执行流调度、状态管理、服务部署策略、资源分配策略、进程故障恢复、状态故障恢复</p><p>优点：</p><ul><li>模块可重用，不同场景需求选用不同组合</li><li>根据场景制作特定优化插件</li><li>功能级别相同插件可替换、方便排查问题</li><li>（基本）独立开发，无缝集成，方便团队合作</li></ul><p>缺点：</p><ul><li>模块繁杂，系统配置复杂（状态管理插件存放的位置，HBase，Redis，放哪里都有区别）</li><li>插件抽象要求高，还完全 stable</li><li>某些插件相互依赖、不独立（理论上是笛卡尔乘积组合情况，但耦合性降低现在仍然是努力的目标）</li></ul><h1 id="融合优化"><a href="#融合优化" class="headerlink" title="融合优化"></a>融合优化</h1><h2 id="Level-of-indirection-solves-everything"><a href="#Level-of-indirection-solves-everything" class="headerlink" title="Level of indirection solves everything"></a>Level of indirection solves everything</h2><p>可以解决谁产生谁消费的问题，但是交互比较麻烦。</p><p>Problem： The indirection layer does enable flexibility but also brings cost</p><p>从静态数据流（static data flow）思考，并不会出现这种问题，图确定，必然有。</p><p>Back to the future，借鉴过去经验，想着能不能把动态往静态拉一把，我们还需要获取一些信息。</p><p>基于为微核架构的 Runtime optimization hybrid run-time</p><h2 id="Our-Work"><a href="#Our-Work" class="headerlink" title="Our Work"></a>Our Work</h2><h3 id="Distributed-Gabbage-Collection"><a href="#Distributed-Gabbage-Collection" class="headerlink" title="Distributed Gabbage Collection"></a>Distributed Gabbage Collection</h3><p>现在解决方案存在的问题：LRU（页面置换算法：最近最久未使用），删 object，但是可能还会用，删了可能会触发后面请求的 Failue，导致:</p><ul><li>负担增大</li><li>无法找回</li></ul><p>蚂蚁金服的解决方案：</p><p><img src="https://eddyblog.oss-cn-shenzhen.aliyuncs.com/CCFADL105/ZhenyuGuo/ZhenyuGuo-034.jpg" srcset="/img/loading.gif" alt="Ourwork"></p><h2 id="融合计算的思考路径"><a href="#融合计算的思考路径" class="headerlink" title="融合计算的思考路径"></a>融合计算的思考路径</h2><p><img src="https://eddyblog.oss-cn-shenzhen.aliyuncs.com/CCFADL105/ZhenyuGuo/ZhenyuGuo-038.jpg" srcset="/img/loading.gif" alt=""></p>]]></content>
    
    
    <categories>
      
      <category>Research</category>
      
      <category>讲座会议</category>
      
    </categories>
    
    
    <tags>
      
      <tag>讲座会议</tag>
      
      <tag>CCFADL</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>分布式系统学习——阶段性总结2</title>
    <link href="/post/72aa152d.html"/>
    <url>/post/72aa152d.html</url>
    
    <content type="html"><![CDATA[<h1 id="感受"><a href="#感受" class="headerlink" title="感受"></a>感受</h1><p>这篇阶段性总结写于乘高铁从长沙前往北京参加讲习会议的路途中，主要目的是回顾一下已经阅读完成的四篇分布式系统（Distributed System）相关论文的重点概念，相关实践（虽然很小），以及自我感受和后面的想法。</p><h1 id="Paper3——The-Google-File-System"><a href="#Paper3——The-Google-File-System" class="headerlink" title="Paper3——The Google File System"></a>Paper3——The Google File System</h1><p>关键词：<strong>集群存储</strong>、<strong>分布式存储</strong>、<strong>高可用性</strong>、<strong>一致性原则</strong></p><p>回忆梳理重点词：<strong>单 master</strong>、<strong>chunk 和 chunkserver</strong>、<strong>追加 append</strong>、</p><p>坦白讲这篇文章是四篇中读的时间最长的一篇文章，概念性比较强导致我不能通过代码或者公式的方式去直观的理解。</p><p>这篇总结主要写我印象深刻的点，更多的细节还要回去翻自己的翻译修改版本。</p><h2 id="Design-Motivation"><a href="#Design-Motivation" class="headerlink" title="Design Motivation"></a>Design Motivation</h2><p>应用需求/系统发展带来的一些对应的设计模式观念上的转变。</p><ul><li>对于计算机集群，<strong>故障是常态</strong></li><li>存储超大量</li><li>追加（append）而非覆盖（overwrite）</li><li>尽可能并行化操作</li><li>带宽重要性大于时延，要考虑网络带宽和负载</li></ul><h2 id="Architecture"><a href="#Architecture" class="headerlink" title="Architecture"></a>Architecture</h2><h3 id="GFS-chunkserver"><a href="#GFS-chunkserver" class="headerlink" title="GFS chunkserver"></a>GFS chunkserver</h3><p>在 GFS chunkserver 中，文件都是分成固定大小的 chunk（64MB）来存储的，每个 chunk 通过全局唯一的 64 位的 chunk handle 来标识。handle 由 master 分配。多台备份（GFS 中默认是 3 台）。</p><h3 id="GFS-master"><a href="#GFS-master" class="headerlink" title="GFS master"></a>GFS master</h3><p>GFS master 管理所有的元数据信息（metadata），包括 namespaces，访问控制信息，文件到 chunk 的映射信息，以及 chunk 的地址信息（即 chunk 存放在哪台 GFS chunkserver 上）。</p><h3 id="GFS-client"><a href="#GFS-client" class="headerlink" title="GFS client"></a>GFS client</h3><p>GFS client 是 GFS 应用端使用的 API 接口，client 和 GFS master 交互来获取元数据信息，但是所有和数据相关的信息都是直接和 GFS chunkserver 来交互的。</p><h3 id="Application"><a href="#Application" class="headerlink" title="Application"></a>Application</h3><p>Application 为使用 gfs 的应用，应用通过 GFS client 与 GFS 系统打交道，系统有一些必要的性质（以适应在 GFS 上的高效利用）。</p><h2 id="Strategies"><a href="#Strategies" class="headerlink" title="Strategies"></a>Strategies</h2><h3 id="Single-Master"><a href="#Single-Master" class="headerlink" title="Single Master"></a>Single Master</h3><p>单 Master 很容易导致 Master 成为性能瓶颈和单点故障。对于前者，GFS 的解决策略是 client 对 master 返回的请求 chunk 位置具备短暂记忆性（60s），下放部分职能给 chunkserver（包括指派 private 来保证数据的一致性）。</p><p>对于后者，才有心跳线备份 Master 是可行的。</p><h3 id="Consistency-Model"><a href="#Consistency-Model" class="headerlink" title="Consistency Model"></a>Consistency Model</h3><p>GFS 论文介绍中写明了：采用了一种简化的一致性模型，可以高效服务于所需应用。</p><p>模型中的一致的（consistent）和定义的（defined）概念如下：</p><ul><li>consistent：所有的客户端都能看到一样的数据，不管它们从哪个副本读取。</li><li>defined：当一个文件区域发生操作后，client 可以看到刚刚操作和所有数据，那么说这次操作是 defined。</li></ul><p>可以确定 defined 要求更强，在实际应用中会有不同情况出现，在原论文中用表格的形式直观化了。</p><p>我的感受：<strong>GFS 的保证是成功操作一次</strong>，由于所适应的应用以追加（append）为主。这样的策略和一致性模型保证操作会出现但是非幂等的冗余操作会导致结果错误，GFS 通过要求在应用层面上加过滤（filter）或者唯一话来解决这一问题。一言以蔽之：“宁滥勿缺”。</p><h3 id="Master-Operation-Namespace-Management-and-Locking"><a href="#Master-Operation-Namespace-Management-and-Locking" class="headerlink" title="Master Operation-Namespace Management and Locking"></a>Master Operation-Namespace Management and Locking</h3><ul><li>快照对本层和对应的快照层都加写锁。</li><li>写操作对所写文件加写锁而对文件所在目录加读锁。</li></ul><p>这样的分配策略既保证了一定程度上的并发许可（比如同一目录下的多个文件写），也保证了快照操作和写文件操作在相同目录下的串行化从而避免冲突。</p><h3 id="Master-Operation-Replica-Placement"><a href="#Master-Operation-Replica-Placement" class="headerlink" title="Master Operation-Replica Placement"></a>Master Operation-Replica Placement</h3><p>对于 Creation , Rebalancing 策略都是相近的。</p><ul><li>利用率低于平均水平的磁盘优先，平均化磁盘利用。</li><li>低频读写的 chunkserver 优先，平均化网络带宽利用，避免单点拥塞。</li><li>跨机架，防止整架挂掉。</li></ul><p>对于 Re-replication，则要考虑对于备份更紧迫的情况：</p><ul><li>丢失两个副本的 chunk 比丢失一个副本的 chunk 的复制认为优先级高</li><li>文件正在使用比文件已被删除的 chunk 的优先级高</li><li>阻塞了 client 进程的 chunk 的优先级高</li></ul><p>但是实现中如何让 master 高效查询 client 阻塞进程，以及副本数量（涉及到计数），我觉得也是个算法上可以研究的地方。</p><h2 id="读后感受"><a href="#读后感受" class="headerlink" title="读后感受"></a>读后感受</h2><p>GFS 的介绍应该是四篇文章中目前读的最慢的一篇了，太多概念都是通过文字方式讲述的，需要一点点在大脑里构建 GFS 中 Master，chunk，chunkserver 的关系。而且并列的概念关系我也没抓住重点（可能这也是我读论文的不足之处），所以这篇总结主要写了一些几个构成和我理解整理以后他们的工作策略，还请老师能指点我以后该怎样读这种文字多，新概念多的论文。</p><h1 id="Paper4——MapReduce-Simplified-Data-Processing-on-Large-Clusters"><a href="#Paper4——MapReduce-Simplified-Data-Processing-on-Large-Clusters" class="headerlink" title="Paper4——MapReduce: Simplified Data Processing on Large Clusters"></a>Paper4——MapReduce: Simplified Data Processing on Large Clusters</h1><p>关键词：<strong>Map 函数</strong>、<strong>Reduce 函数</strong></p><p>啥是 MapReduce？——一种编程模型，适于处理大规模数据集</p><p>为啥叫 MapReduce？——核心就是两个函数，分别叫 Map、Reduce</p><p>如果前述 GFS 系统实现了文件，那 MapReduce 则是利用了这个文件系统和其他底层实现，规划出一种编程范型，提供了对外便捷的接口，可以让程序员忽略分布式算法/并行/容错/数据分发的细节，而达到分布式计算的目的。</p><p>下面回顾一下核心 Model：</p><h2 id="Model"><a href="#Model" class="headerlink" title="Model"></a>Model</h2><p><strong>Map</strong>，是由用户编写的，取一个输入对，并且产生一系列中间的键值对。MapReduce 库将那些具有相同的中间键 I 的中间值聚集在一起，然后将它们传递给 Reduce 函数。</p><p><strong>Reduce</strong>，同样是由用户编写的，接收一个中间键 I 和该键对应的一系列的中间值。Reduce 函数通过将这些值合并来组成一个可能更小的集合（值的集合）。通常每个 Reduce 函数只产生 0 个或 1 个输出值。Reduce 函数一般通过一个迭代器（via an iterator）来获取中间值，从而在中间值的数目远远大于内存容量时，我们也能够处理。</p><h3 id="Example"><a href="#Example" class="headerlink" title="Example"></a>Example</h3><ul><li>Distributed Grep（分布式查找）：Map 函数获取匹配提供的模式的行，Reduce 函数只是简单地将这些中间数据拷贝到输出。</li><li>Count of URL Access Frequency（计算 URL 访问频率）：Map 函数处理 web 请求的日志，并且输出<url, 1="">。Reduce 函数将拥有相同 URL 的 value 相加，得到<url, total="" count="">对</url,></url,></li><li>Reverse Web-Link Graph：Map 函数输出<target, source="">对，其中 source 所在的 page 都有连向 target 这个 URL 的链接。Reduce 函数将给定 target 的所有的 source URL 连接起来，输出<target, list(source)="">对</target,></target,></li><li>Term-Vector per Host：一个 term vector 表示一系列<word, frequency="">的键值对，word 表示一篇或者一系列文章中出现的比较重要的单词，frequency 表示它们出现的次数。Map 函数对于每篇输入的文章输出<hostname, term="" vector="">键值对（其中 hostname 是从文章所在的 URL 中抽取出来的）Reduce 函数获取给定 host 的 term vectors。它将这些 term vectors 累加起来，丢弃非频繁出现的 term，并产生一个最终的<hostname, term="" vector="">对。</hostname,></hostname,></word,></li><li>Inverted Index：Map 函数对每篇文章进行处理，并输出一系列的<word, document="" id="">对。Reduce 函数接收给定 word 的所有键值对，对相应的 document ID 进行排序并且输出<word, list="">对。所有输出对的集合构成了一个简单的倒排索引。用了 MapReduce 模型，对单词位置的追踪就变得非常简单了。</word,></word,></li><li>Distributed Sort：Map 函数从每个 record 中抽取出 key，产生<key, record="">键值对。Reduce 函数只是简单地将所有对输出。这个计算模型依赖于 Section 4.1 中描述的划分技巧以及 Section 4.2 中描述的排序特性。</key,></li></ul><h2 id="Implement"><a href="#Implement" class="headerlink" title="Implement"></a>Implement</h2><p>实现的细节不再赘述，在翻译文档中翻译过切理解了，M 份 Map 操作的 Worker 和 R 份 Reduce 操作的 Worker。</p><h3 id="Fault-Tolerance"><a href="#Fault-Tolerance" class="headerlink" title="Fault Tolerance"></a>Fault Tolerance</h3><ul><li>Worker Failure：不在响应 master 而被 master 标记为 failure 状态后，其任务会被分摊至其他 wordker。对于 M 任务，需要重做前面已经完成的（因为 Map 产生的中间结果本地存储，而此时“本地”是 failure 的），而对于 R 任务，继续完成即可。</li><li>Master Failure：我们可以很快地根据最新的快照来重新启动一个 master task。但是，因为我们只有一个 master，因此故障的概率比较低。所以，在我们的实现中如果 master 出现了故障就只是简单地停止 MapReduce 操作。用户可以检测到这种情况，并且如果他们需要的话可以重新开始一次 MapReduce 操作。</li><li>Semantics in the Presence of Failures：针对非确定性执行，是解集空间中的一个。</li></ul><h2 id="Refinements"><a href="#Refinements" class="headerlink" title="Refinements"></a>Refinements</h2><p>此外还有一些有用的扩展：</p><ul><li>Hash 之前的划分操作</li><li>划分产生文件的顺序性</li><li>Map 和 Reduce 之间加 Combiner 操作合并简化（C 和 R 操作很像，只是输出到哪有了差别）</li><li>跳过故障点</li><li>Status 动态显示</li></ul><h2 id="读后感受-1"><a href="#读后感受-1" class="headerlink" title="读后感受"></a>读后感受</h2><p>很神奇的一种编程范式，相当于做了一个介于应用和分布式环境中间的接口，按照这种编程范式去编程便可以充分利用下面的分布式资源而忽略其具体实现细节。</p><p>实现方案理解起来也是非常巧妙，给人的感觉更像是从大的集合中抽出键值相同的小集合，再做合并。</p><p>希望后续可以读到更多关于分布式有趣的想法！</p>]]></content>
    
    
    <categories>
      
      <category>Computer Science</category>
      
      <category>分布式系统</category>
      
    </categories>
    
    
    <tags>
      
      <tag>分布式系统</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>数论学习——欧拉函数与中国剩余定理</title>
    <link href="/post/86266eca.html"/>
    <url>/post/86266eca.html</url>
    
    <content type="html"><![CDATA[<h1 id="欧拉函数"><a href="#欧拉函数" class="headerlink" title="欧拉函数"></a>欧拉函数</h1><p>针对前面所学习的欧拉公式，如果我们无法快速有效的计算出来欧拉函数$\phi$的值的话，我们就不能充分发挥欧拉公式的作用，下面给出欧拉函数的计算方法。</p><blockquote><p><strong>定理 11.1 （$\phi$函数公式）</strong></p><p>(a) 如果$p$是素数且$k ≥ 1$，则</p><script type="math/tex; mode=display">\phi(p^k) = p^k - p^{k-1}</script><p>(b) 如果$\gcd (m,n) =1$，则$\phi(mn) = \phi(m) \phi(n)$</p></blockquote><h2 id="证明过程"><a href="#证明过程" class="headerlink" title="证明过程"></a>证明过程</h2><p><strong>证明</strong> (a)素数情况的证明用全部数$p^k$减去与$p$不互素的$p,2p,3p, \cdots , (p^{k-1}-1)p, p^{k-1}p$，共$p^{k-1}$个。所以是$p^{k} - p^{k-1}$，余下要证明(b),</p><p>构造两个集合，集合 A，$\{ a: 1 \le a \le mn , \gcd (a, mn) = 1\}$，集合 B， $\{ (b,c): 1 \le b \le m, \gcd(b,m) =1 , 1 \le c \le n, \gcd(c,n) = 1  \}$，显然两个集合的大小分别为$\phi(mn)$和$\phi(m) \phi(n)$</p><p>对于下面这种 A-&gt;B 的映射关系 $a \mod mn   \to  (a \mod m, a \mod n$)，我们可以证明它是一一映射的，由此也就得到了$\phi(mn) = \phi(m) \phi(n)$</p><ol><li><p><strong>单射</strong>的证明（A 集合的不同数对应 B 集合的不同序对），假设原像为$a_1,a_2$，他们在 B 中有相同的映像，则有：</p><script type="math/tex; mode=display">a_1 \equiv a_2 \mod m</script><script type="math/tex; mode=display">a_1 \equiv a_2 \mod n</script><p>可以推导得$a_1 - a_2 \equiv 0 \mod mn$，而又因为$m,n$互素，所以我们可以得到</p><script type="math/tex; mode=display">a_1 \equiv a_2 \mod mn</script></li><li><p><strong>满射</strong>的证明（B 集合的每个序对适合 A 集合的某个数），根据映射式以及对于任意$b,c$已知值：</p><script type="math/tex; mode=display">a \equiv b \mod m</script><script type="math/tex; mode=display">a \equiv c \mod n</script><p>这个同余式组有解，这个用到了中国剩余定理的简化版（两个方程），给出证明。</p><p>因为$\gcd(m,n) = 1$，可计算（存在逆元）$m^{-1} ,n^{-1}$，满足$m^{-1}m \equiv 1 \mod n , n^{-1}n \equiv 1 \mod m$，则有</p><script type="math/tex; mode=display">bn^{-1}n+cm^{-1}m \equiv b \mod m</script><script type="math/tex; mode=display">bn^{-1}n+cm^{-1}m \equiv c \mod n</script><p>我们便找到了一个解$a = bn^{-1}n+cm^{-1}m$，实际上可证明在$\mod mn$条件下这个解是唯一的，见后面完整版中国剩余定理的证明。</p></li></ol><a id="more"></a><h1 id="中国剩余定理"><a href="#中国剩余定理" class="headerlink" title="中国剩余定理"></a>中国剩余定理</h1><p>《数论概论》这本书上只介绍到了两方程的情况，查阅 Wiki 等资料拓展学习了一下。</p><blockquote><p><strong>定理 11.2 （中国剩余定理简化版）</strong><br>设$m_1,m_2, \cdots ,m_n$是整数，其中任意两数两两互质，则对任意整数：$a_1,a_2, \cdots , a_n$，下面的同余方程有解。</p><script type="math/tex; mode=display">\begin{equation}\left\{             \begin{array}{lr}             x \equiv a_1 , \mod m_1 & \\             x \equiv a_2 , \mod m_2 & \\             x \equiv a_3 , \mod m_3 & \\              \cdots \\             x \equiv a_n , \mod m_n & \\             \end{array}\right.\end{equation}</script><p>设$M = m_1 \times m_2 \times \cdots \times m_n = \prod_{i=1}^{n}m_i$，并设$M_i = M/m_i, t_i \equiv M_i^{-1} \mod m_i$。方程的解表示为：</p><script type="math/tex; mode=display">x = a_1t_1M_1 + a_2t_2M_2  + \cdots + a_nt_nM_n + kM = kM + \sum_{i=1}^{n}a_it_iM_i , k \in Z</script><p>在模$M$的意义下，方程组有唯一解，为：</p><script type="math/tex; mode=display">x = \sum_{i=1}^{n}a_it_iM_i</script></blockquote><h2 id="证明过程-1"><a href="#证明过程-1" class="headerlink" title="证明过程"></a>证明过程</h2><p>主要参考 Wiki 上的证明方法，<a href="https://zh.wikipedia.org/wiki/%E4%B8%AD%E5%9B%BD%E5%89%A9%E4%BD%99%E5%AE%9A%E7%90%86" target="_blank" rel="noopener">中国剩余定理- 维基百科，自由的百科全书</a></p><p><strong>证明</strong> 由于${\forall i,j ,i \ne j, \gcd(m_i,m_j) =1 }$，所以对于$\gcd(m_i,M_i) = 1$，所以均存在$t_i$使得$t_iM_i \equiv 1 \mod m_i$，即$M_i$模$m_i$的数论倒数，考察$a_it_iM_i$这个乘积：</p><p>对于${\forall j \in \{ 1, 2, \cdots , n\}}$，会出现两种情况：</p><ul><li>$j = i$时，$a_it_iM_i \equiv a_i \mod m_i$，后两项乘积是 1</li><li>$j \ne i$时，$a_it_iM_i \equiv 0 \mod m_j$，原因是$m_j \mid M_i$。</li></ul><p>那么我们不难得出，$x = \sum_{i=1}^{n}a_it_iM_i$符合方程组。</p><p>下证在模$M$条件下解的唯一性。</p><p>假设存在$x_1,x_2$都是方程组的解且$1 \le x_1,x_2 \le M, x_1 \ne x_2$，那么我们可以得到方程组：</p><script type="math/tex; mode=display">\begin{equation}\left\{            \begin{array}{lr}            x_1 - x_2 \equiv 0 , \mod m_1 & \\            x_1 - x_2 \equiv 0 , \mod m_2 & \\            x_1 - x_2 \equiv 0 , \mod m_3 & \\            \cdots \\            x_1 - x_2 \equiv 0 , \mod m_n &            \end{array}\right.\end{equation}</script><p>因而可以得到$(M = \prod_{i=1}^{n} m_i) \mid \vert x_1 -x_2 \vert$，而由条件$\vert x_1 - x_2 \vert \le M-1$显然矛盾，所以在模$M$下解是唯一的。</p>]]></content>
    
    
    <categories>
      
      <category>Mathematics</category>
      
      <category>数论</category>
      
    </categories>
    
    
    <tags>
      
      <tag>数论</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>分布式系统学习——阶段性总结1</title>
    <link href="/post/eba34497.html"/>
    <url>/post/eba34497.html</url>
    
    <content type="html"><![CDATA[<h1 id="感受"><a href="#感受" class="headerlink" title="感受"></a>感受</h1><p>主要回顾分布式学习前两篇 Paper 阅读感受。</p><h1 id="Paper1——Time-Clocks-and-the-Ordering-of-Events-in-a-Distributed-System"><a href="#Paper1——Time-Clocks-and-the-Ordering-of-Events-in-a-Distributed-System" class="headerlink" title="Paper1——Time, Clocks, and the Ordering of Events in a Distributed System"></a>Paper1——Time, Clocks, and the Ordering of Events in a Distributed System</h1><p>回忆梳理关键词：<strong>Happen Before 关系</strong>、<strong>偏序全序（局部序全局序）</strong>、<strong>逻辑时钟</strong>、<strong>物理时钟</strong>。</p><h2 id="主体内容总结"><a href="#主体内容总结" class="headerlink" title="主体内容总结"></a>主体内容总结</h2><p>本文以分布式中系统中涉及时间概念的一个很困惑的问题作为引子—<br>—在分布式系统的架构中，当消息传输的时间不可忽略（如同广义相对论中时间的相对性），我们该如何定义分布式系统中时间发生的<strong>顺序</strong>，Lamport 向读者介绍了以下内容。</p><ul><li>分布式系统中事件发生先后的概念（happen before）。</li><li>基于 happen before 的逻辑时钟（偏序/局部）</li><li>逻辑时钟在给定条件后的全局化（全局序），并给出了一个基于全局序的<strong>解决资源争夺问题</strong>方法。</li><li>物理时钟及其他相关问题</li></ul><h3 id="Happen-Before"><a href="#Happen-Before" class="headerlink" title="Happen Before"></a>Happen Before</h3><p>这一段主要是用了离散数学里学到的关系，线序、偏序、全序的概念。</p><p>Lamport 不依赖物理时钟定义了事件 happen before（后面简写为 HB）的关系，基于以下的设想：</p><ul><li>分布的各进程内的事件是线序，在先发生的对在后发生的具备 HB 关系</li><li>跨进程（进程间消息通信作为收/发两个事件）的事件，发出对接收有 HB 关系。</li></ul><p>根据实际情况我们很容易总结出来，HB 关系应该是<strong>反自反、反对称、传递</strong>的。</p><p>整个分布式系统由于消息的通信构成一个从系统 start 开始的偏序集合。</p><h3 id="Logical-Clocks"><a href="#Logical-Clocks" class="headerlink" title="Logical Clocks"></a>Logical Clocks</h3><p>基于 HB 关系，Lamport 给出了一个给事件赋值的函数（逻辑时钟）及其计算方法，先后可通过函数值（逻辑时钟值）大小反映出来（<strong>但反过来不行</strong>）。</p><p>分布式算法概括：</p><ol><li>每个 Process 对本进程的线序事件，计数值递增。</li><li>每个 Process 的事件发送消息时，附带时间戳。</li><li>每个 Process 接受到其他事件的消息时（HB 关系箭头的弧头），更新其计数器值为消息时间戳和本地计数器值 Max（+1）。</li></ol><h3 id="Order-Totally"><a href="#Order-Totally" class="headerlink" title="Order Totally"></a>Order Totally</h3><p>将偏序全局化，需要人工定义一个 Process 的优先值（Process 顺序）。</p><p>人工定义的 Process 顺序不同会导致全序的不同，所以对于一个确定的（消息发送等确定）分布式系统，<strong>偏序集是确定的（唯一的），而全局序是不唯一的</strong>。</p><p>托这个全局序（全局的时间戳值）的福，Lamport 给出了一个解决单资源互斥问题的分布式算法。</p><p>算法细节及证明见翻译 doc，直观理解，没有这个全局序我们就不能依靠全局序的时间戳来比较从而进行对应操作。</p><h3 id="Physical-Clocks"><a href="#Physical-Clocks" class="headerlink" title="Physical Clocks"></a>Physical Clocks</h3><p>对于异常情况：存在外部的限制要求。Lamport 给出的解决方法。</p><ol><li>外部要求内部化</li><li>引入实际物理时钟</li></ol><p>对物理时钟的要求是：增速逼近单位 1，以及分布式物理时钟的一致性（数学证明还没有看懂）。</p><h2 id="读完感受"><a href="#读完感受" class="headerlink" title="读完感受"></a>读完感受</h2><p>虽然是 1970+的文章了，但是分布式的核心问题（我以为的）已然提及，Lamport 对分布式中事件顺序的认识像极了相对论世界中事件/时间的观点，着实让我 get 了分布式不同于我现在所用所看所学的单机系统最大的不同。</p><p>对于问题解决的思路也是极为清晰，从关系的定义，到不依赖实际时间的逻辑大小、到全局化、再到实际时钟，结合实际问题的分布式算法，可以从最初的构想到最终的实现有一个流水线似的认识。</p><p>自己最喜欢的离散数学也在这里面发挥了很大的作用，见识到了数学——这种基础学科作为科学发展地基般的作用，我反复读了四到五遍文章，也看了 Lamport 本人对他自己这篇文章的评价和网络上其他人的评价，对于文章中可推的公式和可证明的地方都尝试自己推导了一下，着实让人着迷，作为自己尝试科研的启蒙文章，真的非常开心。</p><h1 id="Paper2——Implementing-Fault-Tolerant-Services-Using-the-State-Machine-Approach-A-Tutorial"><a href="#Paper2——Implementing-Fault-Tolerant-Services-Using-the-State-Machine-Approach-A-Tutorial" class="headerlink" title="Paper2——Implementing Fault-Tolerant Services Using the State Machine Approach: A Tutorial"></a>Paper2——Implementing Fault-Tolerant Services Using the State Machine Approach: A Tutorial</h1><p>回忆梳理关键词：<strong>状态机</strong>，<strong>容错（Fault Tolerance）</strong>、<strong>两种故障</strong></p><h2 id="主体内容总结-1"><a href="#主体内容总结-1" class="headerlink" title="主体内容总结"></a>主体内容总结</h2><p>看论文标题就知道，是一篇“Tutorial”，讲了用状态机模型来达到容错服务。</p><p>包括后面所看到的 GFS，自己学习的 LVM，都存在这样的问题：<strong>出错、出错、出错</strong>，由多台分布式机器构成的系统中难免会碰到这样那样的错误，防止出错此时显得太过较真，采用合适的策略（状态机、备份、心跳线热启动等）将出错导致的系统整体性能下降掩盖过去，达到高可用、用户层透明才是更“分布式”的思考方式。</p><h3 id="State-Machine"><a href="#State-Machine" class="headerlink" title="State Machine"></a>State Machine</h3><p>接触了算法中涉及的自动机（AC 自动机、后缀自动机）以及编译原理中的自动机（DFA，PDA），对于状态机的概念已经比较熟悉了，这里用文章中的定义再从另一个角度强调一下：<strong>状态机的输出完全由它处理的请求序列决定</strong>。</p><h3 id="Fault-Tolerance"><a href="#Fault-Tolerance" class="headerlink" title="Fault Tolerance"></a>Fault Tolerance</h3><p>两种计算机系统中常见错误：</p><ul><li>Byzantine Failures（拜占庭故障）：该组件可能表现出任意和恶意的行为，可能涉及与其他故障组件的勾结（个人理解是会反馈假结果，无法有效监测且可能影响周围组件）</li><li>Fail-stop Failures. （异常终止错误）：允许其他组件检测到错误并停止。</li></ul><p>考虑最坏情况下的 t tolerance</p><p>拜占庭故障所需组件数：2t+1（保证多数）<br>异常终止所需组件数：t+1（保证存在一个返回正确结果即可）</p><p>某些特殊条件下还可以弱化条件。</p><p>实现的条件是保证备份（副本）的协调（Replica Coordination）：所有备份（副本）都可以接收到且接收到顺序相同的请求序列。</p><p>拆分成两个子要求：</p><ol><li>Agreement：每个非故障状态机都会接收到每个请求。</li><li>Order：每个非故障状态机都会以相同的顺序处理这些请求。</li></ol><p>文章后续解释了个子要求的实现方式。</p><p>Agreement: 通过设置 transmitter 来使所有非故障状态机达到相同值。</p><h3 id="Order"><a href="#Order" class="headerlink" title="Order"></a>Order</h3><p>Order 条件极其稳定性测试，稳定的请求可以传递给后面的状态机副本。个人对稳定的理解：具备相对优先顺序、不会改变、可被执行。</p><p>文章介绍了几种实现方法：</p><ul><li>使用逻辑时钟（Lamport 的方法）赋值</li><li>同步的物理时钟方法</li></ul><p>对应的稳定性检测在文章翻译部分分析过了，逻辑时钟是基于 FIFO 假设以及错误信息告知假设，使得当收到其他机器发来了更晚时间戳请求时，则先前的请求就是稳定的。而物理时钟是满足在$\tau - \delta$时间之前的即为稳定的。</p><h2 id="读完感受-1"><a href="#读完感受-1" class="headerlink" title="读完感受"></a>读完感受</h2><p>应用了上一篇 Lamport 的时钟来解决 Order 的问题，感觉思路上是联通的。</p><p>状态机模型的应用有点感觉是执行状态的重复（但是说实话没有找到确切的状态描述，可能是论文看的还不够仔细）。</p><p>重新认识了两种类型，然后突然发现拜占庭问题还是 Lamport 等人最先提出来的，我想有机会去了解一下原论文，毕竟这个问题在网络/安全/系统中出现多次了。</p>]]></content>
    
    
    <categories>
      
      <category>Computer Science</category>
      
      <category>分布式系统</category>
      
    </categories>
    
    
    <tags>
      
      <tag>分布式系统</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>数论学习——同余式、幂与欧拉公式</title>
    <link href="/post/ce543259.html"/>
    <url>/post/ce543259.html</url>
    
    <content type="html"><![CDATA[<h1 id="定理-10-1（欧拉公式）"><a href="#定理-10-1（欧拉公式）" class="headerlink" title="定理 10.1（欧拉公式）"></a>定理 10.1（欧拉公式）</h1><blockquote><p>如果$\gcd(a,m) = 1$，则</p><script type="math/tex; mode=display">a^{\phi(m)} \equiv 1 \mod m</script></blockquote><h2 id="证明过程"><a href="#证明过程" class="headerlink" title="证明过程"></a>证明过程</h2><p>至此，我们已经确定了考察的数的正确集合，所以欧拉公式的证明几乎和费马小定理完全一致。</p><p>先证明引理：</p><blockquote><p><strong>引理 10.2</strong> 如果$\gcd(a,m) = 1$，则数$b_{1}a,b_{2}a,b_{3}a, \cdots , b_{\phi(m)}a \mod m$与数$b_{1},b_{2},b_{3}, \cdots , b_{\phi(m)} \mod m$相同，尽管他们的次序并不相同。</p></blockquote><p><strong>证明</strong>：（极尽相似费马小定理的证明）实际上我们是证明了一个弱一些的结论，由于可以确定$\phi(m) \le m-1$，当$m$为素数时候取等，那么我们不妨假设有$b_j a \equiv b_k a \mod m$，做差，由于同余，而$m \nmid a$，$m \mid \vert b_j - b_k \vert$，而由于前述条件，只能有$0$符合条件，则得到$b_j \equiv b_k \mod m$，与假设矛盾（应该两两不同余）。引理得证。</p><p>后续，构造</p><script type="math/tex; mode=display">(b_{1}a) \cdot (b_{2}a) \cdot (b_{3}a) \cdots (b_{\phi(m)}a) \equiv b_1 \cdot b_2 \cdot b_3 \cdots b_{\phi(m)} \mod m</script><p>提公因式：</p><script type="math/tex; mode=display">a^{\phi(m)}B \equiv B \mod m</script><p>由于每个$b_i$与$m$互素，所以我们可以两边整体消去$B$，得到：</p><script type="math/tex; mode=display">a^{\phi(m)} \equiv 1 \mod m</script>]]></content>
    
    
    <categories>
      
      <category>Mathematics</category>
      
      <category>数论</category>
      
    </categories>
    
    
    <tags>
      
      <tag>数论</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>数论学习——同余式、幂与费马小定理</title>
    <link href="/post/799b8bb4.html"/>
    <url>/post/799b8bb4.html</url>
    
    <content type="html"><![CDATA[<h1 id="费马小定理"><a href="#费马小定理" class="headerlink" title="费马小定理"></a>费马小定理</h1><blockquote><p>设$p$是素数，$a$是任意整数且$a$，则</p><script type="math/tex; mode=display">a^{p-1} \not\equiv 1 \mod p</script></blockquote><h2 id="证明过程"><a href="#证明过程" class="headerlink" title="证明过程"></a>证明过程</h2><p>尝试证明一般性的费马小定理。首先证明如下断言。</p><blockquote><p><strong>引理 9.2</strong> 设$p$是素数，$a$是任何整数且$a \not\equiv 0 \mod p$，则数$a,2a,3a, \cdots , (p-1)a \mod p$与数$1,2,3, \cdots ,(p-1)$相同，尽管他们的次序并不相同。</p></blockquote><p><strong>证明</strong> 反证法，假设存在两个模$p$同余的$ka,ja$，且两个数本身是不同的，做差后在这个假设下反推，若同余，而$p$为素数，素数整除乘积，必定整除乘积的一个因数，而我们从要求中已经得到$p \nmid a$，而又$\vert k-j \vert &lt; p-1$，得到$k-j = 0$，而这与我们假设两者本身不同相违背，得证。</p><p>利用该引理，容易完成费马小定理的证明，引理说明数列$a,2a,3a, \cdots , (p-1)a \mod p$与数列$1,2,3, \cdots ,(p-1) \mod p$相同，构造：</p><script type="math/tex; mode=display">a \cdot (2a) \cdot (3a) \cdots ((p-1)a) \equiv 1 \cdot 2 \cdot 3 \cdots (p-1) \mod p</script><p>从左边提出$p-1$个$a$得：</p><script type="math/tex; mode=display">a^{p-1} \cdot (p-1)!  \equiv  (p-1)!  \mod p</script><p>根据同余式两边消的性质（参加另一篇《同余式、线性同余定理》拓展性质 2），我们便可以得到。</p><script type="math/tex; mode=display">a^{p-1} \equiv 1 \mod p</script>]]></content>
    
    
    <categories>
      
      <category>Mathematics</category>
      
      <category>数论</category>
      
    </categories>
    
    
    <tags>
      
      <tag>数论</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>数论学习——同余式、线性同余定理</title>
    <link href="/post/ebe560d9.html"/>
    <url>/post/ebe560d9.html</url>
    
    <content type="html"><![CDATA[<p>今天写密码学实验报告放射密码一题的时候，看到线性同余式$c = ma+ b \mod n$，感觉到自己对于同余方程的掌握一点也不牢固，所以又拿出来《数论概论》重新回顾了一下，后续会写一个数论专题，本章主要讨论线性同余式定理。</p><h1 id="同余式"><a href="#同余式" class="headerlink" title="同余式"></a>同余式</h1><p>对于同余式我们已经很熟悉了，如果$m$整除$a-b$我们就说$a$与$b$模$m$同余。</p><p>记为</p><script type="math/tex; mode=display">a \equiv b \mod m</script><p>同余式满足一些我们熟悉的通常的等式的性质，例如：$a_1 \equiv b_1 \mod m$，且，$a_2 \equiv b_2 \mod m$，那么我们可以得到$a_1 \pm b_1 \equiv a_2 \pm b_2 \mod m$（类似等式两边相加），以及$a_1 a_2 \equiv b_1 b_2 \mod m$（类似等式两边相乘），但是需要指出的是，用数除同余式并不总是可能的，这个问题详见拓展性质 2。</p><p>数$m$叫做同余式的<strong>模</strong>，我们也很容易得知，每个整数必然与 0~m-1 的一个数模$m$同余。</p><p>一些同余式的拓展性质</p><ol><li><p>同余式 $ab \equiv (a \mod m)(b \mod m) \mod m$ 恒成立。</p><p>证明：已知$a \equiv (a \mod m) \mod m$，$b \equiv (b \mod m) \mod m$，所以由相乘的性质德政。</p></li><li><p>当满足$\gcd (c,m) = 1$，则同余式$a c \equiv b c \mod m$可从同余式两边消去$c$。</p><p>证明：对于同余式$a c \equiv b c \mod m$成立，则有等式$ac-bc = km, k \in Z$，即$(a-b)c = km$成立，我们容易观察得等式左边为$c$的倍数，所以等式右侧也应为$c$的倍数，而我们又知道$\gcd (c,m) = 1$，也即$c \nmid m$，所以$c \mid k$，不妨设$k’c = k$，所以我们可以得到$a - b = k’ m$，故有，$a \equiv b \mod m$，得证。</p></li></ol><h1 id="同余方程"><a href="#同余方程" class="headerlink" title="同余方程"></a>同余方程</h1><p>我们的任务是解同余式$ax \equiv c \mod m$，包括判断其有没有解，有几个解，各个解是什么。</p><p>当然，可以应用同余式的性质解决一些简单的带未知数的同余式，如$4x \equiv 3 \mod 19$，我们两边乘以$5$得出，$20x \equiv 15 \mod 19$，应用性质 1，可得到$x \equiv 15 \mod 19$，代入可检测我们的答案。事实上，该式也只有这一个解。</p><p>我们接下来回归到一般形的求解过程中。对于同余式：</p><script type="math/tex; mode=display">ax \equiv c \mod m</script><p>我们需要求整数$x$使得$m \mid ax-c$，如果可以求得整数$y$使得$ax-c = my$，则数$m$ 就整除数$ax-c$，移项后我们看到$ax \equiv c \mod m$有解当且仅当线性方程$ax-my =c$有解（等价推导），这个问题很像线性方程和最大公因数里讨论的问题（拓展欧几里得算法）。</p><p>设$g = \gcd(a,m)$，我们观察到，形如$ax-my$的每个数都是$g$的倍数。因此：</p><ol><li>$g \nmid c$，则$ax-my = c$无解，从而由等价性，原同余方程也没有解。</li><li><p>$g \mid c$，则由线性方程定理我们可以知道</p><script type="math/tex; mode=display">au+mv = g</script><p>总是有解的，不妨假设通过拓展欧几里得算法求得$u = u_0$，$v = v_0$，则有：</p><script type="math/tex; mode=display">a u_0 + m v_0 = g</script><p>我们可以与原同余方程等价的线性方程的一个解。</p><script type="math/tex; mode=display">a \frac{c u_0}{g} + m \frac{c v_0}{g} = c</script><p>即我们得到了$x_0 \equiv \frac{c u_0}{g} \mod m$式原同余方程的一个解，那其他解呢？假设$x_1$是同余式的其他解，则$a x_1 \equiv a x_0 \mod m$，那么$m \mid a x_1 - a x_0$，这蕴含：</p><script type="math/tex; mode=display">\frac{m}{g} \mid \frac{a(x_1 -x_0)}{g}</script><p>我们已知$\frac{m}{g}$与$\frac{a}{g}$没有大于 1 的公因数（除以最大公因数），从而$\frac{m}{g} \mid x_1 - x_0$。</p><script type="math/tex; mode=display">x_1 = x_0 + k \bullet \frac{m}{g}</script><p>但是相差为$m$的倍数的两个解在模数意义下被认为是相同的，所以原同余方程恰好有$g$个不同的解，即</p><script type="math/tex; mode=display">x_i = x_0 + i \bullet \frac{m}{g}, i = 0,1,2 \cdots , g-1</script><p>子证明，假设有$g+1$个不同解，则由鸽笼定理知，必存在$i_p \equiv i_q \mod g$，则$x_p - x_q = (p-q) \bullet \frac{m}{g} = k’g \bullet \frac{m}{g} = k’m$，那么这两个解是相同的，矛盾。</p></li></ol><p>这就完成了对同余式$ax \equiv c \mod m$的分析，结果为如下定理</p><h1 id="线性同余定理"><a href="#线性同余定理" class="headerlink" title="线性同余定理"></a>线性同余定理</h1><blockquote><p><strong>设$a,c,m \in Z$,$m \geq 1$，且设$g = \gcd (a,m)$.</strong></p><p>(a)如果$g \nmid c$，则同余式$ax \equiv c \mod m$没有解。</p><p>(b)如果$g \mid c$，则同余式子$ax \equiv c \mod m$恰好有$g$个不同的解，先利用拓展欧几里得算法求得线性方程</p><script type="math/tex; mode=display">au+mv = g</script><p>的一个解$(u_0,v_0)$，则$x_0 = \frac{c u_0}{g}$是同余方程的一个解，完全集由</p><script type="math/tex; mode=display">x = x_0 + k \bullet \frac{m}{g}  \mod m , k = 0,1,2 \cdots , g-1</script></blockquote><a id="more"></a><h2 id="重要注记"><a href="#重要注记" class="headerlink" title="重要注记"></a>重要注记</h2><p>线性同余式定理的最重要的情形是$\gcd (a,m) = 1$，在这种情形下，同余式恰好有一个解。我们甚至可以把解写成分数</p><script type="math/tex; mode=display">x \equiv \frac{c}{a}  \mod m</script><h1 id="模-p-多项式根定理"><a href="#模-p-多项式根定理" class="headerlink" title="模$p$多项式根定理"></a>模$p$多项式根定理</h1><blockquote><p>设$p$为素数，$f(x) = a_0 x^{d} + a_1 x^{d-1} +\cdots +a_d$是次数为$d ≥ 1$的整系数多项式，且$p$不整除$a_0$，则同余式$f(x) \equiv 0 \mod p$最多有$d$个模$p$不同余的解。</p></blockquote><p>反证法：</p><p>假设：存在一个首项系数不被$p$整除的整系数多项式$F(x)$，使得同余式$F(x) \equiv 0 \mod p$模$p$不同余的根的个数大于$F(x)$的次数。</p><p><strong>在所有这样的多项式中选择一个次数最低的$F(x)$</strong>，为 d 次，则$r_1,r_2,\cdots,r_{d+1}$是同余式的$d+1$个模$p$不同余的解。对于任意值$x$，$r$，$F(x)-F(r)$都是可约的（利用$a^t - b^t = (a-b)(a^{t-1}+a^{t-2}b+ \cdots + b^{t-1})$），我们可以得到，$F(x) = F(r)+(x - r)G(x)$，而$G(x)$的次数为$d-1$次，我们已经假设原$F(x) \equiv 0$有$r+1$个互不同余的解，令$x=r_1$，$r$取剩下其中任意一个$r_k$，由于$p$为素数，我们可以得到$G(r_k) \equiv 0 \mod p$，我们发现$G(x)$也是一个符合要求的多项式，这就与我们的假设条件相互矛盾，<strong>$F(x)$不是最小次的</strong>。得证。</p>]]></content>
    
    
    <categories>
      
      <category>Mathematics</category>
      
      <category>数论</category>
      
    </categories>
    
    
    <tags>
      
      <tag>数论</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>《Justice公正》桑德尔教授公共课观后感+读书摘录</title>
    <link href="/post/9fb9be6e.html"/>
    <url>/post/9fb9be6e.html</url>
    
    <content type="html"><![CDATA[<h1 id="第一章-做正当的事"><a href="#第一章-做正当的事" class="headerlink" title="第一章 做正当的事"></a>第一章 做正当的事</h1><p>对于灾患情况下一些物价被抬长，反价格欺诈法的出现在人群中出现了一些争论声，以“查理”飓风袭击美国为例，有的人反对，这样讲到，<strong>“根据市场所产生的价格索价，不是欺诈，也不是贪婪或无耻之举，而只是物品和服务在自由社会中分配的方式。尽管价格暴涨着实令人恼怒，但这些愤怒并不构成干涉自由市场的”正当理由。高价格才能促使更多的生产流入患灾地区。”</strong>而另一些人则维护反价格欺诈法，<strong>“在危急关头，比如当人们逃命时，或者在飓风后为家人寻求基本日用品时，在索要过高价格，政府不能袖手旁观。”</strong></p><p>关于反价格欺诈的争论引发了一些道德和法律相关的棘手问题：物品和服务的销售商利用一场自然灾害，根据市场需求随意定价，这是否是不正当的？如果不正当，那么法律应当做些什么呢？政府是否应当禁止价格欺诈——即使这样做干涉了购买者和销售者的交易自由。</p><h2 id="福利、自由与德性"><a href="#福利、自由与德性" class="headerlink" title="福利、自由与德性"></a>福利、自由与德性</h2><p>法律的出台，制定的问题，以及我们如何组织一个社会，这些都是关于公正（Justice）的问题，想要解答它们，我们必须探索公正的含义。</p><p>有些人对于反价格欺诈法的争论，背后的福利、自由的问题以及一些人们对于这些话题（尽管他们没有切身受到飓风影响）所表达出来的情绪波动，都表征着背后的一种我们潜意识里的道德论证。</p><p>我个人觉得尽管潜意识里已经进行过自我的道德论证，对于深入的讨论，对社会有贡献的讨论，我们有必要将这种论证明确化，以避免其仅出自一种本能的、直觉的反应。这种情绪常被看做是一种原始的、不应当干涉公共政策或法律的感情。</p><blockquote><p>雅各比：“把商贩们看做魔鬼并不能加快弗罗里达重建的脚步。”</p></blockquote><p>政治哲学中一个重要问题：一个公正的社会应当努力推进其公民的德性吗？或者，法律是否应当在各种德性观念中保持中立，以使公民们能够自由地为自己选择最佳的生活方式？</p><p>传统观点认为，对于这一问题的不同解答区分了古代和现代的两种政治思考。在某种意义上是对的，亚里士多德教导我们公正意味着给予人们所应得，我们不得不决定哪些德性值得尊敬和奖赏，<strong>如果不首先反思哪种是人们最想要的生活方式，我们就不能弄明白什么是公正的宪法</strong>。对他而言，法律不可能中立于良善生活的各种问题。</p><p>与此相对，现代政治哲学家们——从 18 世纪的伊曼纽尔·康德（Immanuel Kant）到 20 世纪的约翰·罗尔斯（John Rawls）——认为，<strong>那界定我们各种权利的公正原则，应当不依赖于任何特殊的德性观念或最佳生活方式的观念</strong>，反过来讲，一个公正的社会应当尊重每个人选择它自己的关于良善生活观念的自由。</p><a id="more"></a><h2 id="受什么样的伤才配得上紫心勋章"><a href="#受什么样的伤才配得上紫心勋章" class="headerlink" title="受什么样的伤才配得上紫心勋章"></a>受什么样的伤才配得上紫心勋章</h2><p>关于紫心勋章的争论，并不只是一种如何界定上海之真实性的医学或临床上的争论。此争论的核心在于各种关于道德品格和勇士勇气的观念。坚持流血才能配得上紫心勋章的人们相信，创伤后应激障碍反映出的不是值得赞赏或鼓励的德性，而是一种不值得尊敬的性格上的软弱；而那些认为心理创伤也应当算数的人们则反驳说，那些受到长期性心灵创伤和严重抑郁症所折磨的老兵们，与那些失去一只胳膊的老兵们为他们的国家做出的牺牲同样确凿无疑，同样光荣。</p><p>如果不搞清楚军章所鼓励的德性是什么，我们就不能决定谁可以配得上紫心勋章，这与亚里士多德教导我们的相一致。</p><p>展开来讲，这一事件追溯回从荣誉和德性的古代伦理，其实今天有关经济安排的对与错的争论，经常会将我们带回到亚里士多德关于人们在道德上应得什么，以及为何如此的讨论。</p><h2 id="对政府救助的愤慨"><a href="#对政府救助的愤慨" class="headerlink" title="对政府救助的愤慨"></a>对政府救助的愤慨</h2><p>经济危机时发给金融投机公司高管的奖金，点燃了公众的怒火。许多人批判其为贪婪，但是这种对于贪婪的批判的问题在于，<strong>它没有把这次经济崩溃后从救助款项中拿到的奖励，与经济繁荣时期从市场获得的奖励区分开来</strong>。事实上民怨的核心是：政府奖励了他们的失败，这才是他们真正愤怒的地方。</p><p>更深入的，成功人士应得市场所赋予他们的丰厚收入吗？这些丰厚收入是否取决于他们无法掌控的因素呢？在经济良好时期和经济低迷时期，公民之间的相互责任又意味着什么呢？</p><h2 id="失控的电车"><a href="#失控的电车" class="headerlink" title="失控的电车"></a>失控的电车</h2><p>在不可停下只可转换轨道的电车上，原始轨道上有五个工人，右边轨道有一个工人。是撞向五个人还是撞向那一个人？</p><p>牺牲一个人生命以挽救五个人的生命似乎是正当的事情，那如果更换情况，一个壮硕的人在桥上，推下去可以挽救五个人，这时候会坚持原有的道德判断吗？如果你觉得用自己的双手将一个人推向死亡确实比转动电车的方向盘更加残忍，那再做改变，你有一个可以转向的方向盘，连接那个壮硕的人脚下的一个活板门，不伸手推，这时候转动这个方向盘就会使之成为正当之举了吗？或者，者是否仍然比作为有轨电车司机的你拐向岔道在道德上更为恶劣呢？</p><p>某些道德困境源于相互冲突的道德原则，另一些则源于我们不确定事情如何展开（阿富汗牧羊人困境，《孤独幸存者》）。重要的假想案例有助于我们剥离出重要的道德原则，并检验它们的力量。</p><h1 id="第二章-最大幸福原则-功利主义"><a href="#第二章-最大幸福原则-功利主义" class="headerlink" title="第二章 最大幸福原则/功利主义"></a>第二章 最大幸福原则/功利主义</h1><p>“米尼奈特”沉没使得饥肠辘辘的四人不得不决定其中一个人作为其他三人的“食物”，我们该如何看待？</p><p>如果拯救多数人而不是全部饿死是提升了人们的整体幸福感，那么我们的反驳又从何而来呢？是质疑实际利益（幸福感）的提升并非如我们想象的那样？（比如此事件的恶劣后果导致的社会影响，削弱对谋杀这一规范的权威性？）还是说尽管利大于弊，但我们仍感觉在道德上无法接受这一做法。</p><p>这引导我们去探索一些更重大的道德和政治哲学的问题：道德就是计算生命、权衡得失呢？还是某些道德责任和人权是根本的，以至于它们超越于这样的算计之上？如果某些权力在这方面是根本性的——假如它们是自然的、神圣的、不可剥夺和无条件的——我们该如何甄别它们呢？又是什么使得它们具有这样的根本性呢。</p><h2 id="杰里米·边沁的功利主义"><a href="#杰里米·边沁的功利主义" class="headerlink" title="杰里米·边沁的功利主义"></a>杰里米·边沁的功利主义</h2><p>边沁是英国道德哲学家和法律改革者，创立了功利主义（Utilitarianism）学说，其主要观点很简单，并对人具有直觉上的吸引力：<strong>道德的最高原则就是使幸福最大化，使快乐总体上超过痛苦</strong>，对边沁而言，<strong>正当的行为就是任何使功利最大化的行为</strong>。他所说的“功利”，意指任何能够产生快乐或幸福，并阻止痛苦或苦难的东西。</p><p>边沁将其哲学思想尝试作为政治改革的基础，他提出了很多计划来使刑法政策更有效、更人性化。诸如环形监狱（私人监狱）、乞丐的管理收容（为了促进整体社会福利而将他们行动上隔离）。</p><p>对于边沁的反对声音当然也存在，在考虑当代的功利主义思维方式的事例之前，我们有必要质问，边沁的哲学是否可以反驳呢？如果是的话，理由是什么？</p><h3 id="反驳-1：个体权利"><a href="#反驳-1：个体权利" class="headerlink" title="反驳 1：个体权利"></a>反驳 1：个体权利</h3><p>如果坚持边沁所认为的功利主义的逻辑，就极有可能纵容无视人类基本尊严的行为，比如将基督徒扔给狮子来取悦古罗马人，严刑逼供来防止一场大规模恐怖袭击。那如果严刑逼供能达到的唯一目的是折磨恐怖分子年幼无知的女儿呢（她对事情一无所知）？</p><p>批评者们认为有些时候为了整体利益而去侵犯一个人的一些基本权利（比如生命、自由）是在道德上不可接受的。这是对<strong>维护基本人权</strong>的考量。</p><h2 id="反驳-2：通用价值货币"><a href="#反驳-2：通用价值货币" class="headerlink" title="反驳 2：通用价值货币"></a>反驳 2：通用价值货币</h2><p>更 Commercial 的例子有烟草公司的伤害性帮助政府节省了很大的开支，是促进了整体福利吗？福特公司明知 Pinto 汽车油箱问题但为了收益的最大化（以死亡赔付衡量生命价值后）选择无视问题，是正确的吗？等等。</p><p>深究我们对于功利主义的批判，最终归根于一些道德重要的东西——亦即这样一种观念：<strong>我们不可能在一个尺度上衡量和比较所有的价值和物品。</strong></p><p>#</p>]]></content>
    
    
    <categories>
      
      <category>Life</category>
      
      <category>阅读</category>
      
    </categories>
    
    
    <tags>
      
      <tag>阅读</tag>
      
      <tag>影视</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>分布式系统学习——GFS谷歌文件系统Paper翻译</title>
    <link href="/post/7c86d8e8.html"/>
    <url>/post/7c86d8e8.html</url>
    
    <content type="html"><![CDATA[<h1 id="读书笔记——The-Google-File-System"><a href="#读书笔记——The-Google-File-System" class="headerlink" title="读书笔记——The Google File System"></a>读书笔记——The Google File System</h1><p><a href="https://www.cnblogs.com/finalboss1987/p/5169559.html" target="_blank" rel="noopener">参考翻译版本：Google File System 翻译（转）</a></p><p>加粗和笔者注是重点关注的部分。</p><h1 id="Abstract"><a href="#Abstract" class="headerlink" title="Abstract"></a>Abstract</h1><p>我们已经设计和实现了 Google File System，一个适用于大规模分布式数据处理相关应用的，可扩展的分布式文件系统。它基于普通的不算昂贵的硬件设备，<strong>实现了容错的设计，并且为大量客户端提供极高的整体处理性能</strong>。</p><h1 id="Introduction"><a href="#Introduction" class="headerlink" title="Introduction"></a>Introduction</h1><p>我们已经为 Google 迅速增长的数据处理需求而设计和实现了 Google File System(GFS)。GFS 和上一个分布式文件系统有着很多相同的设计目的，比如性能，扩展性，可靠性，以及可用性。不过，包括现在和未来预期下，它的设计是基于我们应用的工作量和技术环境驱动的，因而 GFS 都有一些和上一个版本明显不同的地方。这就要求我们重新审视传统的设计选择，并探索完全不同的设计要点。</p><ul><li>首先，<strong>节点失效将被看成是正常情况，而不再视为异常情况</strong>。整个文件系统包含了几百个或者几千个由廉价的普通机器组成的存储机器，而且这些机器是被与之匹配数量的客户端机器访问。这些节点的质量和数量都实际上都导致总会出现一些失效情况，并且某一部分机器并不会从当前失效中恢复回来。原因是多样的，比如程序的 bug，操作系统的 bug，人工操作 error，以及硬盘坏掉，内存，网络，插板的损坏，电源的坏掉等等。因此，<strong>持续监视，错误检测，容错处理，自动恢复</strong>必须集成到这个文件系统的设计中来。</li><li>第二，<strong>大型数据文件的规模出现导致文件观念的改变</strong>。当我们通常操作迅速增长的，由很多 TB 组成的，包含数十亿对象的数据集，我们可不希望管理数十亿个 KB 大小的文件（无论文件系统是否有如此能理）。所以，设计约定和设计参数比如 I/O 操作以及 blocksize（块大小），都需要重新审查。</li><li>第三，<strong>文件的改变常为追加（append）而非覆盖（overwrite），对一个文件的随机写操作（random write）实际上是几乎不存在的</strong>。当一旦写完，文件就是只读的，并且一般都是顺序读取。许多 data 都具备这样的特性：仅供应用扫描数据的超大数据库、应用不断产生的数据流、归档的数据、机器交互的中间数据生成和处理。对于这些巨型文件的访问模式来说，“追加（append）”是最重要的，所以我们首要在性能上优化并保证原子性操作的就是它，而缓存客户端中的数据块则失去吸引力（不是 GFS 重点关注的对象）。</li><li>第四，结合应用与文件系统 API 一同设计对于增加整个系统的弹性有很大的好处。例如我们放宽 GFS 一致性模型后可以在避免给应用增加负担的同时简化文件系统。我们也引入了原子的追加（append）操作，这样可以让多个客户端并发对同一文件进行追加操作，而不需要额外的同步。这些在本论文的后边章节有描述。</li></ul><a id="more"></a><h1 id="Design-Overview"><a href="#Design-Overview" class="headerlink" title="Design Overview"></a>Design Overview</h1><h2 id="Assumptions"><a href="#Assumptions" class="headerlink" title="Assumptions"></a>Assumptions</h2><p>在针对我们的需求设计文件系统时，由一些既是机会又是挑战的假设指导我们的操作。前述给出了一些关键信息，现在将更细致的阐述这些假设。</p><ul><li>系统由许多廉价而易出错的商品组件构成，他必须持续监管自身并在此基础上及时监测、容纳组件故障。</li><li>系统存储了大量的超大文件。预期好几百万个文件，每一个超过 100MB。数 GB 的文件会经常出现并且应当受到有效的管理。系统必须同时支持小型文件，但不必为小型文件进行特别的优化。</li><li>一般的工作都是由两类读取操作组成：大规模流式读取和小规模随机读取。<ul><li>在大规模流式读取中，每个独立操作通常要读取几百 KB 的数据，更常见的是每次读取 1MB 或者以上的数据。对于同一个客户端来说，往往会发起连续的读取操作顺序读取一个文件。</li><li>小规模的随机读取通常在文件的不同位置，读取几 KB 数据。对于性能有过特别考虑的应用通常会作批处理并且对他们读取的内容进行排序，这样可以使得他们的读取始终是单向顺序读取，而不需要往回读取数据。</li></ul></li><li>工作同时包含大规模顺序的写操作，将数据不断追加之文件中，其规模与读取规模相当。一旦写入完成，文件几乎不会再做该懂。小的随机写入操作应被支持但无需在意其效率。</li><li>系统必须为同时追加到同一文件的多个客户端有效地实现明确定义的语义含义。我们的文件通常用于生产者 - 消费者队列情形或用于多路合并（many-way merging）。 数百个独立运作在机器上的生产者将并发地向某个文件追加数据。 具有最小同步开销的原子性保证是必不可少的。</li><li>高持续带宽比低延迟更重要。我们的大多数目标应用程序都在处理大量数据时以很高的速度预先完成任务，很少有对单个读或写有严格的响应时间要求的应用程序。</li></ul><h2 id="Interface"><a href="#Interface" class="headerlink" title="Interface"></a>Interface</h2><p>虽然 GFS 没有实现像 POSIX 这样一些标准地 API，但是它提供了一套常见的文件系统接口。文件在目录中按层次结构组织，并由路径名标识。我们提供了对文件的一些常规的操作：_create_，_delete_，_open_，_close_，_read_，_write_。</p><p>此外 GFS 还提供了<em>snapshot</em>，<em>record append</em>操作。Snapshot 以较低耗费建立一个文件或者是目录树的拷贝。Record append 则允许多个客户端对相同一个文件并发进行追加（append）数据时保证每个追加操作的原子性。这个对于多路合并操作和多个客户端同时操作的生产者/消费者队列的实现非常有用，它不用额外的加锁处理。这种文件对于构造大型分布式应用来说，是不可或缺的。两者将在后面 3.4 和 3.3 节单独讲述。</p><h2 id="Architecture"><a href="#Architecture" class="headerlink" title="Architecture"></a>Architecture</h2><p>一个 GFS 集群由一个 master 和多个 chunkserver 组成，可以被多个 client 访问，如图 1 所示。</p><p>它们都是一个运行着用户级服务进程（user-level process）的商品化 linux 机器。只要机器资源允许以及由于运行可能的片状应用程序代码带来的低可靠性是可以接受的，那么可以很容易的在同一台机器上运行一个 chunkserver 和 client。</p><p><img src="https://eddyblog.oss-cn-shenzhen.aliyuncs.com/%E8%AE%BA%E6%96%87%E6%88%AA%E5%9B%BE/OS_4_1.png" srcset="/img/loading.gif" alt="OS_4_1"></p><p>文件被划分成固定大小的 chunk。每个 chunk 是由 chunk 创建时由 master 分配的一个不可变的全局唯一的 64bit 句柄来标识。Chunkserver 将 chunk 作为 linux 文件存储在本地，对于 chunk 数据的读写通过 chunk 的 handle 和字节边界来表示。为了可靠性，每个 chunk 存储在多个 chunkserver 上。尽管用户可以为不同文件名字空间区域指定不同的备份级别，默认地我们存储三个备份（与后续的 MapReduce 对于 GFS 输入文件常为三份备份习惯上是一回事）。</p><p>Master 维护所有的文件系统元数据。包括名字空间（namespace），访问控制信息（access control information），文件与 chunk 的映射信息，chunk 的当前位置（current locations 注意是 chunck 多个备份的位置）。它也控制系统范围内的一些活动，比如 chunk 租赁管理，僵死 chunk 的垃圾回收，chunkserver 间的 chunk 迁移。Master 与 chunkserver 通过心跳信息（_Heart Beat_ messages）进行周期性的通信，以发送指令和收集 chunkserver 的状态。</p><p>应用程序链接的 GFS 客户端代码，实现了文件系统 API 以及代表应用程序与 master 和 chunkserver 进行通信以读写数据。客户端如果需要操作元数据则需要与 master 通信，但是所有的纯数据通信直接与 chunksever 通信。我们没有提供 POSIX API，因此也就不需要与 linux vnode layer 关联。</p><p>客户端或者 chunkserver 都不会对文件数据进行缓存（cache）。客户端缓存只能得到很少的好处，因为大部分的应用需要直接读取整个大文件或者工作集合太大根本无法缓存。没有 cache 简化了客户端和整个系统，因为不需要考虑缓存一致性问题(实际上客户端会缓存元数据)。Chunkserver 不需要进行文件数据缓存，是因为 chunk 是作为本地文件存储，这样 Linux 自身会将那些经常访问的数据进行缓存（间接利用了操作系统？）。</p><h2 id="Single-Master"><a href="#Single-Master" class="headerlink" title="Single Master"></a>Single Master</h2><p>只有一个 master 大大简化了我们的设计，而且使得 master 可以利用全局信息对 chunk 的放置和备份进行更好（sophisticated 老练的）的判断。然而，我们必须最小化其在读写过程中的参与，以防止其成为运行的瓶颈。Clients 永远不会通过 master 读取数据，它只向 master 询问它该与哪个 chunckserver 联系，并且 client 将这些信息在有限的时间段内进行缓存，直接与 chunksever 交互进行很多后续的操作。（<strong>注意，不缓存文件数据，但是会缓存和那个 chunkserver 交互的信息</strong>）。</p><p>我们简单解释一些一个读操作的交互过程：首先，通过固定大小的 chunk，客户端将应用程序中标识的文件名和 offset 转换为 chunk 的 index。然后给 master 发送一个包含文件名和 chunk index 的请求，master 返回相应的 chunk 的 handle 和所有备份的位置。客户端以文件名和 chunk index 为 key 将这条信息进行缓存。</p><p>然后客户端给其中一个备份发送一个请求，通常是最近的那个。请求标识了 chunk 的 handle 以及在那个 chunk 内的字节边界。直到缓存信息过期或者重新打开文件之前，对于相同 chunk 的后续读操作就不需要 client-master 的通信了。事实上，客户端通常在一个请求中查询多个 chunk 的信息，master 也可以将这些被请求的多个 chunk 的信息包裹在一块进行返回。这种特别的信息，并没有额外的花费就避免了未来的 client-master 的多次通信。</p><h2 id="Chunk-Size"><a href="#Chunk-Size" class="headerlink" title="Chunk Size"></a>Chunk Size</h2><p>Chunk 大小是一个关键的设计参数。我们选择了 64mb，远远大于现有的文件系统块。每个 chunk 的副本作为普通的 linux 文件存储在 chunkserver 上，如果需要才会进行扩展。Lazy 空间分配避免了内部碎片造成的空间浪费，很可能最大的碎片有向一个 chunk 那么大。</p><p>大的 chunk size 提供了几个重要的优势。首先，降低了 client 与 sever 的交互需求，因为在相同 chunk 上的读写只需要一个初始化请求就可以从 master 得到 chunk 的位置信息。这个减少对于我们的应用负载是非常明显的，因为我们应用大部分需要顺序的读写整个大文件。即使对于小的随机读取，客户端也可以很容易的缓存一个几 TB 工作集的所有 chunk 的位置信息。其次，由于 chunk 很大，那么客户端就很有可能在一个给定的 chunk 上执行更多的操作，这样可以将一个与 chunkserver 的 TCP 连接保持更长的时间，这就减少了网络开销。再者，降低了存储在 master 上的元数据大小。这样就允许我们将元数据存放在内存中，反过来就带来了我们将在 2.6.1 中讨论的其他优势。</p><p>另一方面，大的 chunk size，即使采用了 lazy 空间分配，也有它的缺点。小的文件可能只有少数几个 chunk，或许只有一个。如果很多的 client 都需要访问这个文件，这样那些存储了这些 chunk 的 chunkserver 就会变成热点。实际中，热点还没有成为一个主要的考虑点因为我们的应用绝大部分都是在顺序读大的多 chunk 文件。</p><p>然而，当 GFS 第一次使用在一个批处理队列（Batch-queue）系统时，热点确实出现了：一个可执行文件作为一个 chunk 的文件写到 GFS，然后同时在数百台机器上开始执行。存储了该可执行文件的那些 chunkserver 被数百个并发请求瞬间变成超载。我们通过更高的备份级别存储这样的可执行文件以及减慢队列系统的应用程序启动时间解决了这个问题。一个潜在的长远的解决方案是在这种情况下，允许客户端从其他客户端读取数据。（单一申请频次高的文件容易导致热点问题。）</p><h2 id="Metadata"><a href="#Metadata" class="headerlink" title="Metadata"></a>Metadata</h2><p>Master 存储了三个主要类型的元数据：<strong>文件和 chunk 名字空间，文件到 chunk 的映射信息，每个 chunk 的备份的位置</strong>。所有的元数据都保存在 master 的内存中。前两种类型还通过将更新操作的日志保存在本地硬盘和备份在远程机器来保持持久化。使用 log 允许我们简单可靠地更新 master 的状态，不用担心当 master crash 的时候的不一致性。Master 并没有永久保存 chunk 的位置信息，而是在 master 启动或者某个 chunkserver 加入集群时，它会向每个 chunkserver 询问它的 chunks 信息（动态询问保存）。</p><h3 id="In-Memory-Data-Structures"><a href="#In-Memory-Data-Structures" class="headerlink" title="In-Memory Data Structures"></a>In-Memory Data Structures</h3><p>由于元数据存储在内存里，master 的操作是很快的。因此对于 master 来说，可以简单有效地对在后台整个状态进行周期性扫描。这个周期性的扫描是用来实现 chunk 垃圾回收，chunkserver 出现失败时进行的重备份（re-replication），以及为了平衡负载和磁盘空间在 chunkserver 间的 chunk 迁移。4.3 4.4 将进一步讨论这些活动。</p><p>这样全内存策略存在一个潜在的限制就是 chunk 的数目，因此整个系统的容量取决于 master 有多少可用内存。实际中这不是一个很严重的限制。Master 为每个 64MB 的 chunk 维护少于 64byte 的数据。大部分的 chunk 是满的，因为大部分的文件包含多个 chunk，只有最后一个 chunk 可能是未慢的。类似的，每个文件名字空间数据通常需要少于 64byte 因为文件名称存储时会使用前缀压缩算法进行压缩。</p><p>如果需要支持更大的文件系统，只需要往 master 里添加内存。这点开销与通过将元数据存储到内存所得到简单性，可靠性，性能和灵活性，将是很小的一笔花费。</p><h3 id="Chunk-Loactions"><a href="#Chunk-Loactions" class="headerlink" title="Chunk Loactions"></a>Chunk Loactions</h3><p>Master 并没有提供一个永久性的存储保存对于一个给定的 chunk 都是那些 chunkserver 保存了它的副本。它只是在启动时，简单地从 chunkserver 那里把这些信息拉过来（见本小节开头）。Master 能够保证它自己是更新过的，因为是由它来控制 chunk 的放置，以及通过周期性的心跳信息来监控 chunkserver。</p><p>起初，我们尝试将 chunk 位置信息永久保存在 master，但是我们发现在启动时去 chunkserver 请求这些数据更简单。这样避免了当 chunkserver 在加入或者离开集群，改名，失败，重启等待时需要的 master 与 chunkserver 间的同步。在一个数百台机器的集群中，这样的事件太经常了。</p><p>理解这个设计决定的另一个方式是 chunkserver 对于自己有还是没有某个 chunk 具有最终的发言权。在 master 上维护一个这些信息一致性视图是没有意义的，因为发生在 chunkserver 上的错误可能使得一些 chunk 突然间不见了(比如硬盘可能会坏掉或者不可用)，一个操作可能将 chunkserver 重命名。</p><p>（读者注：server 具备自己有没有某个 chunck 的最终发言权，要联络，不要记忆。）</p><h3 id="Operation-Log"><a href="#Operation-Log" class="headerlink" title="Operation Log"></a>Operation Log</h3><p>操作日志包含了关键元数据改变的历史记录。它是 GFS 的核心。它不仅是元数据的唯一一致性记录，而且它也定义了那些并发操作的逻辑上的时间表。<strong>文件和 chunk 的版本都是唯一且永远地由它们创建时的逻辑时间来标识的</strong>。</p><p>因此操作日志是很关键的，我们必须可靠地保存它，在任何元数据变更在被持久化之前不应当被客户端看到。否则，即便 chunckserver 自己保存了它们，我们将丢失整个文件系统或者最近的客户端操作。因此我们将它备份在多个远程机器上，对于一个客户端操作只有当该操作对应的日志记录被刷新到本地和远程的磁盘上时才会发出响应。Master 将几个操作日志捆在一块刷新，从而降低刷新和复制对于整个系统吞吐率的影响。</p><p>Master 通过重新执行操作日志来恢复它的文件系统。为了最小化启动时间，我们必须将日志保持在很小的规模。当日志增长超过一定的大小后，Master 给它的状态设置检查点，它可以通过从本地磁盘加载最新的检查点进行恢复，然后重新执行那些在该检查点之后的日志记录。检查点保存了一个压缩的类 B 树的结构，不需要额外的解析就可以直接映射到内存用于名字空间查找。这大大提高了恢复的速度和可用性。</p><p>因为建立一个检查点会花费一些时间，master 的内部状态的结构设计使得一个新的检查点可以不需要延时那些接受到的变化就可以被创建。Master 会启动一个新的线程切换到一个新的日志文件然后创建新的检查点。这个新的检查点包含在切换之前的所有变更。对于一个包含几百万文件的集群大概需要几分钟就可以完成。结束后，它将会被写回本地和远程的磁盘。</p><p>恢复只需要最新完全的检查点和后来的日志文件。更老的检查点和日志文件可以自由的删除，当然我们会保存了一些来应对某些突发情况。在创建检查点的时候发生的失败不会影响系统的正确性，因为恢复代码会检测和跳过不完全的检查点。</p><h2 id="Consistency-Model"><a href="#Consistency-Model" class="headerlink" title="Consistency Model"></a>Consistency Model</h2><p>GFS 使用一个放宽的一致性模型不但很好的支持了我们的高度分布式的应用，而且实现起来也相对简单和有效率。我们现在讨论 GFS 所提供的保证以及它们对应用程序的意味着什么。我们也会讲述 GFS 如何维护这些保证，但是会将具体的细节留到其他论文里讲述。</p><h3 id="Guarantees-by-GFS"><a href="#Guarantees-by-GFS" class="headerlink" title="Guarantees by GFS"></a>Guarantees by GFS</h3><p>文件名字空间的改变(比如文件创建)是原子性的。它们只由 master 进行处理：名字空间锁来保证原子性和正确性(4.1 节)。Master 的操作日志定义了这些操作的全局性的排序。</p><p>当数据变更后，文件区域的状态取决于变更的类型，变更是否成功以及是否是并发进行的。表 1 是对结果的一个概述。</p><p><img src="https://eddyblog.oss-cn-shenzhen.aliyuncs.com/%E8%AE%BA%E6%96%87%E6%88%AA%E5%9B%BE/OS_4_2.png" srcset="/img/loading.gif" alt="OS_4_2"></p><p><strong>一致的（Consistent）：</strong>：所有的客户端无论从哪个副本读取数据总是看到相同的数据。</p><p><strong>定义良好的（defined）</strong>：一致的文件可以被客户端读取全部的变更。</p><p>操作影响：</p><ol><li>变更成功，且没有受到其他并发写者的影响，那么被影响的区域就是定义良好的（肯定是一致性的）。</li><li>并发的成功变更，影响区域是一致的，但不是定义良好的，客户端可能无法看到所有的更改。(<strong>如果变更是针对相同的数据写这样有的变更就会被新的变更所覆盖，这样用户就无法看到最先的变更了，同时发生在跨 chunk 的操作会被拆分成两个操作，这样这个操作的一部分可能会被其他操作覆盖，而另一部分则保留下来，如 3.1 节末尾所述</strong>)<br>，通常其看到的是多个变更组合以后的结果。</li><li>一个失败的变更，会使区域进入非一致的状态（因此也是未定义的状态）：不同的客户端在不同的访问中可能看到不同的数据。我们下面描述下我们的应用程序如何区分定义良好的区域和未定义的区域。应用程序不需要进一步区分未定义区域的各种不同的类型。</li></ol><p>数据变更可能是写或者记录 append。写操作会使数据在应用程序指定的偏移位置写入。记录 append 操作会使数据原子性的 append，<strong>如果是并发性的话则至少会被 append 一次</strong>，但是偏移位置是由 GFS 决定的(见 3.3 节，通常的理解可能是在客户端想写入的那个文件的尾部)。偏移位置会被返回给客户端，同时标记包含这条记录的那个定义良好的文件区域的起始位置。另外 GFS 可能会在它们之间插入一些 padding 或者记录的副本。它们会占据那些被认为是不一致的区域，通常它们比用户数据小的多。</p><p>在一系列成功的变更之后，变更的文件区域被保证是<strong>定义良好的</strong>的，同时包含了最后一次变更的数据写入。GFS 通过两种方式来实现：</p><ul><li>将这些变更以相同的操作顺序应用在该 chunk 的所有的副本上，</li><li>使用 chunk 的版本号来检测那些可能是由于它的 chunkserver 挂掉了而丢失了一些变更的陈旧副本。陈旧的副本永远都不会再参与变更或者返回给那些向 master 询问 chunk 位置的 client，它们会优先参与垃圾回收。</li></ul><p>因为客户端会缓存 chunk 的位置，在信息更新之前它们可能会读到陈旧的副本。时间窗口由缓存值的超时时间以及文件的下一次打开（这种文件的打开会清除该文件相关的所有 chunk information）而限制。由于我们的大多数文件是 append-only 的，因此一个陈旧副本通常会返回一个过早结束信号（premature）的 chunk 而不是过时（outdated）的数据。当读取者（由 client 担当）重试并与 master 联系时，它会立即得到当前的 chunk 位置（更新相关的信息）。</p><p>成功的变更很久之后，组件失败仍有可能破坏或者污染数据。GFS 通过进行周期性的 master 和所有 chunkserver 的握手找到那些失败的 chunkserver，同时通过校验和(5.2 节)来检测数据的污染。一旦发现问题，会尽快的利用正确的副本恢复(4.3 节)。只有一个块的所有副本在 GFS 做出反应之前，全部丢失，这个块才会不可逆转的丢失，而通常 GFS 的反应是在几分钟内的。即使在这种情况下，块不可用，而不是被污染：应用程序会收到清晰的错误信息而不是被污染的数据。</p><h3 id="Implications-for-Applications"><a href="#Implications-for-Applications" class="headerlink" title="Implications for Applications"></a>Implications for Applications</h3><p>GFS 应用程序可以通过使用简单的技术来适应这种放宽的一致性模型，这些技术已经为其他目的所需要：依赖于 append 操作而不是 overwrite，检查点保存，写入时自我验证，自我标识记录。</p><p>典型应用一：一个写操作者会从头至尾生成一个文件。当写完所有数据后它自动的将文件重命名为一个永久性的名称，或者通过周期性的检查点检查已经有多少数据被成功写入了。检查点可以通过校验和实现。</p><p>典型应用二：多个写者同时向一个文件 append，为了归并/生产者消费者队列，记录的 append 的 append-at-least-once 语义保证了每个写者的输出。读取者这样处理偶然的 padding 和重复数据。写者为每条记录准备一些额外信息比如校验和，这样它的合法性就可以验证。如果不能容忍重复的数据（比如他们可以触发非幂等的操作，幂等操作是指无论执行多少次结果都会改变、而非幂等是指结果会改变），可以通过在记录中使用唯一标识符来过滤它们，很多时候都需要这些标识符命名相应的应用程序实体，比如网页文档。这些用于 record 输入输出的功能函数是以库的形式被我们的应用程序共享的，同时应用于 gongle 其他的文件接口实现。所以，相同系列的记录，加上一些罕见的重复，总是直接被分发给记录读取者。</p><h1 id="System-Interactions"><a href="#System-Interactions" class="headerlink" title="System Interactions"></a>System Interactions</h1><p>我们是以尽量最小化 master 在所有操作中的参与度来设计系统的。在这个背景下，我们现在描述下 client，master 以及 chunkserver 如何交互来实现数据变更，原子性 append 记录以及快照的。</p><h2 id="Leases-and-Mutation-Order"><a href="#Leases-and-Mutation-Order" class="headerlink" title="Leases and Mutation Order"></a>Leases and Mutation Order</h2><p>每个变更在所有的副本上执行，我们使用租约（leases）来保持多个副本间变更顺序的一致性。Master 授权给其中的一个副本一个该 chunk 的租约，我们把它叫做主副本（primary）。这个主副本为针对该 chunk 的所有变更的选择一个执行顺序，然后所有的副本根据这个顺序执行变更。因此，全局的变更顺序首先是由 master 选择的租约授权顺序来确定的（可能有多个 chunk 需要进行修改），而同一个租约内的变更顺序则是由那个主副本（primary）来定义的。</p><p>租约机制是为了最小化 master 的管理开销而设计的。一个租约有一个初始化为 60s 的超时时间设置。然而只要这个 chunk 正在变更，那个主副本就可以向 master 请求延长租约。这些请求和授权通常是与 master 和 chunkserver 间的心跳信息（帮助 master 确定 chunkserver 的状态）一起发送的。有时候 master 可能想在租约过期前撤销它(比如，master 可能想使对一个正在重命名的文件的变更无效)。即使 master 无法与主副本进行通信，它也可以在旧的租约过期后安全的将租约授权给另一个新的副本。</p><p>如图 2，我们将用如下的数字标识的步骤来表示一个写操作的控制流程。</p><p><img src="https://eddyblog.oss-cn-shenzhen.aliyuncs.com/%E8%AE%BA%E6%96%87%E6%88%AA%E5%9B%BE/OS_4_3.png" srcset="/img/loading.gif" alt="OS_4_3.png"></p><ol><li><p>client 向 master 询问那个 chunkserver 获取了当前 chunk 的租约以及其他副本所在的位置。如果没有人得到租约，master 将租约授权给它选择的一个副本。</p></li><li><p>master 返回该主副本的标识符以及其他副本的位置。Client 为未来的变更缓存这个数据。只有当主副本没有响应或者租约到期（60s 或者 master revoke）时它才需要与 master 联系。</p></li><li><p>client 将数据推送给所有的副本，client 可以以任意的顺序（针对副本的顺序）进行推送。每个 chunkserver 会将数据存放在内部的 LRU buffer cache 里，直到数据被使用或者过期（缓冲流）。通过将控制流与数据流分离，我们可以通过将昂贵的数据流基于网络拓扑进行调度来提高性能，而不用考虑哪个 chunkserver 是主副本。3.2 节更深入地讨论了这点。</p></li><li><p>一旦所有的副本接受到了数据，client 发送一个写请求给主副本，这个请求标识了先前推送给所有副本的数据。主副本会给它收到的所有变更(可能来自多个 client)安排一个连续的序列号来进行必需的串行化。它将这些变更根据序列号应用在本地副本上。</p></li><li><p>主副本将写请求发送给所有的次副本，每个次副本以与主副本相同的串行化顺序应用这些变更。</p></li><li><p>所有的次副本完成操作后向主副本返回应答</p></li><li><p>主副本向 client 返回应答。任何副本碰到的错误都会返回给 client。出现错误时，该写操作可能已经在主副本以及一部分次副本上执行成功。(如果主副本失败，那么它不会安排一个序列号并且发送给其他人)。客户端请求将会被认为是失败的，被修改的区域将会处在非一致状态下。我们的客户端代码会通过重试变更来处理这样的错误。它会首先在 3 到 7 步骤间进行一些尝试后在重新从头重试这个写操作。</p></li></ol><p>如果应用程序的一个写操作很大或者跨越了 chunk 的边界，GFS client 代码会将它转化为多个写操作。它们都会遵循上面的控制流程，但是可能会被来自其他 client 的操作插入或者覆盖。因此共享的文件区域可能会包含来自不同 client 的片段，虽然这些副本是一致的，因为所有的操作都按照相同的顺序在所有副本上执行成功了。但是文件区域会处在一种一致但是未定义的状态，正如 2.7 节描述的那样（一致，但是由于并发 client 获取不到全部的操作信息，所以是未定义的）。</p><h2 id="Data-Flow"><a href="#Data-Flow" class="headerlink" title="Data Flow"></a>Data Flow</h2><p>为了更高效的使用网络，我们将数据流从控制流中分离出来。控制流从 client 到达主副本，然后到达其他的所有次副本，而数据则是线性地通过一个仔细选择的 chunkserver 链像流水线那样推送过去的。我们的目标是充分利用每个机器的网络带宽，避免网络瓶颈和高延时链路，最小化数据推送的延时。</p><p>为了充分利用每个机器的网络带宽，数据通过 chunkserver 链线性的推送过去而不是以其他的拓扑结构进行分布比如树型。因此每个机器的带宽可以全部用来发送数据而不是为多个接受者进行切分。</p><p>为了尽可能的避免网络瓶颈和高延时链路，每个机器向网络中还没有收到该数据的最近的那个机器推送数据。我们网络拓扑足够简单，以至于距离可以通过 IP 地址估计出来。</p><p>最后为了最小化延时，我们通过将 TCP 数据传输进行流水化。一旦一个 chunkserver 收到数据，它就开始立即往下发送数据。流水线对我们来说尤其有用，因为我们使用了一个全双工链路的交换网络。立即发送数据并不会降低数据接受速率。如果没有网络拥塞，向 $R$ 个副本传输 $B$ 字节的数据理想的时间耗费是 $B/T+RL$ ,$T$ 代表网络吞吐率，$L$ 是机器间的网络延时。我们的网络连接是 100Mbps($T$),$L$ 远远低于 1ms，因此 1MB 的数据理想情况下需要 80ms 就可以完成。</p><h2 id="Atomic-Record-Appends"><a href="#Atomic-Record-Appends" class="headerlink" title="Atomic Record Appends"></a>Atomic Record Appends</h2><p>GFS 提供一个原子性的 append 操作叫做 record append(注意这与传统的 append 操作也是不同的)。在传统的写操作中，用户指定数据需要写的便宜位置。对于相同区域的并行写操作是不可串行的：该区域的末尾可能包含来自多个 client 的数据片段。但在一个 record append 操作中，<strong>client 唯一需要说明的只有数据</strong>。GFS 会将它至少原子性地 append 到文件中一次，<strong>append 的位置是由 GFS 选定的</strong>，<strong>同时会将这个位置返回给 client</strong>。这很类似于 unix 文件打开模式中的 O_APPEND，当多个写者并发操作时不会产生竞争条件。</p><p>Record append 在我们的分布式应用中被大量的使用。很多在不同机器的 client 并发地向同一个文件 append。如果使用传统的写操作，client 将需要进行复杂而又昂贵的同步化操作，比如通过一个分布式锁管理器。在我们的工作负载中，这样的文件通常作为一个多生产者/单消费者队列或者用来保存来自多个不同 client 的归并结果。</p><p>Record append 是一种类型的变更操作，除了一点点在主副本上的额外逻辑，其余依然遵循 3.1 节的控制流。Client 将所有的数据推送给所有副本后（3.1 第 4 步），它向主副本发送请求。主副本检查将该记录 append 到该 chunk 是否会导致该 chunk 超过它的最大值(64MB)。如果超过了，它就将该 chunk 填充到最大值，告诉次副本（scondaries）也填充到最大值，然后告诉客户端该操作应该在下一个 chunk 上重试。(append 的 Record 大小需要控制在最大 trunk 大小的四分之一以内，这样可以保证最坏情况下的碎片可以保持在一个可以接受的水平上 )。如果记录可以没有超过最大尺寸，就按照普通情况处理，主副本将数据 append 到它的副本上，告诉次副本将数据写在相同的偏移位置上，最后向 client 返回成功应答。</p><p>如果 record append 在任何一个副本上失败，client 就会重试这个操作。这样，相同 chunk 的多个副本就可能包含不同的数据，这些数据可能包含了相同记录的整个或者部分的重复值。GFS 并不保证所有的副本在位级别上的一致性，它只保证数据作为一个原子单元最少写入一次。这个属性是由如下的简单观察推导出来的，当操作报告成功时，数据肯定被写入到某个 trunk 的所有副本的相同偏移位置上。此后，所有的副本至少达到了记录尾部的大小，因此未来的记录将会被放置在更高的便宜位置，或者是另一个不同的 chunk，即使另一个副本变成了主副本。在我们的一致性保证里，record append 操作成功后写下的数据区域是已定义的(肯定是一致的)，然而介于其间的数据则是不一致的(因此也是未定义的)。我们的应用程序可以处理这样的不一致区域，正如我们在 2.7.2 里讨论的那样（对于少见的重复/应用应为记录添加一些额外的信息来保证其合法性，不能容忍的幂等操作，可以通过使用唯一标识符过滤）。</p><h2 id="Snapshot"><a href="#Snapshot" class="headerlink" title="Snapshot"></a>Snapshot</h2><p>快照操作可以非常快速的保存文件或者目录树的一个拷贝，同时可以最小化对于正在执行的变更操作的中断。用户经常用它来创建大数据集的分支拷贝，以及拷贝的拷贝。或者用来创建检查点，以实验接下来的提交或者回滚。</p><p>像 AFS，我们使用标准的 copy-on-write 技术来实现快照。当 master 收到一个快照请求时，它首先撤销将要进行快照的那些文件对应的 chunk 的所有已发出的租约。这就使得对于这些 chunk 的后续写操作需要与 master 交互来得到租约持有者。这就首先给 master 一个机会创建该 chunk 的新的拷贝（强迫与 master 交互以使新的租约生成）。</p><p>当这些租约被撤销或者过期后，master 将这些操作以日志形式写入磁盘。然后复制该文件或者目录树的元数据，然后将这些日志记录应用到内存中的复制后的状态上，新创建的快照文件与源文件一样指向相同的 chunk。</p><p>当 client 在快照生效后第一次对一个 chunk C 进行写入时，它会发送请求给 master 找到当前租约拥有者。Master 注意到对于 chunk C 的引用计数大于 1。它延迟回复客户端的请求，选择一个新的 chunk handle C’然后让每个拥有 C 的那些 chunkserver 创建一个新的叫做 C’的 chunk。通过在相同的 chunkserver 上根据原始的 chunk 创建新 chunk，就保证了数据拷贝是本地地，而不是通过网络(我们的硬盘比 100Mbps 网络快大概三倍)。这样，对于任何 chunk 的请求处理都没有什么不同：master 为新才 chunk C’的副本中的一个授权租约，然后返回给 client，这样它就可以正常的写这个 chunk 了，client 不需要知道该 chunk 实际上是从一个现有的 chunk 创建出来的。</p><h1 id="Master-Operation"><a href="#Master-Operation" class="headerlink" title="Master Operation"></a>Master Operation</h1><p>Master 执行所有的名字空间操作。此外，它还管理整个系统的 chunk replicas：决定如何放置，创建新的 chunk 和相应的副本，协调整个系统范围内的活动保证 chunk 都是完整备份的，在 chunkserver 间进行负载平衡，回收没有使用的存储空间。我们现在讨论这些主题。</p><h2 id="Namespace-Management-and-Locking"><a href="#Namespace-Management-and-Locking" class="headerlink" title="Namespace Management and Locking"></a>Namespace Management and Locking</h2><p>很多 master 操作都需要花费很长时间：比如，一个快照操作要撤销该快照所包含的 chunk 的所有租约。我们并不想耽误其他运行中的 master 操作，因此我们允许多个操作同时是活动的，通过在名字空间区域使用锁来保证正确的串行化。</p><p>不像传统的文件系统，GFS 的目录并没有一种数据结构用来列出该目录下所有文件，而且也不支持文件或者目录别名（像 unix 的硬链接或者软连接那样）。GFS 在逻辑上将命名空间作为一个通过路径全称到元数据映射的查找表。通过采用前缀压缩，这个表可以有效地在内存中表示。名字空间树中的每个节点（要么是文件的绝对路径名称要么是目录的）具有一个相关联的读写锁。</p><p>每个 master 操作在它运行前，需要获得一个锁的集合。比如如果它想操作/d1/d2…/dn/leaf，那么它需要获得/d1,/d1/d2……/d1/d2…/dn 这些目录的读锁，然后才能得到路径/d1/d2…/dn/leaf 的读锁或者写锁。Leaf 可能是个文件或者目录，这取决于具体的操作。</p><p>我们现在解释一下，当为/home/user 创建快照/save/user 时，锁机制如何防止文件/home/user/foo 被创建。快照操作需要获得在/home /save 上的读锁，以及/home/user 和/save/user 上的写锁。文件创建需要获得在/home 和/home/user 上的读锁，以及在/home/user/foo 上的写锁。这两个操作将会被正确的串行化，因为它们试图获取在/home/user 上的相冲突的锁。文件创建并不需要父目录的写锁，因为实际上这里并没有”目录”或者说是类似于 inode 的数据结构，需要防止被修改。读锁已经足够用来防止父目录被删除。</p><p>（这种加锁机制的好处是对于同一个目录下，可以并行的操作文件，例如，同一个目录下并行的创建文件。快照会对新旧本层进行写加锁因而防止了对原始文件目录增加文件的操作产生的冲突。）</p><p>因为名字空间有很多节点，所以读写锁对象只有在需要时才会被分配，一旦不再使用用就删除。为了避免死锁，锁是按照一个一致的全序关系进行获取的：首先根据所处的名字空间树的级别，相同级别的则根据字典序。</p><h2 id="Replica-Placement"><a href="#Replica-Placement" class="headerlink" title="Replica Placement"></a>Replica Placement</h2><p>如何安置 replicas 的目标是：</p><ul><li>最大化数据可靠性和可用性</li><li>最大化网络带宽的利用</li></ul><p><strong>这里的最大化不仅仅是机器间的问题</strong>，还要考虑机架间的问题</p><p>在以下 3 种情况下，Master 会进行创建 replicas 的操作：</p><ul><li>创建了新的 chunk</li><li>需要重新备份</li><li>负载均衡</li></ul><p>如何选择将 replicas 放置到哪台机器上呢？</p><ul><li>优先选择磁盘利用率低的 chunkserver，使得较长时间将会平均化 chunkserver 的利用。</li><li>GFS 会限制每个 chunkserver『最近』创建的次数。换句话说，如果一个 chunkserver 近期创建 replicas 的操作比较频繁，就不会优先选择它（因为创建就意味着以后会进行读取，为了防止突然间大量的读取出现在同一台机器上）</li><li>保证可用性，尽可能跨机架（racks）进行创建操作</li></ul><p>当可用的备份低于要求时（GFS 要求为 3 份），master 会对 chunk 进行重新备份，在以下情况有可能需要重新备份：</p><ul><li>chunkserver 不可用了</li><li>备份损坏了</li><li>硬盘挂掉了</li><li>所要求的最低备份数量提高了</li></ul><p>当有多个 chunk 需要备份时，GFS 如何决定先备份哪个呢？策略如下：</p><ul><li>优先选择可用备份少的（仅有一份备份的更加迫切）</li><li>优先备份最近没有 delete 文件的（for live files）</li><li>优先备份阻塞了 client 操作的（这样可以最小化对运行中应用的影响）</li></ul><p>当 master 决定了备份哪个之后，会把当前可用的 chunk 直接克隆到目标位置（遵循 replicas 放置的类似规则：平均磁盘利用率、防止单一机器高 IO、跨机架）。</p><p>周期性的检查副本分布以求重平衡，副本的移动过程中是新建一个新的，放置规则和前述讨论一致。放置了新的必须删除旧的（通常情况下倾向删除自身空白空间低于平均水平的）。</p><h2 id="Garbage-Collection"><a href="#Garbage-Collection" class="headerlink" title="Garbage Collection"></a>Garbage Collection</h2><p>文件删除后，GFS 并不立即释放可用的物理存储（进行物理删除，而是等对应的垃圾清理进行到文件和 chunk 级别时再真正删除（Lazy）。</p><h3 id="Mechanism"><a href="#Mechanism" class="headerlink" title="Mechanism"></a>Mechanism</h3><p>具体地，对于一个文件的删除操作，GFS 仅仅是写一条日志记录，然后把文件命名成一个对外部不可见的名称，这个名称会包含删除的时间戳。GFS master 会定期的扫描，当这些文件存在超过 3 天（可设定）后，这些文件会从 namespace 中删掉，并且内存的中 metadata 会被删除，切断了和 chunk 的联系。</p><p>在对 chunk namespace 的定期扫描时，master 找到那些孤儿块(无法从任何文件到达)，擦除这些块的元数据。在与 chunkserver 的 heartbeat 的交互过程中，GFS master 会把不在 metadata 中的 chunk 告诉 chunkserver，然后 chunkserver 对照后就可以删除这些 chunk 了。</p><h2 id="Discussion"><a href="#Discussion" class="headerlink" title="Discussion"></a>Discussion</h2><p>master 在内存中储存那个查找表（前缀压缩过的），保存了所有文件-chunck 映射，因而很容易找到 chunck 的引用。chunck 只不过是放在特定目录下的 linux 文件，master 不知道的副本就是 garbage。</p><p>采用这种方式删除的好处：</p><ol><li>利用心跳方式交互，在一次删除失败后，还可以通过下次心跳继续重试操作</li><li>删除操作和其他的全局扫描 metadata 的操作可以放到一起做<br>为删除这种不可逆转操作提供了一定弹性恢复的保护网。<br>坏处：</li></ol><p>有可能有的应用需要频繁的创建和删除文件，这种延期删除方式会导致磁盘使用率偏高，GFS 提供的解决方案是，对一个文件调用删除操作两次，GFS 会马上做物理删除操作，释放空间。同时允许用户在不同名字空间内使用不同的重备份和回收策略（不执行副本和直接物理删除）</p>]]></content>
    
    
    <categories>
      
      <category>Computer Science</category>
      
      <category>分布式系统</category>
      
    </categories>
    
    
    <tags>
      
      <tag>Paper</tag>
      
      <tag>分布式系统</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>分布式系统学习——MapReduce方法Paper翻译</title>
    <link href="/post/cbabc18d.html"/>
    <url>/post/cbabc18d.html</url>
    
    <content type="html"><![CDATA[<h1 id="读书笔记——MapReduce-Simplified-Data-Processing-on-Large-Clusters"><a href="#读书笔记——MapReduce-Simplified-Data-Processing-on-Large-Clusters" class="headerlink" title="读书笔记——MapReduce: Simplified Data Processing on Large Clusters"></a>读书笔记——MapReduce: Simplified Data Processing on Large Clusters</h1><p>大型集群上的简化处理：MapReduce（两个主要操作）</p><p><a href="https://www.cnblogs.com/YaoDD/p/6017397.html" target="_blank" rel="noopener">原始翻译版本网址：《MapReduce: Simplified Data Processing on Large Cluster 》翻译</a></p><h2 id="Abstract"><a href="#Abstract" class="headerlink" title="Abstract"></a>Abstract</h2><p>MapReduce 是一种编程模型和一种用来处理和产生大数据集的相关实现。用户定义 map 函数（map function）来处理 key/value 键值对来产生一系列的中间的 key/value 键值对。还要定义一个 reduce 函数(reduce function)用来合并有着相同中间 key 值的中间 value。许多现实世界中的任务都可以用这种模型来表达，就像下文所展示的那样。</p><p>用这个风格（函数式）编写的程序可以自动并行地在大规模集群上工作。运行时系统会自动处理例如切割输入数据，在机器之间调度程序的执行，处理机器故障以及管理必要的机器间通信等细节问题。这可以让那些对于并行分布式系统<strong>没有任何经验</strong>的程序员也能<strong>很简单</strong>地利用起一个大的分布式系统的资源。</p><p>我们的 MapReduce 的实现运行在一个由大的商业机构成的集群当中并且是高度可扩展的：一个典型的 MapReduce 计算要在上千台机器中处理 TB 数量级的数据。程序员会觉得这个系统非常好用：已经有成千上万的 MapReduce 程序被实现出来并且每天有上千个 MapReduce 任务运行在 Google 的集群上。</p><h2 id="Introduction"><a href="#Introduction" class="headerlink" title="Introduction"></a>Introduction</h2><p>在过去五年中，作者和许多 Google 的其他人已经实现了成百上千个用于特殊目的的计算程序用于处理大量的 raw data（如抓取文件，Web 请求日志等），用于计算产生各种各样的 derived data（如倒排索引、Web 文件结构的图片展示、每个 host 抓取的文件数量总结、指定日期最频繁的访问请求等）。许多这种计算程序在概念上都是非常直接的。然而输入的数据量往往很大，并且计算需要分布在成百上千台机器中为了在一个可接受的时间内完成任务。但是除了简单的计算模型以外，我们需要大量复杂的代码用来处理例如如何并行化计算、分发数据、处理故障等等问题。</p><p>为了解决这样的复杂性，我们设计了一种新的抽象，它让我们只需要表示出我们想要执行的计算模型，而将背后复杂的并行化，容错，数据分发，负载平衡等等技术的实现细节隐藏在了库中。我们这种新的抽象是受 Lisp 以及其他一些函数式编程语言中的 map 和 reduce 原语影响而来的。我们意识到为了计算出一系列的中间键值对，许多的计算都需要对于输入中的每个逻辑“记录”进行 map 操作。然后还需要对所有共享同一个 key 的 value 进行 reduce 操作，从而能够对派生的数据进行适当的组合。我们这种让用户自定义 map 和 reduce 操作的编程模型能够让我们简单地对大量数据实现并行化，并且使用重新执行（re-execution）作为主要的容错机制。</p><p>我们这项工作的主要共享是提供了一个简单并且强大的接口能够让我们实现自动的并行化并且分布处理大规模的计算，同时该接口的实现能在大型的商用 PC 集群上获得非常高的性能。</p><p>Section 2 描述了基本的编程模型以及一些简单的例子。Section 3 描述了为我们的基于集群的计算环境量身定做的 MapReduce 接口。Section 4 描述了一些我们认为有用的对于编程模型的改进。Section 5 是对我们的实现在不同任务下的性能测试。Section 6 包含了 MapReduce 在 Google 内的使用情况，包括我们以它为基础重写我们的产品索引系统的经验。Section 7 讨论了相关的工作以及未来的发展。</p><a id="more"></a><h2 id="Programming-Model"><a href="#Programming-Model" class="headerlink" title="Programming Model"></a>Programming Model</h2><p>计算模型以一系列的键值对作为输入并产生一系列的键值对作为输出。MapReduce 库的用户以“Map”和”Reduce”两个函数来表达计算。</p><p><strong>Map</strong>，是由用户编写的，取一个输入对，并且产生一系列中间的键值对。MapReduce 库将那些具有相同的中间键$I$的中间值聚集在一起，然后将它们传递给 Reduce 函数。</p><p><strong>Reduce</strong>，同样是由用户编写的，接收一个中间键$I$和该键对应的一系列的中间值。Reduce 函数通过将这些值合并来组成一个可能更小的集合（值的集合）。通常每个 Reduce 函数只产生 0 个或 1 个输出值。Reduce 函数一般通过一个迭代器（via an iterator）来获取中间值，从而在中间值的数目远远大于内存容量时，我们也能够处理。</p><h3 id="Example"><a href="#Example" class="headerlink" title="Example"></a>Example</h3><p>下面来考虑这样一个问题：统计大量文档中每一个单词出现的次数。对此，用户需要编写类似于如下的伪代码：</p><pre><code class="hljs python">　　map(String key, String value):　　　　// key: document name　　　　// value: document contents　　　　<span class="hljs-keyword">for</span> each word w <span class="hljs-keyword">in</span> value:　　　　　　EmitIntermediate(w, <span class="hljs-string">"1"</span>);　　reduce(String key, Iterator values):　　　　// key: a word　　　　// values: a list of counts　　　　int result = <span class="hljs-number">0</span>;　　　　<span class="hljs-keyword">for</span> each v <span class="hljs-keyword">in</span> values:　　　　　　result += ParseInt(v);　　　　Emit(AsString(result));</code></pre><p>Map 函数为在每一个单词出现的时候，为它加上一个计数（在这个简单的例子中就是加 1）。Reduce 函数对每个单词（作为中间键值对的键）的所有计数进行叠加。</p><p>另外，用户需要用输入输出文件的名字，以及一个可选的 tuning paramete 去 fill in 一个叫 mapreduce specification 的对象。之后，用户调用 MapReduce 函数，将上述定义的对象传递进去。用户的代码将和 MapReduce 库相连（由 C++实现）。Appendix A 中有这个例子所有的代码文档。</p><pre><code class="hljs python">map     (k1,v1)  -&gt;  list(k2,v2)reduce  (k2,list(v2)) -&gt; list(v2)</code></pre><p>需要注意的是，输入的 key 和 value 与输出的 key 和 value 是不同的类型，而中间的 key 和 value 与输出的 key 和 value 是相同的类型（用 k1 和 k2 表示）。我们的 C++实现都是以字符串的形式和用户代码进行交互的，至于将字符串类型转换成相应合适的类型的工作则由用户代码来完成了。</p><h3 id="More-Example"><a href="#More-Example" class="headerlink" title="More Example"></a>More Example</h3><p>接下来是一些能够简单地用 MapReduce 计算模型进行表达的例子</p><p>Distributed Grep（分布式查找）：Map 函数获取匹配提供的模式的行，Reduce 函数只是简单地将这些中间数据拷贝到输出。</p><p>Count of URL Access Frequency（计算 URL 访问频率）：Map 函数处理 web 请求的日志，并且输出<url, 1="">。Reduce 函数将拥有相同 URL 的 value 相加，得到<url, total="" count="">对</url,></url,></p><p>Reverse Web-Link Graph：Map 函数输出<target, source="">对，其中 source 所在的 page 都有连向 target 这个 URL 的链接。Reduce 函数将给定 target 的所有的 source URL 连接起来，输出<target, list(source)="">对</target,></target,></p><p>Term-Vector per Host：一个 term vector 表示一系列<word, frequency="">的键值对，word 表示一篇或者一系列文章中出现的比较重要的单词，frequency 表示它们出现的次数。Map 函数对于每篇输入的文章输出<hostname, term="" vector="">键值对（其中 hostname 是从文章所在的 URL 中抽取出来的）Reduce 函数获取给定 host 的 term vectors。它将这些 term vectors 累加起来，丢弃非频繁出现的 term，并产生一个最终的<hostname, term="" vector="">对。</hostname,></hostname,></word,></p><p>Inverted Index：Map 函数对每篇文章进行处理，并输出一系列的<word, document="" id="">对。Reduce 函数接收给定 word 的所有键值对，对相应的 document ID 进行排序并且输出<word, list<document="" id="">&gt;对。所有输出对的集合构成了一个简单的倒排索引。用了 MapReduce 模型，对单词位置的追踪就变得非常简单了。</word,></word,></p><p>Distributed Sort：Map 函数从每个 record 中抽取出 key，产生<key, record="">键值对。Reduce 函数只是简单地将所有对输出。这个计算模型依赖于 Section 4.1 中描述的划分技巧以及 Section 4.2 中描述的排序特性。</key,></p><p>（上述可以全部理解了）</p><h2 id="Implementation"><a href="#Implementation" class="headerlink" title="Implementation"></a>Implementation</h2><p>对于 MapReduce 的接口，各种各样不同的实现都是可能的。所有正确的选择都是基于当下环境的。比如，一种实现可能适合于小的共享内存的机器，另一种可能适合于大型的 NUMA 多处理器机器，甚至有的是为更大的互联的机器集群设计的。</p><p>本节中描述的实现基于的是 Google 中最常用的计算环境：一个由大量商用 PC 机通过交换以太网互联的集群。在我们的环境中：</p><ol><li><p>机器通常都是 x86 的双核处理器，其上运行 Linux，每台机器拥有 2-4G 的内存</p></li><li><p>商用网络硬件—-通常是 100 M/s 或者 1 G/s，但是综合起来要小于平均带宽</p></li><li><p>一个集群由成千上万台机器组成，因此机器故障是常有的事</p></li><li><p>存储由便宜的 IDE 磁盘提供，它们都与独立的机器直接相连。一个内部研发的文件系统用于管理所有存储于这些硬盘上的文件。该文件系统通过 Replication 在不可靠的硬件上提供了可用性和可靠性</p></li><li><p>用户提交 jobs 给调度系统。每个 job 由一系列的 task 组成，并且由调度器分配到集群中一系列可用的机器上</p></li></ol><h3 id="Execution-Overview"><a href="#Execution-Overview" class="headerlink" title="Execution Overview"></a>Execution Overview</h3><p>通过将输入数据自动分割成 M 份，Map 函数得以在多台机器上分布式执行。每一个输入块都能并行地在不同的机器上执行。通过划分函数(例如，hash(key) mod R)将中间键划分为 R 份，Reduce 函数也能被分布式地调用。其中划分的数目 R 和划分函数都是由用户指定的。</p><p><img src="https://eddyblog.oss-cn-shenzhen.aliyuncs.com/%E8%AE%BA%E6%96%87%E6%88%AA%E5%9B%BE/OS_3_1.png" srcset="/img/loading.gif" alt="OS_3_1"></p><p>上图 1 展示了在我们的实现中 MapReduce 全部的流程。当用户程序调用 MapReduce 函数时，接下来的动作将按序发生（图 1 中标记的数字与下面的数字是一一对应的）：</p><ol><li><p>用户程序中的 MapReduce 库首先将输入文件划分为$M$片，每片大小一般在 16MB 到 64MB 之间（由用户通过一个可选的参数指定）。之后，它在集群的很多台机器上都启动了相同的程序拷贝。</p></li><li><p>其中有一个拷贝程序是特别的——master。剩下的都是 worker，它们接收 master 分配的任务。其中有 M 个 Map 任务和 R 个 Reduce 任务要分配。master 挑选一个空闲的 worker 并且给它分配一个 map 任务或者 reduce 任务。</p></li><li><p>被分配到 Map 任务的 worker 会去读取相应的输入块的内容。它从输入文件中解析出键值对并且将每个键值对传送给用户定义的 Map 函数。而由 Map 函数产生的中间键值对缓存在内存中。</p></li><li><p>被缓存的键值对会阶段性地写回本地磁盘，并且被划分函数分割成 R 份。这些缓存对在磁盘上的位置会被回传给 master，master 再负责将这些位置转发给 Reduce worker。</p></li><li><p>当 Reduce worker 从 master 那里接收到这些位置信息时，它会使用远程过程调用从 Map worker 的本地磁盘中获取缓存的数据。当 Reduce worker 读入全部的中间数据之后，它会根据中间键对它们进行排序，这样所有具有相同键的键值对就都聚集在一起了。排序是必须的，因为会有许多不同的键被映射到同一个 reduce task 中。如果中间数据的数量太大，以至于不能够装入内存的话，还需要另外的排序。</p></li><li><p>Reduce worker 遍历已经排完序的中间数据。每当遇到一个新的中间键，它会将 key 和相应的中间值传递给用户定义的 Reduce 函数。Reduce 函数的输出会被添加到这个 Reduce 部分的输出文件中。</p></li><li><p>当所有的 Map tasks 和 Reduce tasks 都已经完成的时候，master 将唤醒用户程序。到此为止，用户代码中的 MapReduce 调用返回。</p></li></ol><p>当成功执行完之后，MapReduce 的执行结果被存放在 R 个输出文件中（每个 Reduce task 对应一个，文件名由用户指定）。通常用户并不需要将 R 个输出文件归并成一个。因为它们通常将这些文件作为另一个 MapReduce 调用的输入，或者将它们用于另外一个能够以多个文件作为输入的分布式应用。</p><p>（个人理解：module R 将中间键值对分为 R 份一方面是为了执行 Reduce work 的处理器进行分布式并行计算，另一方面，产生的分布式数据也可以接着用于其他能以多文件为输入的分布式应用。）</p><h3 id="Master-Data-Structures"><a href="#Master-Data-Structures" class="headerlink" title="Master Data Structures"></a>Master Data Structures</h3><p>在 master 中保存了许多的数据结构。对于每个 Map task 和 Reduce task，master 都保存了它们的状态（idle，in-progress 或者是 completed）以及 worker 所在机器的标识（对于非 idle 空转状态的 tasks 而言）。</p><p>master 相当于是一个管道，通过它 Map task 所产生的中间文件被传递给了 Reduce task。因此，对于每一个已经完成的 Map task，master 会存储由它产生的 R 个中间文件的位置和大小（分配给 R 个 Reduce task 执行，需要远程读取这些数据，所以要记录位置和大小）。当 Map task 完成的时候，master 就会收到位置和大小的更新信息。而这些信息接下来就会逐渐被推送到处于 in-progress 状态的 Reduce task 中。</p><h3 id="Fault-Tolerance"><a href="#Fault-Tolerance" class="headerlink" title="Fault Tolerance"></a>Fault Tolerance</h3><p>容错处理</p><p>因为 MapReduce 库的设计初衷是用成千上万的机器去处理大量的数据，所以它就必须能用优雅的方式对机器故障进行处理。</p><h4 id="Worker-Failure"><a href="#Worker-Failure" class="headerlink" title="Worker Failure"></a>Worker Failure</h4><p>master 会周期性地 ping 每一个 worker。如果经过了一个特定的时间还未从某一个 worker 上获得响应，那么 master 会将 worker 标记为 failed。所有由该 worker 完成的 Map task 都被回退为 idle 状态，因此能够被重新调度到其他的 worker 上。同样的，所有 failed worker 正在执行的 Map task 或者 Reduce task 也会被回退为 idle 状态，并且被重新调度。</p><p><strong>发生故障的机器上已经完成的 Map task 需要重新执行的原因是，它们的输入是保存在本地磁盘的，因此发生故障之后就不能获取了。而已经完成的 Reduce task 并不需要被重新执行，因为它们的输出是存放在全局的文件系统中的。</strong></p><p>当一个 Map task 开始由 worker A 执行，后来又由 worker B 执行（因为 A 故障了）。所有执行 Reduce task 的 worker 都会收到这个重新执行的通知。那些还未从 worker A 中读取数据的 Reduce task 将会从 worker B 中读取数据。</p><p>MapReduce 对于大面积的机器故障是非常具有弹性的。例如，在一次 MapReduce 操作中，网络维护造成了集群中八十台机器在几分钟的时间内处于不可达的状态。MapReduce 的 master 只是简单地将不可达的 worker 机器上的工作重新执行了一遍，接着再继续往下执行，最终完成了 MapReduce 的操作。</p><h4 id="Master-Failure"><a href="#Master-Failure" class="headerlink" title="Master Failure"></a>Master Failure</h4><p>对于 master，我们可以简单地对上文所述的 master 数据结构做周期性的快照。如果一个 master task 死了，我们可以很快地根据最新的快照来重新启动一个 master task。但是，因为我们只有一个 master，因此故障的概率比较低。所以，在我们的实现中如果 master 出现了故障就只是简单地停止 MapReduce 操作。用户可以检测到这种情况，并且如果他们需要的话可以重新开始一次 MapReduce 操作。</p><h4 id="Semantics-in-the-Presence-of-Failures"><a href="#Semantics-in-the-Presence-of-Failures" class="headerlink" title="Semantics in the Presence of Failures"></a>Semantics in the Presence of Failures</h4><p>如果用户提供的 Map 和 Reduce 操作是关于输入值的确定性函数，那么我们分布式的实现将会产生同样的输出，在整个程序经过没有出现故障的顺序执行之后。</p><p>我们依赖 Map task 和 Reduce task 原子性地提交输出来实现上述特性。每一个正在执行的 task 都会将它的输出写到一个私有的临时文件中。一个 Reduce task 产生一个这样的文件，而一个 Map task 产生 R 个这样的文件（每个 Reduce work 一个）。当一个 Map task 完成的时候，worker 就会给 master 发送一个信息，，其中包含了 R 个临时文件的名字。如果 master 收到了一个来自于已经完成了的 Map task 的完成信息，那么它就将它自动忽略。否则，将 R 个文件的名称记录到一个 master 数据结构中。</p><p>当一个 Reduce task 完成的时候，Reduce worker 会自动将临时输出文件命名为最终输出文件。如果同一个 Reduce task 在多台机器上运行，那么多个重命名操作产生的最终输出文件名将会产生冲突。对此，我们依赖底层文件系统提供的原子重命名操作来保证最终文件系统中的数据来自一个 Reduce task。</p><p>大多数的 Map 和 Reduce 操作都是确定性的，事实上，我们的语义等同于顺序执行。因此这让程序员非常容易地能够解释他们程序的行为。当 Map 和 Reduce 操作是非确定性的时候，我们提供较弱，但仍然合理的语义。在非确定性的操作中，对于一个特定的 Reduce task R1 的输出是对应非确定性程序顺序执行产生的一个结果。然而，对于另一个 Reduce task R2，它的输出对应于非确定性程序另一个顺序执行的结果。</p><p>下面考虑 Map task $M$和 Reduce task $R_1$和$R_2$。让$e(R_i)$表示$R_i$的执行结果。更弱的语义意味着，$e(R_1)$可能从 M 的一次执行结果中读取输入，而$e(R_2)$可能从 M 的另一次执行中读取输入。</p><h3 id="Locality"><a href="#Locality" class="headerlink" title="Locality"></a>Locality</h3><p>网络带宽在我们的计算环境中是相对稀缺的资源。我们通过将输入数据（由 GFS 管理）存储在集群中每台机器的本地磁盘的方法来节省带宽。GFS 将输入文件切分成 64MB 大小的块，并且将每个块的多份拷贝（通常为 3 份）存储在不同的机器上。MapReduce 的 master 获取所有输入文件的位置信息，然后将 Map task 调度到有相应输入文件副本的机器上。当发生故障时，再将 Map task 调度到邻近的具有该 task 输入文件副本的机器（即在同一台交换机内具有相同数据的机器）。当在一个集群的大量机器上做 MapReduce 操作时，大多数的输入数据都是从本地读取的，而不用消耗带宽。</p><h3 id="Task-Granularity"><a href="#Task-Granularity" class="headerlink" title="Task Granularity"></a>Task Granularity</h3><p>如上所述，我们将 Map 操作分成 M 份，Reduce 操作分成 R 份。在理想的情况下，M 和 R 的值应该要比集群中 worker machine 的数量多得多。让一个 worker 同时进行许多不同的 task 有利于提高动态的负载均衡，同时在一个 worker 故障的时候能尽快恢复。许多已经完成的 Map task 也能尽快地传播到其他所有的 worker machine 上。</p><p>在我们的实现中，M 和 R 的大小是有一个实用范围的。因为我们的 master 需要做$O(M+R)$个调度决定，并且还要在内存中保存$O(M<em>R)$个状态（源自前面所说：<strong>对于每一个已经完成的 Map task，master 会存储由它产生的 R 个中间文件的位置和大小。</strong>）。（但是内存使用的常数还是比较小的，$O(M</em>R)$个 Map task/Reduce task 状态对，每个的大小大概在一个字节）</p><p>另外，$R$通常受限于用户，因为每个 Reduce task 的输出都分散在不同的输出文件中。事实上，我们会选择$M$，使得每个输入文件大概 16MB 到 64MB 的输入文件（因此上文所述的局部性优化会达到最优，减少带宽负担，尽量利用本地存储数据进行 Map task）。而我们会让 R 成为 worker machine 数量的一个较小的倍数。因此，我们通常在进行 MapReduce 操作时，$M=200000$，$R=5000$，使用 2000 个 worker machine。</p><h3 id="Backup-Tasks"><a href="#Backup-Tasks" class="headerlink" title="Backup Tasks"></a>Backup Tasks</h3><p>“straggler”（落伍的士兵）的存在是拖慢整个 MapReduce 操作的通常的原因之一。所谓的”straggler”是指一台机器用了过长的时间去完成整个计算任务中最后几个 Map task 或者 Reduce task。Straggler 出现的原因有很多。比如一台机器上硬盘坏了，它就会经历大量的可纠正错误，从而让它的性能从 30MB/s 下降到 1MB/s。集群的调度系统可能将其他 task 调度到该机器上，导致它执行 MapReduce 代码的速度变慢很多，因为 CPU，内存，本地磁盘，网络带宽的竞争加剧。我们最近遇到的一个问题是一台机器的初始化代码有点问题，它会导致处理器的缓存被禁用，在这些受影响的机器上进行的计算速度会下降到原来的百分之一。（ping 得到不判定为故障机，但是自身速度过慢会拖累整体，出现短板效应）</p><p>对此，我们有一个通用的机制用来缓解 straggler 的问题。当 MapReduce 操作接近结束的时候，master 会将那些仍在执行的 task 的备份进行调度执行。无论是原来的还是备份执行完成，该 task 都将被标记为已完成。我们通过调整将该操作导致的计算资源消耗仅仅提高了几个百分点（只在即将结束的时候进行备份竞争执行）。但是在完成大型的 MapReduce 操作时，却让整个执行时间下降了好多。例如，Section 5.3 中所描述的排序算法在备份机制关闭的情况下，需要多消耗 44%的时间。</p><h2 id="Refinements"><a href="#Refinements" class="headerlink" title="Refinements"></a>Refinements</h2><p>虽然对于大多数需求由 Map 和 Reduce 函数提供的功能已经足够了，但是我们还是发现了一些有用的扩展。对它们的描述如下。</p><h3 id="Partitioning-Function"><a href="#Partitioning-Function" class="headerlink" title="Partitioning Function"></a>Partitioning Function</h3><p>MapReduce 用户决定他们的 Reduce task 或者输出文件的数目 R。通过一个划分函数，根据中间键值将各个 task 的数据进行划分。默认的划分函数是通过哈希（比如，hash(key) mod R）。这通常会产生非常好的较为均衡的划分。但是在其他一些情况下，通过键值的其他函数来划分要更好一些。例如，有的时候输出键值是一些 URL，我们希望同一个 host 的内容能放在同一个输出文件中。为了支持这种情况，MapReduce 库的用户可以提供一个特殊的划分函数。例如，使用“hash(Hostname(urlKey)) mod R”作为划分函数，从而让所有来自于同一个 host 的 URL 的内容都输出到同一个输出文件。</p><p>（个人理解，hash 之前可以根据需求（key 的相似性、urlhost 相同）对 key 提前进行一次分组）</p><h3 id="Ordering-Guarantees"><a href="#Ordering-Guarantees" class="headerlink" title="Ordering Guarantees"></a>Ordering Guarantees</h3><p>我们确保在一个给定的划分中，中间键值对都按照键值的升序进行处理。这样的处理顺序确保了每一个划分产生一个排好序的输出文件。这样的话，如果输出文件格式需要支持根据 key 进行有效的随机查找会比较方便。同时，输出文件（应用）的用户也会觉得已经排好序的数据使用起来特别方便。</p><h3 id="Combiner-Function"><a href="#Combiner-Function" class="headerlink" title="Combiner Function"></a>Combiner Function</h3><p>在有些情况下，每个 Map task 都会产生大量的中间键的重复而用户指定的 Reduce 函数是交互和关联的。Section 2.1 中的单词统计就是一个很好的例子。因为单词的出现频率服从于 Zipf 分布，每个 Map Task 都会产生成百上千个<the, 1="">这样的记录。所有这些记录都会通过网络被送到一个 Reduce task 中，并且由 Reduce 函数加在一起去产生一个数。我们允许用户使用了可选的 Cominer 函数，用于在网络传输之前部分地进行归并操作。</the,></p><p>Combiner 函数在每个执行 Map task 的机器上执行。通常 Combiner 和 Reduce 函数使用的是相同的代码。Reduce 函数和 Combiner 函数<strong>唯一的不同</strong>是 MapReduce 库<strong>如何处理函数的输出</strong>。Reduce 函数的输出写到最终的输出文件中。而 Combiner 函数的输出会被写到一个最终将被送给 Reduce task 的中间文件中（合并后替代原有的中间键值对集合传递给 Reduce Task 机器，这样减少了带宽的占用）。</p><p>部分的合并操作能极大地加速某类特定的 MapReduce 操作。Appendix A 包含了一个使用 Combiner 的例子。</p><h3 id="Input-and-Output-Types"><a href="#Input-and-Output-Types" class="headerlink" title="Input and Output Types"></a>Input and Output Types</h3><p>MapReduce 库提供了对读入数据文件多种的格式支持。例如，”text”格式的输入将每一行作为键值对：key 是文件内的偏移，value 是该行的内容。另外一种比较常用的格式存储一系列按照键进行排序的键值对。每一个输出格式的实现都知道如何将自己进行合理的划分从而能让不同的 Map task 进行处理（例如，text 模式就知道将区域划分到以行为边界）。用户可以通过简单地定义一个 reader 接口来提供一个新的输入类型的实现。事实上，大多数用户只使用了预定义输入类型的很小一部分。</p><p>reader 并不一定要从文件中读取数据。例如，我们可以很容易地定义一个从数据库，或者内存中映射的数据结构中读取记录的 reader。</p><p>同理，我们也支持产生不同格式的输出数据，用户也能编写新的输出数据格式。</p><h3 id="Side-effects"><a href="#Side-effects" class="headerlink" title="Side-effects"></a>Side-effects</h3><p>在有些情况下，MapReduce 的用户会很容易发现 Map 或者 Reduce 操作会产生一些辅助文件作为额外的输出文件。我们依赖应用的编写者去保证这些副作用是原子和幂等的。一般来说，应用会写到一个临时文件中，并且在它完全产生之后，通过一个原子操作将它重命名。</p><p>对于一个单一的 task 产生的多个输出文件，我们不提供原子性的两相提交支持。因此，产生多个输出文件并且有跨文件一致性要求的 task 需要是确定性的。但是这样的限制在实践过程中并不是什么问题。</p><h3 id="Skipping-Bad-Records"><a href="#Skipping-Bad-Records" class="headerlink" title="Skipping Bad Records"></a>Skipping Bad Records</h3><p>有时候，如果用户的代码中有 bug 的话，会导致 Map 或者 Reduce 操作在某些记录上崩溃。这些 bug 会导致 MapReduce 操作的正常完成。对于这种情况，通常就是去修 bug。不过有时候这是不可行的，也许 bug 是第三方库造成的，而我们并不能得到它的源代码。而且，有时候我们允许忽略掉一些记录，例如在对一个大数据集做分析的时候。因此我们提供了一种可选的执行模式，当 MapReduce 库检测到一些记录会造成崩溃时，就会主动跳过它们，从而保证正常地运行。</p><p>每一个 worker 进程都安装了一个 signal handler 用于捕捉段错误和 bug。在调用用户的 Map 和 Reduce 操作之前，MapReduce 库会将参数的序号保存在一个全局变量中。如果用户代码产生了一个信号，signal handler 就会传输一个参数含有序号的”last gasp”UDP 包给 MapReduce 的 master。当 master 在一个特定的记录中发现了不知一次的错误，这表示在下一次执行相应的 Map 或者 Reduce 操作的时候一个将它跳过。</p><h3 id="Local-Execution"><a href="#Local-Execution" class="headerlink" title="Local Execution"></a>Local Execution</h3><p>Map 或者 Reduce 函数的调试问题是非常 tricky 的。因为实际的计算发生在分布式的系统中，通常由成百上千台机器组成，并且工作的分配由 master 动态执行。为了帮助调试，分析，以及小规模的测试，我们开发了另外一个 MapReduce 库的实现，它能够在本地机器上顺序执行一个 MapReduce 操作的所有工作。它的控制交给用户，因此计算可以被限定到制定的 Map task 中执行。用户利用指定的 flag 启动程序，然后就能非常简单地使用任何它们觉得有用的调试或者测试工具了。</p><h3 id="Status-Information"><a href="#Status-Information" class="headerlink" title="Status Information"></a>Status Information</h3><p>master 运行了一个内置的 HTTP server 并且输出了一系列供人们使用的状态页。状态页会显示程序的计算过程，例如已经完成了多少个 task，还有多少个 task 正在执行，输入的字节数，中间数据的字节数，输出的字节数，以及处理速度等等。该页还包含了指向各个 task 的标准错误和标准输出链接。用户可以利用这些数据来判断计算会持续多长时间，以及计算是否需要添加更多的资源。这些页面还能用来发现什么时候处理速度比预期地下降好多。</p><p>另外，顶层的状态页显示了那些 worker 出错了，以及在它们出错时正在执行哪些 Map 和 Reduce task。这些信息在诊断用户代码出现的 bug 时是非常有用的。</p><p>MapReduce 库提供了一个叫 counter 的设施用于统计各种不同事件出现的次数。例如，用户可能想要统计已经处理过的单词的数目或者德国文件的索引数量。</p><p>为了使用这一特性，用户代码创建一个命名的 counter 对象，并且在 Map 以及 Reduce 函数中对 counter 进行增加。例如：</p><pre><code class="hljs python">Counter* uppercase;uppercase = GetCounter("uppercase");map(String name, String contents):　　for each word w in contents:　　　　if(IsCapitalized(w)):　　　　　　uppercase-&gt;Increment();　　　　EmitIntermediate(w, "1");</code></pre><p>每个 worker 机器上 counter 的值会定期传给 master（捎带在给 master 的 ping 回复中）。master 将来自成功执行的 Map 和 Reduce task 的 counter 值聚集起来。然后在 MapReduce 操作完成之后返回给用户代码。当前的 counter 值也会显示在 master 的状态页上（前述的 state pages），所以用户能从实时观看计算的进行。在聚集 counter 的值的时候，master 会消除 Map 或者 Reduce task 的重复执行造成的重复计算。（重复执行可能由 backup tasks 或者因为错误重新执行的 task 引起）。</p><p>有些 counter 的值是由 MapReduce 库自动维护的，例如已经处理的输入键值对数目以及已经产生的输出键值对数目。</p><p>用户发现 counter 特性对于检查 MapReduce 操作的执行是非常有用的。例如，在有些 MapReduce 操作中，用户代码想要确保产生的输出对的数目和已经处理的输入对的数目是恰好相等的（比如检查满射），或者处理的德语文件的数目占总处理文件数目的比重在一个可容忍的范围内。</p><h2 id="Performance"><a href="#Performance" class="headerlink" title="Performance"></a>Performance</h2><p>在这个 section 中，我们通过运行在一个集群上的两个 computation 来测试 MapReduce 的性能。一个 Computation 搜索一个 T 的数据，从中获取一个特定的模式。另一个 computation 对一个 T 的数据进行排序。</p><p>这两个程序代表了由用户实际编写的 MapReduce 程序的一个子集———一类程序用于将数据从一种表示方法切换到另一种表示方法。另一类程序则从大数据集中抽取出一小部分有趣的数据。</p><h3 id="Cluster-Configuration"><a href="#Cluster-Configuration" class="headerlink" title="Cluster Configuration"></a>Cluster Configuration</h3><p>所有程序都运行在一个由 1800 台机器组成的机器上。每一台机器都有两个 2GHz 的 Intel Xeon 处理器，并且允许 Hper-Threading（超线程）， 4GB 内存，两个 160GB 的 IDE 磁盘，以及一个 G 比特的以太网链路。这些机器被安排在一个两层树状的交换网络中，根节点的带宽大概在 100-200Gbps。因为所有机器都在同一个托管设备中，因此任意两台机器间的 RTT 少于 1ms。</p><p>其中 4GB 中的 1-1.5G 是为集群中运行的其他任务预留的。程序在一个周末的下午运行，此时 CPU，磁盘，网络基本都处于空闲状态。</p><h3 id="Grep"><a href="#Grep" class="headerlink" title="Grep"></a>Grep</h3><p>grep 程序需要扫描 10 的十次方条 100-byte 的记录，搜索一个相对罕见的三字符模式（出现了 92337 次）。输入被分成大概 64MB 份（M = 15000），所有的输出文件都存放在一个文件中（R = 1）。</p><p>Figure 2 显示了 Computation 随着时间的变化过程。Y 轴代表了输入数据的扫描速度。随着机器逐渐加入 MapReduce 的计算当中，速度越来越快，当有 1764 个 worker 加入时，达到峰值 30GB/s。随着 Map task 的结束，速度开始下降并且在 80s 的时候到达 0,。整个 Computation 从开始到结束总共花费了大概 150s。这其中还包括了 1 分钟的启动开销。开销主要来源于将程序分发到 worker machine 中，和 GFS 交互并打开 1000 个输入文件，以及获取局部性优化所需的信息的延时。</p><h3 id="Sort"><a href="#Sort" class="headerlink" title="Sort"></a>Sort</h3><p>排序程序用于对 10 的十次方条记录（大概 1T 的数据）进行排序。程序以 TeraSort benchmark 为模型。</p><p>排序程序由不超过 50 行用户代码组成，一个三行的 Map function 从 text 的一行中提取一个 10-byte 的排序 key，与原始的 text line 组合成一个中间 key/value pair。我们使用内置的 Identity 函数作为 Reduce 的运算符。这一函数将中间键值对传递出作为输出对。最终的排序输出是一个二路复制的 GFS 文件。</p><p>输入被分成 64MB 份（M = 15000），而将输出分为 4000 份（R = 4000）。分割成许根据初始的 key 将其分割到 R 份中的一个。</p><p><img src="https://eddyblog.oss-cn-shenzhen.aliyuncs.com/%E8%AE%BA%E6%96%87%E6%88%AA%E5%9B%BE/OS_3_2.png" srcset="/img/loading.gif" alt="OS_3_2"></p><p>图 3（a）展示了排序程序的正常执行，左上方的图表示读入的速率，在达到峰值 13GB/s 后迅速滑落因为所有的 map tasks 在 200 秒内就已经完成。值得注意的是，输入的速率慢于 grep 操作（对于相同的 M 划分），这是因为对于 sort 操作，花费了一半的事件以及 I/O 带宽用于将中间键值对结果写入本地磁盘，而 grep 操作对应的输出则可以小到忽略不计。</p><p>中间左边的图表示经历 map tasks 后通过网络向 reduce tasks 传输数据的速率。这一混排在首个完成的 map task 后启动。第一个突起表示所有 reduce tasks 运行的第一个批次（R = 1700 nearly all），开始计算后 300 秒左右，第一批次的部分 reduce tasks 完成，我们开始向完成的机器进一步递送剩余 reduce tasks 的数据。</p><p>左下的图表示排序好的数据向最终文件写出的速率。从第一批次 reduce tasks 完成到开始写数据有一段时间间隔，这是因为机器忙于对中间数据进行排序。</p><p>关于速度的比较，输入数据高于 shuffle 速率和输出速率，这是因为输入是基于本地存储，而又因为网络带宽的限制，以及输出要求两份 replica 的要求，shuffle 速率高于输出速率。我们写成两个副本，因为这是我们的底层文件系统提供的可靠性和可用性机制要求。 如果底层文件系统使用擦除编码（erasure coding）而不是复制（replication），则可以减少写入数据的网络带宽要求。</p><p>（GFS 介绍的论文里应该会解释为什么需要两份 replica）。</p><h3 id="Effect-of-Backup-Tasks"><a href="#Effect-of-Backup-Tasks" class="headerlink" title="Effect of Backup Tasks"></a>Effect of Backup Tasks</h3><p>在图 3（b）中，我们展示了禁止 backup tasks 情况下执行排序操作的结果。流程与图 3（a）很相似，但存在一个相当长的且看不出有明显活动的尾部。960 秒后，除了剩余的 5 个，其余 reduce tasks 均已完成，然而剩余的 stragglers 直到 300 秒后才完成任务，着导致整体耗时 1283 秒，比具备 backup tasks（最终备份处理任务）情况下多耗时 44%。</p><h3 id="Machine-Failures"><a href="#Machine-Failures" class="headerlink" title="Machine Failures"></a>Machine Failures</h3><p>在图 3（c）中，我们展示了将 1746 台工作机器中的 200 台机器故意宕机几分钟以模拟机器故障情况下排序操作的执行结果，底层的集群立刻重启新的工作进程（因为仅仅是 kill 进程，实际上机器功能良好）。</p><p>worker 的 deaths 通过图表中负值输入速率来表示，因为先前一些已完成的 map work 丢失而需要被重新执行（根据先前分析，由于 map task 得到的中间结果存储在本地，宕机后无法正确访问，使得之前的任务需要被重新执行 re-execute）。重执行开始得十分迅速，整体耗时仅仅比正常情况多耗时 5%。</p><h2 id="Experience"><a href="#Experience" class="headerlink" title="Experience"></a>Experience</h2><p>我们得 MapReduce 库首个版本于 2003 年 2 月写成，并在 2003 年 8 月进行了重要加强，包括引入局部优化，worker 执行任务间动态负载均衡等等。从那时起，我们非常欣喜得看到 MapReduce 在解决各类问题上的广泛应用。现在，它已 Google 用于以下广泛领域的研究。</p><ul><li>大规模机器学习问题</li><li>Google News 和 Froogle products（Google 购物）的聚类问题</li><li>提取用于生成热门查询报告的数据（如 Google Zeitgeiest）</li><li>提取网页上进行的试验或产品性能</li><li>大规模图形计算</li></ul><h2 id="Large-Scale-Indexing"><a href="#Large-Scale-Indexing" class="headerlink" title="Large-Scale Indexing"></a>Large-Scale Indexing</h2><p>目前为止，我们最重要的 MapReduce 应用之一是重写一个产生谷歌搜索引擎需要的数据结构的复杂系统。索引系统以被抓取系统检索到的文件（GFS 文件形式储存）为输入，raw content 大小约 20T，索引进程进行约 10 次 MapReduce 组成的序列操作。相较于先前 ad-hoc 分布式索引系统，现在应用 MapReduce 后，系统具备以下优点：</p><ul><li>因为与容错、分布式、并行化相关内容隐藏在库重，索引代码更加简单、精巧、易于理解。比如，计算的一个阶段从原有 3800 行 C++代码削减至 700 行。</li><li>概念上可与计算分开，从而使改动变得简单。</li><li>内部对一些机器故障的解决使得整个过程更容易成功执行。进一步的，也更容易向系统中加入新的机器。</li></ul><h2 id="Related-Work"><a href="#Related-Work" class="headerlink" title="Related Work"></a>Related Work</h2><h2 id="Conclusion"><a href="#Conclusion" class="headerlink" title="Conclusion"></a>Conclusion</h2><p>现在 MapReduce 已成功被 Google 应用于各种目的，我们将这种成功归功于以下原因。</p><ul><li>甚至对于并行和分布式系统缺乏相关经验的编程人员，由于相关细节隐藏在库中，模型仍具备易用性。</li><li>大量问题易于以 MapReduce 地方式解决。</li><li>我们将其实现在大规模集群上，因而适于很多大型问题。</li></ul><p>在这项工作中我们学习到很多，</p><ul><li>重新定义编程范式使得并行/分布式运算易于实现，也获得了相当的容错性能。</li><li>网络带宽作为稀缺资源，使得我们的很多优化都意在减少通过网络传输的数据。</li><li>冗余的任务执行（backup tasks）可以用于减少缓慢机器的影响，以及解决机器故障和数据丢失。</li></ul>]]></content>
    
    
    <categories>
      
      <category>Computer Science</category>
      
      <category>分布式系统</category>
      
    </categories>
    
    
    <tags>
      
      <tag>Paper</tag>
      
      <tag>分布式系统</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>分布式系统学习——状态机容错模型Paper翻译</title>
    <link href="/post/86b562df.html"/>
    <url>/post/86b562df.html</url>
    
    <content type="html"><![CDATA[<p>学习笔记参考：</p><p><a href="https://www.jianshu.com/p/542262237d55" target="_blank" rel="noopener">分布式系统基础-State Machine</a></p><h1 id="读书笔记——Implementing-Fault-Tolerant-Services-Using-the-State-Machine-Approach-A-Tutorial"><a href="#读书笔记——Implementing-Fault-Tolerant-Services-Using-the-State-Machine-Approach-A-Tutorial" class="headerlink" title="读书笔记——Implementing Fault-Tolerant Services Using the State Machine Approach: A Tutorial"></a>读书笔记——Implementing Fault-Tolerant Services Using the State Machine Approach: A Tutorial</h1><p>利用状态机实现容错服务的一个教程</p><h2 id="摘要部分"><a href="#摘要部分" class="headerlink" title="摘要部分"></a>摘要部分</h2><p>状态机方法是在分布式系统中实现容错服务的一般方法。 本文回顾了该方法并描述了两种不同故障模型的协议 - 拜占庭和故障停止。 还讨论了用于移除故障组件和集成修复组件的系统重新配置技术。</p><h2 id="Introduction"><a href="#Introduction" class="headerlink" title="Introduction"></a>Introduction</h2><p>分布式软件常由客户端（clients）和服务端（services）构成。</p><p>集中式的服务端虽然是最简单的架构方式，但也导致了其容错性只能与执行该服务的处理器相同，换言之，依旧是单机的容错性能。</p><p>如果这样级别的容错不可接受，那就应该在分布系统的独立容错的不同处理器上运行原始服务的副本，协议用于这些副本的交互。分布式系统的物理电气隔离确保了故障的独立性。</p><blockquote><p>The state machine approcah is a general method for implementing a fault-tolerant service by replicating servers and coordinating client interactions with sever replicas.</p></blockquote><p>状态机方法是同过复制服务器（设置代理/备份）并协调客户端与服务器代理交互的一种实现容错服务的通用方法。</p><p>该方法还为理解和设计（服务器 replica）管理协议提供了一个框架。许多涉及数据或软件复制的协议——无论是为了掩盖故障，还是为了在没有集中控制的情况下促进交互——都可以使用状态机方法派生出来。尽管实际上很少有协议是以这种方式获得的，但是从状态机的角度观察它们有助于理解它们是如何以及为什么工作的。</p><p>本文是状态机方法的一个教程，描述了两种典型环境下的方法和实现。</p><a id="more"></a><h2 id="State-Machine"><a href="#State-Machine" class="headerlink" title="State Machine"></a>State Machine</h2><p>状态机由状态变量（编码描述状态），状态转移指令（描述状态变化）。每一条指令由确定性程序构成。命令的执行是原子的。一段客户端的请求可以看作是指定对应的状态机实施指定的 command（同时包含该 command 要求的全部信息）</p><p>请求的输出可以看作是一个 actuator（在程序控制系统中），或是其他的外围设备，或是等待先前请求响应的客户机（可以看作是编译原理中自动机理论的语义分析）。</p><p>请求由状态机每次执行一条，并且与潜在的因果关系一直。因此，状态机的客户端可以对要处理的请求的顺序做以下假设。</p><blockquote><p>O1. 单个客户对给定的状态机 sm 发送的请求将被按照发送的顺序执行。</p><p>O2. 如果客户机 c 向状态机 sm 发出请求 r 可能导致客户机 c’向 sm 发出请求 r’，那么 sm 在 r’之前处理 r。</p></blockquote><p>考虑到通信网络的延迟，尤其是在分布式网络中（可以联系上一篇论文），O1 和 O2 并不意味着状态机会根据制定/接收到的请求指令执行。</p><p>状态机的语义表征：<strong>状态机的输出完全由它处理的请求序列决定</strong></p><blockquote><p>Anything that can be structured in terms of proce- dures and procedure calls can also be structured using state machines and clients.</p><p><strong>a state machine implements the procedure</strong></p><p><strong>requests implement the procedure calls.</strong></p></blockquote><p>事实上，状态机在系统结构上比过程调用通常提供的灵活性更大。使用状态机，在处理请求之前不会延迟发出请求的客户机，并且可以将请求的输出发送到发出请求的客户机之外的其他地方。我们没有理由怀疑根据状态机客户端构建的应用会更加简洁。</p><h2 id="Fault-Tolerance"><a href="#Fault-Tolerance" class="headerlink" title="Fault Tolerance"></a>Fault Tolerance</h2><p>两种典型的错误行为</p><blockquote><p>Byzantine Failures（拜占庭故障）：</p><p>该组件可能表现出任意和恶意的行为，可能涉及与其他故障组件的勾结</p><p>Fail-stop Failures. （异常终止错误）</p><p>允许其他组件检测到错误并停止。</p></blockquote><p>t fault tollerant：指系统在一定范围的活动中最多不超过 t 个组件发生故障，传统的 MTBF（平均故障间隔时间）和其他的统计的故障评定方法固然有其可取之处，但是，去测定系统的最大容载故障组建个数潜意识中要求了系统具备一定的修正能力（当出现故障组件个数超出/即将超出限额时的补救措施）。</p><h2 id="Fault-tolerance-state-machine"><a href="#Fault-tolerance-state-machine" class="headerlink" title="Fault-tolerance state machine"></a>Fault-tolerance state machine</h2><p>步入正题，容错状态机。</p><p>由于备份（副本）运行在分布式系统的不同处理器上，在假定每个错误最多影响一个处理器，而在不出错的情况下，相同初始状态的状态机经相同的输入（request 序列）应该抵达相同状态并输出相同内容，那么结合该系统状态机副本的输出，得到容错状态机的输出。</p><p>若考虑满足最坏情况下，出现拜占庭故障，正常运行的组件仍占据大多数，要求一个 t fault-tollerant 状态机应之少包含 2t+1 个组件。</p><p>而如果考虑故障停止情况下，那么只要满足还有一个 non-fautlty 组件具备正常输出能力即可，所以应至少包含 t+1 个组件。</p><p>实现上述容错状态机的关键在于<strong>备份（副本）的协调（Replica Coordination）</strong>：所有备份（副本）都可以接收到且接收到顺序相同的请求序列。</p><p>拆分成两个子要求：</p><ol><li>Agreement：每个非故障状态机都会接收到每个请求。</li><li>Order：每个非故障状态机都会以相同的顺序处理这些请求。</li></ol><p>Order 保证的是相对顺序（局部序）。</p><p>在某些情况下条件可以放宽，比如，如果我们假设只会发生 Fail-Stop Failure,并且只会收到读请求，那么 Agreement 可以被弱化成只要一台（而非每台）正常运行的状态机收到这个读请求就好啦．很容易理解。另外对于通信请求，若处理不同的请求 r 和 r’时，r-&gt;r’和 r’-&gt;r 的终状态和输出序列相同的话。文章举了一个投票的自动机例子，如果候选者每个人投票数最大为 1，且阈值（MAJ）的两倍要大于总值（Cno），换句话说，至多只有一人会被投出，那么无论怎样交换请求（投票顺序），自动机的输出和最终输出必然是相同的。但若允许每个人投票多次，或是阈值不满足上述要求，则交换请求会影响到自动机的输出和终状态。</p><h3 id="Agreement"><a href="#Agreement" class="headerlink" title="Agreement"></a>Agreement</h3><p>我们可以通过引入一个新的组件，称为 transmitter，它负责向其他的组件发送一个值，只要满足以下条件，那么就能满足 Aggrement:</p><blockquote><p>IC1: All nonfaulty processors agree on the same value. 全部的正常运行的 processors 同意同一个值</p><p>IC2: If the transmitter is nonfaulty, then all nonfaulty processors use its value as the one on which they agree. 如果 transmitter 正常运行，那么其他的正常运行的 processors 均使用它的值作为它们同意的那个值</p></blockquote><p>这种协议已经引起了学术界的关注．目前也已经有相应的协议产生了。我们可以将 client 作为 transmitter,也可以单独设置这样一个组件．但是如果单独设置这样一个组件的话，我们需要确保请求在发送到 trasmitter 的过程中，丢失或者被篡改．我们可以通过让 client 也接收 transmitter 发送的请求，来避免这种情况。难点是应对在执行过程中出错的处理器。</p><h3 id="Order-and-Stability"><a href="#Order-and-Stability" class="headerlink" title="Order and Stability"></a>Order and Stability</h3><p>顺序要求可以通过为请求赋唯一标识符值来实现，且对于<strong>稳定</strong>的请求，将最小值传递给后面的状态机副本。（个人对稳定的理解：具备相对优先顺序、不会改变、可被执行）</p><p>要点：identifiers 的指定方法和“稳定”测试。</p><p>另外需要注意的是，identifiers 的分配还需要符合 Sec.1 里 O1 和 O2，这就要求祖先请求的 identifiers 值要更小，即若$r_j$是由于$r_i$而产生的，则$uid(r_i)&lt; uid(r_j)$。</p><p>文章介绍了三种方法</p><h4 id="Using-Logical-Clocks"><a href="#Using-Logical-Clocks" class="headerlink" title="Using Logical Clocks"></a>Using Logical Clocks</h4><p>利用上一篇文章所介绍的逻辑时钟，即给偏序请求集根据两条规则。</p><blockquote><p><strong>C1.</strong> 如果 a 和 b 是同一进程的两个事件且 a 发生在 b 之前，则$C_i \langle a \rangle &lt; C_i \langle b \rangle$。</p><p><strong>C2.</strong> 如果 a 是 i 进程消息发送方，而 b 是 j 进程中该消息的接收方，则$C_i \langle a \rangle &lt; C_j \langle b \rangle$。</p></blockquote><p>Condition）。</p><p>设计算法来为上述构建的时钟函数赋值，为满足 C1 和 C2，分别设定两条规则：</p><blockquote><p><strong>IR1.</strong> 同一个 process 的相邻 event，其时钟值是递增的。</p><p><strong>IR2.</strong> i 进程 a 活动发送的消息会携带一个时间戳$T_m = C_i \langle a \rangle$，则接收方 b 进程活动 b 设定其时钟值为$C_j \langle b \rangle = MAX(T_m,C_j \langle b \rangle)+1$。</p></blockquote><p>C 值即我们希望得到的 identifier 值，接下来文章用来描述检查 stable 的方法，通过对处理器之间传递的消息附加序列号而已实现一些 communication channels：</p><blockquote><p><strong>FIFO Channels.</strong> 一对处理器间的消息接收顺序即发送顺序。</p></blockquote><p>而对于出现故障停止的处理器，我们也可以假定下列情况的存在。</p><blockquote><p><strong>Failure Detection Assumption.</strong> 一个处理器 p 可以检测到另一个处理器 q 发生故障仅能够在其收到最后一条 q 发给 p 的消息后。</p></blockquote><p>两个假设是一致的，在该假设下，可以构建如下的检测方法：</p><blockquote><p><strong>Logical Clock Stability Test Toleranting Fail-stop Failures.</strong> A request is stable at replica $sm_i$ if a request with larger timestamp has been received by $sm_i$ from every client running on a nonfaulty processor.当所有处理器（无论 faulty 还是 nonfaulty）都以更晚的时间戳发送给该状态机副本一条请求时，先前的请求就是稳定的。</p></blockquote><p>接下来文章分类讨论解释了为什么上述成立，nonfaulty 的处理机一旦发送了更大的，由于递增性，下次发送的时间戳值会更大，而根据 FIFO 原则，receive order 和 deliver order 相同，也符合递增性。而对于认定为出错的处理机，根据 Failure Detection Assumption 原则，我们可以确定是在收到了最后一条消息后，所以之后也不会再收到故障处理器的消息，综上，测试条件成立。</p><h4 id="Synchronized-Real-Time-Clocks"><a href="#Synchronized-Real-Time-Clocks" class="headerlink" title="Synchronized Real-Time Clocks"></a>Synchronized Real-Time Clocks</h4><p>第二种构建满足 O1 和 O2 条件的 identifiers 值得方法是应用近似同步的实时时钟。</p><p>定义$T_p(e)$为事件 e 发生时 p 处理器的实时时钟值。我们通过向$T_p(e)$尾部后缀一端定长二进制串来唯一标定“p 处理器上的客户机进行了事件 e”这一信息。</p><p>那么为了满足 O1 和 O2 条件做以下规定。</p><ol><li>Satisfied O1. 在有效的时钟精度（clock ticks/resolution）中一个处理器不会进行多于一次的请求。</li><li>Satisfied O2. 时钟同步应优于最小消息传递时间。</li></ol><p>满足规定后，可以有以下的检测方法。设定$\Delta$为消息发出后确保每一个正常处理器收到消息时间不晚于$uid(r) + \Delta$的阈值，这样的$\Delta$是一定存在的。</p><blockquote><p><strong>Real-Time Clock Stability Test Tolerating Byzantine Failures 1.</strong> A request $r$ is stable at a state machine replica $sm_i$ being executed by processor $p$ if the local clock at $p$ reads $\tau$ and $uid(r) &lt; \tau - \Delta$</p></blockquote>]]></content>
    
    
    <categories>
      
      <category>Computer Science</category>
      
      <category>分布式系统</category>
      
    </categories>
    
    
    <tags>
      
      <tag>Paper</tag>
      
      <tag>分布式系统</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>分布式系统学习——Lamport时钟经典论文Paper翻译</title>
    <link href="/post/b6a38e07.html"/>
    <url>/post/b6a38e07.html</url>
    
    <content type="html"><![CDATA[<p>阅读笔记参考：<a href="https://www.jianshu.com/p/0c79d650d13f" target="_blank" rel="noopener">小强zju的读书笔记</a></p><p><a href="https://www.jianshu.com/p/0d49b1811203" target="_blank" rel="noopener">分布式系统基础－Lamport Clock</a></p><p><a href="https://www.microsoft.com/en-us/research/publication/time-clocks-ordering-events-distributed-system/" target="_blank" rel="noopener">Lamport本人评述</a></p><h1 id="读书笔记——Time-Clocks-and-the-Ordering-of-Events-in-a-Distributed-System"><a href="#读书笔记——Time-Clocks-and-the-Ordering-of-Events-in-a-Distributed-System" class="headerlink" title="读书笔记——Time, Clocks, and the Ordering of Events in a Distributed System"></a>读书笔记——Time, Clocks, and the Ordering of Events in a Distributed System</h1><h2 id="摘要部分"><a href="#摘要部分" class="headerlink" title="摘要部分"></a>摘要部分</h2><p>本文研究了分布式系统中一个事件先于另一个事件发生的概念，并展示了如何定义事件的偏序，同时给出了一种可以对时间完全排序的分布式时钟同步算法。通过一种解决同步问题的方法来描述对全体事件的同步。</p><p>然后介绍专门用于同步物理时钟的情况，并推导出时钟不同步的界限。</p><h2 id="Introduction"><a href="#Introduction" class="headerlink" title="Introduction"></a>Introduction</h2><p>时间概念是我们思维方式的基础，更基本的源于事件发生顺序，其贯穿我们对系统（system）的思考。然而在分布式系统中我们应<strong>重新审视</strong>这一基本概念。</p><blockquote><p>A system is distributed if the message transmission delay is not negligible compared to the time between events in a single process.</p></blockquote><p><strong>如果与单个进程中的事件之间的时间相比，消息传输延迟不可忽略，那么该系统就是分布式的。</strong><br>（无论是在单机系统还是多机系统上，上述情况都要考虑）</p><p>本文重点关注空间分离的系统，但是单机多处理器系统涉及一些相类似的问题，因为某些事件可能以不可预测的顺序发生。“之前发生”只是系统中事件的部分排序。（事实上整体事件呈现一个偏序集合 No happen before）。</p><a id="more"></a><h2 id="The-Partial-Ordering"><a href="#The-Partial-Ordering" class="headerlink" title="The Partial Ordering"></a>The Partial Ordering</h2><blockquote><p>We will therefore define the “happened before” relation without using physical clocks.</p></blockquote><p>我们将不依赖物理时钟定义“happen before”规则。</p><p>因应用的不同，我们可以将一个子程序（或是一条机器指令的执行）当作某个process里的一个event。</p><p>我们假定某个process的所有events构成一个序列，这个序列是线序（或许应该说不包含相等的情况），用文中的话说是具有<strong>先验总排序</strong>。我们根据process中event的发生顺序定义“happen before”</p><p>定义“happen before”关系，用（→表示）</p><blockquote><ol><li><p>如果a，b是相同进程的两个事件，且a出现在b之前，那么$a \rightarrow b$。</p></li><li><p>如果a是某进程消息发送的一方，b是另一进程接收该消息的一方，则$a \rightarrow b$。</p></li><li><p>该关系具备传递性，即$a \rightarrow b$ ，$b \rightarrow c$，则$a \rightarrow c$。如果$a \nrightarrow b$，$b \nrightarrow a$，那我们称a，b是并发（concurrent）的。</p></li><li><p>另外补充，该关系是反自反的，即，对任意a，$a \nrightarrow a$，（系统中一个时间可以在它自身之前发生没有实际意义）。</p></li></ol></blockquote><p>在图中$a \rightarrow b$即表示可以从a通过波浪线（消息传播途径），或者纵向的进程轴线（事件发生途径）走到b。</p><p>另一种方式解读该图像，我们也可以说，并发的进程是不会不经意间相互影响的。</p><blockquote><p>Happened Before的理论和狭义相对论中的物理世界中的观念十分的类似，即event的先后是相对的，在实际世界中的不同惯性坐标系下，2个event的先后关系可能发生变化。不过Paper中没有深入的对比，我会在感想部分中深入讨论下</p></blockquote><h2 id="Logical-Clocks"><a href="#Logical-Clocks" class="headerlink" title="Logical Clocks"></a>Logical Clocks</h2><p>现在考虑引入时钟，先以数学的方式为每个事件分配一个数字来代表其事件发生的时间。以时钟函数$C_i$表示$P_i$进程，其中$C_i \langle a \rangle$表示该进程a事件的值。$C$ 函数表示整个系统的时钟，如果b是进程$P_i$的事件之一，则$C \langle b \rangle = C_i \langle b \rangle$。</p><p>由于当前没有将函数值和物理事件关联起来，所以我们将其认为是逻辑时间。</p><p>考虑该逻辑时钟的合理性，我们无法根据物理时间验证（这会要求基于物理时间的时钟引入），考虑一个强合理性的条件，如果事件a发生在另一个事件b之前，则a应该在比b更早的时间发生。 我们更正式地陈述这种情况如下。</p><blockquote><p>Clock Condition</p><p>For any events a, b:<br>if $a \rightarrow b$ then $C \langle a \rangle &lt; C \langle b \rangle$</p></blockquote><p>其逆命题不成立（否则会要求所有并发事件同时发生，易证否），即只具备充分性。</p><p>满足下面两条件时，时钟条件（Clock Condition）是满足的。</p><blockquote><p><strong>C1.</strong> 如果a和b是同一进程的两个事件且a发生在b之前，则$C_i \langle a \rangle &lt; C_i \langle b \rangle$。</p><p><strong>C2.</strong> 如果a是i进程消息发送方，而b是j进程中该消息的接收方，则$C_i \langle a \rangle &lt; C_j \langle b \rangle$。</p></blockquote><p>  Condition）。</p><p>通过算法来为上述构建的时钟函数赋值，为满足C1和C2，分别设定两条规则：</p><blockquote><p><strong>IR1.</strong> 同一个process的相邻event，其时钟值是递增的。</p><p><strong>IR2.</strong> i进程a活动发送的消息会携带一个时间戳$T_m = C_i \langle a \rangle$，则接收方b进程活动b设定其时钟值为$C_j \langle b \rangle = MAX(T_m,C_j \langle b \rangle)+1$。</p></blockquote><p>两条分别对应两条规则，所以时钟条件也得到满足，保证了具备逻辑时钟的合理系统。</p><h2 id="Ordering-the-Events-Totally"><a href="#Ordering-the-Events-Totally" class="headerlink" title="Ordering the Events Totally"></a>Ordering the Events Totally</h2><p>在规定进程间一个顺序后，通过以下规则，我们从事件的偏序构建全序，我们便可得到新的“全序关系”（用$\Rightarrow$）来表示：</p><blockquote><ol><li>若对于a，b两事件，有$C_i \langle a \rangle &lt; C_j \langle b \rangle$，则$a \Rightarrow b$</li><li>若$C_i \langle a \rangle = C_j \langle b \rangle$ 且 $P_i &lt; P_j$，则$a \Rightarrow b$</li></ol></blockquote><p>可以说“$\Rightarrow$”是将“happen before”偏序关系“$\rightarrow$”拓展成的全序关系。</p><p>该全序依赖与系统时钟的确定，是不唯一的，相反，唯一确定的是事件发生的偏序关系。</p><p>对事件进行全排序的有用性将通过解决下列情况下的互斥问题来说明，考虑一个共享单个资源的固定过程集合的系统：</p><blockquote><p>Q1. 已被授予资源的进程必须先释放它，然后才能将其授予另一个进程。<br>Q2. 必须按照它们的顺序授予对资源的不同请求。<br>Q3. 如果授予资源的每个进程最终都会释放该资源，那么每一个请求都后被授权。</p></blockquote><p>通过一个中心化的进程通过请求抵达的时刻来安排资源是不可行的（后抵达该进程的消息可能先需求了资源）。</p><p>为了解决该问题，我们实行一个满足了IR1和IR2的系统，并且通过其定义出所有事件的全序，具备全局序后，问题就变得相当简单了，只需要确保每个进程清楚其他进程得操作即可。</p><h3 id="分布式算法细节"><a href="#分布式算法细节" class="headerlink" title="分布式算法细节"></a>分布式算法细节</h3><p>每个进程维护自己的<strong>请求队列</strong>，规定请求队列初始包含单一的消息$T_0$：$P_0$请求资源，其中$P_0$是初始占据资源的进程（根据假设，所有资源初始归同一进程占据），且$T_0$小于任何时钟的初始值。</p><p>该算法由以下五条规则定义。为了方便起见，假定每个规则定义的操作构成一个单一事件。</p><ol><li>为了请求资源，请求方进程$P_i$将消息“$T_m$：$P_i$请求资源”递送至所有其他进程，并把该消息加入自己的请求队列。$T_m$表示该消息的时间戳。</li><li>当$P_j$收到消息“$T_m$：$P_i$请求资源”，将其加入自己的请求队列并向$P_i$发送一个带时间戳的确认消息。</li><li>为了释放资源，进程$P_i$将所有“$T_m$：$P_i$请求资源”消息移出队列，并把一个带时间戳的释放消息递送给所有其他进程。</li><li>当$P_j$收到消息“$P_i$释放资源”，将所有“$T_m$：$P_i$请求资源”消息移出队列。</li><li>当满足下列两条件时，进程$P_i$占据该资源：<ol><li>存在一个“$T_m$：$P_i$请求资源”消息在其请求队列中并且序优先于其他的所有请求。</li><li>$P_i$收到了所有其他进程发来的时间戳晚于$T_m$的消息。</li></ol></li></ol><p>易于说明该算法满足该系统的三个要求。</p><p>这是一个分布式算法，每个进程独立遵循这些规则，没有集中的同步进程或是中央存储。</p><p>根据算法1-&gt;5构建可以证明Q1，Q2，Q3是满足要求的。</p><p>对于Q1，反证法：</p><p>假设Q1不成立，则意味着在资源分配给某进程后，假设该进程为$P_j$，存在至少一个进程，假设为$P_i$，未释放该资源。但是根据3、4点，这意味着，$P_i$没有发出“释放”的消息，也就应导致着进程$P_j$维护的队列中，仍存在“$T_{m_1}$：$P_i$请求资源”这一消息并未移出（第四点），且$T_{m_1}$是最早的。现在我们审查第五点，上述未删除的消息存在队列，便不会使“$T_{m_2}$：$P_j$请求资源”这条满足最先（5.1点），那$P_j$维护队列中不满足其占有资源的条件，矛盾。</p><p>对于Q2，时间戳是一个全序，由于5.2点要求收到所有其他进程法来的更晚的消息，所以可以保证先前消息是完全的，可以确定是最早的，根据全序顺序，可保证。</p><p>对于Q3，反证法：</p><p>假设在均释放的情况下，存在至少一个请求没有被授权（批准），不妨设最早的是$P_j$的请求，则在其自身队列以及所有其他进程队列中都应在某一时间后都存在着这样一条“$T_{m_2}$：$P_j$请求资源”，由于始终未被授权，假设5.1不被满足，则应存在“$T_{m_1}$：$P_i$请求资源”始终存在，且$T_{m_1}&lt;T_{m_2}$但是我们设定$P_j$是最早的不被授权的，所以前者必定在某个时间释放，$P_i$请求资源的记录会随释放消息的到达被撤，不可能始终存在，不成立。若5.2始终不能被满足，在5.1成立后，由于没有fail的机器，必然会收到确认消息，不成立。所以5.1，5.2总会在一定时间后被满足，矛盾。</p><h2 id="Anomalous-Behavior"><a href="#Anomalous-Behavior" class="headerlink" title="Anomalous Behavior"></a>Anomalous Behavior</h2><p>异常情况，上面定义的Logical Clocks有一些反常的行为，例如我们定义的Total Ordering是$b&lt;a$，但事实上a事件的操作员执行之后通过电话告诉b事件的操作员开始执行，那么Logical Clocks给出的全序就明显违背了客观情况。</p><p>这种情况的出现是由于系统不知道“电联”这一要求，因为这种先后顺序是在系统外定义的。<br>为避免这种反常，有2中解法：</p><ol><li>将外部的happened before关系手动的引入到系统内（event b产生是强调依赖 event a）</li><li>引入实际物理时钟</li></ol><h2 id="Physical-Clocks"><a href="#Physical-Clocks" class="headerlink" title="Physical Clocks"></a>Physical Clocks</h2><p>对物理始终两条限制，</p><p><img src="https://eddyblog.oss-cn-shenzhen.aliyuncs.com/%E8%AE%BA%E6%96%87%E6%88%AA%E5%9B%BE/OS_1_1.png" srcset="/img/loading.gif" alt="OS_1_1"></p><p><img src="https://eddyblog.oss-cn-shenzhen.aliyuncs.com/%E8%AE%BA%E6%96%87%E6%88%AA%E5%9B%BE/OS_1_2.png" srcset="/img/loading.gif" alt="OS_1_2"></p><p>实际上时限制增速尽可能贴近1，以及各时钟的同步性。</p><p>后面保证物理时钟一致性以及满足C1，C2的算法暂时没有看懂，所以后面再补吧，数学功底差一些。</p>]]></content>
    
    
    <categories>
      
      <category>Computer Science</category>
      
      <category>分布式系统</category>
      
    </categories>
    
    
    <tags>
      
      <tag>Paper</tag>
      
      <tag>分布式系统</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>TOFEL写作</title>
    <link href="/post/3d51fca5.html"/>
    <url>/post/3d51fca5.html</url>
    
    <content type="html"><![CDATA[<h2 id="Exercise"><a href="#Exercise" class="headerlink" title="Exercise"></a>Exercise</h2><p>Confronting some parents assertion that the elder children in the family should take care of the younger, while others hold the view that all the children should be treated equatily, regardless of the age.</p><p>Problem: 意思发生改变</p><h2 id="题目改写方法"><a href="#题目改写方法" class="headerlink" title="题目改写方法"></a>题目改写方法</h2><h2 id="背景句"><a href="#背景句" class="headerlink" title="背景句"></a>背景句</h2><h2 id="观点句"><a href="#观点句" class="headerlink" title="观点句"></a>观点句</h2><p>I reckon/assure/advocate/argue/contend that</p><p>I assert the statement that</p><p>From my perspective in my view<br>From where I stand,<br>As far as I am concerned,</p><h3 id="让步-转折"><a href="#让步-转折" class="headerlink" title="让步+转折"></a>让步+转折</h3><p>Although</p><h1 id="独立写作思路理由篇"><a href="#独立写作思路理由篇" class="headerlink" title="独立写作思路理由篇"></a>独立写作思路理由篇</h1><p>四大题型分类：利弊题、事实题、今昔对比、特殊词。</p><p>事实题和利弊题四六开（新手重点解决利弊题）。</p><h2 id="利弊题主题句写法"><a href="#利弊题主题句写法" class="headerlink" title="利弊题主题句写法"></a>利弊题主题句写法</h2><p>小 Trick：题目中所有的对象都可以分析利弊（老小孩、小小孩、大人）。</p><p>利弊题常用解法，万能理由：针对个人。</p><div class="table-container"><table><thead><tr><th style="text-align:center">万能理由</th><th style="text-align:center">英文表达</th><th style="text-align:center">笔记（备注）</th></tr></thead><tbody><tr><td style="text-align:center">省钱（性价比高）</td><td style="text-align:center">save money/cost-effective</td><td style="text-align:center">Especially for the poor（极限论证）</td></tr><tr><td style="text-align:center">省时间（便捷）</td><td style="text-align:center">save time/convenient</td><td style="text-align:center">portable</td></tr><tr><td style="text-align:center">有效率</td><td style="text-align:center">Improve efficiency/efficient</td><td style="text-align:center">study/work/</td></tr><tr><td style="text-align:center">安全（身心健康）</td><td style="text-align:center">safe/physical/mental health</td><td style="text-align:center">安全类词汇：&lt;/br&gt;safe safety（个人安全） &lt;/br&gt;secure security（社会安全、安保）&lt;/br&gt;unexpended accidents(potential risks)（不可预知的风险）&lt;/br&gt;Tsunami（海啸）、tornado（龙卷风）、storm（风暴）&lt;/br&gt;健康类词汇（physical）：&lt;/br&gt;short-sight、lack of exercise、overweight、obesity、diabete、heart attack、influence/strengthen the immune system/ protect sb from infectious disease:flu build muscle/ chese muscle&lt;/br&gt;健康类词汇（mental）：&lt;/br&gt;干正事：(release/relieve/reduce) strsss/pressure/burden -&gt; mentail illness: depression&amp; anxiety&amp;insominia（失眠）-&gt; commit suicide （就自杀） : e.g. the hight suicide rate in Japan &lt;/br&gt; 不干正事： mass media -&gt; violent and pornographic information -&gt; mimick the bad behavior -&gt; go astray/ misguided</td></tr><tr><td style="text-align:center">发掘兴趣爱好</td><td style="text-align:center">discover one’s interest</td></tr><tr><td style="text-align:center">扩展知识</td><td style="text-align:center">broaden one’s horizons /expand one’s knowledge</td></tr><tr><td style="text-align:center">交朋友（团队精神）</td><td style="text-align:center">make friends(cooperative/collaborative,teamwork spirits)</td></tr><tr><td style="text-align:center">培养能力</td><td style="text-align:center">improve skills and develop abilities</td><td style="text-align:center">acdemic（学术能力）&lt;/br&gt; practical skill（实践能力）&lt;/br&gt; step on the royal road of academics/ part-time/internship/voluntary activities/ time-management（时间管理能力）</td></tr><tr><td style="text-align:center">增进家人感情</td><td style="text-align:center">strengthen/reinforce family/relationship/ties/bonds</td></tr><tr><td style="text-align:center">成就感（自我实现）</td><td style="text-align:center">obtain a sense of accomplishment/achievement(self-fulfillment)</td></tr></tbody></table></div>]]></content>
    
    
    <categories>
      
      <category>English</category>
      
      <category>TOFEL</category>
      
    </categories>
    
    
    <tags>
      
      <tag>TOFEL</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>细数我去过的那些博物馆（院）</title>
    <link href="/post/2810df46.html"/>
    <url>/post/2810df46.html</url>
    
    <content type="html"><![CDATA[<h1 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h1><p>出了广东省博物馆的大门，感觉自己跑编了大半个中国的省级及以上的博物馆（博物院），随手发了个朋友圈，感慨之余，朋友圈下面的评论倒是提醒我，为何不给造访过的这些博物馆排个位序，比较一下其间的不同？我觉得颇有道理。今天由于出行方式的选择失误导致了我错过了最后一班去往深圳的高铁，目前返回广州东站搭乘城际列车，不过事情总有好的一面，我便多了几十分钟写这篇文章的时间。虽然一拖再拖，不过总算是写了大半部分。</p><p>接下来的部分，我将自己对各个博物馆印象最深刻的地方作为章节标题来逐个介绍他们，整篇文章完整阅读约耗费 8 分钟时间，若您无暇完整阅读，想留一个初步印象作为接下来规划旅行的“扫盲贴”的话，那我建议您花 1-2 分钟阅读以下各节标题。</p><p>我对各博物馆（院）的评价主要参考（但不限于）以下几个方面：</p><ol><li>馆藏文物丰富程度</li><li>考古科研贡献程度</li><li>展示文物丰富程度</li><li>馆内安保情况以及展示文物保护措施</li><li>配套讲解以及辅助文字说明</li><li>博物馆布局以及展示的相关性</li></ol><h1 id="最推介——陕西历史博物馆"><a href="#最推介——陕西历史博物馆" class="headerlink" title="最推介——陕西历史博物馆"></a>最推介——陕西历史博物馆</h1><ol><li><p>前述</p><p>如果让我从参观的众多博物馆中挑出一个 The Best One 的话，我个人觉得，陕历博当之无愧。我本人一直信奉将已拥有的全部发挥出来便是 The Best，博物馆（院）中，陕历博即是如此。</p><p>我是高三毕业的暑假参加西安交大自招的时候顺路参观的陕西历史博物馆，虽然那时距离写这篇文章已经有一段时间了，但我后续造访的很多博物馆（院）在许多方面依旧稍逊（甚至远逊于）当时的陕历博。如果您之前从未造访过任何一个博物馆（院），抑或是您想从新从头开启自己的“博物馆神奇之旅”，那我一定要推荐您去陕西西安看看。一个陕历博，是将半部中国古代史，毫无保留地铺开展现在你眼前。</p><p>陕历博位于陕西省西安市雁塔区，大雁塔西北侧，除去节假日里外里两圈等候参观的长队，其实看外观也颇具历史范，地铁抵达也比较方便。</p></li><li><p>推介理由</p><p>藏品数量质量及连贯性最佳，文字讲解我见过得博物馆中最为详尽，有语音导览配套，但不依赖（个别博物馆语音导览做过头了，文字少的可怜）。展厅装潢切合历史（石器的灰黄，秦朝的黑，特别是汉朝的赤红），国宝级文物丰富且配有重点介绍（兵符和独孤信的煤精印我至今还能清晰的回忆起来）。大唐遗宝的发觉过程也可以让参观者详尽的了解到国宝的发掘过程。</p></li><li><p>周边景点</p><p>大雁塔（大慈恩寺）、秦始皇陵地宫展览馆、秦始皇兵马俑博物馆（不知道玉甲那个分馆开了没有）。</p></li><li><p>其他</p><p>南方的同学可能吃不太习惯北方的面食，可以的话我还是非常推介羊肉泡馍+各式各样的肉夹馍的，PS 羊肉泡馍不要晚上吃。</p></li></ol><h1 id="最恢宏——北京故宫博物院"><a href="#最恢宏——北京故宫博物院" class="headerlink" title="最恢宏——北京故宫博物院"></a>最恢宏——北京故宫博物院</h1><ol><li><p>前述</p><p>作为一个河北人，我这个从小学就被拉去看天安门升旗仪式的娃，比其他省份抵达首都有着交通上的便利，三次参观北京故宫博物院，怎么说，故宫应该是我印象中展出/馆藏占比最小的一个博物院，但单单这展出部分，或许就已经足够体现中国古代后期封建王朝的历史了。</p><p>大众游客初访博物院一般走的是午门——神武门线路，节假日游客很多，而且需要提醒的是该线路以在外参观建筑为主，露天而且是没有树木给你遮挡烈日的（为何如此大家可以自己做做攻略）。PS 野导游经常会给你讲野史，关于故宫线路的网上讲解以及官方讲解都还不错，起码不是野史，或者说不带着奇怪民间迷信。</p></li><li><p>推介理由</p><p>理由这个有点难写，谈起博物馆（院）不谈故宫不谈紫禁城是很难的，这座独一无二的皇家园林建筑群本身就是一个无价的文物，首批五 A 级景区，内涵之丰富我想应该是我等不能想象的。但这客观上也造成了我们多是仰视高高在上的故宫，想要探寻其内在的种种则需要我们花费更多的精力和时间。此外，故宫在文物保护，流失文物找回，文物修缮（《我在故宫修文物》）等方面做出的巨大努力也让这里除去文物本身观赏价值外，更有些其他方面的韵味。据闻西区东区也在逐步开放了，我想讲解服务方面北京故宫也会继续走在路上。</p></li><li><p>周边景点</p><p>八达岭长城可以去看一下，不推荐鸟巢水立方（除非你想打卡照片）。可以再去一下天坛和中国国家博物馆（这个我没去过，惭愧）。</p></li><li><p>其他</p><p>游北京，千万别跟团，团体游水有些深，现在网络也发达了，自由行不仅可以自己把握时间，而且防止被骗被宰，京油子这个名字可不是没道理（抱歉，我真的没有贬义）。</p></li></ol><h1 id="最内涵——上海博物馆"><a href="#最内涵——上海博物馆" class="headerlink" title="最内涵——上海博物馆"></a>最内涵——上海博物馆</h1><ol><li><p>前述</p><p>上海博物馆新馆与 96 年建成，馆址在人民广场附近，交通很便利。印象中东北部还有上海城市规划馆和一个小的商圈。我讲上海博物馆内涵是因为从外观上，尽管周围是公园平地，但是整体看上海博物馆并不是很大（或许仅仅是错觉，上博陈列面积约 12000 平方米，已经不小了），从正门进入以后也是以四方形正厅构造，略窄的楼梯缓步登上二楼三楼逐步参观，但同时，其馆藏之丰富，文物来源之广泛确实告诉我们，人不可貌相，博物馆也是这个道理。</p></li><li><p>推介理由</p><p>除了文物丰富程度，上博文物的配套文字介绍以及相关知识延拓是国内一流水平的，陕历博和上博在这方面我觉得做的真的很到位，我现在还能回想起来古代青铜馆内对各类青铜器上的装饰纹理的介绍（云纹，鱼纹，云雷纹，夔龙纹，饕餮纹，火纹等等），带图，带解释，详尽丰富，甚至你还可以学到辨析商周青铜器早晚期的一些方法。</p><p>Further More，上博和国外知名博物馆的交流也是国内博物馆中最为频繁的，这也为上博带来了更多的其他国家的藏品展览机会以及更好的国际视角，我当时参观的时候恰好碰上大英博物馆在上博设展，刘易斯棋子（还记得哈利波特与魔法石吗？），埃及藏品等等。除了更多的国际交流活动外，上博的公众号经营的也是最为优秀的，不仅有“硬”科普，还会向公众推送近期上博要举行的各类活动，将 2</p></li><li><p>周边景点</p><p>上海市城市规划馆（同在人民广场，步行不过五分钟，一睹上海发展史还是很不错的），外滩，思南路（北头的 Line Friend 店，文艺青年专属街道），十号线路线（上海市图书馆、宋庆龄故居），田子坊+日月光中心。</p></li><li><p>其他</p><p>节假日出行请提前安排好住宿，另外工作日上海的地铁真的很挤，我和朋友亲眼目睹了 2 号线挤停。</p></li></ol><a id="more"></a><h1 id="商海先行——广东省博物馆"><a href="#商海先行——广东省博物馆" class="headerlink" title="商海先行——广东省博物馆"></a>商海先行——广东省博物馆</h1><ol><li><p>前述</p><p>截至目前，广东省博物馆应该是我最晚参观的一个博物馆，它位于广州市新中轴线，珠江新城东南，花城大道东侧，与广州市图书馆、大剧院、第二青年宫共同构成了花城广场两侧的文教区。</p><p>广东省博物馆论体量，比不过超大型占地面积的一些博物馆，论文物丰富，广州城建城历史虽不短，但少作为政权的核心城邦来对待，因而也比不上六朝古都或是紫禁城，但广东省的独特地位（临海通商口岸，居民迁移）等，造就了广东省的独特文化，而广州省博物馆也市恰恰抓住了其最具特色的两点：“海”与“商”。</p></li><li><p>推介理由</p><p>“南海一号”发掘过程，发掘藏品给你充分展示了古代对外经贸的各方面情况，以及航海方面的知识（包括但不限于当时的造船技术、船舶载货的方式），通过对当时情景的复原，甚至可以从一些方面解释该船沉没的原因。</p><p>此外其他展区，诸如木雕、端砚也非常用心的讲解了潮州等地区的特别文化。</p></li><li><p>周边景点</p><p>粤式点心当然是要吃的啦~点都德、陶陶居、广州酒家，稻香。此外西关地区的文明路甜品店也不应错过，上下九地区，广州塔，双鸭山大学（手动狗头）。</p></li><li><p>其他</p><p>多点人来，组团吃早茶可以点更多样式（我就是吃了这个亏）。</p></li></ol><h1 id="燕赵齐鲁——河北博物院、山东博物馆"><a href="#燕赵齐鲁——河北博物院、山东博物馆" class="headerlink" title="燕赵齐鲁——河北博物院、山东博物馆"></a>燕赵齐鲁——河北博物院、山东博物馆</h1><ol><li><p>前述<br>附近<br>讲真对于这两博物馆（院），我并不能给出一个很明确的文物相关的特色，只能以历史地名作为本节标题，如果谈参观这两馆的最大好处，我想就是不用排队，参观不挤了，当然，每一座博物馆（院）都是有灵魂的，如果你想了解这两片土地孕育出的文化，那这两座博物馆自然是首选。</p><pre><code>外观特征的话，印象中山东博物馆的台——阶——很——多，河北省博物院的北——门——不——开（其实是开了但不显眼，和南区广场的大门形成鲜明的反差）。两者的外观颜色蛮相近的，而且好像都可以刷身份证免票进（很环保，支持）。河北省博物院其实面积很大，但是由于建筑不高，且铺开形成南北两区，让人感觉不出来其五万多平方米的占地。</code></pre></li><li><p>推介理由</p><p>山东博物馆：为济南这个文化之都增了一笔亮色，山博对文物考古的贡献也颇大，作为解放后第一批博物馆，接管了原来文物后开启了大片的田野调查，著作也是相当的，在北方地区为考古文物发掘的事业做出了巨大贡献。</p><p>值得一看的藏品：首推鲁国大玉璧+孙子兵法！其他的我印象真的不是很深刻 sry。</p><p>河北博物院：以中山靖王相关的文物以及满城汉墓出土文物最为出名，另外河北省博常设一些红色展览以及书画临展，有兴趣的同学可以关注一下。</p><p>值得一看的藏品：长信宫灯（如果你能了解烟道的原理这些古人智慧结晶就更棒了），中山王相关的铁足铜鼎和金缕玉衣（后来去了湖南省博我才知道金缕玉衣不止中山靖王有）但值得一说的是，刘胜的金缕玉衣是中国首次发现、规格最高、最完整的玉制葬衣。</p></li><li><p>周边景点</p><p>山博附近：去了济南为什么不去临近的泰安爬个泰山呢？还有曲阜的三孔景区。</p><p>河北博物院：北边正定县城（大佛寺、荣国府取景地）可以一去，石家庄东开发区天山海世界是个玩水的好去处。</p></li><li><p>其他</p><p>我自认为北方这两个地方民风都蛮朴实的，不过气候都偏干燥，尤其是春夏季节，南方的同学如果选择这个季节来的话记得带上各种保湿用品，PS 吃辣会很容易上火。河北我推荐尝尝保定或者河间的驴肉火烧，山东。。山东大煎饼我是不推荐的，其他鲁菜根据经济能力可以尝试一下，便宜坊是个不错的店家（印象中），锅贴好吃。</p></li></ol><h1 id="西南异域——四川省博物院、三星堆博物馆"><a href="#西南异域——四川省博物院、三星堆博物馆" class="headerlink" title="西南异域——四川省博物院、三星堆博物馆"></a>西南异域——四川省博物院、三星堆博物馆</h1><ol><li><p>前述</p><p>这两个博物馆都是我大一暑假个人游途中去的，参观西南一隅的博物馆是别样的文化体验。综合来讲两家的文物主要侧重本地发掘（这是自然），因而更注重地域性，历史时间的连贯性以及和历史事件的衔接就没有一些博物馆那么好了。</p></li><li><p>推介理由</p><p>两馆都对特色文物、国宝级文物的展览渲染让我印象深刻，川博丰富多彩的展示了蜀地地区文化以及和中原地区的联系变化，在众多博物馆中独树一帜。三星堆文化、古蜀国，拾其底蕴最丰富的历史片段做详尽的讲解。</p><p>特色文物：铜面具、金面具、太阳神鸟金箔（学材料和艺术的强烈推介去看一下）。</p></li><li><p>周边景点</p><p>宽窄巷、武侯祠和锦里。</p></li><li><p>其他</p><p>冰粉！冰粉一定要尝一尝！每当回想起我的成都之行我都后悔当时没有多吃几碗冰粉！</p></li></ol><h1 id="旧馆新缮——湖北省博物馆、湖南省博物馆"><a href="#旧馆新缮——湖北省博物馆、湖南省博物馆" class="headerlink" title="旧馆新缮——湖北省博物馆、湖南省博物馆"></a>旧馆新缮——湖北省博物馆、湖南省博物馆</h1><ol><li><p>前述</p><p>湖南省湖北省属于中部内陆省份，我自己在湖南长沙读书，虽然博物馆没有二刷，但是对于这两座城市还是熟悉一些，湖南省博物馆是 17 年左右刚刚修缮好的阔别五年再度向公众开放，外观好像有独特意义，我记不大清了。湖北省博物馆也是从旧馆迁移至新馆，外观高台基、大坡面屋顶莫名让我想起了其中的镇馆之宝曾侯乙编钟（随便乱想的）。</p><p>如果想了解湖南省博物馆“闭关五年”做了些什么以及新世纪以来湖南考古发现，新发现陈列也是一个值得参观学习的地方。</p></li><li><p>推介理由</p><p>两个博物馆都是颇有历史，经历迁移或者重新修缮焕然一新的新馆。对于长江中下游的文化，春秋战国时期楚/吴/越文化有着详尽的介绍，爱好这方面历史的同学不要错过了。不过可惜的是两馆对于文物的科普讲解并不是非常详尽，当然，对特色文物照顾还是非常到位的，湖北省博物馆对曾侯乙编钟编磬的介绍不可谓不详尽，音律知识、演奏方法甚至都有介绍，电子语音导览还可以听一首古编钟的曲子。而湖南省博物馆则是通过灯光把千年女尸以及素纱褝衣的材质特点展现到极致。</p><p>特色文物</p><p>湖北省博物馆：越王勾践剑、曾侯乙编钟编磬。</p><p>湖南省博物馆：（以马王堆出土文物为主）汉墓 T 形帛画，素纱褝衣。</p></li><li><p>周边景点</p><p>湖北省博：湖北省美术馆、汉阳造文化产业区、江汉关博物馆、湖北省图书馆<br>湖南省博：三观一厅区域（长沙市博物馆、长沙市城市规划馆、长沙市图书馆、长沙市音乐厅）、简牍博物馆、太平老街、解放西（长沙酒吧文化一条街）</p></li></ol>]]></content>
    
    
    <categories>
      
      <category>Life</category>
      
      <category>旅行</category>
      
    </categories>
    
    
    <tags>
      
      <tag>旅行</tag>
      
      <tag>博物馆</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>2019-07-08广东省游记</title>
    <link href="/post/8886f58d.html"/>
    <url>/post/8886f58d.html</url>
    
    <content type="html"><![CDATA[<h1 id="抵达"><a href="#抵达" class="headerlink" title="抵达"></a>抵达</h1><p>出发前两天在长沙定了住宿火车票和机票，预计在广州市停留两天、深圳停留三天、香港一天之后返程。</p>]]></content>
    
    
    <categories>
      
      <category>Life</category>
      
      <category>旅行</category>
      
    </categories>
    
    
    <tags>
      
      <tag>旅行</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>操作系统学习——Linux基础学习篇（第6章）</title>
    <link href="/post/4309bc34.html"/>
    <url>/post/4309bc34.html</url>
    
    <content type="html"><![CDATA[<h1 id="第-0-章-Linux-的文件权限和目录配置"><a href="#第-0-章-Linux-的文件权限和目录配置" class="headerlink" title="第 0 章 Linux 的文件权限和目录配置"></a>第 0 章 Linux 的文件权限和目录配置</h1><h1 id="用户与用户组"><a href="#用户与用户组" class="headerlink" title="用户与用户组"></a>用户与用户组</h1><p><strong>用户</strong>：由于 Linux 被设计为一个多用户、多任务的系统，用户概念在 Linux 中极为重要。</p><p><strong>文件所有者</strong>：为了应对多人工作环境，分离不同用户的工作环境，设置了文件的归属权（文件所有者的角色）。</p><p><strong>用户组</strong>：团队开发协作的需要，在用户概念之上设置了用户组的权限管理级别。每组成员相对而言更易互相修改对方的数据，但是其他组的组员则不能看到本组的文件内容。</p><h1 id="Linux-文件权限概念"><a href="#Linux-文件权限概念" class="headerlink" title="Linux 文件权限概念"></a>Linux 文件权限概念</h1><h2 id="Linux-文件属性"><a href="#Linux-文件属性" class="headerlink" title="Linux 文件属性"></a>Linux 文件属性</h2><p>执行命令</p><pre><code class="hljs bash">ls -al</code></pre><p>会得到下面的结果</p><p><img src="https://eddyblog.oss-cn-shenzhen.aliyuncs.com/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F%E5%AD%A6%E4%B9%A0Linux%E5%9F%BA%E7%A1%80%E5%AD%A6%E4%B9%A0%E7%AF%87/6.1.png" srcset="/img/loading.gif" alt="6.1"></p><ol><li><p>第一列代表文件权限（permission）</p><p>第一个字符</p><ul><li>[d]表示目录</li><li>[-]表示文件</li><li>[l]表示链接文件（linkfile）</li><li>[b]表示可控存储的接口设备</li><li>[c]表示串行端口设备</li></ul><p>后面字符三个一组</p><ul><li>[r]表示可读</li><li>[w]表示可写</li><li>[x]表示可执行</li><li>第一组为文件所有者权限、第二组为同用户组权限、第三组为其他非本用户组的权限。</li></ul></li><li><p>第二列表示有多少文件名连接到此节点（i-node）</p></li><li>第三列表示这个文件的所有者账号</li><li>第四列表示这个文件所属的用户组</li><li>第五列表示文件大小（默认为 B）</li><li>第六列表示文件创建日期或者最近修改日期</li><li>第七列表示文件名</li></ol><h2 id="改变文件属性和权限"><a href="#改变文件属性和权限" class="headerlink" title="改变文件属性和权限"></a>改变文件属性和权限</h2><p>三个命令</p><ol><li><p>chgrp 改变文件所属的用户组</p><pre><code class="hljs bash">chgrp [-R] 账号名称：组名 文件或目录</code></pre><p>-R 参数表示是否要递归改变子目录下的所有文件</p></li><li><p>chown 改变文件所有者</p><pre><code class="hljs bash">chown [-R] 账号名称：组名 文件或目录</code></pre><p>-R 参数同上</p></li><li><p>chmod 改变文件的权限</p><ul><li><p>数字修改</p><pre><code class="hljs bash">chmod xxx 文件目录</code></pre><p>将三端权限二进制化（比如 777 就表示权限全开）</p></li><li><p>符号修改</p><pre><code>    | 命令 | 组对象 | 操作符 | 权限 | 文件名 |    | :-----: | :-----: | :-----: | :-----: | :-------: |    | chmod | u g o a | + - = | r w x | 文件或目录 |    eg    <pre><code class="hljs bash">chmod u+r,o=rwx  xxx</code></pre></code></pre><a id="more"></a></li></ul></li></ol><h2 id="目录与文件的权限意义"><a href="#目录与文件的权限意义" class="headerlink" title="目录与文件的权限意义"></a>目录与文件的权限意义</h2><ol><li><p>对文件的意义</p><ul><li>r(read)表示可以读此文件的具体内容</li><li>w(write)表示可以编辑、新增或是修改文件的内容（但不含删除）</li><li>x(execute)表示可以被系统执行的权限</li></ul></li><li><p>对目录的意义</p><ul><li>r 表示可以读取目录结构权限，可以查询到文件名数据，也可以利用<code>ls</code>命令来获取列表内容的显示</li><li>w 表示可以<strong>新建文件/目录，删除已经存在的文件和目录（无视此文件/目录的），重命名，转移文件/目录的位置</strong>。（也即，删除一个文件的权限是跟是否具备此文件所在目录的写权限有关，而跟文件本身权限无关）</li><li>x 表示是否可以进入该目录成为工作目录（working directory）的权限。</li></ul></li></ol><h2 id="Linux-文件种类与扩展名"><a href="#Linux-文件种类与扩展名" class="headerlink" title="Linux 文件种类与扩展名"></a>Linux 文件种类与扩展名</h2><h3 id="文件种类"><a href="#文件种类" class="headerlink" title="文件种类"></a>文件种类</h3><p>普通文件、纯文本文件（cat 的文件）、二进制文件、数据格式文件</p><p>目录（d）</p><p>连接文件（l）类似 Windows 下面的快捷方式</p><p>设备与设备文件（device）：通常在/dev 这个目录，通常分为两种：</p><ol><li><p>块（block）设备文件</p><p>一些存储数据供系统随机访问的接口设备，例如硬盘等。</p></li><li><p>字符（character）设备文件</p><p>一些串行端口接口设备，特征是一次性读取，不能够截断输出。</p></li></ol><p>套接字（socket）：网络进程通信，通常在/var/run 中</p><p>管道（FIFO，pipe）：解决多个程序同时访问一个文件造成的错误问题</p><h3 id="文件扩展名"><a href="#文件扩展名" class="headerlink" title="文件扩展名"></a>文件扩展名</h3><p>只是以适当的扩展名来表示是什么种类，而实际能否运行依赖数据+execute 执行权限（这一点和 Windows 判断可执行程序有很大的不同）。</p><p><code>*.sh</code>：脚本或批处理文件，主要用 shell 写。</p><p><code>*Z</code>、<code>*.tar</code>、<code>*.tar.gz</code>、<code>*.zip</code>等：压缩文件，由不同压缩软件使用决定。</p><p><code>*.html</code>等：网页相关文件</p><p>长度限制：默认使用 Ext2/Ext3 文件系统，单一文件名/目录名限制长度为 255 字符、包含完整路径名称及目录的完整文件名为 4096 个字符。</p><h2 id="Linux-目录配置"><a href="#Linux-目录配置" class="headerlink" title="Linux 目录配置"></a>Linux 目录配置</h2><h3 id="Linux-目录配置标准：FHS"><a href="#Linux-目录配置标准：FHS" class="headerlink" title="Linux 目录配置标准：FHS"></a>Linux 目录配置标准：FHS</h3><ul><li>/ (root，根目录)，与开机系统有关</li><li>/usr （UNIX software resource）：与软件安装/执行有关</li><li>/var （variable）：与系统运作过程有关</li></ul><p>其他详情可以自行百度，或者查看目录树（单独再找机会整理一下）</p><h3 id="绝对路径与相对路径"><a href="#绝对路径与相对路径" class="headerlink" title="绝对路径与相对路径"></a>绝对路径与相对路径</h3><p>区别<code>/var/log</code>（绝对路径）和<code>../var/log</code>（相对路径）</p><blockquote><p>网络文件常常提到类似“。/run.sh”的数据，这个命令的意义是什？</p><p>答：由于命令执行需要变量（bash 章节会提及）的支持，若执行文件放置在本目录并且本目录并非正规的执行文件目录（/bin、/usr/bin 等为正规），此时要执行命令就要严格指定该执行文件。“./”代表“本目录”的意思，所以“./run.sh”代表执行本目录名下的 run.sh 文件</p></blockquote><p>END</p>]]></content>
    
    
    <categories>
      
      <category>Computer Science</category>
      
      <category>操作系统</category>
      
    </categories>
    
    
    <tags>
      
      <tag>操作系统</tag>
      
      <tag>Linux</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>密码技术学习——密码学课程PPT复习提纲</title>
    <link href="/post/b94eea64.html"/>
    <url>/post/b94eea64.html</url>
    
    <content type="html"><![CDATA[<h1 id="CSU密码学课程独门复习提纲"><a href="#CSU密码学课程独门复习提纲" class="headerlink" title="CSU密码学课程独门复习提纲"></a>CSU密码学课程独门复习提纲</h1><p>易考点，并不是“真正意义上”密码学的重点（页数P是按4张PPT一页来的）。</p><h1 id="第一部分-引言"><a href="#第一部分-引言" class="headerlink" title="第一部分 引言"></a>第一部分 引言</h1><ol><li>P4 信息安全定义（Information Security）</li><li>P4 密码学定义（Cryptography）</li><li>五类安全服务（认证鉴别服务、访问控制服务、数据保密性服务、数据完整性服务、抗否认服务）（又名：进不来、拿不走、看不懂、改不了、跑不了）</li><li>P7 安全服务与密码技术的关系（表格）。</li></ol><h1 id="第二部分-密码学概述（古典密码）"><a href="#第二部分-密码学概述（古典密码）" class="headerlink" title="第二部分 密码学概述（古典密码）"></a>第二部分 密码学概述（古典密码）</h1><ol><li>P9 理论安全与时间全（香农信息论，资源与运算力限制）</li><li>P9 四种基本攻击类型</li><li>P10 对称密码与公钥密码各自的特点</li><li>P12 几个同余式的定理（运算性质）</li><li>P16 仿射密码的攻击</li><li><strong>P17 维吉尼亚密码特征（弱点、攻击方式）</strong></li></ol><h1 id="第三部分-现代密码算法"><a href="#第三部分-现代密码算法" class="headerlink" title="第三部分 现代密码算法"></a>第三部分 现代密码算法</h1><h2 id="数学基础"><a href="#数学基础" class="headerlink" title="数学基础"></a>数学基础</h2><ol><li>P21 当$p$为素数时候，模$p$的简化剩余系是一个交换乘群。</li><li>P22 模、剩余系、完全/简化剩余系的概念</li><li>P23 欧拉函数、欧拉定理、费马小定理</li><li>P24 阶、原根定义（利用原根的阶简化计算）</li><li>P24 原根是否存在的充要条件 $n=2,4,p^e,2p^e$ 其中$e≥1$，$p$为素数</li><li>P25 快速指数算法</li><li><strong>P27 置换群、完美洗牌（从2开始交叉插入） $f(x) = 2x \% (2n+1)$</strong></li></ol><h2 id="对称密码算法"><a href="#对称密码算法" class="headerlink" title="对称密码算法"></a>对称密码算法</h2><ol><li><strong>P33 DES和IDEA比较（分组位数、轮数、子密个数等）</strong></li><li><strong>P34 P38 AES总结（分组位数、轮数、子密钥个数等）</strong></li><li>P39 序列密码与分组密码对比（加密方式）</li><li><strong>P47 Hash函数性质</strong></li><li>P47 MD5与SHA函数对比</li><li><strong>P48经典对称密码算法的特点</strong></li></ol><h2 id="公钥密码算法"><a href="#公钥密码算法" class="headerlink" title="公钥密码算法"></a>公钥密码算法</h2><ol><li>P49 公钥密码算法概述</li><li><strong>P50 BSGS算法求离散对数问题，同余方程求解</strong></li><li><strong>P51 CRT</strong></li><li>P52 二次同余方程、二次符号定理、性质</li><li><strong>P53 二次互反定理（$p,q$均为素数的时候判定二次同余方程是否有解加快速度）</strong></li><li>P55 P56 素数生成与素性检测算法</li><li>P57 RSA算法（算法描述、攻击方法、中间人、共模攻击）</li><li>P60 EIGamal算法（选取k的好处、同密文、发送者多次发送不冲突，对比RSA）</li><li>P61 ECC算法</li><li>P62 背包算法（超递增背包-&gt;普通背包 加密）</li><li><strong>P63 公钥密码算法各种比较</strong></li></ol><h2 id="签名算法（这里分类有点迷）"><a href="#签名算法（这里分类有点迷）" class="headerlink" title="签名算法（这里分类有点迷）"></a>签名算法（这里分类有点迷）</h2><ol><li>P65 RSA签名（密钥使用不当，攻击方式）</li><li>P66 DSA算法</li><li><strong>P67 左上签名算法小结</strong></li></ol><h1 id="第四部分-基本密码协议"><a href="#第四部分-基本密码协议" class="headerlink" title="第四部分 基本密码协议"></a>第四部分 基本密码协议</h1><ol><li>P68 密码协议分类（仲裁者裁决者分别对应）</li><li>P70 保密通信协议（公钥密码的中间人攻击、改进方法）</li><li>P73 密钥协商协议（对称+仲裁者、公钥、DH的中间人、EKE的优势看左半面、椭圆曲线DH、双线性对）</li><li><strong>P73 密钥协商协议总结</strong></li><li>P78 数字签名协议形式化描述（对称、公钥）</li><li>P79 阈下信道</li><li>P81 身份鉴别协议（SKEY协议单向链、双向鉴别）</li><li>P83 秘密共享协议（门限分案、Shamir、Bloom）</li></ol><h1 id="第五部分-中级密码协议"><a href="#第五部分-中级密码协议" class="headerlink" title="第五部分 中级密码协议"></a>第五部分 中级密码协议</h1><ol><li><strong>P88 Shamir三次传输协议（异或的问题，不需要共享密钥）</strong></li><li><strong>P88 不经意传输协议（利用上面的、选哪个不知道系列）</strong></li><li>P88 （不考）智力扑克协议</li><li>P89 安全多方计算举例子，理解，盲因子</li><li>P92 密钥分发协议（加入/不加入会话密钥）</li><li>P93 基于CRT密钥分发协议+<strong>总结</strong></li></ol><h1 id="第六部分-高级密码协议"><a href="#第六部分-高级密码协议" class="headerlink" title="第六部分 高级密码协议"></a>第六部分 高级密码协议</h1><p>懂概念、小题</p><ol><li>P94 <strong>零知识协议目的</strong></li><li>P95 盲签名协议（理解）</li><li>P95 同时签约协议（应用不经意传输，理解）</li><li>P97 匿名投票协议图示（可能考）+匿名通信协议（不考）</li><li>P99 数字现金协议图示（理解）</li></ol><h1 id="第七部分-分组密码加密模式"><a href="#第七部分-分组密码加密模式" class="headerlink" title="第七部分 分组密码加密模式"></a>第七部分 分组密码加密模式</h1><p>融入其中了，要考可能只靠特点</p><ol><li>P103 四种模式总结表格</li></ol><h1 id="第八部分-密钥管理"><a href="#第八部分-密钥管理" class="headerlink" title="第八部分 密钥管理"></a>第八部分 密钥管理</h1><ol><li>P105 P106 密钥生命周期内：生成与密钥更新（安全性、哈希生成新密钥）</li><li><strong>P106 P107 Kerberos最后一节课特别强调</strong></li><li>P108 数字证书概述</li><li></li></ol>]]></content>
    
    
    <categories>
      
      <category>Computer Science</category>
      
      <category>密码学</category>
      
    </categories>
    
    
    <tags>
      
      <tag>密码学</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>操作系统学习——Linux基础学习篇（第1章）</title>
    <link href="/post/86ae82ba.html"/>
    <url>/post/86ae82ba.html</url>
    
    <content type="html"><![CDATA[<h1 id="第-1-章-Linux-是什么"><a href="#第-1-章-Linux-是什么" class="headerlink" title="第 1 章 Linux 是什么"></a>第 1 章 Linux 是什么</h1><p><strong>Linux 就是一套操作系统</strong>，内核+系统调用。</p><blockquote><p>Windos 操作系统本来就是针对个人计算机 x86 架构的硬件设计的，所以只能在 x86 的个人计算机上运行，在不同平台上无法运行。而 Linux 是开源系统，也可以（事实上基本上已经）被修改成适合在各种机器上面运行的，也就是说，Linux 是具有“可移植性”，是很重要的不同点。</p></blockquote><h1 id="UNIX-历史"><a href="#UNIX-历史" class="headerlink" title="UNIX 历史"></a>UNIX 历史</h1><ul><li>1973 年：UNIX 正式诞生</li><li>1977 年：重要的 UNIX 分支——BSD 诞生</li><li>1979 年：重要的 System V 架构与版权声明</li><li>1984 年之一：x86 架构的 Minix 操作系统诞生</li><li>1984 年之二：GNU 项目与 FSF 基金会成立<ul><li>GNU 相关的一些产出：Emacs 程序编辑器、GCC（GNU C Compiler）、GNU 通用公共许可证（GPL）、bash shell 基本接口</li></ul></li><li>1988 年：图形接口 XFree86 项目（非营利性，后被集成到 Linux 操作系统中）</li><li>1991 年：芬兰大学生 Linus Torvalds 的一则消息<ul><li>BBS 上贴出宣称以 bash，gcc 等工具写了一个小小的内核程序，这个内核程序可以在 Intel 的 386 机器上面运行，然很多人感兴趣，从此开始了 Linux 不平凡的旅程。</li></ul></li></ul><h1 id="关于-GNU-项目"><a href="#关于-GNU-项目" class="headerlink" title="关于 GNU 项目"></a>关于 GNU 项目</h1><p>待补充</p><h1 id="Linux-的内核版本"><a href="#Linux-的内核版本" class="headerlink" title="Linux 的内核版本"></a>Linux 的内核版本</h1><ul><li><p>主、次版本为奇数：开发中版本（development）</p><p>如 2.5.xx，这种内核版本主要用在测试和开发新功能，所以通常这种版本仅有内核开发工程师会使用，如果有新增的内核程序代码，会加到这种版本中</p></li><li><p>主、次版本为偶数：稳定版本（stable）</p><p>如 2.6.xx，等到内核功能开发成熟后会加到这类的版本，主要用在一般家庭计算机以及企业版本中。重点在于提供用户一个相对稳定的 Linux 作业环境平台。</p></li></ul><p>区分内核版本（Linux 版本多少）以及发行版本（Linux Ubuntu/CentOS distribution 版本多少）。</p><h1 id="Linux-distribution"><a href="#Linux-distribution" class="headerlink" title="Linux distribution"></a>Linux distribution</h1><p>“Kernel+Softwares+Tools”的可完全安装的系统，称为 Linux distribution</p><p>各大 Linux Distributions 的主要异同：支持标准。</p><p>一些标准和规范：Linux Standard Base（LSB）以及目录架构 File system Hierarchy Standard（FHS）</p><h1 id="Linux-的优缺点"><a href="#Linux-的优缺点" class="headerlink" title="Linux 的优缺点"></a>Linux 的优缺点</h1><ul><li><p>稳定的系统</p><p>基于 UNIX 概念开发出来的，有相似的程序接口和操作方式，也继承了稳定性效率高的特点。</p></li><li><p>免费或少许费用</p><p>基于 GPL 授权下的产物，因此任何人皆可自由取得 Linux，不需要负担很大的版权费用。</p></li><li><p>安全性、漏洞的快速修补</p><p>由于有强大的社区、热心团体、个人参与其中开发，因此可以随时获得最新的安全信息，并随时更新，相对较安全。</p></li><li><p>多任务、多用户</p><p>不同于 Windows 系统的单人多任务，Linux 可以在一部主机上划分不同等级的用户并且每个用户登录系统的时候工作环境都可以不同。</p></li><li><p>用户与用户组的规划</p></li><li>相对比较不耗资源</li><li>适合需要小内核程序的嵌入式系统</li><li>整合度佳且多样的图形用户界面（GUI）</li></ul><h1 id="关于授权"><a href="#关于授权" class="headerlink" title="关于授权"></a>关于授权</h1><p>待补充</p><a id="more"></a>]]></content>
    
    
    <categories>
      
      <category>Computer Science</category>
      
      <category>操作系统</category>
      
    </categories>
    
    
    <tags>
      
      <tag>操作系统</tag>
      
      <tag>Linux</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>操作系统学习——Linux基础学习篇（第0章）</title>
    <link href="/post/20d9890e.html"/>
    <url>/post/20d9890e.html</url>
    
    <content type="html"><![CDATA[<p>这个系列主要是依赖《鸟哥的 Linux 私房菜》一本书，记录自己的学习过程以及笔记。</p><h1 id="第-0-章-计算机概论"><a href="#第-0-章-计算机概论" class="headerlink" title="第 0 章 计算机概论"></a>第 0 章 计算机概论</h1><h1 id="计算机"><a href="#计算机" class="headerlink" title="计算机"></a>计算机</h1><h2 id="计算机组成单元"><a href="#计算机组成单元" class="headerlink" title="计算机组成单元"></a>计算机组成单元</h2><p>计算机硬件五大单元：<strong>输入单元</strong>，<strong>输出单元</strong>，<strong>控制单元</strong>，<strong>算术逻辑单元</strong>，<strong>存储单元</strong>，联系学过的计算机组成原理，实际上对应的就是计算机组成原理里的内容。输入、输出、控制器、运算器、存储器（主要指内存）。而控制器运算器构成 CPU，CPU 与存储器称为主机（实际上还包含输入输出的接口），在本书中称为系统单元，而与此相对的是外围设备（输入输出外存）。</p><h2 id="CPU-种类"><a href="#CPU-种类" class="headerlink" title="CPU 种类"></a>CPU 种类</h2><p>根据微指令集的划分</p><ul><li>精简指令集 Reduced Instruction Set Computer RISC<ul><li>这种 CPU 设计中，微指令集较为精简，每个指令的执行时间都很短，完成的操作也很单纯，指令的执行性能较佳，但要做复杂的事情就要多条来完成。常见：SPARC 系列、Power Architecture 系列、ARM 系列。</li><li>应用方面，比如索尼的 PS3 应用的是 PowerPC 架构的 Cell 处理器，ARM 更是常见</li></ul></li><li>复杂指令集 Complex Instruction Set Computer CISC<ul><li>每个小指令可以执行一些低阶的硬件操作，指令数目多、复杂、长度并不相同，因为复杂所以耗时长一些，但个别指令可以处理的工作较为丰富。常见：AMD、Intel、VIA 等 x86 架构的 CPU。</li><li>由于 AMD、Intel、VIA 所开发出来的 x86 架构 CPU 被大量用于 PC 机上，个人计算机常被称为 x86 架构计算机。来源就是因为最早的 Intel 开发出来的 CPU 代号为 8086，后来又有 80286，80386，就被称为 x86 了。</li><li>在 2003 年以前由 Intel 所开发的 x86 架构 CPU 由 8 位升级到 16 位、32 位、后来 AMD 又依次架构修改新一代 CPU 位 64 位，为了区别两者的不同，因此 64 位的个人计算机 CPU 又被称为 x86_64 的架构。</li><li>不同的 x86 架构 CPU 的区别：整体结构（二层缓存、每次可执行的指令数）、微指令集（针对不同特性发展各异）。</li></ul></li></ul><blockquote><ul><li>多媒体微指令集：MMX，SSE，SSE2，SSE3，SSE4，AMD-3DNow!</li><li>虚拟化微指令集：Intel-VT，AMD-SVM</li><li>省电功能：Intel-SpeedStep，AMD-PowerNow!</li><li>64/32 位兼容技术：AMD-AMD64，Intel-EM64T</li></ul></blockquote><a id="more"></a><h1 id="个人计算机架构与接口设备"><a href="#个人计算机架构与接口设备" class="headerlink" title="个人计算机架构与接口设备"></a>个人计算机架构与接口设备</h1><p>Linux 早期也根据个人计算机的架构发展来的，所以真的需要了解一下。</p><p>Intel 主板架构，最重要的是芯片组，芯片组常被分为两个桥接器来控制各组件的通信，分别是：</p><ul><li>北桥负责连接速度较快的 CPU、内存与显卡组建。</li><li>南桥负责连接速度较慢的周边接口。</li></ul><p>AMD 主板架构，内存直接与 CPU 通信而不通过北桥，AMD 为了加速两者的通信，将内存控制组件集成到 CPU 当中，这样可以加速两者的传输速度。</p><p>根据设计不同选择了不同的总线架构。</p><h2 id="CPU"><a href="#CPU" class="headerlink" title="CPU"></a>CPU</h2><p>主流的都是双核已上架够了，实际上是在一个 CPU 中封装了多个运算内核。</p><p>CPU 频率是指 CPU 每秒钟可以进行的工作次数。</p><blockquote><p>由于不同 CPU 微指令集不同，每次频率可以进行的指令数也不同，不能直接以频率论高低，严谨的说目前只能来比较同款 CPU 的速度。</p></blockquote><ul><li>外频：CPU 与外部组件进行数据传输/运算时的速度。</li><li>倍频：CPU 内部用来加速工作性能的一个倍数，相乘才是 CPU 的频率。</li></ul><p>一般出厂固定倍频，超频玩家常通过超频外频达到提升 CPU 的频率。</p><h2 id="主板上的-BIOS"><a href="#主板上的-BIOS" class="headerlink" title="主板上的 BIOS"></a>主板上的 BIOS</h2><p>CMOS 主要功能为记录主板上的重要参数，包括系统时间、CPU 电压与频率、各项设备的 IO 地址与 IRQ，由于这些数据的记录要花费电力，因此主板上面才有电池。</p><p>BIOS 为写入到主板某一块山村或 EEPROM 的程序，它可以在开机的时候执行，以加载 CMOS 当中的参数，并尝试调用存储设备中的开机程序，进一步进入到操作系统当中。</p><h1 id="软件程序运行"><a href="#软件程序运行" class="headerlink" title="软件程序运行"></a>软件程序运行</h1><p>“我们知道没有插电的计算机是一堆废铁，那么插了电的计算机是什么？”</p><p>“一堆会电人的废铁。”</p><p>计算机需要软件：系统软件+应用软件。</p><p>为了要克服硬件方面总是需要重复编写句柄的问题，所以就产生了操作系统（Operating System，OS），事实上，OS 伴随计算机发展一直都存在，从提高 CPU 运算速率到资源管理到方便用户使用，一直是计算机必备的软件。</p><h2 id="操作系统"><a href="#操作系统" class="headerlink" title="操作系统"></a>操作系统</h2><ul><li><p>操作系统内核（Kernel）</p><p>Kernel 主要在于管控硬件与提供相关的能力（如网络功能），避免用户直接操作，<strong>内核在内存中放置的区块是受保护的，并且开机后就一直常驻在内存当中</strong></p></li><li><p>系统调用（System Call）</p><p>遵循内核的规定，从参考硬件变成了参考内核功能。操作软件通常会提供一整组开发接口（API）给工程师开发软件，这就是系统调用层。</p></li><li><p>一些点</p><ul><li>操作系统内核直接参考硬件规格写成</li><li>操作系统只是在管理</li><li>应用程序都是参考对应的操作系统开发接口</li></ul></li></ul>]]></content>
    
    
    <categories>
      
      <category>Computer Science</category>
      
      <category>操作系统</category>
      
    </categories>
    
    
    <tags>
      
      <tag>操作系统</tag>
      
      <tag>Linux</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>密码技术学习——基于RSA的不可否认签名方案</title>
    <link href="/post/6028c50e.html"/>
    <url>/post/6028c50e.html</url>
    
    <content type="html"><![CDATA[<p>本文主要内容主要来自Chaum van Antwerpen在89年发表的《Undeniable Signatures》一文以及Gennaro、Krawczyk和Rabin在97年发表的《RSA-Based Undeniable Signatures》一文，用来了解不可否认签名方案的相关知识。</p><h1 id="介绍"><a href="#介绍" class="headerlink" title="介绍"></a>介绍</h1><h2 id="背景介绍"><a href="#背景介绍" class="headerlink" title="背景介绍"></a>背景介绍</h2><p>数字签名的复制属性不同于我们现实生活中的签名文件，在不考虑时间戳的前提下，我们基本上可以认为复制签名和原始签名是相同的。这种极易复制的性质在很多场合下是有利的，比如带签名公告的分发，开源软件的认证，这种性质多要求带签名的副本对分发无抵抗要求（甚至是希望分发）。</p><p>但它不适合许多其他应用程序。对于在某种程度上对个人或商业敏感的所有书面或口头承诺的电子替代品。 在这种情况下，经核证的副本的扩散可能会导致勒索，或者工业间谍的非法利用。这种承诺的接受者当然应该能够确保发行人以后不能否认它，但未经发行人同意，接收方也不能向其他任何人展示承诺。</p><p>不可否认的签名非常适合这种应用程序。不可否认签名(如数字签名)是由签名者发出的数字，它取决于签名者的公钥和签名的消息。然而，与数字签名不同的是，不可否认的签名如果没有签名者的合作是无法验证的。</p><h2 id="不可否认签名"><a href="#不可否认签名" class="headerlink" title="不可否认签名"></a>不可否认签名</h2><p>不可否认签名概念由Chaum和van Antwerpen在[1]（89年）首先提出。它拓展了普通签名的概念，使用强不可否认性，且对签名的验证要求在签署者（证明者）的参与下完成。这以性质有效的防止了带签名的有价值文件的多次拷贝分发的滥用情况，在一些特殊场合下起到了作用。下面具体说明不可否认性质的含义以及不可否认签名的应用。</p><h3 id="不可否认性质"><a href="#不可否认性质" class="headerlink" title="不可否认性质"></a>不可否认性质</h3><p>不可否认性质包括两层含义：</p><blockquote><ol><li>签名的证实和否定必须与签名者合作完成，这一点可以有效地防止一些有价值文件被随意的复制或分发；</li><li>签名者不能抵赖它曾签过的签名，由于他曾签过的签名可以通过拒绝执行证实协议来否认他曾签过的签名，为了防止此类事件发生，不可否认签名增加了一个否认协议，签名者可以利用否认协议证明一个伪造的签名是假的；而如果签名者拒绝执行否认协议，就表明签名事实上是由他签署的。</li></ol></blockquote><p>论文中提出基于RSA的第一个不可否认的签名方案。 自1989年引入以来，大量工作一直致力于研究不可否认的签名。 到目前为止，这项工作一直基于离散对数系统。 相反，我们的方案使用常规RSA签名来生成不可否认的签名。 在这个新设置中，RSA的签名和验证指数都由签名者保密，而公钥由单个公共消息上的复合模数和样本RSA签名组成。</p><p>我们的方案具有一些吸引人的特性：首先是可证明的安全性，伪造不可否认的签名与伪造常规RSA签名一样困难。其次，确认和拒绝协议都是零知识（特别是，确认协议仅涉及两轮通信和少量取幂）。此外，我们的方案的基于RSA的结构提供了<strong>简单而优雅</strong>的解决方案，以提供最初引入不可否认签名的文献中发现的不可否认签名的几个<strong>更高级的属性</strong>，包括不可否认签名的可转换性（转换为可公开验证的签名），委托确认能力的可能性，拒绝签名给第三方而不放弃签署的权力，以及签名和确认操作的分布式（阈值）版本的存在。</p><p>由于上述属性以及我们的不可否认的签名与标准RSA签名相同的事实，我们提出的方案对于实际实现来说，它变得非常有吸引力。</p><a id="more"></a><h1 id="预备知识"><a href="#预备知识" class="headerlink" title="预备知识"></a>预备知识</h1><p><img src="https://eddyblog.oss-cn-shenzhen.aliyuncs.com/%E5%AF%86%E7%A0%81%E5%AD%A6/rsa_udc1.png" srcset="/img/loading.gif" alt="1"></p><p>引理 1：</p><p>令 $n=pq$，且$p&lt;q$，$p=2p’+1$，$q=2q’+1$，$p$，$q$，$p’$，$q’$均为质数，则：</p><ol><li>$Z_n^{*}$中的任意元素的阶均在集合$\{1,2,p’,q’,2p’,2q’,p’q’,2p’q’\}$中。</li><li>对于给定的$w$满足$w \in Z_n^{*} \setminus \{ -1 , 1 \}$，且$ord(w)&lt;p’q’$，则$gcd(w-1,n)$或$gcd(w+1,n)$是n的一个素因子。</li></ol><p><img src="https://eddyblog.oss-cn-shenzhen.aliyuncs.com/%E5%AF%86%E7%A0%81%E5%AD%A6/rsa_udc2.png" srcset="/img/loading.gif" alt="2"></p><p>引理 2：</p><p>令$n$同引理1中规定，对于给定的$w$满足$ord(w) \in \{ p’q’, 2p’q’ \}$，则对于任意$m \in Z_n^{*}$ , $m^4 \in \langle w \rangle$</p><h1 id="新的不可否认签名方案"><a href="#新的不可否认签名方案" class="headerlink" title="新的不可否认签名方案"></a>新的不可否认签名方案</h1><p>在这一节，我们给出我们方案的细节，首先我们定义如下集合。</p><script type="math/tex; mode=display">N= \{ n | n = pq, p<q , p = 2 p'+1, q= 2q'+1\}</script><p>其中$p$，$q$，$p’$，$q’$均为质数。该系统由签名者根据通过以下方式设置。从该集合里随机选取一个元素$n$，选择$e,d \in [ \varphi(n) ]$, 满足$ed \equiv 1 \mod { \varphi (n) }$；选择一对$(w,S_w)$满足$w \in Z_n^{*}, w \not ={1} , S_w = w^{d} \mod {n}$，公钥参数为$(n,w,S_w)$，私钥参数为$(e,d)$,</p><p>我们用$PK$表示所有按照上述方法生成的$(n,w,S_w)$元组。关于公钥形式的选择以及如何验证其正确性，请参见4.3节。特别地，这里体现出，$w$可以被设置为一个固定的值。比如总是设置为$w = 2$，这种简化提高了公钥系统计算以$w$为基数的幂的效率。</p><h2 id="生成一个签名"><a href="#生成一个签名" class="headerlink" title="生成一个签名"></a>生成一个签名</h2><p>为了在消息上生成签名，签名者执行常规RSA签名操作，即，他计算$S_m = m^{d} \mod {n}$，得到输出$(m, S_m)$，更准确地说，在应用求幂之前首先通过合适的编码（比如通过单向哈希函数）处理消息，使得生成的签名方案面对选择明文攻击依旧可以假定是不可伪造的（需要说明，普通RSA没有这个属性）。给定一个消息$m$，我们认为$\overset{\rm -}{m}$为编码输出后的消息，因此，$S_{\overset{\rm -}{m} } \overset{\rm def}{=} {\overset{\rm -}{m}}^{d}$，我们稍稍泛用了$S_w$来表示$w^{d} \mod {n}$，且用$w$而非$\overset{\rm -}{w}$。</p><h2 id="确认协议"><a href="#确认协议" class="headerlink" title="确认协议"></a>确认协议</h2><p>我们提出了一个确认签名的协议。 它由两个玩家，证明者和验证者执行。 协议的公共输入是公钥参数，即$(n,w,S_w) \in PK$，以及$(m,S_m)$。如果$S_m$是有效签名，则$P$将可以说服$V$这个事实，反之如果不是有效的，则除了一个微不足道的概率，没有任何证明者（即使是一个计算上无界的证明者）能够让$V$相信这个签名是有效的。</p><p><img src="https://eddyblog.oss-cn-shenzhen.aliyuncs.com/%E5%AF%86%E7%A0%81%E5%AD%A6/rsa_udc3.png" srcset="/img/loading.gif" alt="3"></p><p>协议的想法是产生一个相关的元素，该元素对签名者来说是随机的，并且验证者签名（假设消息$m$上的签名是正确的）。 这个“盲”元素是通过消息$m$取$i$次幂来创建的，以及他的（正确的签名是公知的）。 直观地说，作弊证明者需要找到作为骗子的价值。 然而，有许多指数给出了相同的结果，并且我们证明了证明者（即使计算上无界）也无法区分它们。</p><p>该协议的一个有趣的方面是证明者可以成功说服验证者接受签名，多一个参数的签名多个签名，在设计拒绝协议时，我们确保签名者不能拒绝此扩展形式的签名，$SIG(m) \overset{\rm def}{=} \alpha \overset{\rm -}{m}^{d}, ord(\alpha) ≤ 2$.</p><p>为了便于说明，确认协议出现了零知识协议版本，有一些众所周知的技术[GMW]，[BCC]，[Go]使用概念函数的概念将零知识属性添加到上述协议：</p><p>在第2步中，$P$，不再发送$A$而是发送一个承诺$commit(A)$，当$V$向$P$揭示$i,j$的值时，在检查$Q \overset{\rm def}{ = } {S_m^{2i}}{S_w^{j}} \mod n$，$P$再将$A$告诉$V$，则验证者检查$A$是否符合之前的承诺，然后进行上述协议的第三步。</p><p>通过承诺函数的性质实现零知识条件，即</p><ol><li>$commit(x)$不反应关于$x$的任何信息（对破译有用处的任何信息）</li><li>$P$不能找到$x’$使得$commit(x) = commit(x’)$</li></ol><p>承诺函数可以通过多种方式实现，比如简单的用语义安全的RSA加密$A$，而验证者不知道私钥，如果想打开这个承诺，应用概率加密，这是一个有效的方法，因为不存在长幂运算。</p><p>定理 1（确认定理）</p><p>证明对于任意符合定义要求的$(n,w,S_w) \in PK$，确认协议均具备完整性，健壮性和零知识。</p><p>完整性：偶次幂消除了二阶的因子$\alpha$的影响，我们允许这样的签名。</p><p>健壮性：我们试图说明，当签名无效时$P$说服$V$接受签名的概率由选择$A$通过$V$的测试的最大概率决定。我们可以证明（证明过程见原文章）概率为${\pi}_1+{\pi}_2 &lt; \frac{\varphi(n)}{ord(\alpha) ord(w)} + \frac{2(n - \varphi (n))}{n}$，结合引理1我们又易得到$ord(w) ≥ p’q’$，欺骗者不知道关于$n$的因式分解信息，以及$ord(\alpha) ≥ p’$，所以我们能得到${\pi}_2 &lt; \frac{4}{p’}$，以及${\pi}_1  + {\pi}_2 &lt; \frac{6}{p’}$由于$p’$也是一个相当大的质数，所以实际概率很小。</p><p>零知识：见前述协议详情。</p><h2 id="拒绝协议"><a href="#拒绝协议" class="headerlink" title="拒绝协议"></a>拒绝协议</h2><p>图2展示了拒绝协议。 协议的公共输入是公钥参数，即$(n,w,S_w) \in PK$，以及$(m,S_m)$。如果$S_m$不是有效签名，那么$P$能够说服$V$这个事实，若签名效，$P$能够说服$V$该签名无效的概率可以忽略不计。</p><p>我们的解决方案是基于 由Chaum [Ch1]引入的协议，旨在用零知识的一个素数域上两个元素的离散对数的不等式。 上述论文中提到的协议和证明对于对$n$为合数的简化剩余系不具备有效性，特别地，是因为它们依赖一个简化剩余系地生成器（而我们已经证明符合我们要求地简化剩余系的最大阶并不等于群的阶）。 不过，一个针对上述协议的细致改良版本以及一个相关的证明方法会被用来证明解决在$n$为合数的简化剩余系问题。</p><p><img src="https://eddyblog.oss-cn-shenzhen.aliyuncs.com/%E5%AF%86%E7%A0%81%E5%AD%A6/rsa_udc4.png" srcset="/img/loading.gif" alt="4"></p><p>该协议以下面的方式工作，验证者在第一步中给出两个证明者可以使用验证指数$e$验证的两个值（通过商值${( \frac{ \overset{\rm -}{m} }{S_m^e}  })^{i}$来验证 ）。仅当正民者可以找到选定$i$值时，验证者才接受协议的运行。如果$S_m$不是消息$m$的有效签名，则$P$，需要彻底搜索$i$应取值的范围，然而，如果$S_m$时有效签名，无论$i$的取值为多少，上述商式的结果恒等于$1$，那么证明者不能获取到关于$i$的任何信息从而只能猜测$i$的值（来达到欺骗的目的）。</p><p>为了实现对$i$的穷尽搜索，一个人需要选择一个尽可能小的范围，如果上界设置为某个值$k$，则证明着需要对$\frac{ \overset{\rm -}{m} }{S_m^e}$进行$k$次乘法操作来找到$i$。因而该协议具有$\frac{1}{k}$的出错概率。因为注意到选择$k$的时间复杂度为$O( \log n )$，那么穷举搜索的成本大概相当于单个的长幂运算。另一方面，这种情况下欺骗的概率为$\frac{1}{k}$。我们以$k = 1024$为例，我们可以重复该协议十次，则可以实现$\frac{1}{2^{100}}$的安全性。正如在引言中所述，相对于运行欺骗概率为$\frac{1}{2}$的子协议，效率要高十倍。</p><p>下图展示了协议流程（忽略了零知识的步骤），这与确认协议的情况类似。然而，在这个协议中，需要在第2步中特殊对待。如果一个（诚实）的证明者并没有找到一个满足等式的$i$值，那么就意味着$V$是在欺骗，$P$中止协议的执行。虽然终止协议中没有泄露很多信息，但它确实揭示了一部分，在零知识版主中我们甚至连这些信息都不想泄露。因而，$P$应当继续协议的执行并在“假承诺”中提交0值。这样会掩盖$i$值被发现与否的信息。需要指明在$i$值没有被找到的情况下，验证者会被曝光为欺骗者从而0的承诺将不会被揭示。</p><p>定理 2（拒绝定理）</p><p>证明对于任意符合定义要求的$(n,w,S_w) \in PK$，确认协议均具备完整性，健壮性和零知识。</p><p>完整性：即对于$S_m \notin SIG(m)$，若两人均遵守协议的执行，那么$V$总会接受$S_m$不是消息$m$的一个合法签名。</p><p>健壮性：即对于$S_m \in SIG(m)$，那么一个骗子证明者$P^{*}$即便计算能力无上界，无法以大于$\frac{1}{k}+ \frac{O(1)}{p’}$的概率说服$V$拒绝该签名（不认为该签名合法）。</p><p>零知识：该协议是零知识的，对于输入的消息和不合法签名，任何（很可能是骗子）验证者$V^{*}$与证明者$P$的交互中都不会获取除了$S_m$是个非法签名外的任何信息。</p><p>验证过程需要再学习。</p><h1 id="安全性分析"><a href="#安全性分析" class="headerlink" title="安全性分析"></a>安全性分析</h1><p>文章这里不对不可否认签名的安全性要求做正式分析，关于这种正确且完整的处理，我们建议读者参考Damgard和Pedersen的论文[DP]；这些概念的概述可以在我们的介绍中找到（特别是在1.1节）。这里我们基于该大纲以及前一节中零知识证明结果来讨论我们解决方案的安全性。</p><h2 id="签名的不可伪造性"><a href="#签名的不可伪造性" class="headerlink" title="签名的不可伪造性"></a>签名的不可伪造性</h2><p>我们证明如下定理</p><p>定理 3</p><p>假定基础RSA签名是不可伪造的（对已知明文或者选择明文攻击），则我们的不可否认签名方案对相同攻击也是不可伪造的。</p><p>如前所述，RSA不能直接抵抗选择明文攻击，但我们通过其他方法来解决这个问题，例如，在取幂之前对消息进行适当的编码（参见3.1节）。</p><p>假设存在一个伪造者$F$，在接收到不可否认的公钥对，并与签名者进行确认和拒绝协议交互后，它可以在我们的方案中伪造不可否认的签名。即可以输出$(m,S_m)$且$S_m \in SIG(m)$。我们构建了一个攻击者$A$，他将使用此伪造和伪造的常规RSA签名。给定RSA公钥$(n,e)$，若$A$想要伪造一个签名他需要按照如下步骤操作，首先选择一个随机值，并将不可否认签名的模式的公钥对设置为$(n,w=r^e \mod n, S_w = r)$并且将这些值交给$F$,当$F$请求一个在$m$上的不可否认签名时，攻击者$A$请求$S$取签署消息并且将其交给$F$这个签名对$m,S_m$，当$F$请求对$F$提供的对$m,S$验证时，$A$首先检查$S_m$是否等于$S$，从而与$F$执行确认或拒绝协议（仅需知道$e$即可）。经过这一步骤后，伪造者$F$就可以产生一个伪造的我们设计的不可否认签名方案。</p><h2 id="签名的不可分辨性"><a href="#签名的不可分辨性" class="headerlink" title="签名的不可分辨性"></a>签名的不可分辨性</h2><p>不可否认签名的基本目标是，没有人能够在不与合法签名者进行协议交互的情况下验证消息及其(声称的)签名的有效性。根据[DP]指出，我们需要证明公钥信息和任何消息$m$（但不是签名指数$d$），一个人可以模拟出$m$的签名，从分布的意义上说，模拟签名不能和有效签名区分开。我们通过以下方式实现该属性，给定任何消息，我们对其底层RSA确定的编码，然后将消息随机幂次模$n$，那么与真实签名的差别即下面等式。</p><script type="math/tex; mode=display">\log {(s(m))} \overset{\rm ?}{=}  \log {(S_w)}</script><p>$Z_n^*$上的离散对数难题，这个问题还没有有效解法，尽管它与RSA，因子分解或者离散对数问题的等价性尚未建立，因此我们需要以下难以处理的假设，以用来描述模拟前面和真实签名的硬度差别。</p><p>假设EDL</p><p>对于值$n,w,S_w, \overset{\rm -}{m},s(w)$，他们对于离散对数的等式是不可分辨的。</p><p>我们的假设建立$e,d$保密，因为我们的方案公钥中并不含$e$，并且协议是零知识的。</p><p>注意，对消息编码是我们假设的一部分，我们强调，模素数的模拟假设对于声称先前不可变签名方案的安全性也是必要的（参见[DP]）。 然而，虽然我们可以证明EDL假设意味着我们签名的可模拟性，但在[DP]中这个含义并未得到证实，但只是推测为。</p><p>定理 4</p><p>根据上述EDL假设，我们的签名是可模拟的，因此如果没有签名者或其委托的确认者/合作就无法验证。</p><h2 id="选择签名者的密钥"><a href="#选择签名者的密钥" class="headerlink" title="选择签名者的密钥"></a>选择签名者的密钥</h2><p>在第3节中，我们定义了签名者的公共和私有参数应该是什么。 我们对确认和拒绝协议的（强壮性）分析取决于正确选择的这些参数。 通常，只要签名者向可信方（例如，认证机构）注册该公钥，就可以进行该公钥的验证。 在这里，我们概述了用于检查模数$n$的正确组成，$w$以及$S_w$是$w$的幂，的协议。（作为签名者对签名的“承诺”）。 请注意，这些协议仅在注册时间执行一次。 我们用作为这些参数的验证者的实体表示，并通过证明其正确选择的签名者。这些协议<strong>仅在注册时间</strong>执行一次。这里我们用$V$表示验证参数有效性的实体，$P$表示希望证明参数有效性的证明者。</p><p><strong>验证$w$是高阶的</strong></p><p>根据引理1，如果$w \notin \{-1,1 \}$，并且$gcd(w-1,n)$并不是$n$的因子。事实上，我们可以选择固定的$w$值，比如$w=2$，对于<strong>所有</strong>不可否认签名，这个选值总能顺利通过验证（或者因子是可分解的。）</p><p><strong>验证$S_w \in  \langle w \rangle$</strong></p><p>下面的协议基本上是证明[CEG]中证明的离散对数协议，再一次修改了模数以便能够使用合数模量。签署者$P$选择一个值$r \in _r [ \varphi (n)]$，并且将其交给$V$值$w’ = w^r$。验证者$V$用以随机位$b$回复（不经意传输）。如果$b=0$，则$P$返回值$r$，若$b=1$，则$P$返回值$d+r \mod \varphi(n)$。在第一种情况下，$V$检查是否$w^r = w’$，而在第二种情况下，检查是否$w^{d+r} = w’ S_w$，若$w \notin \langle w \rangle$，那么$P$通过测试的概率为$\frac{1}{2}$，重复这个测试$k$次，那么欺骗概率降低到$\frac{1}{2^k}$。（有些像不透露$d$的零知识证明，d，e都在私钥对中）。事实上，如果我们假设存在一个理想的哈希函数，那么协议可以非交互的执行。</p><h1 id="拓展"><a href="#拓展" class="headerlink" title="拓展"></a>拓展</h1><p>该协议适用相关文献中提到的关于不可否认签名的性质的拓展。</p><h2 id="可转换的不可否认签名"><a href="#可转换的不可否认签名" class="headerlink" title="可转换的不可否认签名"></a>可转换的不可否认签名</h2><p>这种最早出现在[BCDP]中，并最早在[DP]中提出了基于ElGamal签名的安全方案。可转换的不可否认签名允许签名者可以通过发布一个（或者多个值）将不可否认签名转换为常规（即可以不同过与签名者交互自身验证）数字签名。在我们的方案中，只要公布$e$的值就可以轻松转化为传统的RSA签名。转化方案的安全性（即不可伪造性）暗示了该转化方案的安全性。</p><h2 id="授权委派"><a href="#授权委派" class="headerlink" title="授权委派"></a>授权委派</h2><p>这个想法是希望能让签名者向第三方授权确认或否认能力，但不向其提供签名的能力。 在很多文献中，这一概念通常在签名的可转换性上下文中解释。但是，这两个概念是不同的。</p><p>显然，如果公开的话，那会将该不可否认签名转化为可普遍验证的签名。然而，然而，反过来却未必正确。转换签名的信息如果秘密交给第三方，可能依旧不允许该方以不可转让的方式证明签名的真伪。在我们的设置中，签名者可以简单地给第三方密钥，这是唯一需要的信息，用来成功地执行拒绝和确认协议。且显然，$e$的接受方并不能自己签署文件，这基于常规RSA签名的性质。</p><h2 id="分布式证明者（签署者）"><a href="#分布式证明者（签署者）" class="headerlink" title="分布式证明者（签署者）"></a>分布式证明者（签署者）</h2>]]></content>
    
    
    <categories>
      
      <category>Computer Science</category>
      
      <category>密码学</category>
      
    </categories>
    
    
    <tags>
      
      <tag>密码学</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>【洛谷-P2756】解题报告（二分图最大匹配）</title>
    <link href="/post/d6212e2f.html"/>
    <url>/post/d6212e2f.html</url>
    
    <content type="html"><![CDATA[<h1 id="原始题目"><a href="#原始题目" class="headerlink" title="原始题目"></a>原始题目</h1><p><a href="https://www.luogu.org/problemnew/show/P2756" target="_blank" rel="noopener">P2756 飞行员配对方案问题</a></p><h1 id="题目大意"><a href="#题目大意" class="headerlink" title="题目大意"></a>题目大意</h1><p>给定两个集合，存在一些连接两个集合的边表示配合，来自不同集合的一对元素构成一个配对，求最大的配对数量。</p><h1 id="解题思路"><a href="#解题思路" class="headerlink" title="解题思路"></a>解题思路</h1><p>集合内无边，所以构成二分图，求二分图的最大匹配。</p><a id="more"></a><h1 id="解题代码"><a href="#解题代码" class="headerlink" title="解题代码"></a>解题代码</h1><pre><code class="hljs C++"><span class="hljs-meta">#<span class="hljs-meta-keyword">include</span> <span class="hljs-meta-string">&lt;bits/stdc++.h&gt;</span></span><span class="hljs-keyword">using</span> <span class="hljs-keyword">namespace</span> <span class="hljs-built_in">std</span>;<span class="hljs-keyword">typedef</span> <span class="hljs-keyword">long</span> <span class="hljs-keyword">long</span> ll;<span class="hljs-keyword">typedef</span> <span class="hljs-keyword">unsigned</span> <span class="hljs-keyword">long</span> <span class="hljs-keyword">long</span> ull;<span class="hljs-keyword">typedef</span> <span class="hljs-built_in">vector</span>&lt;<span class="hljs-keyword">int</span>&gt; vi;<span class="hljs-keyword">typedef</span> pair&lt;<span class="hljs-keyword">int</span>, <span class="hljs-keyword">int</span>&gt; pii;<span class="hljs-keyword">typedef</span> pair&lt;<span class="hljs-built_in">string</span>, <span class="hljs-built_in">string</span>&gt; pss;<span class="hljs-meta">#<span class="hljs-meta-keyword">define</span> rep(i, a, n) for (int i = a; i &lt; n; ++i)</span><span class="hljs-meta">#<span class="hljs-meta-keyword">define</span> per(i, a, n) for (int i = n - 1; i &gt;= a; --i)</span><span class="hljs-meta">#<span class="hljs-meta-keyword">define</span> fi first</span><span class="hljs-meta">#<span class="hljs-meta-keyword">define</span> se second</span><span class="hljs-meta">#<span class="hljs-meta-keyword">define</span> mp make_pair</span><span class="hljs-meta">#<span class="hljs-meta-keyword">define</span> np next_permutation</span><span class="hljs-meta">#<span class="hljs-meta-keyword">define</span> pb push_back</span><span class="hljs-meta">#<span class="hljs-meta-keyword">define</span> INF 0x3f3f3f3f</span><span class="hljs-keyword">const</span> <span class="hljs-keyword">int</span> maxn = <span class="hljs-number">1e3</span> + <span class="hljs-number">5</span>;vi e[maxn];<span class="hljs-keyword">int</span> n, m;<span class="hljs-built_in">bitset</span>&lt;maxn&gt; v;<span class="hljs-keyword">int</span> fa[maxn], ans;<span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">dfs</span><span class="hljs-params">(<span class="hljs-keyword">int</span> x)</span></span>&#123;    rep(i, <span class="hljs-number">0</span>, e[x].size())    &#123;        <span class="hljs-keyword">int</span> y = e[x][i];        <span class="hljs-keyword">if</span> (v[y])            <span class="hljs-keyword">continue</span>;        v[y] = <span class="hljs-number">1</span>;        <span class="hljs-keyword">if</span> (!fa[y] || dfs(fa[y])) &#123;            fa[y] = x;            <span class="hljs-keyword">return</span> <span class="hljs-number">1</span>;        &#125;    &#125;    <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;&#125;<span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">init</span><span class="hljs-params">()</span></span>&#123;    rep(i, <span class="hljs-number">0</span>, maxn) e[i].clear();    <span class="hljs-built_in">memset</span>(fa, <span class="hljs-number">0</span>, <span class="hljs-keyword">sizeof</span>(fa));    v.reset();    ans = <span class="hljs-number">0</span>;&#125;<span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span>&#123;    ios::sync_with_stdio(<span class="hljs-literal">false</span>);    <span class="hljs-keyword">while</span> (<span class="hljs-built_in">cin</span> &gt;&gt; m &gt;&gt; n) &#123;        init();        <span class="hljs-keyword">int</span> a, b;        <span class="hljs-keyword">while</span> (<span class="hljs-built_in">cin</span> &gt;&gt; a &gt;&gt; b &amp;&amp; a != <span class="hljs-number">-1</span>) &#123;            e[a].pb(n + b);            e[n + b].pb(a);        &#125;        rep(i, <span class="hljs-number">1</span>, m + <span class="hljs-number">1</span>)        &#123;            v.reset();            ans += dfs(i);        &#125;        <span class="hljs-keyword">if</span> (ans == <span class="hljs-number">0</span>) &#123;            <span class="hljs-built_in">cout</span> &lt;&lt; <span class="hljs-string">"No Solution!"</span> &lt;&lt; <span class="hljs-built_in">endl</span>;            <span class="hljs-keyword">continue</span>;        &#125;        <span class="hljs-built_in">cout</span> &lt;&lt; ans &lt;&lt; <span class="hljs-built_in">endl</span>;        rep(i, n + <span class="hljs-number">1</span>, n + n + <span class="hljs-number">1</span>)        &#123;            <span class="hljs-keyword">if</span> (fa[i] != <span class="hljs-number">0</span>)                <span class="hljs-built_in">cout</span> &lt;&lt; fa[i] &lt;&lt; <span class="hljs-string">" "</span> &lt;&lt; i - n &lt;&lt; <span class="hljs-built_in">endl</span>;        &#125;    &#125;&#125;</code></pre><h1 id="收获与反思"><a href="#收获与反思" class="headerlink" title="收获与反思"></a>收获与反思</h1><p>搬运定义</p><h2 id="图的匹配相关"><a href="#图的匹配相关" class="headerlink" title="图的匹配相关"></a>图的匹配相关</h2><p><code>图的匹配</code>：<strong>任意两条边都没有公共端点</strong>的边的集合被称为图的一组匹配。</p><p><code>二分图最大匹配</code>：在二分图中，包含边数最多的一组匹配被称为二分图的最大匹配。</p><p>对于任意一组匹配 $S$ （边集），属于 $S$ 的边被称为<strong>匹配边</strong>，不属于 $S$ 的边被称为<strong>非匹配边</strong>。匹配边的端点被称为<strong>匹配点</strong>，其他节点被称为<strong>非匹配点</strong>。</p><p>如果二分图中存在一条连接两个非匹配点的路径 ，使得非匹配边与匹配边在路径上交替出现，那么称该路径是匹配 $S$ 的增广路（也称交错路）。</p><h2 id="增广路的性质"><a href="#增广路的性质" class="headerlink" title="增广路的性质"></a>增广路的性质</h2><ol><li>长度为奇数</li><li>奇数边是非匹配边，偶数边是匹配边。</li><li>如果把路径上所有边的状态（是否为匹配边）取反，那么得到的新的边集 $S’$ 仍然是一组匹配，并且匹配的边数增加了 $1$ 。</li></ol><h2 id="匈牙利算法（增光路算法）"><a href="#匈牙利算法（增光路算法）" class="headerlink" title="匈牙利算法（增光路算法）"></a>匈牙利算法（增光路算法）</h2><p>主要过程：</p><ol><li>设 $S$为空集，即所有边都是非匹配边。</li><li>寻找增广路 path ，把 path 上所有边的匹配状态取反，得到一个更大的匹配 $S’$。（利用增光路性质3）</li><li>重复第 2 步，直至图中不存在增广路。</li></ol><h2 id="寻找增广路"><a href="#寻找增广路" class="headerlink" title="寻找增广路"></a>寻找增广路</h2><p>依次尝试给每一个左部节点 xx 寻找一个匹配的右部节点 yy 。</p><p>dfs方法。</p><p>常有两种写法</p><ol><li><p>单标记，邻接表写法</p> <pre><code class="hljs C++"><span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">dfs</span><span class="hljs-params">(<span class="hljs-keyword">int</span> x)</span></span>&#123;    rep(i, <span class="hljs-number">0</span>, e[x].size())    &#123;        <span class="hljs-keyword">int</span> y = e[x][i];        <span class="hljs-keyword">if</span> (v[y])            <span class="hljs-keyword">continue</span>;        v[y] = <span class="hljs-number">1</span>;        <span class="hljs-keyword">if</span> (!fa[y] || dfs(fa[y])) &#123;            fa[y] = x;            <span class="hljs-keyword">return</span> <span class="hljs-number">1</span>;        &#125;    &#125;    <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;&#125;</code></pre></li><li><p>双标记，数组写法</p></li></ol><pre><code class="hljs C++"><span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">dfs</span><span class="hljs-params">(<span class="hljs-keyword">int</span> x)</span></span>&#123;    rep(i,<span class="hljs-number">0</span>,n)&#123;        <span class="hljs-keyword">if</span>(!mmp[x][i] || v[i]) <span class="hljs-keyword">continue</span>;        v[i] =<span class="hljs-number">1</span>;        <span class="hljs-keyword">if</span>(!fa[i] || dfs(fa[i]))&#123;            fa[i] = x;            fa[x] = i; <span class="hljs-comment">//双标记</span>            <span class="hljs-keyword">return</span> <span class="hljs-number">1</span>;        &#125;    &#125;    <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;&#125;</code></pre><p>双标记对于访问二分图里所有点得到的匹配是实际值，单标记访问所有点得到的匹配是2倍，如果访问一个集合点则是实际值，单标记更多用于两集和已被分隔开的情况。</p>]]></content>
    
    
    <categories>
      
      <category>Computer Science</category>
      
      <category>ACM</category>
      
      <category>洛谷</category>
      
    </categories>
    
    
    <tags>
      
      <tag>ACM</tag>
      
      <tag>洛谷</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>【洛谷-P2104】解题报告（模拟）</title>
    <link href="/post/61642081.html"/>
    <url>/post/61642081.html</url>
    
    <content type="html"><![CDATA[<h1 id="原始题目"><a href="#原始题目" class="headerlink" title="原始题目"></a>原始题目</h1><p><a href="https://www.luogu.org/problemnew/show/P2104" target="_blank" rel="noopener">P2104 二进制</a></p><h1 id="题目大意"><a href="#题目大意" class="headerlink" title="题目大意"></a>题目大意</h1><p>模拟二进制运算，保证最高位不改变，输入初始与运算，输出结果。</p><h1 id="解题思路"><a href="#解题思路" class="headerlink" title="解题思路"></a>解题思路</h1><p>vector模拟栈操作：</p><ol><li>‘*’入栈0</li><li>‘\’出栈</li><li>‘+’则末尾++，然后更新</li><li>‘-‘则末尾—，然后更新</li></ol><a id="more"></a><h1 id="解题代码"><a href="#解题代码" class="headerlink" title="解题代码"></a>解题代码</h1><pre><code class="hljs C++"><span class="hljs-comment">// 这个题用vector  ++v.back()  比  ++v[v.size()-1] 跑的要慢    有些奇怪 值得探索一下</span><span class="hljs-meta">#<span class="hljs-meta-keyword">include</span> <span class="hljs-meta-string">&lt;bits/stdc++.h&gt;</span></span><span class="hljs-keyword">using</span> <span class="hljs-keyword">namespace</span> <span class="hljs-built_in">std</span>;<span class="hljs-keyword">typedef</span> <span class="hljs-keyword">long</span> <span class="hljs-keyword">long</span> ll;<span class="hljs-keyword">typedef</span> <span class="hljs-keyword">unsigned</span> <span class="hljs-keyword">long</span> <span class="hljs-keyword">long</span> ull;<span class="hljs-keyword">typedef</span> <span class="hljs-built_in">vector</span>&lt;<span class="hljs-keyword">int</span>&gt; vi;<span class="hljs-keyword">typedef</span> pair&lt;<span class="hljs-keyword">int</span>, <span class="hljs-keyword">int</span>&gt; pii;<span class="hljs-keyword">typedef</span> pair&lt;<span class="hljs-built_in">string</span>, <span class="hljs-built_in">string</span>&gt; pss;<span class="hljs-meta">#<span class="hljs-meta-keyword">define</span> rep(i, a, n) for (int i = a; i &lt; n; ++i)</span><span class="hljs-meta">#<span class="hljs-meta-keyword">define</span> per(i, a, n) for (int i = n - 1; i &gt;= a; --i)</span><span class="hljs-meta">#<span class="hljs-meta-keyword">define</span> fi first</span><span class="hljs-meta">#<span class="hljs-meta-keyword">define</span> se second</span><span class="hljs-meta">#<span class="hljs-meta-keyword">define</span> mp make_pair</span><span class="hljs-meta">#<span class="hljs-meta-keyword">define</span> pb push_back</span><span class="hljs-meta">#<span class="hljs-meta-keyword">define</span> all(x) x.begin(), x.end()</span><span class="hljs-meta">#<span class="hljs-meta-keyword">define</span> endl <span class="hljs-meta-string">'\n'</span></span>vi v;<span class="hljs-keyword">int</span> n, m;<span class="hljs-built_in">string</span> op;<span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span>&#123;    ios::sync_with_stdio(<span class="hljs-literal">false</span>);    <span class="hljs-keyword">int</span> temp;    <span class="hljs-keyword">while</span> (<span class="hljs-built_in">cin</span> &gt;&gt; n &gt;&gt; m) &#123;        <span class="hljs-built_in">cin</span> &gt;&gt; op;        rep(i, <span class="hljs-number">0</span>, n) v.pb(op[i] - <span class="hljs-string">'0'</span>);        <span class="hljs-built_in">cin</span> &gt;&gt; op;        rep(i, <span class="hljs-number">0</span>, m)        &#123;            <span class="hljs-keyword">if</span> (op[i] == <span class="hljs-string">'*'</span>) &#123;                v.pb(<span class="hljs-number">0</span>);            &#125; <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (op[i] == <span class="hljs-string">'/'</span>) &#123;                v.pop_back();            &#125; <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (op[i] == <span class="hljs-string">'+'</span>) &#123;                ++v.back();                per(i, <span class="hljs-number">0</span>, v.size())                &#123;                    <span class="hljs-keyword">if</span> (v[i] == <span class="hljs-number">2</span>) &#123;                        v[i] = <span class="hljs-number">0</span>;                        ++v[i - <span class="hljs-number">1</span>];                    &#125; <span class="hljs-keyword">else</span>                        <span class="hljs-keyword">break</span>;                &#125;            &#125; <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (op[i] == <span class="hljs-string">'-'</span>) &#123;                --v.back();                per(i, <span class="hljs-number">0</span>, v.size())                &#123;                    <span class="hljs-keyword">if</span> (v[i] &lt; <span class="hljs-number">0</span>) &#123;                        v[i] = <span class="hljs-number">1</span>;                        --v[i - <span class="hljs-number">1</span>];                    &#125; <span class="hljs-keyword">else</span>                        <span class="hljs-keyword">break</span>;                &#125;            &#125;        &#125;        <span class="hljs-comment">// cout &lt;&lt; v[0];</span>        rep(i, <span class="hljs-number">0</span>, v.size())        &#123;            <span class="hljs-built_in">cout</span> &lt;&lt; v[i];        &#125;        <span class="hljs-built_in">cout</span> &lt;&lt; <span class="hljs-built_in">endl</span>;    &#125;&#125;</code></pre><h1 id="收获与反思"><a href="#收获与反思" class="headerlink" title="收获与反思"></a>收获与反思</h1><p>vector的一些操作<code>pop_back()</code>,<code>push_back()</code>.<code>back()</code>等熟悉一下，有时候很方便。</p>]]></content>
    
    
    <categories>
      
      <category>Computer Science</category>
      
      <category>ACM</category>
      
      <category>洛谷</category>
      
    </categories>
    
    
    <tags>
      
      <tag>ACM</tag>
      
      <tag>洛谷</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>【洛谷-P1914】解题报告（字符串）</title>
    <link href="/post/4c842940.html"/>
    <url>/post/4c842940.html</url>
    
    <content type="html"><![CDATA[<h1 id="原始题目"><a href="#原始题目" class="headerlink" title="原始题目"></a>原始题目</h1><p><a href="https://www.luogu.org/problemnew/show/P1914" target="_blank" rel="noopener">P1414 小书童——密码</a></p><h1 id="题目大意"><a href="#题目大意" class="headerlink" title="题目大意"></a>题目大意</h1><p>移位密码还原</p><h1 id="解题思路"><a href="#解题思路" class="headerlink" title="解题思路"></a>解题思路</h1><p>水题</p><a id="more"></a><h1 id="解题代码"><a href="#解题代码" class="headerlink" title="解题代码"></a>解题代码</h1><pre><code class="hljs C++"><span class="hljs-meta">#<span class="hljs-meta-keyword">include</span> <span class="hljs-meta-string">&lt;bits/stdc++.h&gt;</span></span><span class="hljs-keyword">using</span> <span class="hljs-keyword">namespace</span> <span class="hljs-built_in">std</span>;<span class="hljs-keyword">typedef</span> <span class="hljs-keyword">long</span> <span class="hljs-keyword">long</span> ll;<span class="hljs-keyword">typedef</span> <span class="hljs-keyword">unsigned</span> <span class="hljs-keyword">long</span> <span class="hljs-keyword">long</span> ull;<span class="hljs-keyword">const</span> <span class="hljs-keyword">int</span> maxn = <span class="hljs-number">1e5</span> + <span class="hljs-number">5</span>;<span class="hljs-meta">#<span class="hljs-meta-keyword">define</span> rep(i, a, n) for (int i = a; i &lt; n; ++i)</span><span class="hljs-meta">#<span class="hljs-meta-keyword">define</span> per(i, a, n) for (int i = n - 1; i &gt;= a; --i)</span><span class="hljs-meta">#<span class="hljs-meta-keyword">define</span> fi first</span><span class="hljs-meta">#<span class="hljs-meta-keyword">define</span> se second</span><span class="hljs-meta">#<span class="hljs-meta-keyword">define</span> pb push_back</span><span class="hljs-meta">#<span class="hljs-meta-keyword">define</span> np next_permutation</span><span class="hljs-meta">#<span class="hljs-meta-keyword">define</span> mp make_pair</span><span class="hljs-meta">#<span class="hljs-meta-keyword">define</span> endl <span class="hljs-meta-string">'\n'</span></span><span class="hljs-built_in">string</span> s;<span class="hljs-keyword">int</span> n;<span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span>&#123;    ios::sync_with_stdio(<span class="hljs-literal">false</span>);    <span class="hljs-keyword">while</span> (<span class="hljs-built_in">cin</span> &gt;&gt; n &gt;&gt; s) &#123;        rep(i, <span class="hljs-number">0</span>, s.length())        &#123;            <span class="hljs-built_in">cout</span> &lt;&lt; <span class="hljs-keyword">char</span>(<span class="hljs-string">'a'</span> + ((s[i] - <span class="hljs-string">'a'</span>) + n) % <span class="hljs-number">26</span>);        &#125;        <span class="hljs-built_in">cout</span> &lt;&lt; <span class="hljs-built_in">endl</span>;    &#125;&#125;</code></pre><h1 id="收获与反思"><a href="#收获与反思" class="headerlink" title="收获与反思"></a>收获与反思</h1><p>无</p>]]></content>
    
    
    <categories>
      
      <category>Computer Science</category>
      
      <category>ACM</category>
      
      <category>洛谷</category>
      
    </categories>
    
    
    <tags>
      
      <tag>ACM</tag>
      
      <tag>洛谷</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>【洛谷-P1909】解题报告（水题）</title>
    <link href="/post/7a1fb89c.html"/>
    <url>/post/7a1fb89c.html</url>
    
    <content type="html"><![CDATA[<h1 id="原始题目"><a href="#原始题目" class="headerlink" title="原始题目"></a>原始题目</h1><p><a href="https://www.luogu.org/problemnew/show/P1909" target="_blank" rel="noopener">P1909 买铅笔</a></p><h1 id="题目大意"><a href="#题目大意" class="headerlink" title="题目大意"></a>题目大意</h1><p>三种笔个数，单价不同，求买超过n支铅笔最少花费。</p><h1 id="解题思路"><a href="#解题思路" class="headerlink" title="解题思路"></a>解题思路</h1><p>水题</p><a id="more"></a><h1 id="解题代码"><a href="#解题代码" class="headerlink" title="解题代码"></a>解题代码</h1><pre><code class="hljs C++"><span class="hljs-meta">#<span class="hljs-meta-keyword">include</span> <span class="hljs-meta-string">&lt;bits/stdc++.h&gt;</span></span><span class="hljs-keyword">using</span> <span class="hljs-keyword">namespace</span> <span class="hljs-built_in">std</span>;<span class="hljs-keyword">typedef</span> <span class="hljs-keyword">long</span> <span class="hljs-keyword">long</span> ll;<span class="hljs-keyword">typedef</span> <span class="hljs-keyword">unsigned</span> <span class="hljs-keyword">long</span> <span class="hljs-keyword">long</span> ull;<span class="hljs-keyword">typedef</span> <span class="hljs-built_in">vector</span>&lt;<span class="hljs-keyword">int</span>&gt; vi;<span class="hljs-keyword">typedef</span> pair&lt;<span class="hljs-keyword">int</span>, <span class="hljs-keyword">int</span>&gt; pii;<span class="hljs-keyword">typedef</span> pair&lt;<span class="hljs-built_in">string</span>, <span class="hljs-built_in">string</span>&gt; pss;<span class="hljs-meta">#<span class="hljs-meta-keyword">define</span> rep(i, a, n) for (int i = a; i &lt; n; ++i)</span><span class="hljs-meta">#<span class="hljs-meta-keyword">define</span> per(i, a, n) for (int i = n - 1; i &gt;= a; --i)</span><span class="hljs-meta">#<span class="hljs-meta-keyword">define</span> fi first</span><span class="hljs-meta">#<span class="hljs-meta-keyword">define</span> se second</span><span class="hljs-meta">#<span class="hljs-meta-keyword">define</span> all(x) x.begin(), x.end()</span><span class="hljs-meta">#<span class="hljs-meta-keyword">define</span> mp make_pair</span><span class="hljs-meta">#<span class="hljs-meta-keyword">define</span> pb push_back</span><span class="hljs-meta">#<span class="hljs-meta-keyword">define</span> np next_permutation</span><span class="hljs-meta">#<span class="hljs-meta-keyword">define</span> INF 0x3f3f3f3f</span><span class="hljs-meta">#<span class="hljs-meta-keyword">define</span> EPS 1e-8</span><span class="hljs-meta">#<span class="hljs-meta-keyword">define</span> endl <span class="hljs-meta-string">'\n'</span></span><span class="hljs-keyword">int</span> a[<span class="hljs-number">10</span>], b[<span class="hljs-number">10</span>], n, ans[<span class="hljs-number">3</span>], cnt;<span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span>&#123;    ios::sync_with_stdio(<span class="hljs-literal">false</span>);    <span class="hljs-keyword">while</span> (<span class="hljs-built_in">cin</span> &gt;&gt; n) &#123;        rep(i, <span class="hljs-number">0</span>, <span class="hljs-number">3</span>)        &#123;            <span class="hljs-built_in">cin</span> &gt;&gt; a[i] &gt;&gt; b[i];            ans[i] = <span class="hljs-built_in">ceil</span>(<span class="hljs-number">1.0</span> * n / a[i]) * b[i];        &#125;        <span class="hljs-keyword">int</span> minp = ans[<span class="hljs-number">0</span>];        rep(i, <span class="hljs-number">1</span>, <span class="hljs-number">3</span>)        &#123;            <span class="hljs-keyword">if</span> (ans[i] &lt; minp) &#123;                minp = ans[i];            &#125;        &#125;        <span class="hljs-built_in">cout</span> &lt;&lt; minp &lt;&lt; <span class="hljs-built_in">endl</span>;    &#125;&#125;</code></pre><h1 id="收获与反思"><a href="#收获与反思" class="headerlink" title="收获与反思"></a>收获与反思</h1><p>无</p>]]></content>
    
    
    <categories>
      
      <category>Computer Science</category>
      
      <category>ACM</category>
      
      <category>洛谷</category>
      
    </categories>
    
    
    <tags>
      
      <tag>ACM</tag>
      
      <tag>洛谷</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>【洛谷-P1781】解题报告（排序）</title>
    <link href="/post/beeeff10.html"/>
    <url>/post/beeeff10.html</url>
    
    <content type="html"><![CDATA[<h1 id="原始题目"><a href="#原始题目" class="headerlink" title="原始题目"></a>原始题目</h1><p><a href="https://www.luogu.org/problemnew/show/P1781" target="_blank" rel="noopener">P1781 宇宙总统</a></p><h1 id="题目大意"><a href="#题目大意" class="headerlink" title="题目大意"></a>题目大意</h1><p>输出出现次数最多的编号</p><h1 id="解题思路"><a href="#解题思路" class="headerlink" title="解题思路"></a>解题思路</h1><p>排序</p><a id="more"></a><h1 id="解题代码"><a href="#解题代码" class="headerlink" title="解题代码"></a>解题代码</h1><pre><code class="hljs C++"><span class="hljs-meta">#<span class="hljs-meta-keyword">include</span> <span class="hljs-meta-string">&lt;bits/stdc++.h&gt;</span></span><span class="hljs-keyword">using</span> <span class="hljs-keyword">namespace</span> <span class="hljs-built_in">std</span>;<span class="hljs-keyword">typedef</span> <span class="hljs-keyword">long</span> <span class="hljs-keyword">long</span> ll;<span class="hljs-keyword">typedef</span> <span class="hljs-keyword">unsigned</span> <span class="hljs-keyword">long</span> <span class="hljs-keyword">long</span> ull;<span class="hljs-keyword">const</span> <span class="hljs-keyword">int</span> maxn = <span class="hljs-number">1e5</span> + <span class="hljs-number">5</span>;<span class="hljs-meta">#<span class="hljs-meta-keyword">define</span> rep(i, a, n) for (int i = a; i &lt; n; ++i)</span><span class="hljs-meta">#<span class="hljs-meta-keyword">define</span> per(i, a, n) for (int i = n - 1; i &gt;= a; --i)</span><span class="hljs-meta">#<span class="hljs-meta-keyword">define</span> fi first</span><span class="hljs-meta">#<span class="hljs-meta-keyword">define</span> se second</span><span class="hljs-meta">#<span class="hljs-meta-keyword">define</span> pb push_back</span><span class="hljs-meta">#<span class="hljs-meta-keyword">define</span> np next_permutation</span><span class="hljs-meta">#<span class="hljs-meta-keyword">define</span> mp make_pair</span><span class="hljs-meta">#<span class="hljs-meta-keyword">define</span> endl <span class="hljs-meta-string">'\n'</span></span><span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">node</span> &#123;</span>    <span class="hljs-built_in">string</span> s;    <span class="hljs-keyword">int</span> id;&#125;;node a[maxn];<span class="hljs-function"><span class="hljs-keyword">bool</span> <span class="hljs-title">cmp</span><span class="hljs-params">(node a, node b)</span></span>&#123;    <span class="hljs-keyword">if</span> (a.s.length() != b.s.length()) &#123;        <span class="hljs-keyword">return</span> a.s.length() &gt; b.s.length();    &#125; <span class="hljs-keyword">else</span> &#123;        <span class="hljs-keyword">int</span> len = a.s.length();        rep(i, <span class="hljs-number">0</span>, len)        &#123;            <span class="hljs-keyword">if</span> (a.s[i] != b.s[i])                <span class="hljs-keyword">return</span> a.s[i] &gt; b.s[i];        &#125;    &#125;&#125;<span class="hljs-keyword">int</span> n;<span class="hljs-built_in">string</span> ss;<span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span>&#123;    ios::sync_with_stdio(<span class="hljs-literal">false</span>);    <span class="hljs-keyword">while</span> (<span class="hljs-built_in">cin</span> &gt;&gt; n) &#123;        rep(i, <span class="hljs-number">1</span>, n + <span class="hljs-number">1</span>)        &#123;            <span class="hljs-built_in">cin</span> &gt;&gt; ss;            a[i].s = ss;            a[i].id = i;        &#125;        sort(a + <span class="hljs-number">1</span>, a + <span class="hljs-number">1</span> + n, cmp);        <span class="hljs-built_in">cout</span> &lt;&lt; a[<span class="hljs-number">1</span>].id &lt;&lt; <span class="hljs-built_in">endl</span>             &lt;&lt; a[<span class="hljs-number">1</span>].s &lt;&lt; <span class="hljs-built_in">endl</span>;    &#125;&#125;</code></pre>]]></content>
    
    
    <categories>
      
      <category>Computer Science</category>
      
      <category>ACM</category>
      
      <category>洛谷</category>
      
    </categories>
    
    
    <tags>
      
      <tag>ACM</tag>
      
      <tag>洛谷</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>【洛谷-P1716】解题报告（排序）</title>
    <link href="/post/773c10c5.html"/>
    <url>/post/773c10c5.html</url>
    
    <content type="html"><![CDATA[<h1 id="原始题目"><a href="#原始题目" class="headerlink" title="原始题目"></a>原始题目</h1><p><a href="https://www.luogu.org/problemnew/show/P1716" target="_blank" rel="noopener">P1716 双调序列</a></p><h1 id="题目大意"><a href="#题目大意" class="headerlink" title="题目大意"></a>题目大意</h1><p>双调序列的第一个数是n个整数中的最大数，第二个数是n个整数中的最小数，第三个数是n个数中的第二大数，第四个数是n个数中的第二小数……取过的数不能再取，依次类推，直到结束。</p><p>给定序列，输出双调序列。</p><h1 id="解题思路"><a href="#解题思路" class="headerlink" title="解题思路"></a>解题思路</h1><p>排序以后正反输出。</p><a id="more"></a><h1 id="解题代码"><a href="#解题代码" class="headerlink" title="解题代码"></a>解题代码</h1><pre><code class="hljs C++"><span class="hljs-meta">#<span class="hljs-meta-keyword">include</span> <span class="hljs-meta-string">&lt;bits/stdc++.h&gt;</span></span><span class="hljs-keyword">using</span> <span class="hljs-keyword">namespace</span> <span class="hljs-built_in">std</span>;<span class="hljs-keyword">typedef</span> <span class="hljs-keyword">long</span> <span class="hljs-keyword">long</span> ll;<span class="hljs-keyword">typedef</span> <span class="hljs-keyword">unsigned</span> <span class="hljs-keyword">long</span> <span class="hljs-keyword">long</span> ull;<span class="hljs-keyword">typedef</span> pair&lt;<span class="hljs-keyword">int</span>, <span class="hljs-keyword">int</span>&gt; pii;<span class="hljs-keyword">typedef</span> pair&lt;<span class="hljs-built_in">string</span>, <span class="hljs-built_in">string</span>&gt; pss;<span class="hljs-meta">#<span class="hljs-meta-keyword">define</span> rep(i, a, n) for (int i = a; i &lt; n; ++i)</span><span class="hljs-meta">#<span class="hljs-meta-keyword">define</span> per(i, a, n) for (int i = n - 1; i &gt;= a; --i)</span><span class="hljs-meta">#<span class="hljs-meta-keyword">define</span> pb push_back</span><span class="hljs-meta">#<span class="hljs-meta-keyword">define</span> np next_permutation</span><span class="hljs-meta">#<span class="hljs-meta-keyword">define</span> mp make_pair</span><span class="hljs-keyword">const</span> <span class="hljs-keyword">int</span> maxn = <span class="hljs-number">1e5</span> + <span class="hljs-number">5</span>;ll a[maxn];<span class="hljs-keyword">int</span> n;<span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span>&#123;    ios::sync_with_stdio(<span class="hljs-literal">false</span>);    <span class="hljs-keyword">while</span> (<span class="hljs-built_in">cin</span> &gt;&gt; n) &#123;        rep(i, <span class="hljs-number">0</span>, n) <span class="hljs-built_in">cin</span> &gt;&gt; a[i];        sort(a, a + n);        <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> i = n - <span class="hljs-number">1</span>, j = <span class="hljs-number">0</span>;; i--, j++) &#123;            <span class="hljs-keyword">if</span> (i == j) &#123;                <span class="hljs-built_in">cout</span> &lt;&lt; a[i] &lt;&lt; <span class="hljs-built_in">endl</span>;                <span class="hljs-keyword">break</span>;            &#125;            <span class="hljs-keyword">if</span> (i &lt; j)                <span class="hljs-keyword">break</span>;            <span class="hljs-built_in">cout</span> &lt;&lt; a[i] &lt;&lt; <span class="hljs-built_in">endl</span>                 &lt;&lt; a[j] &lt;&lt; <span class="hljs-built_in">endl</span>;        &#125;        <span class="hljs-comment">// cout &lt;&lt; endl;</span>    &#125;&#125;</code></pre><h1 id="收获与反思"><a href="#收获与反思" class="headerlink" title="收获与反思"></a>收获与反思</h1><p>无</p>]]></content>
    
    
    <categories>
      
      <category>Computer Science</category>
      
      <category>ACM</category>
      
      <category>洛谷</category>
      
    </categories>
    
    
    <tags>
      
      <tag>ACM</tag>
      
      <tag>洛谷</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>【洛谷-P1603】解题报告（排序）</title>
    <link href="/post/2f392380.html"/>
    <url>/post/2f392380.html</url>
    
    <content type="html"><![CDATA[<h1 id="原始题目"><a href="#原始题目" class="headerlink" title="原始题目"></a>原始题目</h1><p><a href="https://www.luogu.org/problemnew/show/P1603" target="_blank" rel="noopener">P1603 斯诺登的密码</a></p><h1 id="题目大意"><a href="#题目大意" class="headerlink" title="题目大意"></a>题目大意</h1><p>找出英文字母表示的数字平方后%100排成一排，输出排列中最小的（开头去0）。</p><h1 id="解题思路"><a href="#解题思路" class="headerlink" title="解题思路"></a>解题思路</h1><p>排序后输出，头部的0。</p><a id="more"></a><h1 id="解题代码"><a href="#解题代码" class="headerlink" title="解题代码"></a>解题代码</h1><pre><code class="hljs C++">#include &lt;bits/stdc++.h&gt;using namespace std;typedef long long ll;typedef unsigned long long ull;typedef vector&lt;int&gt; vi;typedef pair&lt;int, int&gt; pii;#define rep(i, a, n) for (int i = a; i &lt; n; ++i)#define per(i, a, n) for (int i = n - 1; i &gt;= a; --i)#define pb push_back#define mp make_pair#define INF 0x3f3f3f3f#define EPS 1e-8#define all(x) x.begin(), x.end()const int maxn = 1e3 + 5;map&lt;string, int&gt; dic;void init()&#123;    dic.clear();    dic.insert(mp("one", (1 * 1 % 100)));    dic.insert(mp("two", (2 * 2 % 100)));    dic.insert(mp("three", (3 * 3 % 100)));    dic.insert(mp("four", (4 * 4 % 100)));    dic.insert(mp("five", (5 * 5 % 100)));    dic.insert(mp("six", (6 * 6 % 100)));    dic.insert(mp("seven", (7 * 7 % 100)));    dic.insert(mp("eight", (8 * 8 % 100)));    dic.insert(mp("nine", (9 * 9 % 100)));    dic.insert(mp("ten", (10 * 10 % 100)));    dic.insert(mp("eleven", (11 * 11 % 100)));    dic.insert(mp("twelve", (12 * 12 % 100)));    dic.insert(mp("thirteen", (13 * 13 % 100)));    dic.insert(mp("fourteen", (14 * 14 % 100)));    dic.insert(mp("fifteen", (15 * 15 % 100)));    dic.insert(mp("sixteen", (16 * 16 % 100)));    dic.insert(mp("seventeen", (17 * 17 % 100)));    dic.insert(mp("eighteen", (18 * 18 % 100)));    dic.insert(mp("nineteen", (19 * 19 % 100)));    dic.insert(mp("twenty", (20 * 20 % 100)));    //a both another first second third    dic.insert(mp("a", 1));    dic.insert(mp("both", 4));    dic.insert(mp("another", 1));    dic.insert(mp("first", 1));    dic.insert(mp("second", 4));    dic.insert(mp("third", 9));&#125;string ss;int a[maxn], cnt;int main()&#123;    ios::sync_with_stdio(false);    init();    while (getline(cin, ss)) &#123;        cnt = 0;        stringstream st(ss.substr(0, ss.length() - 1));        string temp;        while (st &gt;&gt; temp) &#123;            transform(all(temp), temp.begin(), ::tolower);            if (dic.count(temp) != 0) &#123;                a[cnt++] = dic[temp];            &#125;        &#125;        // cout &lt;&lt; "# cnt=" &lt;&lt; cnt &lt;&lt; endl;        // rep(i, 0, cnt) cout &lt;&lt; a[i] &lt;&lt; " ";        // cout &lt;&lt; endl;        sort(a, a + cnt);        int flag = 0;        int i = 0;        for (; i &lt; cnt; i++) &#123;            if (a[i] == 0)                continue;            flag = 1;            cout &lt;&lt; a[i];            i++;            break;        &#125;        if (flag == 0) &#123;            cout &lt;&lt; 0 &lt;&lt; endl;            continue;        &#125;        for (i; i &lt; cnt; i++) &#123;            cout &lt;&lt; setw(2) &lt;&lt; setfill('0') &lt;&lt; a[i];        &#125;        cout &lt;&lt; endl;    &#125;&#125;</code></pre><h1 id="收获与反思"><a href="#收获与反思" class="headerlink" title="收获与反思"></a>收获与反思</h1><p>无</p>]]></content>
    
    
    <categories>
      
      <category>Computer Science</category>
      
      <category>ACM</category>
      
      <category>洛谷</category>
      
    </categories>
    
    
    <tags>
      
      <tag>ACM</tag>
      
      <tag>洛谷</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>【洛谷-P1598】解题报告（字符串）</title>
    <link href="/post/541f3acd.html"/>
    <url>/post/541f3acd.html</url>
    
    <content type="html"><![CDATA[<h1 id="原始题目"><a href="#原始题目" class="headerlink" title="原始题目"></a>原始题目</h1><p><a href="https://www.luogu.org/problemnew/show/P1598" target="_blank" rel="noopener">P1598 垂直柱状图</a></p><h1 id="题目大意"><a href="#题目大意" class="headerlink" title="题目大意"></a>题目大意</h1><p>写一个程序从输入文件中去读取四行大写字母（全都是大写的，每行不超过100个字符），然后用柱状图输出每个字符在输入文件中出现的次数</p><h1 id="解题思路"><a href="#解题思路" class="headerlink" title="解题思路"></a>解题思路</h1><p>统计各字母出现频次以及频次最大值（作为高），然后按层从高低扫描，层≤该字母出现频次的时候输出。</p><a id="more"></a><h1 id="解题代码"><a href="#解题代码" class="headerlink" title="解题代码"></a>解题代码</h1><pre><code class="hljs C++"><span class="hljs-meta">#<span class="hljs-meta-keyword">include</span> <span class="hljs-meta-string">&lt;bits/stdc++.h&gt;</span></span><span class="hljs-keyword">using</span> <span class="hljs-keyword">namespace</span> <span class="hljs-built_in">std</span>;<span class="hljs-keyword">typedef</span> <span class="hljs-keyword">long</span> <span class="hljs-keyword">long</span> ll;<span class="hljs-keyword">typedef</span> <span class="hljs-keyword">unsigned</span> <span class="hljs-keyword">long</span> <span class="hljs-keyword">long</span> ull;<span class="hljs-keyword">const</span> <span class="hljs-keyword">int</span> maxn = <span class="hljs-number">1e5</span> + <span class="hljs-number">5</span>;<span class="hljs-meta">#<span class="hljs-meta-keyword">define</span> rep(i, a, n) for (int i = a; i &lt; n; ++i)</span><span class="hljs-meta">#<span class="hljs-meta-keyword">define</span> per(i, a, n) for (int i = n - 1; i &gt;= a; --i)</span><span class="hljs-meta">#<span class="hljs-meta-keyword">define</span> fi first</span><span class="hljs-meta">#<span class="hljs-meta-keyword">define</span> se second</span><span class="hljs-meta">#<span class="hljs-meta-keyword">define</span> pb push_back</span><span class="hljs-meta">#<span class="hljs-meta-keyword">define</span> np next_permutation</span><span class="hljs-meta">#<span class="hljs-meta-keyword">define</span> mp make_pair</span><span class="hljs-meta">#<span class="hljs-meta-keyword">define</span> endl <span class="hljs-meta-string">'\n'</span></span><span class="hljs-keyword">int</span> a[maxn];<span class="hljs-built_in">string</span> s;<span class="hljs-keyword">int</span> mmax;<span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span>&#123;    ios::sync_with_stdio(<span class="hljs-literal">false</span>);    mmax = <span class="hljs-number">-1</span>;    rep(i, <span class="hljs-number">0</span>, <span class="hljs-number">4</span>)    &#123;        getline(<span class="hljs-built_in">cin</span>, s);        rep(i, <span class="hljs-number">0</span>, s.length())        &#123;            <span class="hljs-keyword">if</span> (s[i] &gt;= <span class="hljs-string">'A'</span> &amp;&amp; s[i] &lt;= <span class="hljs-string">'Z'</span>) &#123;                a[s[i] - <span class="hljs-string">'A'</span>]++;                <span class="hljs-keyword">if</span> (a[s[i] - <span class="hljs-string">'A'</span>] &gt; mmax)                    mmax = a[s[i] - <span class="hljs-string">'A'</span>];            &#125;        &#125;    &#125;    <span class="hljs-comment">// rep(i, 0, 26) cout &lt;&lt; "#" &lt;&lt; a[i] &lt;&lt; endl;</span>    per(i, <span class="hljs-number">1</span>, mmax + <span class="hljs-number">1</span>)    &#123;        <span class="hljs-keyword">int</span> target = <span class="hljs-number">25</span>;        per(j, <span class="hljs-number">0</span>, <span class="hljs-number">26</span>)        &#123;            <span class="hljs-keyword">if</span> (a[j] &gt;= i) &#123;                target = j;                <span class="hljs-keyword">break</span>;            &#125;        &#125;        <span class="hljs-keyword">if</span> (a[<span class="hljs-number">0</span>] &gt;= i)            <span class="hljs-built_in">cout</span> &lt;&lt; <span class="hljs-string">"*"</span>;        <span class="hljs-keyword">else</span>            <span class="hljs-built_in">cout</span> &lt;&lt; <span class="hljs-string">" "</span>;        rep(j, <span class="hljs-number">1</span>, target + <span class="hljs-number">1</span>)        &#123;            <span class="hljs-keyword">if</span> (a[j] &gt;= i)                <span class="hljs-built_in">cout</span> &lt;&lt; <span class="hljs-string">" *"</span>;            <span class="hljs-keyword">else</span>                <span class="hljs-built_in">cout</span> &lt;&lt; <span class="hljs-string">"  "</span>;        &#125;        <span class="hljs-built_in">cout</span> &lt;&lt; <span class="hljs-built_in">endl</span>;    &#125;    <span class="hljs-built_in">cout</span> &lt;&lt; <span class="hljs-string">'A'</span>;    rep(i, <span class="hljs-number">1</span>, <span class="hljs-number">26</span>) <span class="hljs-built_in">cout</span> &lt;&lt; <span class="hljs-string">" "</span> &lt;&lt; <span class="hljs-keyword">char</span>(<span class="hljs-string">'A'</span> + i);    <span class="hljs-built_in">cout</span> &lt;&lt; <span class="hljs-built_in">endl</span>;    <span class="hljs-built_in">cin</span> &gt;&gt; mmax;&#125;</code></pre><h1 id="收获与反思"><a href="#收获与反思" class="headerlink" title="收获与反思"></a>收获与反思</h1><p>主要输出格式</p>]]></content>
    
    
    <categories>
      
      <category>Computer Science</category>
      
      <category>ACM</category>
      
      <category>洛谷</category>
      
    </categories>
    
    
    <tags>
      
      <tag>ACM</tag>
      
      <tag>洛谷</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>【洛谷-P1583】解题报告（排序）</title>
    <link href="/post/c544c33a.html"/>
    <url>/post/c544c33a.html</url>
    
    <content type="html"><![CDATA[<h1 id="原始题目"><a href="#原始题目" class="headerlink" title="原始题目"></a>原始题目</h1><p><a href="https://www.luogu.org/problemnew/show/P1603" target="_blank" rel="noopener">P1603 斯诺登的密码</a></p><h1 id="题目大意"><a href="#题目大意" class="headerlink" title="题目大意"></a>题目大意</h1><p>第一次根据初始权值分为10类（模10），第i类的人将会额外得到$E[i]$的权值，输出最终权值最大的k个人。</p><h1 id="解题思路"><a href="#解题思路" class="headerlink" title="解题思路"></a>解题思路</h1><p>两次排序。</p><a id="more"></a><h1 id="解题代码"><a href="#解题代码" class="headerlink" title="解题代码"></a>解题代码</h1><pre><code class="hljs C++"><span class="hljs-meta">#<span class="hljs-meta-keyword">include</span> <span class="hljs-meta-string">&lt;bits/stdc++.h&gt;</span></span><span class="hljs-keyword">using</span> <span class="hljs-keyword">namespace</span> <span class="hljs-built_in">std</span>;<span class="hljs-keyword">typedef</span> <span class="hljs-keyword">long</span> <span class="hljs-keyword">long</span> ll;<span class="hljs-keyword">typedef</span> <span class="hljs-keyword">unsigned</span> <span class="hljs-keyword">long</span> <span class="hljs-keyword">long</span> ull;<span class="hljs-keyword">const</span> <span class="hljs-keyword">int</span> maxn = <span class="hljs-number">1e5</span> + <span class="hljs-number">5</span>;<span class="hljs-meta">#<span class="hljs-meta-keyword">define</span> rep(i, a, n) for (int i = a; i &lt; n; ++i)</span><span class="hljs-meta">#<span class="hljs-meta-keyword">define</span> per(i, a, n) for (int i = n - 1; i &gt;= a; --i)</span><span class="hljs-meta">#<span class="hljs-meta-keyword">define</span> fi first</span><span class="hljs-meta">#<span class="hljs-meta-keyword">define</span> se second</span><span class="hljs-meta">#<span class="hljs-meta-keyword">define</span> pb push_back</span><span class="hljs-meta">#<span class="hljs-meta-keyword">define</span> np next_permutation</span><span class="hljs-meta">#<span class="hljs-meta-keyword">define</span> mp make_pair</span><span class="hljs-meta">#<span class="hljs-meta-keyword">define</span> endl <span class="hljs-meta-string">'\n'</span></span><span class="hljs-keyword">int</span> n, k;<span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">node</span> &#123;</span>    <span class="hljs-keyword">int</span> w, id;&#125;;node a[maxn];<span class="hljs-function"><span class="hljs-keyword">bool</span> <span class="hljs-title">cmp</span><span class="hljs-params">(node a, node b)</span></span>&#123;    <span class="hljs-keyword">if</span> (a.w != b.w)        <span class="hljs-keyword">return</span> a.w &gt; b.w;    <span class="hljs-keyword">else</span>        <span class="hljs-keyword">return</span> a.id &lt; b.id;&#125;<span class="hljs-keyword">int</span> add[<span class="hljs-number">20</span>];<span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span>&#123;    ios::sync_with_stdio(<span class="hljs-literal">false</span>);    <span class="hljs-keyword">while</span> (<span class="hljs-built_in">cin</span> &gt;&gt; n &gt;&gt; k) &#123;        rep(i, <span class="hljs-number">1</span>, <span class="hljs-number">10</span> + <span class="hljs-number">1</span>) <span class="hljs-built_in">cin</span> &gt;&gt; add[i];        rep(i, <span class="hljs-number">1</span>, n + <span class="hljs-number">1</span>)        &#123;            <span class="hljs-built_in">cin</span> &gt;&gt; a[i].w;            a[i].id = i;        &#125;        sort(a + <span class="hljs-number">1</span>, a + n + <span class="hljs-number">1</span>, cmp);        rep(i, <span class="hljs-number">1</span>, n + <span class="hljs-number">1</span>)        &#123;            a[i].w += add[(i - <span class="hljs-number">1</span>) % <span class="hljs-number">10</span> + <span class="hljs-number">1</span>];        &#125;        sort(a + <span class="hljs-number">1</span>, a + n + <span class="hljs-number">1</span>, cmp);        <span class="hljs-built_in">cout</span> &lt;&lt; a[<span class="hljs-number">1</span>].id;        rep(i, <span class="hljs-number">2</span>, k + <span class="hljs-number">1</span>)        &#123;            <span class="hljs-built_in">cout</span> &lt;&lt; <span class="hljs-string">" "</span> &lt;&lt; a[i].id;        &#125;        <span class="hljs-built_in">cout</span> &lt;&lt; <span class="hljs-built_in">endl</span>;    &#125;&#125;</code></pre><h1 id="收获与反思"><a href="#收获与反思" class="headerlink" title="收获与反思"></a>收获与反思</h1><p>无</p>]]></content>
    
    
    <categories>
      
      <category>Computer Science</category>
      
      <category>ACM</category>
      
      <category>洛谷</category>
      
    </categories>
    
    
    <tags>
      
      <tag>ACM</tag>
      
      <tag>洛谷</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>【洛谷-P1553】解题报告（字符串）</title>
    <link href="/post/a2966b48.html"/>
    <url>/post/a2966b48.html</url>
    
    <content type="html"><![CDATA[<h1 id="原始题目"><a href="#原始题目" class="headerlink" title="原始题目"></a>原始题目</h1><p><a href="https://www.luogu.org/problemnew/show/P1553" target="_blank" rel="noopener">P1553 数字反转（升级版）</a></p><h1 id="题目大意"><a href="#题目大意" class="headerlink" title="题目大意"></a>题目大意</h1><p>小数，分数，百分数，整数按照对应的规则反转后输出。</p><h1 id="解题思路"><a href="#解题思路" class="headerlink" title="解题思路"></a>解题思路</h1><p>按要求模拟操作就行</p><a id="more"></a><h1 id="解题代码"><a href="#解题代码" class="headerlink" title="解题代码"></a>解题代码</h1><pre><code class="hljs C++"><span class="hljs-meta">#<span class="hljs-meta-keyword">include</span> <span class="hljs-meta-string">&lt;bits/stdc++.h&gt;</span></span><span class="hljs-keyword">using</span> <span class="hljs-keyword">namespace</span> <span class="hljs-built_in">std</span>;<span class="hljs-keyword">typedef</span> <span class="hljs-keyword">long</span> <span class="hljs-keyword">long</span> ll;<span class="hljs-keyword">typedef</span> <span class="hljs-keyword">unsigned</span> <span class="hljs-keyword">long</span> <span class="hljs-keyword">long</span> ull;<span class="hljs-keyword">typedef</span> <span class="hljs-built_in">vector</span>&lt;<span class="hljs-keyword">int</span>&gt; vi;<span class="hljs-keyword">typedef</span> pair&lt;<span class="hljs-keyword">int</span>, <span class="hljs-keyword">int</span>&gt; pii;<span class="hljs-keyword">typedef</span> pair&lt;<span class="hljs-built_in">string</span>, <span class="hljs-built_in">string</span>&gt; pss;<span class="hljs-meta">#<span class="hljs-meta-keyword">define</span> rep(i, a, n) for (int i = a; i &lt; n; ++i)</span><span class="hljs-meta">#<span class="hljs-meta-keyword">define</span> per(i, a, n) for (int i = n - 1; i &gt;= a; --i)</span><span class="hljs-meta">#<span class="hljs-meta-keyword">define</span> fi first</span><span class="hljs-meta">#<span class="hljs-meta-keyword">define</span> se second</span><span class="hljs-meta">#<span class="hljs-meta-keyword">define</span> mp make_pair</span><span class="hljs-meta">#<span class="hljs-meta-keyword">define</span> pb push_back</span><span class="hljs-meta">#<span class="hljs-meta-keyword">define</span> all(x) x.begin(), x.end()</span><span class="hljs-keyword">const</span> <span class="hljs-keyword">int</span> maxn = <span class="hljs-number">1e5</span> + <span class="hljs-number">5</span>;<span class="hljs-built_in">string</span> s, s1, s2;<span class="hljs-comment">//写成函数形式</span><span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">checkprint</span><span class="hljs-params">(<span class="hljs-built_in">string</span> sss)</span></span>&#123;    reverse(all(sss));    <span class="hljs-keyword">int</span> flag = <span class="hljs-number">1</span>;    rep(i, <span class="hljs-number">0</span>, sss.length())    &#123;        <span class="hljs-keyword">if</span> (sss[i] == <span class="hljs-string">'0'</span> &amp;&amp; flag)            <span class="hljs-keyword">continue</span>;        <span class="hljs-built_in">cout</span> &lt;&lt; sss[i];        flag = <span class="hljs-number">0</span>;    &#125;    <span class="hljs-keyword">if</span> (flag)        <span class="hljs-built_in">cout</span> &lt;&lt; <span class="hljs-number">0</span>;&#125;<span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span>&#123;    ios::sync_with_stdio(<span class="hljs-literal">false</span>);    <span class="hljs-keyword">while</span> (<span class="hljs-built_in">cin</span> &gt;&gt; s) &#123;        <span class="hljs-keyword">int</span> temp1 = s.find(<span class="hljs-string">'/'</span>);        <span class="hljs-keyword">int</span> temp2 = s.find(<span class="hljs-string">'.'</span>);        <span class="hljs-keyword">int</span> temp3 = s.find(<span class="hljs-string">'%'</span>);        <span class="hljs-keyword">if</span> (temp1 != <span class="hljs-number">-1</span>) &#123;            s1 = s.substr(<span class="hljs-number">0</span>, temp1);            s2 = s.substr(temp1 + <span class="hljs-number">1</span>, s.length() - s1.length() - <span class="hljs-number">1</span>);            checkprint(s1);            <span class="hljs-built_in">cout</span> &lt;&lt; <span class="hljs-string">"/"</span>;            checkprint(s2);            <span class="hljs-built_in">cout</span> &lt;&lt; <span class="hljs-built_in">endl</span>;        &#125; <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (temp2 != <span class="hljs-number">-1</span>) &#123;            s1 = s.substr(<span class="hljs-number">0</span>, temp2);            checkprint(s1);            <span class="hljs-built_in">cout</span> &lt;&lt; <span class="hljs-string">"."</span>;            s2 = s.substr(temp2 + <span class="hljs-number">1</span>, s.length() - s1.length() - <span class="hljs-number">1</span>);            <span class="hljs-keyword">int</span> tempi = <span class="hljs-number">0</span>;            <span class="hljs-keyword">while</span> (tempi &lt; s2.length() &amp;&amp; s2[tempi] == <span class="hljs-string">'0'</span>)                tempi++;            <span class="hljs-keyword">if</span> (tempi == s2.length())                <span class="hljs-built_in">cout</span> &lt;&lt; <span class="hljs-number">0</span> &lt;&lt; <span class="hljs-built_in">endl</span>;            <span class="hljs-keyword">else</span> &#123;                <span class="hljs-built_in">string</span> s3 = s2.substr(tempi, s2.length() - tempi);                reverse(all(s3));                <span class="hljs-built_in">cout</span> &lt;&lt; s3 &lt;&lt; <span class="hljs-built_in">endl</span>;            &#125;        &#125; <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (temp3 != <span class="hljs-number">-1</span>) &#123;            s1 = s.substr(<span class="hljs-number">0</span>, temp3);            checkprint(s1);            <span class="hljs-built_in">cout</span> &lt;&lt; <span class="hljs-string">"%"</span> &lt;&lt; <span class="hljs-built_in">endl</span>;        &#125; <span class="hljs-keyword">else</span> &#123;            checkprint(s);            <span class="hljs-built_in">cout</span> &lt;&lt; <span class="hljs-built_in">endl</span>;        &#125;    &#125;&#125;</code></pre><h1 id="收获与反思"><a href="#收获与反思" class="headerlink" title="收获与反思"></a>收获与反思</h1><p>注意细节，印象中去0还有百分数开始写崩了。</p>]]></content>
    
    
    <categories>
      
      <category>Computer Science</category>
      
      <category>ACM</category>
      
      <category>洛谷</category>
      
    </categories>
    
    
    <tags>
      
      <tag>ACM</tag>
      
      <tag>洛谷</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>【洛谷-P1540】解题报告（模拟）</title>
    <link href="/post/d2760377.html"/>
    <url>/post/d2760377.html</url>
    
    <content type="html"><![CDATA[<h1 id="原始题目"><a href="#原始题目" class="headerlink" title="原始题目"></a>原始题目</h1><p><a href="https://www.luogu.org/problemnew/show/P1540" target="_blank" rel="noopener">P1540 机器翻译</a></p><h1 id="题目大意"><a href="#题目大意" class="headerlink" title="题目大意"></a>题目大意</h1><p>给出内存容量和查找数列，求访问外存数量</p><h1 id="解题思路"><a href="#解题思路" class="headerlink" title="解题思路"></a>解题思路</h1><p>队列模拟（事后想想不需要，记录当前容量就行），vis数组记录状态。</p><a id="more"></a><h1 id="解题代码"><a href="#解题代码" class="headerlink" title="解题代码"></a>解题代码</h1><pre><code class="hljs C++"><span class="hljs-meta">#<span class="hljs-meta-keyword">include</span> <span class="hljs-meta-string">&lt;bits/stdc++.h&gt;</span></span><span class="hljs-keyword">using</span> <span class="hljs-keyword">namespace</span> <span class="hljs-built_in">std</span>;<span class="hljs-keyword">typedef</span> <span class="hljs-keyword">long</span> <span class="hljs-keyword">long</span> ll;<span class="hljs-keyword">const</span> <span class="hljs-keyword">int</span> maxn = <span class="hljs-number">1e5</span> + <span class="hljs-number">5</span>;<span class="hljs-meta">#<span class="hljs-meta-keyword">define</span> rep(i, a, b) for (int i = a; i &lt; b; ++i)</span><span class="hljs-meta">#<span class="hljs-meta-keyword">define</span> per(i, a, b) for (int i = b - 1; i &gt;= a; --i)</span><span class="hljs-keyword">int</span> vis[maxn];<span class="hljs-built_in">queue</span>&lt;<span class="hljs-keyword">int</span>&gt; q;<span class="hljs-keyword">int</span> n, m;<span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span>&#123;    ios::sync_with_stdio(<span class="hljs-literal">false</span>);    <span class="hljs-keyword">while</span> (<span class="hljs-built_in">cin</span> &gt;&gt; n &gt;&gt; m) &#123;        <span class="hljs-comment">// s.clear();</span>        <span class="hljs-built_in">memset</span>(vis, <span class="hljs-number">0</span>, <span class="hljs-keyword">sizeof</span>(vis));        <span class="hljs-keyword">int</span> ans = <span class="hljs-number">0</span>;        rep(i, <span class="hljs-number">0</span>, m)        &#123;            <span class="hljs-keyword">int</span> a;            <span class="hljs-built_in">cin</span> &gt;&gt; a;            <span class="hljs-keyword">if</span> (vis[a])                <span class="hljs-keyword">continue</span>;            <span class="hljs-keyword">else</span> &#123;                <span class="hljs-keyword">if</span> (q.size() == n) &#123;                    <span class="hljs-keyword">int</span> temp = q.front();                    q.pop();                    vis[temp] = <span class="hljs-number">0</span>;                    vis[a] = <span class="hljs-number">1</span>;                    q.push(a);                    ans++;                &#125; <span class="hljs-keyword">else</span> &#123;                    q.push(a);                    vis[a] = <span class="hljs-number">1</span>;                    ans++;                &#125;            &#125;        &#125;        <span class="hljs-built_in">cout</span> &lt;&lt; ans &lt;&lt; <span class="hljs-built_in">endl</span>;    &#125;    <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;&#125;</code></pre><h1 id="收获与反思"><a href="#收获与反思" class="headerlink" title="收获与反思"></a>收获与反思</h1><p>无</p>]]></content>
    
    
    <categories>
      
      <category>Computer Science</category>
      
      <category>ACM</category>
      
      <category>洛谷</category>
      
    </categories>
    
    
    <tags>
      
      <tag>ACM</tag>
      
      <tag>洛谷</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>【洛谷-P1525】解题报告（二分图，二分）</title>
    <link href="/post/749ff2bc.html"/>
    <url>/post/749ff2bc.html</url>
    
    <content type="html"><![CDATA[<h1 id="原始题目"><a href="#原始题目" class="headerlink" title="原始题目"></a>原始题目</h1><p><a href="https://www.luogu.org/problemnew/show/P1525" target="_blank" rel="noopener">P1525 关押罪犯</a></p><h1 id="题目大意"><a href="#题目大意" class="headerlink" title="题目大意"></a>题目大意</h1><p>N个罪犯，M对矛盾关系，分成两个集合，同一集合的里有矛盾关系的会产生矛盾，冲突事件影响力为当前两个集合中矛盾关系值得最大值，求怎么分配使得冲突最小</p><h1 id="解题思路"><a href="#解题思路" class="headerlink" title="解题思路"></a>解题思路</h1><ol><li><p>二分图+二分答案</p><p> 博客中作为二分图的练习题，二分冲突影响（答案），判断在该条件下能否构成二分图（矛盾值小于判断答案的就忽略该条边）。</p></li><li><p>并查集+贪心</p><p> 按值从大大小排序所有的冲突值，然后按序判断当前边连接两点是否已在一个集合中，若在则跳出判断输出当前冲突变得值，若在则秉持<strong>敌人的敌人当朋友</strong>进行Merge，可以证明，Merge到的集合内就算产生了新的冲突，由于我们是按冲突值从大到小访问的，矛盾（该变会在更靠前位置拆分，不会出现这种情况）。而且满足最优子结构，全局解必然包括当前的最优解。</p></li></ol><a id="more"></a><h1 id="解题代码"><a href="#解题代码" class="headerlink" title="解题代码"></a>解题代码</h1><p>二分图+二分答案</p><pre><code class="hljs C++"><span class="hljs-meta">#<span class="hljs-meta-keyword">include</span> <span class="hljs-meta-string">&lt;bits/stdc++.h&gt;</span></span><span class="hljs-keyword">using</span> <span class="hljs-keyword">namespace</span> <span class="hljs-built_in">std</span>;<span class="hljs-keyword">typedef</span> <span class="hljs-keyword">long</span> <span class="hljs-keyword">long</span> ll;<span class="hljs-keyword">typedef</span> <span class="hljs-keyword">unsigned</span> <span class="hljs-keyword">long</span> <span class="hljs-keyword">long</span> ull;<span class="hljs-keyword">typedef</span> <span class="hljs-built_in">vector</span>&lt;<span class="hljs-keyword">int</span>&gt; vi;<span class="hljs-keyword">typedef</span> pair&lt;<span class="hljs-keyword">int</span>, <span class="hljs-keyword">int</span>&gt; pii;<span class="hljs-meta">#<span class="hljs-meta-keyword">define</span> rep(i, a, n) for (int i = a; i &lt; n; ++i)</span><span class="hljs-meta">#<span class="hljs-meta-keyword">define</span> per(i, a, n) for (int i = n - 1; i &gt;= a; --i)</span><span class="hljs-meta">#<span class="hljs-meta-keyword">define</span> fi first</span><span class="hljs-meta">#<span class="hljs-meta-keyword">define</span> pb push_back</span><span class="hljs-meta">#<span class="hljs-meta-keyword">define</span> mp make_pair</span><span class="hljs-meta">#<span class="hljs-meta-keyword">define</span> EPS 1e-8</span><span class="hljs-meta">#<span class="hljs-meta-keyword">define</span> INF 0x3f3f3f3f3f</span><span class="hljs-meta">#<span class="hljs-meta-keyword">define</span> endl <span class="hljs-meta-string">'\n'</span></span><span class="hljs-meta">#<span class="hljs-meta-keyword">define</span> all(x) x.bgein(), x.end()</span><span class="hljs-keyword">const</span> <span class="hljs-keyword">int</span> maxn = <span class="hljs-number">2e4</span> + <span class="hljs-number">5</span>;<span class="hljs-keyword">const</span> <span class="hljs-keyword">int</span> maxm = <span class="hljs-number">2e5</span> + <span class="hljs-number">5</span>;<span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">Edge</span> &#123;</span>    <span class="hljs-keyword">int</span> u, v, w;    Edge(<span class="hljs-keyword">int</span> _u, <span class="hljs-keyword">int</span> _v, <span class="hljs-keyword">int</span> _w)        : u(_u)        , v(_v)        , w(_w)    &#123;    &#125;    Edge() &#123;&#125;    <span class="hljs-keyword">bool</span> <span class="hljs-keyword">operator</span>&lt;(<span class="hljs-keyword">const</span> Edge b) &#123; <span class="hljs-keyword">return</span> w &gt; b.w; &#125;&#125; p[maxm];<span class="hljs-built_in">vector</span>&lt;pii&gt; e[maxn];<span class="hljs-keyword">int</span> n, m, k, t, vis[maxn];<span class="hljs-function"><span class="hljs-keyword">inline</span> <span class="hljs-keyword">void</span> <span class="hljs-title">init</span><span class="hljs-params">()</span></span>&#123;    rep(i, <span class="hljs-number">0</span>, n + <span class="hljs-number">1</span>) e[i].clear();&#125;<span class="hljs-function"><span class="hljs-keyword">bool</span> <span class="hljs-title">dfs</span><span class="hljs-params">(<span class="hljs-keyword">int</span> x, <span class="hljs-keyword">int</span> co)</span></span>&#123;    vis[x] = co;    rep(i, <span class="hljs-number">0</span>, e[x].size())    &#123;        <span class="hljs-keyword">int</span> y = e[x][i].first;        <span class="hljs-keyword">if</span> (vis[y] == co)            <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;        <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (!vis[y] &amp;&amp; !dfs(y, <span class="hljs-number">3</span> - co))            <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;    &#125;    <span class="hljs-keyword">return</span> <span class="hljs-number">1</span>;&#125;<span class="hljs-function"><span class="hljs-keyword">inline</span> <span class="hljs-keyword">bool</span> <span class="hljs-title">pd</span><span class="hljs-params">(<span class="hljs-keyword">int</span> mid)</span></span>&#123;    init();    <span class="hljs-built_in">memset</span>(vis, <span class="hljs-number">0</span>, <span class="hljs-keyword">sizeof</span>(vis));    rep(i, <span class="hljs-number">0</span>, m)    &#123;        <span class="hljs-keyword">if</span> (p[i].w &lt;= mid)            <span class="hljs-keyword">break</span>;        e[p[i].u].pb(mp(p[i].v, p[i].w));        e[p[i].v].pb(mp(p[i].u, p[i].w));    &#125;    rep(i, <span class="hljs-number">1</span>, n + <span class="hljs-number">1</span>)    &#123;        <span class="hljs-keyword">if</span> (!vis[i] &amp;&amp; !dfs(i, <span class="hljs-number">1</span>))            <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;    &#125;    <span class="hljs-keyword">return</span> <span class="hljs-number">1</span>;&#125;<span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span>&#123;    ios::sync_with_stdio(<span class="hljs-literal">false</span>);    <span class="hljs-keyword">while</span> (<span class="hljs-built_in">cin</span> &gt;&gt; n &gt;&gt; m) &#123;        rep(i, <span class="hljs-number">0</span>, m)        &#123;            <span class="hljs-built_in">cin</span> &gt;&gt; p[i].u &gt;&gt; p[i].v &gt;&gt; p[i].w;        &#125;        sort(p, p + m);        <span class="hljs-keyword">int</span> l = <span class="hljs-number">0</span>, r = p[<span class="hljs-number">0</span>].w, mid;        <span class="hljs-keyword">while</span> (l &lt; r) &#123;            mid = (l + r) &gt;&gt; <span class="hljs-number">1</span>;            <span class="hljs-keyword">if</span> (pd(mid))                r = mid;            <span class="hljs-keyword">else</span>                l = mid + <span class="hljs-number">1</span>;        &#125;        <span class="hljs-built_in">cout</span> &lt;&lt; l &lt;&lt; <span class="hljs-built_in">endl</span>;    &#125;&#125;</code></pre><p>并查集（待补充）</p><h1 id="收获与反思"><a href="#收获与反思" class="headerlink" title="收获与反思"></a>收获与反思</h1><p>二分图判定染色法（待补充）</p>]]></content>
    
    
    <categories>
      
      <category>Computer Science</category>
      
      <category>ACM</category>
      
      <category>洛谷</category>
      
    </categories>
    
    
    <tags>
      
      <tag>ACM</tag>
      
      <tag>洛谷</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>【洛谷-P1243】解题报告（排序）</title>
    <link href="/post/89d4cd71.html"/>
    <url>/post/89d4cd71.html</url>
    
    <content type="html"><![CDATA[<h1 id="原始题目"><a href="#原始题目" class="headerlink" title="原始题目"></a>原始题目</h1><p><a href="https://www.luogu.org/problemnew/show/P1243" target="_blank" rel="noopener">P1243 排序集合</a></p><h1 id="题目大意"><a href="#题目大意" class="headerlink" title="题目大意"></a>题目大意</h1><p>对于集合 $N={1,2,⋯,n} $的子集，输出第k小的集合。小于关系为字典序。</p><h1 id="解题思路"><a href="#解题思路" class="headerlink" title="解题思路"></a>解题思路</h1><p>这个题不是二进制位序，回溯根据第n+1-k大输出对应位置，可以提前预处理出后面元素数的前缀和（1,3,7,15…），然后用lower_bound确定位置。</p><a id="more"></a><h1 id="解题代码"><a href="#解题代码" class="headerlink" title="解题代码"></a>解题代码</h1><pre><code class="hljs C++"><span class="hljs-meta">#<span class="hljs-meta-keyword">include</span> <span class="hljs-meta-string">&lt;bits/stdc++.h&gt;</span></span><span class="hljs-keyword">using</span> <span class="hljs-keyword">namespace</span> <span class="hljs-built_in">std</span>;<span class="hljs-keyword">typedef</span> <span class="hljs-keyword">long</span> <span class="hljs-keyword">long</span> ll;<span class="hljs-keyword">typedef</span> <span class="hljs-keyword">unsigned</span> <span class="hljs-keyword">long</span> <span class="hljs-keyword">long</span> ull;<span class="hljs-keyword">typedef</span> <span class="hljs-built_in">vector</span>&lt;<span class="hljs-keyword">int</span>&gt; vi;<span class="hljs-keyword">typedef</span> pair&lt;<span class="hljs-keyword">int</span>, <span class="hljs-keyword">int</span>&gt; pii;<span class="hljs-keyword">typedef</span> pair&lt;<span class="hljs-built_in">string</span>, <span class="hljs-built_in">string</span>&gt; pss;<span class="hljs-meta">#<span class="hljs-meta-keyword">define</span> rep(i, a, n) for (int i = a; i &lt; n; ++i)</span><span class="hljs-meta">#<span class="hljs-meta-keyword">define</span> per(i, a, n) for (int i = n - 1; i &gt;= a; --i)</span><span class="hljs-meta">#<span class="hljs-meta-keyword">define</span> fi first</span><span class="hljs-meta">#<span class="hljs-meta-keyword">define</span> se second</span><span class="hljs-meta">#<span class="hljs-meta-keyword">define</span> pb push_back</span><span class="hljs-meta">#<span class="hljs-meta-keyword">define</span> np next_permutation</span><span class="hljs-meta">#<span class="hljs-meta-keyword">define</span> mp make_pair</span><span class="hljs-meta">#<span class="hljs-meta-keyword">define</span> endl <span class="hljs-meta-string">'\n'</span></span><span class="hljs-meta">#<span class="hljs-meta-keyword">define</span> INF 0x3f3f3f3f</span><span class="hljs-keyword">const</span> <span class="hljs-keyword">int</span> maxn = <span class="hljs-number">1e5</span> + <span class="hljs-number">5</span>;ll a[maxn], presum[maxn];<span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">init</span><span class="hljs-params">()</span></span>&#123;    a[<span class="hljs-number">0</span>] = presum[<span class="hljs-number">0</span>] = <span class="hljs-number">1</span>;    rep(i, <span class="hljs-number">1</span>, <span class="hljs-number">33</span>)    &#123;        a[i] = a[i - <span class="hljs-number">1</span>] * <span class="hljs-number">2</span>;        presum[i] = presum[i - <span class="hljs-number">1</span>] + a[i];    &#125;&#125;ll n, t;vi ans;<span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">solve</span><span class="hljs-params">(ll start, ll len, ll cnt)</span></span>&#123;    <span class="hljs-comment">// cout &lt;&lt; "(" &lt;&lt; start &lt;&lt; " " &lt;&lt; len &lt;&lt; " " &lt;&lt; cnt &lt;&lt; ")" &lt;&lt; endl;</span>    <span class="hljs-keyword">int</span> index = lower_bound(presum, presum + len, cnt) - presum;    <span class="hljs-comment">// cout &lt;&lt; "len-index=" &lt;&lt; len - index &lt;&lt; endl;</span>    <span class="hljs-keyword">if</span> (cnt == presum[index - <span class="hljs-number">1</span>]) &#123;        ans.pb(start + len - index + <span class="hljs-number">1</span>);        <span class="hljs-keyword">return</span>;    &#125;    <span class="hljs-keyword">if</span> (index == len) &#123;        <span class="hljs-keyword">return</span>;    &#125;    ans.pb(start + len - index);    solve(start + len - index, index, cnt - presum[index - <span class="hljs-number">1</span>]);&#125;<span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span>&#123;    <span class="hljs-comment">// ios::sync_with_stdio(false);</span>    init();    <span class="hljs-keyword">while</span> (<span class="hljs-built_in">cin</span> &gt;&gt; n &gt;&gt; t) &#123;        ans.clear();        ll temp = <span class="hljs-number">2</span>;        rep(i, <span class="hljs-number">1</span>, n) temp *= <span class="hljs-number">2</span>;        solve(<span class="hljs-number">0</span>, n, temp + <span class="hljs-number">1</span> - t);        <span class="hljs-keyword">if</span> (!ans.size()) &#123;            <span class="hljs-built_in">cout</span> &lt;&lt; <span class="hljs-string">"0"</span> &lt;&lt; <span class="hljs-built_in">endl</span>;            <span class="hljs-keyword">continue</span>;        &#125;        <span class="hljs-built_in">cout</span> &lt;&lt; ans[<span class="hljs-number">0</span>];        rep(i, <span class="hljs-number">1</span>, ans.size())        &#123;            <span class="hljs-built_in">cout</span> &lt;&lt; <span class="hljs-string">" "</span> &lt;&lt; ans[i];        &#125;        <span class="hljs-built_in">cout</span> &lt;&lt; <span class="hljs-built_in">endl</span>;    &#125;&#125;</code></pre><h1 id="收获与反思"><a href="#收获与反思" class="headerlink" title="收获与反思"></a>收获与反思</h1><p>这个题感觉应该有更好的做法</p>]]></content>
    
    
    <categories>
      
      <category>Computer Science</category>
      
      <category>ACM</category>
      
      <category>洛谷</category>
      
    </categories>
    
    
    <tags>
      
      <tag>ACM</tag>
      
      <tag>洛谷</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>【洛谷-P1200】解题报告（字符串）</title>
    <link href="/post/b133bf62.html"/>
    <url>/post/b133bf62.html</url>
    
    <content type="html"><![CDATA[<h1 id="原始题目"><a href="#原始题目" class="headerlink" title="原始题目"></a>原始题目</h1><p><a href="https://www.luogu.org/problemnew/show/P1200" target="_blank" rel="noopener">P1200 [USACO1.1]你的飞碟在这儿</a></p><h1 id="题目大意"><a href="#题目大意" class="headerlink" title="题目大意"></a>题目大意</h1><p>字母’A’~’Z’对应1到26，字符串hash为对应值相乘mod47，若两字符串相等则输出”GO”,否则”STAY”.</p><h1 id="解题思路"><a href="#解题思路" class="headerlink" title="解题思路"></a>解题思路</h1><p>字符串hash</p><a id="more"></a><h1 id="解题代码"><a href="#解题代码" class="headerlink" title="解题代码"></a>解题代码</h1><pre><code class="hljs C++"><span class="hljs-meta">#<span class="hljs-meta-keyword">include</span> <span class="hljs-meta-string">&lt;bits/stdc++.h&gt;</span></span><span class="hljs-meta">#<span class="hljs-meta-keyword">include</span> <span class="hljs-meta-string">&lt;sstream&gt;</span></span><span class="hljs-keyword">using</span> <span class="hljs-keyword">namespace</span> <span class="hljs-built_in">std</span>;<span class="hljs-keyword">typedef</span> <span class="hljs-keyword">long</span> <span class="hljs-keyword">long</span> ll;<span class="hljs-keyword">typedef</span> <span class="hljs-keyword">unsigned</span> <span class="hljs-keyword">long</span> <span class="hljs-keyword">long</span> ull;<span class="hljs-keyword">typedef</span> <span class="hljs-built_in">vector</span>&lt;<span class="hljs-keyword">int</span>&gt; vi;<span class="hljs-keyword">typedef</span> pair&lt;<span class="hljs-keyword">int</span>, <span class="hljs-keyword">int</span>&gt; pii;<span class="hljs-keyword">typedef</span> pair&lt;<span class="hljs-built_in">string</span>, <span class="hljs-built_in">string</span>&gt; pss;<span class="hljs-meta">#<span class="hljs-meta-keyword">define</span> rep(i, a, n) for (int i = a; i &lt; n; ++i)</span><span class="hljs-meta">#<span class="hljs-meta-keyword">define</span> per(i, a, n) for (int i = n - 1; i &gt;= a; --i)</span><span class="hljs-meta">#<span class="hljs-meta-keyword">define</span> fi first</span><span class="hljs-meta">#<span class="hljs-meta-keyword">define</span> se second</span><span class="hljs-meta">#<span class="hljs-meta-keyword">define</span> pb push_back</span><span class="hljs-meta">#<span class="hljs-meta-keyword">define</span> mp make_pair</span><span class="hljs-meta">#<span class="hljs-meta-keyword">define</span> np next_permutation</span><span class="hljs-meta">#<span class="hljs-meta-keyword">define</span> INF 0x3f3f3f3f</span><span class="hljs-meta">#<span class="hljs-meta-keyword">define</span> EPS 1e-8</span><span class="hljs-meta">#<span class="hljs-meta-keyword">define</span> endl <span class="hljs-meta-string">'\n'</span></span><span class="hljs-built_in">string</span> a, b;<span class="hljs-keyword">const</span> <span class="hljs-keyword">int</span> mod = <span class="hljs-number">47</span>;<span class="hljs-keyword">const</span> <span class="hljs-keyword">int</span> maxn = <span class="hljs-number">1e5</span> + <span class="hljs-number">5</span>;<span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span>&#123;    ios::sync_with_stdio(<span class="hljs-literal">false</span>);    <span class="hljs-keyword">while</span> (<span class="hljs-built_in">cin</span> &gt;&gt; a &gt;&gt; b) &#123;        <span class="hljs-keyword">int</span> ans = <span class="hljs-number">1</span>, ans2 = <span class="hljs-number">1</span>;        rep(i, <span class="hljs-number">0</span>, a.length())        &#123;            ans = (ans * (a[i] - <span class="hljs-string">'A'</span> + <span class="hljs-number">1</span>)) % mod;        &#125;        rep(i, <span class="hljs-number">0</span>, b.length())        &#123;            ans2 = (ans2 * (b[i] - <span class="hljs-string">'A'</span> + <span class="hljs-number">1</span>)) % mod;        &#125;        <span class="hljs-keyword">if</span> (ans == ans2)            <span class="hljs-built_in">cout</span> &lt;&lt; <span class="hljs-string">"GO"</span> &lt;&lt; <span class="hljs-built_in">endl</span>;        <span class="hljs-keyword">else</span>            <span class="hljs-built_in">cout</span> &lt;&lt; <span class="hljs-string">"STAY"</span> &lt;&lt; <span class="hljs-built_in">endl</span>;    &#125;&#125;</code></pre><h1 id="收获与反思"><a href="#收获与反思" class="headerlink" title="收获与反思"></a>收获与反思</h1><p>字符串hash入门</p>]]></content>
    
    
    <categories>
      
      <category>Computer Science</category>
      
      <category>ACM</category>
      
      <category>洛谷</category>
      
    </categories>
    
    
    <tags>
      
      <tag>ACM</tag>
      
      <tag>洛谷</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>【洛谷-P1177】解题报告（排序）</title>
    <link href="/post/6eaa7771.html"/>
    <url>/post/6eaa7771.html</url>
    
    <content type="html"><![CDATA[<h1 id="原始题目"><a href="#原始题目" class="headerlink" title="原始题目"></a>原始题目</h1><p><a href="https://www.luogu.org/problemnew/show/P1177" target="_blank" rel="noopener">P1177 【模板】快速排序</a></p><h1 id="题目大意"><a href="#题目大意" class="headerlink" title="题目大意"></a>题目大意</h1><p>快排模板不解释</p><h1 id="解题思路"><a href="#解题思路" class="headerlink" title="解题思路"></a>解题思路</h1><p>快排模板不解释</p><a id="more"></a><h1 id="解题代码"><a href="#解题代码" class="headerlink" title="解题代码"></a>解题代码</h1><pre><code class="hljs C++"><span class="hljs-meta">#<span class="hljs-meta-keyword">include</span> <span class="hljs-meta-string">&lt;bits/stdc++.h&gt;</span></span><span class="hljs-keyword">using</span> <span class="hljs-keyword">namespace</span> <span class="hljs-built_in">std</span>;<span class="hljs-keyword">typedef</span> <span class="hljs-keyword">long</span> <span class="hljs-keyword">long</span> ll;<span class="hljs-keyword">typedef</span> <span class="hljs-keyword">unsigned</span> <span class="hljs-keyword">long</span> <span class="hljs-keyword">long</span> ull;<span class="hljs-keyword">const</span> <span class="hljs-keyword">int</span> maxn = <span class="hljs-number">1e5</span> + <span class="hljs-number">5</span>;<span class="hljs-meta">#<span class="hljs-meta-keyword">define</span> rep(i, a, n) for (int i = a; i &lt; n; ++i)</span><span class="hljs-meta">#<span class="hljs-meta-keyword">define</span> per(i, a, n) for (int i = n - 1; i &gt;= a; --i)</span><span class="hljs-meta">#<span class="hljs-meta-keyword">define</span> fi first</span><span class="hljs-meta">#<span class="hljs-meta-keyword">define</span> se second</span><span class="hljs-meta">#<span class="hljs-meta-keyword">define</span> pb push_back</span><span class="hljs-meta">#<span class="hljs-meta-keyword">define</span> np next_permutation</span><span class="hljs-meta">#<span class="hljs-meta-keyword">define</span> mp make_pair</span><span class="hljs-keyword">int</span> a[maxn], n, vis[maxn];<span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span>&#123;    ios::sync_with_stdio(<span class="hljs-literal">false</span>);    <span class="hljs-keyword">while</span> (<span class="hljs-built_in">cin</span> &gt;&gt; n) &#123;        <span class="hljs-built_in">memset</span>(vis, <span class="hljs-number">0</span>, <span class="hljs-keyword">sizeof</span>(vis));        <span class="hljs-keyword">int</span> cnt = <span class="hljs-number">0</span>;        rep(i, <span class="hljs-number">0</span>, n)        &#123;            <span class="hljs-keyword">int</span> temp;            <span class="hljs-built_in">cin</span> &gt;&gt; temp;            <span class="hljs-keyword">if</span> (!vis[temp]) &#123;                a[cnt++] = temp;                vis[temp] = <span class="hljs-number">1</span>;            &#125;        &#125;        sort(a, a + cnt);        <span class="hljs-built_in">cout</span> &lt;&lt; cnt &lt;&lt; <span class="hljs-string">"\n"</span>;        <span class="hljs-built_in">cout</span> &lt;&lt; a[<span class="hljs-number">0</span>];        rep(i, <span class="hljs-number">1</span>, cnt)        &#123;            <span class="hljs-built_in">cout</span> &lt;&lt; <span class="hljs-string">" "</span> &lt;&lt; a[i];        &#125;        <span class="hljs-built_in">cout</span> &lt;&lt; <span class="hljs-string">"\n"</span>;    &#125;&#125;</code></pre><h1 id="收获与反思"><a href="#收获与反思" class="headerlink" title="收获与反思"></a>收获与反思</h1><p>无</p>]]></content>
    
    
    <categories>
      
      <category>Computer Science</category>
      
      <category>ACM</category>
      
      <category>洛谷</category>
      
    </categories>
    
    
    <tags>
      
      <tag>ACM</tag>
      
      <tag>洛谷</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>【Aizu-ITP2_11_C】解题报告（二进制枚举）</title>
    <link href="/post/88a7282d.html"/>
    <url>/post/88a7282d.html</url>
    
    <content type="html"><![CDATA[<h1 id="原始题目"><a href="#原始题目" class="headerlink" title="原始题目"></a>原始题目</h1><p><a href="http://judge.u-aizu.ac.jp/onlinejudge/description.jsp?id=ITP2_11_C" target="_blank" rel="noopener">Aizu-ITP2_11_C  Aizu原始题面</a></p><p><a href="https://vjudge.net/problem/Aizu-ITP2_11_C" target="_blank" rel="noopener">Aizu-ITP2_11_C  Vj题面</a></p><h1 id="题目大意"><a href="#题目大意" class="headerlink" title="题目大意"></a>题目大意</h1><p>给定集合大小，同时给定一个子集k，要求输出子集是该子集k的子集。同时输出其在原集合所有子集中的二进制序编号，根据二进制编号从小到大依次输出符合的子集。</p><h1 id="解题思路"><a href="#解题思路" class="headerlink" title="解题思路"></a>解题思路</h1><p>本题$n≤28$还可以枚举全部子集计数求其编号，一一枚举原集合子集计数然后判断会超时。</p><p>直接枚举给定子集k的子集，但是要根据其中元素计算在原集合所有子集中的二进制序编号。</p><p>实际上，编号就是该元素放在原集合子集中的二进制表示，由于题目本身就是原数字，所以直接二进制位运算可计算出其序号<code>sum += (1 &lt;&lt; a[j])</code>。</p><a id="more"></a><h1 id="解题代码"><a href="#解题代码" class="headerlink" title="解题代码"></a>解题代码</h1><pre><code class="hljs C++"><span class="hljs-meta">#<span class="hljs-meta-keyword">include</span> <span class="hljs-meta-string">&lt;bits/stdc++.h&gt;</span></span><span class="hljs-keyword">using</span> <span class="hljs-keyword">namespace</span> <span class="hljs-built_in">std</span>;<span class="hljs-keyword">typedef</span> <span class="hljs-keyword">long</span> <span class="hljs-keyword">long</span> ll;<span class="hljs-keyword">typedef</span> <span class="hljs-keyword">unsigned</span> <span class="hljs-keyword">long</span> <span class="hljs-keyword">long</span> ull;ll a[<span class="hljs-number">100</span>], n, m;<span class="hljs-meta">#<span class="hljs-meta-keyword">define</span> rep(i, a, n) for (ll i = a; i &lt; n; ++i)</span><span class="hljs-meta">#<span class="hljs-meta-keyword">define</span> per(i, a, n) for (ll i = n - 1; i &gt;= a; --i)</span><span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">print_subset</span><span class="hljs-params">(ll n, ll m)</span></span>&#123;    rep(i, <span class="hljs-number">0</span>, (<span class="hljs-number">1</span> &lt;&lt; m))    &#123;        ll sum = <span class="hljs-number">0</span>;        ll temp[<span class="hljs-number">100</span>];        <span class="hljs-keyword">int</span> ccnt = <span class="hljs-number">0</span>;        rep(j, <span class="hljs-number">0</span>, m)        &#123;            <span class="hljs-comment">//注意位运算的顺序</span>            <span class="hljs-keyword">if</span> (((<span class="hljs-number">1</span> &lt;&lt; j) &amp; i)) &#123;                temp[ccnt++] = a[j];                sum += (<span class="hljs-number">1</span> &lt;&lt; a[j]);            &#125;        &#125;        <span class="hljs-built_in">cout</span> &lt;&lt; sum &lt;&lt; <span class="hljs-string">":"</span>;        rep(j, <span class="hljs-number">0</span>, ccnt)        &#123;            <span class="hljs-built_in">cout</span> &lt;&lt; <span class="hljs-string">" "</span> &lt;&lt; temp[j];        &#125;        <span class="hljs-built_in">cout</span> &lt;&lt; <span class="hljs-built_in">endl</span>;    &#125;&#125;<span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span>&#123;    ios::sync_with_stdio(<span class="hljs-literal">false</span>);    <span class="hljs-keyword">while</span> (<span class="hljs-built_in">cin</span> &gt;&gt; n) &#123;        <span class="hljs-built_in">cin</span> &gt;&gt; m;        rep(i, <span class="hljs-number">0</span>, m) <span class="hljs-built_in">cin</span> &gt;&gt; a[i];        sort(a, a + m);        print_subset(n, m);    &#125;&#125;</code></pre><h1 id="收获与反思"><a href="#收获与反思" class="headerlink" title="收获与反思"></a>收获与反思</h1><p>直接根据元素构成计算其在全部子集中的序号。</p>]]></content>
    
    
    <categories>
      
      <category>Computer Science</category>
      
      <category>ACM</category>
      
      <category>Aizu</category>
      
    </categories>
    
    
    <tags>
      
      <tag>ACM</tag>
      
      <tag>Aizu</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>【Aizu-ITP2_11_B】解题报告（二进制枚举）</title>
    <link href="/post/8573f32.html"/>
    <url>/post/8573f32.html</url>
    
    <content type="html"><![CDATA[<h1 id="原始题目"><a href="#原始题目" class="headerlink" title="原始题目"></a>原始题目</h1><p><a href="http://judge.u-aizu.ac.jp/onlinejudge/description.jsp?id=ITP2_11_B" target="_blank" rel="noopener">Aizu-ITP2_11_B  Aizu原始题面</a></p><p><a href="https://vjudge.net/problem/Aizu-ITP2_11_B" target="_blank" rel="noopener">Aizu-ITP2_11_B  Vj题面</a></p><h1 id="题目大意"><a href="#题目大意" class="headerlink" title="题目大意"></a>题目大意</h1><p>给定集合大小，同时给定一个子集k，要求输出子集包含该子集k。同时输出其在原集合所有子集中的二进制序编号，根据二进制编号从小到大依次输出符合的子集。</p><h1 id="解题思路"><a href="#解题思路" class="headerlink" title="解题思路"></a>解题思路</h1><p>本题$n≤18$还可以枚举全部子集计数求其编号，对于每个子集判断是否包含所有要求包含元素（该位与运算），满足的话最后输出。</p><a id="more"></a><h1 id="解题代码"><a href="#解题代码" class="headerlink" title="解题代码"></a>解题代码</h1><pre><code class="hljs C++"><span class="hljs-meta">#<span class="hljs-meta-keyword">include</span> <span class="hljs-meta-string">&lt;bits/stdc++.h&gt;</span></span><span class="hljs-keyword">using</span> <span class="hljs-keyword">namespace</span> <span class="hljs-built_in">std</span>;<span class="hljs-keyword">typedef</span> <span class="hljs-keyword">long</span> <span class="hljs-keyword">long</span> ll;<span class="hljs-keyword">typedef</span> <span class="hljs-keyword">unsigned</span> <span class="hljs-keyword">long</span> <span class="hljs-keyword">long</span> ull;ll checknum[<span class="hljs-number">100</span>], n, m;<span class="hljs-meta">#<span class="hljs-meta-keyword">define</span> rep(i, a, n) for (ll i = a; i &lt; n; ++i)</span><span class="hljs-meta">#<span class="hljs-meta-keyword">define</span> per(i, a, n) for (ll i = n - 1; i &gt;= a; --i)</span><span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">print_subset</span><span class="hljs-params">(ll n, ll m)</span></span>&#123;    ll ans = <span class="hljs-number">0</span>;    rep(i, <span class="hljs-number">0</span>, (<span class="hljs-number">1</span> &lt;&lt; n))    &#123;        ans++;        <span class="hljs-keyword">int</span> flag = <span class="hljs-number">1</span>;        rep(j, <span class="hljs-number">0</span>, m)        &#123;            <span class="hljs-comment">//注意位运算的顺序</span>            <span class="hljs-keyword">if</span> (((<span class="hljs-number">1</span> &lt;&lt; checknum[j]) &amp; i) == <span class="hljs-number">0</span>) &#123;                flag = <span class="hljs-number">0</span>;                <span class="hljs-keyword">break</span>;            &#125;        &#125;        <span class="hljs-keyword">if</span> (!flag)            <span class="hljs-keyword">continue</span>;        <span class="hljs-built_in">cout</span> &lt;&lt; ans - <span class="hljs-number">1</span> &lt;&lt; <span class="hljs-string">":"</span>;        rep(j, <span class="hljs-number">0</span>, n)        &#123;            <span class="hljs-keyword">if</span> ((<span class="hljs-number">1</span> &lt;&lt; j) &amp; i)                <span class="hljs-built_in">cout</span> &lt;&lt; <span class="hljs-string">" "</span> &lt;&lt; j;        &#125;        <span class="hljs-built_in">cout</span> &lt;&lt; <span class="hljs-built_in">endl</span>;    &#125;&#125;<span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span>&#123;    ios::sync_with_stdio(<span class="hljs-literal">false</span>);    <span class="hljs-keyword">while</span> (<span class="hljs-built_in">cin</span> &gt;&gt; n) &#123;        <span class="hljs-built_in">memset</span>(checknum, <span class="hljs-number">0</span>, <span class="hljs-keyword">sizeof</span>(checknum));        <span class="hljs-built_in">cin</span> &gt;&gt; m;        rep(i, <span class="hljs-number">0</span>, m) <span class="hljs-built_in">cin</span> &gt;&gt; checknum[i];        print_subset(n, m);    &#125;&#125;</code></pre><h1 id="收获与反思"><a href="#收获与反思" class="headerlink" title="收获与反思"></a>收获与反思</h1><p>枚举子集常见的思路，参见。</p>]]></content>
    
    
    <categories>
      
      <category>Computer Science</category>
      
      <category>ACM</category>
      
      <category>Aizu</category>
      
    </categories>
    
    
    <tags>
      
      <tag>ACM</tag>
      
      <tag>Aizu</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>【Aizu-ITP2_11_A】解题报告（二进制枚举）</title>
    <link href="/post/52360052.html"/>
    <url>/post/52360052.html</url>
    
    <content type="html"><![CDATA[<h1 id="原始题目"><a href="#原始题目" class="headerlink" title="原始题目"></a>原始题目</h1><p><a href="http://judge.u-aizu.ac.jp/onlinejudge/description.jsp?id=ITP2_11_A" target="_blank" rel="noopener">Aizu-ITP2_11_A  Aizu原始题面</a></p><p><a href="https://vjudge.net/problem/Aizu-ITP2_11_A" target="_blank" rel="noopener">Aizu-ITP2_11_A  Vj题面</a></p><h1 id="题目大意"><a href="#题目大意" class="headerlink" title="题目大意"></a>题目大意</h1><p>根据二进制序编号，从0开始输出子集。</p><h1 id="解题思路"><a href="#解题思路" class="headerlink" title="解题思路"></a>解题思路</h1><p>枚举所有二进制可能，然后根据各位情况输出元素。</p><a id="more"></a><h1 id="解题代码"><a href="#解题代码" class="headerlink" title="解题代码"></a>解题代码</h1><pre><code class="hljs C++"><span class="hljs-meta">#<span class="hljs-meta-keyword">include</span> <span class="hljs-meta-string">&lt;bits/stdc++.h&gt;</span></span><span class="hljs-keyword">using</span> <span class="hljs-keyword">namespace</span> <span class="hljs-built_in">std</span>;<span class="hljs-keyword">typedef</span> <span class="hljs-keyword">long</span> <span class="hljs-keyword">long</span> ll;<span class="hljs-meta">#<span class="hljs-meta-keyword">define</span> rep(i, a, n) for (ll i = a; i &lt; n; ++i)</span><span class="hljs-meta">#<span class="hljs-meta-keyword">define</span> per(i, a, n) for (ll i = n - 1; i &gt;= a; --i)</span><span class="hljs-meta">#<span class="hljs-meta-keyword">define</span> fi first</span><span class="hljs-meta">#<span class="hljs-meta-keyword">define</span> se second</span><span class="hljs-meta">#<span class="hljs-meta-keyword">define</span> mp mkae_pair</span><span class="hljs-meta">#<span class="hljs-meta-keyword">define</span> pb push_back</span><span class="hljs-meta">#<span class="hljs-meta-keyword">define</span> endl <span class="hljs-meta-string">'\n'</span></span>ll n;<span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">print_subset</span><span class="hljs-params">(ll n)</span></span>&#123;    ll cnt = <span class="hljs-number">0</span>;    rep(i, <span class="hljs-number">0</span>, (<span class="hljs-number">1</span> &lt;&lt; n))    &#123;        <span class="hljs-built_in">cout</span> &lt;&lt; cnt++ &lt;&lt; <span class="hljs-string">":"</span>;        rep(j, <span class="hljs-number">0</span>, n)        &#123;            <span class="hljs-keyword">if</span> ((<span class="hljs-number">1</span> &lt;&lt; j) &amp; i) &#123;                <span class="hljs-built_in">cout</span> &lt;&lt; <span class="hljs-string">" "</span> &lt;&lt; j;            &#125;        &#125;        <span class="hljs-built_in">cout</span> &lt;&lt; <span class="hljs-built_in">endl</span>;    &#125;&#125;<span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span>&#123;    ios::sync_with_stdio(<span class="hljs-literal">false</span>);    <span class="hljs-keyword">while</span> (<span class="hljs-built_in">cin</span> &gt;&gt; n) &#123;        print_subset(n);    &#125;&#125;</code></pre><h1 id="收获与反思"><a href="#收获与反思" class="headerlink" title="收获与反思"></a>收获与反思</h1><p>枚举子集常见的思路</p><ol><li><p>回溯法(根据排列好的子集字典序输出)</p> <pre><code class="hljs C++"><span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">print_subset1</span><span class="hljs-params">(<span class="hljs-keyword">int</span> N, <span class="hljs-keyword">int</span>* A, <span class="hljs-keyword">int</span> cnt)</span></span>&#123;    <span class="hljs-built_in">cout</span> &lt;&lt; <span class="hljs-string">"&#123;"</span>;    rep(i, <span class="hljs-number">0</span>, cnt)    &#123;        <span class="hljs-built_in">cout</span> &lt;&lt; A[i] &lt;&lt; <span class="hljs-string">" "</span>;    &#125;    <span class="hljs-built_in">cout</span> &lt;&lt; <span class="hljs-string">"&#125;"</span> &lt;&lt; <span class="hljs-built_in">endl</span>;    <span class="hljs-keyword">int</span> nxt = cnt ? A[cnt - <span class="hljs-number">1</span>] + <span class="hljs-number">1</span> : <span class="hljs-number">0</span>;    rep(i, nxt, N)    &#123;        A[cnt] = i;        print_subset1(N, A, cnt + <span class="hljs-number">1</span>);    &#125;&#125;</code></pre></li><li><p>枚举二进制位</p> <pre><code class="hljs C++"><span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">print_subset2</span><span class="hljs-params">(<span class="hljs-keyword">int</span> N, <span class="hljs-keyword">int</span>* A)</span></span>&#123;    rep(i, <span class="hljs-number">0</span>, (<span class="hljs-number">1</span> &lt;&lt; N))    &#123;        <span class="hljs-built_in">cout</span> &lt;&lt; <span class="hljs-string">"&#123;"</span>;        rep(j, <span class="hljs-number">0</span>, N)        &#123;            <span class="hljs-keyword">if</span> ((<span class="hljs-number">1</span> &lt;&lt; j) &amp; i)                <span class="hljs-built_in">cout</span> &lt;&lt; A[j] &lt;&lt; <span class="hljs-string">" "</span>;        &#125;        <span class="hljs-built_in">cout</span> &lt;&lt; <span class="hljs-string">"&#125;"</span> &lt;&lt; <span class="hljs-built_in">endl</span>;    &#125;&#125;</code></pre></li></ol>]]></content>
    
    
    <categories>
      
      <category>Computer Science</category>
      
      <category>ACM</category>
      
      <category>Aizu</category>
      
    </categories>
    
    
    <tags>
      
      <tag>ACM</tag>
      
      <tag>Aizu</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>【洛谷-P1009】解题报告（高精度）</title>
    <link href="/post/ea5d5d2f.html"/>
    <url>/post/ea5d5d2f.html</url>
    
    <content type="html"><![CDATA[<h1 id="原始题目"><a href="#原始题目" class="headerlink" title="原始题目"></a>原始题目</h1><p><a href="https://www.luogu.org/problemnew/show/P1009" target="_blank" rel="noopener">P1009 阶乘之和</a></p><h1 id="题目大意"><a href="#题目大意" class="headerlink" title="题目大意"></a>题目大意</h1><p>阶乘之和</p><h1 id="解题思路"><a href="#解题思路" class="headerlink" title="解题思路"></a>解题思路</h1><p>爆ll，需要高精度，上ACM大数模板或者</p><blockquote><p>人生苦短，我用PY</p></blockquote><a id="more"></a><h1 id="解题代码"><a href="#解题代码" class="headerlink" title="解题代码"></a>解题代码</h1><pre><code class="hljs C++"><span class="hljs-meta">#<span class="hljs-meta-keyword">include</span> <span class="hljs-meta-string">&lt;bits/stdc++.h&gt;</span></span><span class="hljs-keyword">using</span> <span class="hljs-keyword">namespace</span> <span class="hljs-built_in">std</span>;<span class="hljs-keyword">typedef</span> <span class="hljs-keyword">long</span> <span class="hljs-keyword">long</span> ll;<span class="hljs-keyword">typedef</span> <span class="hljs-keyword">unsigned</span> <span class="hljs-keyword">long</span> <span class="hljs-keyword">long</span> ull;<span class="hljs-keyword">typedef</span> pair&lt;<span class="hljs-keyword">int</span>, <span class="hljs-keyword">int</span>&gt; pii;<span class="hljs-meta">#<span class="hljs-meta-keyword">define</span> rep(i, a, n) for (int i = a; i &lt; n; ++i)</span><span class="hljs-meta">#<span class="hljs-meta-keyword">define</span> per(i, a, n) for (int i = n - 1; i &gt;= a; --i)</span><span class="hljs-meta">#<span class="hljs-meta-keyword">define</span> pb push_back</span><span class="hljs-meta">#<span class="hljs-meta-keyword">define</span> MAXN 9999</span><span class="hljs-meta">#<span class="hljs-meta-keyword">define</span> MAXSIZE 10</span><span class="hljs-meta">#<span class="hljs-meta-keyword">define</span> DLEN 4</span><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">BigNum</span> &#123;</span><span class="hljs-keyword">private</span>:    <span class="hljs-keyword">int</span> a[<span class="hljs-number">500</span>]; <span class="hljs-comment">//可以控制大数的位数</span>    <span class="hljs-keyword">int</span> len; <span class="hljs-comment">//大数长度</span><span class="hljs-keyword">public</span>:    BigNum()    &#123;        len = <span class="hljs-number">1</span>;        <span class="hljs-built_in">memset</span>(a, <span class="hljs-number">0</span>, <span class="hljs-keyword">sizeof</span>(a));    &#125; <span class="hljs-comment">//构造函数</span>    BigNum(<span class="hljs-keyword">const</span> <span class="hljs-keyword">int</span>); <span class="hljs-comment">//将一个int类型的变量转化为大数</span>    BigNum(<span class="hljs-keyword">const</span> <span class="hljs-keyword">char</span>*); <span class="hljs-comment">//将一个字符串类型的变量转化为大数</span>    BigNum(<span class="hljs-keyword">const</span> BigNum&amp;); <span class="hljs-comment">//拷贝构造函数</span>    BigNum&amp; <span class="hljs-keyword">operator</span>=(<span class="hljs-keyword">const</span> BigNum&amp;); <span class="hljs-comment">//重载赋值运算符，大数之间进行赋值运算</span>    <span class="hljs-keyword">friend</span> istream&amp; <span class="hljs-keyword">operator</span>&gt;&gt;(istream&amp;, BigNum&amp;); <span class="hljs-comment">//重载输入运算符</span>    <span class="hljs-keyword">friend</span> ostream&amp; <span class="hljs-keyword">operator</span>&lt;&lt;(ostream&amp;, BigNum&amp;); <span class="hljs-comment">//重载输出运算符</span>    BigNum <span class="hljs-keyword">operator</span>+(<span class="hljs-keyword">const</span> BigNum&amp;) <span class="hljs-keyword">const</span>; <span class="hljs-comment">//重载加法运算符，两个大数之间的相加运算</span>    BigNum <span class="hljs-keyword">operator</span>-(<span class="hljs-keyword">const</span> BigNum&amp;) <span class="hljs-keyword">const</span>; <span class="hljs-comment">//重载减法运算符，两个大数之间的相减运算</span>    BigNum <span class="hljs-keyword">operator</span>*(<span class="hljs-keyword">const</span> BigNum&amp;)<span class="hljs-keyword">const</span>; <span class="hljs-comment">//重载乘法运算符，两个大数之间的相乘运算</span>    BigNum <span class="hljs-keyword">operator</span>/(<span class="hljs-keyword">const</span> <span class="hljs-keyword">int</span>&amp;) <span class="hljs-keyword">const</span>; <span class="hljs-comment">//重载除法运算符，大数对一个整数进行相除运算</span>    BigNum <span class="hljs-keyword">operator</span>^(<span class="hljs-keyword">const</span> <span class="hljs-keyword">int</span>&amp;) <span class="hljs-keyword">const</span>; <span class="hljs-comment">//大数的n次方运算</span>    <span class="hljs-keyword">int</span> <span class="hljs-keyword">operator</span>%(<span class="hljs-keyword">const</span> <span class="hljs-keyword">int</span>&amp;) <span class="hljs-keyword">const</span>; <span class="hljs-comment">//大数对一个int类型的变量进行取模运算</span>    <span class="hljs-keyword">bool</span> <span class="hljs-keyword">operator</span>&gt;(<span class="hljs-keyword">const</span> BigNum&amp; T) <span class="hljs-keyword">const</span>; <span class="hljs-comment">//大数和另一个大数的大小比较</span>    <span class="hljs-keyword">bool</span> <span class="hljs-keyword">operator</span>&gt;(<span class="hljs-keyword">const</span> <span class="hljs-keyword">int</span>&amp; t) <span class="hljs-keyword">const</span>; <span class="hljs-comment">//大数和一个int类型的变量的大小比较</span>    <span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">print</span><span class="hljs-params">()</span></span>; <span class="hljs-comment">//输出大数</span>&#125;;BigNum::BigNum(<span class="hljs-keyword">const</span> <span class="hljs-keyword">int</span> b) <span class="hljs-comment">//将一个int类型的变量转化为大数</span>&#123;    <span class="hljs-keyword">int</span> c, d = b;    len = <span class="hljs-number">0</span>;    <span class="hljs-built_in">memset</span>(a, <span class="hljs-number">0</span>, <span class="hljs-keyword">sizeof</span>(a));    <span class="hljs-keyword">while</span> (d &gt; MAXN) &#123;        c = d - (d / (MAXN + <span class="hljs-number">1</span>)) * (MAXN + <span class="hljs-number">1</span>);        d = d / (MAXN + <span class="hljs-number">1</span>);        a[len++] = c;    &#125;    a[len++] = d;&#125;BigNum::BigNum(<span class="hljs-keyword">const</span> <span class="hljs-keyword">char</span>* s) <span class="hljs-comment">//将一个字符串类型的变量转化为大数</span>&#123;    <span class="hljs-keyword">int</span> t, k, index, l, i;    <span class="hljs-built_in">memset</span>(a, <span class="hljs-number">0</span>, <span class="hljs-keyword">sizeof</span>(a));    l = <span class="hljs-built_in">strlen</span>(s);    len = l / DLEN;    <span class="hljs-keyword">if</span> (l % DLEN)        len++;    index = <span class="hljs-number">0</span>;    <span class="hljs-keyword">for</span> (i = l - <span class="hljs-number">1</span>; i &gt;= <span class="hljs-number">0</span>; i -= DLEN) &#123;        t = <span class="hljs-number">0</span>;        k = i - DLEN + <span class="hljs-number">1</span>;        <span class="hljs-keyword">if</span> (k &lt; <span class="hljs-number">0</span>)            k = <span class="hljs-number">0</span>;        <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> j = k; j &lt;= i; j++)            t = t * <span class="hljs-number">10</span> + s[j] - <span class="hljs-string">'0'</span>;        a[index++] = t;    &#125;&#125;BigNum::BigNum(<span class="hljs-keyword">const</span> BigNum&amp; T)    : len(T.len) <span class="hljs-comment">//拷贝构造函数</span>&#123;    <span class="hljs-keyword">int</span> i;    <span class="hljs-built_in">memset</span>(a, <span class="hljs-number">0</span>, <span class="hljs-keyword">sizeof</span>(a));    <span class="hljs-keyword">for</span> (i = <span class="hljs-number">0</span>; i &lt; len; i++)        a[i] = T.a[i];&#125;BigNum&amp; BigNum::<span class="hljs-keyword">operator</span>=(<span class="hljs-keyword">const</span> BigNum&amp; n) <span class="hljs-comment">//重载赋值运算符，大数之间进行赋值运算</span>&#123;    <span class="hljs-keyword">int</span> i;    len = n.len;    <span class="hljs-built_in">memset</span>(a, <span class="hljs-number">0</span>, <span class="hljs-keyword">sizeof</span>(a));    <span class="hljs-keyword">for</span> (i = <span class="hljs-number">0</span>; i &lt; len; i++)        a[i] = n.a[i];    <span class="hljs-keyword">return</span> *<span class="hljs-keyword">this</span>;&#125;istream&amp; <span class="hljs-keyword">operator</span>&gt;&gt;(istream&amp; in, BigNum&amp; b) <span class="hljs-comment">//重载输入运算符</span>&#123;    <span class="hljs-keyword">char</span> ch[MAXSIZE * <span class="hljs-number">4</span>];    <span class="hljs-keyword">int</span> i = <span class="hljs-number">-1</span>;    in &gt;&gt; ch;    <span class="hljs-keyword">int</span> l = <span class="hljs-built_in">strlen</span>(ch);    <span class="hljs-keyword">int</span> count = <span class="hljs-number">0</span>, sum = <span class="hljs-number">0</span>;    <span class="hljs-keyword">for</span> (i = l - <span class="hljs-number">1</span>; i &gt;= <span class="hljs-number">0</span>;) &#123;        sum = <span class="hljs-number">0</span>;        <span class="hljs-keyword">int</span> t = <span class="hljs-number">1</span>;        <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> j = <span class="hljs-number">0</span>; j &lt; <span class="hljs-number">4</span> &amp;&amp; i &gt;= <span class="hljs-number">0</span>; j++, i--, t *= <span class="hljs-number">10</span>) &#123;            sum += (ch[i] - <span class="hljs-string">'0'</span>) * t;        &#125;        b.a[count] = sum;        count++;    &#125;    b.len = count++;    <span class="hljs-keyword">return</span> in;&#125;ostream&amp; <span class="hljs-keyword">operator</span>&lt;&lt;(ostream&amp; out, BigNum&amp; b) <span class="hljs-comment">//重载输出运算符</span>&#123;    <span class="hljs-keyword">int</span> i;    <span class="hljs-built_in">cout</span> &lt;&lt; b.a[b.len - <span class="hljs-number">1</span>];    <span class="hljs-keyword">for</span> (i = b.len - <span class="hljs-number">2</span>; i &gt;= <span class="hljs-number">0</span>; i--) &#123;        <span class="hljs-built_in">cout</span>.width(DLEN);        <span class="hljs-built_in">cout</span>.fill(<span class="hljs-string">'0'</span>);        <span class="hljs-built_in">cout</span> &lt;&lt; b.a[i];    &#125;    <span class="hljs-keyword">return</span> out;&#125;BigNum BigNum::<span class="hljs-keyword">operator</span>+(<span class="hljs-keyword">const</span> BigNum&amp; T) <span class="hljs-keyword">const</span> <span class="hljs-comment">//两个大数之间的相加运算</span>&#123;    <span class="hljs-function">BigNum <span class="hljs-title">t</span><span class="hljs-params">(*<span class="hljs-keyword">this</span>)</span></span>;    <span class="hljs-keyword">int</span> i, big; <span class="hljs-comment">//位数</span>    big = T.len &gt; len ? T.len : len;    <span class="hljs-keyword">for</span> (i = <span class="hljs-number">0</span>; i &lt; big; i++) &#123;        t.a[i] += T.a[i];        <span class="hljs-keyword">if</span> (t.a[i] &gt; MAXN) &#123;            t.a[i + <span class="hljs-number">1</span>]++;            t.a[i] -= MAXN + <span class="hljs-number">1</span>;        &#125;    &#125;    <span class="hljs-keyword">if</span> (t.a[big] != <span class="hljs-number">0</span>)        t.len = big + <span class="hljs-number">1</span>;    <span class="hljs-keyword">else</span>        t.len = big;    <span class="hljs-keyword">return</span> t;&#125;BigNum BigNum::<span class="hljs-keyword">operator</span>-(<span class="hljs-keyword">const</span> BigNum&amp; T) <span class="hljs-keyword">const</span> <span class="hljs-comment">//两个大数之间的相减运算</span>&#123;    <span class="hljs-keyword">int</span> i, j, big;    <span class="hljs-keyword">bool</span> flag;    BigNum t1, t2;    <span class="hljs-keyword">if</span> (*<span class="hljs-keyword">this</span> &gt; T) &#123;        t1 = *<span class="hljs-keyword">this</span>;        t2 = T;        flag = <span class="hljs-number">0</span>;    &#125; <span class="hljs-keyword">else</span> &#123;        t1 = T;        t2 = *<span class="hljs-keyword">this</span>;        flag = <span class="hljs-number">1</span>;    &#125;    big = t1.len;    <span class="hljs-keyword">for</span> (i = <span class="hljs-number">0</span>; i &lt; big; i++) &#123;        <span class="hljs-keyword">if</span> (t1.a[i] &lt; t2.a[i]) &#123;            j = i + <span class="hljs-number">1</span>;            <span class="hljs-keyword">while</span> (t1.a[j] == <span class="hljs-number">0</span>)                j++;            t1.a[j--]--;            <span class="hljs-keyword">while</span> (j &gt; i)                t1.a[j--] += MAXN;            t1.a[i] += MAXN + <span class="hljs-number">1</span> - t2.a[i];        &#125; <span class="hljs-keyword">else</span>            t1.a[i] -= t2.a[i];    &#125;    t1.len = big;    <span class="hljs-keyword">while</span> (t1.a[t1.len - <span class="hljs-number">1</span>] == <span class="hljs-number">0</span> &amp;&amp; t1.len &gt; <span class="hljs-number">1</span>) &#123;        t1.len--;        big--;    &#125;    <span class="hljs-keyword">if</span> (flag)        t1.a[big - <span class="hljs-number">1</span>] = <span class="hljs-number">0</span> - t1.a[big - <span class="hljs-number">1</span>];    <span class="hljs-keyword">return</span> t1;&#125;BigNum BigNum::<span class="hljs-keyword">operator</span>*(<span class="hljs-keyword">const</span> BigNum&amp; T) <span class="hljs-keyword">const</span> <span class="hljs-comment">//两个大数之间的相乘运算</span>&#123;    BigNum ret;    <span class="hljs-keyword">int</span> i, j, up;    <span class="hljs-keyword">int</span> temp, temp1;    <span class="hljs-keyword">for</span> (i = <span class="hljs-number">0</span>; i &lt; len; i++) &#123;        up = <span class="hljs-number">0</span>;        <span class="hljs-keyword">for</span> (j = <span class="hljs-number">0</span>; j &lt; T.len; j++) &#123;            temp = a[i] * T.a[j] + ret.a[i + j] + up;            <span class="hljs-keyword">if</span> (temp &gt; MAXN) &#123;                temp1 = temp - temp / (MAXN + <span class="hljs-number">1</span>) * (MAXN + <span class="hljs-number">1</span>);                up = temp / (MAXN + <span class="hljs-number">1</span>);                ret.a[i + j] = temp1;            &#125; <span class="hljs-keyword">else</span> &#123;                up = <span class="hljs-number">0</span>;                ret.a[i + j] = temp;            &#125;        &#125;        <span class="hljs-keyword">if</span> (up != <span class="hljs-number">0</span>)            ret.a[i + j] = up;    &#125;    ret.len = i + j;    <span class="hljs-keyword">while</span> (ret.a[ret.len - <span class="hljs-number">1</span>] == <span class="hljs-number">0</span> &amp;&amp; ret.len &gt; <span class="hljs-number">1</span>)        ret.len--;    <span class="hljs-keyword">return</span> ret;&#125;BigNum BigNum::<span class="hljs-keyword">operator</span>/(<span class="hljs-keyword">const</span> <span class="hljs-keyword">int</span>&amp; b) <span class="hljs-keyword">const</span> <span class="hljs-comment">//大数对一个整数进行相除运算</span>&#123;    BigNum ret;    <span class="hljs-keyword">int</span> i, down = <span class="hljs-number">0</span>;    <span class="hljs-keyword">for</span> (i = len - <span class="hljs-number">1</span>; i &gt;= <span class="hljs-number">0</span>; i--) &#123;        ret.a[i] = (a[i] + down * (MAXN + <span class="hljs-number">1</span>)) / b;        down = a[i] + down * (MAXN + <span class="hljs-number">1</span>) - ret.a[i] * b;    &#125;    ret.len = len;    <span class="hljs-keyword">while</span> (ret.a[ret.len - <span class="hljs-number">1</span>] == <span class="hljs-number">0</span> &amp;&amp; ret.len &gt; <span class="hljs-number">1</span>)        ret.len--;    <span class="hljs-keyword">return</span> ret;&#125;<span class="hljs-keyword">int</span> BigNum::<span class="hljs-keyword">operator</span>%(<span class="hljs-keyword">const</span> <span class="hljs-keyword">int</span>&amp; b) <span class="hljs-keyword">const</span> <span class="hljs-comment">//大数对一个int类型的变量进行取模运算</span>&#123;    <span class="hljs-keyword">int</span> i, d = <span class="hljs-number">0</span>;    <span class="hljs-keyword">for</span> (i = len - <span class="hljs-number">1</span>; i &gt;= <span class="hljs-number">0</span>; i--) &#123;        d = ((d * (MAXN + <span class="hljs-number">1</span>)) % b + a[i]) % b;    &#125;    <span class="hljs-keyword">return</span> d;&#125;BigNum BigNum::<span class="hljs-keyword">operator</span>^(<span class="hljs-keyword">const</span> <span class="hljs-keyword">int</span>&amp; n) <span class="hljs-keyword">const</span> <span class="hljs-comment">//大数的n次方运算</span>&#123;    BigNum t, ret(<span class="hljs-number">1</span>);    <span class="hljs-keyword">int</span> i;    <span class="hljs-keyword">if</span> (n &lt; <span class="hljs-number">0</span>)        <span class="hljs-built_in">exit</span>(<span class="hljs-number">-1</span>);    <span class="hljs-keyword">if</span> (n == <span class="hljs-number">0</span>)        <span class="hljs-keyword">return</span> <span class="hljs-number">1</span>;    <span class="hljs-keyword">if</span> (n == <span class="hljs-number">1</span>)        <span class="hljs-keyword">return</span> *<span class="hljs-keyword">this</span>;    <span class="hljs-keyword">int</span> m = n;    <span class="hljs-keyword">while</span> (m &gt; <span class="hljs-number">1</span>) &#123;        t = *<span class="hljs-keyword">this</span>;        <span class="hljs-keyword">for</span> (i = <span class="hljs-number">1</span>; i &lt;&lt; <span class="hljs-number">1</span> &lt;= m; i &lt;&lt;= <span class="hljs-number">1</span>) &#123;            t = t * t;        &#125;        m -= i;        ret = ret * t;        <span class="hljs-keyword">if</span> (m == <span class="hljs-number">1</span>)            ret = ret * (*<span class="hljs-keyword">this</span>);    &#125;    <span class="hljs-keyword">return</span> ret;&#125;<span class="hljs-keyword">bool</span> BigNum::<span class="hljs-keyword">operator</span>&gt;(<span class="hljs-keyword">const</span> BigNum&amp; T) <span class="hljs-keyword">const</span> <span class="hljs-comment">//大数和另一个大数的大小比较</span>&#123;    <span class="hljs-keyword">int</span> ln;    <span class="hljs-keyword">if</span> (len &gt; T.len)        <span class="hljs-keyword">return</span> <span class="hljs-literal">true</span>;    <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (len == T.len) &#123;        ln = len - <span class="hljs-number">1</span>;        <span class="hljs-keyword">while</span> (a[ln] == T.a[ln] &amp;&amp; ln &gt;= <span class="hljs-number">0</span>)            ln--;        <span class="hljs-keyword">if</span> (ln &gt;= <span class="hljs-number">0</span> &amp;&amp; a[ln] &gt; T.a[ln])            <span class="hljs-keyword">return</span> <span class="hljs-literal">true</span>;        <span class="hljs-keyword">else</span>            <span class="hljs-keyword">return</span> <span class="hljs-literal">false</span>;    &#125; <span class="hljs-keyword">else</span>        <span class="hljs-keyword">return</span> <span class="hljs-literal">false</span>;&#125;<span class="hljs-keyword">bool</span> BigNum::<span class="hljs-keyword">operator</span>&gt;(<span class="hljs-keyword">const</span> <span class="hljs-keyword">int</span>&amp; t) <span class="hljs-keyword">const</span> <span class="hljs-comment">//大数和一个int类型的变量的大小比较</span>&#123;    <span class="hljs-function">BigNum <span class="hljs-title">b</span><span class="hljs-params">(t)</span></span>;    <span class="hljs-keyword">return</span> *<span class="hljs-keyword">this</span> &gt; b;&#125;<span class="hljs-keyword">void</span> BigNum::print() <span class="hljs-comment">//输出大数</span>&#123;    <span class="hljs-keyword">int</span> i;    <span class="hljs-built_in">cout</span> &lt;&lt; a[len - <span class="hljs-number">1</span>];    <span class="hljs-keyword">for</span> (i = len - <span class="hljs-number">2</span>; i &gt;= <span class="hljs-number">0</span>; i--) &#123;        <span class="hljs-built_in">cout</span>.width(DLEN);        <span class="hljs-built_in">cout</span>.fill(<span class="hljs-string">'0'</span>);        <span class="hljs-built_in">cout</span> &lt;&lt; a[i];    &#125;    <span class="hljs-built_in">cout</span> &lt;&lt; <span class="hljs-built_in">endl</span>;&#125;<span class="hljs-keyword">int</span> n;<span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span>&#123;    ios::sync_with_stdio(<span class="hljs-literal">false</span>);    <span class="hljs-keyword">while</span> (<span class="hljs-built_in">cin</span> &gt;&gt; n) &#123;        BigNum ans = <span class="hljs-number">0</span>;        <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> i = <span class="hljs-number">1</span>; i &lt;= n; ++i) &#123;            BigNum temp = <span class="hljs-number">1</span>;            rep(j, <span class="hljs-number">1</span>, i + <span class="hljs-number">1</span>)            &#123;                temp = temp * j;            &#125;            ans = ans + temp;        &#125;        ans.print();    &#125;&#125;</code></pre><pre><code class="hljs py">num = int(input())sum = <span class="hljs-number">0</span><span class="hljs-keyword">for</span> i <span class="hljs-keyword">in</span> range(<span class="hljs-number">1</span>,num+<span class="hljs-number">1</span>):    cnt = <span class="hljs-number">1</span>    <span class="hljs-keyword">for</span> j <span class="hljs-keyword">in</span> range(<span class="hljs-number">1</span>,i+<span class="hljs-number">1</span>):        cnt*=j    sum+=cntprint(sum)</code></pre><h1 id="收获与总结"><a href="#收获与总结" class="headerlink" title="收获与总结"></a>收获与总结</h1><p>无</p>]]></content>
    
    
    <categories>
      
      <category>Computer Science</category>
      
      <category>ACM</category>
      
      <category>洛谷</category>
      
    </categories>
    
    
    <tags>
      
      <tag>ACM</tag>
      
      <tag>洛谷</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>【洛谷-P1089】解题报告（水题）</title>
    <link href="/post/d0d58037.html"/>
    <url>/post/d0d58037.html</url>
    
    <content type="html"><![CDATA[<h1 id="原始题目"><a href="#原始题目" class="headerlink" title="原始题目"></a>原始题目</h1><p><a href="https://www.luogu.org/problemnew/show/P1089" target="_blank" rel="noopener">P1089 津津的储蓄计划</a></p><h1 id="题目大意"><a href="#题目大意" class="headerlink" title="题目大意"></a>题目大意</h1><p>月初估算，多余的存，如果某月得到零花钱不足预算，则输出-X，X位月份，否则输出最后金钱（存储的变1.2倍）。</p><h1 id="解题思路"><a href="#解题思路" class="headerlink" title="解题思路"></a>解题思路</h1><p>水题</p><a id="more"></a><h1 id="解题代码"><a href="#解题代码" class="headerlink" title="解题代码"></a>解题代码</h1><pre><code class="hljs C++"><span class="hljs-meta">#<span class="hljs-meta-keyword">include</span> <span class="hljs-meta-string">&lt;bits/stdc++.h&gt;</span></span><span class="hljs-keyword">using</span> <span class="hljs-keyword">namespace</span> <span class="hljs-built_in">std</span>;<span class="hljs-keyword">typedef</span> <span class="hljs-keyword">long</span> <span class="hljs-keyword">long</span> ll;<span class="hljs-keyword">typedef</span> <span class="hljs-keyword">unsigned</span> <span class="hljs-keyword">long</span> <span class="hljs-keyword">long</span> ull;<span class="hljs-keyword">typedef</span> <span class="hljs-built_in">vector</span>&lt;<span class="hljs-keyword">int</span>&gt; vi;<span class="hljs-keyword">typedef</span> pair&lt;<span class="hljs-keyword">int</span>, <span class="hljs-keyword">int</span>&gt; pii;<span class="hljs-keyword">typedef</span> pair&lt;<span class="hljs-built_in">string</span>, <span class="hljs-built_in">string</span>&gt; pss;<span class="hljs-meta">#<span class="hljs-meta-keyword">define</span> rep(i, a, n) for (int i = a; i &lt; n; ++i)</span><span class="hljs-meta">#<span class="hljs-meta-keyword">define</span> per(i, a, n) for (int i = n - 1; i &gt;= a; --i)</span><span class="hljs-meta">#<span class="hljs-meta-keyword">define</span> fi first</span><span class="hljs-meta">#<span class="hljs-meta-keyword">define</span> se second</span><span class="hljs-meta">#<span class="hljs-meta-keyword">define</span> all(x) x.begin(), x.end()</span><span class="hljs-meta">#<span class="hljs-meta-keyword">define</span> mp make_pair</span><span class="hljs-meta">#<span class="hljs-meta-keyword">define</span> pb push_back</span><span class="hljs-meta">#<span class="hljs-meta-keyword">define</span> np next_permutation</span><span class="hljs-meta">#<span class="hljs-meta-keyword">define</span> INF 0x3f3f3f3f</span><span class="hljs-meta">#<span class="hljs-meta-keyword">define</span> EPS 1e-8</span><span class="hljs-meta">#<span class="hljs-meta-keyword">define</span> endl <span class="hljs-meta-string">'\n'</span></span><span class="hljs-keyword">const</span> <span class="hljs-keyword">int</span> maxn = <span class="hljs-number">1e5</span> + <span class="hljs-number">5</span>;<span class="hljs-keyword">int</span> ans, cnt, num, save;<span class="hljs-keyword">int</span> a[maxn];<span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span>&#123;    ios::sync_with_stdio(<span class="hljs-literal">false</span>);    rep(i, <span class="hljs-number">1</span>, <span class="hljs-number">12</span> + <span class="hljs-number">1</span>) <span class="hljs-built_in">cin</span> &gt;&gt; a[i];    rep(i, <span class="hljs-number">1</span>, <span class="hljs-number">12</span> + <span class="hljs-number">1</span>)    &#123;        cnt += <span class="hljs-number">300</span>;        cnt -= a[i];        <span class="hljs-keyword">if</span> (cnt &lt; <span class="hljs-number">0</span>) &#123;            <span class="hljs-built_in">cout</span> &lt;&lt; <span class="hljs-string">'-'</span> &lt;&lt; i &lt;&lt; <span class="hljs-built_in">endl</span>;            <span class="hljs-keyword">break</span>;        &#125;        save += (cnt / <span class="hljs-number">100</span>);        cnt %= <span class="hljs-number">100</span>;    &#125;    <span class="hljs-keyword">if</span> (cnt &gt;= <span class="hljs-number">0</span>) &#123;        cnt += save * <span class="hljs-number">120</span>;        <span class="hljs-built_in">cout</span> &lt;&lt; cnt &lt;&lt; <span class="hljs-built_in">endl</span>;    &#125;&#125;</code></pre><h1 id="收获与反思"><a href="#收获与反思" class="headerlink" title="收获与反思"></a>收获与反思</h1><p>无</p>]]></content>
    
    
    <categories>
      
      <category>Computer Science</category>
      
      <category>ACM</category>
      
      <category>洛谷</category>
      
    </categories>
    
    
    <tags>
      
      <tag>ACM</tag>
      
      <tag>洛谷</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>【洛谷-P1085】解题报告（水题）</title>
    <link href="/post/dbad9cab.html"/>
    <url>/post/dbad9cab.html</url>
    
    <content type="html"><![CDATA[<h1 id="原始题目"><a href="#原始题目" class="headerlink" title="原始题目"></a>原始题目</h1><p><a href="https://www.luogu.org/problemnew/show/P1085" target="_blank" rel="noopener">P1085 不高兴的津津</a></p><h1 id="题目大意"><a href="#题目大意" class="headerlink" title="题目大意"></a>题目大意</h1><p>阈值排序，没有则0，有输出相同最大值最小的坐标。</p><h1 id="解题思路"><a href="#解题思路" class="headerlink" title="解题思路"></a>解题思路</h1><p>水题</p><a id="more"></a><h1 id="解题代码"><a href="#解题代码" class="headerlink" title="解题代码"></a>解题代码</h1><pre><code class="hljs C++"><span class="hljs-meta">#<span class="hljs-meta-keyword">include</span> <span class="hljs-meta-string">&lt;bits/stdc++.h&gt;</span></span><span class="hljs-keyword">using</span> <span class="hljs-keyword">namespace</span> <span class="hljs-built_in">std</span>;<span class="hljs-keyword">typedef</span> <span class="hljs-keyword">long</span> <span class="hljs-keyword">long</span> ll;<span class="hljs-keyword">typedef</span> <span class="hljs-keyword">unsigned</span> <span class="hljs-keyword">long</span> <span class="hljs-keyword">long</span> ull;<span class="hljs-keyword">typedef</span> pair&lt;<span class="hljs-keyword">int</span>, <span class="hljs-keyword">int</span>&gt; pii;<span class="hljs-keyword">typedef</span> pair&lt;<span class="hljs-built_in">string</span>, <span class="hljs-built_in">string</span>&gt; pss;<span class="hljs-keyword">typedef</span> <span class="hljs-built_in">vector</span>&lt;<span class="hljs-keyword">int</span>&gt; vi;<span class="hljs-meta">#<span class="hljs-meta-keyword">define</span> rep(i, a, n) for (int i = a; i &lt; n; ++i)</span><span class="hljs-meta">#<span class="hljs-meta-keyword">define</span> per(i, a, n) for (int i = n - 1; i &gt;= a; --i)</span><span class="hljs-meta">#<span class="hljs-meta-keyword">define</span> fi first</span><span class="hljs-meta">#<span class="hljs-meta-keyword">define</span> se second</span><span class="hljs-meta">#<span class="hljs-meta-keyword">define</span> mp make_pair</span><span class="hljs-meta">#<span class="hljs-meta-keyword">define</span> np next_permutation</span><span class="hljs-meta">#<span class="hljs-meta-keyword">define</span> pb push_back</span><span class="hljs-meta">#<span class="hljs-meta-keyword">define</span> all(x) x.begin(), x.end()</span><span class="hljs-meta">#<span class="hljs-meta-keyword">define</span> INF 0x3f3f3f3f</span><span class="hljs-built_in">vector</span>&lt;pii&gt; ans;<span class="hljs-keyword">int</span> mmax = -INF;<span class="hljs-function"><span class="hljs-keyword">bool</span> <span class="hljs-title">cmp</span><span class="hljs-params">(pii a, pii b)</span></span>&#123;    <span class="hljs-keyword">if</span> (a.second != b.second) &#123;        <span class="hljs-keyword">return</span> a.second &gt; b.second;    &#125; <span class="hljs-keyword">else</span>        <span class="hljs-keyword">return</span> a.fi &lt; b.fi;&#125;<span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span>&#123;    ios::sync_with_stdio(<span class="hljs-literal">false</span>);    rep(i, <span class="hljs-number">1</span>, <span class="hljs-number">7</span> + <span class="hljs-number">1</span>)    &#123;        <span class="hljs-keyword">int</span> a, b;        <span class="hljs-built_in">cin</span> &gt;&gt; a &gt;&gt; b;        <span class="hljs-keyword">if</span> (a + b &gt; <span class="hljs-number">8</span>) &#123;            ans.pb(mp(i, a + b));        &#125;    &#125;    <span class="hljs-keyword">if</span> (ans.size() == <span class="hljs-number">0</span>)        <span class="hljs-built_in">cout</span> &lt;&lt; <span class="hljs-number">0</span> &lt;&lt; <span class="hljs-built_in">endl</span>;    <span class="hljs-keyword">else</span> &#123;        sort(all(ans), cmp);        <span class="hljs-built_in">cout</span> &lt;&lt; ans[<span class="hljs-number">0</span>].first &lt;&lt; <span class="hljs-built_in">endl</span>;    &#125;&#125;</code></pre><h1 id="收获与反思"><a href="#收获与反思" class="headerlink" title="收获与反思"></a>收获与反思</h1><p>无</p>]]></content>
    
    
    <categories>
      
      <category>Computer Science</category>
      
      <category>ACM</category>
      
      <category>洛谷</category>
      
    </categories>
    
    
    <tags>
      
      <tag>ACM</tag>
      
      <tag>洛谷</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>【洛谷-P1071】解题报告（字符串）</title>
    <link href="/post/6aa464c0.html"/>
    <url>/post/6aa464c0.html</url>
    
    <content type="html"><![CDATA[<h1 id="原始题目"><a href="#原始题目" class="headerlink" title="原始题目"></a>原始题目</h1><p><a href="https://www.luogu.org/problemnew/show/P1071" target="_blank" rel="noopener">P1071 潜伏者</a></p><h1 id="题目大意"><a href="#题目大意" class="headerlink" title="题目大意"></a>题目大意</h1><p>仅大写字母的放射密码。</p><ol><li>所有信息扫描完毕，‘AA’-‘ZZ’ 所有 26 26个字母在原信息中均出现过并获得了相应的“密字”。</li><li>所有信息扫描完毕，但发现存在某个（或某些）字母在原信息中没有出现。</li><li>扫描中发现掌握的信息里有明显的自相矛盾或错误（违反 SS 国密码的编码规则）。</li></ol><h1 id="解题思路"><a href="#解题思路" class="headerlink" title="解题思路"></a>解题思路</h1><p>map映射储存然后判断是否满足1条件即可。</p><a id="more"></a><h1 id="解题代码"><a href="#解题代码" class="headerlink" title="解题代码"></a>解题代码</h1><pre><code class="hljs C++"><span class="hljs-comment">// 数组类型和 映射都尝试一下</span><span class="hljs-meta">#<span class="hljs-meta-keyword">include</span> <span class="hljs-meta-string">&lt;bits/stdc++.h&gt;</span></span><span class="hljs-keyword">using</span> <span class="hljs-keyword">namespace</span> <span class="hljs-built_in">std</span>;<span class="hljs-keyword">typedef</span> <span class="hljs-keyword">long</span> <span class="hljs-keyword">long</span> ll;<span class="hljs-keyword">typedef</span> <span class="hljs-keyword">unsigned</span> <span class="hljs-keyword">long</span> <span class="hljs-keyword">long</span> ull;<span class="hljs-keyword">typedef</span> <span class="hljs-built_in">vector</span>&lt;<span class="hljs-keyword">int</span>&gt; vi;<span class="hljs-keyword">typedef</span> pair&lt;<span class="hljs-keyword">int</span>, <span class="hljs-keyword">int</span>&gt; pii;<span class="hljs-meta">#<span class="hljs-meta-keyword">define</span> rep(i, a, n) for (int i = a; i &lt; n; ++i)</span><span class="hljs-meta">#<span class="hljs-meta-keyword">define</span> per(i, a, n) for (int i = n - 1; i &gt;= a; --i)</span><span class="hljs-meta">#<span class="hljs-meta-keyword">define</span> fi first</span><span class="hljs-meta">#<span class="hljs-meta-keyword">define</span> se second</span><span class="hljs-meta">#<span class="hljs-meta-keyword">define</span> mp make_pair</span><span class="hljs-meta">#<span class="hljs-meta-keyword">define</span> np next_permutation</span><span class="hljs-meta">#<span class="hljs-meta-keyword">define</span> pb puss_back</span><span class="hljs-meta">#<span class="hljs-meta-keyword">define</span> endl <span class="hljs-meta-string">'\n'</span></span><span class="hljs-meta">#<span class="hljs-meta-keyword">define</span> all(x) x.begin(), x.end()</span><span class="hljs-built_in">string</span> a, b, c;<span class="hljs-built_in">map</span>&lt;<span class="hljs-keyword">char</span>, <span class="hljs-keyword">char</span>&gt; dic, dic2;<span class="hljs-function"><span class="hljs-keyword">bool</span> <span class="hljs-title">check</span><span class="hljs-params">()</span></span>&#123;    dic.clear();    dic2.clear();    <span class="hljs-keyword">if</span> (a.length() != b.length())        <span class="hljs-keyword">return</span> <span class="hljs-literal">false</span>;    rep(i, <span class="hljs-number">0</span>, a.length())    &#123;        <span class="hljs-keyword">if</span> (dic.count(a[i])) &#123;            <span class="hljs-keyword">if</span> (dic[a[i]] != b[i])                <span class="hljs-keyword">return</span> <span class="hljs-literal">false</span>;        &#125; <span class="hljs-keyword">else</span> &#123;            <span class="hljs-keyword">if</span> (dic2.count(b[i]) &amp;&amp; dic2[b[i]] != a[i])                <span class="hljs-keyword">return</span> <span class="hljs-literal">false</span>;            dic[a[i]] = b[i];            dic2[b[i]] = a[i];        &#125;    &#125;    <span class="hljs-comment">// cout &lt;&lt; dic.size() &lt;&lt; endl;</span>    <span class="hljs-keyword">if</span> (dic2.size() == <span class="hljs-number">26</span>)        <span class="hljs-keyword">return</span> <span class="hljs-literal">true</span>;    <span class="hljs-keyword">else</span>        <span class="hljs-keyword">return</span> <span class="hljs-literal">false</span>;&#125;<span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span>&#123;    ios::sync_with_stdio(<span class="hljs-literal">false</span>);    <span class="hljs-keyword">while</span> (<span class="hljs-built_in">cin</span> &gt;&gt; a &gt;&gt; b &gt;&gt; c) &#123;        <span class="hljs-keyword">if</span> (!check())            <span class="hljs-built_in">cout</span> &lt;&lt; <span class="hljs-string">"Failed"</span> &lt;&lt; <span class="hljs-built_in">endl</span>;        <span class="hljs-keyword">else</span> &#123;            rep(i, <span class="hljs-number">0</span>, c.length())            &#123;                <span class="hljs-built_in">cout</span> &lt;&lt; dic[c[i]];            &#125;            <span class="hljs-built_in">cout</span> &lt;&lt; <span class="hljs-built_in">endl</span>;        &#125;    &#125;&#125;</code></pre><h1 id="收获与反思"><a href="#收获与反思" class="headerlink" title="收获与反思"></a>收获与反思</h1><p>无</p>]]></content>
    
    
    <categories>
      
      <category>Computer Science</category>
      
      <category>ACM</category>
      
      <category>洛谷</category>
      
    </categories>
    
    
    <tags>
      
      <tag>ACM</tag>
      
      <tag>洛谷</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>【洛谷-P1068】解题报告（排序）</title>
    <link href="/post/386b56e6.html"/>
    <url>/post/386b56e6.html</url>
    
    <content type="html"><![CDATA[<h1 id="原始题目"><a href="#原始题目" class="headerlink" title="原始题目"></a>原始题目</h1><p><a href="https://www.luogu.org/problemnew/show/P1068" target="_blank" rel="noopener">P1068 分数线划定</a></p><h1 id="题目大意"><a href="#题目大意" class="headerlink" title="题目大意"></a>题目大意</h1><p>取前150%分数，然后按照分数从高到低（不低于录取分数）输出。</p><h1 id="解题思路"><a href="#解题思路" class="headerlink" title="解题思路"></a>解题思路</h1><p>排序后直接判断分数即可。</p><a id="more"></a><h1 id="解题代码"><a href="#解题代码" class="headerlink" title="解题代码"></a>解题代码</h1><pre><code class="hljs C++"><span class="hljs-meta">#<span class="hljs-meta-keyword">include</span> <span class="hljs-meta-string">&lt;bits/stdc++.h&gt;</span></span><span class="hljs-keyword">using</span> <span class="hljs-keyword">namespace</span> <span class="hljs-built_in">std</span>;<span class="hljs-keyword">typedef</span> <span class="hljs-keyword">long</span> <span class="hljs-keyword">long</span> ll;<span class="hljs-keyword">typedef</span> <span class="hljs-keyword">unsigned</span> <span class="hljs-keyword">long</span> <span class="hljs-keyword">long</span> ull;<span class="hljs-keyword">const</span> <span class="hljs-keyword">int</span> maxn = <span class="hljs-number">1e5</span> + <span class="hljs-number">5</span>;<span class="hljs-meta">#<span class="hljs-meta-keyword">define</span> rep(i, a, n) for (int i = a; i &lt; n; ++i)</span><span class="hljs-meta">#<span class="hljs-meta-keyword">define</span> per(i, a, n) for (int i = n - 1; i &gt;= a; --i)</span><span class="hljs-meta">#<span class="hljs-meta-keyword">define</span> fi first</span><span class="hljs-meta">#<span class="hljs-meta-keyword">define</span> se second</span><span class="hljs-meta">#<span class="hljs-meta-keyword">define</span> pb push_back</span><span class="hljs-meta">#<span class="hljs-meta-keyword">define</span> np next_permutation</span><span class="hljs-meta">#<span class="hljs-meta-keyword">define</span> mp make_pair</span><span class="hljs-meta">#<span class="hljs-meta-keyword">define</span> endl <span class="hljs-meta-string">'\n'</span></span><span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">node</span> &#123;</span>    <span class="hljs-keyword">int</span> id, score;&#125;;node a[maxn], ans[maxn];<span class="hljs-function"><span class="hljs-keyword">bool</span> <span class="hljs-title">cmp</span><span class="hljs-params">(node a, node b)</span></span>&#123;    <span class="hljs-keyword">if</span> (a.score != b.score)        <span class="hljs-keyword">return</span> a.score &gt; b.score;    <span class="hljs-keyword">else</span>        <span class="hljs-keyword">return</span> a.id &lt; b.id;&#125;<span class="hljs-keyword">int</span> n, m;<span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span>&#123;    ios::sync_with_stdio(<span class="hljs-literal">false</span>);    <span class="hljs-keyword">while</span> (<span class="hljs-built_in">cin</span> &gt;&gt; n &gt;&gt; m) &#123;        m = (<span class="hljs-keyword">int</span>)(m * <span class="hljs-number">1.5</span>);        <span class="hljs-keyword">if</span> (m &gt; n)            m = n;        rep(i, <span class="hljs-number">1</span>, n + <span class="hljs-number">1</span>) <span class="hljs-built_in">cin</span> &gt;&gt; a[i].id &gt;&gt; a[i].score;        sort(a + <span class="hljs-number">1</span>, a + n + <span class="hljs-number">1</span>, cmp);        <span class="hljs-keyword">int</span> cnt = <span class="hljs-number">1</span>;        <span class="hljs-keyword">while</span> (cnt &lt;= n &amp;&amp; a[cnt].score &gt;= a[m].score) &#123;            ans[cnt].id = a[cnt].id;            ans[cnt].score = a[cnt].score;            cnt++;        &#125;        cnt--;        <span class="hljs-built_in">cout</span> &lt;&lt; a[m].score &lt;&lt; <span class="hljs-string">" "</span> &lt;&lt; cnt &lt;&lt; <span class="hljs-built_in">endl</span>;        rep(i, <span class="hljs-number">1</span>, cnt + <span class="hljs-number">1</span>)        &#123;            <span class="hljs-built_in">cout</span> &lt;&lt; ans[i].id &lt;&lt; <span class="hljs-string">" "</span> &lt;&lt; ans[i].score &lt;&lt; <span class="hljs-built_in">endl</span>;        &#125;    &#125;&#125;</code></pre><h1 id="收获与反思"><a href="#收获与反思" class="headerlink" title="收获与反思"></a>收获与反思</h1><p>无</p>]]></content>
    
    
    <categories>
      
      <category>Computer Science</category>
      
      <category>ACM</category>
      
      <category>洛谷</category>
      
    </categories>
    
    
    <tags>
      
      <tag>ACM</tag>
      
      <tag>洛谷</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>【洛谷-P1055】解题报告（字符串）</title>
    <link href="/post/69feca91.html"/>
    <url>/post/69feca91.html</url>
    
    <content type="html"><![CDATA[<h1 id="原始题目"><a href="#原始题目" class="headerlink" title="原始题目"></a>原始题目</h1><p><a href="https://www.luogu.org/problemnew/show/P1055" target="_blank" rel="noopener">P1055 ISBN号码</a></p><h1 id="题目大意"><a href="#题目大意" class="headerlink" title="题目大意"></a>题目大意</h1><p>对于每一个ISBN编号，最后末位是各位乘对应数组模11的结果，对于每一个ISBN检测是否符合要求。</p><h1 id="解题思路"><a href="#解题思路" class="headerlink" title="解题思路"></a>解题思路</h1><p>按字符串输入做判断即可</p><a id="more"></a><h1 id="解题代码"><a href="#解题代码" class="headerlink" title="解题代码"></a>解题代码</h1><pre><code class="hljs C++"><span class="hljs-meta">#<span class="hljs-meta-keyword">include</span> <span class="hljs-meta-string">&lt;bits/stdc++.h&gt;</span></span><span class="hljs-meta">#<span class="hljs-meta-keyword">include</span> <span class="hljs-meta-string">&lt;sstream&gt;</span></span><span class="hljs-keyword">using</span> <span class="hljs-keyword">namespace</span> <span class="hljs-built_in">std</span>;<span class="hljs-keyword">typedef</span> <span class="hljs-keyword">long</span> <span class="hljs-keyword">long</span> ll;<span class="hljs-keyword">typedef</span> <span class="hljs-keyword">unsigned</span> <span class="hljs-keyword">long</span> <span class="hljs-keyword">long</span> ull;<span class="hljs-keyword">typedef</span> <span class="hljs-built_in">vector</span>&lt;<span class="hljs-keyword">int</span>&gt; vi;<span class="hljs-keyword">typedef</span> pair&lt;<span class="hljs-keyword">int</span>, <span class="hljs-keyword">int</span>&gt; pii;<span class="hljs-keyword">typedef</span> pair&lt;<span class="hljs-built_in">string</span>, <span class="hljs-built_in">string</span>&gt; pss;<span class="hljs-meta">#<span class="hljs-meta-keyword">define</span> rep(i, a, n) for (int i = a; i &lt; n; ++i)</span><span class="hljs-meta">#<span class="hljs-meta-keyword">define</span> per(i, a, n) for (int i = n - 1; i &gt;= a; --i)</span><span class="hljs-meta">#<span class="hljs-meta-keyword">define</span> fi first</span><span class="hljs-meta">#<span class="hljs-meta-keyword">define</span> se second</span><span class="hljs-meta">#<span class="hljs-meta-keyword">define</span> pb push_back</span><span class="hljs-meta">#<span class="hljs-meta-keyword">define</span> mp make_pair</span><span class="hljs-meta">#<span class="hljs-meta-keyword">define</span> np next_permutation</span><span class="hljs-meta">#<span class="hljs-meta-keyword">define</span> INF 0x3f3f3f3f</span><span class="hljs-meta">#<span class="hljs-meta-keyword">define</span> EPS 1e-8</span><span class="hljs-meta">#<span class="hljs-meta-keyword">define</span> endl <span class="hljs-meta-string">'\n'</span></span><span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span>&#123;    ios::sync_with_stdio(<span class="hljs-literal">false</span>);    <span class="hljs-built_in">string</span> s;    <span class="hljs-keyword">while</span> (<span class="hljs-built_in">cin</span> &gt;&gt; s) &#123;        <span class="hljs-function"><span class="hljs-built_in">stringstream</span> <span class="hljs-title">ss</span><span class="hljs-params">(s)</span></span>;        <span class="hljs-keyword">char</span> checkstring[<span class="hljs-number">20</span>], temp;        <span class="hljs-keyword">int</span> cnt = <span class="hljs-number">1</span>;        <span class="hljs-keyword">while</span> (ss &gt;&gt; temp) &#123;            <span class="hljs-keyword">if</span> (temp != <span class="hljs-string">'-'</span>)                checkstring[cnt++] = temp;        &#125;        <span class="hljs-keyword">int</span> ans = <span class="hljs-number">0</span>;        rep(i, <span class="hljs-number">1</span>, <span class="hljs-number">10</span>) ans += (checkstring[i] - <span class="hljs-string">'0'</span>) * i;        ans %= <span class="hljs-number">11</span>;        <span class="hljs-keyword">if</span> (ans == <span class="hljs-number">10</span>)            ans = <span class="hljs-string">'X'</span>;        <span class="hljs-keyword">else</span>            ans += <span class="hljs-string">'0'</span>;        <span class="hljs-keyword">if</span> (ans != checkstring[<span class="hljs-number">10</span>]) &#123;            rep(i, <span class="hljs-number">0</span>, s.length() - <span class="hljs-number">1</span>) <span class="hljs-built_in">cout</span> &lt;&lt; s[i];            <span class="hljs-built_in">cout</span> &lt;&lt; (<span class="hljs-keyword">char</span>)ans &lt;&lt; <span class="hljs-built_in">endl</span>;        &#125; <span class="hljs-keyword">else</span>            <span class="hljs-built_in">cout</span> &lt;&lt; <span class="hljs-string">"Right"</span> &lt;&lt; <span class="hljs-built_in">endl</span>;    &#125;&#125;</code></pre><h1 id="收获与反思"><a href="#收获与反思" class="headerlink" title="收获与反思"></a>收获与反思</h1><p>无</p>]]></content>
    
    
    <categories>
      
      <category>Computer Science</category>
      
      <category>ACM</category>
      
      <category>洛谷</category>
      
    </categories>
    
    
    <tags>
      
      <tag>ACM</tag>
      
      <tag>洛谷</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>【洛谷-P1051】解题报告（模拟）</title>
    <link href="/post/7d274866.html"/>
    <url>/post/7d274866.html</url>
    
    <content type="html"><![CDATA[<h1 id="原始题目"><a href="#原始题目" class="headerlink" title="原始题目"></a>原始题目</h1><p><a href="https://link" target="_blank" rel="noopener">text</a></p><h1 id="题目大意"><a href="#题目大意" class="headerlink" title="题目大意"></a>题目大意</h1><h1 id="解题思路"><a href="#解题思路" class="headerlink" title="解题思路"></a>解题思路</h1><h1 id="解题代码"><a href="#解题代码" class="headerlink" title="解题代码"></a>解题代码</h1>]]></content>
    
    
    <categories>
      
      <category>Computer Science</category>
      
      <category>ACM</category>
      
      <category>洛谷</category>
      
    </categories>
    
    
    <tags>
      
      <tag>ACM</tag>
      
      <tag>洛谷</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>【洛谷-P1035】解题报告（水题）</title>
    <link href="/post/d0793265.html"/>
    <url>/post/d0793265.html</url>
    
    <content type="html"><![CDATA[<h1 id="原始题目"><a href="#原始题目" class="headerlink" title="原始题目"></a>原始题目</h1><p><a href="https://www.luogu.org/problemnew/show/P1035" target="_blank" rel="noopener">P1035</a></p><h1 id="题目大意"><a href="#题目大意" class="headerlink" title="题目大意"></a>题目大意</h1><p>对于调和级数，求最小的n使得调和级数求和大于给定的k。</p><h1 id="解题思路"><a href="#解题思路" class="headerlink" title="解题思路"></a>解题思路</h1><p>水题</p><a id="more"></a><h1 id="解题代码"><a href="#解题代码" class="headerlink" title="解题代码"></a>解题代码</h1><pre><code class="hljs C++"><span class="hljs-meta">#<span class="hljs-meta-keyword">include</span> <span class="hljs-meta-string">&lt;bits/stdc++.h&gt;</span></span><span class="hljs-keyword">using</span> <span class="hljs-keyword">namespace</span> <span class="hljs-built_in">std</span>;<span class="hljs-keyword">typedef</span> <span class="hljs-keyword">long</span> <span class="hljs-keyword">long</span> ll;<span class="hljs-keyword">typedef</span> <span class="hljs-keyword">unsigned</span> <span class="hljs-keyword">long</span> <span class="hljs-keyword">long</span> ull;<span class="hljs-keyword">typedef</span> <span class="hljs-built_in">vector</span>&lt;<span class="hljs-keyword">int</span>&gt; vi;<span class="hljs-keyword">typedef</span> pair&lt;<span class="hljs-keyword">int</span>, <span class="hljs-keyword">int</span>&gt; pii;<span class="hljs-keyword">typedef</span> pair&lt;<span class="hljs-built_in">string</span>, <span class="hljs-built_in">string</span>&gt; pss;<span class="hljs-meta">#<span class="hljs-meta-keyword">define</span> rep(i, a, n) for (int i = a; i &lt; n; ++i)</span><span class="hljs-meta">#<span class="hljs-meta-keyword">define</span> per(i, a, n) for (int i = n - 1; i &gt;= a; --i)</span><span class="hljs-meta">#<span class="hljs-meta-keyword">define</span> fi first</span><span class="hljs-meta">#<span class="hljs-meta-keyword">define</span> se second</span><span class="hljs-meta">#<span class="hljs-meta-keyword">define</span> mp make_pair</span><span class="hljs-meta">#<span class="hljs-meta-keyword">define</span> np next_permutation</span><span class="hljs-meta">#<span class="hljs-meta-keyword">define</span> pb push_back</span><span class="hljs-meta">#<span class="hljs-meta-keyword">define</span> tol(x, y) std::transform(x.begin(), x.end(), y.begin(), ::tolower)</span><span class="hljs-meta">#<span class="hljs-meta-keyword">define</span> tou(x, y) std::transform(x.begin(), x.end(), y.begin(), ::toupper)</span><span class="hljs-meta">#<span class="hljs-meta-keyword">define</span> all(x) x.begin(), x.end()</span><span class="hljs-meta">#<span class="hljs-meta-keyword">define</span> INF 0x3f3f3f3f</span><span class="hljs-meta">#<span class="hljs-meta-keyword">define</span> EPS 1e-8</span><span class="hljs-keyword">int</span> m, t;ll n;<span class="hljs-keyword">double</span> ans;<span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span>&#123;    ios::sync_with_stdio(<span class="hljs-literal">false</span>);    <span class="hljs-keyword">while</span> (<span class="hljs-built_in">cin</span> &gt;&gt; n) &#123;        ans = <span class="hljs-number">0</span>;        ll i;        <span class="hljs-keyword">for</span> (i = <span class="hljs-number">1</span>; ans + <span class="hljs-number">1.0</span> / i &lt;= n + EPS; i++) &#123;            ans += <span class="hljs-number">1.0</span> / i;        &#125;        <span class="hljs-built_in">cout</span> &lt;&lt; i &lt;&lt; <span class="hljs-built_in">endl</span>;    &#125;&#125;</code></pre><h1 id="收获与反思"><a href="#收获与反思" class="headerlink" title="收获与反思"></a>收获与反思</h1><p>无</p>]]></content>
    
    
    <categories>
      
      <category>Computer Science</category>
      
      <category>ACM</category>
      
      <category>洛谷</category>
      
    </categories>
    
    
    <tags>
      
      <tag>ACM</tag>
      
      <tag>洛谷</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>【洛谷-P1010】解题报告（模拟）</title>
    <link href="/post/2bfcd7aa.html"/>
    <url>/post/2bfcd7aa.html</url>
    
    <content type="html"><![CDATA[<h1 id="原始题目"><a href="#原始题目" class="headerlink" title="原始题目"></a>原始题目</h1><p><a href="https://www.luogu.org/problemnew/show/P1010" target="_blank" rel="noopener">P1010 幂次方</a></p><h1 id="题目大意"><a href="#题目大意" class="headerlink" title="题目大意"></a>题目大意</h1><p>2表示2的1次方，2(0)表示2的0次方，所有的底数和指数都变为二进制表示形式，且仅有2和2(0)构成。</p><h1 id="解题思路"><a href="#解题思路" class="headerlink" title="解题思路"></a>解题思路</h1><p>递归得到n的表示方法，输出字符串并记忆化存储到映射中。</p><p>注意:</p><ol><li>开头部分处理+号</li><li>0,1作为边界不再继续递归</li><li>递归返回结果加入上一次调用构造的字符串。</li></ol><a id="more"></a><h1 id="解题代码"><a href="#解题代码" class="headerlink" title="解题代码"></a>解题代码</h1><pre><code class="hljs C++"><span class="hljs-meta">#<span class="hljs-meta-keyword">include</span> <span class="hljs-meta-string">&lt;bits/stdc++.h&gt;</span></span><span class="hljs-keyword">using</span> <span class="hljs-keyword">namespace</span> <span class="hljs-built_in">std</span>;<span class="hljs-keyword">typedef</span> <span class="hljs-keyword">long</span> <span class="hljs-keyword">long</span> ll;<span class="hljs-keyword">typedef</span> <span class="hljs-keyword">unsigned</span> <span class="hljs-keyword">long</span> <span class="hljs-keyword">long</span> ull;<span class="hljs-keyword">typedef</span> <span class="hljs-built_in">vector</span>&lt;<span class="hljs-keyword">int</span>&gt; vi;<span class="hljs-meta">#<span class="hljs-meta-keyword">define</span> rep(i, a, n) for (int i = a; i &lt; n; ++i)</span><span class="hljs-meta">#<span class="hljs-meta-keyword">define</span> per(i, a, n) for (int i = n - 1; i &gt;= a; --i)</span><span class="hljs-meta">#<span class="hljs-meta-keyword">define</span> fi first</span><span class="hljs-meta">#<span class="hljs-meta-keyword">define</span> se second</span><span class="hljs-meta">#<span class="hljs-meta-keyword">define</span> mp make_pair</span><span class="hljs-meta">#<span class="hljs-meta-keyword">define</span> np next_permutation</span><span class="hljs-keyword">int</span> n;<span class="hljs-built_in">map</span>&lt;<span class="hljs-keyword">int</span>, <span class="hljs-built_in">string</span>&gt; tostring;<span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">init</span><span class="hljs-params">()</span></span>&#123;    tostring.clear();    tostring.insert(mp(<span class="hljs-number">0</span>, <span class="hljs-string">"0"</span>));    tostring.insert(mp(<span class="hljs-number">1</span>, <span class="hljs-string">"2(0)"</span>));    tostring.insert(mp(<span class="hljs-number">2</span>, <span class="hljs-string">"2"</span>));&#125;<span class="hljs-function"><span class="hljs-built_in">string</span> <span class="hljs-title">solve</span><span class="hljs-params">(<span class="hljs-keyword">int</span> n)</span></span>&#123;    <span class="hljs-keyword">if</span> (tostring.count(n)) &#123;        <span class="hljs-keyword">return</span> tostring[n];    &#125;    <span class="hljs-built_in">string</span> temp = <span class="hljs-string">""</span>;    <span class="hljs-keyword">int</span> num = <span class="hljs-number">1</span>;    <span class="hljs-keyword">while</span> ((<span class="hljs-number">1</span> &lt;&lt; num) &lt;= n)        num++;    <span class="hljs-keyword">int</span> flag = <span class="hljs-number">1</span>;    per(i, <span class="hljs-number">0</span>, num)    &#123;        <span class="hljs-keyword">if</span> ((<span class="hljs-number">1</span> &lt;&lt; i) &amp; n) &#123;            <span class="hljs-keyword">if</span> (flag) &#123;                flag = <span class="hljs-number">0</span>;                <span class="hljs-keyword">if</span> (i == <span class="hljs-number">1</span> || i == <span class="hljs-number">0</span>) &#123;                    temp += tostring[i + <span class="hljs-number">1</span>];                    <span class="hljs-keyword">continue</span>;                &#125;                temp += <span class="hljs-string">"2("</span>;                temp += solve(i);                temp += <span class="hljs-string">")"</span>;            &#125; <span class="hljs-keyword">else</span> &#123;                temp += <span class="hljs-string">"+"</span>;                <span class="hljs-keyword">if</span> (i == <span class="hljs-number">1</span> || i == <span class="hljs-number">0</span>) &#123;                    temp += tostring[i + <span class="hljs-number">1</span>];                    <span class="hljs-keyword">continue</span>;                &#125;                temp += <span class="hljs-string">"2("</span>;                temp += solve(i);                temp += <span class="hljs-string">")"</span>;            &#125;        &#125;    &#125;    tostring.insert(mp(n, temp));    <span class="hljs-keyword">return</span> temp;&#125;<span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span>&#123;    ios::sync_with_stdio(<span class="hljs-literal">false</span>);    init();    <span class="hljs-keyword">while</span> (<span class="hljs-built_in">cin</span> &gt;&gt; n) &#123;        <span class="hljs-built_in">cout</span> &lt;&lt; solve(n) &lt;&lt; <span class="hljs-built_in">endl</span>;    &#125;&#125;</code></pre><h1 id="收获与反思"><a href="#收获与反思" class="headerlink" title="收获与反思"></a>收获与反思</h1><p>模拟+递归，注意处理的情况，记忆化。</p>]]></content>
    
    
    <categories>
      
      <category>Computer Science</category>
      
      <category>ACM</category>
      
      <category>洛谷</category>
      
    </categories>
    
    
    <tags>
      
      <tag>ACM</tag>
      
      <tag>洛谷</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>【洛谷-P1008】解题报告（水题）</title>
    <link href="/post/7fbcb888.html"/>
    <url>/post/7fbcb888.html</url>
    
    <content type="html"><![CDATA[<h1 id="原始题目"><a href="#原始题目" class="headerlink" title="原始题目"></a>原始题目</h1><p><a href="https://www.luogu.org/problemnew/show/P1008" target="_blank" rel="noopener">P1008 三连击</a></p><h1 id="题目大意"><a href="#题目大意" class="headerlink" title="题目大意"></a>题目大意</h1><p>将$1,2, \cdots ,9$共$9$个数分成$3$组，分别组成$3$个三位数，且使这$3$个三位数构成$1:2:3$的比例，试求出所有满足条件的$3$个三位数。</p><h1 id="解题思路"><a href="#解题思路" class="headerlink" title="解题思路"></a>解题思路</h1><p>注意无0的问题，暴力解。</p><a id="more"></a><h1 id="解题代码"><a href="#解题代码" class="headerlink" title="解题代码"></a>解题代码</h1><pre><code class="hljs C++"><span class="hljs-comment">// 192 384 576</span><span class="hljs-comment">// 219 438 657</span><span class="hljs-comment">// 267 534 801  这个包含0去掉</span><span class="hljs-comment">// 273 546 819</span><span class="hljs-comment">// 327 654 981</span><span class="hljs-meta">#<span class="hljs-meta-keyword">include</span> <span class="hljs-meta-string">&lt;bits/stdc++.h&gt;</span></span><span class="hljs-keyword">using</span> <span class="hljs-keyword">namespace</span> <span class="hljs-built_in">std</span>;<span class="hljs-keyword">const</span> <span class="hljs-keyword">int</span> maxn = <span class="hljs-number">1e5</span> + <span class="hljs-number">5</span>;<span class="hljs-keyword">typedef</span> <span class="hljs-keyword">long</span> <span class="hljs-keyword">long</span> ll;<span class="hljs-keyword">typedef</span> <span class="hljs-keyword">unsigned</span> <span class="hljs-keyword">long</span> <span class="hljs-keyword">long</span> ull;<span class="hljs-keyword">typedef</span> <span class="hljs-built_in">vector</span>&lt;<span class="hljs-keyword">int</span>&gt; vi;<span class="hljs-meta">#<span class="hljs-meta-keyword">define</span> rep(i, a, n) for (int i = a; i &lt; n; ++i)</span><span class="hljs-meta">#<span class="hljs-meta-keyword">define</span> per(i, a, n) for (int i = n - 1; i &gt;= a; --i)</span><span class="hljs-meta">#<span class="hljs-meta-keyword">define</span> fi first</span><span class="hljs-meta">#<span class="hljs-meta-keyword">define</span> se second</span><span class="hljs-meta">#<span class="hljs-meta-keyword">define</span> endl <span class="hljs-meta-string">'\n'</span></span><span class="hljs-meta">#<span class="hljs-meta-keyword">define</span> all(x) x.begin(), x.end()</span><span class="hljs-meta">#<span class="hljs-meta-keyword">define</span> pb push_back</span><span class="hljs-meta">#<span class="hljs-meta-keyword">define</span> np next_permutation</span><span class="hljs-meta">#<span class="hljs-meta-keyword">define</span> mp make_pair</span><span class="hljs-keyword">int</span> vis[maxn];<span class="hljs-function"><span class="hljs-keyword">bool</span> <span class="hljs-title">check</span><span class="hljs-params">(<span class="hljs-keyword">int</span> num)</span></span>&#123;    <span class="hljs-keyword">int</span> a[<span class="hljs-number">6</span>];    <span class="hljs-keyword">int</span> num1 = <span class="hljs-number">2</span> * num;    <span class="hljs-keyword">int</span> num2 = <span class="hljs-number">3</span> * num;    <span class="hljs-keyword">if</span> (num2 &gt;= <span class="hljs-number">999</span>)        <span class="hljs-keyword">return</span> <span class="hljs-literal">false</span>;    <span class="hljs-comment">// if (num / 100 == 1)</span>        <span class="hljs-comment">// cout &lt;&lt; num1 &lt;&lt; " " &lt;&lt; num2 &lt;&lt; endl;</span>    rep(i, <span class="hljs-number">0</span>, <span class="hljs-number">3</span>)    &#123;        a[i] = num1 % <span class="hljs-number">10</span>;        num1 /= <span class="hljs-number">10</span>;    &#125;    rep(i, <span class="hljs-number">3</span>, <span class="hljs-number">6</span>)    &#123;        a[i] = num2 % <span class="hljs-number">10</span>;        num2 /= <span class="hljs-number">10</span>;    &#125;    rep(i, <span class="hljs-number">0</span>, <span class="hljs-number">6</span>)    &#123;        <span class="hljs-keyword">if</span> (vis[a[i]])            <span class="hljs-keyword">return</span> <span class="hljs-literal">false</span>;        vis[a[i]] = <span class="hljs-number">1</span>;    &#125;    <span class="hljs-keyword">return</span> <span class="hljs-literal">true</span>;&#125;<span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span>&#123;    ios::sync_with_stdio(<span class="hljs-literal">false</span>);    rep(i, <span class="hljs-number">1</span>, <span class="hljs-number">3</span> + <span class="hljs-number">1</span>)    &#123;        vis[i] = <span class="hljs-number">1</span>;        rep(j, <span class="hljs-number">1</span>, <span class="hljs-number">9</span> + <span class="hljs-number">1</span>)        &#123;            <span class="hljs-keyword">if</span> (vis[j])                <span class="hljs-keyword">continue</span>;            vis[j] = <span class="hljs-number">1</span>;            rep(k, <span class="hljs-number">1</span>, <span class="hljs-number">9</span> + <span class="hljs-number">1</span>)            &#123;                vis[i] = vis[j] = <span class="hljs-number">1</span>;                <span class="hljs-keyword">if</span> (vis[k])                    <span class="hljs-keyword">continue</span>;                vis[k] = <span class="hljs-number">1</span>;                <span class="hljs-keyword">int</span> temp = <span class="hljs-number">100</span> * i + <span class="hljs-number">10</span> * j + k;                <span class="hljs-keyword">if</span> (check(temp)) &#123;                    <span class="hljs-built_in">cout</span> &lt;&lt; temp &lt;&lt; <span class="hljs-string">" "</span> &lt;&lt; <span class="hljs-number">2</span> * temp &lt;&lt; <span class="hljs-string">" "</span> &lt;&lt; <span class="hljs-number">3</span> * temp &lt;&lt; <span class="hljs-built_in">endl</span>;                &#125;                <span class="hljs-built_in">memset</span>(vis, <span class="hljs-number">0</span>, <span class="hljs-keyword">sizeof</span>(vis));            &#125;            vis[j] = <span class="hljs-number">0</span>;        &#125;        vis[i] = <span class="hljs-number">0</span>;    &#125;    <span class="hljs-keyword">int</span> n;    <span class="hljs-built_in">cin</span> &gt;&gt; n;&#125;</code></pre><h1 id="收获与反思"><a href="#收获与反思" class="headerlink" title="收获与反思"></a>收获与反思</h1><p>无</p>]]></content>
    
    
    <categories>
      
      <category>Computer Science</category>
      
      <category>ACM</category>
      
      <category>洛谷</category>
      
    </categories>
    
    
    <tags>
      
      <tag>ACM</tag>
      
      <tag>洛谷</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>【洛谷-P1940】解题报告（数学，大数）</title>
    <link href="/post/81d45fa1.html"/>
    <url>/post/81d45fa1.html</url>
    
    <content type="html"><![CDATA[<h1 id="原始题目"><a href="#原始题目" class="headerlink" title="原始题目"></a>原始题目</h1><p><a href="https://www.luogu.org/problemnew/show/P1940" target="_blank" rel="noopener">P1940 Reversible Number</a></p><h1 id="题目大意"><a href="#题目大意" class="headerlink" title="题目大意"></a>题目大意</h1><p>有些正整数n可能满足n + 回文(n)（回文(n)是把n倒过来写所得的数）得到的结果的各位都是奇数。那么，小于等于10^x的Reversible数有多少个？方便起见，x是大于等于3小于等于400的正整数。</p><h1 id="解题思路"><a href="#解题思路" class="headerlink" title="解题思路"></a>解题思路</h1><p>很明显不可能是暴力的，题目范围给400位，所以暗示我们跟位数有关系。</p><p>暴力求前几位能得到下面数据</p><blockquote><p>1-9 0</p><p>10-99 20</p><p>100-999 100</p><p>1000-9999 600</p><p>10000-99999 0</p><p>100000-999999 18000</p><p>1000000-9999999 50000</p></blockquote><p>发现奇偶位是有规律的。</p><a id="more"></a><p>数学如下</p><ol><li><p>偶数位数；</p><blockquote><p>若要保证回文性质，要求全部位<strong>不能进位</strong></p></blockquote><p> 可用反证法证明，推矛盾,所以有:</p><script type="math/tex; mode=display">even[2] = 20 , even[2n] = even[2(n-1)] * 30</script></li><li><p>奇数位数：</p><blockquote><p>必然是 进位|不进位|进位</p><p>进位|不进位|进位|不进位|进位|不进位|进位</p><p> 即模4余3位数时可以找到满足的reversible数。</p></blockquote><script type="math/tex; mode=display">odd[3] = [100], odd[4n+3] = odd[4(n-1)+3] * 500</script></li></ol><p>暴力对拍代码</p><pre><code class="hljs C++"><span class="hljs-meta">#<span class="hljs-meta-keyword">include</span> <span class="hljs-meta-string">&lt;bits/stdc++.h&gt;</span></span><span class="hljs-keyword">using</span> <span class="hljs-keyword">namespace</span> <span class="hljs-built_in">std</span>;<span class="hljs-keyword">typedef</span> <span class="hljs-keyword">long</span> <span class="hljs-keyword">long</span> ll;<span class="hljs-meta">#<span class="hljs-meta-keyword">define</span> rep(i, a, n) for (ll i = a; i &lt; n; ++i)</span><span class="hljs-meta">#<span class="hljs-meta-keyword">define</span> per(i, a, n) for (ll i = n - 1; i &gt;= a; --i)</span>ll n, m, N;<span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span>&#123;    <span class="hljs-keyword">while</span> (<span class="hljs-built_in">cin</span> &gt;&gt; n &gt;&gt; m &gt;&gt; N) &#123;        ll cnt = <span class="hljs-number">0</span>;        rep(i, n, m + <span class="hljs-number">1</span>)        &#123;            ll flag = <span class="hljs-number">1</span>;            <span class="hljs-keyword">if</span> (i % <span class="hljs-number">10</span> == <span class="hljs-number">0</span>)                <span class="hljs-keyword">continue</span>;            ll temp = i;            ll sum = temp;            <span class="hljs-keyword">for</span> (ll j = <span class="hljs-number">0</span>; j &lt; N; j++) &#123;                ll addsum = temp % <span class="hljs-number">10</span>;                <span class="hljs-keyword">for</span> (ll k = <span class="hljs-number">0</span>; k &lt; N - j - <span class="hljs-number">1</span>; k++)                sum += addsum;                temp /= <span class="hljs-number">10</span>;            &#125;            temp = sum;            <span class="hljs-keyword">while</span> (temp) &#123;                <span class="hljs-keyword">if</span> ((temp &amp; <span class="hljs-number">1</span>) == <span class="hljs-number">0</span>)                    flag = <span class="hljs-number">0</span>;                temp /= <span class="hljs-number">10</span>;            &#125;            <span class="hljs-comment">// cout &lt;&lt; sum &lt;&lt; endl;</span>            <span class="hljs-keyword">if</span> (flag) &#123;                <span class="hljs-comment">// cout &lt;&lt; "i=" &lt;&lt; i &lt;&lt; "  sum=" &lt;&lt; sum &lt;&lt; endl;</span>                cnt++;            &#125;        &#125;        <span class="hljs-built_in">cout</span> &lt;&lt; cnt &lt;&lt; <span class="hljs-built_in">endl</span>;    &#125;&#125;</code></pre><h1 id="解题代码"><a href="#解题代码" class="headerlink" title="解题代码"></a>解题代码</h1><pre><code class="hljs C++"><span class="hljs-comment">// 1-9 0</span><span class="hljs-comment">// 10-99 20</span><span class="hljs-comment">// 100-999 100</span><span class="hljs-comment">// 1000-9999 600</span><span class="hljs-comment">// 10000-99999 0</span><span class="hljs-comment">// 100000-999999 18000</span><span class="hljs-comment">// 1000000-9999999 50000 ???</span><span class="hljs-comment">//</span><span class="hljs-meta">#<span class="hljs-meta-keyword">include</span> <span class="hljs-meta-string">&lt;bits/stdc++.h&gt;</span></span><span class="hljs-keyword">using</span> <span class="hljs-keyword">namespace</span> <span class="hljs-built_in">std</span>;<span class="hljs-meta">#<span class="hljs-meta-keyword">define</span> rep(i, a, n) for (int i = a; i &lt; n; ++i)</span><span class="hljs-meta">#<span class="hljs-meta-keyword">define</span> per(i, a, n) for (int i = n - 1; i &gt;= a; --i)</span><span class="hljs-meta">#<span class="hljs-meta-keyword">define</span> fi first</span><span class="hljs-meta">#<span class="hljs-meta-keyword">define</span> se second</span><span class="hljs-meta">#<span class="hljs-meta-keyword">define</span> pb push_back</span><span class="hljs-meta">#<span class="hljs-meta-keyword">define</span> np next_permutation</span><span class="hljs-meta">#<span class="hljs-meta-keyword">define</span> INF 0x3f3f3f3f</span><span class="hljs-meta">#<span class="hljs-meta-keyword">define</span> EPS 1e-8</span><span class="hljs-meta">#<span class="hljs-meta-keyword">define</span> eps <span class="hljs-meta-string">'\n'</span></span><span class="hljs-keyword">typedef</span> <span class="hljs-keyword">long</span> <span class="hljs-keyword">long</span> ll;<span class="hljs-keyword">typedef</span> <span class="hljs-keyword">unsigned</span> <span class="hljs-keyword">long</span> <span class="hljs-keyword">long</span> ull;<span class="hljs-keyword">typedef</span> pair&lt;<span class="hljs-keyword">int</span>, <span class="hljs-keyword">int</span>&gt; pii;<span class="hljs-keyword">typedef</span> pair&lt;<span class="hljs-built_in">string</span>, <span class="hljs-built_in">string</span>&gt; pss;<span class="hljs-keyword">typedef</span> <span class="hljs-built_in">vector</span>&lt;<span class="hljs-keyword">int</span>&gt; vi;<span class="hljs-meta">#<span class="hljs-meta-keyword">include</span> <span class="hljs-meta-string">&lt;algorithm&gt;</span></span><span class="hljs-meta">#<span class="hljs-meta-keyword">include</span> <span class="hljs-meta-string">&lt;iomanip&gt;</span></span><span class="hljs-meta">#<span class="hljs-meta-keyword">include</span> <span class="hljs-meta-string">&lt;iostream&gt;</span></span><span class="hljs-meta">#<span class="hljs-meta-keyword">include</span> <span class="hljs-meta-string">&lt;string&gt;</span></span><span class="hljs-keyword">using</span> <span class="hljs-keyword">namespace</span> <span class="hljs-built_in">std</span>;<span class="hljs-meta">#<span class="hljs-meta-keyword">define</span> MAXN 9999</span><span class="hljs-meta">#<span class="hljs-meta-keyword">define</span> MAXSIZE 10</span><span class="hljs-meta">#<span class="hljs-meta-keyword">define</span> DLEN 4</span><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">BigNum</span> &#123;</span><span class="hljs-keyword">private</span>:    <span class="hljs-keyword">int</span> a[<span class="hljs-number">500</span>]; <span class="hljs-comment">//可以控制大数的位数</span>    <span class="hljs-keyword">int</span> len; <span class="hljs-comment">//大数长度</span><span class="hljs-keyword">public</span>:    BigNum()    &#123;        len = <span class="hljs-number">1</span>;        <span class="hljs-built_in">memset</span>(a, <span class="hljs-number">0</span>, <span class="hljs-keyword">sizeof</span>(a));    &#125; <span class="hljs-comment">//构造函数</span>    BigNum(<span class="hljs-keyword">const</span> <span class="hljs-keyword">int</span>); <span class="hljs-comment">//将一个int类型的变量转化为大数</span>    BigNum(<span class="hljs-keyword">const</span> <span class="hljs-keyword">char</span>*); <span class="hljs-comment">//将一个字符串类型的变量转化为大数</span>    BigNum(<span class="hljs-keyword">const</span> BigNum&amp;); <span class="hljs-comment">//拷贝构造函数</span>    BigNum&amp; <span class="hljs-keyword">operator</span>=(<span class="hljs-keyword">const</span> BigNum&amp;); <span class="hljs-comment">//重载赋值运算符，大数之间进行赋值运算</span>    <span class="hljs-keyword">friend</span> istream&amp; <span class="hljs-keyword">operator</span>&gt;&gt;(istream&amp;, BigNum&amp;); <span class="hljs-comment">//重载输入运算符</span>    <span class="hljs-keyword">friend</span> ostream&amp; <span class="hljs-keyword">operator</span>&lt;&lt;(ostream&amp;, BigNum&amp;); <span class="hljs-comment">//重载输出运算符</span>    BigNum <span class="hljs-keyword">operator</span>+(<span class="hljs-keyword">const</span> BigNum&amp;) <span class="hljs-keyword">const</span>; <span class="hljs-comment">//重载加法运算符，两个大数之间的相加运算</span>    BigNum <span class="hljs-keyword">operator</span>-(<span class="hljs-keyword">const</span> BigNum&amp;) <span class="hljs-keyword">const</span>; <span class="hljs-comment">//重载减法运算符，两个大数之间的相减运算</span>    BigNum <span class="hljs-keyword">operator</span>*(<span class="hljs-keyword">const</span> BigNum&amp;)<span class="hljs-keyword">const</span>; <span class="hljs-comment">//重载乘法运算符，两个大数之间的相乘运算</span>    BigNum <span class="hljs-keyword">operator</span>/(<span class="hljs-keyword">const</span> <span class="hljs-keyword">int</span>&amp;) <span class="hljs-keyword">const</span>; <span class="hljs-comment">//重载除法运算符，大数对一个整数进行相除运算</span>    BigNum <span class="hljs-keyword">operator</span>^(<span class="hljs-keyword">const</span> <span class="hljs-keyword">int</span>&amp;) <span class="hljs-keyword">const</span>; <span class="hljs-comment">//大数的n次方运算</span>    <span class="hljs-keyword">int</span> <span class="hljs-keyword">operator</span>%(<span class="hljs-keyword">const</span> <span class="hljs-keyword">int</span>&amp;) <span class="hljs-keyword">const</span>; <span class="hljs-comment">//大数对一个int类型的变量进行取模运算</span>    <span class="hljs-keyword">bool</span> <span class="hljs-keyword">operator</span>&gt;(<span class="hljs-keyword">const</span> BigNum&amp; T) <span class="hljs-keyword">const</span>; <span class="hljs-comment">//大数和另一个大数的大小比较</span>    <span class="hljs-keyword">bool</span> <span class="hljs-keyword">operator</span>&gt;(<span class="hljs-keyword">const</span> <span class="hljs-keyword">int</span>&amp; t) <span class="hljs-keyword">const</span>; <span class="hljs-comment">//大数和一个int类型的变量的大小比较</span>    <span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">print</span><span class="hljs-params">()</span></span>; <span class="hljs-comment">//输出大数</span>&#125;;BigNum::BigNum(<span class="hljs-keyword">const</span> <span class="hljs-keyword">int</span> b) <span class="hljs-comment">//将一个int类型的变量转化为大数</span>&#123;    <span class="hljs-keyword">int</span> c, d = b;    len = <span class="hljs-number">0</span>;    <span class="hljs-built_in">memset</span>(a, <span class="hljs-number">0</span>, <span class="hljs-keyword">sizeof</span>(a));    <span class="hljs-keyword">while</span> (d &gt; MAXN) &#123;        c = d - (d / (MAXN + <span class="hljs-number">1</span>)) * (MAXN + <span class="hljs-number">1</span>);        d = d / (MAXN + <span class="hljs-number">1</span>);        a[len++] = c;    &#125;    a[len++] = d;&#125;BigNum::BigNum(<span class="hljs-keyword">const</span> <span class="hljs-keyword">char</span>* s) <span class="hljs-comment">//将一个字符串类型的变量转化为大数</span>&#123;    <span class="hljs-keyword">int</span> t, k, index, l, i;    <span class="hljs-built_in">memset</span>(a, <span class="hljs-number">0</span>, <span class="hljs-keyword">sizeof</span>(a));    l = <span class="hljs-built_in">strlen</span>(s);    len = l / DLEN;    <span class="hljs-keyword">if</span> (l % DLEN)        len++;    index = <span class="hljs-number">0</span>;    <span class="hljs-keyword">for</span> (i = l - <span class="hljs-number">1</span>; i &gt;= <span class="hljs-number">0</span>; i -= DLEN) &#123;        t = <span class="hljs-number">0</span>;        k = i - DLEN + <span class="hljs-number">1</span>;        <span class="hljs-keyword">if</span> (k &lt; <span class="hljs-number">0</span>)            k = <span class="hljs-number">0</span>;        <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> j = k; j &lt;= i; j++)            t = t * <span class="hljs-number">10</span> + s[j] - <span class="hljs-string">'0'</span>;        a[index++] = t;    &#125;&#125;BigNum::BigNum(<span class="hljs-keyword">const</span> BigNum&amp; T)    : len(T.len) <span class="hljs-comment">//拷贝构造函数</span>&#123;    <span class="hljs-keyword">int</span> i;    <span class="hljs-built_in">memset</span>(a, <span class="hljs-number">0</span>, <span class="hljs-keyword">sizeof</span>(a));    <span class="hljs-keyword">for</span> (i = <span class="hljs-number">0</span>; i &lt; len; i++)        a[i] = T.a[i];&#125;BigNum&amp; BigNum::<span class="hljs-keyword">operator</span>=(<span class="hljs-keyword">const</span> BigNum&amp; n) <span class="hljs-comment">//重载赋值运算符，大数之间进行赋值运算</span>&#123;    <span class="hljs-keyword">int</span> i;    len = n.len;    <span class="hljs-built_in">memset</span>(a, <span class="hljs-number">0</span>, <span class="hljs-keyword">sizeof</span>(a));    <span class="hljs-keyword">for</span> (i = <span class="hljs-number">0</span>; i &lt; len; i++)        a[i] = n.a[i];    <span class="hljs-keyword">return</span> *<span class="hljs-keyword">this</span>;&#125;istream&amp; <span class="hljs-keyword">operator</span>&gt;&gt;(istream&amp; in, BigNum&amp; b) <span class="hljs-comment">//重载输入运算符</span>&#123;    <span class="hljs-keyword">char</span> ch[MAXSIZE * <span class="hljs-number">4</span>];    <span class="hljs-keyword">int</span> i = <span class="hljs-number">-1</span>;    in &gt;&gt; ch;    <span class="hljs-keyword">int</span> l = <span class="hljs-built_in">strlen</span>(ch);    <span class="hljs-keyword">int</span> count = <span class="hljs-number">0</span>, sum = <span class="hljs-number">0</span>;    <span class="hljs-keyword">for</span> (i = l - <span class="hljs-number">1</span>; i &gt;= <span class="hljs-number">0</span>;) &#123;        sum = <span class="hljs-number">0</span>;        <span class="hljs-keyword">int</span> t = <span class="hljs-number">1</span>;        <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> j = <span class="hljs-number">0</span>; j &lt; <span class="hljs-number">4</span> &amp;&amp; i &gt;= <span class="hljs-number">0</span>; j++, i--, t *= <span class="hljs-number">10</span>) &#123;            sum += (ch[i] - <span class="hljs-string">'0'</span>) * t;        &#125;        b.a[count] = sum;        count++;    &#125;    b.len = count++;    <span class="hljs-keyword">return</span> in;&#125;ostream&amp; <span class="hljs-keyword">operator</span>&lt;&lt;(ostream&amp; out, BigNum&amp; b) <span class="hljs-comment">//重载输出运算符</span>&#123;    <span class="hljs-keyword">int</span> i;    <span class="hljs-built_in">cout</span> &lt;&lt; b.a[b.len - <span class="hljs-number">1</span>];    <span class="hljs-keyword">for</span> (i = b.len - <span class="hljs-number">2</span>; i &gt;= <span class="hljs-number">0</span>; i--) &#123;        <span class="hljs-built_in">cout</span>.width(DLEN);        <span class="hljs-built_in">cout</span>.fill(<span class="hljs-string">'0'</span>);        <span class="hljs-built_in">cout</span> &lt;&lt; b.a[i];    &#125;    <span class="hljs-keyword">return</span> out;&#125;BigNum BigNum::<span class="hljs-keyword">operator</span>+(<span class="hljs-keyword">const</span> BigNum&amp; T) <span class="hljs-keyword">const</span> <span class="hljs-comment">//两个大数之间的相加运算</span>&#123;    <span class="hljs-function">BigNum <span class="hljs-title">t</span><span class="hljs-params">(*<span class="hljs-keyword">this</span>)</span></span>;    <span class="hljs-keyword">int</span> i, big; <span class="hljs-comment">//位数</span>    big = T.len &gt; len ? T.len : len;    <span class="hljs-keyword">for</span> (i = <span class="hljs-number">0</span>; i &lt; big; i++) &#123;        t.a[i] += T.a[i];        <span class="hljs-keyword">if</span> (t.a[i] &gt; MAXN) &#123;            t.a[i + <span class="hljs-number">1</span>]++;            t.a[i] -= MAXN + <span class="hljs-number">1</span>;        &#125;    &#125;    <span class="hljs-keyword">if</span> (t.a[big] != <span class="hljs-number">0</span>)        t.len = big + <span class="hljs-number">1</span>;    <span class="hljs-keyword">else</span>        t.len = big;    <span class="hljs-keyword">return</span> t;&#125;BigNum BigNum::<span class="hljs-keyword">operator</span>-(<span class="hljs-keyword">const</span> BigNum&amp; T) <span class="hljs-keyword">const</span> <span class="hljs-comment">//两个大数之间的相减运算</span>&#123;    <span class="hljs-keyword">int</span> i, j, big;    <span class="hljs-keyword">bool</span> flag;    BigNum t1, t2;    <span class="hljs-keyword">if</span> (*<span class="hljs-keyword">this</span> &gt; T) &#123;        t1 = *<span class="hljs-keyword">this</span>;        t2 = T;        flag = <span class="hljs-number">0</span>;    &#125; <span class="hljs-keyword">else</span> &#123;        t1 = T;        t2 = *<span class="hljs-keyword">this</span>;        flag = <span class="hljs-number">1</span>;    &#125;    big = t1.len;    <span class="hljs-keyword">for</span> (i = <span class="hljs-number">0</span>; i &lt; big; i++) &#123;        <span class="hljs-keyword">if</span> (t1.a[i] &lt; t2.a[i]) &#123;            j = i + <span class="hljs-number">1</span>;            <span class="hljs-keyword">while</span> (t1.a[j] == <span class="hljs-number">0</span>)                j++;            t1.a[j--]--;            <span class="hljs-keyword">while</span> (j &gt; i)                t1.a[j--] += MAXN;            t1.a[i] += MAXN + <span class="hljs-number">1</span> - t2.a[i];        &#125; <span class="hljs-keyword">else</span>            t1.a[i] -= t2.a[i];    &#125;    t1.len = big;    <span class="hljs-keyword">while</span> (t1.a[t1.len - <span class="hljs-number">1</span>] == <span class="hljs-number">0</span> &amp;&amp; t1.len &gt; <span class="hljs-number">1</span>) &#123;        t1.len--;        big--;    &#125;    <span class="hljs-keyword">if</span> (flag)        t1.a[big - <span class="hljs-number">1</span>] = <span class="hljs-number">0</span> - t1.a[big - <span class="hljs-number">1</span>];    <span class="hljs-keyword">return</span> t1;&#125;BigNum BigNum::<span class="hljs-keyword">operator</span>*(<span class="hljs-keyword">const</span> BigNum&amp; T) <span class="hljs-keyword">const</span> <span class="hljs-comment">//两个大数之间的相乘运算</span>&#123;    BigNum ret;    <span class="hljs-keyword">int</span> i, j, up;    <span class="hljs-keyword">int</span> temp, temp1;    <span class="hljs-keyword">for</span> (i = <span class="hljs-number">0</span>; i &lt; len; i++) &#123;        up = <span class="hljs-number">0</span>;        <span class="hljs-keyword">for</span> (j = <span class="hljs-number">0</span>; j &lt; T.len; j++) &#123;            temp = a[i] * T.a[j] + ret.a[i + j] + up;            <span class="hljs-keyword">if</span> (temp &gt; MAXN) &#123;                temp1 = temp - temp / (MAXN + <span class="hljs-number">1</span>) * (MAXN + <span class="hljs-number">1</span>);                up = temp / (MAXN + <span class="hljs-number">1</span>);                ret.a[i + j] = temp1;            &#125; <span class="hljs-keyword">else</span> &#123;                up = <span class="hljs-number">0</span>;                ret.a[i + j] = temp;            &#125;        &#125;        <span class="hljs-keyword">if</span> (up != <span class="hljs-number">0</span>)            ret.a[i + j] = up;    &#125;    ret.len = i + j;    <span class="hljs-keyword">while</span> (ret.a[ret.len - <span class="hljs-number">1</span>] == <span class="hljs-number">0</span> &amp;&amp; ret.len &gt; <span class="hljs-number">1</span>)        ret.len--;    <span class="hljs-keyword">return</span> ret;&#125;BigNum BigNum::<span class="hljs-keyword">operator</span>/(<span class="hljs-keyword">const</span> <span class="hljs-keyword">int</span>&amp; b) <span class="hljs-keyword">const</span> <span class="hljs-comment">//大数对一个整数进行相除运算</span>&#123;    BigNum ret;    <span class="hljs-keyword">int</span> i, down = <span class="hljs-number">0</span>;    <span class="hljs-keyword">for</span> (i = len - <span class="hljs-number">1</span>; i &gt;= <span class="hljs-number">0</span>; i--) &#123;        ret.a[i] = (a[i] + down * (MAXN + <span class="hljs-number">1</span>)) / b;        down = a[i] + down * (MAXN + <span class="hljs-number">1</span>) - ret.a[i] * b;    &#125;    ret.len = len;    <span class="hljs-keyword">while</span> (ret.a[ret.len - <span class="hljs-number">1</span>] == <span class="hljs-number">0</span> &amp;&amp; ret.len &gt; <span class="hljs-number">1</span>)        ret.len--;    <span class="hljs-keyword">return</span> ret;&#125;<span class="hljs-keyword">int</span> BigNum::<span class="hljs-keyword">operator</span>%(<span class="hljs-keyword">const</span> <span class="hljs-keyword">int</span>&amp; b) <span class="hljs-keyword">const</span> <span class="hljs-comment">//大数对一个int类型的变量进行取模运算</span>&#123;    <span class="hljs-keyword">int</span> i, d = <span class="hljs-number">0</span>;    <span class="hljs-keyword">for</span> (i = len - <span class="hljs-number">1</span>; i &gt;= <span class="hljs-number">0</span>; i--) &#123;        d = ((d * (MAXN + <span class="hljs-number">1</span>)) % b + a[i]) % b;    &#125;    <span class="hljs-keyword">return</span> d;&#125;BigNum BigNum::<span class="hljs-keyword">operator</span>^(<span class="hljs-keyword">const</span> <span class="hljs-keyword">int</span>&amp; n) <span class="hljs-keyword">const</span> <span class="hljs-comment">//大数的n次方运算</span>&#123;    BigNum t, ret(<span class="hljs-number">1</span>);    <span class="hljs-keyword">int</span> i;    <span class="hljs-keyword">if</span> (n &lt; <span class="hljs-number">0</span>)        <span class="hljs-built_in">exit</span>(<span class="hljs-number">-1</span>);    <span class="hljs-keyword">if</span> (n == <span class="hljs-number">0</span>)        <span class="hljs-keyword">return</span> <span class="hljs-number">1</span>;    <span class="hljs-keyword">if</span> (n == <span class="hljs-number">1</span>)        <span class="hljs-keyword">return</span> *<span class="hljs-keyword">this</span>;    <span class="hljs-keyword">int</span> m = n;    <span class="hljs-keyword">while</span> (m &gt; <span class="hljs-number">1</span>) &#123;        t = *<span class="hljs-keyword">this</span>;        <span class="hljs-keyword">for</span> (i = <span class="hljs-number">1</span>; i &lt;&lt; <span class="hljs-number">1</span> &lt;= m; i &lt;&lt;= <span class="hljs-number">1</span>) &#123;            t = t * t;        &#125;        m -= i;        ret = ret * t;        <span class="hljs-keyword">if</span> (m == <span class="hljs-number">1</span>)            ret = ret * (*<span class="hljs-keyword">this</span>);    &#125;    <span class="hljs-keyword">return</span> ret;&#125;<span class="hljs-keyword">bool</span> BigNum::<span class="hljs-keyword">operator</span>&gt;(<span class="hljs-keyword">const</span> BigNum&amp; T) <span class="hljs-keyword">const</span> <span class="hljs-comment">//大数和另一个大数的大小比较</span>&#123;    <span class="hljs-keyword">int</span> ln;    <span class="hljs-keyword">if</span> (len &gt; T.len)        <span class="hljs-keyword">return</span> <span class="hljs-literal">true</span>;    <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (len == T.len) &#123;        ln = len - <span class="hljs-number">1</span>;        <span class="hljs-keyword">while</span> (a[ln] == T.a[ln] &amp;&amp; ln &gt;= <span class="hljs-number">0</span>)            ln--;        <span class="hljs-keyword">if</span> (ln &gt;= <span class="hljs-number">0</span> &amp;&amp; a[ln] &gt; T.a[ln])            <span class="hljs-keyword">return</span> <span class="hljs-literal">true</span>;        <span class="hljs-keyword">else</span>            <span class="hljs-keyword">return</span> <span class="hljs-literal">false</span>;    &#125; <span class="hljs-keyword">else</span>        <span class="hljs-keyword">return</span> <span class="hljs-literal">false</span>;&#125;<span class="hljs-keyword">bool</span> BigNum::<span class="hljs-keyword">operator</span>&gt;(<span class="hljs-keyword">const</span> <span class="hljs-keyword">int</span>&amp; t) <span class="hljs-keyword">const</span> <span class="hljs-comment">//大数和一个int类型的变量的大小比较</span>&#123;    <span class="hljs-function">BigNum <span class="hljs-title">b</span><span class="hljs-params">(t)</span></span>;    <span class="hljs-keyword">return</span> *<span class="hljs-keyword">this</span> &gt; b;&#125;<span class="hljs-keyword">void</span> BigNum::print() <span class="hljs-comment">//输出大数</span>&#123;    <span class="hljs-keyword">int</span> i;    <span class="hljs-built_in">cout</span> &lt;&lt; a[len - <span class="hljs-number">1</span>];    <span class="hljs-keyword">for</span> (i = len - <span class="hljs-number">2</span>; i &gt;= <span class="hljs-number">0</span>; i--) &#123;        <span class="hljs-built_in">cout</span>.width(DLEN);        <span class="hljs-built_in">cout</span>.fill(<span class="hljs-string">'0'</span>);        <span class="hljs-built_in">cout</span> &lt;&lt; a[i];    &#125;    <span class="hljs-built_in">cout</span> &lt;&lt; <span class="hljs-built_in">endl</span>;&#125;<span class="hljs-keyword">int</span> n, m;<span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span>&#123;    <span class="hljs-keyword">while</span> (~<span class="hljs-built_in">scanf</span>(<span class="hljs-string">"%d"</span>, &amp;n)) &#123;        BigNum ans;        <span class="hljs-keyword">if</span> (n == <span class="hljs-number">1</span>)            <span class="hljs-built_in">printf</span>(<span class="hljs-string">"0\n"</span>);        <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (n == <span class="hljs-number">2</span>)            <span class="hljs-built_in">printf</span>(<span class="hljs-string">"20\n"</span>);        <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (n == <span class="hljs-number">3</span>) &#123;            <span class="hljs-built_in">printf</span>(<span class="hljs-string">"120\n"</span>);        &#125;        <span class="hljs-comment">// continue;</span>        <span class="hljs-keyword">else</span> &#123;            ans = <span class="hljs-number">120</span>;            BigNum tempeven = <span class="hljs-number">20</span>;            BigNum tempodd = <span class="hljs-number">100</span>;            <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> i = <span class="hljs-number">4</span>; i &lt;= n; i++) &#123;                <span class="hljs-keyword">if</span> (i % <span class="hljs-number">4</span> == <span class="hljs-number">3</span>) &#123;                    ans = ans + (tempodd = tempodd * <span class="hljs-number">500</span>);                &#125;                <span class="hljs-keyword">if</span> ((i &amp; <span class="hljs-number">1</span>) == <span class="hljs-number">0</span>) &#123;                    ans = ans + (tempeven = tempeven * <span class="hljs-number">30</span>);                &#125;            &#125;            ans.print();        &#125;    &#125;&#125;</code></pre><h1 id="收获与反思"><a href="#收获与反思" class="headerlink" title="收获与反思"></a>收获与反思</h1><p>奇偶位发现规律并且找出可能数情况的本质，而不是单纯对数据找规律。</p>]]></content>
    
    
    <categories>
      
      <category>Computer Science</category>
      
      <category>ACM</category>
      
      <category>洛谷</category>
      
    </categories>
    
    
    <tags>
      
      <tag>ACM</tag>
      
      <tag>洛谷</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>【洛谷-P1396】解题报告（二分，BFS）</title>
    <link href="/post/3156b4f3.html"/>
    <url>/post/3156b4f3.html</url>
    
    <content type="html"><![CDATA[<h1 id="原始题目"><a href="#原始题目" class="headerlink" title="原始题目"></a>原始题目</h1><p><a href="https://www.luogu.org/problemnew/show/P1396" target="_blank" rel="noopener">P1396 营救</a></p><h1 id="题目大意"><a href="#题目大意" class="headerlink" title="题目大意"></a>题目大意</h1><p>给定一张图，求s到t的路径使得路径上的边权值最大值最小</p><h1 id="解题思路"><a href="#解题思路" class="headerlink" title="解题思路"></a>解题思路</h1><p>最大值最小问题</p><p>二分答案，左界为0有界，有界为所有边权的Max。</p><a id="more"></a><h1 id="解题代码"><a href="#解题代码" class="headerlink" title="解题代码"></a>解题代码</h1><pre><code class="hljs C++"><span class="hljs-comment">//bfs+二分</span><span class="hljs-meta">#<span class="hljs-meta-keyword">include</span> <span class="hljs-meta-string">&lt;bits/stdc++.h&gt;</span></span><span class="hljs-keyword">using</span> <span class="hljs-keyword">namespace</span> <span class="hljs-built_in">std</span>;<span class="hljs-meta">#<span class="hljs-meta-keyword">define</span> rep(i, a, n) for (int i = a; i &lt; n; ++i)</span><span class="hljs-meta">#<span class="hljs-meta-keyword">define</span> per(i, a, n) for (int i = n - 1; i &gt;= a; --i)</span><span class="hljs-meta">#<span class="hljs-meta-keyword">define</span> fi first</span><span class="hljs-meta">#<span class="hljs-meta-keyword">define</span> se second</span><span class="hljs-meta">#<span class="hljs-meta-keyword">define</span> pb push_back</span><span class="hljs-meta">#<span class="hljs-meta-keyword">define</span> np next_permutation</span><span class="hljs-meta">#<span class="hljs-meta-keyword">define</span> INF 0x3f3f3f3f</span><span class="hljs-meta">#<span class="hljs-meta-keyword">define</span> EPS 1e-8</span><span class="hljs-meta">#<span class="hljs-meta-keyword">define</span> eps <span class="hljs-meta-string">'\n'</span></span><span class="hljs-keyword">typedef</span> <span class="hljs-keyword">long</span> <span class="hljs-keyword">long</span> ll;<span class="hljs-keyword">typedef</span> <span class="hljs-keyword">unsigned</span> <span class="hljs-keyword">long</span> <span class="hljs-keyword">long</span> ull;<span class="hljs-keyword">typedef</span> pair&lt;<span class="hljs-keyword">int</span>, <span class="hljs-keyword">int</span>&gt; pii;<span class="hljs-keyword">typedef</span> pair&lt;<span class="hljs-built_in">string</span>, <span class="hljs-built_in">string</span>&gt; pss;<span class="hljs-keyword">typedef</span> <span class="hljs-built_in">vector</span>&lt;<span class="hljs-keyword">int</span>&gt; vi;<span class="hljs-keyword">const</span> <span class="hljs-keyword">int</span> maxn = <span class="hljs-number">1e5</span> + <span class="hljs-number">5</span>;<span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">edge</span> &#123;</span>    <span class="hljs-keyword">int</span> u, v, w;    edge(<span class="hljs-keyword">int</span> _u, <span class="hljs-keyword">int</span> _v, <span class="hljs-keyword">int</span> _w)        : u(_u)        , v(_v)        , w(_w)    &#123;    &#125;    edge() &#123;&#125;&#125;;<span class="hljs-built_in">vector</span>&lt;edge&gt; e[maxn];<span class="hljs-keyword">int</span> vis[maxn];<span class="hljs-keyword">int</span> n, m, ans, ss, tt;<span class="hljs-function"><span class="hljs-keyword">inline</span> <span class="hljs-keyword">void</span> <span class="hljs-title">addEdge</span><span class="hljs-params">(<span class="hljs-keyword">int</span> u, <span class="hljs-keyword">int</span> v, <span class="hljs-keyword">int</span> w)</span></span>&#123;    e[u].push_back(edge(u, v, w));&#125;<span class="hljs-function"><span class="hljs-keyword">bool</span> <span class="hljs-title">check</span><span class="hljs-params">(<span class="hljs-keyword">int</span> mid)</span></span>&#123;    <span class="hljs-built_in">queue</span>&lt;<span class="hljs-keyword">int</span>&gt; q;    <span class="hljs-built_in">memset</span>(vis, <span class="hljs-number">0</span>, <span class="hljs-keyword">sizeof</span>(<span class="hljs-keyword">int</span>) * (n + <span class="hljs-number">1</span>));    q.push(ss);    vis[ss] = <span class="hljs-number">1</span>;    <span class="hljs-keyword">int</span> now, nxt;    <span class="hljs-keyword">while</span> (!q.empty()) &#123;        now = q.front();        q.pop();        rep(i, <span class="hljs-number">0</span>, e[now].size())        &#123;            <span class="hljs-keyword">int</span> tempv = e[now][i].v;            <span class="hljs-keyword">int</span> tempw = e[now][i].w;            <span class="hljs-keyword">if</span> (vis[tempv] || tempw &gt; mid)                <span class="hljs-keyword">continue</span>;            <span class="hljs-keyword">else</span> &#123;                vis[tempv] = <span class="hljs-number">1</span>;                <span class="hljs-keyword">if</span> (tempv == tt)                    <span class="hljs-keyword">return</span> <span class="hljs-literal">true</span>;                q.push(tempv);            &#125;        &#125;    &#125;    <span class="hljs-keyword">return</span> <span class="hljs-literal">false</span>;&#125;<span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span>&#123;    ios::sync_with_stdio(<span class="hljs-literal">false</span>);    <span class="hljs-keyword">while</span> (<span class="hljs-built_in">cin</span> &gt;&gt; n &gt;&gt; m &gt;&gt; ss &gt;&gt; tt) &#123;        ans = <span class="hljs-number">1e4</span> + <span class="hljs-number">5</span>;        <span class="hljs-keyword">int</span> tu, tv, tw;        rep(i, <span class="hljs-number">0</span>, n + <span class="hljs-number">1</span>) e[i].clear();        rep(i, <span class="hljs-number">1</span>, m + <span class="hljs-number">1</span>)        &#123;            <span class="hljs-built_in">cin</span> &gt;&gt; tu &gt;&gt; tv &gt;&gt; tw;            addEdge(tu, tv, tw);            addEdge(tv, tu, tw);        &#125;        <span class="hljs-keyword">int</span> l = <span class="hljs-number">0</span>;        <span class="hljs-keyword">int</span> r = <span class="hljs-number">1e4</span> + <span class="hljs-number">5</span>;        <span class="hljs-keyword">int</span> mid;        <span class="hljs-keyword">while</span> (l &lt; r) &#123;            mid = (l + r) &gt;&gt; <span class="hljs-number">1</span>;            <span class="hljs-keyword">if</span> (check(mid))                r = mid;            <span class="hljs-keyword">else</span>                l = mid + <span class="hljs-number">1</span>;        &#125;        <span class="hljs-built_in">cout</span> &lt;&lt; l &lt;&lt; <span class="hljs-built_in">endl</span>;    &#125;&#125;</code></pre><h1 id="收获与反思"><a href="#收获与反思" class="headerlink" title="收获与反思"></a>收获与反思</h1><p>最大值最小问题，最小值最大问题，可尝试二分答案。</p>]]></content>
    
    
    <categories>
      
      <category>Computer Science</category>
      
      <category>ACM</category>
      
      <category>洛谷</category>
      
    </categories>
    
    
    <tags>
      
      <tag>ACM</tag>
      
      <tag>洛谷</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>【洛谷-P1056】解题报告（模拟）</title>
    <link href="/post/792ebb35.html"/>
    <url>/post/792ebb35.html</url>
    
    <content type="html"><![CDATA[<h1 id="原始题目"><a href="#原始题目" class="headerlink" title="原始题目"></a>原始题目</h1><p><a href="https://www.luogu.org/problemnew/show/P1056" target="_blank" rel="noopener">P1056 排座椅</a></p><h1 id="题目大意"><a href="#题目大意" class="headerlink" title="题目大意"></a>题目大意</h1><p>给出一个$M$行$N$列的矩形，某些相邻的同学交头接耳，设置$K$条横向通道，$L$条纵向通道给出最好的划分方案，能避免最多组同学交头接耳。</p><h1 id="解题思路"><a href="#解题思路" class="headerlink" title="解题思路"></a>解题思路</h1><p>对每一行/列交头接耳的同学对数计数，分别对行列排序后排序输出前k或l个。（注意输出的时候按照字典序，所以要将前k或l个做二次排序，这里有些小坑）。</p><a id="more"></a><h1 id="解题代码"><a href="#解题代码" class="headerlink" title="解题代码"></a>解题代码</h1><pre><code class="hljs C++"><span class="hljs-meta">#<span class="hljs-meta-keyword">include</span> <span class="hljs-meta-string">&lt;bits/stdc++.h&gt;</span></span><span class="hljs-keyword">using</span> <span class="hljs-keyword">namespace</span> <span class="hljs-built_in">std</span>;<span class="hljs-keyword">typedef</span> <span class="hljs-keyword">long</span> <span class="hljs-keyword">long</span> ll;<span class="hljs-keyword">const</span> <span class="hljs-keyword">int</span> maxn = <span class="hljs-number">1e5</span> + <span class="hljs-number">5</span>;<span class="hljs-meta">#<span class="hljs-meta-keyword">define</span> rep(i, a, b) for (int i = a; i &lt; b; ++i)</span><span class="hljs-meta">#<span class="hljs-meta-keyword">define</span> per(i, a, b) for (int i = b - 1; i &gt;= a; --i)</span><span class="hljs-meta">#<span class="hljs-meta-keyword">define</span> fi first</span><span class="hljs-meta">#<span class="hljs-meta-keyword">define</span> se second</span><span class="hljs-keyword">int</span> m, n, a, b, d;<span class="hljs-keyword">int</span> xx1, yy1, xx2, yy2;<span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">node</span> &#123;</span>    <span class="hljs-keyword">int</span> id;    <span class="hljs-keyword">int</span> cnt;&#125;;node xx[maxn], yy[maxn];<span class="hljs-function"><span class="hljs-keyword">bool</span> <span class="hljs-title">cmp</span><span class="hljs-params">(node a, node b)</span></span>&#123;    <span class="hljs-keyword">return</span> a.cnt &gt; b.cnt;&#125;<span class="hljs-function"><span class="hljs-keyword">bool</span> <span class="hljs-title">cmp1</span><span class="hljs-params">(node a, node b)</span></span>&#123;    <span class="hljs-keyword">return</span> a.id &lt; b.id;&#125;<span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span>&#123;    ios::sync_with_stdio(<span class="hljs-literal">false</span>);    <span class="hljs-keyword">while</span> (<span class="hljs-built_in">cin</span> &gt;&gt; m &gt;&gt; n &gt;&gt; a &gt;&gt; b &gt;&gt; d) &#123;        rep(i, <span class="hljs-number">1</span>, m + <span class="hljs-number">1</span>) xx[i].id = i, xx[i].cnt = <span class="hljs-number">0</span>;        rep(i, <span class="hljs-number">1</span>, n + <span class="hljs-number">1</span>) yy[i].id = i, yy[i].cnt = <span class="hljs-number">0</span>;        rep(i, <span class="hljs-number">0</span>, d)        &#123;            <span class="hljs-built_in">cin</span> &gt;&gt; xx1 &gt;&gt; yy1 &gt;&gt; xx2 &gt;&gt; yy2;            <span class="hljs-keyword">if</span> (xx1 == xx2) &#123;                yy[min(yy1, yy2)].cnt++;            &#125; <span class="hljs-keyword">else</span> &#123;                xx[min(xx1, xx2)].cnt++;            &#125;        &#125;        sort(xx + <span class="hljs-number">1</span>, xx + m + <span class="hljs-number">1</span>, cmp);        sort(yy + <span class="hljs-number">1</span>, yy + n + <span class="hljs-number">1</span>, cmp);        sort(xx + <span class="hljs-number">1</span>, xx + a + <span class="hljs-number">1</span>, cmp1);        sort(yy + <span class="hljs-number">1</span>, yy + b + <span class="hljs-number">1</span>, cmp1);        <span class="hljs-built_in">cout</span> &lt;&lt; xx[<span class="hljs-number">1</span>].id;        rep(i, <span class="hljs-number">2</span>, a + <span class="hljs-number">1</span>) <span class="hljs-built_in">cout</span> &lt;&lt; <span class="hljs-string">" "</span> &lt;&lt; xx[i].id;        <span class="hljs-built_in">cout</span> &lt;&lt; <span class="hljs-built_in">endl</span>;        <span class="hljs-built_in">cout</span> &lt;&lt; yy[<span class="hljs-number">1</span>].id;        rep(i, <span class="hljs-number">2</span>, b + <span class="hljs-number">1</span>) <span class="hljs-built_in">cout</span> &lt;&lt; <span class="hljs-string">" "</span> &lt;&lt; yy[i].id;        <span class="hljs-built_in">cout</span> &lt;&lt; <span class="hljs-built_in">endl</span>;    &#125;&#125;</code></pre><h1 id="收获与反思"><a href="#收获与反思" class="headerlink" title="收获与反思"></a>收获与反思</h1><p>因为需要二次排序那里一直Wa，注意审题啊，题目输出格式里明确指出了。</p>]]></content>
    
    
    <categories>
      
      <category>Computer Science</category>
      
      <category>ACM</category>
      
      <category>洛谷</category>
      
    </categories>
    
    
    <tags>
      
      <tag>ACM</tag>
      
      <tag>洛谷</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>【洛谷-P1067】解题报告（模拟）</title>
    <link href="/post/dd932d44.html"/>
    <url>/post/dd932d44.html</url>
    
    <content type="html"><![CDATA[<h1 id="原始题目"><a href="#原始题目" class="headerlink" title="原始题目"></a>原始题目</h1><p><a href="https://www.luogu.org/problemnew/show/P1067" target="_blank" rel="noopener">P1067 多项式输出</a></p><h1 id="题目大意"><a href="#题目大意" class="headerlink" title="题目大意"></a>题目大意</h1><p>给出n次多项式的各项系数，输出符合规范的多项式表达形式。</p><h1 id="解题思路"><a href="#解题思路" class="headerlink" title="解题思路"></a>解题思路</h1><p>模拟注意点：</p><ol><li>最大项为正不需要加正号，其余各项需要</li><li>x^1改为x</li><li>为0的时候跳过</li></ol><a id="more"></a><h1 id="解题代码"><a href="#解题代码" class="headerlink" title="解题代码"></a>解题代码</h1><pre><code class="hljs C++"><span class="hljs-comment">//没考虑常数项，过了</span><span class="hljs-meta">#<span class="hljs-meta-keyword">include</span> <span class="hljs-meta-string">&lt;bits/stdc++.h&gt;</span></span><span class="hljs-keyword">using</span> <span class="hljs-keyword">namespace</span> <span class="hljs-built_in">std</span>;<span class="hljs-keyword">typedef</span> <span class="hljs-keyword">long</span> <span class="hljs-keyword">long</span> ll;<span class="hljs-keyword">const</span> <span class="hljs-keyword">int</span> maxn = <span class="hljs-number">1e5</span> + <span class="hljs-number">5</span>;<span class="hljs-meta">#<span class="hljs-meta-keyword">define</span> rep(i, a, b) for (int i = a; i &lt; b; ++i)</span><span class="hljs-meta">#<span class="hljs-meta-keyword">define</span> per(i, a, b) for (int i = b - 1; i &gt;= a; --i)</span><span class="hljs-comment">// int x[maxn], y[maxn];</span><span class="hljs-keyword">int</span> a[maxn], b[maxn];<span class="hljs-keyword">int</span> n;<span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span>&#123;    ios::sync_with_stdio(<span class="hljs-literal">false</span>);    <span class="hljs-keyword">while</span> (<span class="hljs-built_in">cin</span> &gt;&gt; n) &#123;        per(i, <span class="hljs-number">0</span>, n + <span class="hljs-number">1</span>)        &#123;            <span class="hljs-built_in">cin</span> &gt;&gt; a[i];            <span class="hljs-keyword">if</span> (i == <span class="hljs-number">0</span>) &#123;                <span class="hljs-keyword">if</span> (a[i] == <span class="hljs-number">0</span>)                    <span class="hljs-built_in">cout</span> &lt;&lt; <span class="hljs-built_in">endl</span>;                <span class="hljs-keyword">else</span> &#123;                    <span class="hljs-keyword">if</span> (a[i] &gt; <span class="hljs-number">0</span>)                        <span class="hljs-built_in">cout</span> &lt;&lt; <span class="hljs-string">"+"</span>;                    <span class="hljs-built_in">cout</span> &lt;&lt; a[i] &lt;&lt; <span class="hljs-built_in">endl</span>;                &#125;                <span class="hljs-keyword">break</span>;            &#125; <span class="hljs-keyword">else</span> &#123;                <span class="hljs-keyword">if</span> (a[i] == <span class="hljs-number">0</span>)                    <span class="hljs-keyword">continue</span>;                <span class="hljs-keyword">if</span> (i != n &amp;&amp; a[i] &gt; <span class="hljs-number">0</span>)                    <span class="hljs-built_in">cout</span> &lt;&lt; <span class="hljs-string">"+"</span>;                <span class="hljs-keyword">if</span> (<span class="hljs-built_in">abs</span>(a[i]) == <span class="hljs-number">1</span>) &#123;                    <span class="hljs-keyword">if</span> (a[i] &lt; <span class="hljs-number">0</span>)                        <span class="hljs-built_in">cout</span> &lt;&lt; <span class="hljs-string">"-"</span>;                    <span class="hljs-keyword">if</span> (i != <span class="hljs-number">1</span>)                        <span class="hljs-built_in">cout</span> &lt;&lt; <span class="hljs-string">"x^"</span> &lt;&lt; i;                    <span class="hljs-keyword">else</span>                        <span class="hljs-built_in">cout</span> &lt;&lt; <span class="hljs-string">"x"</span>;                &#125; <span class="hljs-keyword">else</span> &#123;                    <span class="hljs-built_in">cout</span> &lt;&lt; a[i];                    <span class="hljs-keyword">if</span> (i != <span class="hljs-number">1</span>)                        <span class="hljs-built_in">cout</span> &lt;&lt; <span class="hljs-string">"x^"</span> &lt;&lt; i;                    <span class="hljs-keyword">else</span>                        <span class="hljs-built_in">cout</span> &lt;&lt; <span class="hljs-string">"x"</span>;                &#125;            &#125;        &#125;        <span class="hljs-built_in">cout</span> &lt;&lt; <span class="hljs-built_in">endl</span>;    &#125;    <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;&#125;</code></pre><h1 id="收获与反思"><a href="#收获与反思" class="headerlink" title="收获与反思"></a>收获与反思</h1><p>模拟注意细节。</p>]]></content>
    
    
    <categories>
      
      <category>Computer Science</category>
      
      <category>ACM</category>
      
      <category>洛谷</category>
      
    </categories>
    
    
    <tags>
      
      <tag>ACM</tag>
      
      <tag>洛谷</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>【洛谷-P1003】解题报告（模拟）</title>
    <link href="/post/4a2509a9.html"/>
    <url>/post/4a2509a9.html</url>
    
    <content type="html"><![CDATA[<h1 id="原始题目"><a href="#原始题目" class="headerlink" title="原始题目"></a>原始题目</h1><p><a href="https://www.luogu.org/problemnew/show/P1003" target="_blank" rel="noopener">P1003 铺地毯</a></p><h2 id="题目描述"><a href="#题目描述" class="headerlink" title="题目描述"></a>题目描述</h2><p>为了准备一个独特的颁奖典礼，组织者在会场的一片矩形区域（可看做是平面直角坐标系的第一象限）铺上一些矩形地毯。一共有 $n$ 张地毯，编号从 $1$ 到 $n$。现在将这些地毯按照编号从小到大的顺序平行于坐标轴先后铺设，后铺的地毯覆盖在前面已经铺好的地毯之上。</p><p>地毯铺设完成后，组织者想知道覆盖地面某个点的最上面的那张地毯的编号。注意：在矩形地毯边界和四个顶点上的点也算被地毯覆盖。</p><a id="more"></a><h2 id="输入输出格式"><a href="#输入输出格式" class="headerlink" title="输入输出格式"></a>输入输出格式</h2><h3 id="输入格式："><a href="#输入格式：" class="headerlink" title="输入格式："></a>输入格式：</h3><p>输入共$n+2$行</p><p>第一行，一个整数$n$，表示总共有$n$张地毯</p><p>接下来的$n$行中，第 $i+1$ 行表示编号$i$的地毯的信息，包含四个正整数$a ,b ,g ,k$，每两个整数之间用一个空格隔开，分别表示铺设地毯的左下角的坐标$(a,b)$以及地毯在$x$轴和$y$轴方向的长度</p><p>第$n+2$行包含两个正整数$x$和$y$，表示所求的地面的点的坐标$(x,y)$</p><h3 id="输出格式："><a href="#输出格式：" class="headerlink" title="输出格式："></a>输出格式：</h3><p>输出共$1$行，一个整数，表示所求的地毯的编号；若此处没有被地毯覆盖则输出$-1$</p><h2 id="输入输出样例"><a href="#输入输出样例" class="headerlink" title="输入输出样例"></a>输入输出样例</h2><h3 id="输入样例-1："><a href="#输入样例-1：" class="headerlink" title="输入样例#1："></a>输入样例#1：</h3><p>3<br>1 0 2 3<br>0 2 3 3<br>2 1 3 3<br>2 2</p><h3 id="输出样例-1："><a href="#输出样例-1：" class="headerlink" title="输出样例#1："></a>输出样例#1：</h3><p>3</p><h3 id="输入样例-2："><a href="#输入样例-2：" class="headerlink" title="输入样例#2："></a>输入样例#2：</h3><p>3<br>1 0 2 3<br>0 2 3 3<br>2 1 3 3<br>4 5</p><h3 id="输出样例-2："><a href="#输出样例-2：" class="headerlink" title="输出样例#2："></a>输出样例#2：</h3><p>-1</p><h2 id="说明"><a href="#说明" class="headerlink" title="说明"></a>说明</h2><p>【样例解释1】</p><p>如下图，1 号地毯用实线表示，2 号地毯用虚线表示，3 号用双实线表示，覆盖点$(2,2)$的最上面一张地毯是 $3$ 号地毯。</p><p>【数据范围】</p><p>对于30% 的数据，有 $n ≤2$ ；<br>对于50% 的数据，$0 ≤a, b, g, k≤100$；<br>对于100%的数据，有 $0 ≤n ≤10,000$ ，$0≤a, b, g, k ≤100,000$ 。</p><p>noip2011提高组day1第1题</p><h1 id="题目大意"><a href="#题目大意" class="headerlink" title="题目大意"></a>题目大意</h1><p>如题</p><h1 id="解题思路"><a href="#解题思路" class="headerlink" title="解题思路"></a>解题思路</h1><p>根据查询点的多少选择，查询点少的时候考虑保存操作根据然后对每个查询看最终点的覆盖值。</p><h1 id="解题代码"><a href="#解题代码" class="headerlink" title="解题代码"></a>解题代码</h1><pre><code class="hljs C++"><span class="hljs-meta">#<span class="hljs-meta-keyword">include</span> <span class="hljs-meta-string">&lt;bits/stdc++.h&gt;</span></span><span class="hljs-keyword">using</span> <span class="hljs-keyword">namespace</span> <span class="hljs-built_in">std</span>;<span class="hljs-keyword">typedef</span> <span class="hljs-keyword">long</span> <span class="hljs-keyword">long</span> ll;<span class="hljs-keyword">const</span> <span class="hljs-keyword">int</span> maxn = <span class="hljs-number">1e5</span> + <span class="hljs-number">5</span>;<span class="hljs-meta">#<span class="hljs-meta-keyword">define</span> rep(i, a, b) for (int i = a; i &lt; b; ++i)</span><span class="hljs-meta">#<span class="hljs-meta-keyword">define</span> per(i, a, b) for (int i = b - 1; i &gt;= a; --i)</span><span class="hljs-keyword">int</span> x[maxn], y[maxn];<span class="hljs-keyword">int</span> a[maxn], b[maxn];<span class="hljs-keyword">int</span> n;<span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span>&#123;    ios::sync_with_stdio(<span class="hljs-literal">false</span>);    <span class="hljs-keyword">while</span> (<span class="hljs-built_in">cin</span> &gt;&gt; n) &#123;        <span class="hljs-keyword">int</span> ans = <span class="hljs-number">-1</span>;        rep(i, <span class="hljs-number">1</span>, n + <span class="hljs-number">1</span>)        &#123;            <span class="hljs-built_in">cin</span> &gt;&gt; x[i] &gt;&gt; y[i] &gt;&gt; a[i] &gt;&gt; b[i];        &#125;        <span class="hljs-keyword">int</span> xx, yy;        <span class="hljs-built_in">cin</span> &gt;&gt; xx &gt;&gt; yy;        rep(i, <span class="hljs-number">1</span>, n + <span class="hljs-number">1</span>)        &#123;            <span class="hljs-keyword">if</span> (xx &gt;= x[i] &amp;&amp; xx &lt;= x[i] + a[i] &amp;&amp; yy &gt;= y[i] &amp;&amp; yy &lt;= y[i] + b[i]) &#123;                ans = i;            &#125;        &#125;        <span class="hljs-built_in">cout</span> &lt;&lt; ans &lt;&lt; <span class="hljs-built_in">endl</span>;    &#125;    <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;&#125;</code></pre><h1 id="收获与反思"><a href="#收获与反思" class="headerlink" title="收获与反思"></a>收获与反思</h1><p>简单模拟即可。</p>]]></content>
    
    
    <categories>
      
      <category>Computer Science</category>
      
      <category>ACM</category>
      
      <category>洛谷</category>
      
    </categories>
    
    
    <tags>
      
      <tag>ACM</tag>
      
      <tag>洛谷</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>【洛谷-P1001】解题报告（水题）</title>
    <link href="/post/b04c1acf.html"/>
    <url>/post/b04c1acf.html</url>
    
    <content type="html"><![CDATA[<h1 id="原始题目"><a href="#原始题目" class="headerlink" title="原始题目"></a>原始题目</h1><p><a href="https://www.luogu.org/problemnew/show/P1001" target="_blank" rel="noopener">P1001 A+B Problem</a></p><h2 id="题目描述"><a href="#题目描述" class="headerlink" title="题目描述"></a>题目描述</h2><p>输入两个整数 a,b，输出它们的和(|a|,|b|&lt;=10^9)。</p><p>注意</p><ol><li>pascal 使用 integer 会爆掉哦！</li><li>有负数哦！</li><li>c/c++的 main 函数必须是 int 类型，而且最后要 return 0。这不仅对洛谷其他题目有效，而且也是 noip/noi 比赛的要求！</li></ol><p>好吧，同志们，我们就从这一题开始，向着大牛的路进发。</p><blockquote><p>任何一个伟大的思想，都有一个微不足道的开始。</p></blockquote><a id="more"></a><h2 id="输入输出格式"><a href="#输入输出格式" class="headerlink" title="输入输出格式"></a>输入输出格式</h2><h3 id="输入格式："><a href="#输入格式：" class="headerlink" title="输入格式："></a>输入格式：</h3><p>两个整数以空格分开</p><h3 id="输出格式："><a href="#输出格式：" class="headerlink" title="输出格式："></a>输出格式：</h3><p>一个数</p><h2 id="输入输出样例"><a href="#输入输出样例" class="headerlink" title="输入输出样例"></a>输入输出样例</h2><h3 id="输入样例-1："><a href="#输入样例-1：" class="headerlink" title="输入样例#1："></a>输入样例#1：</h3><p>20 30</p><h3 id="输出样例-1："><a href="#输出样例-1：" class="headerlink" title="输出样例#1："></a>输出样例#1：</h3><p>50</p><h1 id="题目大意"><a href="#题目大意" class="headerlink" title="题目大意"></a>题目大意</h1><p>如题</p><h1 id="解题思路"><a href="#解题思路" class="headerlink" title="解题思路"></a>解题思路</h1><p>水题</p><h1 id="解题代码"><a href="#解题代码" class="headerlink" title="解题代码"></a>解题代码</h1><pre><code class="hljs C++"><span class="hljs-meta">#<span class="hljs-meta-keyword">include</span> <span class="hljs-meta-string">&lt;bits/stdc++.h&gt;</span></span><span class="hljs-keyword">using</span> <span class="hljs-keyword">namespace</span> <span class="hljs-built_in">std</span>;<span class="hljs-keyword">typedef</span> <span class="hljs-keyword">long</span> <span class="hljs-keyword">long</span> ll;ll a, b, c, d;<span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span>&#123;    ios::sync_with_stdio(<span class="hljs-literal">false</span>);    <span class="hljs-keyword">while</span> (<span class="hljs-built_in">cin</span> &gt;&gt; a &gt;&gt; b &gt;&gt; c &gt;&gt; d) &#123;        ll sum = (c - a) * <span class="hljs-number">60</span> + d - b;        <span class="hljs-built_in">cout</span> &lt;&lt; sum / <span class="hljs-number">60l</span>l &lt;&lt; <span class="hljs-string">" "</span> &lt;&lt; sum % <span class="hljs-number">60</span> &lt;&lt; <span class="hljs-built_in">endl</span>;    &#125;    <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;&#125;</code></pre><h1 id="收获与反思"><a href="#收获与反思" class="headerlink" title="收获与反思"></a>收获与反思</h1><p>无</p>]]></content>
    
    
    <categories>
      
      <category>Computer Science</category>
      
      <category>ACM</category>
      
      <category>洛谷</category>
      
    </categories>
    
    
    <tags>
      
      <tag>ACM</tag>
      
      <tag>洛谷</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>JavaScript学习——《精通JavaScript》读书笔记</title>
    <link href="/post/859584ac.html"/>
    <url>/post/859584ac.html</url>
    
    <content type="html"><![CDATA[<h1 id="第2章-特性、函数和对象"><a href="#第2章-特性、函数和对象" class="headerlink" title="第2章 特性、函数和对象"></a>第2章 特性、函数和对象</h1><h2 id="语言特性"><a href="#语言特性" class="headerlink" title="语言特性"></a>语言特性</h2><p>引用与值，js中采用<code>值</code>，<code>引用</code>两种方式来保存数据。原始值复制到变量中，而其余部分都依赖引用，从而表征上看的是多个不同名的对象维护相同的数据。</p><h3 id="作用域"><a href="#作用域" class="headerlink" title="作用域"></a>作用域</h3><p><strong>不同于块作用域的语言</strong>，js中只有两种作用域：<code>函数作用域</code>与<code>全局作用域</code>。</p><p>举个栗子</p><pre><code class="hljs js"><span class="hljs-keyword">var</span> foo = <span class="hljs-string">'test'</span>;<span class="hljs-keyword">if</span>(<span class="hljs-literal">true</span>)&#123;    <span class="hljs-comment">//其实修改的是全局作用域</span>    <span class="hljs-keyword">var</span> foo = <span class="hljs-string">'new test'</span>;&#125;<span class="hljs-comment">// 我们会发现这个是true，js中if块语句修改的是全局作用域</span><span class="hljs-built_in">console</span>.log(foo === <span class="hljs-string">'new test'</span>);<span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">test</span>(<span class="hljs-params"></span>) </span>&#123;    <span class="hljs-keyword">var</span> foo = <span class="hljs-string">'old test'</span>;    <span class="hljs-comment">// 函数作用域中我们这里看到的是ture</span>    <span class="hljs-built_in">console</span>.log(foo === <span class="hljs-string">'old test'</span>);&#125;<span class="hljs-comment">//退出函数作用域我们看到的依旧是new test</span><span class="hljs-built_in">console</span>.log(foo === <span class="hljs-string">'new test'</span>);</code></pre><p>另外还需要注意隐式的全局变量声明，专业的js程序猿都应该使用var来初始化变量。这样变量才会拥有你所期望的作用域，避免出乎意料的产生全局变量（比如在函数中不加var）。</p><h3 id="上下文"><a href="#上下文" class="headerlink" title="上下文"></a>上下文</h3><p>你的代码总是拥有某种形式的上下文（代码执行的环境）。上下文是一件强有力的工具，也是面向对象代码必不可少的组成部分。</p><p>太秀了，直接给函数然后就可以调用函数的方法了。</p><pre><code class="hljs js"><span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">setFoo</span>(<span class="hljs-params">fooInput</span>)</span>&#123;    <span class="hljs-keyword">this</span>.foo = fooInput;&#125;<span class="hljs-keyword">var</span> foo = <span class="hljs-number">10</span>; <span class="hljs-comment">//这里定义全局变量foo</span><span class="hljs-keyword">var</span> obj = &#123;<span class="hljs-attr">foo</span>:<span class="hljs-number">10</span>&#125;; <span class="hljs-comment">//定义一个对象，一个成员foo</span><span class="hljs-comment">//此时foo的值为10</span>setFoo(<span class="hljs-number">30</span>);<span class="hljs-comment">//全局调用，this实际上是window，所以全局变量foo值为30</span><span class="hljs-comment">//骚操作来了</span>obj.setFoo = setFoo;obj.setFoo(<span class="hljs-number">30</span>);<span class="hljs-comment">//这样一来将setFoo()与obj绑定在一起，通过this访问obj的上下文，修改了对应的值。</span></code></pre><p>Javascript中有两种方法可以在指定的上下文中运行函数。</p>]]></content>
    
    
    <categories>
      
      <category>Computer Science</category>
      
      <category>JavaScript</category>
      
    </categories>
    
    
    <tags>
      
      <tag>JavaScript</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>《电子产业兴衰史》读书笔记</title>
    <link href="/post/a3770b00.html"/>
    <url>/post/a3770b00.html</url>
    
    <content type="html"><![CDATA[<h1 id="第1章-一个大产业正在从消失"><a href="#第1章-一个大产业正在从消失" class="headerlink" title="第1章 一个大产业正在从消失"></a>第1章 一个大产业正在从消失</h1><p>ICT产业得贸易赤字额与天然气增加得进口额持平</p><p>2000年之前作为令战后新兴经济体骄傲得两大出口商品是电子产品和汽车，然而当来到21世纪，两个产业的发展却是南辕北辙。</p><p>1991年，处于泡沫经济下的，当时媒体还给出如下的评述：</p><blockquote><p>P002 “继汽车之后，电子产品成为了赚取外汇的又一大得力干将。”</p></blockquote><p>关注两产业的贸易收支也可以明显观察到，2000年之前二者可谓势均力敌，但在之后汽车的贸易顺差虽然出现了大幅波动（受一定经济危机的影响），但总体趋势还是上升的，在2013年仍然保证了12万亿元的顺差，而电子产业确实逐渐走低，2013年彻底转变为贸易赤字。</p><p>这里需要区分书中几个常见缩写</p><p><code>ICT</code>：（Information and Communication Technology，信息技术与通信技术）。</p><p><code>电子产业</code>：在国民经济计算中主要用来衡量电子产品<strong>制造业</strong>的发展情况。</p><p><code>信息通信产业</code>：在总务省以及其他机构的统计中，主要用来表现整个信息通信产业的附加值（主要以邮政、报纸、出版、广告等），与电子产业关系密切。</p><p>虽然根据总务省的相关调查统计结果，信息通信产业和电子产业对名义GDP的贡献以及产值、进出口等都是下跌趋势，但明显信息通信产业没有电子产业下滑的那么明显。</p><h2 id="电子产业发展的三个时期"><a href="#电子产业发展的三个时期" class="headerlink" title="电子产业发展的三个时期"></a>电子产业发展的三个时期</h2><ol><li><p>电子产业发展的黄金时期——1970~1985年</p><p> 1970年前，整体经济形式良好，但经济的主角是钢铁和造船业等。</p><blockquote><p>P010 “1970~1985年，的产业结构发生了很大的变化。从1973年开始，钢铁的生产量和原原油的进口量开始减少。与之相对，国内对硅（半导体集成电路的材料）的需求与日俱增。以钢铁产业为代表的‘厚重长大’产业陷入成长低迷，半导体等‘轻薄短小’产业则高速成长”。</p></blockquote><p> 20世纪70年代之后，电子产业在世界范围内开始具有举足轻重的作用。实际上，这一时期电子产业的发展主要靠出口。内需上升三倍，而出口则增加了11倍之多（数据来源经济产业省资源能源统计）。</p></li><li><p>1985年之后贸易顺差开始减少</p><p> 贸易顺差一路看涨的情景在85年发生了转折，出口不再强劲。</p><blockquote><p>P012 进入1985年之后，出口的增长速度变慢，反之进口则开始稳步增加，直接导致了贸易顺差的减少。</p></blockquote><p> 同时，硅需求增长也同步放缓，变相反映出国内电子产业增幅速度变缓。</p></li><li><p>2000年之前，内需增长拉动电子产业的发展</p><p> 内需拉动（主导）阶段，当时经济形势，1985-2000年，经济在泡沫经济的狂潮中崩溃，陷入了人们说的“异常事态”。整体经济增速放缓。<strong>失去的二十年</strong></p><p> 不过或许，内需主导是健全的结构转变？否则电子产业的低迷期会来的更加早一些?</p></li><li><p>2000年以后电子产业总体衰退</p><p> 国内产值在2000年之后急剧下降。</p><blockquote><p>P014 “<strong>GDP几乎没有增长，而电子产业产值却是‘10年减半’</strong>，从生产的角度来看，电子产业是急速衰退的”。</p></blockquote><p> 然而电子零部件出口的持续增长（整体表现强劲），勉强维持了电子产业整体的贸易顺差，但是2008年之后（也是受经济危机的受害者）零部件出口减少，电子产业整体最终转为了贸易赤字。</p></li></ol><p>后续章节着重关注在各个领域，电视、通信、计算机、半导体等究竟发生了什么，以及为什么会发生这些问题。</p>]]></content>
    
    
    <categories>
      
      <category>Life</category>
      
      <category>阅读</category>
      
    </categories>
    
    
    <tags>
      
      <tag>阅读</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>《迦陵说词讲稿》读书笔记</title>
    <link href="/post/4123b063.html"/>
    <url>/post/4123b063.html</url>
    
    <content type="html"><![CDATA[<p>依旧主要为内容摘录</p><h1 id="第一章-词与文化"><a href="#第一章-词与文化" class="headerlink" title="第一章 词与文化"></a>第一章 词与文化</h1><h2 id="第一讲-从西方文论看花间词的美感特质。"><a href="#第一讲-从西方文论看花间词的美感特质。" class="headerlink" title="第一讲 从西方文论看花间词的美感特质。"></a>第一讲 从西方文论看花间词的美感特质。</h2><p>传统文学批评是模糊的、泛泛的，叶先生的学生们常常提出，希望她做些更详细、更有逻辑条理性的分析。我们的课堂上，学生缺乏这种主导课堂的能力以及向授课教师提出要求的勇气。</p><p>先提出困惑</p><blockquote><p>P3 “词作为一种很重要的韵文形式，虽然再中国文学史上占有一席地位，但词学本身却一直是在困惑、矛盾和争议之中发展下来的。”</p></blockquote><p>花间词里写什么？美女。还有什么？爱情。所有的作者都是男性，而他们都要用女性的口吻、女性的语言，写女性的情思。然而中国的传统文学观念是“诗言志，文载道”，而且诗不但要言志，其中最好还要有寄托，如果以传统文学观念去衡量五代以来发展出的词学，那结论是显然的，词学从一开始就不符合传统的文学标准。</p><p>然而词所配合的乐曲在当时是一种新兴的音乐，曲调非常悦耳，有很强的吸引力，广泛在民间流行，这种市井中的快速传播大量丰富了词的创作。</p><blockquote><p>P8 “你现在看任二北先生他们整理的敦煌的曲子，你就会发现它里面有错字、别字及文法不通的现象。因此那个时候这些民间曲子不被人重视，从隋唐以来，这些曲子没有人整理，没有人印刷，一直埋没无传。直到晚清，我们才发现我们竟有如此之多的民间的瑰宝长眠于窟穴之中。”</p></blockquote><p>文人雅士们喜欢填词，一方面是真的感慨这种流行曲子之美，另一方面，可能更重要的，是因为表达的天性一直受着“诗言志，文载道”观念的制约。对于美女与爱情这种形式难以找到合适的形式表达。</p><p>然而这种发展是纠结和妥协的，文人们一方面希望用这种新的形式表达真情实感，一方面又顾及他人（甚至自己叩问自己）这种小词是不是传统观念的叛逆。因而他们也寻找理由与解释为自己开脱、辩解。如黄庭坚所讲“空中语耳”，解释所写都不是作者本人的真感受、真性情，亦或是如晏几道以多义性诡辩之。</p><a id="more"></a><blockquote><p>P11 “其实，宋人为小词所作的辩解还不止于此。有的时候，他们还把词的好坏与作者本人品格的优劣也联系起来，认为品格高雅的人，他所写的美女与爱情的品格也是高雅的；品格低劣的人，他所写的美女与爱情的品格也一定是低俗的。”</p></blockquote>]]></content>
    
    
    <categories>
      
      <category>Life</category>
      
      <category>阅读</category>
      
    </categories>
    
    
    <tags>
      
      <tag>阅读</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>编译原理学习——下推自动机PDA与有限自动机DFA</title>
    <link href="/post/3f9eff25.html"/>
    <url>/post/3f9eff25.html</url>
    
    <content type="html"><![CDATA[<h1 id="为何说丢失了信息"><a href="#为何说丢失了信息" class="headerlink" title="为何说丢失了信息"></a>为何说丢失了信息</h1><p>从需求的角度，如果 DFA 与上下文无关文法（2 型文法）等价，我们仅通过 DFA 就可以完成全部的语法分析，不必引入堆栈等等，但实际上我们需要用到堆栈，也可以直观感受到 DFA 相较于上下文无关文法，信息不足，而缺少的那部分，就和这个“堆栈”密切相关。</p><p>从词法、语法分析的角度，我们在先前第二章已经接触了词法分析，使用的利器就是 DFA 或者 NFA，那既然词法分析用的是这个工具，到了语法分析仍然使用相同的工具就可以完成，岂不是倒退语法分析需求（难度）与词法分析需求（难度）相等吗？显然这是不可能的，所以对于 DFA 对于语法分析并不是全部，还缺少着信息。</p><p>从等价性的角度（这个更科学一些吧），我们了解到 DFA 与 NFA 两者的识别能力相同，且和 RE（正规表达式）可以相互转化，又与正规文法（3 型文法）等价，而上下文无关文法（2 型文法）与 PDA（下推自动机）是等价的。所以我们可以确定由上下文无关文法构造分析表（DFA）时，缺少的信息实际上就是 PDA 和 DFA 的差别。</p><h1 id="丢了什么"><a href="#丢了什么" class="headerlink" title="丢了什么"></a>丢了什么</h1>]]></content>
    
    
    <categories>
      
      <category>Computer Science</category>
      
      <category>编译原理</category>
      
    </categories>
    
    
    <tags>
      
      <tag>编译原理</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>《枪炮、病菌与钢铁》读书笔记</title>
    <link href="/post/74a4286c.html"/>
    <url>/post/74a4286c.html</url>
    
    <content type="html"><![CDATA[<iframe frameborder="no" border="0" marginwidth="0" marginheight="0" width="330" height="86" src="//music.163.com/outchain/player?type=2&id=451991086&auto=1&height=66"></iframe><h1 id="内容摘录与笔记"><a href="#内容摘录与笔记" class="headerlink" title="内容摘录与笔记"></a>内容摘录与笔记</h1><h2 id="前言-耶利的问题"><a href="#前言-耶利的问题" class="headerlink" title="前言 耶利的问题"></a>前言 耶利的问题</h2><blockquote><p>P2“耶利的问题：‘为什么你们白人制造了那么多的货物并将它们运到新几内亚来，而我们黑人却几乎没有属于我们自己的货物呢？’”</p><p>P3 “在普通新几内亚人的生活方式和普通欧洲人或普通美国人的生活方式之间仍然存在着巨大的差异。类似的差异同样把世界上其他民族的生活方式区别了开来。这些巨大的差异必定具有人们可能认为显而易见的重要原因。”</p><p>P3 “关于这个问题的解决办法，专业的历史学家们仍然意见不一：大多数人甚至不再问这样的问题了。”</p><p>P3 “在 25 年后撰写的本书就是试图对耶利的问题作出回答。”</p><p>P10 “在传统的新几内亚社会中，聪明人比不那么聪明的人更有可能逃脱导致高死亡率的死因。然而，在传统的欧洲社会中，流行性疾病造成的死亡率的差异与智力几乎没有任何关系，而是与取决于人体化学细节的遗传抵抗力有关。例如，血型为 B 或 O 的人比血型为 A 的人对天花有更强的抵抗力。就是说，促进智力基因的自然选择，在新几内亚比在人口稠密、政治上复杂的社会可能要无情得多，因为在这样的社会里，对人体化学组成得自然选择反而更有效力。”</p></blockquote><p>如果说之前读到得历史著作对历史进程必然性的分析是基于分布在各大陆的民族在政治、军事、文化等等方面的差异而来的，那么本书想要探究的则是这些差异的来源和产生模式。相较于讨论为什么欧洲人能够<br>屠杀或者正如其他民族的直接原因，这本书着眼于分析，为什么是欧洲人而不是非洲人、亚洲人能够屠杀或者征服其他民族，这种差异是如何从零慢慢演变出来的。是对历史进程终极原因的探索。</p><a id="more"></a><blockquote><p>P15 “新闻记者总使要求作者用一句话把篇幅很长的书加以概括。对本书来说，这样的一句话就是：‘不同民族的历史遵循不同的道路前进，其原因是民族环境的差异，而不是民族自身在生物学上的差异。’”</p></blockquote><p>我更倾向于理解成，更<strong>主要</strong>的原因是…而不是…（阅读前）</p><blockquote><p>P19 “造成粮食生产传播速度差异的一个重大因素原来竟是大陆的轴线方向：欧亚大陆主要是东西向，而美洲和非洲则主要是南北向（第十章）。”</p><p>P19 “第三部分（《从粮食到枪炮、病菌与钢铁》，第十一章到第十四章）从密籍人口所特有的病菌的演化开始，对从终极原因到近似原因的联系进行了考察（第十一章）。欧亚大陆的病菌杀死的印第安人和其他非欧亚大陆民族，比欧亚大陆的枪炮或钢铁武器所杀死的要多得多。相反，在新大陆，很少有或根本没有任何危险的病菌在等待未来的欧洲征服者。为什么病菌的交流这样不相等？在这里，近来分子生物学的研究成果在把病菌和粮食生产的出现相联系方面是富于启发性的，而这两者的联系在欧亚大陆要远远超过美洲。”</p><p>P22 “然而，我希望我已经使读者相信，历史并不‘就是一个又一个讨厌的事实’，就像一个愤世嫉俗者说的那样。的确存在着始用于历史的广泛模式，<br>而寻找这些模式的解释不但令人陶醉，也是大有裨益的。”</p></blockquote><h2 id="第一部分-从伊甸园到卡哈马卡"><a href="#第一部分-从伊甸园到卡哈马卡" class="headerlink" title="第一部分 从伊甸园到卡哈马卡"></a>第一部分 从伊甸园到卡哈马卡</h2><h3 id="第一章-走上起跑线——公元前-11000-年前各个大陆发生了些什么"><a href="#第一章-走上起跑线——公元前-11000-年前各个大陆发生了些什么" class="headerlink" title="第一章 走上起跑线——公元前 11000 年前各个大陆发生了些什么"></a>第一章 走上起跑线——公元前 11000 年前各个大陆发生了些什么</h3><blockquote><p>P3 “用以比较不同大陆的历史发展的合适起点是公元前 11000 年左右。这个年代大致相当于世界上一些地区村社生活的开始。这时，美洲毫无疑问已经出现了首批定居者，更新世和上一次冰期已经结束，地质学家所说的全新世已经开始。在那个年代的几千年内，动植物的训话至少在世界上的一个地方开始了。从那时起，某些大陆上的族群是否已经比其他大陆上的族群领先一步或处于明显优势呢？”</p></blockquote><p>本章想要探索的问题，快速浏览人类的初期历史，是否在很早期就在不同大陆上的人类演化产生了优劣之分，从而影响之后的历史进程。</p><blockquote><p>P8 “我曾在《第三种黑猩猩》一书中主张，是喉的完善为现代语言提供了解剖学的基础，而发挥人的创造力是要大大依靠语言的。而另外一些人则提出，在当时脑容量不变的情况下脑组织发生的变化，使现代语言成为可能。”</p></blockquote><p>大约 10 万年至 5 万年前，人类种族祖先能力发生巨大变化原因的两种解释。</p><p>在之后，4 万年前，克罗马努人用他们现代人的体格，先进的文化，语言技能和智慧，或者变相利用他们身上的细菌，取代了欧洲的尼安德特人，没有证据证明两个早期人类种族的混合，更多的证据指向克罗马努人让尼安德特人不复存在。</p><p>这种种族本身的跃进和人类生存区域的重大扩张在时间上不谋而合。由非洲、亚欧大陆拓展到澳大利亚/新几内亚，以及在大陆板块快速扩散。</p><blockquote><p>P9 “那时候，要从亚洲大陆到达澳大利亚/新几内亚，仍然需要渡过 8 个海峡，其中最宽的一个海峡至少有 50 英里宽。被大多数这样的海峡分隔开的岛屿彼此隔海相望，但从澳大利亚看不见印度尼西亚……因此，对澳大利亚/新几内亚的占有使一个重大事件，因为那需要有水运工具，因此这一点显然提供了关于历史上使用水运工具的最早证据”</p></blockquote><p>还有人类的早期祖先们在各个大陆拓张过程中可能对一些大型哺乳动物带来的影响。</p><blockquote><p>P11 “如此众多的大型动物几乎同时消失这一点引出了一个显而易见的问题：是什么造成了这种情况？一个显而易见的可能答案是：它们被首批到达的人类杀光或间接消灭了。”</p></blockquote><p>由于这种大型哺乳动物灭绝不单单出现在澳大利亚/新几内亚地区，其他大陆包括后来的美洲，也同样出现了这样的灭绝现象，时间也与人类的首次到达和拓殖相差不多，更增添了这一假说的可能性。 也有一些人持气候变化印象，不过作者认为历经历史上的多次气候变化都没灭绝的一众物种都在人类足迹到达之后灭亡，难说是巧合。</p><blockquote><p>P11 “我们知道，加拉帕戈斯群岛喝南极的鸟类喝哺乳动物同样也是在没有人类的情况下演化的，并且直到现代才看见了人，所以今天仍温顺得不可救药。如果不是环境保护主义者采取了保护性措施，它们可能已经很快灭绝了。在其他一些最近才发现的岛上，由于保护措施没有很快实施，消灭动物的事的确发生了：一个这样的受害者就是毛里求斯岛的渡渡鸟，渡渡鸟实际上已成了一种绝种的象征。”</p></blockquote><p>很难不让人思考过去新西兰的恐鸟、马达加斯加的大狐猴喝夏威夷的巨型野鹅是不是也是由于相同原因在更早的时间灭绝。</p><blockquote><p>P13 “从解剖学看，确实掌握了这种技术的现代民族（缝制衣服等抵御寒冷的技术），在大约 2 万年前进入西伯利亚（对此通常都有一些认为时间还要早得多的说法）。这一扩张可能就是欧亚大陆长毛象和长毛犀绝种的原因。”</p><p>P19 “随着人类在美洲的定居，各个大陆和陆边岛屿以及从印度尼西亚到新几内亚东面的洋中岛，凡是可居住的大多数地区都有人类在生活。在世界上其余岛屿的定居直到现代才完成：地中海诸岛如克里特岛、塞浦路斯岛、科西嘉岛和撒丁岛约在公元前 8500 年到 4000 年之间；加勒比海诸岛从公元前 4000 年左右开始；波里尼西亚群岛和密克罗尼西亚群岛在公元前 1200 年到公元 1000 年之间；马达加斯加岛在公元 300 年到 800 年之间；冰岛在公元 9 世纪。美洲印第安人可能是现代伊努伊特人的祖先，他们大约在公元前 2000 年遍布北极附近地区。这样，在过去的 700 年中，唯一的无人居住、等待欧洲探险者光顾的地区就只剩下大西洋和印度洋中那些最偏远的岛屿（如亚速尔群岛和塞舌尔群岛）和南极大陆了。”</p><p>P22 “因此，一个被送回到公元前 11000 年的观察者可能不会预测到哪个大陆上的人类社会会发展最快，但他可以提出充分的理由说明任何一个大陆都有这样的机会……欧亚大陆社会发展较快的真实原因根本不是我们所虚构的公元前 11000 年时的考古学家所猜测的那种直截了当的原因。本书以下篇幅所要研究的就是去发现那些真正的原因。”</p></blockquote><p>去探索导致不同大陆发展差异，历史特殊性的真正原因。</p><h3 id="第二章-历史的自然实验——地理因素是怎样塑造波利尼西亚群岛的社会的"><a href="#第二章-历史的自然实验——地理因素是怎样塑造波利尼西亚群岛的社会的" class="headerlink" title="第二章 历史的自然实验——地理因素是怎样塑造波利尼西亚群岛的社会的"></a>第二章 历史的自然实验——地理因素是怎样塑造波利尼西亚群岛的社会的</h3><p>如果说达尔文在加拉帕戈斯群岛所观察到的“自然实验”是物种起源假说的有力证据，那本书作者对于人类社会在波利尼西亚群岛演化的“自然实验”则是为解决人类发展历史为何如此，是什么造成了历史，给出了可以分析的模式。</p><p>莫里奥里人与毛利人的冲突，虽是由相同祖先分化而来，环境的不同使两个地区的人类走上不同的演化道路，莫里奥里人回归狩猎采集的生活，坚持和平避免冲突的政策，而毛利人则走上集约农业的道路，信奉征服与掠夺。</p><blockquote><p>P24 “这种相反的演化道路注定了他们最后冲突的结果。如果我们能够了解这两个岛屿社会向截然不同的方向发展的原因，我们也许就有了一个模式，用以了解各个大陆不同发展的更广泛的问题。”</p></blockquote><p>这两个人类社会间的冲突又是波利尼西亚群岛这个中等规模“自然实验”下一个更微观的实验。</p><blockquote><p>P28 “在波利尼西亚群岛之间，至少有 6 种环境可变因素促成了波利尼西亚社会之间的这些差异：岛屿气候、地址类型、海洋资源、面积、地形的破碎和隔离程度……”</p></blockquote><h3 id="第三章-卡哈马卡的冲突——为什么印加帝国皇帝阿塔瓦尔帕没有俘虏西班牙国王查理一世"><a href="#第三章-卡哈马卡的冲突——为什么印加帝国皇帝阿塔瓦尔帕没有俘虏西班牙国王查理一世" class="headerlink" title="第三章 卡哈马卡的冲突——为什么印加帝国皇帝阿塔瓦尔帕没有俘虏西班牙国王查理一世"></a>第三章 卡哈马卡的冲突——为什么印加帝国皇帝阿塔瓦尔帕没有俘虏西班牙国王查理一世</h3><blockquote><p>P54 “因此，皮萨罗俘虏阿塔瓦尔帕这件事，表明了导致欧洲人向新大陆移民而不是美洲土著向欧洲移民的那组近似的因素。皮萨罗成功的直接原因包括：以枪炮、钢铁武器和马匹为基础的军事技术；欧亚大陆的传染性流行病；欧洲的航海技术；欧洲国家集中统一的行政组织和文字。本书的书名是这些近似因素的简略的表达，这些因素也使现代欧洲人能够去征服其他大陆的民族。”</p></blockquote><p>划重点，<strong>本书的书名是这些近似因素的简略的表达</strong>。</p><h2 id="第二部分-粮食生产的出现和传播"><a href="#第二部分-粮食生产的出现和传播" class="headerlink" title="第二部分 粮食生产的出现和传播"></a>第二部分 粮食生产的出现和传播</h2><h3 id="第四章-农民的力量——枪炮、病菌与钢铁的根源"><a href="#第四章-农民的力量——枪炮、病菌与钢铁的根源" class="headerlink" title="第四章 农民的力量——枪炮、病菌与钢铁的根源"></a>第四章 农民的力量——枪炮、病菌与钢铁的根源</h3><blockquote><p>P58 “粮食生产是枪炮、病菌和钢铁发展的一个先决条件。因此，在不同大陆的族群是否或何时变成农民和牧人方面的地理差异，在很大程度上说明了他们以后截然不同的命运。”</p><p>P64 “总之，动植物的驯化意味着人类的粮食越来越多，因而也就意味着人口越来越稠密。因此而带来的粮食和（在某些地区）利用畜力运输剩余量是，成了定居的、行政上集中统一的、社会等级分明额、经济上复杂的、技术上富有革新精神的社会的发展的先决条件。因此，能否利用驯化的动植物，最终说明了为什么帝国、知书写字和钢铁武器在欧亚大陆最早发展起来，而在其他大陆则发展较晚，或根本没有发展起来。”</p></blockquote><h3 id="第五章-历史上的穷与富——粮食生产开始时的地理差异"><a href="#第五章-历史上的穷与富——粮食生产开始时的地理差异" class="headerlink" title="第五章 历史上的穷与富——粮食生产开始时的地理差异"></a>第五章 历史上的穷与富——粮食生产开始时的地理差异</h3><blockquote><p>P67 “为什么粮食生产首先在看似相当贫瘠的土地上形成，只是到后来才在今天最肥沃的农田和<br>牧场发展起来？”</p></blockquote><p>确定古代遗存和年代以后，人们怎样确定这个动物或者植物是在附近驯化的，而不是在别处驯化，<br>后来才传到这个遗址来的？</p><blockquote><p>P70 “一个方法是研究这个作物或动物的野生祖先的地理分布图，并推断出驯化势必发生在野生祖先出现的地方。”</p><p>P87 “确定某个作物或动物的驯化地点的第二个方法，是在地图上标出每个地区驯化物种首次出现的年代。出现年代最早的地点也许就是驯化最早的地点——而如果野生物种的祖先也在那里出现，且如果它们在其他地点首先出现的年代随着与推定的最早驯化地点距离的增加而渐次推后，从而表明驯化物种在向其他那些地点传播，情况就尤为如此。”</p><p>P87 “一个极端情况是：有些地区的粮食生产完全是独立出现的……目前能够举出详细又令人信服的证据的这样的地区只有 5 个：西南亚，亦称近东或新月沃地；中国；中美洲（该词用来指墨西哥的中部和南部以及中美洲的毗连地区）；那美洲的安第斯山脉地区，可能还有亚马孙河流域的毗连地区；以及美国东部。在这些粮食生产中心中，有些中心或所有中心可能实际上包含了附近的几个或多或少独立出现的粮食生产的中心，如中国北方的黄河流域和中国南部的长江流域。”</p><p>P92 “另一个极端情况是：有些地区的粮食生产毫无疑问不但是从外来作物和动物的引进开始的，而且也是从外来人的突然到来开始的。”</p></blockquote><h3 id="第六章-种田还是不种田——粮食生产传播的原因"><a href="#第六章-种田还是不种田——粮食生产传播的原因" class="headerlink" title="第六章 种田还是不种田——粮食生产传播的原因"></a>第六章 种田还是不种田——粮食生产传播的原因</h3><p>一个常见的错误观念：从到处流浪流浪的狩猎采集族群与定居的粮食生产者之间必定是界限分明。</p><blockquote><p>P97 “粮食生产制度的渐次形成乃是许多关于时间和劳力分配的不同决定积累的结果。”</p><p>P98 “觅食的人和觅食的动物一样，都在不断地按优先顺序来做出分配劳力的决定，哪怕是无意识地也是一样。他们首先集中注意力于最喜欢的食物，或者能够产生最高报偿的食物……在做出这些决定时要考虑许多问题。人们寻找食物是为了充饥果腹。他们也渴望得到一些特别的食物。如果所有其他情况相同，人们就用一种以最少的时间、最小的努力和最大的回报的方法去寻找食物。”</p><p>P100 “我们必须把粮食生产同狩猎采集看作是<strong>相互竞争的供选择的方法</strong>。”</p></blockquote><h3 id="第七章-怎样识别杏仁——古代作物的无意识的发展"><a href="#第七章-怎样识别杏仁——古代作物的无意识的发展" class="headerlink" title="第七章 怎样识别杏仁——古代作物的无意识的发展"></a>第七章 怎样识别杏仁——古代作物的无意识的发展</h3><blockquote><p>P110 “迄今为止，我们对野生植物演化为作物的描述的种种变化，与早期农民实际上可能已注意到的一些特征直接有关——如果实的大小、苦味、多肉、含油和纤维的长度。通过收获这些具有特别可取的品质的野生植物，古代人在无意识中传播了这些植物，使他们走上了驯化的道路。”</p></blockquote><p>部分奇怪的突变本不利于植物在无人的环境下竞争，不过恰巧是这些突变利于人类对其驯化而保留了下来。</p><blockquote><p>P111 “一个明显的例子就是豌豆。豌豆的种子（我们吃的豌豆）封闭在豆荚里。野豌豆要发芽生长，就必须破荚而出。为了做到这一点，豌豆就演化出一种基因，能使豆荚突然破裂，把豌豆弹射到地上。偶然产生突变的豌豆的豆荚不会爆裂。在野外，这种产生突变的豌豆一直到死都是包裹在亲株上的豆荚里面，而只有这种能爆裂的豆荚才能把它们的基因传递给后代。但与此相反的是，人类能够收获到的唯一豆荚可能就是留在植株上那些不爆裂的豆荚。因此，一旦人类开始把野豌豆带回家去吃，立刻就产生了对这种单基因突变的选择。对同样不爆裂突变进行选择的例子还有兵豆、亚麻和罂粟。”</p></blockquote><p>与之相似的还有后文介绍的大麦和小麦，野生型麦秆可以自动脱落使得种子落到能够发芽生长的地面上，而突变型却保留在麦秆顶端，给人类的采集带来了方便，其后代同样保持了这样的性状，对这种突变品种的无意识选择，显然是人类对植物的第一个重大的“改良”，标志着新月沃地农业的开始。</p><h3 id="第八章-问题在苹果还是印第安人——为什么有些地区的族群未能驯化植物"><a href="#第八章-问题在苹果还是印第安人——为什么有些地区的族群未能驯化植物" class="headerlink" title="第八章 问题在苹果还是印第安人——为什么有些地区的族群未能驯化植物"></a>第八章 问题在苹果还是印第安人——为什么有些地区的族群未能驯化植物</h3><blockquote><p>P127 “人类历史的主要事实之一，是西南亚的那个叫做新月沃地的地区在人类发展早期的重要性。那个地区似乎是包括城市、文字、帝国以及我们所说的文明（不论是福是祸）在内的一连串新情况发生的地方。而所有这些情况之所以发生，都是由于有了稠密的人口，有了剩余粮食的贮存，以及可以养活不从事农业的专门人材，凡此种种之所以可能又都是由于出现了以作物栽培和牲口饲养为形式的粮食生产。”</p></blockquote><p>气候的原因——也影响了早期粮食生产基地的“选址”</p><blockquote><p>P146 “对美国东部驯化植物最了解的农民，就是这个地区的印第安人自己。他们在墨西哥三位一体的作物体系引进后宣判了当地驯化植物的命运：或者把它们完全抛弃，或者把它们的重要性降低。这个结果也表明了印第安人没有受到文化保守主义的束缚，而是在看到一种优良的植物时完全能够认识到它的价值。因此，同在新几内亚一样，美国东部土生土长的粮食生产所受到的限制，不是由于印第安人本身，而是完全决定于美洲的生物区系和环境。”</p></blockquote><p>那么总结性的讲，限制粮食生产或者粮食生产发展水平的主要原因可以归结为下面一段话。</p><blockquote><p>P147 “所有这些不存在本地粮食生产或只有有限的本地粮食生产的地区，都缺少可驯化的牲畜和谷物的野生祖先。”</p></blockquote><p>关于第八章章节首部提出的问题的答案</p><blockquote><p>P150 “因此，在欧洲人到达时，印第安人仍未能驯化北美的苹果，其原因不是印第安人，也不在苹果……印第安人未能驯化苹果的原因却是在于印第安人所能得到的<strong>整个野生动植物组合</strong>。这个组合的<strong>微弱</strong>的驯化潜力，就是北美粮食生产<strong>很晚</strong>才开始的主要原因。</p></blockquote><h3 id="第九章-斑马、不行的婚姻和安娜·卡列尼娜原则——为什么大多数大型野生哺乳动物没有得到驯化"><a href="#第九章-斑马、不行的婚姻和安娜·卡列尼娜原则——为什么大多数大型野生哺乳动物没有得到驯化" class="headerlink" title="第九章 斑马、不行的婚姻和安娜·卡列尼娜原则——为什么大多数大型野生哺乳动物没有得到驯化"></a>第九章 斑马、不行的婚姻和安娜·卡列尼娜原则——为什么大多数大型野生哺乳动物没有得到驯化</h3><blockquote><p>P151 “可驯化的动物都是可以驯化的；不可驯化的动物各有各的不可驯化之处。”</p></blockquote><p>即可以驯化的大型哺乳动物是要求符合多种条件的，这些条件都是“被驯化”这一结果的必要条件，而缺少其中任一（甚至被干扰）都会影响到大型哺乳动物的驯化。</p><blockquote><p>P170 “人类同大多数动物缔结了一种不幸的婚姻，这是由于许多可能的原因中的一个或多个原因造成的：动物的日常食物、生长速度、交配习惯、性情、容易受惊的倾向以及群居组织的几个不同的特点。只有很少一部分野生哺乳动物由于在上述所有这些方面都能协调一致而最终得以和人类结成美满的婚姻”</p></blockquote><h3 id="第十章-辽阔的天空与偏斜的轴线——为什么在不同的大陆粮食生产传播的速度不同"><a href="#第十章-辽阔的天空与偏斜的轴线——为什么在不同的大陆粮食生产传播的速度不同" class="headerlink" title="第十章 辽阔的天空与偏斜的轴线——为什么在不同的大陆粮食生产传播的速度不同"></a>第十章 辽阔的天空与偏斜的轴线——为什么在不同的大陆粮食生产传播的速度不同</h3><blockquote><p>P173 “轴线走向影响了作物和牲口的传播速度，可能还影响文字、车轮和其他发明的传播速度。这种基本的地理特征在过去 500 年中队印第安人、非洲人和欧亚大陆人十分不同的经验的形成起了巨大的促进作用。”</p></blockquote><p>关于“抢先驯化现象”：</p><p>可以反应作物在大陆上的传播速度可以利用“抢先驯化现象”，即如果某一未驯化可利用作物的地方，当面临该作物的野生祖先和传播而来的变种（驯化）作物，可以推断出当地人类会选择后者，因而不会再进行一次其野生祖先的驯化。</p><p>因而，通过遗传分析，可以得到的结果是：欧亚大陆驯化的古代作物多数显示出只有一个不同的野生变种或不同的转化突变体，即反应出一次可利用的驯化。但新大陆的驯化作物则常常出现至少两个，即在不同场合独立的出现了驯化现象。这说明，新大陆对比欧亚大陆，前期驯化成果并没有迅速传播开来，侧面反映了粮食传播的速度差异。</p><p>进一步的</p><blockquote><p>P176 “某种作物的迅速传播可能不但抢先阻止了同一植物的野生祖先在其他地方的驯化，而且也阻止了有亲缘关系的野生植物的驯化。”</p><p>P180 “为什么作物从新月沃地向外传播的速度如此之快？回答部分地取决于我在本章开始时谈到的欧亚大陆的东西向周线。位于同一纬度地东西两地，白天的长度和季节的变化完全相同。在较小程度上，它们也往往具有类似的疾病、温度和雨量情势以及动植物生境或生物群落区（植被类型）。”</p></blockquote><h2 id="第三部分-从粮食到枪炮、病菌与钢铁"><a href="#第三部分-从粮食到枪炮、病菌与钢铁" class="headerlink" title="第三部分 从粮食到枪炮、病菌与钢铁"></a>第三部分 从粮食到枪炮、病菌与钢铁</h2><h3 id="第十一章-牲畜的致命礼物——病菌的演化"><a href="#第十一章-牲畜的致命礼物——病菌的演化" class="headerlink" title="第十一章 牲畜的致命礼物——病菌的演化"></a>第十一章 牲畜的致命礼物——病菌的演化</h3><blockquote><p>P203 “因此，当人口的数量和集中达到一定程度时，我们也就达到了这样的一个历史阶段，在这个阶段我们至少能够形成并保持只有我们人类才会有的人群病。但这个结论也有其矛盾之处：在那时以前这些病是不可能存在的！相反，它们必须演化成新的疾病。那么，这些新的疾病又是从哪里来的呢？”</p><p>P203 “最近，由于对致病病菌所进行的分子研究，证据正在不断出现。就引起我们独有的疾病的许多病菌来说，分子生物学家现在能够确定一些亲缘关系最为接近的病菌。这些病菌同样证明是人群传染病的媒介——不过只在我们的各种家畜和宠物中流行罢了！”</p></blockquote><table><tr><th>人类疾病</th><th>携带亲缘关系最为接近的抗原体的动物</th></tr><tr><td>麻疹</td><td>牛（牛瘟）</td></tr><tr><td>肺结核</td><td>牛</td></tr><tr><td>天花</td><td>牛（牛痘）或携带亲缘痘病毒的其他牲畜</td></tr><tr><td>流行性感冒</td><td>猪和鸭</td></tr><tr><td>百日咳</td><td>猪、狗</td></tr><tr><td>恶性疟疾</td><td>禽鸟（鸡和鸭？）</td></tr></table><p>动物原病转化为人类疾病一般可以分为四个阶段。</p><p>回到开头耶利的问题。</p><blockquote><p>P212 “如果没有欧洲送给其他大陆的不详礼物——从欧亚大陆人与家畜的长期密切关系中演化<br>出来的病菌，这一切也许是不会发生的。”</p></blockquote><h3 id="第十二章-蓝图和借用字母"><a href="#第十二章-蓝图和借用字母" class="headerlink" title="第十二章 蓝图和借用字母"></a>第十二章 蓝图和借用字母</h3><p>文字的力量显而易见，能够指导重大行动下达指令，能够记录前人经验（包括但不限于航海）从而<br>给后人以经验和指导。</p><p>几个问题：</p><ul><li>为什么只有某些民族产生了文字？</li><li>文字在人类历史上分别产生过几次？</li><li>为什么有些民族发明文字早得多？</li><li>为什么有些民族发明文字但之后却利用的很少？</li></ul><p>苏美尔人表示抽象名词的神奇创新：</p><blockquote><p>P218 “也许整个文字史上最重要的一步是苏美尔人采用了语音符号，开始时是借助代表发音</p></blockquote><p>相同而又可以画出来的名词的符号来书写抽象名词。例如，要为<code>弓</code>画出一个可以识别的图形是容易的，但要为<code>生命</code>画出一个可以识别的图形就困难了，但这两者的发音在苏美尔语里都是<code>ti</code>，因此一张弓的图形的意思或者是<code>弓</code>，或者是<code>生命</code>。解决由此而产生的歧义是<br>加上一个叫做义符的无声符号，以表示拟议中的对象所属的名词类别。语言学家把这种决定性的创新称之为<code>画迷原则</code>，也是今天构成双关语的基础。”</p><p>传播形式的两端：“蓝图复制”和“思想传播”。</p><blockquote><p>P225 “罗马字母本身就是长长的一系列蓝图复制的终端产品。在人类历史上，字母只产生过一次：是在公元前第二个千年中从现代叙利亚到西奈半岛这个地区内说闪语的人当中产生的。历史上的和现行的几百种字母，追本溯源全都来自闪语字母这个老祖宗，有些（如爱尔兰的欧甘字母）是思想传播的结果，但大多数则是通过字母形式的实际复制和修改而产生的。 ”</p></blockquote><p>关于文子传播的困惑（为什么有些地方产生了文字却没有传播出去呢？）</p><blockquote><p>P234 “一个相关的限制是很少有人学会书写这些早期的文字。只有国王或寺庙雇佣的专职文字记录者，才掌握关于文字的知识。”</p></blockquote><p>人数少到以至于科学家们可以根据 B 类线性文字的笔迹确定抄写人员（文字记录人员）的大致数量。而早期这种现象可以说是蓄意为之的，因为统治者可不想文字称为底层民众反抗的有效工具，早期文字仅服务于统治者，是控制奴役他人的工具。指导后来这种文字传向民间才有了口口相传的诗歌、史诗落实在笔头上的可能。</p><p>而且文字的产生最初是足够复杂而集中统一的政治机构的需要，没有发展到这一层及的小型部落，即便收到了思想传播的而影响，也很有可能不会发展出文字。</p><blockquote><p>P237 “狩猎采集社会没有发明出文字，甚至也没有采用过任何文字，因为它们既没有需要使用早期文字的机构，也没有生产力为养活文字专家所必需的剩余粮食的社会机制和农业机制。”</p></blockquote><h3 id="第十三章-需要之母"><a href="#第十三章-需要之母" class="headerlink" title="第十三章 需要之母"></a>第十三章 需要之母</h3><blockquote><p>P243 “我们最终将要涉及本书的一个中心问题：为什么在不同的大陆上技术以不同的速度演进的问题”</p><p>P247 “我的两个主要结论是：技术的发展是插个旗积累的，而不是靠孤立的英雄行为；技术在发明出来后</p></blockquote><p>大部分都得到了使用，而不是发明出来去满足某种预见到的需要。”</p><p>一种技术产生后传播受到多种因素的影响。</p><blockquote><p>P263 “中世纪欧洲从 3000 年的字母发展中继承的字母文字适合于用活字印刷，因为只需浇铸几十个字母就行了，</p></blockquote><p>不像中国文字那样需用几千个语言符号。”</p><blockquote><p>P265 “现在，让我们来总结一下，粮食生产开始的时间、技术传播的障碍和人口的多寡这三大因素的变化，是怎样直接导致我们所看到的各大陆之间在技术发展方面的差异的。欧亚大陆（实际上也包括北非在内）是世界上最大的陆块，包含有数量最多的互相竞争的社会。它也是最早开始拥有粮食生产的两个中心的陆块，这两个中心就是新月沃迪和中国。它的东西向的主轴线，使欧亚大陆一个地区采用的许多发明得以较快地传播到欧亚大陆具有想同纬度和气候的其他地区的社会。它的沿次轴线（南北轴线）的宽度，同美洲巴拿马地峡的狭窄形成了对照。它没有把美洲和非洲的主轴线切断的那种严峻的生态障碍。因此，对技术传播的地理和生态障碍，在欧亚大陆没有在其他大陆那样严峻。由于所有这些因素，后更新世技术的加速发展，在欧亚大陆没有在其他大陆那样严峻。由于所有这些因素，后更新世技术的加速发展，在欧亚大陆开始得最早，从而导致了本地最大的技术积累。”</p></blockquote><h3 id="第十四章-从平等主义到盗贼统治"><a href="#第十四章-从平等主义到盗贼统治" class="headerlink" title="第十四章 从平等主义到盗贼统治"></a>第十四章 从平等主义到盗贼统治</h3><blockquote><p>P281 “盗贼统治者和英明政治家得区别，强盗贵族和公益赞助人的区别，只是程度不同而已：这只是一个从生产者那里榨取来的财物有多少被上层人物留下来的问题。”</p></blockquote><p>获取群众的支持，从古至今的盗贼统治者混合使用了 4 种办法：</p><ol><li>接触平民的武装，同时武装上层掌权人物。</li><li>用通行的办法把得到的财务的很大一部分再分配给群众来博取欢心。</li><li>利用对武力的绝对控制来维持公共秩序和制止暴力以促进社会幸福。</li><li>制造一种为盗贼统治辩护的意识形态或宗教。</li></ol><p>早期国家相较于酋长管辖地，直观的差别是规模更大，亲属关系更平淡，最高世袭领袖对信息、决策和权力实行更大的垄断。</p><blockquote><p>P285 “许多早期国家，也是大多数早期国家，都层经历过奴隶制，其规模比酋长管辖地大得多。这不是因为酋长管辖地在处理被打败的敌人时更加宽大为怀，而是因为国家经济专门化的发展，更多的大规模胜场和更多的公共工程需要使用更多的奴隶劳动。此外，更大规模的国家战争能够得到更多的俘虏。”</p></blockquote><p>当然，相较于酋长管辖地，还有一些潜在优势，比如国家对意识形态的统一更能激发一些个人的奉献精神，心甘情愿为国捐躯，现代国家中这已经成为一条基本思想通过我们从小受到的教育灌输进我们的大脑，使我们忘记了它标志着同以往人类历史的彻底决裂。</p><p>不再顾及自己感情和生命，取而代之的，“为了国王和国家”，“为了上帝和西班牙”，“战死沙场最光荣，给我们以生命的神最看重这种光荣的死：我远远看见了它，我的内心充满了对它的渴望！”</p><h2 id="第五部分-在五章中环游世界"><a href="#第五部分-在五章中环游世界" class="headerlink" title="第五部分 在五章中环游世界"></a>第五部分 在五章中环游世界</h2><h3 id="第十五章-耶利的族人——澳大利亚和新几内亚的历史"><a href="#第十五章-耶利的族人——澳大利亚和新几内亚的历史" class="headerlink" title="第十五章 耶利的族人——澳大利亚和新几内亚的历史"></a>第十五章 耶利的族人——澳大利亚和新几内亚的历史</h3><blockquote><p>P321 “‘他们是世界上最悲惨的人，是和没有理性的野兽差不多的人。’”</p><p>P334 “澳大利亚发展粮食生产的另一个主要障碍是缺乏可以驯化的野生植物。甚至现代欧洲的植物遗传学家除了从澳大利亚当地的野生植物中培育出澳洲坚果外，其他就再也没有培育出什么作物来。”</p></blockquote><p>仅有的籽粒最重的 56 种禾本科植物的名单中，只有两种出产在澳大利亚，而且这两种又位列名单末尾，恶劣的干旱环境与不适宜的粮食种植，加之大型有袋类动物的灭绝（与人类共生同步时间短），澳大利亚土著始终都没有突破石器的界限，发展成为有组织的政治实体。</p><h3 id="第十六章-中国是怎样成为中国人的中国的——东亚的历史"><a href="#第十六章-中国是怎样成为中国人的中国的——东亚的历史" class="headerlink" title="第十六章 中国是怎样成为中国人的中国的——东亚的历史"></a>第十六章 中国是怎样成为中国人的中国的——东亚的历史</h3><p>在世界上人口最多的 6 个国家中，除一国歪，其余都是不久前实现政治统一的民族大熔炉。而这一个特殊的国家就是中国。</p><blockquote><p>P349 “近代民族大熔炉这一普遍现象的重大例外是世界上人口最多的国家——中国。今天的中国无论在政治上，文化上或是语言上似乎都是一个大一统的国家，至少再外行人看来是这样。它在公元前 221 年就已经在政治上同意了，并从那时起在大多数世纪中一直保持着统一的局面”</p></blockquote><p>中国这种表面上的统一，并不是理所当然的，本不应该指望有这种统一，而是应该像早期的欧洲（甚至到近代）还有非洲，美洲，由多个早期的聚居中心。华南华北的气候差异，包括语言文字上的差异，本应是多样性的，但我们最终看到的却是相同或者十分相似的语言和文化。</p><p>通过语言敲开中国史也是东亚历史（包括印尼地区）的大门。</p><blockquote><p>P354 “我们可以作这样的推理：如果现代的某些地区只有一种语言或有亲属关系的语族，而这一语言或语族又占有一个广大的连续的区域，那么这些地区就证明了这一语族在地理上的扩张，知识由于时间还不够长，它还没有来得及分化成许多语言。最后，我们还可以作反向的推理：如果在现代的某些地区内存在着属于某一特定语系的语言高度多样性现象，那么这些地区差不多就是该语系的早期分布中心。”</p></blockquote><p>作者根据上述的推理，可以得到中国境内各语系语族发展的经过：华北原先被说汉藏语的人占据，华南不同地区不同时间被说苗瑶语、南亚语和傣-加岱语的人所占据；汉藏语的人经几次南迁（各种缘由的），取代了大部分华南说其他语言的人。而留下的少数发展到今天则形成了差异明显但根源相同的原华南各语系语言。</p><p>较短的南北距离没有相当程度上阻挡各早期聚集地的交流，文化多样性地区之间的交流丰富了中国的文化和技术，而交战的酋长管辖地的竞争，兼并则演化乘了规模更大、权力更集中的国家的形成（建立在早期粮食发展中心、足够人数、与并不明显的地理分割的基础上）。</p><blockquote><p>P358 “中国则不同（于欧亚大陆西部的语言产生），它在华北得到完善，并流传各地，预先制止了任何其他不成熟的书写系统的发展或取而代之，最后演化为今天仍在中国使用的文字。”</p></blockquote><p>中国的这种发展同时也辐射到周边地区，包括原华南地区人的迁移，带去了中国先进的早期文明。</p><blockquote><p>P359 “中国的这种影响就像蒸汽压路机一样势不可挡，先前的热带东南亚民族在这一地区的现代居民中几乎没有留下任何痕迹。只剩下狩猎采集族群的三个孑遗群体——马来半岛的塞芒族小黑人、安达曼群岛岛民和斯里兰卡维多依族矮小黑人——使我们想到热带东南亚的原先居民可能是黑肤、鬈发，就像现代的新几内亚人，而不像肤色较浅、直发的中国华南人及其旁系属现代的热带东南亚人。”</p></blockquote><h3 id="第十七章-驶向波利尼西亚的快艇——南岛人扩张的历史"><a href="#第十七章-驶向波利尼西亚的快艇——南岛人扩张的历史" class="headerlink" title="第十七章 驶向波利尼西亚的快艇——南岛人扩张的历史"></a>第十七章 驶向波利尼西亚的快艇——南岛人扩张的历史</h3><p>由上一章所提到的肤色上的一致、体貌特征、遗传相似性、语言语系都有力表明了，说南岛语的中国华南人，他们在不久前扩散到整个菲律宾和印度尼西亚，更替了原来的居民（很有可能是与新几内亚特征更为相似的原住民）。</p><p>南岛语的故乡很有可能就是古代台湾。</p><blockquote><p>P369 “考古学证据和语言学证据之间两个引人注目的一致证实了这样的推断：几千年前把一种新石器文化带到台湾、菲律宾和印度尼西亚的民族说的是南岛语，并且是今天仍然居住在这些岛屿上的说南岛语的人的祖先。”</p></blockquote><p>反映时间纵深的现代南岛语系的差异性最深刻的在台湾，而马来半岛和苏门答腊的语言全都属于一个亚语支。台湾为南岛语系源头向东南亚和印尼扩张的过程显然更加合理。</p><p>一种有趣的证明方法：根据现代语言词汇来重构古代语言的词汇，对比起差异性结合该词可能产生的年代就可以分析出不同语言的亲属关系（或者相似程度）。</p><p>但是这种迁移的前提条件是说南岛语的人们具备更加先进的粮食种植技术和其他的技术条件，面对狩猎采集种族的时候这种领先优势很自然便会侵占其原住民的生存空间，但面临相同的粮食种植族群，就不一样了（或者是到达其自然环境改变，自身粮食种植和相关技能无法发挥的地方）</p><blockquote><p>P372 “然而，说南岛语的农民未能再向前进入东南亚大陆，因为说南亚语和加岱语的农民已经更替了那些原有的狩猎采集族群，同时也因为说南岛语的农民并不拥有对说南亚语和傣——加岱语的农民的任何优势。”</p></blockquote><p>相类似的，向新几内亚地区发展时，由于该区域有高原地区的最初的粮食产地，新几内亚人从事粮食生产也有数千年之久，南岛人并不具备优势，所以被挡在了外围。</p><p>东亚和太平洋人类社会是颇有教益的，提供了很多环境塑造历史的生动例子。</p><blockquote><p>P380 “东亚和太平洋族群凭借他们地理上的家园，无论在利用可驯化的动植物方面，或是再与其他族群的联系方面，都显得与众不同。一次又一次地，是具有发展粮食生产的先决条件并处在有利于传播来自别处的技术的地理位置上的族群，取代了缺乏这些优势的族群。一次又一次地，当一次移民浪潮在不同的环境中展开时，环境的不同决定了移民的后代以各自的不同方式发展。”</p></blockquote><h3 id="第十八章-两个半球的碰撞——欧亚大陆与美洲历史的比较"><a href="#第十八章-两个半球的碰撞——欧亚大陆与美洲历史的比较" class="headerlink" title="第十八章 两个半球的碰撞——欧亚大陆与美洲历史的比较"></a>第十八章 两个半球的碰撞——欧亚大陆与美洲历史的比较</h3><p>根本问题：为什么是欧洲人到达了印第安人地国家并征服了它，而不是相反。</p><p>综合运用前几章地内容加以解释。</p><p>从粮食生产地角度，由于更新世晚期美洲大陆的哺乳动物大量灭绝（至少比欧亚要惨重一些），而可供驯养的就更少了，只有羊驼。</p><blockquote><p>P383 “如果不是由于这些动物灭绝了，现代史的进程可能会有所不同。当科尔特斯率领他的满身泥污的雇佣军于 1519 年再墨西哥海岸登陆时，他们可能会被几千个骑着本地驯化的美洲马的阿兹特克骑兵赶进大海。那么，结果就不是阿兹特克人死于天花，而是那些西班牙人可能会被对疾病有抵抗力的阿兹特克人所传染的美洲病菌消灭光。依靠畜力的美洲文明国家可能会派遣自己的征服者区蹂躏欧洲。”</p></blockquote><p>除了丢失了提供蛋白质、或者供军事、粮食耕作的大型哺乳动物，美洲的原始农业，相较欧亚大陆也有不少不利条件，比如以下五条。</p><ul><li>依赖蛋白质含量低的玉米，而不是欧亚大陆种类繁多、蛋白质吩咐的谷物。</li><li>点种、不能撒播</li><li>缺乏畜力（可驯化的大型哺乳动物的缺失）耕作</li><li>缺乏可以增加土壤肥力的动物粪便</li><li>缺乏畜力进行脱粒、碾磨和灌溉之类的农活</li></ul><p>由粮食生产差异带来的，是其他各个方面的差异。不能养活足够的人，人口不够稠密所以不足以演化出致命疾病、以及更先进的技术等等。</p><p>技术领域：金属器具、战争用具与骑兵、能源运转（这里我们要重视蒸汽动力出现前畜力、风力、水力的差异）、轮子（轮子和仅有的羊驼始终都没有机会碰面）以及海上运输。</p><p>人员不够稠密实际上使美洲大陆空间上更像一个个孤立分裂的小大陆，难以像欧亚大陆一样形成权力集中的政治实体，政治合法化以及调动大量资源进行对其他民族的战争。</p><p>书中关于欧亚大陆的领先优势结果的细致论述在此就不再过多分析了，有机会可以再回顾一下。</p><h3 id="尾声-人类史作为一门科学的未来"><a href="#尾声-人类史作为一门科学的未来" class="headerlink" title="尾声 人类史作为一门科学的未来"></a>尾声 人类史作为一门科学的未来</h3><p>各大陆民族长期历史之间的显著差异，不是源自这些民族本身的天生差异，而是源自他们环境的差异。</p><p>各大陆不同的特点中，有 4 组差异是最重要的：</p><p>第一组差异是各大陆在可以用作驯化的起始物种的野生动植物品种方面的差异。粮食生产是基础性的差异是关键的，而且有运气的成分在里面，有如安娜卡列尼娜原则，不是人类想驯化就可以驯化。</p><p>第二组差异是那些影响传播和迁移速度的因素，比如轴线，地理障碍等。欧亚大陆在这一组上具有得天独厚的优势。</p><p>第三组是影响大陆之间传播的因素，更为孤立的澳大利亚就受到了相当的影响。抢先驯化现象还有驯化成果的传播，有时恰恰依赖大陆之间的联系程度。</p><p>第四组是最后一组各大陆之间在面积和人口总数方面的差异。更大面积或更多人口意味着更多的潜在发明者，更多的互相竞争的社会，更多的可以采用的发明创造——以及更大的采用和保有发明创造的压力。竞争的作用太大了。</p><p>特别的，关注一下中国的情况可以说明，前期的优势并不能决定后期的后期，中国恰恰是因为过早形成了单一集权的国家，统一形式虽然加快了前期技术的传播，但是在单一决策失误上付出的代价却让我们丧失了优势，地理上的四通八达对技术的发展既有积极的影响也有消极的影响。</p><p>历史不再是一个又一个令人讨厌的事实。</p>]]></content>
    
    
    <categories>
      
      <category>Life</category>
      
      <category>阅读</category>
      
    </categories>
    
    
    <tags>
      
      <tag>阅读</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>操作系统学习——集群技术初识</title>
    <link href="/post/2024a703.html"/>
    <url>/post/2024a703.html</url>
    
    <content type="html"><![CDATA[<p>（可以关注一下 Future Generation Computer Systems）</p><p>集群技术初识——以 Linux 负载均衡集群学习为例</p><h1 id="写在前面"><a href="#写在前面" class="headerlink" title="写在前面"></a>写在前面</h1><p>本文主要参考：章文嵩博士所写的<a href="http://www.linuxvirtualserver.org/zh/lvs1.html#author1" target="_blank" rel="noopener">Linux 服务器集群系统介绍</a>，<a href="https://blog.51cto.com/jiangzhi2013/1222666" target="_blank" rel="noopener">集群技术（原理篇）</a>，高俊峰所著《高性能 Linux 服务器构建实战》，魔软运维社所著《大规模 Linux 集群架构最佳实践》。</p><p>由于查阅资料的时候不懂得地方太多，所以多数只能从概念上简单理解，如想自己深入理解其中的奥妙，还需要完成本门课程，将基础打好，同时熟悉 Linux 系统的一些基本情况后再做深入且仔细的学习。</p><h1 id="第一部分-什么是集群"><a href="#第一部分-什么是集群" class="headerlink" title="第一部分 什么是集群"></a>第一部分 什么是集群</h1><h2 id="背景"><a href="#背景" class="headerlink" title="背景"></a>背景</h2><p>我们在计算机网络中已经学习了<strong>吞吐量</strong>的概念，即单位时间内成功地传送数据的数量（以比特、字节、分组等测量），我们这里着重考量接收端的吞吐能力（以带宽衡量）。</p><p>Internet 的飞速发展给网络带宽和服务器带来巨大的挑战。从网络技术的发展来看，网络带宽的增长远高于处理器速度和内存访问速度的增长，这是什么意思。数据出了小区门（计算机）在<strong>路途中已经可以上高速公路</strong>了，但是在<strong>小区内的行驶速度却成了难题</strong>，越来越多的瓶颈会出现在服务器端。互联网的海洋中对性能的不断提高，高可伸缩性、高可用性、可管理性、价格有效性的网络服务技术将成为网络服务技术的主导。各种平台下的技术方案应运而生。</p><a id="more"></a><h2 id="对称多处理系统"><a href="#对称多处理系统" class="headerlink" title="对称多处理系统"></a>对称多处理系统</h2><blockquote><p>对称多处理（Symmetric Multi-Processor，简称 SMP）是由多个对称的处理器、和通过总线共享的内存和 I/O 部件所组成的计算机系统。SMP 是一种低并行度的结构，是我们通常所说的”紧耦合多处理系统”，</p></blockquote><p>SMP 的可扩展能力有限，但也有相应的优点：</p><ul><li>单一系统映像（Single System Image）</li><li>有共享的内存和 I/O，</li><li>易编程。</li></ul><p>由于 SMP 的可扩展能力有限，SMP 服务器显然不能满足高可伸缩、高可用网络服务中的负载处理能力不断增长需求。随着负载不断增长，会导致服务器不断地升 级。这种服务器升级有下列不足：</p><ul><li>升级过程繁琐，机器切换会使服务暂时中断，并造成原有计算资源的浪费</li><li>越往高端的服务器，所花费的代价越大；</li><li>三是 SMP 服务器是单一故障点（Single Point of Failure），一旦该服务器或应用软件失效，会导致整个服务的中断。</li></ul><h2 id="集群的起源"><a href="#集群的起源" class="headerlink" title="集群的起源"></a>集群的起源</h2><p>集群并不是一个全新的概念，其实早在七十年代计算机厂商和研究机构就开始了对集群系统的研究和开发。由于主要用于科学工程计算，所以这些系统并不为大家所熟知。直到 Linux 集群的出现，集群的概念才得以广为传播。对集群的研究起源于集群系统的良好的性能可扩展性(scalability)。提高 CPU 主频和总线带宽是最初提供计算机性能的主要手段。但是这一手段对系统性能的提供是有限的。接着人们通过增加 CPU 个数和内存容量来提高性能，于是出现了向量机，对称多处理机(SMP)等。但是当 CPU 的个数超过某一阈值，象 SMP 这些多处理机系统的可扩展性就变的极差。主要瓶颈在于 CPU 访问内存的带宽并不能随着 CPU 个数的增加而有效增长。与 SMP 相反，集群系统的性能随着 CPU 个数的增加几乎是线性变化的</p><p><img src="https://eddyblog.oss-cn-shenzhen.aliyuncs.com/20190321os1.jpg" srcset="/img/loading.gif" alt="1"></p><p>集群恰恰是通过高性能网络或局域网互联的服务器集群正成为实现高可伸缩的、高可用网络服务的有效结构（而非基于单机 CPU 数量的增长）。这种松耦合结构的服务器集群系统有下列优点：</p><ul><li><p><strong>性能</strong></p><p>网络服务的工作负载通常是大量相互独立的任务，通过一组服务器分而治之，可以获得很高的整体性能。</p></li><li><p><strong>性能/价格比</strong></p><p>组成集群系统的 PC 服务器或 RISC 服务器和标准网络设备因为大规模生产降低成本，价格低，具有最高的性能/价格比。若整体性能随着结点数的增长而接近线性增加，该系统的性能/价格比接近于 PC 服务器。所以，这种松耦合结构比紧耦合的多处理器系统具有更好的性能/价格比。</p></li><li><p><strong>可伸缩性</strong></p><p>集群系统中的结点数目可以增长到几千个，乃至上万个，其伸缩性远超过单台超级计算机。</p></li><li><p><strong>高可用性</strong><br>在硬件和软件上都有冗余，通过检测软硬件的故障，将故障屏蔽，由存活结点提供服务，可实现高可用性。</p></li></ul><p>当然，用服务器集群系统实现可伸缩网络服务也存在很多挑战性的工作：</p><ul><li><p><strong>透明性</strong>（Transparency）<br>对用户透明，如何高效地使得由多个独立计算机组成的松藕合的集群系统构成一个虚拟服务器；客户端应用程序与集群系统交互时，就像与一台高性能、高可用的服务器交互一样，客户端无须作任何修改。部分服务器的切入和切出不会中断服务，这对用户也是透明的。</p></li><li><p><strong>性能</strong>（Performance）</p><p>性能要接近线性加速，这需要设计很好的软硬件的体系结构，消除系统可能存在的瓶颈。将负载较均衡地调度到各台服务器上。</p></li><li><p><strong>高可用性</strong>（Availability）</p><p>需要设计和实现很好的系统资源和故障的监测和处理系统。当发现一个模块失败时，要这模块上提供的服务迁移到其他模块上。在理想状况下，这种迁移是即时的、自动的。</p></li><li><p><strong>可管理性</strong>（Manageability）</p><p>要使集群系统变得易管理，就像管理一个单一映像系统一样。在理想状况下，软硬件模块的插入能做到即插即用（Plug &amp; Play）。</p></li><li><p><strong>可编程性</strong>（Programmability）</p><p>在集群系统上，容易开发应用程序。</p></li></ul><h2 id="集群类型"><a href="#集群类型" class="headerlink" title="集群类型"></a>集群类型</h2><p>通常我们根据需求将集群分为三类：<code>负载均衡集群（Load Balancing LB）</code><br>,<code>高可用性集群（High Availability HA）</code>,<code>高性能也叫科学集群（High Performance HP</code>。</p><p>下面做一下详细的介绍（来源自博客），笔者本人学习中只听闻过负载均衡集群。</p><ul><li><p>负载均衡集群（Load Balancing LB）</p><p>负载均衡集群为企业需求提供了更实用的系统。如名称所暗示的，该系统使负载可以在计算机集群中尽可能平均地分摊处理。该负载可能是需要均衡的应用程序处理负载或网络流量负载。这样的系统非常适合于运行同一组应用程序的大量用户。每个节点都可以处理一部分负载，并且可以在节点之间动态分配负载，以实现平衡。对于网络流量也是如此。通常，网络服务器应用程序接受了太多入网流量，以致无法迅速处理，这就需要将流量发送给在其它节点上运行的网络服务器应用。还可以根据每个节点上不同的可用资源或网络的特殊环境来进行优化。</p></li><li><p>高可用性集群（High Availability HA）</p><p>高可用性集群的出现是为了使集群的整体服务尽可能可用，以便考虑计算硬件和软件的易错性。如果高可用性集群中的主节点发生了故障，那么这段时间内将由次节点代替它。次节点通常是主节点的镜像，所以当它代替主节点时，它可以完全接管其身份，并且因此使系统环境对于用户是一致的。</p></li><li><p>高性能也叫科学集群（High Performance HP）</p><p>为集群开发并行编程应用程序，以解决复杂的科学问题。这是并行计算的基础，尽管它不使用专门的并行超级计算机，这种超级计算机内部由十至上万个独立处理器组成。但它却使用商业系统，如通过高速连接来链接的一组单处理器或双处理器 PC，并且在公共消息传递层上进行通信以运行并行应用程序。因此，您会常常听说又有一种便宜的 Linux 超级计算机问世了。但它实际是一个计算机集群，其处理能力与真的超级计算机相等，通常一套象样的集群配置开销要超过 $100,000。这对一般人来说似乎是太贵了，但与价值上百万美元的专用超级计算机相比还算是便宜的。</p></li></ul><h2 id="集群的实现"><a href="#集群的实现" class="headerlink" title="集群的实现"></a>集群的实现</h2><p>根据网络资料，已知的负载均衡集群可以通过硬件和软件两种方式实现，其他两种集群的实现方式不太清楚。</p><p>硬件方式：即通过专用的硬件（处理机）进行内容的分发调度，一般而言，硬件负载均衡在功能、性能上优于软件方式，不过成本昂贵。而且最重要的是该专用硬件是单点配置，即具有发生单点故障导致整个集群瘫痪的风险。</p><p>软件方式：软件负载均衡解决方案是指在一台或多台服务器相应的操作系统上安装一个或多个附加软件来实现负载均衡，它的优点是基于特定环境，配置简单，使用灵活，成本低廉，可以满足一般的负载均衡需求。</p><p>后面着重以 LVS（著名的开源项目）为例来说明 LVS 集群系统的实现。</p><h1 id="第二部分-LVS-集群系统"><a href="#第二部分-LVS-集群系统" class="headerlink" title="第二部分 LVS 集群系统"></a>第二部分 LVS 集群系统</h1><h2 id="项目诞生"><a href="#项目诞生" class="headerlink" title="项目诞生"></a>项目诞生</h2><blockquote><p>针对高可伸缩、高可用网络服务的需求，我们给出了基于 IP 层和基于内容请求分发的负载平衡调度解决方法，并在 Linux 内核中实现了这些方法，将一组服务器构成一个实现可伸缩的、高可用网络服务的虚拟服务器。</p><p>虚拟服务器的体系结构如图 2 所示，一组服务器通过高速的局域网或者地理分布的广域网相互连接，在它们的前端有一个负载调度器（Load Balancer）。负载调度器能无缝地将网络请求调度到真实服务器上，从而使得服务器集群的结构对客户是透明的，客户访问集群系统提供的网络服务就像访 问一台高性能、高可用的服务器一样。客户程序不受服务器集群的影响不需作任何修改。系统的伸缩性通过在服务机群中透明地加入和删除一个节点来达到，通过检 测节点或服务进程故障和正确地重置系统达到高可用性。由于我们的负载调度技术是在 Linux 内核中实现的，我们称之为 Linux 虚拟服务器（Linux Virtual Server）。</p><p><img src="https://eddyblog.oss-cn-shenzhen.aliyuncs.com/20190321os2.jpg" srcset="/img/loading.gif" alt="2"></p></blockquote><h2 id="LVS-集群的组成与特点"><a href="#LVS-集群的组成与特点" class="headerlink" title="LVS 集群的组成与特点"></a>LVS 集群的组成与特点</h2><p>Linux 虚拟服务器（Linux Virtual Server，LVS）是一个由章文嵩开发的一款自由软件，利用 LVS 可以实现高可用的、可伸缩的 Web、Mail、Cache 和 Media 等网络服务。并在此基础上开发支持庞大用户数的、可伸缩的、高可用的电子商务应用。LVS 自 1998 年发展到现在，已经变得比较成熟，目前广泛应用在各种网络服务和电子商务应用中。</p><p>LVS 具有很好的可伸缩性、可靠性和可管理性，通过 LVS 要实现的最终目标是：利用 Linux 操作系统和 LVS 集群软件实现一个高可用、高性能、低成本的服务器应用集群。</p><h3 id="LVS-集群的组成"><a href="#LVS-集群的组成" class="headerlink" title="LVS 集群的组成"></a>LVS 集群的组成</h3><p>利用 LVS 架设的服务器集群由 3 个部分组成：最前端的是负载均衡层（用 Load Balancer 表示），中间是服务器群组层（用 Server Array 表示），底端是数据共享存储层（用 Shared Storage 表示，这里应该还涉及一些分布式存储？的知识）。在用户看来，整个 LVS 集群系统的所有内部应用结构都是透明的，最终用户只是在使用一个虚拟服务器提供的高性能服务。</p><p>下面对 LVS 三个组成部分进行详细的介绍：</p><ul><li>负载均衡层：位于整个集群系统的最前端，由一台或多台负载均衡调度器（Director Server），只有一台调度器的时候我们也将其成为 Load Balancer，LVS 核心模块 IPVS 就安装在 Director Server 上，而 Director 的主要作用类似于一个路由器，它含有为完成 LVS 功能所设定的路由表，通过这些路由表把用户的请求分发给服务器群组层的应用服务器（Real Server），整个过程对访问集群的用户是透明的。同时，在 Director Server 上还要安装对 Real Server 的监控模块 Ldirectord，此模块用于监测各个 Real Server 服务的健康状况。在 Real Server 不可用时将其从 LVS 路由表中剔除，在恢复时重新加入（伸缩性的体现）。</li><li>服务器群组层：由一组实际运行应用服务的机器组成，Real Server 可以是 Web 服务器、Mail 服务器、FTP 服务器、DNS 服务器、视频服务器中的一个或多个，每个 Real Server 之间通过高速的 LAN 或分布在各地的 WAN 相连接。在实际的应用中，Director Server 也可以同时兼任 Real Server 的角色。</li><li>共享存储层：是为所有 Real Server 提供共享存储空间和内容一致性的存储区域，一般由磁盘阵列设备组成。为了提供内容的一致性，一般可以通过 NFS 网络文件系统共享数据，但是 NFS 在繁忙的业务系统中，性能并不是很好，此时可以采用集群文件系统，例如 Red Hat 的 GFS 文件系统，Oracle 提供的 OCFS2 文件系统等。</li></ul><p>从整个 LVS 结构可以看出，Dirctor Server 是整个 LVS 的核心。目前，用于 Director Server 的操作系统只有 Linux 和 FreeBSD，Linux 2.6 内核完全内置了 LVS 的各个模块，不用任何设置就可以支持 LVS 功能。</p><h3 id="LVS-集群的特点"><a href="#LVS-集群的特点" class="headerlink" title="LVS 集群的特点"></a>LVS 集群的特点</h3><ol><li><p>IP 负载均衡与负载调度算法</p><ol><li><p>IP 负载均衡技术</p><p>负载均衡技术有很多实现方案，有<strong>基于 DNS 域名轮流解析的方法</strong>，有<strong>基于客户端调度访问的方法</strong>，有<strong>基于应用层系统负载的调度方法</strong>，还有<strong>基于 IP 地址的调度方法</strong>。在这些负载调度算法中，执行效率最高的是 IP 负载均衡技术。</p><p>LVS 的 IP 负载均衡技术是通过 IPVS 模块来实现的。IPVS 是 LVS 集群系统的核心软件，它的主要作用是：安装在 Director Server 上，同时在 Director Server 上虚拟出一个 IP 地址，用户必须通过这个虚拟的 IP 地址访问服务器。这个虚拟 IP 一般称为 LVS 的 VIP，即 Virtual IP。访问的请求首先经过 VIP 到达负载调度器，然后由负载调度器从 Real Server 列表中选择一个服务器节点相应用户的请求。</p><p>在用户的请求到达负载调度器后，调度器如何请求发送到提供服务的 Real Server 节点，而 Real Server 节点如何返回数据给用户，是 IPVS 实现的重点技术。IPVS 实现负载均衡地方式有 3 种，分别是<strong>NAT</strong>、<strong>TUN</strong>和<strong>DR</strong>。（原书后面有详细介绍，这里就不多写了，有兴趣之后再了解）。</p></li><li><p>负载均衡调度算法</p><p>动态选择的实现，就是负载调度算法。IPVS 实现了 8 种负载调度算法。分别是，<strong>轮叫调度（Round Robin）</strong>、<strong>加权轮叫调度（Weighted Round Robin）</strong>、<strong>最少连接调度（Least Connections）</strong>、<strong>加权最少连接调度（Weighted Least Connections）</strong>、<strong>基于局部性的最少连接（Locality-Based Least Connections）</strong>、<strong>带复制的基于局部性最少连接（Locality-Based Least Connections with Replication）</strong>、<strong>目标地址散列（Destination Hashing）</strong>和<strong>源地址散列（Source Hashing）</strong>。</p><p>如果想要进一步了解，请登录<a href="http://zh.linuxvirtualserver.org" target="_blank" rel="noopener">LVS 中文站点</a>，查阅更详细的信息。</p></li></ol></li><li><p>高可用性</p><p>LVS 是一个基于内核级别的应用软件，因此具有很高的处理性能。由 LVS 构建的负载均衡集群系统具有优秀的处理能力，每个服务节点的故障不会影响整个系统的正常使用，又能够实现负载的合理均衡，使应用具有超高负荷的服务能力，可支持上百万个并发连接请求。</p></li><li><p>高可靠性</p><p>LVS 负载均衡集群软件已经在企业和学校中得到了很好的普及，国内外很多大型的、关键性的 Web 站点也都采用了 LVS 集群软件，所以它的可靠性在实践中得到了很好印证。有很多由 LVS 构成的负载均衡系统，运行很长时间，从未进行过重新启动。这些都说明了 LVS 的高稳定性和高可靠性。</p></li><li><p>使用环境</p><p>目前仅支持 Linux 和 FreeBSD 系统作为前端 Director Server，但是支持大多数的 TCP 和 UDP 协议。支持 TCP 协议的应用有：HTTP、HTTPS、FTP、SMTP、POP3、IMAP4 等等；支持 UDP 协议的应用有：DNS、NTP、ICP、视频和音频流播放协议等。</p><p>LVS 对 Real Server 的操作系统没有任何限制，Real Server 可运行在任何支持 TCP/IP 的操作系统上，包括 Linux，各种 UNIX（如 FreeBSD、Sun Solaris、HP Unix 等），Mac OS 和 Windows 等。</p></li><li><p>开源软件</p><p>LVS 集群软件是按 GPL（GNU Public License 许可证发行的自由软件，因此，使用者可以得到软件的源代码，并且可以根据自己的需要进行各种修改，但是修改必须以 GPL 方式发行。</p></li></ol><h1 id="第三部分-集群系统的配套应用"><a href="#第三部分-集群系统的配套应用" class="headerlink" title="第三部分 集群系统的配套应用"></a>第三部分 集群系统的配套应用</h1><h2 id="Heartbeat"><a href="#Heartbeat" class="headerlink" title="Heartbeat"></a>Heartbeat</h2><p>如果负载均衡层（Load Balancer）仅由一台 Director Server 来实现 VIP 与集群资源的调度，就会面临单点故障后整个集群系统瘫痪的危险。为了实现 LVS 负载均衡系统下的高可用性，我们可以使用一些常用的 HA 软件，实现“双机互备”。</p><p>heartbeat 使 Linux-HA 项目中的一个组件，也是目前开源 HA 项目中最成功的一个例子，它提供了所有 HA 软件需要的基本功能，检测集群中的系统服务，在集群的节点间转移共享 IP 地址的所有者等。自 1999 年开始到现在，heartbeat 在行业内得到了广泛应用，也发行了很多版本，最核心的包括两个部分，其最核心包括心跳监测部分和资源接管部分，心跳监测可以通过网络链路和串口进行，而且支持冗余链路，它们之间相互发送报文来告诉对方自己当前的状态，如果在指定的时间内未受到对方发送的报文，那么就认为对方失效，这时需启动资源接管模块来接管运 行在对方主机上的资源或者服务。</p><h2 id="IP-网络存储-iSCSI"><a href="#IP-网络存储-iSCSI" class="headerlink" title="IP 网络存储 iSCSI"></a>IP 网络存储 iSCSI</h2><p>主要介绍基于 IP SAN 的网络存储 iSCSI。iSCSI 技术以其低廉的构建成本和优秀的存储性能，博得了很多 CIO 和存储管理员的喜爱，目前陆续进入企业应用领域，推动了企业的存储环境向集中式转变。虽然，目前对于 iSCSI 应该在什么样的环境中使用还存在着诸多争议，但是 iSCSI 的前途使光明的，在未来的存储世界中，iSCSI 一定会占据重要的席位。</p><h3 id="存储概念的术语"><a href="#存储概念的术语" class="headerlink" title="存储概念的术语"></a>存储概念的术语</h3><p>在存储的世界里，有各种各样的名词和术语，常见的有 SCSI、FC、DAS、NAS、SAN 等。本节重点介绍与存储相关的术语和知识。</p><ol><li><p>SCSI 介绍</p><p>SCSI 是小型计算机系统接口（Small Computer System Interface）的简称，SCSI 作为输入/输出接口，主要用于硬盘、光盘、磁带机、扫描仪、打印机等设备。</p></li><li><p>FC 介绍</p><p>FC 是光纤通道（Fiber Channel）的简称，是一种适合于千兆数据传输的、成熟而安全的解决方案，与传统的 SCSI 技术相比，FC 提供更高的数据传输速率，更远的传输距离，更多的设备连接支持，更稳定的性能，更简易的安装。</p></li><li><p>DAS 介绍</p><p>DAS 是直联式存储（Directed-Attached Storage）的简称，是指将存储设备通过 SCSI 接口或光纤通道直接连接到一台计算机上，当服务器在地理上比较分散，很暗通过远程进行互连时，DAS 是比较好的解决方案。但是这种存储方式只能通过与之连接的主机进行访问，不能实现数据与其他主机的共享，同时，DAS 会占用服务器操作系统资源，例如 CPU 资源、IO 资源等，并且数据量越大，占用操作系统资源就越严重。</p></li><li><p>NAS 介绍</p><p>网络接入存储（Network-Attached Storage）简称 NAS，它通过网络交换机连接存储系统和服务器，建立专门用于数据存储的私有网络，用户通过 TCP/IP 协议访问数据，采用业界标准文件共享协议如 NFS、HTTP、CIFS 来实现基于文件级的数据共享。NAS 存储使文件共享访问变得更方便和快捷，并且能很容易地增加存储容量。通过企业化的文件服务器和存储技术相结合，NAS 为那些需要共享大量文件数据的企业提供了一个高效的、可靠的、高性价比的解决方案。但是 NAS 也有一定的局限性，它会受到网络带宽和网络拥堵的影响，在一定程度上限制了 NAS 的网络传输能力。</p></li><li><p>SAN 介绍</p><p>存储区域网络（Storage Area Network）简称 SAN，它是一种通过光纤交换机、光线路由器、光纤集线器等设备将磁盘阵列、磁带等存储设备与相关服务器连接起来的高速专用子网。</p><p>SAN 由三个部分组成，分别是连接设备（如路由器、光纤交换机和 Hub）、接口（如 SCSI、FC）、通信协议（如 IP 和 SCSI）。这三部分再加上存储设备和服务器就构成了一个 SAN 系统。SAN 提供了一个灵活的、高性能的和高扩展性的存储网络环境，它可以更加有效地传输海量地数据块。由于采用了光纤接口，因此 SAN 还具有更高的带宽，同时，SAN 也使统一管理和集中控制实现简化。现在 SAN 已经广泛应用于 ISP 和银行等，随着用户业务量增大，SAN 的应用前景将越来越光明。</p></li></ol><h3 id="iSCSI-的概念"><a href="#iSCSI-的概念" class="headerlink" title="iSCSI 的概念"></a>iSCSI 的概念</h3><p>iSCSI，即 internet SCSI，是 IETF 制定的一项标准，用于将 SCSI 数据块映射为以太网数据包。从根本上说，它是一种基于 IP Storage 理论的新型存储技术，该技术将存储行业广泛应用的 SCSI 接口技术 IP 网络技术相结合，可以在 IP 网络上构建 SAN。简单地说，iSCSI 就是在 IP 网络上运行 SCSI 协议的一种网络存储技术。iSCSI 最初由 Cisco 和 IBM 两家开发，并且得到了广大 IP 存储技术爱好者的大力支持，这几年迅速的发展壮大。</p><h3 id="FC-SAN-与-IP-SAN"><a href="#FC-SAN-与-IP-SAN" class="headerlink" title="FC SAN 与 IP SAN"></a>FC SAN 与 IP SAN</h3><p>在 iSCSI 技术出现后，通过 IP 技术搭建的存储网络也应运而生，SAN 技术也就出现了两种不同的实现方式，即 FC SAN 与 IP SAN。简单来说，以光纤搭建的存储网络就是 FC SAN，以 SCSI 技术搭建的存储网络叫做 IP SAN。</p><p>作为 SAN 的两种实现方式，他们各有优劣，下面从几个方面分别阐述。</p><ol><li>在数据传输方式上，FC SAN 与 IP SAN 都采用块协议方式来完成，这是他们的相同点。</li><li>在传输速度上，就目前传输速率而言，FC SAN（2Gbit/s）最快，iSCSI（1Gbit/s）次之。</li><li>在传输距离上，FC SAN 理论上可以达到 100 公里，而事实上，传输 50 公里过后，会出现瓶颈。而通过 IP 网络的 iSCSI 技术在理论上没有距离的限制，即 iSCSI 可以进行没有距离限制的数据传输。</li><li>在管理及维护成本上，架设 FC SAN 网络需要投入很多硬件成本吗，并且需要特定的工具软件进行操作管理，而 IP SAN 构建成本低廉，由于 iSCSI 是通过 IP 网络来传输数据和分配存储资源的，因此只要在现有的网络上进行管理和使用即可，这样就可以省下大笔的管理费用及培训成本。</li></ol><p>当然，iSCSI 的推广还存在着安全性、软硬件适配问题等，但是相信在未来的网络存储世界里，IP SAN 绝对会拥有一席之地。</p><h3 id="iSCSI-的组成"><a href="#iSCSI-的组成" class="headerlink" title="iSCSI 的组成"></a>iSCSI 的组成</h3><p>一个简单的 iSCSI 系统大致有以下部分组成：</p><ol><li>iSCSI Initiator 或者 iSCSI HBA</li><li>iSCSI Target</li><li>以太网交换机</li><li>一台或者多台服务器</li></ol><p>详细的软硬件设备介绍（Initiator 和 Target）以及 iSCSI 工作原理有兴趣再做进一步研究，在此不再叙述。</p>]]></content>
    
    
    <categories>
      
      <category>Computer Science</category>
      
      <category>操作系统</category>
      
    </categories>
    
    
    <tags>
      
      <tag>操作系统</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>PHP学习——Laravel框架入门</title>
    <link href="/post/d7435d20.html"/>
    <url>/post/d7435d20.html</url>
    
    <content type="html"><![CDATA[<h1 id="环境搭建"><a href="#环境搭建" class="headerlink" title="环境搭建"></a>环境搭建</h1><p>此处省略，后面补充</p><h1 id="Laravel教程微博实例"><a href="#Laravel教程微博实例" class="headerlink" title="Laravel教程微博实例"></a>Laravel教程微博实例</h1><h2 id="构建页面"><a href="#构建页面" class="headerlink" title="构建页面"></a>构建页面</h2><h2 id="样式美化"><a href="#样式美化" class="headerlink" title="样式美化"></a>样式美化</h2><pre><code class="hljs Bash">yarn install --no-bin-linksyarn add cross-env</code></pre><p>使用Boostrap组件进行前端样式美化</p><h3 id="Bootstrap再入门"><a href="#Bootstrap再入门" class="headerlink" title="Bootstrap再入门"></a>Bootstrap再入门</h3><p>上面代码将引入<code>public/css/app.css</code>样式文件。</p><p><code>header</code>, <code>nav</code> 是 HTML5 提供的一种语义化标签，其实际作用与 div 一致，语义化的标签能帮助机器更方便理解代码，使代码更简洁，有助于网站的 SEO 优化。我们在上面代码使用到一些如 <code>navbar</code>, <code>container</code> 等类名在 Bootstrap 中都拥有特殊含义。</p><h2 id="Laravel-前端工作流"><a href="#Laravel-前端工作流" class="headerlink" title="Laravel 前端工作流"></a>Laravel 前端工作流</h2><p>介绍<code>Sass</code>,<code>NPM</code>,<code>Yarn</code>,<code>Laravel Mix</code>来构成一套完整的前端工作流。</p><h3 id="SASS语法基础"><a href="#SASS语法基础" class="headerlink" title="SASS语法基础"></a>SASS语法基础</h3><ol><li><p>样式文件导入</p><p> Sass使用<code>@import</code> 来导入其它的样式文件从而实现样式嵌套。</p></li><li><p>变量</p><p> Sass允许加入自己的变量，所有的变量以<code>$</code>开头</p> <pre><code class="hljs css">$navbar-color: #3c3e42;.navbar-inverse &#123;    background-color: $navbar-color;&#125;</code></pre><p> 在编译成功后，变量会被替代为对应的值</p></li><li><p>嵌套</p><p> Sass允许选择器中相互嵌套以减少代码量</p></li><li><p>引用父选择器</p><p> 在Sass嵌套中使用<code>&amp;</code>对父选择器进行引用：</p> <pre><code class="hljs css">a &#123;    color: white;    &amp;:hover &#123;        color: blue;    &#125;&#125;</code></pre></li></ol><h3 id="NPM"><a href="#NPM" class="headerlink" title="NPM"></a>NPM</h3><p><code>NPM</code> 是Node.js 的包管理和任务管理工具，其强大的功能也是Node.js能够如此成功的因素之一。在使用NPM安装第三方模块（也可理解为扩展包）时，你需要在 <code>package.json</code> 中队需要安装的模块指定好名称和版本号。然后运行下面的命令进行安装：</p><pre><code class="hljs shell"><span class="hljs-meta">$</span><span class="bash"> npm install</span></code></pre><p>在学习教程中，出于安装速度考虑，我们使用更加现代化的 <code>Yarn</code> 来替代 <code>NPM</code> 的包管理功能。然而我们仍然会使用到 <code>NPM</code> 的任务管理功能，如命令 <code>npm run watch-poll</code>。</p><h3 id="Yarn"><a href="#Yarn" class="headerlink" title="Yarn"></a>Yarn</h3><p>Yarn 是 Facebook 在 2016 年 10 月开源的一个新的包管理器，用于替代现有的 NPM 客户端或者其他兼容 NPM 仓库的包管理工具。Yarn 在保留 NPM 原有工作流特性的基础上，使之变得更快、更安全、更可靠。在后面的项目开发中，我们统一使用 Yarn 来代替 NPM 进行安装包的管理。</p><p>我们可通过下面命令来安装当前项目的所有包：</p><pre><code class="hljs shell"><span class="hljs-meta">$</span><span class="bash"> yarn install</span></code></pre><a id="more"></a><h3 id="Laravel-Mix"><a href="#Laravel-Mix" class="headerlink" title="Laravel Mix"></a>Laravel Mix</h3><p>Laravel Mix 一款前端任务自动化管理工具，使用了工作流的模式对制定好的任务依次执行。Mix 提供了简洁流畅的 API，让你能够为你的 Laravel 应用定义 Webpack 编译任务。Mix 支持许多常见的 CSS 与 JavaScript 预处理器，通过简单的调用，你可以轻松地管理前端资源。我们可以在 webpack.mix.js 文件中制定一些如资源文件的编译、压缩等任务。Laravel 已默认为我们生成了 webpack.mix.js 文件，并集成了 <code>laravel-mix</code> 模块。</p><h2 id="浏览器缓存问题"><a href="#浏览器缓存问题" class="headerlink" title="浏览器缓存问题"></a>浏览器缓存问题</h2><h3 id="问题描述"><a href="#问题描述" class="headerlink" title="问题描述"></a>问题描述</h3><blockquote><p>现代化的浏览器，会对静态文件进行缓存，静态文件在本课程的范畴内，指的是 .css 、.js 后缀的文件。这是一个浏览器的优化功能，极大地加快了网页的加载速度，但是在我们日常开发和维护中，有时候会造成混淆。</p><p>开发时，你明明修改了样式，但是刷新浏览器却看不见变化，然后你就来回不断地修改你的样式文件，做各种测试，浏览器页面仍然一成不变。直到你重新刷新好多次，或者修改样式文件名称时，才恍然大悟，原来是浏览器缓存了。</p></blockquote><h3 id="解决方法"><a href="#解决方法" class="headerlink" title="解决方法"></a>解决方法</h3><p>Laravel Mix，增加哈希值，只要修改，哈希值改变，则客户端浏览器就需要重新加载文件。</p><p>对 <code>webpack.mix.js</code> 稍作修改</p><pre><code class="hljs js"><span class="hljs-keyword">const</span> mix = <span class="hljs-built_in">require</span>(<span class="hljs-string">'laravel-mix'</span>);mix.js(<span class="hljs-string">'resources/js/app.js'</span>, <span class="hljs-string">'public/js'</span>)   .sass(<span class="hljs-string">'resources/sass/app.scss'</span>, <span class="hljs-string">'public/css'</span>).version();</code></pre><h2 id="局部视图"><a href="#局部视图" class="headerlink" title="局部视图"></a>局部视图</h2><p>随着代码量增加，都存在默认视图中会变得太过臃肿，难以维护，所以最好将部分视图分离出来，成为单独得局部视图。</p><h3 id="头部和底部视图"><a href="#头部和底部视图" class="headerlink" title="头部和底部视图"></a>头部和底部视图</h3><p>首先，我们需要新建一个头部视图文件。</p><p>resources/views/layouts/_header.blade.php</p><pre><code class="hljs html"><span class="hljs-tag">&lt;<span class="hljs-name">nav</span> <span class="hljs-attr">class</span>=<span class="hljs-string">"navbar navbar-expand-lg navbar-dark bg-dark"</span>&gt;</span>  <span class="hljs-tag">&lt;<span class="hljs-name">div</span> <span class="hljs-attr">class</span>=<span class="hljs-string">"container "</span>&gt;</span>    <span class="hljs-tag">&lt;<span class="hljs-name">a</span> <span class="hljs-attr">class</span>=<span class="hljs-string">"navbar-brand"</span> <span class="hljs-attr">href</span>=<span class="hljs-string">"/"</span>&gt;</span>Weibo App<span class="hljs-tag">&lt;/<span class="hljs-name">a</span>&gt;</span>    <span class="hljs-tag">&lt;<span class="hljs-name">ul</span> <span class="hljs-attr">class</span>=<span class="hljs-string">"navbar-nav justify-content-end"</span>&gt;</span>      <span class="hljs-tag">&lt;<span class="hljs-name">li</span> <span class="hljs-attr">class</span>=<span class="hljs-string">"nav-item"</span>&gt;</span><span class="hljs-tag">&lt;<span class="hljs-name">a</span> <span class="hljs-attr">class</span>=<span class="hljs-string">"nav-link"</span> <span class="hljs-attr">href</span>=<span class="hljs-string">"/help"</span>&gt;</span>帮助<span class="hljs-tag">&lt;/<span class="hljs-name">a</span>&gt;</span><span class="hljs-tag">&lt;/<span class="hljs-name">li</span>&gt;</span>      <span class="hljs-tag">&lt;<span class="hljs-name">li</span> <span class="hljs-attr">class</span>=<span class="hljs-string">"nav-item"</span> &gt;</span><span class="hljs-tag">&lt;<span class="hljs-name">a</span> <span class="hljs-attr">class</span>=<span class="hljs-string">"nav-link"</span> <span class="hljs-attr">href</span>=<span class="hljs-string">"#"</span>&gt;</span>登录<span class="hljs-tag">&lt;/<span class="hljs-name">a</span>&gt;</span><span class="hljs-tag">&lt;/<span class="hljs-name">li</span>&gt;</span>    <span class="hljs-tag">&lt;/<span class="hljs-name">ul</span>&gt;</span>  <span class="hljs-tag">&lt;/<span class="hljs-name">div</span>&gt;</span><span class="hljs-tag">&lt;/<span class="hljs-name">nav</span>&gt;</span></code></pre><p>可以看到，我们在头部视图的文件名前面加了下划线 _，这样做是为了指定该视图文件为局部视图，为局部视图增加前缀下划线是『约定俗成』的做法，方便了其它人快速地理解该文件的实际作用。从这里开始，我们都会为局部文件添加下划线前缀。</p><p>现在让我们再来为应用创建一个底部视图，用于置放网站的一些基础信息。</p><p>resources/views/layouts/_footer.blade.php</p><pre><code class="hljs html"><span class="hljs-tag">&lt;<span class="hljs-name">footer</span> <span class="hljs-attr">class</span>=<span class="hljs-string">"footer"</span>&gt;</span>  <span class="hljs-tag">&lt;<span class="hljs-name">img</span> <span class="hljs-attr">class</span>=<span class="hljs-string">"brand-icon"</span> <span class="hljs-attr">src</span>=<span class="hljs-string">"https://iocaffcdn.phphub.org/uploads/sites/KDiyAbV0hj1ytHpRTOlVpucbLebonxeX.png"</span>&gt;</span>  <span class="hljs-tag">&lt;<span class="hljs-name">a</span> <span class="hljs-attr">href</span>=<span class="hljs-string">"https://learnku.com/laravel/courses"</span> <span class="hljs-attr">target</span>=<span class="hljs-string">_blank</span>&gt;</span>    刻意练习，每日精进  <span class="hljs-tag">&lt;/<span class="hljs-name">a</span>&gt;</span>  <span class="hljs-tag">&lt;<span class="hljs-name">div</span> <span class="hljs-attr">class</span>=<span class="hljs-string">"float-right"</span>&gt;</span>    <span class="hljs-tag">&lt;<span class="hljs-name">a</span> <span class="hljs-attr">href</span>=<span class="hljs-string">"/about"</span> &gt;</span>关于<span class="hljs-tag">&lt;/<span class="hljs-name">a</span>&gt;</span>  <span class="hljs-tag">&lt;/<span class="hljs-name">div</span>&gt;</span><span class="hljs-tag">&lt;/<span class="hljs-name">footer</span>&gt;</span></code></pre><h2 id="布局中的链接"><a href="#布局中的链接" class="headerlink" title="布局中的链接"></a>布局中的链接</h2><h3 id="Laravel中链接地址的写法"><a href="#Laravel中链接地址的写法" class="headerlink" title="Laravel中链接地址的写法"></a>Laravel中链接地址的写法</h3><p>较为常见的链接地址的写法</p><pre><code class="hljs html"><span class="hljs-tag">&lt;<span class="hljs-name">li</span>&gt;</span><span class="hljs-tag">&lt;<span class="hljs-name">a</span> <span class="hljs-attr">href</span>=<span class="hljs-string">"/help"</span>&gt;</span>帮助<span class="hljs-tag">&lt;/<span class="hljs-name">a</span>&gt;</span><span class="hljs-tag">&lt;/<span class="hljs-name">li</span>&gt;</span></code></pre><p>在Laravel中，我们可以这么写</p><pre><code class="hljs html"><span class="hljs-tag">&lt;<span class="hljs-name">li</span>&gt;</span><span class="hljs-tag">&lt;<span class="hljs-name">a</span> <span class="hljs-attr">href</span>=<span class="hljs-string">" route('help') "</span>&gt;</span>帮助<span class="hljs-tag">&lt;/<span class="hljs-name">a</span>&gt;</span><span class="hljs-tag">&lt;/<span class="hljs-name">li</span>&gt;</span></code></pre><p>大括号括起来的部分是在HTML中内嵌PHP的Blade语法标识符，表示包含在该区块内的代码都将用PHP来编译运行。<code>route()</code>方法由Laravel提供，传递一个具体的路由名称来生成完整的URL。</p><p>在 Laravel 中，我们可以通过在路由后面链式调用 name 方法来为路由指定名称：</p><pre><code class="hljs php">Route::get(<span class="hljs-string">'/help'</span>, <span class="hljs-string">'StaticPagesController@help'</span>)-&gt;name(<span class="hljs-string">'help'</span>);</code></pre><p>可以看到 <code>route(&#39;help&#39;)</code>为我们生成了完整的 URL 地址，这样当我们需要对生成的 URL 进行更改时，我们只需要改动路由文件即可，由此可见在实际开发中养成对路由的命名是一个好习惯，可以帮助我们节省很多工作量，另外也是 Laravel 项目开发的最佳实践。</p><p>均改为<code>href=&quot;route()&quot;</code>的形式</p><h2 id="静态页面"><a href="#静态页面" class="headerlink" title="静态页面"></a>静态页面</h2><p>在我们后面的教程中，将会为应用添加注册登录的功能，本节让我们先来完成用户注册功能的第一步：为用户注册功能创建基本的静态页面。</p><h3 id="注册路由"><a href="#注册路由" class="headerlink" title="注册路由"></a>注册路由</h3><p>当用户访问注册url时，进入我们的注册页面</p><p>修改（添加）路由</p><pre><code class="hljs php">Route::get(<span class="hljs-string">'/'</span>, <span class="hljs-string">'StaticPagesController@home'</span>)-&gt;name(<span class="hljs-string">'home'</span>);Route::get(<span class="hljs-string">'/help'</span>, <span class="hljs-string">'StaticPagesController@help'</span>)-&gt;name(<span class="hljs-string">'help'</span>);Route::get(<span class="hljs-string">'/about'</span>, <span class="hljs-string">'StaticPagesController@about'</span>)-&gt;name(<span class="hljs-string">'about'</span>);Route::get(<span class="hljs-string">'signup'</span>, <span class="hljs-string">'UsersController@create'</span>)-&gt;name(<span class="hljs-string">'signup'</span>);</code></pre><p>注册路由时，URI signup 和 /signup 从使用上来看，并无区别，Laravel 框架兼容这两种写法。</p><p>注意这里不在注册到<code>StaticPagesController</code>控制器上，因为不单是静态页面，会涉及和数据库的交互，所以围绕用户使用用户控制器来处理此逻辑。</p><h2 id="用户模型"><a href="#用户模型" class="headerlink" title="用户模型"></a>用户模型</h2><h3 id="MVC框架的M"><a href="#MVC框架的M" class="headerlink" title="MVC框架的M"></a>MVC框架的M</h3><p>M-Model（模型），构建一个基本的用户模型来实现用户数据的存储，并了解Laravel如何对模型对象进行增删查改等操作。后面我们还会在此用户模型上添加用户注册和登录的功能，并对用户进行权限认证，管理员具备用户的删除操作。再构建一套用户账号激活和密码找回系统。</p><h3 id="用户认证系统"><a href="#用户认证系统" class="headerlink" title="用户认证系统"></a>用户认证系统</h3><p>Laravel集成了一整套用户登录注册功能，并提供了一些方便的API，但是出于学习目的，我们会借助一些简单的API来独自开发一个完整的用户认证系统。</p><p>如果定制性不高，还是建议使用Laravel的默认提供的用户认证系统。</p><h3 id="Eloquent-ORM"><a href="#Eloquent-ORM" class="headerlink" title="Eloquent ORM"></a>Eloquent ORM</h3><p>在接下来几章要实现的用户注册功能需要用到数据库来进行数据存储，用于放置用户的基本信息。在这期间，还需要用到数据模型- Model，利用 Laravel 提供的 Eloquent ORM 跟数据库进行交互，实现用户数据的增删改查操作。Eloquent 提供了简洁优雅的 ActiveRecord 实现来跟数据库进行交互。Active Record 是一种领域模型模式，该模式由 Martin Fowler 在 2003 年出版的《企业应用架构模式》一书中进行了详细叙述并命名。其特点是一个模型类对应关系型数据库中的一个表，模型类的一个实例对应表中的一行记录。Active Record 最大优点是允许我们简单, 直观地操作数据层。</p><h3 id="数据库迁移"><a href="#数据库迁移" class="headerlink" title="数据库迁移"></a>数据库迁移</h3><p>Laravel中通过数据库迁移来管理数据库表结构，迁移就像数据库中的版本控制。</p><p>好处</p><ol><li>多人并行开发</li><li>代码版本管理</li><li>数据库版本控制：如：回滚重置更新</li><li>兼容多种数据库系统</li><li>部署方便</li></ol><h3 id="默认迁移文件"><a href="#默认迁移文件" class="headerlink" title="默认迁移文件"></a>默认迁移文件</h3><p>所有迁移文件统一放置在 <code>database/migrations</code> 文件夹里</p><p>我们看到Laravel已经默认创建好了两个迁移文件。</p><ul><li>database/migrations/2014_10_12_000000_create_users_table.php</li><li>database/migrations/2014_10_12_100000_create_password_resets_table.php</li></ul><p>加入时间戳避免多人开发时候的命名冲突。</p><h3 id="创建数据库表"><a href="#创建数据库表" class="headerlink" title="创建数据库表"></a>创建数据库表</h3><p>up方法里，通过调用 <code>Schema</code> 类的<code>create</code>方法来创建<code>users</code>表：</p><pre><code class="hljs php">Schema::create(<span class="hljs-string">'users'</span>, <span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-params">(Blueprint $table)</span> </span>&#123;    ...&#125;);</code></pre><p>两个参数</p><ul><li>参数1：表名称</li><li>参数2：Blueprint实例的必报（函数依赖关系必报）</li></ul><h3 id="定义数据表字段"><a href="#定义数据表字段" class="headerlink" title="定义数据表字段"></a>定义数据表字段</h3><p>CreateUsersTable 类中通过 Blueprint 的实例 $table 为 users 表创建所需的数据库字段。接下来让我们来详细讲解 Blueprint 实例 $table 的基本用法：</p><pre><code class="hljs php">$table-&gt;increments(<span class="hljs-string">'id'</span>);</code></pre><p>由 increments 方法创建了一个 integer 类型的自增长 id。</p><pre><code class="hljs php">$table-&gt;string(<span class="hljs-string">'name'</span>);</code></pre><p>由 string 方法创建了一个 name 字段，用于保存用户名称。</p><pre><code class="hljs php">$table-&gt;string(<span class="hljs-string">'email'</span>)-&gt;unique();</code></pre><p>由 string 方法创建了一个 email 字段，且在最后指定该字段的值为唯一值，用于保存用户邮箱。</p><pre><code class="hljs php">$table-&gt;timestamp(<span class="hljs-string">'email_verified_at'</span>)-&gt;nullable();</code></pre><p>Email 验证时间，空的话意味着用户还未验证邮箱。<code>nullable()</code>方法表示字段可空。</p><pre><code class="hljs php">$table-&gt;string(<span class="hljs-string">'password'</span>, <span class="hljs-number">60</span>);</code></pre><p>由 string 方法创建了一个 password 字段，且在 string 方法中指定保存的值最大长度为 60，用于保存用户密码。</p><pre><code class="hljs php">$table-&gt;rememberToken();</code></pre><p>由 rememberToken 方法为用户创建一个 remember_token 字段，用于保存『记住我』的相关信息。</p><pre><code class="hljs php">$table-&gt;timestamps();</code></pre><p>由 timestamps 方法创建了一个 created_at 和一个 updated_at 字段，分别用于保存用户的创建时间和更新时间。注意和前面email的timestap字段区分开。</p><h3 id="回滚迁移"><a href="#回滚迁移" class="headerlink" title="回滚迁移"></a>回滚迁移</h3><p>down 方法会在回滚命令发起时被调用，是 up 方法的逆向操作。在上面的代码中，up 创建了 users 表，那么这里将会通过调用 Schema 的 drop 方法来删除 users 表。</p><pre><code class="hljs php">Schema::dropIfExists(<span class="hljs-string">'users'</span>);</code></pre><h2 id="用户注册"><a href="#用户注册" class="headerlink" title="用户注册"></a>用户注册</h2><p>本章节为注册页添加一个注册表单</p><h3 id="隐式绑定"><a href="#隐式绑定" class="headerlink" title="隐式绑定"></a>隐式绑定</h3><p>由于我们使用了 <code>view(&#39;users.show&#39;, compact(&#39;user&#39;))</code> 将用户数据与视图进行绑定，因此在视图中可以直接使用 <code>$user</code> 来访问用户实例。</p><h2 id="会话管理"><a href="#会话管理" class="headerlink" title="会话管理"></a>会话管理</h2><p>由于 HTTP 协议是无状态的，所以 Laravel 提供了一种用于临时保存用户数据的方法 - 会话（Session），并附带支持多种会话后端驱动，可通过统一的 API 进行使用。</p><p>我们可以使用 session() 方法来访问会话实例。而当我们想存入一条缓存的数据，让它只在下一次的请求内有效时，则可以使用 flash 方法。flash 方法接收两个参数，第一个为会话的键，第二个为会话的值，我们可以通过下面这行代码的为会话赋值。</p><p>接下来的消息提示我们会用会话进行闪存，并分别为其设定好指定的键。<code>danger</code>, <code>warning</code>, <code>success</code>, <code>info</code> 这四个键名在 Bootstrap 分别具有不同样式展现效果，因此后面我们将使用这几个键名作为消息提示的专有设定。</p><h3 id="用户CRUD"><a href="#用户CRUD" class="headerlink" title="用户CRUD"></a>用户CRUD</h3><p>新增的 edit 动作主要做了以下几个操作：</p><p>利用了 Laravel 的『隐性路由模型绑定』功能，直接读取对应 ID 的用户实例 $user，未找到则报错；<br>将查找到的用户实例 $user 与编辑视图进行绑定；<br>在将用户数据与视图进行绑定之后，便可以在视图上通过 $user 来访问用户对象。接下来让我们接着完成用户编辑页面的构建。</p><p>编辑成功<br>现在的用户编辑功能还有两个地方需要优化：</p><ol><li><p>在每次更改个人资料的时候都输入完整的密码，才能更新其它信息，对于不想对密码进行更新的用户，这个过程会比较繁琐；</p></li><li><p>更新成功之后在页面上没有进行任何提示，而是直接跳转到用户的个人页面，用户体验非常不好；</p></li></ol>]]></content>
    
    
    <categories>
      
      <category>Computer Science</category>
      
      <category>PHP</category>
      
    </categories>
    
    
    <tags>
      
      <tag>PHP</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>数据挖掘学习——数据驱动比赛笔记</title>
    <link href="/post/53729461.html"/>
    <url>/post/53729461.html</url>
    
    <content type="html"><![CDATA[<h1 id="数据挖掘比赛简介"><a href="#数据挖掘比赛简介" class="headerlink" title="数据挖掘比赛简介"></a>数据挖掘比赛简介</h1><h1 id="主要任务"><a href="#主要任务" class="headerlink" title="主要任务"></a>主要任务</h1><p>对中国青少年科技创新比赛做统计分析</p><h2 id="分析目标"><a href="#分析目标" class="headerlink" title="分析目标"></a>分析目标</h2><ol><li>各省历年一、二等奖获奖情况比较</li><li>东、中、西部地区获奖情况比较</li><li>各省获奖最多的学校（集中度）</li><li>各省获奖最多的学校获学科类别比较</li><li>历年选题相似度比较</li><li>工程学项目选题变化趋势</li><li>获奖项目水平与学生知识匹配度</li><li>2009-2012（有保送）、2013-2014（高考加分）、2015-2018（自主招生（选题和获奖情况比较</li><li>三等奖与一等奖在选题上的差别</li></ol><h1 id="初步想法"><a href="#初步想法" class="headerlink" title="初步想法"></a>初步想法</h1><p>编程使用语言：<code>python</code></p><p>使用外部库：</p><ol><li><code>jieba</code>用于中文分词</li><li><code>numpy</code>,<code>matplotlib</code>用于科学计算与绘图</li><li><code>wordcloud</code>用于制作词云</li></ol><p>利用 python 相关外部库，通过 jieba 中文分词对限定范围内的中文文本进行分词，然后统计词频，</p><p>统计词频以后绘制词云图</p>]]></content>
    
    
    <categories>
      
      <category>Computer Science</category>
      
      <category>数据挖掘</category>
      
    </categories>
    
    
    <tags>
      
      <tag>数据挖掘</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>编译原理学习——《编译原理》龙书读书笔记（一）</title>
    <link href="/post/f8e4bc7f.html"/>
    <url>/post/f8e4bc7f.html</url>
    
    <content type="html"><![CDATA[<h1 id="第-1-章-引论"><a href="#第-1-章-引论" class="headerlink" title="第 1 章 引论"></a>第 1 章 引论</h1><p>目标语言翻译成一种能被计算机执行的形式，完成这一过程的软件系统称为<strong>编译器</strong>（compiler）。</p><p>本书介绍的是设计和实现编译器的方法。</p><p>本章内容</p><ol><li>介绍语言翻译器的不同形式</li><li>在高层次（概念层次）概述一个典型编译器的结构</li><li>讨论程序设计语言和硬件体系结构的发展趋势</li><li>编译器理论和计算机科学理论的关系的一些事实</li><li>给出一些在编译器设计领域以外的应用</li></ol><h2 id="语言处理器"><a href="#语言处理器" class="headerlink" title="语言处理器"></a>语言处理器</h2><p><strong>编译器</strong>，和<strong>解释器</strong>（Interpreter）是常见的两种形式。</p><p>主要区别：解释器并不同编译器一样将源程序编译成目标程序，而是对源语句（结合用户的输入）逐条解释执行。</p><p><strong>预处理器</strong>，除了编译器之外，创建一个可执行的目标程序还需要一些其他程序，比如将程序员写程序时划分的多个模块聚合在一起的任务，以及将称为<strong>宏</strong>（micro）展开成源语言格式的任务，有时就由预处理器完成。</p><h2 id="一个编译器的结构"><a href="#一个编译器的结构" class="headerlink" title="一个编译器的结构"></a>一个编译器的结构</h2><p>通过编译器，源程序映射到目标语言程序（语义上等价），映射过程大致分为<strong>分析</strong>和<strong>综合</strong>两部分。</p><ol><li><p>分析（analysis）</p><p>把源程序分解为多个组成要素，加上语法结构，创建中间表示。</p><p>检测是否符合源程序语言语义并给出用户相应提示，同时收集源程序的一些信息，存放在一个称为<strong>符号表</strong>（symbol table）的数据结构中，然后一并传送给综合部分。</p></li><li><p>综合（synthesis）</p><p>根据分析得到的中间表示和符号表中的信息来构造用户期待的目标程序。</p></li></ol><p>常称分析部分为编译器的<strong>前端</strong>（front end），而综合部份为编译器的<strong>后端</strong>（back end）。</p><p>编译过程可以拆成一组<strong>过程</strong>（phase）</p><h3 id="词法分析"><a href="#词法分析" class="headerlink" title="词法分析"></a>词法分析</h3><p><strong>词法分析</strong>（lexical analysis）或称为<strong>扫描</strong>（scanning）。读入源程序字符流，拆成词素序列，词法单元和一个符号表。</p><h3 id="语法分析"><a href="#语法分析" class="headerlink" title="语法分析"></a>语法分析</h3><p><strong>语法分析</strong>（syntax analysis）或称为<strong>解析</strong>（parsing）根据词法单元的第一个分量创造一个树形的中间表示，一种常用的表示方法时<strong>语法树</strong>（syntax tree）。</p><h3 id="语义分析"><a href="#语义分析" class="headerlink" title="语义分析"></a>语义分析</h3><p><strong>语义分析器</strong>（sermantic analyzer）使用语法树和符号表中的信息来检查源程序是否和语言定义的语义一致。同时收集类型信息，在随后的中间代码生成过程中使用。</p><p>一个重要部分时<strong>类型检查</strong>（type checking），同时实现（如果允许的话）自动类型转换。</p><h3 id="中间代码生成"><a href="#中间代码生成" class="headerlink" title="中间代码生成"></a>中间代码生成</h3>]]></content>
    
    
    <categories>
      
      <category>Computer Science</category>
      
      <category>编译原理</category>
      
    </categories>
    
    
    <tags>
      
      <tag>编译原理</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>编译原理学习——基本概念梳理</title>
    <link href="/post/e8bc7157.html"/>
    <url>/post/e8bc7157.html</url>
    
    <content type="html"><![CDATA[<h1 id="正式上课前注意点梳理"><a href="#正式上课前注意点梳理" class="headerlink" title="正式上课前注意点梳理"></a>正式上课前注意点梳理</h1><h2 id="关于编译原理学习"><a href="#关于编译原理学习" class="headerlink" title="关于编译原理学习"></a>关于编译原理学习</h2><p>编译本身是一个超级算法，其中分成两大部分：理论和技术。</p><p>编译原理的学习不同于离散数学，离散数学的各个部分是相对而言分离的，各部分没有直接的前后因果关系，但是编译原理作为一个“算法”，是一个整体，<strong>前后贯通和呼应</strong>，因此，在学习编译原理的过程中，必须把前面的基础学懂了才能应对后面的内容。</p><p>根据教材，《编译原理》第一章到第五章侧重于理论，第六章和第七章是理论与技术结合，再后面的章节主要是计数方法介绍。</p><p>《编译原理》学习的要点在<strong>形式语言</strong>和<strong>自动机</strong>，所有的一切最终都是归结到自动机的理论和应用。</p><p>巩固好前驱课程，如数据结构、高级语言程序设计、汇编语言等专业课程有助于编译原理课程的学习。</p><h2 id="关于数学的客观来源与表现形式"><a href="#关于数学的客观来源与表现形式" class="headerlink" title="关于数学的客观来源与表现形式"></a>关于数学的客观来源与表现形式</h2><p>编译原理学习中提到的形式语言与自动机。</p><p><strong>形式语言</strong>和<strong>自动机</strong>，是从两个角度、使用两种建模方式对相同客观对象描述的两个“等价”的数学模型，各有其在不同的环境下的用途。</p><p>数学的形式是主观的，但来源是客观的，都是对客观世界的抽象。主观性表现在抽象的形态是“随心所欲”的，同一个对象可被抽象为不同的数学表示方式和运算方式，但其根本性是客观的，离开了物化的或具体化意义的数学是不存在的，如果存在，也是毫无价值的。</p><a id="more"></a><h2 id="初识“自动机”"><a href="#初识“自动机”" class="headerlink" title="初识“自动机”"></a>初识“自动机”</h2><p>话放在前面，不是严格意义上的自动机，而是为了方便初学者理解的“简化版自动机”</p><p>为了方便理解，先行介绍“简化”的自动机，我们当下可以认为自动机是由$n$个状态组成的状态集合，$S= \{ s_1,s_2, \cdots ,s_n \}$和$m$个字符组成的输入字符集合，$\Sigma = \{ a_1,a_2, \cdots , a_m \}$构成的二元组，即$自动机 = <s,\sigma>$</s,\sigma></p><p>但是真正的自动机不是二元组，而是五元组。作为初学者，可以先从理解这个二元组形式的来入门，更容易从本质上理解什么是自动机。</p><p>核查正确性，很容易联想到构造一个“字典”一样的存在，但是不可能用一个标准的字典来穷尽所有正确的单词（单词可能是无穷的）。那么自动机就起到了这个包含了无穷个单词的字典的作用（核查）。</p><p>要完整地弄懂自动机概念，需要四个方面的基础知识：<strong>集合</strong>，<strong>笛卡尔乘积</strong>，<strong>关系</strong>，<strong>函数</strong>。</p><p>当然，掌握了自动机理论，离使用这套理论构造程序语言的编译程序还有一段距离，即理论到应用的距离。应用辨识能力，需要慢慢学习。</p><h2 id="所谓“语言”"><a href="#所谓“语言”" class="headerlink" title="所谓“语言”"></a>所谓“语言”</h2><p>科学和数学的定义，一是要普世、二是要精确。</p><p>回顾“关系”，关系的数学定义是：<strong>A 集合到 B 集合的笛卡尔乘积的子集</strong>。</p><p>那么，<strong>语言</strong>的数学定义是什么？</p><p>语言的数学定义：<strong>语言就是字符串的集合</strong>。</p><p>广义的“语言”，科学和数学方式定义的语言意义重大。最大直接好处是：这些概念所表的东西可以被以数学方式进行处理，比如，列出方程并求解方程，列出逻辑公式并推理，等等。</p><p>既然语言是字符串的集合，我们可以进一步用一个公式产生某些字符串的集合，遗憾的是，有些字符串的集合是找不到公式来产生的。言下之意，有些肯定是可以用公式产生的。我们编译原理关心的是这些可以由数学公式产生的字符串的集合（即语言）</p><p>形式语言的数学定义：<strong>可以由数学公式产生的语言就叫做形式语言</strong>。</p><p><img src="https://eddyblog.oss-cn-shenzhen.aliyuncs.com/20190210language1.png" srcset="/img/loading.gif" alt="1.png"></p><p>人类的自然语言是不可以用数学公式表达出来的，否则，自然语言识别就是 100%准确并且 100%听懂人类语言的机器人也能被制造出来。</p><p>尽管人类语言无法用数学公式统一表达，但是程学设计语言是可以的。实际上，是先数学公式做好，再产生出对应的程序设计语言。</p><p>这个“数学公式”<strong>叫做</strong>文法或<strong>语法</strong>。</p><p>例：G 文法形式是：$S \rightarrow aS|b$ ,其中$S$叫做非终止符，在这里也做开始符号，整个公式叫做产生式集合。</p><p>其推出的语言 $L = \{ ab,aab,aaab, \cdots \}$。</p><p>用数学公式（文法）表示的语言可以很方便的被处理，因为这个语言的特征都通过文法集中体现了，我们只要针对文法进行处理，就等价于对整个语言进行了处理。通过掌控有线而驾驭了无限。</p><p>《编译原理》可以告诉你如何分析程序设计语言的文法来驾驭这个语言。</p><p>人类语言的变化多端和本身造句的模糊性以及其本身不断地发展变化（包括规则本身的变化），使不可能被一个或一组数学公式（形式语法）完全表达。</p><p>程序设计语言不是实践的结果，而是先规定了数学公式，然后再要求用数学公式的法则来写程序。</p><p>语言是字符串的集合，所以语言就会有子集的概念，其实，我们也可以将人类语言中的一些子集用形式语法表达出来，从而实现自动化。比如语音售票机等等。</p><p>经典名句：“买一张济南到长沙的火车票”，和“我要独自一人乘着钢铁巨龙回到梦开始的地方、湘江之滨的湖南省会”，人类能理解意思相同，不过呢，售票机恐怕就不行了。</p><h2 id="再谈“形式语言的文法”和“自动机”的关系"><a href="#再谈“形式语言的文法”和“自动机”的关系" class="headerlink" title="再谈“形式语言的文法”和“自动机”的关系"></a>再谈“形式语言的文法”和“自动机”的关系</h2><p><strong>任何一个语言的文法都有一个等价的自动机</strong>，反之亦然。也就是说：文法和自动机本质上就是同一个东西，或者说是同一个东西的不同数学形式（在前面已经提到过对同一客观存在的不同刻画）。</p><p>而刻画的事物，实际上就是形式语言。</p><p>形式语言和自动机本质上是一个东西的不同数学表示，因此，再很多需要区别的情况下，无论是使用“文法”、“语法”、还是“自动机”，都没有区别，其混合使用的时候我们更应理解它们指的是同一事物（形式语言）。</p><h2 id="文法分类问题"><a href="#文法分类问题" class="headerlink" title="文法分类问题"></a>文法分类问题</h2><p>文法的分类是个需要专门花大量时间来讲述的事情，《计算理论》中由四分之一到三分之一的内容实际上实在讲述文法的分类，可见，这不是一个几句话就能说清楚的问题（文法分类的专业深度很深）。</p><p>词法是关于单词的构成方法，单词是程序语言中最简单的字符串，比如，用户取得变量名称，但是要将一个个单词连成更长的字符串，法则就会难度大很多，显然不单单是检查单词那么简单，这个时候得文法就叫做“句法”（在我们学习的课程中，习惯句法叫做语法）</p><p>教材的编写也符合从易到难的原则，第三章是词法，第四第五章是句法。</p><blockquote><p>词法，难度低</p><p>句法，难度高</p><p>它们都是文法</p></blockquote><p>但是，需要提醒的是：从形式语言的角度看，单词和句子本质上是一个东西，毫无区别（都是字符串），只是相对长短不同而已。</p><p>专门针对单词的自动机（文法）肯定是文法中最简单的一种，或者说是一个完整语言中的一部分，我们把这部分专门描述单词组成规则的部分叫做“词法”。</p><p>For example，C 语言的单词拼写是否正确就是靠 C 语言的词法（自动机）来判定的，把源程序输入自动机，自动机将逐一检查单词，如果有错误就会报警，指出错误。如果全部正确，那就输入这些单词，以备后面使用。</p><p>当然，只检查单词拼写规范是远远不够的，所以 C 语言词法（自动机）仅仅是其中的一部分，还得有检测句法的（人为分类）如 if else 这样的结构是否合法。</p><h2 id="再说语言"><a href="#再说语言" class="headerlink" title="再说语言"></a>再说语言</h2><p>再次强调核心概念：<strong>语言是字符串的集合</strong>。</p><p>关于问题及其求解的思考，其实也跟“语言”有密切关系。</p><p>（下面基本上原封不动搬运徐老师的讲解）</p><p>首先给你一个论断：<strong>凡是能用字符串表达出来的问题就都是一个语言</strong>。很吃惊是吧？按照这个说法，世界上的问题就没有不是语言了（因为你总要用字符串的集合，即语言，把问题表述出来）。</p><p>确实是这样，有了“语言是字符串的集合”这个定义后，世界上的任何问题都是一种语言，对于任何问题的解决，本质上就是看这个问题（即语言）是否能够用数学公式（文法）表达出来，更专业的说法是，世界上所有的问题都是语言，<strong>问题是否可解等价于该语言是否可计算</strong>，“可计算”的基础就是这个问题（即语言）是否可以用形式文法表示出来，如果能用形式语法表示出来，也就等价于存在一个自动机，它可以接受这个问题，即解决这个问题。</p><p>比如，我要你计算一个题目，题目是这样出的：“请计算 2+3=”，这个问题不就是个字符串吗，答案就是自动机（假设存在）输入问题字符串后的最终状态。</p><p>总结：<strong>世界上所有的问题都是语言</strong></p><p>那么，把世界上所有的问题都归结为语言，这有什么意义呢？</p><p>意义很大，要理解这个问题一定要系统学习《计算理论》才能知道。</p><p>举一个语言被广义化后的意义，这是我们计算机学科特别关心的意义。计算机学科的基本问题之一：<strong>什么问题是计算机可以解决的</strong>，大致等价的问题是：<strong>什么问题是计算机不能解决的</strong></p><p>答案是：<strong>凡是能够用形式语法（自动机）表达的问题都是可以用计算机解决的，否则就是不可解的。</strong></p><p>计算机不是万能的，有些问题（即语言）已经被证明是不能用形式文法表达的，对这些语言（即问题 ），你就不要试图用计算机去解决它们了。</p><p>如果理论上不可解，那就彻底不可解。理论上可解，现实中也不一定可解。用逻辑术语来表达，理论上可解是现实可解的必要条件，但不是充分条件。</p><h2 id="语义分析和中间代码生成"><a href="#语义分析和中间代码生成" class="headerlink" title="语义分析和中间代码生成"></a>语义分析和中间代码生成</h2><h3 id="为什么需要语义分析"><a href="#为什么需要语义分析" class="headerlink" title="为什么需要语义分析"></a>为什么需要语义分析</h3><p>诸如类型匹配等检查仅通过词法和语法是难以实现的，类型不匹配这种语义分析要扫描前后文字，这就是“语义分析”也叫作“上下文相关分析”的原因。</p><p>按照分治的思想，设计出中间代码，介于源代码和目标代码（汇编语言代码或者机器码）的一种代码方式。</p><h3 id="中间代码形式举例"><a href="#中间代码形式举例" class="headerlink" title="中间代码形式举例"></a>中间代码形式举例</h3><p><code>逆波兰式</code></p><p>逆波兰表达式也叫做后缀表达式</p><p>要是中缀表达式复杂了，可能就不容易凭经验和概念很快写成等价的后缀式，中缀表达式转换为逆波兰式是可以用程序来完成的，这样，无论多么复杂的中缀表达式，机器都能迅速地转换为后缀式。具体的算法微信上很难写，你们先记住有这么个算法，上课时就有准备了。</p><p><code>三地址码形式</code></p><p>三地址码形式的主要特点是：一个等式中只能出现三个地址（变量）。</p><p>三地址码的具体写法又可以有三元式、四元式等等，这些形式中，一个表达式中只会出现三个地址。</p>]]></content>
    
    
    <categories>
      
      <category>Computer Science</category>
      
      <category>编译原理</category>
      
    </categories>
    
    
    <tags>
      
      <tag>编译原理</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>数学建模——美赛2019E题</title>
    <link href="/post/4c60a529.html"/>
    <url>/post/4c60a529.html</url>
    
    <content type="html"><![CDATA[<h1 id="第一天"><a href="#第一天" class="headerlink" title="第一天"></a>第一天</h1><p>上午定题目 E 题，环境相关</p><p>关键词：环境退化，环境成本，生态经济，适应性模型</p><p>下午开始着手搜集相关论文资料，包括但不限于，生态服务功能价值评估模型，水源森林生态资源衡量标准</p><p>建模思路，层次分析法，搜集大量数据获<strong>可能影响生态成本指标体系的层次结构</strong></p><p>预想的指标：</p><p>评估指标 1 8 24 60 112<br>层次分析法 AHP 113</p><h1 id="第二天"><a href="#第二天" class="headerlink" title="第二天"></a>第二天</h1><p>整理下思路，层次分析法（照着 ppt 又回顾了下）</p><p>搜集数据？不需要细致工程的数据，但是要能衡量大中小型项目的污染标准。</p>]]></content>
    
    
    <categories>
      
      <category>Mathematics</category>
      
      <category>数学建模</category>
      
    </categories>
    
    
    <tags>
      
      <tag>数学建模</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>《無印良品的改革》读书笔记</title>
    <link href="/post/4ab96b49.html"/>
    <url>/post/4ab96b49.html</url>
    
    <content type="html"><![CDATA[<h1 id="序言-新“無印神话”的开端"><a href="#序言-新“無印神话”的开端" class="headerlink" title="序言 新“無印神话”的开端"></a>序言 新“無印神话”的开端</h1><p>無印良品在日本的三大直营店：有乐盯店、京都的 Platz 店与打扮的难波店，其中有乐盯店是一家主要负责向社会大众宣传無印良品的店铺，几乎汇聚了全部经营的商品。</p><p>笔者采访一位职场女性，问是否经常来，得到的答复是这样的。</p><blockquote><p>P005 “是的。这些日杂物品只是看看就令人心情愉快，平时换季的时候我也会来这里买衣服。实际上我也买优衣库的衣服，但是由于细节设计上没有特点，所以只是作为内搭穿在里面。与此相比，無印的没一件服装都很有风格，所以我很喜欢。在我还上高中的时候就经常来购物了，但不知从何时起，無印的商品和店铺失去了特色，觉得失望之后有段时间就没有来过了。但是，从三四年前無印又变的非常吸引人，因此我很高兴又来购物”</p></blockquote><p>诞生既是荣耀，不知为何跌落，却又重回巅峰。这本书大概讲述的，就是讲这样一个世界品牌的故事。</p><p>理念、感性与科学的有机结合。在生活理念中看到科学量化的务实，却绝不会倒向向性价比等纯粹科学量化的指标，而是站立在理念这感性的一方。</p><h1 id="第-1-章-無印良品的诞生及其迅速发展"><a href="#第-1-章-無印良品的诞生及其迅速发展" class="headerlink" title="第 1 章 無印良品的诞生及其迅速发展"></a>第 1 章 無印良品的诞生及其迅速发展</h1><p>西友创立無印良品，本就是走在“品牌热的对立面”，一句“因为合理，所以便宜”广告，打破了人们购物的思维定势，从而引导人们重新审视品牌、价格、品质三者之间的关系。好称无品牌（No Brand）的無印良品，恰恰是宣传的这样一种不愿拘泥于民族品牌而诞生的 New Brand。</p><p>广告海报上写着如下内容</p><blockquote><p>P010 “不依赖品牌和包装来选择商品。这不仅与热情的生活方式相结合，也是一种重要的态度。”</p></blockquote><p>無印良品品牌诞生的原动力：做质量不低于民族品牌但不为品牌做无用功（无谓支出）的优质产品。</p><p>無印良品的商品开发及生产的基本理念：选择优质原材料、不断改良生产工序、商品采用简约包装。</p><h2 id="生活习气与生活美学的艰难选择"><a href="#生活习气与生活美学的艰难选择" class="headerlink" title="生活习气与生活美学的艰难选择"></a>生活习气与生活美学的艰难选择</h2><p>二者实现的途径都要求回归生活本质，但是内涵却大不相同。</p><blockquote><p>P027 “但是，要正确划分‘生活习气’和‘生活美学’之间的界线是极其苦难的。所以，商品上架前的最后检查都交给了富于感性的设计师团队。正是装也判断商品合适与否的顾问团队，在無印良品的发展过程中发挥了巨大的作用。”</p></blockquote><h2 id="無印良品从西友集团的独立"><a href="#無印良品从西友集团的独立" class="headerlink" title="無印良品从西友集团的独立"></a>無印良品从西友集团的独立</h2><p>木内任负责人时期，对無印良品不能掌握自己商品的众多核心信息（诸如完整的销售记录，开发成本等）而对品牌深感忧虑，在他的眼里，無印良品错过了成为子公司的最佳时节，现在却成为了西友的门面工程，这与品牌的初衷越走越远。</p><blockquote><p>P013 “也就是说，‘西武集团式特色’一直将品牌形象摆在前面，这样一来，無印良品的经营就变成了‘看不见的经营’，这正是木内先生深感危机的原因。”</p></blockquote><a id="more"></a><h1 id="第-2-章-从一帆风顺到遭遇挫折"><a href="#第-2-章-从一帆风顺到遭遇挫折" class="headerlink" title="第 2 章 从一帆风顺到遭遇挫折"></a>第 2 章 从一帆风顺到遭遇挫折</h1><p>从無印从西武集团独立出来，便掀起了一股“無印热”，开店邀请纷至沓来。1993 年，無印良品首次开设了拥有大型卖场的直营店——無印良品 LaLaPort（位于千叶县船桥市），1995 年，無印良品在店铺正式公开售股，在获得充足资金后，無印良品又快马加鞭地开设了更多店铺，从 100 坪，300 坪，500 坪最后到 1000 坪。</p><p>然而新开店铺收益不及预期，往往是开设与关闭同时进行，而且随着店铺体量的扩张，为了填满店铺的货架商品种类数，不得不加快新产品的企划。这种“赶工”式的做法为后来的品牌危机埋下了伏笔。</p><p>扩大战略背后暗藏的“失控”以及顾客是否也远离了無印良品，两朵阴霾让这个品牌的发展道路的头上。</p><h1 id="第-3-章-致使無印良品走向凋零的八大原因"><a href="#第-3-章-致使無印良品走向凋零的八大原因" class="headerlink" title="第 3 章 致使無印良品走向凋零的八大原因"></a>第 3 章 致使無印良品走向凋零的八大原因</h1><p>高层人事调整，由松井忠三接任有贺馨担任良品计划的社长。</p><p>一家家店铺的走访，一点点打开店长们的心结让他们敢于张口说话，在不懈的努力下，新社长总算对品牌危机的原因有了一个更清晰的认识。</p><blockquote><p>P059 “对于良品计划业绩突然下滑的原因，一共可以总结出八条。当然，这些原因之间都是相互关联、相互影响的，正因为各个要素相互重叠，才给無印良品的业绩带来了严重的问题。”</p></blockquote><h2 id="原因-1-成功带来的自满情绪"><a href="#原因-1-成功带来的自满情绪" class="headerlink" title="原因 1 成功带来的自满情绪"></a>原因 1 成功带来的自满情绪</h2><blockquote><p>P059 “全体职工在经历無印良品的成功之后，在不知不觉中变得自满起来。”</p></blockquote><p>前期发展一帆风顺，在泡沫经济中逆势增长，售股募集资金，上市过程也是顺风顺水，加之不断增开的大型直营店，无论怎样说都取得了一定的瞩目成果。上述的种种，居安思危精神的懈怠，笔者这么描述的。</p><blockquote><p>P059 “此时，無印良品的员工认为不需要向其他公司学习，只要维持现状即可，由此，大家便失去了谦逊的态度和用心做事的优秀品质。与此相对，在这期间，埋头研究和学习的竞争对手，在不久之后便开始崭露头角。”</p></blockquote><h2 id="原因-2-大企业通病的腐蚀"><a href="#原因-2-大企业通病的腐蚀" class="headerlink" title="原因 2 大企业通病的腐蚀"></a>原因 2 大企业通病的腐蚀</h2><p>内部结构过于僵化，纵向延申过长，不够扁平化带来的最直接的影响就是运行速度的相对迟缓，对市场的讯息反应不够快。</p><p>过去很多优秀的传统变成了“例行公事”，在無印良品里，最典型的就是对于开店事宜的讨论和决议。</p><blockquote><p>P060 “在决定开设门店之时，公司应该重视对该场地条件最为熟知的开发部长的意见，随后才是经营的最高责任人社长做判断。但此时無印良品的实际情况是，几乎每个项目都采取董事会举手表决制，根据少数服从多数的原则决定是否开店。回忆当时的光景，松井说道：‘那时的状态就好比众愚政治一样。’”</p></blockquote><h2 id="原因-3-忘记根本，只顾眼前"><a href="#原因-3-忘记根本，只顾眼前" class="headerlink" title="原因 3 忘记根本，只顾眼前"></a>原因 3 忘记根本，只顾眼前</h2><p>采取的诸多应急措施，有违品牌设立之初的形象，为了应急而应急，却忽视了长远利益的考量。丢失了原则。比如服饰方面一改商品原本只有黑白和自然色的基调，加入其他颜色，这些无视“原则”的商品也被摆上了無印良品的货架。</p><h2 id="原因-4-品牌自身的弱化"><a href="#原因-4-品牌自身的弱化" class="headerlink" title="原因 4 品牌自身的弱化"></a>原因 4 品牌自身的弱化</h2><p>没有专攻品牌的建设，初期品牌优势很大，但随着市场竞争的增强，不再进行品牌理念的打磨最终结果将是被竞争对手淘汰。</p><blockquote><p>P062 “但是时代在进步，消费者的信息收集能力也在飞速提高。同时，其他竞争对手的商品生产也提高到了可以与無印良品相抗衡的水准。在这种情况下，自己十多年前便再未打造锤炼的品牌也必然无法应对市场的巨大变化。”</p></blockquote><p>品牌理念过于强烈对于继续锤炼品牌价值也提高了难度，负责打造品牌的组织结构变得很弱，無印良品内部根本就不存在这样的部门，同时拥有的个人理念都停留在大脑中，不能实现理念的广泛传播，或者作为企业资产实现共享。</p><blockquote><p>P063 “总而言之，个人所拥有的知识和技术无法作为部门及企业的资产共享 ，更无法累积。因此，打造品牌的部门缺失为以后业绩下滑埋下了重大的祸根。”</p></blockquote><h2 id="原因-5-店铺开发战略的失败"><a href="#原因-5-店铺开发战略的失败" class="headerlink" title="原因 5 店铺开发战略的失败"></a>原因 5 店铺开发战略的失败</h2><p>店铺规模逐步增长最终过于庞大，而且太过急于开店。在扩充商品生产和完善供给体制之前，無印良品优先做的是扩大店铺面积。</p><p>这种模式在中小型规模（低于 300 坪）的店铺还未见问题，但是到达 500 坪、1000 坪，涉及到产品的企划开发，就显得很吃力了。</p><p>开店规模不合适，新产品的企划开发难以跟随开店速度，新店开设“众愚政治”状态导致的开店不够谨慎，都划归为店铺开发战略的失败。</p><h2 id="原因-6-社长新旧更替"><a href="#原因-6-社长新旧更替" class="headerlink" title="原因 6 社长新旧更替"></a>原因 6 社长新旧更替</h2><p>良品计划的“创始人”，或者为这家公司注入灵魂的关键人物木内政雄社长回到西友总部工作，也时無印良品走下坡路不得不考虑的一个因素。</p><blockquote><p>P066 “因为在创业阶段，由社长决定应该采取何种战略来经营公司是最为重要的。但是，过了创业期转入下一发展阶段时，领导者身上所必须具备的是能切实地实行经营战略地调动能力及使公司内部抱成一团地能力”</p></blockquote><p>领导者需要有不同于常人地能力，无论公司出于什么时期。</p><blockquote><p>P066 “从创始人手里接过管理权地领导行事必须谨慎，并且一定要有组织能力。为了使企业能够不断发展，建立完备的组织体系和创造相应的公司氛围是非常重要的。而無印良品在以上条件都未具备的时候，公司就脱离了创始人的指导和运作。”</p></blockquote><h2 id="原因-7-对专于创造的初衷产生了摇摆"><a href="#原因-7-对专于创造的初衷产生了摇摆" class="headerlink" title="原因 7 对专于创造的初衷产生了摇摆"></a>原因 7 对专于创造的初衷产生了摇摆</h2><p>“优秀的平均化”策略本是無印良品立足的根本，但是店面扩增，销售压力的增大，“卖掉就好了”思维也逐渐侵蚀了产品本身。而且，时代在变，年轻一代对著名设计者如数家珍的时候，無印良品的商品开始走向腐朽。</p><h2 id="原因-8-优衣库及大创等劲敌的出现"><a href="#原因-8-优衣库及大创等劲敌的出现" class="headerlink" title="原因 8 优衣库及大创等劲敌的出现"></a>原因 8 优衣库及大创等劲敌的出现</h2><p>外部原因——竞争对手的强势崛起。百元店对小物品市场的攻占，优衣库连续三个季度畅销夸张一点说是将所有同行企业（服装部门）推进了水深火热中，以及似鸟公司（NITORI）以家具为中心与無印良品相抗衡。</p><h1 id="第-4-章-改革从服饰开始"><a href="#第-4-章-改革从服饰开始" class="headerlink" title="第 4 章 改革从服饰开始"></a>第 4 章 改革从服饰开始</h1><p>先是一扫堆积如山的存货，改变过量生产模式，提升整体企划更新的速度，维持上架货品的新鲜度以及正价销售率，同时海外店铺也进行存货清扫、“止血”。</p><h2 id="“可视化、计算、行动”"><a href="#“可视化、计算、行动”" class="headerlink" title="“可视化、计算、行动”"></a>“可视化、计算、行动”</h2><p>生产过程的信息不够公开透明，基本上仅存在少数人脑海中（营销总监）。</p><blockquote><p>P085 “于是，在 2002 年，以三零商社的三位负责人为中心，無印良品开始实施经营改革工程。首先公司推行的是改善业务流程，以求能够让公司员工清晰地看到商品生产的过程。其次，召集良品计划女士服装、男士服装等各个领域地经理和营销总监以及总代理，为这些人创造探讨如何改善业务地机会。到了现在，这种习惯也被延续了下来，服饰杂货部每周都召开项目会议。”</p></blockquote><p>单品的原价销售率、折扣销售以及剩余货品的相关数据都被一一记录下来，以这些数据为基础，無印良品提高了计划生产的精确度，从而进行了业务改善。</p><p>在销售情况可视化基础上，掌握商品畅销和滞销情况（無印良品 SABC 等级分析），结合订单业务，降低错失机会以及库存损失的风险。</p><p>改良后的商品周期，分类如图</p><div class="table-container"><table><thead><tr><th style="text-align:left">名称</th><th style="text-align:left">销售时间</th><th style="text-align:left">备注</th></tr></thead><tbody><tr><td style="text-align:left">YF（全年使用款）</td><td style="text-align:left">全年</td><td style="text-align:left">在 20 世纪 90 年代占全部商品的一半</td></tr><tr><td style="text-align:left">SB（季度基本款）</td><td style="text-align:left">26 周</td><td style="text-align:left">每半年更新一次</td></tr><tr><td style="text-align:left">ST（季节流行款）</td><td style="text-align:left">10 周左右</td><td style="text-align:left">目前女装占 80%以上</td></tr></tbody></table></div><p>由过去無印良品认为的“一直摆放在卖场里就能获得安心”，颇为重视 YF 款到现在结合顾客对“卖场变得无趣”等建议做出的种种改变，质朴与安心中也要透露出改变、心意与诚意。</p><blockquote><p>P092 “生活用品还可以因为顾客的喜好保持不变，但服装与此不同，如果一成不变就难免让人感到厌倦。另外，即使不改变基本款的服装，也应该在服装的方向感上做出一些变化以适应潮流。于是無印良品决定先设计出基本款服装，然后组织一个能够把握方向感的团队。”</p></blockquote><p>与山本耀司公司合作，山本耀司公司发挥其创造力，把握产品方向感，而無印良品则将其理念注入其中，并负责其全程的销售。</p><blockquote><p>P98 “以‘文化’和‘感性’为主题发展起来的良品计划，转而以数据及标准值，即‘数值’为基础构筑起最合适的生产、销售组织。”</p></blockquote><h1 id="第-5-章-商品生产方式的进步"><a href="#第-5-章-商品生产方式的进步" class="headerlink" title="第 5 章 商品生产方式的进步"></a>第 5 章 商品生产方式的进步</h1><p>观察法的革新，从造方消费者的住宅来捕捉新的需求。全球·無印，与世界顶级设计师联合，匿名设计，将个人设计的概念融入企业的理念。从世界各地获取新的灵感，创造新产品。</p><p>重建总部与店铺的信赖关系，关注过去忽略的企划速率，以及开发效率的问题，整体提升店铺商品的质量。</p><h1 id="第-6-章-实施新的开店暂略"><a href="#第-6-章-实施新的开店暂略" class="headerlink" title="第 6 章 实施新的开店暂略"></a>第 6 章 实施新的开店暂略</h1><p>从岛村那里学来的，整理出规范化的“开店标准手册”。这样，经验的可视化、标准化，让新手也能按照“無印”式要求去勘察一块商圈是否适合开店。</p><h2 id="开店空间的计算"><a href="#开店空间的计算" class="headerlink" title="开店空间的计算"></a>开店空间的计算</h2><blockquote><p>P122 “统计出每个商圈的零售业销售额后，乘以無印良品的市场占有率，如此便可以算出無印良品在各都市商圈能够确保的市场占有额。然后用上述结果减去现有店铺的销售额。然后，用上述结果减去店铺现有销售额，就饿能够推算出来尚未确保的占有率，即开店空间。”</p></blockquote><script type="math/tex; mode=display">销售额空间 =  \sum_i 店铺i销售额 \times 市场占有率  - 现有店铺销售额</script><p>通过 SABCD 准则对开店水平进行评估，评估参数包括：<strong>市场、商业设施、店铺环境</strong>三大方面以及和周围竞争环境的综合考量。每一个大方面又细分成几个细致的指标，甚至人口的收入差距，标准楼梯高低都考虑在内。</p><p>無印良品从过去的实际成绩中，渐渐积累了这些选择开店地点的智慧。</p><h2 id="开店讨论会与日后的主要战略"><a href="#开店讨论会与日后的主要战略" class="headerlink" title="开店讨论会与日后的主要战略"></a>开店讨论会与日后的主要战略</h2><p>以及对于新店开设的讨论会，听取了岛村集团时任社长的建议，不是喋喋不休的说明，而是针对开店手册（规范标准）进行必要的说明，然后销售总部部长和开发部长负责提出更加具体和更具实质性的问题。</p><p>公司进行了整体调整后，德江先生列举了三个今后开店的重点策略：</p><ol><li><p>扩大店铺的面积。</p><p>但不是无限扩张，将 200 坪定义为标准型店铺，为了强化生活用品部，逐步发展 250 到 300 坪的卖场。</p></li><li><p>推进 500 坪店铺的开发</p><p>目的是增加家电、自行车等生活用品的摆放空间，用来和似鸟等品牌竞争。</p></li><li><p>挑战地方的小商业圈市场</p><p>建立起能够在小商业圈内运营的成本构造，定位可行的开店环境。</p></li></ol><h2 id="海外情况"><a href="#海外情况" class="headerlink" title="海外情况"></a>海外情况</h2><p>欧洲市场则是通过雇佣当地设计师重新设计符合当地需求的服装样式，几番更改后，海外服装设计步入正轨，扭曲为盈。通过加盟许可（Licenced Store）的方式扩大市场占有率。</p><p>中国市场，在与冒牌無印店的官司中获胜（MUJI 当时出书时还未），已经说明了其在东亚这个广大市场的热度。</p><p>美国市场</p><blockquote><p>P143 “2004 年 10 月，無印良品在纽约现代艺术博物馆（The Museum of Mordern Art 简称 MOMA）的零售业部门——“设计门店”的 53 街开设了店铺。由于顾客的反映良好，無印良品的卖场面积也比当初开业时变得更宽敞了。”</p></blockquote><h1 id="第-7-章-大幅度压缩成本的“30-委员会”"><a href="#第-7-章-大幅度压缩成本的“30-委员会”" class="headerlink" title="第 7 章 大幅度压缩成本的“30%委员会”"></a>第 7 章 大幅度压缩成本的“30%委员会”</h1><blockquote><p>P147 “为了进一步提高竞争力，松井忠三社长确定下一步的改革重点就是削减销售管理费（销售费用和一般管理费用）2005 年 2 月，松井在公司内设置了直属社长的‘30%委员会’（升级后的‘30%项目’）。”</p></blockquote><p>30%委员会设定了多个改善项目，包含：</p><ol><li>店铺内作业</li><li>物流</li><li>总部业务</li><li>直接贸易</li><li>店铺租金</li><li>保安与菜场管理</li><li>人工费</li></ol><p>监察室对于不必要的重复流程进行简化，同时对同一监察人执行的监察项目进行复用，并重新审视检查项目的覆盖范围。</p><blockquote><p>P150 “还有，顾客的预付款、返还款以及遗失的财务等，無印良品都会对此进行一一登记后存放在保险箱里。但是，把这些现金的进出归入检查项目、本身既不自然，也成了一种浪费。如果有顾客把财务遗失在店里，只需要立即送到附近的警察局就可以了。”</p></blockquote><p>此外，还有重新合理规划店铺内店员的工作流程，减少不必要的行动浪费，减少标签等等措施。</p><h2 id="無印良品的经费结构目标"><a href="#無印良品的经费结构目标" class="headerlink" title="無印良品的经费结构目标"></a>無印良品的经费结构目标</h2><blockquote><p>P155 “各综合超市的销售管理费比例一般在 27%左右（2006 年度），连锁超市也有不少企业在 24%左右。被良品计划视为加盟店运营榜样的岛村集团只有 21.5%（2007 年 2 月决算期期末实际数据），与之相比，良品计划的 31.5%与其相差了 10 个百分点。”</p></blockquote><p>这些百分比都是销售额的百分比，嗯这个是常识。</p><h1 id="第-8-章-改变卖场员工的工作"><a href="#第-8-章-改变卖场员工的工作" class="headerlink" title="第 8 章 改变卖场员工的工作"></a>第 8 章 改变卖场员工的工作</h1><p>一份“店铺工作指南”只有 16 页，浓缩了开店中种种问题，给店长合理分配员工工作提供了可靠依据。</p><blockquote><p>P172 “如此制定出来的‘店铺工作指南’，其内容网罗了员工从开始上班到关闭店铺、离开店铺为止的所有业务项目。为了便于临时工理解，指南内海使用了彩色图解，为了使员工更容易把握住要点，标题一般都使用简介、易于理解的表达方式，如某一章节的标题为‘什么是实现商品上架的高效化？’”</p></blockquote><p>考虑到了临时工，而且都是通过简介、直观的方式展现出来，可以说整个店铺工作指南也是無印良品理念一脉相承的产出，即避免一切不必要的浪费。</p><p>比如，指南中规定收银台的工作主要由两类员工负责：一是主要负责收银的员工，二是辅助收银的员工。这两类员工分别为‘100%收银负责人’和‘50%收银负责人’。另外，指南中还配有插图解释员工如何根据顾客流动数量来应对收银工作。</p><p>根据 SABCD 等级划分的商品，也在指南中给~出了不同的整理拜访策略：<strong>S 级和 A 级商品一天上架三次，整理两次，而 C 级和 D 级商品则各一次。</strong></p><h2 id="地方诞生的“畅销商品搜索队”"><a href="#地方诞生的“畅销商品搜索队”" class="headerlink" title="地方诞生的“畅销商品搜索队”"></a>地方诞生的“畅销商品搜索队”</h2><p>精确到检查店长们是不是精确了解自己家店面的情况，销售量排名前五的商品，以及对畅销商品摆放位置的检查，摆放方式是否恰当等细节。这就是精确到每一个销售单位的最细致的监督。</p><blockquote><p>P177 “另外，对于业绩特别低迷的店铺，田中等三人则每天早晚一次进行训练，并且训练时间长达半年之久。早上三人对店长作出指示后，当天晚上则再次来到此店确认其执行情况。由于三人每天都去视察，因此不仅对店长，而且对员工的工作状况都能细致地把握，最后还是看到了店铺的小小进步。每当发现进步的时候，田中等人就会表达出来，以此激发员工的工作积极性。”</p></blockquote><p>也正是因为这种“简单粗暴”方式的有效（其有效性很大程度和日本地区人们的工作态度有关），所以总部发现这一方法后将其推向全国。</p><h2 id="“一品入魂”、“天下一品”、“幸运单品”"><a href="#“一品入魂”、“天下一品”、“幸运单品”" class="headerlink" title="“一品入魂”、“天下一品”、“幸运单品”"></a>“一品入魂”、“天下一品”、“幸运单品”</h2><p>都属于营销手段，设定某一目标商品，然后设定能力上可以达到但是之前都为达到的，根据其覆盖范围可以分为店铺型、区域型的。</p><p>带着自信去推销，并依照成绩对其嘉奖，这种方法很有效果。</p><blockquote><p>P184 “系统和人心之间有很多相反的地方，但如果将这些词置换成‘数值’和‘感性’的话，就能与良品计划所开创的平衡经营息息相关。只要公司具备完善的组织结构继续支持销售员工的积极性，那么相信卖场的意识改革就会不断顺利向前推进。”</p></blockquote><h1 id="尾章-良品计划的未来与今后的课题"><a href="#尾章-良品计划的未来与今后的课题" class="headerlink" title="尾章 良品计划的未来与今后的课题"></a>尾章 良品计划的未来与今后的课题</h1><h2 id="無印便利店的可能性"><a href="#無印便利店的可能性" class="headerlink" title="無印便利店的可能性"></a>無印便利店的可能性</h2><p>根据市场分析，通过大型卖场销售無印的产品早晚会达到开店以及销售额的天花板，所以良品计划将目标瞄准了日客流量更大，分布小但覆盖更为全面的便利店。</p><blockquote><p>P188 “而通过与便利店合作，無印良品便多了一个向消费者传达商品信息的据点。便利店和专卖店的顾客之间还是有很大区别的，特别是无印良品的顾客有‘执着’的一面，商品能够进入更多消费者的视野中是具有重大意义的。”</p></blockquote><h2 id="重启食品部门"><a href="#重启食品部门" class="headerlink" title="重启食品部门"></a>重启食品部门</h2><p>無印良品创业之初，食品部门曾作为基础部门之一，但是随后的发展却不及其他部门，一大原因是顾客构成的固化。</p><blockquote><p>P195 “可能是由于过度锤炼商品的品质和感性，反而导致粉丝层受到限制。”</p></blockquote><p>所以放低顾客的受众面，从而增大無印理念影响的消费者的范围，是进后無印良品的主要计划之一。</p><blockquote><p>P196 “無印良品所应该追求的是商品所具有的吸引力，维持品牌形象，或者更高的目标。”</p></blockquote><h2 id="利用电视广告"><a href="#利用电视广告" class="headerlink" title="利用电视广告"></a>利用电视广告</h2><p>从过去基本不采用外媒的态度转化为每年举行一次企业主题的发布会，無印良品的转变是明显的，同时也是必须的（扩大顾客层）。</p><p>03 年的“無印良品的未来”，04 年的“無印良品之家”，05 年的主题则是“茶室和無印良品”，具有强烈主题感的发布会也是迈入新发展时期后，無印良品不停向外界传递的信息：無印良品已经不只是简洁朴素。</p><h2 id="收购家居公司"><a href="#收购家居公司" class="headerlink" title="收购家居公司"></a>收购家居公司</h2><p>IDEE 作为無印良品分支业务的拓展，仍然贯彻“坚实的外表，可变化的内部，并且能够根据生活方式自由地改变房间地布置”的理念，但与之前無印良品自己的家具产品不同的是，IDEE 风格更加现代一些，</p><p>无印良品官方也是这样定义的：</p><blockquote><p><strong>IDÉE</strong>：为空间增光添彩、赋予趣味。</p><p><strong>无印良品</strong>：以极度简约为魅力。</p><p><strong>IDÉE+无印良品</strong>：二者相得益彰，为生活的各个场景提供令人喜悦的组合。</p></blockquote>]]></content>
    
    
    <categories>
      
      <category>Life</category>
      
      <category>阅读</category>
      
    </categories>
    
    
    <tags>
      
      <tag>阅读</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>请你振作下去</title>
    <link href="/post/703409c5.html"/>
    <url>/post/703409c5.html</url>
    
    <content type="html"><![CDATA[<ul><li>不要再这样下去了</li><li>请你自己振作起来</li></ul>]]></content>
    
    
    <categories>
      
      <category>Life</category>
      
      <category>随笔</category>
      
    </categories>
    
    
    <tags>
      
      <tag>随笔</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>算法与数据结构学习——数论专题</title>
    <link href="/post/22b5b237.html"/>
    <url>/post/22b5b237.html</url>
    
    <content type="html"><![CDATA[<h1 id="数论专题复习"><a href="#数论专题复习" class="headerlink" title="数论专题复习"></a>数论专题复习</h1><p>前一部分来源于网络Wannafly Winter Camp冬令营</p><p>Day1 数论专题 Tangjz</p><h2 id="整除理论"><a href="#整除理论" class="headerlink" title="整除理论"></a>整除理论</h2><p>约数（因数）和倍数的定义。</p><p>以及：整除关系的传递性，约数的倍数的线性组合仍为倍数，整除关系为偏序关系反对称推出相等。</p><p>模意义下容易忽略0的问题。</p><p>质数和合数的定义：<br>对于$\forall n \in Z$，如果$\exists_{k \in Z, k \neq1, k \neq n} k \mid n$ 则$n$ 为合数，否则为质数</p><p>一些性质</p><p>若 $n \in Z^{+}$，则$min_{k \mid n} k \le \sqrt{n}$</p><p>对于$\forall n \in Z^{+}$，存在唯一的指数分解$n = \prod_{i=1}^{n}p_i^{e_i}$，这里$p_i$互不相同</p><p>令$\pi(n)$表示不超过$n$的质数个数，有$\pi(n)=\Theta(\frac{n}{\ln{n}})$</p><p>给出n可以知道比n小质数个数的渐近界</p><p>例：2017CCPC合肥网络赛<br>人从S,S+1,S+2,S+3…S+n-<br>作为1,2,3,4,5,6….n</p><p>贪心结论：n&gt;S的部分 都会按j=i座（这时候最优）。然后根据质数密度判断是否有两个质数，然后暴力匹配??</p><p>继续整除理论</p><h3 id="公约数"><a href="#公约数" class="headerlink" title="公约数"></a>公约数</h3><p>对于 $x_1 , x_2 , \cdots , x_n \in Z$ ，且 $\forall_{i=1,2,\cdots,n} d\mid X_i$，则称 $d$ 为它们的公约数</p><p>当$x_1,x_2,\cdots,x_n$不全为零，存在最大的公约数，称为$\gcd(x_1,x_2,\cdots,x_n)$</p><p>当$\gcd(x_1,x_2,\cdots,x_n) = 1$，称$x_1,x_2,\cdots,x_n$互质（互素），注意这里说是整体互质而不是说两两互质。是个大坑。</p><p>$\gcd(a,b) = \gcd(a,b-a) = \gcd(a,b \mod a)$</p><p>欧几里得算法：辗转相除</p><p>时间复杂度分析：$O(\log a+ \log b)$</p><h3 id="公倍数"><a href="#公倍数" class="headerlink" title="公倍数"></a>公倍数</h3><h2 id="同余理论"><a href="#同余理论" class="headerlink" title="同余理论"></a>同余理论</h2><h2 id="不定方程"><a href="#不定方程" class="headerlink" title="不定方程"></a>不定方程</h2><p>之前有课件</p><h2 id="有理逼近"><a href="#有理逼近" class="headerlink" title="有理逼近"></a>有理逼近</h2><p>数论是整数方面的研究，有些地方将无理数用无穷级数+有理数表示。</p><h2 id="数论函数"><a href="#数论函数" class="headerlink" title="数论函数"></a>数论函数</h2><p>使用迪利克雷卷积（暑假课程）进行推导</p>]]></content>
    
    
    <categories>
      
      <category>Computer Science</category>
      
      <category>算法与数据结构</category>
      
    </categories>
    
    
    <tags>
      
      <tag>算法与数据结构</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>校园导航系统CampusNavigation（C++实现）</title>
    <link href="/post/f7b33ddd.html"/>
    <url>/post/f7b33ddd.html</url>
    
    <content type="html"><![CDATA[<h1 id="课程设计选题及要求"><a href="#课程设计选题及要求" class="headerlink" title="课程设计选题及要求"></a>课程设计选题及要求</h1><h2 id="选题-6：校园导航系统"><a href="#选题-6：校园导航系统" class="headerlink" title="选题 6：校园导航系统"></a>选题 6：校园导航系统</h2><p>设计一个校园导航系统，为学校来访者提供各种信息查询服务，方便查找学校主要单位、校园景点之间最短距离，并能及时对该图进行更新，地点信息包括名称、代号、相关介绍等，及两个地点之间有直接路径的距离</p><h2 id="基本功能与技术要求"><a href="#基本功能与技术要求" class="headerlink" title="基本功能与技术要求"></a>基本功能与技术要求</h2><ol><li>数据文件管理功能：创建新文件、打开文件、保存文件。</li><li>计算与统计功能，完成记录中相关数据的统计；<ol><li>能够打开已存在的数据表文件，计算任意两个地点之间的最短路径的长度及途经地点。</li><li>提供来访者从出发地到目的地的路线统计，以图示界面输出。</li></ol></li><li>记录管理功能：记录的管理采用链表、数组等实现。<ol><li>输入／添加/插入记录，并保存到数据文件中。</li><li>查询、显示记录，根据用户要求按所给地点查询单位或景点信息，以及到地点的问路情况等。</li><li>修改记录：能够打开已存在的数据表文件，并对确定的任意记录进行修改，在修改过程中，应显示记录信息，给出确认提示，并对更新的记录信息进行文件保存。</li><li>删除记录：能够打开已存在的数据表文件，可以删除数据表中的任一记录，要求具备逻辑删除（具有恢复功能）和物理删除功能，并对新的数据表信息进行文件保存。</li></ol></li></ol><h1 id="设计思路"><a href="#设计思路" class="headerlink" title="设计思路"></a>设计思路</h1><ol><li><p>整体模式以及主要涉及的模块<br>整体设计采用 MVC 模式，及数据的储存处理与表现分离。使用 QT 框架提供基础的图形界面操作，整体分为三个模块，<code>CNView</code>前端部分负责数据的显示，<code>CNModel</code>数据的储存预处理。</p></li><li><p>模块功能的划分以及类的初步设计</p><ol><li><code>CNView</code> 前端部分<br>主要结合 QT 框架，界面展示，地点展示，路径展示，以及提供对应的 GUI 工具实现文本的录入</li><li><code>CNModel</code> 后端部分</li></ol></li></ol><h2 id="功能设计和模块划分"><a href="#功能设计和模块划分" class="headerlink" title="功能设计和模块划分"></a>功能设计和模块划分</h2><p>本次课程设计额</p><h2 id="C-父类指针操作子类新函数的方式"><a href="#C-父类指针操作子类新函数的方式" class="headerlink" title="C++父类指针操作子类新函数的方式"></a>C++父类指针操作子类新函数的方式</h2><p>父类指针无法直接调用子类的新函数，需要转换为子类的指针后方可调用。</p><p>C++编译器在编译的时候是做静态类型分析。也就是说，你的父类指针是否真的指向一个子类类型，编译器并不会做这个假设。所以你用父类指针去调用子类的函数是无法被识别的。这里提供一种不安全和一种安全的转换方式可以实现该功能：<br>　　假设我们有父类和子类的定义如下：</p><pre><code class="hljs C++"><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Base</span>&#123;</span><span class="hljs-keyword">public</span>:    <span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-keyword">virtual</span> <span class="hljs-title">Func</span><span class="hljs-params">()</span>    </span>&#123;        <span class="hljs-built_in">cout</span> &lt;&lt; <span class="hljs-string">"Base\n"</span>;    &#125;&#125;;<span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Derived</span> :</span> <span class="hljs-keyword">public</span> Base&#123;<span class="hljs-keyword">public</span>:    <span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">Func</span><span class="hljs-params">()</span>    </span>&#123;        <span class="hljs-built_in">cout</span> &lt;&lt; <span class="hljs-string">"Derived\n"</span>;    &#125;    <span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">NewFunc</span><span class="hljs-params">()</span>    </span>&#123;        <span class="hljs-built_in">cout</span> &lt;&lt; <span class="hljs-string">"New func\n"</span>;    &#125;&#125;;</code></pre><ol><li>强制转换（不安全）</li></ol><pre><code class="hljs C++">Base* b = <span class="hljs-keyword">new</span> Derived();b-&gt;Func();<span class="hljs-comment">// 不安全的转换</span>Derived* d = (Derived*)b;d-&gt;NewFunc();</code></pre><p>这里之所以说不安全是因为转换的时候无法得知是否转换成功。编译器强制把 d 当成 Derived 类型去使用。比如说 b 本来是真的指向 Base 而不是 Derived 类型那么强制转换后调用 Derived 的 NewFunc 可能会导致程序崩溃。</p><p>2.动态转换，dynamic_cast（安全）</p><pre><code class="hljs C++">Base* b = <span class="hljs-keyword">new</span> Derived();b-&gt;Func(); <span class="hljs-comment">// 安全转换</span> Derived* d = <span class="hljs-keyword">dynamic_cast</span>&lt;Derived*&gt;(b); <span class="hljs-keyword">if</span> (d != <span class="hljs-literal">NULL</span>)&#123;    d-&gt;NewFunc();&#125;</code></pre><p>dynamic_cast 是在运行时去做转换而非编译时，所以它可以给出是否转换成功的信息。如果转换不成功则返回 NULL。所以可以判断转换结果是否为 NULL 来决定是否能使用该指针不会导致程序崩溃</p><p><img src="http://baike.baidu.com/link？url=MFk9AusANTH86IWBNVk-2zzztggrvbnlpW8T1MsT8aCUhtIv7SWBxgCa6qryivPJLkgdcJz2ULBl2QCzK8CK6a" srcset="/img/loading.gif" alt="dynamic_cast参考"></p><h1 id="第一天进度记录"><a href="#第一天进度记录" class="headerlink" title="第一天进度记录"></a>第一天进度记录</h1><ol><li>完成后端 1/2（除去文件读写）</li><li>string index 放着先不实现，所有都先按照鼠标事件和 xy 坐标来写</li><li>明早补充边的增加和删减 注意边增添的时候算直线距离</li><li>普通点的增加和删减</li></ol><h1 id="第-X-天进度记录"><a href="#第-X-天进度记录" class="headerlink" title="第 X 天进度记录"></a>第 X 天进度记录</h1><p>就是说如果槽的命名是这样的话：</p><pre><code class="hljs C++"><span class="hljs-keyword">void</span> on_&lt;widget name&gt;_&lt;signal name&gt;(&lt;signal parameters&gt;);</code></pre><p>就会自动将<code>widget name</code>中的信号<code>signal name</code>和这个槽<code>void on_&lt;widget name&gt;_&lt;signal name&gt;(&lt;signal parameters&gt;)</code>链接起来。</p><p>这是 QT 不需要 connect 语句就可以自动链接信号和槽的机制！</p><h1 id="绘图相关"><a href="#绘图相关" class="headerlink" title="绘图相关"></a>绘图相关</h1><p>当发生一下情况时会产生绘制事件并调用 paintEvent()函数:</p><ol><li><p>在窗口部件第一次显示时，系统会自动产生一个绘图事件，从而强制绘制这个窗口部件。</p></li><li><p>当重新调整窗口部件的大小时，系统也会产生一个绘制事件。</p></li><li><p>当窗口部件被其他窗口部件遮挡，然后又再次显示出来的时候，就会对那些隐藏的区域产生一个绘制事件。</p></li></ol><p>同时可以调用 QWidget::update()或者 QWidget::repaint()来强制产生一个绘制事件。二者的区别是:</p><p>repaint()函数会强制产生一个即时的重绘事件,而 update()函数只是在 Qt 下一次处理事件时才调用一次绘制事件。</p><p>如果多次调用 update(),Qt 会把连续多次的绘制事件压缩成一个单一的绘制事件，这样可避免闪烁现象。</p><p><strong>使用 repaint()</strong></p>]]></content>
    
    
    <categories>
      
      <category>Computer Science</category>
      
      <category>C++</category>
      
    </categories>
    
    
    <tags>
      
      <tag>C++</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>Git学习——《精通Git》笔记（一）</title>
    <link href="/post/b8ca3dfa.html"/>
    <url>/post/b8ca3dfa.html</url>
    
    <content type="html"><![CDATA[<h1 id="第-1-章-入门"><a href="#第-1-章-入门" class="headerlink" title="第 1 章 入门"></a>第 1 章 入门</h1><h2 id="关于版本控制"><a href="#关于版本控制" class="headerlink" title="关于版本控制"></a>关于版本控制</h2><p>理解版本控制：我们需要他的原因就是我们希望能够记录对一系列文档操作的历史，便于查看修改记录，历史版本，甚至是在出错或者其他情况回滚到过去版本。</p><blockquote><p>P1 “使用版本控制系统，你可以将文件或者整个项目恢复到先前的状态，还可以比对掌握文件随时间的吧 ing 呢个，查看什么人最后做出的更改。”</p></blockquote><p>大型项目需要多人共同完成时，版本控制又提供了很可靠的多人协作的方式，每个人对项目的操作都可以作为一个版本记录其中，而且不同版本的提交留下的历史也为日后出现问题的时候找到对应负责人提供了可信途径（笑）。</p><h3 id="本地版本控制系统"><a href="#本地版本控制系统" class="headerlink" title="本地版本控制系统"></a>本地版本控制系统</h3><p>上古时代的<code>VCS</code>(<code>Version Control System</code> 学点英文)，开始计算机通信还没像现在互联网这种程度时候，本低版本控制也是一个必备需求。<code>RCS</code>，一个常用 VCS 工具，Mac OS X 操作系统中，rcs 命令会使<code>RCS</code>在磁盘上以一种特殊的格式保存补丁集（<code>patch set</code> ， 即记录文件之间的差异）通过叠加补丁来恢复到某个状态。</p><h3 id="集中式版本控制系统"><a href="#集中式版本控制系统" class="headerlink" title="集中式版本控制系统"></a>集中式版本控制系统</h3><p>当多人开发协作流行起来，本低版本控制不能满足需求，集中式版本控制系统（<code>Centralized Version Control System</code>, <code>CVCS</code>）应运而生</p><p>特点：依赖网络、依赖中心仓库、集中管理、单点故障难以处理</p><h3 id="分布式版本控制系统"><a href="#分布式版本控制系统" class="headerlink" title="分布式版本控制系统"></a>分布式版本控制系统</h3><p>为了解决集中式的依赖在线和中心仓库交互、单点故障等问题，分布式版本控制系统（<code>Distributed Version Control System</code>, <code>DVCS</code>）被开发出来。</p><p>特点：无严格意义上的中心仓库，完整镜像（完整备份），</p><h2 id="Git-简史"><a href="#Git-简史" class="headerlink" title="Git 简史"></a>Git 简史</h2><p>Git 产生于 Linux 内核这个超大规模开源软件项目的维护过程中，开始 Linux 内核开发者社区使用的是 BitKeeper 专有分布式版本控制系统，后来关系破裂<br>B 收回软件的使用权，所以 Linux 开发社区（尤其是 Linux 之父林纳斯）汲取了原软件的经验和不足，开发出了自己的控制系统，最初目标是实现：</p><ul><li>速度快</li><li>设计简洁</li><li>对于非线性开发有力支持（大数量分支）</li><li>完全的分布式设计</li><li>能够有效处理像 Linux 内核这种超大型项目（速度及数据量）</li></ul><a id="more"></a><h3 id="Git-特性介绍"><a href="#Git-特性介绍" class="headerlink" title="Git 特性介绍"></a>Git 特性介绍</h3><p>介绍 Git 对比其他版本控制系统的差异，以及一些 Git 独特的地方。</p><h4 id="快照而非差异"><a href="#快照而非差异" class="headerlink" title="快照而非差异"></a>快照而非差异</h4><p>Git 最大不同在于对待数据的方式，很多版本控制系统（CVS、Subversion、Perforce）记录的是一些文件和在文件上随时间做的改动（记录变化量）。Git 记录的是快照，抓取快照后存储一个指向该快照的引用，变动的记录变动后的文件信息，不变动不记录，留下原先的链接，整体宏观上是非线性的，数据变动在快照到快照这个快照流中体现。</p><h4 id="几乎所有操作都在本地执行"><a href="#几乎所有操作都在本地执行" class="headerlink" title="几乎所有操作都在本地执行"></a>几乎所有操作都在本地执行</h4><p>在本地有本地仓库，自己对文件修改并记录版本时，一般无需从网络和其他计算机获取信息，无需考虑网络延时的开销。只有需要通过 Web 交互信息（比如上传至代码托管平台，对比与远程仓库差异）或者和他人写作的时候，在修改完成后再进行网络传输（这时本地已经完成了文件的修改，本地仓已经为最新版本）</p><h4 id="Git-的完整性"><a href="#Git-的完整性" class="headerlink" title="Git 的完整性"></a>Git 的完整性</h4><p>关于完整性，Git 存储前会进行校验和计算，校验使用 SHA-1 散列（嗯密码学相关），改一点散列值都会产生很大变化~。</p><blockquote><p>P6 “因为用途及广，你在 Git 中到处都会看到这种散列值。实际上，Git 并不是通过文件名在数据库中存储信息，而是通过信息的散列值。”</p></blockquote><h1 id="第-2-章-Git-基础"><a href="#第-2-章-Git-基础" class="headerlink" title="第 2 章 Git 基础"></a>第 2 章 Git 基础</h1><h2 id="获取-Git-仓库"><a href="#获取-Git-仓库" class="headerlink" title="获取 Git 仓库"></a>获取 Git 仓库</h2><pre><code class="hljs Git">git clone</code></pre><p>支持 HTTP 协议，ssh 传输协议等。</p><p>一些常见操作如<code>git status</code>查看当前状态，添加文件<code>git add</code>会直接让新文件变为暂存文件，同时，也可以暂存文件，是个多功能指令。编辑文件会由未修改状态变为已修改状态，已修改状态经过暂存变为已暂存状态。<code>git commit</code>会进行提交，执行的是上次<code>git add</code>的暂存文件版本，即在上次暂存后又做修改，这些修改是不会被提交的。</p><h2 id="忽略文件"><a href="#忽略文件" class="headerlink" title="忽略文件"></a>忽略文件</h2><p>.gitignore 文件种列出匹配模式，这些匹配的文件不会被纳入 Git 仓库的文件提交。</p><h2 id="查看变更"><a href="#查看变更" class="headerlink" title="查看变更"></a>查看变更</h2><p><code>git diff</code>命令可以查看哪些变更没有被暂存，哪些已暂存的变更正待提交？输出的是补丁（patch）。带<code>--staged</code>或者是<code>--cached</code>参数，表示查看暂存区对比提交的变更，不带参数表示的是当前未暂存的与暂存区的比较，即一后一前。</p><h2 id="提交变更"><a href="#提交变更" class="headerlink" title="提交变更"></a>提交变更</h2><p><code>git commit</code>会打开指定的文本编辑器（可以是 Vim,Emacs,VSCode）添加 message 后提交暂存区内容。<code>git commit -a</code>命令传入-a 选项会跳过暂存区，直接将所有跟踪文件加入暂存区后提交。</p><h2 id="移除文件"><a href="#移除文件" class="headerlink" title="移除文件"></a>移除文件</h2><p>先从暂存区移除，然后再提交，同时也会从工作目录中删除。直接 rm 移除的时候不会有记录，<code>git rm</code>才可以。</p><h2 id="移动文件"><a href="#移动文件" class="headerlink" title="移动文件"></a>移动文件</h2><p>Git 不会显式跟踪文件的移动，不过 Git 很聪明，能明白。</p><p><code>git mv xx xxx</code>实际上完成了下面这些命令</p><pre><code class="hljs Git">mv xx xxxgit rm xxgit add xxx</code></pre><p>无论改名还是<code>git mv</code>,Git 都能推断出来这是重命名操作。</p><h2 id="查看提交历史"><a href="#查看提交历史" class="headerlink" title="查看提交历史"></a>查看提交历史</h2><p><code>git log</code>可用参数有很多，比如<code>-p</code>按补丁格式显示每个提交引入的更改,<code>--start</code>显示每个提交中被更改的文件的统计信息,<code>--graph</code>用于显示图表展示分支和合并的信息。<code>--pretty</code>用一种可选格式显示提交，选项有 oneline、short、full、fuller 和 format（用于指定自定义格式）。</p><h2 id="撤销操作"><a href="#撤销操作" class="headerlink" title="撤销操作"></a>撤销操作</h2><p>修改，覆盖上一次提交的信息</p><p><code>git commit --amend</code>上述命令会提交暂存区内容，如果你在上次提交之后并没做任何该懂，那么提交快照就不会有变化。</p><p>撤销已暂存文件</p><p><code>git reset</code>命令会恢复到已经修改但未暂存的状态（如果是直接添加文件则会回到未添加的状态）。</p><p>撤销对文件的修改</p><p><code>git checkout --&lt;file&gt;</code>会撤销修改并把文件恢复到上次提交时的状态（或是刚克隆仓库后的状态，或是一开始再工作目录时的状态）。</p><blockquote><p>需要注意的是，git checkout —<file> 是一条危险的指令。执行该命令后，任何对该文件的修改都会丢失，因为上述命令用之前的版本文件做了覆盖，除非你确信不需要这些文件，否则不要使用该条命令。</file></p></blockquote><h2 id="远程仓库的使用"><a href="#远程仓库的使用" class="headerlink" title="远程仓库的使用"></a>远程仓库的使用</h2><p><code>git clone ... &lt;repo&gt; [&lt;dir&gt;]</code> dir 可以理解成别名，<code>git remote</code>查看远程分支，使用-v 参数，会显示 Git 存储的每个远程仓库对应的 URL。</p><h3 id="添加远程仓库拉取与推送"><a href="#添加远程仓库拉取与推送" class="headerlink" title="添加远程仓库拉取与推送"></a>添加远程仓库拉取与推送</h3><p><code>git remote add &lt;name&gt; &lt;url&gt;</code>显示添加一个远程仓库并起名字，根据官方文档，名字是必要的。<code>git fetch &lt;remote-name&gt;</code>从远程仓库拉取数据，项目进行到某个阶段，需要与他人分享你的工作成果时，需要把变更推送到远程仓库，<code>git push [remote-name] [branch-name]</code>将本地分支推送到远程分支，推送 push 的要求详见第三章。</p><h3 id="检查远程仓库"><a href="#检查远程仓库" class="headerlink" title="检查远程仓库"></a>检查远程仓库</h3><p><code>git remote show [remote-name]</code>会给出 URL 地址和分支的跟踪信息，一些差异性信息（分支的增删）等。</p><h3 id="删除和重命名远程仓库"><a href="#删除和重命名远程仓库" class="headerlink" title="删除和重命名远程仓库"></a>删除和重命名远程仓库</h3><p><code>git remote rename &lt;oldname&gt; &lt;newname&gt;</code>将远程仓库的名称修改，<code>git remote rm &lt;remote-name&gt;</code>迁移地址、删除某个镜像或者协作者退出时的情况，用于删除某个远程仓库。</p><h2 id="标签"><a href="#标签" class="headerlink" title="标签"></a>标签</h2><p><code>git tag</code>列举标签。加-l 参数可以模式匹配。</p><h3 id="创建标签"><a href="#创建标签" class="headerlink" title="创建标签"></a>创建标签</h3><p>轻量级（lightweight）标签儿话注释（annotated），一般推荐创建注释因为包含了全部的信息。</p><p>注释标签：<code>git tag -a v1.4 -m &quot;my version 1.4&quot;</code></p><p>轻量标签：<code>git tag v1.4-lw</code> 即不需要-a、-m 参数。</p><h2 id="Git-别名"><a href="#Git-别名" class="headerlink" title="Git 别名"></a>Git 别名</h2><p><code>git config --global alias.ci commit</code> 这样以后就可以用 git ci 代替 git commit 了。</p><h1 id="第-3-章-Git-分支机制"><a href="#第-3-章-Git-分支机制" class="headerlink" title="第 3 章 Git 分支机制"></a>第 3 章 Git 分支机制</h1><h2 id="分支机制简述"><a href="#分支机制简述" class="headerlink" title="分支机制简述"></a>分支机制简述</h2><p>当你发起提交时，Git 存储的是提交对象（commit object），其中包含了指向暂存区快照的指针。</p><p>暂存操作会对加入暂存区提交的每个文件计算校验和（SHA-1 散列值）并把文件的当前版本保存到 Git 仓库中（blob 对象）。而进行 commit 提交时，Git 会先为每个子目录计算校验和，然后再把这些树对象保存到 Git 仓库中。Git 随后会创建提交对象，其中包括元数据以及指向项目根目录的树对象的指针，以便有需要的时候重新创建这次快照。</p><p>个人理解：一次提交内容是一个树模型而不同提交又有父提交的指针也形成一个树模型？</p><p>HEAD 指针指向当前所在的本地分支，checkout 实际上就是切换 HEAD 指向的位置，这样的好处是一个 checkout 实际上可能是不同次提交的不同分支，能使我们关注分支而非提交。</p><blockquote><p><strong>分支切换会更改工作目录文件</strong><br>切换分支时。工作目录的文件会被改变。如果你切换到较旧的分支，工作目录会被恢复到该分支上最后一次提交的状态。如果 Git 再当前状态下无法干净地完成恢复操作，就不会允许你切换分支。</p></blockquote><h2 id="基本的分支与合并操作"><a href="#基本的分支与合并操作" class="headerlink" title="基本的分支与合并操作"></a>基本的分支与合并操作</h2><h3 id="基本分支操作"><a href="#基本分支操作" class="headerlink" title="基本分支操作"></a>基本分支操作</h3><p><code>git checkout -b iss53</code> -b 参数表示新建分支同时移动当前分支到该分支，实际上相当于两条命令执行<code>git branch iss53</code>，<code>git checkout iss53</code>。</p><p>当继续修补 bug 但是手头分支还没有完成地时候，利用 git 我们可以先 checkout 到问题分支（假设这里是 master 分支），新建 hotfix 分支修补问题。</p><p>修补问题完成后 checkout 到 master 分支使用<code>git merge</code>合并 hotfix 到 master，由于在 master 分支是分化出来的 hotfix 分支的直接上游，合并不会存在冲突，合并时出现”fast-forward”提示。这时候分支 master 和 hotfix 在一个提交版本上（指向位置相同），我们现在不需要 hotfix 分支了，<code>git branch -d</code>删除这个分支。</p><p>修补问题完成后，我们就可以继续回到原先开发分支继续工作啦！</p><h3 id="基本合并操作"><a href="#基本合并操作" class="headerlink" title="基本合并操作"></a>基本合并操作</h3><p>在早先有分叉历史的合并过程中，采用三方合并（被并入的提交快照，要合并的提交快照和共同祖先），合并完成后会新建一个提交指向新建的快照（而非像之间 fast-forward 一样只是移动快照的指针）。合并提交的特殊性在于它拥有不止一个父提交。提示为”Merge made by the ‘recursive’ strategy”。</p><p>值得注意的是，Git 会自己判断最优的公共祖先并将其作为合并的基础。</p><h2 id="分支管理"><a href="#分支管理" class="headerlink" title="分支管理"></a>分支管理</h2><p><code>git branch</code>，不带参数列出分支列表，带参数-v 可查看每个分支上的最新提交信息。</p><p><code>git branch --merged</code>会显示哪些分支并入了当前分支，相应的—no-merged 参数则显示未并入的分支。</p><h2 id="与分支有关的工作流"><a href="#与分支有关的工作流" class="headerlink" title="与分支有关的工作流"></a>与分支有关的工作流</h2><h3 id="长期分支"><a href="#长期分支" class="headerlink" title="长期分支"></a>长期分支</h3><p>方便的三方合并机制，使得分支合并是个容易的操作。多个开放的分支分别用于开发周期的不同阶段很合适。</p><p>比如一些开发者所采用的<code>master</code>分支只存放稳定版代码，即已经发布版本或即将发布版本的代码，<code>develop</code>和<code>next</code>的平行分支用于开发或是用于测试代码的稳定性，达到稳定性则合并到<code>master</code>分支中去。这种工作流很明显稳定分支会在提交历史中较为靠后，而前沿的开发分支较为靠前。筒仓（work silo）既视感，几经迭代就放到更稳定的筒仓中。</p><h3 id="主题分支"><a href="#主题分支" class="headerlink" title="主题分支"></a>主题分支</h3><p>适用于短期实现某一特定功能相关工作的分支。短期的外延，然后再合并到主干分支。每个分支的更改都与它的目标特性相关，使得代码审查等活动中俄能够更容易读懂所做的更改。</p><p>无需考虑先后顺序，并行开发无负担且同时易于选择。</p><h2 id="远程分支"><a href="#远程分支" class="headerlink" title="远程分支"></a>远程分支</h2><p>指针存在本地但无法移动，网络通信时自动更新，有些像书签，其表示形式是<code>(remote)/(branch)</code></p><p><code>git fetch</code>命令会更新远程分支指针（就理解成更新另一个人对分支路径的修改），origin 只是默认命名，我们还可以有很多个远程 remote。</p><h3 id="推送"><a href="#推送" class="headerlink" title="推送"></a>推送</h3><p>当需要同别人共享某个分支上的工作成果时，就要把它推送到一个具有<strong>写权限</strong>的远程仓库。本地分支不会自动同步到远程仓库，必须要显式地推送那些你想要与他人共享的分支。这样一来，你可以使用私有分支做一些不想与他人共享的工作，而仅仅推送那些需要与别人协作的主题分支。</p><h3 id="跟踪分支"><a href="#跟踪分支" class="headerlink" title="跟踪分支"></a>跟踪分支</h3><p>基于远程分支创建的本地分支会自动称为跟踪分支（tracking branch）。或者有时候也叫作上游分（upstream branch）。</p><p>跟踪分支与远程分支直接关联。如果你正处在一个跟踪分支上并键入<code>git push</code>Git 会知道要将数据推送到哪个服务器上的哪个分支（pull 同理），这实际上是我们经常看到的操作。</p><p>checkout 到某个远程分支名相同但是本地还没有的分支时候，Git 会帮你创建跟踪分支。</p><h3 id="拉取"><a href="#拉取" class="headerlink" title="拉取"></a>拉取</h3><p>git fetch 命令会拉取本地没有的远程然后最新更新数据。只是读数据，并不会影响本地的工作目录。</p><h2 id="变基"><a href="#变基" class="headerlink" title="变基"></a>变基</h2><p>在 Git 中，要把更改一个分支整合到另一个分支，有两种主要方式：合并（merge）和变基（rebase）。</p><h3 id="工作原理"><a href="#工作原理" class="headerlink" title="工作原理"></a>工作原理</h3><p>首先找到两个要整合的分支（你当前所在的分支和要整合到的分支）的共同祖先，然后取得当前所在分支的每次提交引入的更改（diff），并把这些更改保存为临时文件，这之后将当前分支重置为要整合到的分支，最后在该分支上依次引入之前保存的更改。</p><h3 id="潜在危害"><a href="#潜在危害" class="headerlink" title="潜在危害"></a>潜在危害</h3><p>总结成一句话：<strong>不要对已经存在于本地仓库之外的提交操作执行变基操作</strong>。否则会带来不同分支上相同时间相同内容的混乱。（因为远程仓库并不会跟着进行变基操作）。</p><h1 id="第-4-章"><a href="#第-4-章" class="headerlink" title="第 4 章"></a>第 4 章</h1><h2 id="协议"><a href="#协议" class="headerlink" title="协议"></a>协议</h2><p>本地协议、HTTP（智能与非智能）、SSH 协议等。不再做详细介绍。</p><h2 id="在服务器上搭建-Git"><a href="#在服务器上搭建-Git" class="headerlink" title="在服务器上搭建 Git"></a>在服务器上搭建 Git</h2><p>以 Linux 为例</p><p>开始配置时，先把已有的仓库导出成一个新的裸仓库<code>git clone --bare my_project my_project.git</code>，</p><p>将裸仓库放置在服务器上，假定想要放置在远程服务器/srv/git 目录下（前提时具备 SSH 访问权限）。<code>scp -r my_project.git user@git.example.com:/srv/git</code>，把裸仓库复制到该目录。</p><p>其他用户具有读权限的时候，可以 clone，具有写权限的时候可以推送数据。</p><p>赋予写权限</p><pre><code class="hljs Git">ssh user@git.example.comcd /srv/git/my_project.gitgit init --bare --shared</code></pre><p>就完成了运行一台 Git 简单服务器的全部操作。</p><h1 id="第-6-章-GitHub"><a href="#第-6-章-GitHub" class="headerlink" title="第 6 章 GitHub"></a>第 6 章 GitHub</h1><h2 id="SSH-访问"><a href="#SSH-访问" class="headerlink" title="SSH 访问"></a>SSH 访问</h2><p>使用 SSH 远程连接，则需要配置一个公钥，在设置里面 SSH keys 部分配置。</p><h2 id="为项目做贡献"><a href="#为项目做贡献" class="headerlink" title="为项目做贡献"></a>为项目做贡献</h2><p>Fork 操作，派生项目，推送修改，然后创建拉取请求，将改动写回原始仓库。想要创建拉取请求，点击 Fork 按钮即可。</p><h3 id="GitHub-流程"><a href="#GitHub-流程" class="headerlink" title="GitHub 流程"></a>GitHub 流程</h3><ol><li>从 master 分支中创建一个主题分支。</li><li>提交一些修改来改进项目。</li><li>将该分支推送到 GitHub 上的项目中</li><li>在 GitHub 上创建一个拉取请求</li><li>进行讨论，根据情况继续提交修改</li><li>项目拥有者合并或关闭拉取请求</li></ol><h2 id="项目维护"><a href="#项目维护" class="headerlink" title="项目维护"></a>项目维护</h2><h3 id="项目管理"><a href="#项目管理" class="headerlink" title="项目管理"></a>项目管理</h3><p>一般对于单个项目而言，没有太多的管理事务可做，不过其中有几点值得一提。</p><p>更改默认分支</p><p>在 Options 标签下的个人仓库设置页面中修改，之后所有主要操作都会使用你所选择的分支作为默认分支，包括进行仓库克隆操作时默认检出的分支。</p><p>移交项目</p><p>个人仓库设置中 Transfer ownership 选项可以完成这项操作。（放弃或交由组织管理）</p><h3 id="组织管理"><a href="#组织管理" class="headerlink" title="组织管理"></a>组织管理</h3><p>这一节暂且不管了，多了一些组织团队管理以及审计的功能</p><h3 id="GitHub-脚本化"><a href="#GitHub-脚本化" class="headerlink" title="GitHub 脚本化"></a>GitHub 脚本化</h3><h1 id="第-10-章-Git-内幕"><a href="#第-10-章-Git-内幕" class="headerlink" title="第 10 章 Git 内幕"></a>第 10 章 Git 内幕</h1><p>本章早读晚读都可以，展示 Git 内部工作细节以及实现。</p><h2 id="底层命令和高层命令"><a href="#底层命令和高层命令" class="headerlink" title="底层命令和高层命令"></a>底层命令和高层命令</h2><p><code>git init</code>会初始化一个.git 目录，几乎包含了 Git 存储和操作的所有内容。备份或者克隆，把这个目录复制到别处就可以了。本章讨论的内容基本上都在该目录下。</p><h3 id="Git-对象"><a href="#Git-对象" class="headerlink" title="Git 对象"></a>Git 对象</h3><p>Git 按照内容寻址，那，意味着核心是“键-值”数据存储。插入内容-返回键值，键值检索-返回相应内容。</p><p>objects 目录下有一个文件，这是 Git 最初存储内容的方式：一份内容一份文件，以内容的头部的 SHA-1 校验和作为文件名。子目录采用 SHA-1 的前两个字符为名，文件名用剩余 38 个字符命名。</p><p>可以调用底层<code>git cat-file</code>将内容取回，-p 参数会将内容打印，-t 会给出类型（目前已知有 commit 还有 blob 还有 tree 对象）。</p><h3 id="树对象"><a href="#树对象" class="headerlink" title="树对象"></a>树对象</h3><p>Git 存储内容的方式类似 Unix 文件系统，但有一些简化，所有内容被存储为树对象和 blob 对象。树对相对应 Unix 目录项，blob 对象基本上对应 i 节点或文件内容。单个树对象包含一个或多个树条目，每个条目包含一个指向 blob 对象或子树的指针以及相关的模式、类型和文件名。</p><p>（有机会学习一遍 Unix 和 Linux 的文件系统的表述，记住树对象目录是储存的指针。）</p><h3 id="提交对象"><a href="#提交对象" class="headerlink" title="提交对象"></a>提交对象</h3><p><code>git commit-tree</code>命令指定单个树对象的 SHA-1 以及父提交对象（如果有），创建提交对象。</p><p>对树对象的一系列操作（底层操作），我们实际上可以创建了一个 Git 仓库，这实际上也正是当我们执行 git add 和 git commit 命令时，Git 所执行的操作（底层的）。</p><p>blabla 剩下的以后慢慢填坑吧。</p>]]></content>
    
    
    <categories>
      
      <category>Computer Science</category>
      
      <category>工具</category>
      
    </categories>
    
    
    <tags>
      
      <tag>工具</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>VSCode——Git配置及终端替换</title>
    <link href="/post/eae0b80e.html"/>
    <url>/post/eae0b80e.html</url>
    
    <content type="html"><![CDATA[<h1 id="Git-安装"><a href="#Git-安装" class="headerlink" title="Git 安装"></a>Git 安装</h1><p>如果本机还没有安装过 Git，那么首先从官网上下载合适的版本（Mac OS/Windows/Linux）</p><p><img src="https://eddyblog.oss-cn-shenzhen.aliyuncs.com/VSCode%E2%80%94%E2%80%94Git%E9%85%8D%E7%BD%AE%E5%8F%8A%E7%BB%88%E7%AB%AF%E6%9B%BF%E6%8D%A2/1.png" srcset="/img/loading.gif" alt="1.png"></p><p>官方地址为：<a href="https://git-scm.com/download/win" target="_blank" rel="noopener">https://git-scm.com/download/win</a></p><p>下载完以后双击进行安装，勾选使用 Git Bash 以及使用 VSCode 作为默认编辑器（这个看个人喜好）。</p><p><img src="https://eddyblog.oss-cn-shenzhen.aliyuncs.com/VSCode%E2%80%94%E2%80%94Git%E9%85%8D%E7%BD%AE%E5%8F%8A%E7%BB%88%E7%AB%AF%E6%9B%BF%E6%8D%A2/2.png" srcset="/img/loading.gif" alt="2.png"></p><p>安装成功界面</p><h1 id="检查-Git"><a href="#检查-Git" class="headerlink" title="检查 Git"></a>检查 Git</h1><p>命令行输入</p><pre><code>git --version</code></pre><p>得到结果</p><pre><code>git version 2.20.1.windows.1</code></pre><p>证明 Git 安装正常，若出现异常，无对应函数，确定一下环境变量是否配置正常</p><h1 id="VSCode-中-Git-配置"><a href="#VSCode-中-Git-配置" class="headerlink" title="VSCode 中 Git 配置"></a>VSCode 中 Git 配置</h1><ol><li><p>Git 路径</p><p><code>Ctrl+,</code>打开 Setting 界面，搜索 Git.path，编辑到 User Setting 中（本机都使用所以可以不必每次都添加到 Workspace Setting 处设计），值为本机安装的 Git 文件目录里 git.exe 的路径。（注意 Windows 修改’\\’为’\\\\’）</p><p><img src="https://eddyblog.oss-cn-shenzhen.aliyuncs.com/VSCode%E2%80%94%E2%80%94Git%E9%85%8D%E7%BD%AE%E5%8F%8A%E7%BB%88%E7%AB%AF%E6%9B%BF%E6%8D%A2/3.gif" srcset="/img/loading.gif" alt="3.gif"></p></li><li><p>Git Bash 替换原有终端</p><p>鉴于不少人习惯通过 Git Bash 命令行进行操作，我们利用 VSCode 提供的内置终端功能，将终端替换为 Git Bash，再也不用担心一堆 Git 窗口来回切了，还可以配合<code>Ctrl+\</code>等快捷键充分发挥终端小窗口并行工作的潜力。</p><p><code>Ctrl+,</code>打开 Setting 界面，搜索<code>git.integrated.shell.window</code>,编辑对应框，路径改为对应的 Bash.exe 路径（我的机器中是 D:\Program Files\Git\bin\bash.exe）</p><p><img src="https://eddyblog.oss-cn-shenzhen.aliyuncs.com/VSCode%E2%80%94%E2%80%94Git%E9%85%8D%E7%BD%AE%E5%8F%8A%E7%BB%88%E7%AB%AF%E6%9B%BF%E6%8D%A2/4.gif" srcset="/img/loading.gif" alt="4.gif"></p></li></ol><p>Thanks to 微软爸爸，现在我们就可以在 VSCode 里优雅的使用 Git 啦。</p><p>关于 Git 的教程，后续读完《精通 Git》会补一篇。链接在这里。</p><a id="more"></a>]]></content>
    
    
    <categories>
      
      <category>Computer Science</category>
      
      <category>工具</category>
      
    </categories>
    
    
    <tags>
      
      <tag>工具</tag>
      
      <tag>VSCode</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>VSCode——通用插件推荐与介绍</title>
    <link href="/post/acf6b02e.html"/>
    <url>/post/acf6b02e.html</url>
    
    <content type="html"><![CDATA[<h1 id="VSCode常用插件一览"><a href="#VSCode常用插件一览" class="headerlink" title="VSCode常用插件一览"></a>VSCode常用插件一览</h1><p>这篇文章写了一些目前我已经下载并且使用体验良好的插件，欢迎大家联系我推荐其他插件吼。</p><p>插件主要从通用工具与<strong>编写支持</strong>、<strong>界面/美化</strong>、<strong>语言支持及相关工具</strong>三个类别来进行介绍。</p><h2 id="通用工具与编写支持"><a href="#通用工具与编写支持" class="headerlink" title="通用工具与编写支持"></a>通用工具与编写支持</h2><ol><li>Chinese (Simplified) Language Pack for Visual Studio Code<br> <img src="https://eddyblog.oss-cn-shenzhen.aliyuncs.com/VSCode%E2%80%94%E2%80%94%E9%80%9A%E7%94%A8%E6%8F%92%E4%BB%B6%E6%8E%A8%E8%8D%90%E4%B8%8E%E4%BB%8B%E7%BB%8D/1.png" srcset="/img/loading.gif" alt="1.png"><ul><li>功能：此中文（简体）语言包为 VS Code 提供本地化界面。</li><li>使用方法：安装后，在 locale.json 中添加 “locale”: “zh-cn”，即可载入中文（简体）语言包。要修改 locale.json，你可以同时按下 Ctrl+Shift+P 打开命令面板，之后输入 “config” 筛选可用命令列表，最后选择配置语言命令。请参阅文档并获取更多信息。</li></ul></li><li>vscode-faker<br> <img src="https://eddyblog.oss-cn-shenzhen.aliyuncs.com/VSCode%E2%80%94%E2%80%94%E9%80%9A%E7%94%A8%E6%8F%92%E4%BB%B6%E6%8E%A8%E8%8D%90%E4%B8%8E%E4%BB%8B%E7%BB%8D/3.png" srcset="/img/loading.gif" alt="3.png"><ul><li>功能：提供编造数据</li><li>使用方法：安装后，<code>Ctrl+Shift+P</code>然后输入Faker选择对应的数据进行构造</li></ul></li><li>VS Live Share<br> <img src="https://eddyblog.oss-cn-shenzhen.aliyuncs.com/VSCode%E2%80%94%E2%80%94%E9%80%9A%E7%94%A8%E6%8F%92%E4%BB%B6%E6%8E%A8%E8%8D%90%E4%B8%8E%E4%BB%8B%E7%BB%8D/5.png" srcset="/img/loading.gif" alt="5.png"><ul><li>功能：与他人实时同步编辑代码</li><li>使用方法：安装后根据说明文档来吧，博主目前还用不到，自己稍微尝试了一下，很有趣。</li></ul></li><li>Docker<br> <img src="https://eddyblog.oss-cn-shenzhen.aliyuncs.com/VSCode%E2%80%94%E2%80%94%E9%80%9A%E7%94%A8%E6%8F%92%E4%BB%B6%E6%8E%A8%E8%8D%90%E4%B8%8E%E4%BB%8B%E7%BB%8D/6.png" srcset="/img/loading.gif" alt="6.png"><ul><li>功能：语法高亮，命令以及拼写检查</li><li>使用方法：参见说明文档，博主目前还未接触Docker，只听闻这个东西</li></ul></li></ol><a id="more"></a><h2 id="界面-图标美化"><a href="#界面-图标美化" class="headerlink" title="界面/图标美化"></a>界面/图标美化</h2><ol><li><p>vscode-icons<br> <img src="https://eddyblog.oss-cn-shenzhen.aliyuncs.com/VSCode%E2%80%94%E2%80%94%E9%80%9A%E7%94%A8%E6%8F%92%E4%BB%B6%E6%8E%A8%E8%8D%90%E4%B8%8E%E4%BB%8B%E7%BB%8D/2.png" srcset="/img/loading.gif" alt="2.png"></p><ul><li>功能：提供多彩图标</li><li>使用方法：安装后，<code>Ctrl+Shift+P</code>然后输入Icons选择对应的命令。（博主觉得太花哨，还是选择Seti的VScode图标）</li></ul></li><li><p>Studio Icons<br> <img src="https://eddyblog.oss-cn-shenzhen.aliyuncs.com/VSCode%E2%80%94%E2%80%94%E9%80%9A%E7%94%A8%E6%8F%92%E4%BB%B6%E6%8E%A8%E8%8D%90%E4%B8%8E%E4%BB%8B%E7%BB%8D/4.png" srcset="/img/loading.gif" alt="4.png"></p><ul><li>功能：提供Visual Studio风格图标</li><li>使用方法：安装后，在左下角小齿轮选择Icon Theme找到Visual Studio Code风格的两个Icon配色方案。</li></ul></li></ol><h2 id="Markdown相关"><a href="#Markdown相关" class="headerlink" title="Markdown相关"></a>Markdown相关</h2><ol><li><p>markdownlint<br> <img src="https://eddyblog.oss-cn-shenzhen.aliyuncs.com/VSCode%E2%80%94%E2%80%94%E9%80%9A%E7%94%A8%E6%8F%92%E4%BB%B6%E6%8E%A8%E8%8D%90%E4%B8%8E%E4%BB%8B%E7%BB%8D/7.png" srcset="/img/loading.gif" alt="7.png"></p><ul><li>功能：提供Markdown规范以及风格的检查</li><li>使用方法：<br>安装后，在md文件编写的时候会生效产生markdownlint的warning信息，可以在Setting里面选择错误信息的显示的设置。<br><img src="https://eddyblog.oss-cn-shenzhen.aliyuncs.com/VSCode%E2%80%94%E2%80%94%E9%80%9A%E7%94%A8%E6%8F%92%E4%BB%B6%E6%8E%A8%E8%8D%90%E4%B8%8E%E4%BB%8B%E7%BB%8D/8.png" srcset="/img/loading.gif" alt="8.png"></li></ul></li><li><p>Markdown All in One<br> <img src="https://eddyblog.oss-cn-shenzhen.aliyuncs.com/VSCode%E2%80%94%E2%80%94%E9%80%9A%E7%94%A8%E6%8F%92%E4%BB%B6%E6%8E%A8%E8%8D%90%E4%B8%8E%E4%BB%8B%E7%BB%8D/9.png" srcset="/img/loading.gif" alt="9.png"></p><ul><li>功能：提供Markdown书写习惯的快捷键。</li><li>使用方法：安装后，md文件编写的时候生效，比如<code>Ctrl+B</code>加粗，以及自动对标号顺延。</li></ul></li></ol><h2 id="语言支持及相关工具"><a href="#语言支持及相关工具" class="headerlink" title="语言支持及相关工具"></a>语言支持及相关工具</h2><ol><li>C++相关<br> <img src="https://eddyblog.oss-cn-shenzhen.aliyuncs.com/VSCode%E2%80%94%E2%80%94%E9%80%9A%E7%94%A8%E6%8F%92%E4%BB%B6%E6%8E%A8%E8%8D%90%E4%B8%8E%E4%BB%8B%E7%BB%8D/10.png" srcset="/img/loading.gif" alt="10.png"><ul><li>功能：提供了C++编译测试的支持，以及C++书写检查，代码高亮，和联想输入。</li><li>使用方法：安装后参照说明文档。</li></ul></li><li>Java相关<br>  <img src="https://eddyblog.oss-cn-shenzhen.aliyuncs.com/VSCode%E2%80%94%E2%80%94%E9%80%9A%E7%94%A8%E6%8F%92%E4%BB%B6%E6%8E%A8%E8%8D%90%E4%B8%8E%E4%BB%8B%E7%BB%8D/11.png" srcset="/img/loading.gif" alt="11.png"><ul><li>功能：提供了Java编译测试的支持，以及Java书写规范检查，代码高亮，联想输入</li><li>使用方法：安装后参照说明文档。</li></ul></li><li>Maven<br>  <img src="https://eddyblog.oss-cn-shenzhen.aliyuncs.com/VSCode%E2%80%94%E2%80%94%E9%80%9A%E7%94%A8%E6%8F%92%E4%BB%B6%E6%8E%A8%E8%8D%90%E4%B8%8E%E4%BB%8B%E7%BB%8D/13.png" srcset="/img/loading.gif" alt="13.png"><ul><li>功能：提供了Maven Projects的管理，编译支持。</li><li>使用方法：安装后关联Maven，<code>Ctrl+Shift+P</code> 然后输入Maven可以使用相关指令。</li></ul></li><li>Python<br>  <img src="https://eddyblog.oss-cn-shenzhen.aliyuncs.com/VSCode%E2%80%94%E2%80%94%E9%80%9A%E7%94%A8%E6%8F%92%E4%BB%B6%E6%8E%A8%E8%8D%90%E4%B8%8E%E4%BB%8B%E7%BB%8D/12.png" srcset="/img/loading.gif" alt="12.png"><ul><li>功能：提供了Python编译测试的支持</li><li>使用方法：参考说明文档</li></ul></li></ol>]]></content>
    
    
    <categories>
      
      <category>Computer Science</category>
      
      <category>工具</category>
      
    </categories>
    
    
    <tags>
      
      <tag>工具</tag>
      
      <tag>VSCode</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>VSCode——基础配置</title>
    <link href="/post/9305c5f5.html"/>
    <url>/post/9305c5f5.html</url>
    
    <content type="html"><![CDATA[<p>微软良心之作，高颜值加可拓展性。目前学生党一枚，一边学习着算法一遍又要写写前端以及blog的md，所以就入了VSCode的坑。</p><p>对于我本人，最舒服的莫过于继承了Terminal，以后再也不用跑到编辑器或者IDE外面鼠标右键或者Win+R开终端了。嗯看好微软（买Surface的动力++），另外可以配置好Python，Java和C++环境可以完成一个编辑器上写代码+调试+写博客总结的一系列操作，日后有望成为主要生产力工具。</p><p>后面会着手写一系列关于VSCode基本配置操作以及在各种语言环境，以及插件所实现的VSCode+操作。</p><h1 id="VSCode下载与安装"><a href="#VSCode下载与安装" class="headerlink" title="VSCode下载与安装"></a>VSCode下载与安装</h1><p>首先从官网下载</p><p><img src="https://eddyblog.oss-cn-shenzhen.aliyuncs.com/VSCode%E2%80%94%E2%80%94%E5%9F%BA%E7%A1%80%E9%85%8D%E7%BD%AE/1.png" srcset="/img/loading.gif" alt="1.png"></p><p>安装就不断下一步就行</p><h1 id="VSCode界面"><a href="#VSCode界面" class="headerlink" title="VSCode界面"></a>VSCode界面</h1><p>顺利安装完成，打开VScode以后会出现下图类似的界面（左边side bar上有一些图标是插件提供的，插件功能一会儿会提及）。大体上应该是这个Welcome界面</p><p><img src="https://eddyblog.oss-cn-shenzhen.aliyuncs.com/VSCode%E2%80%94%E2%80%94%E5%9F%BA%E7%A1%80%E9%85%8D%E7%BD%AE/2.png" srcset="/img/loading.gif" alt="2.png"></p><h1 id="VSCode用户设置"><a href="#VSCode用户设置" class="headerlink" title="VSCode用户设置"></a>VSCode用户设置</h1><ol><li><p>进入Setting界面进行设置</p><p> <code>Ctrl+,</code> 打开Setting界面出现如下</p><p> <img src="https://eddyblog.oss-cn-shenzhen.aliyuncs.com/VSCode%E2%80%94%E2%80%94%E5%9F%BA%E7%A1%80%E9%85%8D%E7%BD%AE/3.png" srcset="/img/loading.gif" alt="3.png"></p><p> 用户设置界面可以根据自己的需要搜索祥光的配置项并修改。后续很多插件的DIY配置都需要在这里搜索到匹配的项然后进行Edit in setting.json后编辑。</p><p> <img src="https://eddyblog.oss-cn-shenzhen.aliyuncs.com/VSCode%E2%80%94%E2%80%94%E5%9F%BA%E7%A1%80%E9%85%8D%E7%BD%AE/4.png" srcset="/img/loading.gif" alt="4.png"></p><p> 需要说明的是，左边是默认的用户设置，从左边选择条目加入右边。右边有两个Setting，分别为用户的使用Setting（公用），和当前工作环境的Setting。当编辑当前工作环境Setting的时候VSCode会自动在工作区文件夹建立一个名为.vscode的文件夹内部包含setting.json。</p><p> <img src="https://eddyblog.oss-cn-shenzhen.aliyuncs.com/VSCode%E2%80%94%E2%80%94%E5%9F%BA%E7%A1%80%E9%85%8D%E7%BD%AE/6.png" srcset="/img/loading.gif" alt="6.png"></p></li><li><p>改变编辑器外观（Color Theme）</p><p> <code>Ctrl+K,Ctrl+T</code> 组合按键，或者<code>Ctrl+Shift+P</code> 后输入Color Theme进入选择菜单，VS还很贴心的分出了浅色Theme和深色Theme。博主自己比较喜欢深色就选择了一款深色主题，大家用自己习惯的就好咯。</p><p> <img src="https://eddyblog.oss-cn-shenzhen.aliyuncs.com/VSCode%E2%80%94%E2%80%94%E5%9F%BA%E7%A1%80%E9%85%8D%E7%BD%AE/5.png" srcset="/img/loading.gif" alt="5.png"></p></li></ol><h1 id="VSCode操作命令"><a href="#VSCode操作命令" class="headerlink" title="VSCode操作命令"></a>VSCode操作命令</h1><h2 id="博主常用的快捷键"><a href="#博主常用的快捷键" class="headerlink" title="博主常用的快捷键"></a>博主常用的快捷键</h2><p>下面列了一些（我）常用的快捷键，应付基本需求基本上是没问题了</p><ol><li><code>Ctrl+N</code> 新建一个文件（上面会显示Untitle.txt）</li><li><code>Ctrl+Shift+N</code> 新建一个VSCode编辑器窗口</li><li><code>Ctrl+\</code> 右侧切出一个新的VScode编辑器</li><li><code>Ctrl+Tab</code> 切换打开的文件</li><li><code>Ctrl+P</code> 快速打开 Quick Open</li><li><code>Ctrl+Shift+P</code> 显示命令面板</li><li><code>Ctrl+Shift+Y</code> 显示Debug结果</li><li><code>Ctrl+(ESC下面那个)</code> 显示终端Terminal</li><li><code>Ctrl+Shift+(ESC下面那个)</code> 新增一个Terminal</li><li><code>Terminal+Ctrl+\</code> 右侧切出一个Terminal终端</li><li><code>Ctrl+,</code> 打开Setting界面</li><li><code>Ctrl+Shift+M</code> 打开PROBLEMS出错信息界面（调试或者格式化的时候常用）</li><li><code>Alt+Shif+F</code> 很多插件提供的全页面按对应语言格式化</li></ol><a id="more"></a><h2 id="快捷键中英文对照表"><a href="#快捷键中英文对照表" class="headerlink" title="快捷键中英文对照表"></a>快捷键中英文对照表</h2><p>思否上有前辈贴出了基本上全部的VSCode快捷键中英文对照表</p><p><a href="https://segmentfault.com/a/1190000007688656" target="_blank" rel="noopener">原文链接</a></p><h3 id="常用-General"><a href="#常用-General" class="headerlink" title="常用 General"></a>常用 General</h3><div class="table-container"><table><thead><tr><th>按 Press</th><th>功能 Function</th></tr></thead><tbody><tr><td>Ctrl + Shift + P，F1</td><td>显示命令面板 Show Command Palette</td></tr><tr><td>Ctrl + P</td><td>快速打开 Quick Open</td></tr><tr><td>Ctrl + Shift + N</td><td>新窗口/实例 New window/instance</td></tr><tr><td>Ctrl + Shift + W</td><td>关闭窗口/实例 Close window/instance</td></tr></tbody></table></div><h3 id="基础编辑-Basic-editing"><a href="#基础编辑-Basic-editing" class="headerlink" title="基础编辑 Basic editing"></a>基础编辑 Basic editing</h3><div class="table-container"><table><thead><tr><th>按 Press</th><th>功能 Function</th></tr></thead><tbody><tr><td>Ctrl+X</td><td>剪切行（空选定） Cut line (empty selection)</td></tr><tr><td>Ctrl+C</td><td>复制行（空选定）Copy line (empty selection)</td></tr><tr><td>Alt+ ↑ / ↓</td><td>向上/向下移动行 Move line up/down</td></tr><tr><td>Shift+Alt + ↓ / ↑</td><td>向上/向下复制行 Copy line up/down</td></tr><tr><td>Ctrl+Shift+K</td><td>删除行 Delete line</td></tr><tr><td>Ctrl+Enter</td><td>在下面插入行 Insert line below</td></tr><tr><td>Ctrl+Shift+Enter</td><td>在上面插入行 Insert line above</td></tr><tr><td>Ctrl+Shift+\</td><td>跳到匹配的括号 Jump to matching bracket</td></tr><tr><td>Ctrl+] / [</td><td>缩进/缩进行 Indent/outdent line</td></tr><tr><td>Home</td><td>转到行首 Go to beginning of line</td></tr><tr><td>End</td><td>转到行尾 Go to end of line</td></tr><tr><td>Ctrl+Home</td><td>转到文件开头 Go to beginning of file</td></tr><tr><td>Ctrl+End</td><td>转到文件末尾 Go to end of file</td></tr><tr><td>Ctrl+↑ / ↓</td><td>向上/向下滚动行 Scroll line up/down</td></tr><tr><td>Alt+PgUp / PgDown</td><td>向上/向下滚动页面 Scroll page up/down</td></tr><tr><td>Ctrl+Shift+[</td><td>折叠（折叠）区域 Fold (collapse) region</td></tr><tr><td>Ctrl+Shift+]</td><td>展开（未折叠）区域 Unfold (uncollapse) region</td></tr><tr><td>Ctrl+K Ctrl+[</td><td>折叠（未折叠）所有子区域 Fold (collapse) all subregions</td></tr><tr><td>Ctrl+K Ctrl+]</td><td>展开（未折叠）所有子区域 Unfold (uncollapse) all subregions</td></tr><tr><td>Ctrl+K Ctrl+0</td><td>折叠（折叠）所有区域 Fold (collapse) all regions</td></tr><tr><td>Ctrl+K Ctrl+J</td><td>展开（未折叠）所有区域 Unfold (uncollapse) all regions</td></tr><tr><td>Ctrl+K Ctrl+C</td><td>添加行注释 Add line comment</td></tr><tr><td>Ctrl+K Ctrl+U</td><td>删除行注释 Remove line comment</td></tr><tr><td>Ctrl+/</td><td>切换行注释 Toggle line comment</td></tr><tr><td>Shift+Alt+A</td><td>切换块注释 Toggle block comment</td></tr><tr><td>Alt+Z</td><td>切换换行 Toggle word wrap</td></tr></tbody></table></div><h3 id="导航-Navigation"><a href="#导航-Navigation" class="headerlink" title="导航 Navigation"></a>导航 Navigation</h3><div class="table-container"><table><thead><tr><th>按 Press</th><th>功能 Function</th></tr></thead><tbody><tr><td>Ctrl + T</td><td>显示所有符号 Show all Symbols</td></tr><tr><td>Ctrl + G</td><td>转到行… Go to Line…</td></tr><tr><td>Ctrl + P</td><td>转到文件… Go to File…</td></tr><tr><td>Ctrl + Shift + O</td><td>转到符号… Go to Symbol…</td></tr><tr><td>Ctrl + Shift + M</td><td>显示问题面板 Show Problems panel</td></tr><tr><td>F8</td><td>转到下一个错误或警告 Go to next error or warning</td></tr><tr><td>Shift + F8</td><td>转到上一个错误或警告 Go to previous error or warning</td></tr><tr><td>Ctrl + Shift + Tab</td><td>导航编辑器组历史记录 Navigate editor group history</td></tr><tr><td>Alt + ←/→</td><td>返回/前进 Go back / forward</td></tr><tr><td>Ctrl + M</td><td>切换选项卡移动焦点 Toggle Tab moves focus</td></tr></tbody></table></div><h3 id="搜索和替换-Search-and-replace"><a href="#搜索和替换-Search-and-replace" class="headerlink" title="搜索和替换 Search and replace"></a>搜索和替换 Search and replace</h3><div class="table-container"><table><thead><tr><th>按 Press</th><th>功能 Function</th></tr></thead><tbody><tr><td>Ctrl + F</td><td>查找 Find</td></tr><tr><td>Ctrl + H</td><td>替换 Replace</td></tr><tr><td>F3 / Shift + F3</td><td>查找下一个/上一个 Find next/previous</td></tr><tr><td>Alt + Enter</td><td>选择查找匹配的所有出现 Select all occurences of Find match</td></tr><tr><td>Ctrl + D</td><td>将选择添加到下一个查找匹配 Add selection to next Find match</td></tr><tr><td>Ctrl + K Ctrl + D</td><td>将最后一个选择移至下一个查找匹配项 Move last selection to next Find match</td></tr><tr><td>Alt + C / R / W</td><td>切换区分大小写/正则表达式/整个词 Toggle case-sensitive / regex / whole word</td></tr></tbody></table></div><h3 id="多光标和选择-Multi-cursor-and-selection"><a href="#多光标和选择-Multi-cursor-and-selection" class="headerlink" title="多光标和选择 Multi-cursor and selection"></a>多光标和选择 Multi-cursor and selection</h3><div class="table-container"><table><thead><tr><th>按 Press</th><th>功能 Function</th></tr></thead><tbody><tr><td>Alt +单击</td><td>插入光标 Insert cursor</td></tr><tr><td>Ctrl + Alt +↑/↓</td><td>在上/下插入光标 Insert cursor above / below</td></tr><tr><td>Ctrl + U</td><td>撤消上一个光标操作 Undo last cursor operation</td></tr><tr><td>Shift + Alt + I</td><td>在选定的每一行的末尾插入光标 Insert cursor at end of each line selected</td></tr><tr><td>Ctrl + I</td><td>选择当前行 Select current line</td></tr><tr><td>Ctrl + Shift + L</td><td>选择当前选择的所有出现 Select all occurrences of current selection</td></tr><tr><td>Ctrl + F2</td><td>选择当前字的所有出现 Select all occurrences of current word</td></tr><tr><td>Shift + Alt + →</td><td>展开选择 Expand selection</td></tr><tr><td>Shift + Alt + ←</td><td>缩小选择 Shrink selection</td></tr><tr><td>Shift + Alt + （拖动鼠标）</td><td>列（框）选择 Column (box) selection</td></tr><tr><td>Ctrl + Shift + Alt +（箭头键）</td><td>列（框）选择 Column (box) selection</td></tr><tr><td>Ctrl + Shift + Alt + PgUp / PgDown</td><td>列（框）选择页上/下 Column (box) selection page up/down</td></tr></tbody></table></div><h3 id="丰富的语言编辑-Rich-languages-editing"><a href="#丰富的语言编辑-Rich-languages-editing" class="headerlink" title="丰富的语言编辑 Rich languages editing"></a>丰富的语言编辑 Rich languages editing</h3><div class="table-container"><table><thead><tr><th>按 Press</th><th>功能 Function</th></tr></thead><tbody><tr><td>Ctrl + 空格</td><td>触发建议 Trigger suggestion</td></tr><tr><td>Ctrl + Shift + Space</td><td>触发器参数提示 Trigger parameter hints</td></tr><tr><td>Tab</td><td>Emmet 展开缩写 Emmet expand abbreviation</td></tr><tr><td>Shift + Alt + F</td><td>格式化文档 Format document</td></tr><tr><td>Ctrl + K Ctrl + F</td><td>格式选定区域 Format selection</td></tr><tr><td>F12</td><td>转到定义 Go to Definition</td></tr><tr><td>Alt + F12</td><td>Peek定义 Peek Definition</td></tr><tr><td>Ctrl + K F12</td><td>打开定义到边 Open Definition to the side</td></tr><tr><td>Ctrl + .</td><td>快速解决 Quick Fix</td></tr><tr><td>Shift + F12</td><td>显示引用 Show References</td></tr><tr><td>F2</td><td>重命名符号 Rename Symbol</td></tr><tr><td>Ctrl + K Ctrl + X</td><td>修剪尾随空格 Trim trailing whitespace</td></tr><tr><td>Ctrl + K M</td><td>更改文件语言 Change file language</td></tr></tbody></table></div><h3 id="编辑器管理-Editor-management"><a href="#编辑器管理-Editor-management" class="headerlink" title="编辑器管理 Editor management"></a>编辑器管理 Editor management</h3><div class="table-container"><table><thead><tr><th>按 Press</th><th>功能 Function</th></tr></thead><tbody><tr><td>Ctrl+F4, Ctrl+W</td><td>关闭编辑器 Close editor</td></tr><tr><td>Ctrl+K F</td><td>关闭文件夹 Close folder</td></tr><tr><td>Ctrl+\</td><td>拆分编辑器 Split editor</td></tr><tr><td>Ctrl+ 1 / 2 / 3</td><td>聚焦到第1，第2或第3编辑器组 Focus into 1st, 2nd or 3rd editor group</td></tr><tr><td>Ctrl+K Ctrl+ ←/→</td><td>聚焦到上一个/下一个编辑器组 Focus into previous/next editor group</td></tr><tr><td>Ctrl+Shift+PgUp / PgDown</td><td>向左/向右移动编辑器 Move editor left/right</td></tr><tr><td>Ctrl+K ← / →</td><td>移动活动编辑器组 Move active editor group</td></tr></tbody></table></div><h3 id="文件管理-File-management"><a href="#文件管理-File-management" class="headerlink" title="文件管理 File management"></a>文件管理 File management</h3><div class="table-container"><table><thead><tr><th>按 Press</th><th>功能 Function</th></tr></thead><tbody><tr><td>Ctrl+N</td><td>新文件 New File</td></tr><tr><td>Ctrl+O</td><td>打开文件… Open File…</td></tr><tr><td>Ctrl+S</td><td>保存 Save</td></tr><tr><td>Ctrl+Shift+S</td><td>另存为… Save As…</td></tr><tr><td>Ctrl+K S</td><td>全部保存 Save All</td></tr><tr><td>Ctrl+F4</td><td>关闭 Close</td></tr><tr><td>Ctrl+K Ctrl+W</td><td>关闭所有 Close All</td></tr><tr><td>Ctrl+Shift+T</td><td>重新打开关闭的编辑器 Reopen closed editor</td></tr><tr><td>Ctrl+K</td><td>输入保持打开 Enter Keep Open</td></tr><tr><td>Ctrl+Tab</td><td>打开下一个 Open next</td></tr><tr><td>Ctrl+Shift+Tab</td><td>打开上一个 Open previous</td></tr><tr><td>Ctrl+K P</td><td>复制活动文件的路径 Copy path of active file</td></tr><tr><td>Ctrl+K R</td><td>显示资源管理器中的活动文件 Reveal active file in Explorer</td></tr><tr><td>Ctrl+K O</td><td>显示新窗口/实例中的活动文件 Show active file in new window/instance</td></tr></tbody></table></div><h3 id="显示-Display"><a href="#显示-Display" class="headerlink" title="显示 Display"></a>显示 Display</h3><div class="table-container"><table><thead><tr><th>按 Press</th><th>功能 Function</th></tr></thead><tbody><tr><td>F11</td><td>切换全屏 Toggle full screen</td></tr><tr><td>Shift+Alt+1</td><td>切换编辑器布局 Toggle editor layout</td></tr><tr><td>Ctrl+ = / -</td><td>放大/缩小 Zoom in/out</td></tr><tr><td>Ctrl+B</td><td>切换侧栏可见性 Toggle Sidebar visibility</td></tr><tr><td>Ctrl+Shift+E</td><td>显示浏览器/切换焦点 Show Explorer / Toggle focus</td></tr><tr><td>Ctrl+Shift+F</td><td>显示搜索 Show Search</td></tr><tr><td>Ctrl+Shift+G</td><td>显示Git Show Git</td></tr><tr><td>Ctrl+Shift+D</td><td>显示调试 Show Debug</td></tr><tr><td>Ctrl+Shift+X</td><td>显示扩展 Show Extensions</td></tr><tr><td>Ctrl+Shift+H</td><td>替换文件 Replace in files</td></tr><tr><td>Ctrl+Shift+J</td><td>切换搜索详细信息 Toggle Search details</td></tr><tr><td>Ctrl+Shift+C</td><td>打开新命令提示符/终端 Open new command prompt/terminal</td></tr><tr><td>Ctrl+Shift+U</td><td>显示输出面板 Show Output panel</td></tr><tr><td>Ctrl+Shift+V</td><td>切换Markdown预览 Toggle Markdown preview</td></tr><tr><td>Ctrl+K V</td><td>从旁边打开Markdown预览 Open Markdown preview to the side</td></tr></tbody></table></div><h3 id="调试-Debug"><a href="#调试-Debug" class="headerlink" title="调试 Debug"></a>调试 Debug</h3><div class="table-container"><table><thead><tr><th>按 Press</th><th>功能 Function</th></tr></thead><tbody><tr><td>F9</td><td>切换断点 Toggle breakpoint</td></tr><tr><td>F5</td><td>开始/继续 Start/Continue</td></tr><tr><td>Shift+F5</td><td>停止 Stop</td></tr><tr><td>F11 / Shift+F11</td><td>下一步/上一步 Step into/out</td></tr><tr><td>F10</td><td>跳过 Step over</td></tr><tr><td>Ctrl+K Ctrl+I</td><td>显示悬停 Show hover</td></tr></tbody></table></div><h3 id="集成终端-Integrated-terminal"><a href="#集成终端-Integrated-terminal" class="headerlink" title="集成终端 Integrated terminal"></a>集成终端 Integrated terminal</h3><div class="table-container"><table><thead><tr><th>按 Press</th><th>功能 Function</th></tr></thead><tbody><tr><td>Ctrl+`</td><td>显示集成终端 Show integrated terminal</td></tr><tr><td>Ctrl+Shift+`</td><td>创建新终端 Create new terminal</td></tr><tr><td>Ctrl+Shift+C</td><td>复制选定 Copy selection</td></tr><tr><td>Ctrl+Shift+V</td><td>粘贴到活动端子 Paste into active terminal</td></tr><tr><td>Ctrl+↑ / ↓</td><td>向上/向下滚动 Scroll up/down</td></tr><tr><td>Shift+PgUp / PgDown</td><td>向上/向下滚动页面 Scroll page up/down</td></tr><tr><td>Ctrl+Home / End</td><td>滚动到顶部/底部 Scroll to top/bottom</td></tr></tbody></table></div>]]></content>
    
    
    <categories>
      
      <category>Computer Science</category>
      
      <category>工具</category>
      
    </categories>
    
    
    <tags>
      
      <tag>工具</tag>
      
      <tag>VSCode</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>金融学辅修——金融学笔记（十）</title>
    <link href="/post/380486cb.html"/>
    <url>/post/380486cb.html</url>
    
    <content type="html"><![CDATA[<p>老师提供的习题册，15-16 版本。</p><p>考试时间，19 周周末，问一下课代表确定时间</p><h1 id="债券种类"><a href="#债券种类" class="headerlink" title="债券种类"></a>债券种类</h1><p>国内债券</p><p>国际债券氛围外国债券和欧洲债券</p><p>欧洲债券分为公墓债券和私募债券</p><ul><li><p>债券发行与交易</p><p>三种方式：溢价发行、平价发行、折价发行</p><p>直接债券和无息债券</p><p>几种特殊债券：<br>武士债券、扬基债券、熊猫债券</p><p>政府债券、金融债券、企业债券</p></li><li><p>可转换公司债券</p><ul><li>是一种可以在特定时间，按特定条件转换为普通股股票的特殊公司债券，它兼有债券和股票的特征。</li><li>具有以下条件<ol><li>债券性，有规定的利率和期限。</li><li>股权性，可转换债券为股票后，债权人变为公司的股东， 可转换性，</li><li>可转换性，</li><li>可氛围进内和境外可抓换债券。</li></ol></li></ul></li><li><p>债券的发行与流通</p><ul><li>债券发行市场<br>发行合同书<br>说明 shn</li></ul></li></ul><h2 id="证券投资基金的基本特征"><a href="#证券投资基金的基本特征" class="headerlink" title="证券投资基金的基本特征"></a>证券投资基金的基本特征</h2><h3 id="基本特征"><a href="#基本特征" class="headerlink" title="基本特征"></a>基本特征</h3><p>基金作为一种现代投资工具，三个特征</p><ol><li><p>集合投资，基金是这样一种投资方式；零散基金汇集， 谋取资产的增值。</p></li><li><p>分散风险。科学的投资组合降低风险，一定的资金实力，基金帮助中小投资者解决了资金实力不足的问题。</p></li><li><p>专业理财，基金实行专家管理制度，运用先进的技术手段分析，尽可能地避免投资决策的失误，提高投资的正确率。</p></li></ol><h3 id="证券投资基金的类型"><a href="#证券投资基金的类型" class="headerlink" title="证券投资基金的类型"></a>证券投资基金的类型</h3><p>按组织形式分：公司型投资基金（股份制投资公司），契约型投资基金（信托型投资基金）</p><p>主要区别</p><p>按基金可否赎回分：不可赎回（封闭式基金），可赎回（开放式基金）</p><p>按投资对象分为</p>]]></content>
    
    
    <categories>
      
      <category>Finance</category>
      
      <category>金融学</category>
      
    </categories>
    
    
    <tags>
      
      <tag>辅修</tag>
      
      <tag>金融学</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>金融学辅修——微观经济学笔记（六）</title>
    <link href="/post/62cb42be.html"/>
    <url>/post/62cb42be.html</url>
    
    <content type="html"><![CDATA[<h1 id="第八章-垄断竞争市场"><a href="#第八章-垄断竞争市场" class="headerlink" title="第八章 垄断竞争市场"></a>第八章 垄断竞争市场</h1><h2 id="垄断竞争市场的特点"><a href="#垄断竞争市场的特点" class="headerlink" title="垄断竞争市场的特点"></a>垄断竞争市场的特点</h2><p>完全竞争和完全垄断的市场模式是两个极端的市场类型，它们在现实经济活动中都极其罕见。</p><h2 id="垄断竞争的性质和特这个"><a href="#垄断竞争的性质和特这个" class="headerlink" title="垄断竞争的性质和特这个"></a>垄断竞争的性质和特这个</h2><ol><li><p>市场上买卖双方人数较多；</p><p> 一个生产集团企业数量非常多，每个厂商都认为自己的行为不会引起竞争队首的注意和反应，因而也不会受到<br> 竞争对手的任何影响。</p></li><li><p>各厂商生产的产品有差别</p><p> 这些产品都是非常接近的替代品，较强替代性但不可完全替代。</p><p> 差别越大，垄断越</p><ul><li>厂商进出比较容易；</li><li>厂商是市场价格的影响者</li></ul></li></ol><h1 id="垄断竞争厂商的需求曲线"><a href="#垄断竞争厂商的需求曲线" class="headerlink" title="垄断竞争厂商的需求曲线"></a>垄断竞争厂商的需求曲线</h1><ol><li><p>基本假设<br> 生产集团内所有厂商都具有i昂同的成本曲线和需求曲线，可以以代表性厂商进行分析。</p><p> 特征：需求曲线向右下方倾斜并且比较平坦（弹性比较大）</p></li><li><p>特征：两种需求曲线d和D</p><ol><li><p>关于需求曲线d</p><p> 在垄断竞争生产集团某个厂商改变产品价格，而<strong>其他厂商的产品价格都保持不变时</strong>。<br> 该厂商的产品价格和销售量之间的关系</p><p> <strong>厂商主观摄像的需求曲线——自需求曲线</strong></p></li><li><p>关于需求曲线D<br> 在垄断竞争生产集团某个厂商改变产品价格，而<strong>其他厂商的产品价格发生相同变化时</strong>。<br> 该厂商的产品价格和销售量之间的关系</p><p> <strong>符合客观规律的市场上需求曲线——比例需求曲线</strong></p></li></ol></li><li><p>d和D的关系</p></li></ol><h1 id="垄断竞争厂商的短期均衡"><a href="#垄断竞争厂商的短期均衡" class="headerlink" title="垄断竞争厂商的短期均衡"></a>垄断竞争厂商的短期均衡</h1><ol><li><p>顺势均衡</p></li><li><p>垄断竞争厂商利润最大化行为</p><p> 垄断竞争厂商面临向右下倾斜但比较完全垄断厂商平坦的需求曲线。</p><p> 按MR=MC确定产量（比例需求曲线D）</p><p> 垄断竞争厂商<strong>短期</strong>可能获得超额利润，无超额利润或亏损</p><p> 但在长期无嫦娥利润（超额利润引入新厂商，总供给增加，右下方移动），且产量水平在AC最低点左边。</p></li></ol><p>P        </p><h1 id="不同市场的比较"><a href="#不同市场的比较" class="headerlink" title="不同市场的比较"></a>不同市场的比较</h1><ol><li><p>斯威齐模型</p><p> 两个基本假设：</p><ul><li>一个寡头价格提升的时候，生于寡头不变化，提价寡头销售量减少</li><li>一个寡头价格降低的时候，其他寡头为了防止自己的市场份额缩水，所以跟着降低价格。</li></ul></li><li><p>贝特朗模型</p><p> 概述</p><ul><li>由法国数学家、经济学家贝特朗1883年提出，又称价格竞争的古诺模型</li><li><p>价格竞争：厂商之间竞争围绕价格展开，以价格为决策变化量</p><p>假设:</p></li><li><p>厂商定价时候，</p><p>推理：</p></li><li>每个厂商都有动力降价直至边际成本（为了防止自己的销售量下降）</li><li>价格等于边际成本时，每个厂商都零利润</li><li><p>会不会所有厂商都将价格设定为高于边际成本？不会，不稳定，不符合最优决策。</p><p>均衡含义：</p></li><li>价格战必定使每家企业按p=边际成本的原则来经营，长期看低成本挤走高成本</li><li>同质产品竞争必然导致价格降低至边际成本。</li></ul></li><li><p>价格领导模型</p><p> 概述：</p><p> 行业中一个或极少数几个大厂商变动价格，其他厂商随之跟进。</p><ul><li>晴雨表型：价格领导者反映整个行业成本和需求的变化</li><li><p>支配型：</p><p>支配型领导模型：<br>主导厂商考虑其他厂商的产量怎样取决于它定的价格，次要厂商像完全竞争市场那样行为，价格当作给定的，根据此安排生产。</p><p>价格接收者优先考虑，供给曲线和成本曲线的关系。</p></li></ul></li></ol><h1 id="卡特尔"><a href="#卡特尔" class="headerlink" title="卡特尔"></a>卡特尔</h1><p>卡特尔的一般表达式：</p><p>卡特尔的主要任务<br>    规定统一价格: 运用MR=MC的原则确定整个卡特尔组织的产量</p><p>比较：等边际原理</p><p>卡特尔的不稳定性：</p><ul><li>卡特尔成员有违背协议或背离默契的动机</li><li>监督上的困难与惩罚手段的缺乏</li><li>卡特尔成员违约是因为其需求曲线</li></ul><h1 id="博弈论的概念和不同类型的博弈推理过程"><a href="#博弈论的概念和不同类型的博弈推理过程" class="headerlink" title="博弈论的概念和不同类型的博弈推理过程"></a>博弈论的概念和不同类型的博弈推理过程</h1><ol><li><p>博弈论：又称对策论，是描述、分析多人对策行为的理论。经济学中应用广泛主要用来解释寡头之间的。</p></li><li><p>支付矩阵与占优策略均衡</p><p> 占优策略</p><ul><li><p>无论其他参与者采取什么策略，某参与者都存在唯一的最优策略选择，这一最优策略就是他的占优策略。</p><p>纳什均衡</p></li><li><p>相对不变<br>占优策略一定是纳什均衡，但纳什均衡不一定是占优策略</p><p>囚徒困境</p></li><li>算是一种纳什均衡，也是占优策略。</li><li>囚徒困境说明了维持合作的困难。</li></ul></li><li><p>重复博弈</p><p> 重复博弈——动态博弈的一种特殊情况</p><ul><li>动态博弈是一种反复进行的博弈</li><li>在重复博弈中，同一个博弈被重复多次</li></ul></li></ol><h1 id="不同市场经济效率的比较"><a href="#不同市场经济效率的比较" class="headerlink" title="不同市场经济效率的比较"></a>不同市场经济效率的比较</h1><p>（容易出论述题）</p><ol><li><p><strong>经济效率</strong>是指利用经济资源的有效性</p><ul><li>高的经济效率表示对资源的充分利用</li></ul></li><li><p>不同市场的价格和产量</p><p> 表格<br> 长期和短期超额利润的问题，切线</p></li><li><p>不同市场的经济效率判断标准</p><ul><li>判断标准：P=MC</li><li>边际社会价值=边际社会成本</li></ul></li><li><p>垄断市场与技术进步两种观点</p><ul><li>阻碍技术进步：利润的长期性导致缺乏动力</li><li>促进技术进部：有足够的资金进行大规模的技术研发，技术研发有利于继续保持垄断地位。</li></ul></li></ol>]]></content>
    
    
    <categories>
      
      <category>Finance</category>
      
      <category>微观经济学</category>
      
    </categories>
    
    
    <tags>
      
      <tag>辅修</tag>
      
      <tag>微观经济学</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>金融学辅修——微观经济学笔记（五）</title>
    <link href="/post/7c50967.html"/>
    <url>/post/7c50967.html</url>
    
    <content type="html"><![CDATA[<h1 id="价格歧视"><a href="#价格歧视" class="headerlink" title="价格歧视"></a>价格歧视</h1><p>不是所有的价格差别？都是价格歧视</p><ol><li><p>价格歧视行之有效的条件</p><ul><li>必须在完全垄断的市场条件下，才能实现价格歧视，卖者可以控制价格</li><li>不同的消费群体或不同的销售市场是互相隔离的<br>  <code>这样就避免了中间商</code></li><li></li></ul></li><li><p>价格歧视的类型</p><ol><li><p>一级价格歧视</p><p> <strong>一级价格歧视</strong>也叫完全价格歧视，是指厂商对<strong>每一单位产品</strong>都按<strong>消费者愿意支付的最高价格</strong>出售，每一单位<br>产品的销售价格都不一样，不同消费者所获得的价格是不同的。</p><p> 结论：价格歧视源于对消费者剩余的掠夺</p><p> 问题：为什么难以实行</p><p> 回答：</p><ul><li>消费者很多</li><li>难以估计不同消费者的保留价格或者最高原支付价格。</li></ul></li><li><p>二级价格歧视</p><p> <strong>二级价格歧视</strong>指不同单元的产品以不同的价格出售，而购买同一数量的不同消费者都付统一价格。消费优惠，对于<br> 相同消费的消费者其购买数量相同。</p></li><li><p>三级价格歧视</p><p> <strong>三级价格歧视</strong>同一产品和服务在不同购买对象或不同时间不同市场上收取不同加个。</p><p> 三级价格歧视是<strong>价格歧视最常见的形式</strong><br> eg：富人区和穷人区，国内市场和国外市场，给学生和老年人的折扣。</p><p> 实现市场分割的条件：</p><ul><li>垄断者能够把不同市场或市场的各个部分有效分割</li><li><p>均衡条件：利润函数对Q1，Q2求偏导数，一阶导数等于0，可得边际成本MC=MR1=MR2</p><p>三级价格歧视与需求弹性：<br>需求弹性较大的定较低价格，需求弹性较小的定高价格。弹性相同，收取的加个就是一致的。</p><p>针对不同市场应该如何定价。</p><a id="more"></a></li></ul></li></ol></li><li><p>其他形式的加个策略</p><ol><li><p>二部定价</p><p> 垄断厂商要求消费者先付费以获得商品的购买权，然后再要求为每一单位该商品支付额外的费用。</p></li><li><p>捆绑销售</p><p> 捆绑销售：捆绑销售是指厂商要求客户购买某种商品的同时也不许购买他的另一种产品。</p><p> ？捆绑系数</p></li></ol></li><li><p>自然垄断和政府管制</p><ul><li><p>由来：</p><p>  FC大但是VC小的行业，一个厂商的生产能力即可满足全部市场的需求，若有多个企业经营，造成资源浪费</p></li><li><p>特点：</p><ul><li>存在规模报酬递增，所以AC曲线呈现下降状态</li><li>高价格Pm，高利润、低产出Qm、低效率</li></ul></li><li>低效率的解决：政府管制</li><li>管制定价：</li></ul></li><li><p>垄断厂商的产量决定和效率评价</p></li></ol>]]></content>
    
    
    <categories>
      
      <category>Finance</category>
      
      <category>微观经济学</category>
      
    </categories>
    
    
    <tags>
      
      <tag>辅修</tag>
      
      <tag>微观经济学</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>金融学辅修——金融学笔记（九）</title>
    <link href="/post/bd36a30f.html"/>
    <url>/post/bd36a30f.html</url>
    
    <content type="html"><![CDATA[<h1 id="第七章-金融市场体系"><a href="#第七章-金融市场体系" class="headerlink" title="第七章 金融市场体系"></a>第七章 金融市场体系</h1><h2 id="第一节-金融市场概述"><a href="#第一节-金融市场概述" class="headerlink" title="第一节 金融市场概述"></a>第一节 金融市场概述</h2><p>概念引出：生产单位、消费单位、产品市场、要素四场四元组。支付的流动、收入的流动，所有的货币资金的流动<br>金融资产的交换都在金融市场中进行</p><ol><li><p>金融市场的定义</p><blockquote><p>定义：指经济主体之间为实现一定的目的，通过一定的交易方式进行各种金融叫资产交易的场所、机制<br>和行为的综合。</p></blockquote><p>最直接的理解——“进行金融资产或金融工具交易的市场”</p><p>“金融资产”——能够为持有者带来预期收益且具有特定权利归属关系的金融工具</p><p>“市场”——有形和无形之分</p><p>市场的真正含义——不在于场所，而在于机制</p><p>交易方式+场所+机制：既包括有组织的有形场所也包括分散在不同地点、主要采用现代通讯手段进行的、没有<br>统一组织、依据共同约定的惯例和规则、以协议方式进行的金融交易。</p><p>各种金融资产交易：</p><ol><li><p>狭义的金融市场</p><blockquote><p>定义： 指货币资金借贷和金融工具交易的场所、机制与行为的总和。</p></blockquote><p>最狭义的理解主要是进行有价证券交易的场所、机制与行为的综合。更一般的情况下特指证券市场（股票<br>市场和债券市场）。</p></li></ol></li><li><p>金融市场交易主体</p><p>指为实现一定的目的而进行金融交易的经济主体，包括参与交易的<strong>家庭、非金融企业、政府和各类金融<br>机构</strong></p><ul><li>分为专门</li></ul></li><li><p>金融市场的</p></li></ol><p>4) 金融市场的交易媒体</p><p>   金融市场媒体：是指在金融市场上充当交易媒介、从事交易或促使交易完成的组织、机构或个人。金融市场媒体<br>   同金融市场主体一样，都是金融市场的参与者。</p><p>   佣金支付，促进交易</p><p>5) 金融市场的交易价格</p><p>6) 金融市场的交易方式</p><p>   主要类型：</p><ol><li><p>交易所方式：固定场所、有组织、有制度，集中进行公开竞价的交易方式，主要表现为“多对多”。</p></li><li><p>柜台交易方式：在各金融机构柜台上买卖双方进行面议、分散交易的方式。表现为“一对一”。</p></li><li><p>场外交易方式：既没有固定的交易场所，也不直接接触，而主要是借助电讯手段来完成交易的方式。<br>表现为“一对多”。</p></li></ol><p>7) 金融市场的监管主体</p><p>   金融监管体制：指金融监管当局对金融机构和金融市场施加影响的机制</p>]]></content>
    
    
    <categories>
      
      <category>Finance</category>
      
      <category>金融学</category>
      
    </categories>
    
    
    <tags>
      
      <tag>辅修</tag>
      
      <tag>金融学</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>【HDU-1829】解题报告（带权并查集）</title>
    <link href="/post/792e36ed.html"/>
    <url>/post/792e36ed.html</url>
    
    <content type="html"><![CDATA[<h1 id="原始题目"><a href="#原始题目" class="headerlink" title="原始题目"></a>原始题目</h1><h2 id="A-Bug’s-Life"><a href="#A-Bug’s-Life" class="headerlink" title="A Bug’s Life"></a>A Bug’s Life</h2><ul><li>Time Limit: 15000/5000 MS (Java/Others)    </li><li>Memory Limit: 32768/32768 K (Java/Others)</li><li>Total Submission(s): 20239    </li><li>Accepted Submission(s): 6472</li></ul><h3 id="Problem-Description"><a href="#Problem-Description" class="headerlink" title="Problem Description"></a>Problem Description</h3><ul><li><p>Background </p><p>  Professor Hopper is researching the sexual behavior of a rare species of bugs. He assumes that they feature two different genders and that they only interact with bugs of the opposite gender. In his experiment, individual bugs and their interactions were easy to identify, because numbers were printed on their backs. </p></li><li><p>Problem </p><p>  Given a list of bug interactions, decide whether the experiment supports his assumption of two genders with no homosexual bugs or if it contains some bug interactions that falsify it.</p></li></ul><a id="more"></a><h3 id="Input"><a href="#Input" class="headerlink" title="Input"></a>Input</h3><p>The first line of the input contains the number of scenarios. Each scenario starts with one line giving the number of bugs (at least one, and up to 2000) and the number of interactions (up to 1000000) separated by a single space. In the following lines, each interaction is given in the form of two distinct bug numbers separated by a single space. Bugs are numbered consecutively starting from one.</p><h3 id="Output"><a href="#Output" class="headerlink" title="Output"></a>Output</h3><p>The output for every scenario is a line containing “Scenario #i:”, where i is the number of the scenario starting at 1, followed by one line saying either “No suspicious bugs found!” if the experiment is consistent with his assumption about the bugs’ sexual behavior, or “Suspicious bugs found!” if Professor Hopper’s assumption is definitely wrong.</p><h3 id="Sample-Input"><a href="#Sample-Input" class="headerlink" title="Sample Input"></a>Sample Input</h3><pre><code>23 31 22 31 34 21 23 4</code></pre><h3 id="Sample-Output"><a href="#Sample-Output" class="headerlink" title="Sample Output"></a>Sample Output</h3><pre><code>Scenario #1:Suspicious bugs found!Scenario #2:No suspicious bugs found!</code></pre><h3 id="Hint"><a href="#Hint" class="headerlink" title="Hint"></a>Hint</h3><p>Huge input,scanf is recommended.</p><h3 id="Source"><a href="#Source" class="headerlink" title="Source"></a>Source</h3><p>TUD Programming Contest 2005, Darmstadt, Germany</p><h3 id="Recommend"><a href="#Recommend" class="headerlink" title="Recommend"></a>Recommend</h3><p>linle</p><h1 id="题目大意"><a href="#题目大意" class="headerlink" title="题目大意"></a>题目大意</h1><p>一种虫子具有两种性别，如果假定虫子只跟异性交配，给出交配的虫子号码，判断是否符合假设（即是否存在<br>同性交配的虫子）。</p><h1 id="解题思路"><a href="#解题思路" class="headerlink" title="解题思路"></a>解题思路</h1><ul><li>二元关系的带权并查集（或者称之为二元种类并查集）</li></ul><h1 id="解题代码"><a href="#解题代码" class="headerlink" title="解题代码"></a>解题代码</h1><pre><code class="hljs C++"><span class="hljs-meta">#<span class="hljs-meta-keyword">include</span><span class="hljs-meta-string">&lt;cstdio&gt;</span></span><span class="hljs-meta">#<span class="hljs-meta-keyword">include</span><span class="hljs-meta-string">&lt;cstring&gt;</span></span><span class="hljs-meta">#<span class="hljs-meta-keyword">include</span><span class="hljs-meta-string">&lt;cmath&gt;</span></span><span class="hljs-meta">#<span class="hljs-meta-keyword">include</span><span class="hljs-meta-string">&lt;iostream&gt;</span></span><span class="hljs-meta">#<span class="hljs-meta-keyword">include</span><span class="hljs-meta-string">&lt;iomanip&gt;</span></span><span class="hljs-meta">#<span class="hljs-meta-keyword">include</span><span class="hljs-meta-string">&lt;set&gt;</span></span><span class="hljs-meta">#<span class="hljs-meta-keyword">include</span><span class="hljs-meta-string">&lt;queue&gt;</span></span><span class="hljs-meta">#<span class="hljs-meta-keyword">include</span><span class="hljs-meta-string">&lt;unordered_map&gt;</span></span><span class="hljs-meta">#<span class="hljs-meta-keyword">include</span><span class="hljs-meta-string">&lt;string&gt;</span></span><span class="hljs-meta">#<span class="hljs-meta-keyword">include</span><span class="hljs-meta-string">&lt;sstream&gt;</span></span><span class="hljs-keyword">using</span> <span class="hljs-keyword">namespace</span> <span class="hljs-built_in">std</span>;<span class="hljs-keyword">const</span> <span class="hljs-keyword">int</span> maxn=<span class="hljs-number">1e5</span>+<span class="hljs-number">5</span>;<span class="hljs-keyword">const</span> <span class="hljs-keyword">int</span> maxm=<span class="hljs-number">1e5</span>+<span class="hljs-number">5</span>;<span class="hljs-keyword">const</span> <span class="hljs-keyword">int</span> maxl=<span class="hljs-number">26</span>;<span class="hljs-keyword">typedef</span> <span class="hljs-keyword">long</span> <span class="hljs-keyword">long</span> ll;<span class="hljs-keyword">typedef</span> <span class="hljs-keyword">unsigned</span> <span class="hljs-keyword">long</span> <span class="hljs-keyword">long</span> ull;<span class="hljs-keyword">typedef</span> <span class="hljs-built_in">vector</span>&lt;<span class="hljs-keyword">int</span>&gt; vi;<span class="hljs-keyword">typedef</span> pair&lt;<span class="hljs-keyword">int</span>, <span class="hljs-keyword">int</span>&gt; pii;<span class="hljs-keyword">typedef</span> pair&lt;<span class="hljs-built_in">string</span>,<span class="hljs-built_in">string</span>&gt; pss;<span class="hljs-meta">#<span class="hljs-meta-keyword">define</span> rep(i,a,n) for(int i=a;i&lt;n;++i)</span><span class="hljs-meta">#<span class="hljs-meta-keyword">define</span> per(i,a,n) for(int i=n-1;i&gt;=a;--i)</span><span class="hljs-meta">#<span class="hljs-meta-keyword">define</span> fi first</span><span class="hljs-meta">#<span class="hljs-meta-keyword">define</span> se second</span><span class="hljs-meta">#<span class="hljs-meta-keyword">define</span> pb push_back</span><span class="hljs-meta">#<span class="hljs-meta-keyword">define</span> np next_permutation</span><span class="hljs-meta">#<span class="hljs-meta-keyword">define</span> pb push_back</span><span class="hljs-meta">#<span class="hljs-meta-keyword">define</span> INF 0x3f3f3f3f</span><span class="hljs-meta">#<span class="hljs-meta-keyword">define</span> EPS 1e-8</span><span class="hljs-keyword">int</span> fa[maxn],cnt[maxn],relate[maxn];<span class="hljs-keyword">int</span> n,t,m;<span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">init</span><span class="hljs-params">()</span></span>&#123;    rep(i,<span class="hljs-number">0</span>,maxn)&#123;        fa[i]=i;        cnt[i]=<span class="hljs-number">1</span>;        relate[i]=<span class="hljs-number">0</span>;    &#125;&#125;<span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">find</span><span class="hljs-params">(<span class="hljs-keyword">int</span> x)</span></span>&#123;    <span class="hljs-keyword">if</span>(x==fa[x]) <span class="hljs-keyword">return</span> x;    <span class="hljs-keyword">else</span>&#123;        <span class="hljs-keyword">int</span> temp=fa[x];        fa[x]=find(fa[x]);        relate[x]=(relate[x]+relate[temp])%<span class="hljs-number">2</span>;        <span class="hljs-keyword">return</span> fa[x];    &#125;&#125;<span class="hljs-keyword">int</span> flag;<span class="hljs-function"><span class="hljs-keyword">bool</span> <span class="hljs-title">merge</span><span class="hljs-params">(<span class="hljs-keyword">int</span> x,<span class="hljs-keyword">int</span> y)</span></span>&#123;    <span class="hljs-keyword">int</span> fx=find(x);    <span class="hljs-keyword">int</span> fy=find(y);    <span class="hljs-keyword">if</span>(fx==fy)&#123;        <span class="hljs-comment">//已有关系</span>        <span class="hljs-keyword">return</span> relate[x]==relate[y];    &#125;    <span class="hljs-keyword">else</span>&#123;        fa[fx]=fy;        <span class="hljs-keyword">int</span> temp=(<span class="hljs-number">1</span>+relate[y])%<span class="hljs-number">2</span>;        relate[fx]=(temp+<span class="hljs-number">2</span>-relate[x])%<span class="hljs-number">2</span>;        <span class="hljs-keyword">return</span> <span class="hljs-literal">false</span>;    &#125;&#125;<span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span>&#123;    <span class="hljs-built_in">scanf</span>(<span class="hljs-string">"%d"</span>,&amp;t);    rep(j,<span class="hljs-number">1</span>,t+<span class="hljs-number">1</span>)&#123;        init();        <span class="hljs-built_in">scanf</span>(<span class="hljs-string">"%d%d"</span>,&amp;n,&amp;m);        flag=<span class="hljs-literal">false</span>;        <span class="hljs-keyword">int</span> a,b;        rep(i,<span class="hljs-number">0</span>,m)&#123;            <span class="hljs-built_in">scanf</span>(<span class="hljs-string">"%d%d"</span>,&amp;a,&amp;b);            <span class="hljs-keyword">if</span>(flag) <span class="hljs-keyword">continue</span>;            flag = merge(a,b);        &#125;        <span class="hljs-built_in">printf</span>(<span class="hljs-string">"Scenario #%d:\n"</span>,j);        <span class="hljs-keyword">if</span>(flag) <span class="hljs-built_in">printf</span>(<span class="hljs-string">"Suspicious bugs found!\n"</span>);        <span class="hljs-keyword">else</span> <span class="hljs-built_in">printf</span>(<span class="hljs-string">"No suspicious bugs found!\n"</span>);        <span class="hljs-built_in">printf</span>(<span class="hljs-string">"\n"</span>);    &#125;&#125;</code></pre><h1 id="收获与反思"><a href="#收获与反思" class="headerlink" title="收获与反思"></a>收获与反思</h1><ul><li>手敲并查集和带权并查集，注意输出格式，PE了两次。</li></ul>]]></content>
    
    
    <categories>
      
      <category>Computer Science</category>
      
      <category>ACM</category>
      
      <category>HDU</category>
      
    </categories>
    
    
    <tags>
      
      <tag>ACM</tag>
      
      <tag>HDU</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>【POJ-1182】解题报告（带权并查集）</title>
    <link href="/post/cd41dfb7.html"/>
    <url>/post/cd41dfb7.html</url>
    
    <content type="html"><![CDATA[<h1 id="原始题目"><a href="#原始题目" class="headerlink" title="原始题目"></a>原始题目</h1><h2 id="食物链"><a href="#食物链" class="headerlink" title="食物链"></a>食物链</h2><ul><li>Time Limit: 1000MS        </li><li>Memory Limit: 10000K</li><li>Total Submissions: 95522        </li><li>Accepted: 28832</li></ul><h3 id="Description"><a href="#Description" class="headerlink" title="Description"></a>Description</h3><p>动物王国中有三类动物A,B,C，这三类动物的食物链构成了有趣的环形。A吃B， B吃C，C吃A。<br>现有N个动物，以1－N编号。每个动物都是A,B,C中的一种，但是我们并不知道它到底是哪一种。<br>有人用两种说法对这N个动物所构成的食物链关系进行描述：<br>第一种说法是”1 X Y”，表示X和Y是同类。<br>第二种说法是”2 X Y”，表示X吃Y。<br>此人对N个动物，用上述两种说法，一句接一句地说出K句话，这K句话有的是真的，有的是假的。当一句话满足下列三条之一时，这句话就是假话，否则就是真话。 </p><ol><li><p>当前的话与前面的某些真的话冲突，就是假话； </p></li><li><p>当前的话中X或Y比N大，就是假话； </p></li><li><p>当前的话表示X吃X，就是假话。 </p></li></ol><p>你的任务是根据给定的N（1 &lt;= N &lt;= 50,000）和K句话（0 &lt;= K &lt;= 100,000），输出假话的总数。<br><a id="more"></a></p><h3 id="Input"><a href="#Input" class="headerlink" title="Input"></a>Input</h3><p>第一行是两个整数N和K，以一个空格分隔。 </p><p>以下K行每行是三个正整数 D，X，Y，两数之间用一个空格隔开，其中D表示说法的种类。 </p><ul><li><p>若D=1，则表示X和Y是同类。 </p></li><li><p>若D=2，则表示X吃Y。</p></li></ul><h3 id="Output"><a href="#Output" class="headerlink" title="Output"></a>Output</h3><p>只有一个整数，表示假话的数目。</p><h3 id="Sample-Input"><a href="#Sample-Input" class="headerlink" title="Sample Input"></a>Sample Input</h3><pre><code>100 71 101 1 2 1 22 2 3 2 3 3 1 1 3 2 3 1 1 5 5</code></pre><h3 id="Sample-Output"><a href="#Sample-Output" class="headerlink" title="Sample Output"></a>Sample Output</h3><pre><code>3</code></pre><h3 id="Source"><a href="#Source" class="headerlink" title="Source"></a>Source</h3><p>Noi 01</p><h1 id="题目大意"><a href="#题目大意" class="headerlink" title="题目大意"></a>题目大意</h1><p>如题</p><h1 id="解题思路"><a href="#解题思路" class="headerlink" title="解题思路"></a>解题思路</h1><ul><li>不仅要储存集合的关系，且要表示集合间相互元素的关系，关系可合并（推导），考虑带权并查集</li><li><p>维护一个relate数组，$relate[i]$表示i对根结点的关系。</p><ul><li>0：与根同类</li><li>1：吃根</li><li>2：被根吃</li></ul></li><li><p>推导规则（由于循环食物链，考虑模数关系）：</p><ul><li>A对B的关系为x，B对C的关系为y，则A对C的关系为$(x+y)%3$</li><li>A对B的关系为x，A对C的关系为y，则B对C的关系为$(y-x+3)%3$</li></ul></li></ul><h1 id="解题代码"><a href="#解题代码" class="headerlink" title="解题代码"></a>解题代码</h1><pre><code class="hljs C++"><span class="hljs-meta">#<span class="hljs-meta-keyword">include</span> <span class="hljs-meta-string">&lt;cstdio&gt;</span></span><span class="hljs-meta">#<span class="hljs-meta-keyword">include</span> <span class="hljs-meta-string">&lt;cstring&gt;</span></span><span class="hljs-meta">#<span class="hljs-meta-keyword">include</span> <span class="hljs-meta-string">&lt;iostream&gt;</span></span><span class="hljs-meta">#<span class="hljs-meta-keyword">include</span> <span class="hljs-meta-string">&lt;iomanip&gt;</span></span><span class="hljs-meta">#<span class="hljs-meta-keyword">include</span> <span class="hljs-meta-string">&lt;string&gt;</span></span><span class="hljs-meta">#<span class="hljs-meta-keyword">include</span> <span class="hljs-meta-string">&lt;stack&gt;</span></span><span class="hljs-meta">#<span class="hljs-meta-keyword">include</span> <span class="hljs-meta-string">&lt;queue&gt;</span></span><span class="hljs-meta">#<span class="hljs-meta-keyword">include</span> <span class="hljs-meta-string">&lt;vector&gt;</span></span><span class="hljs-meta">#<span class="hljs-meta-keyword">include</span> <span class="hljs-meta-string">&lt;set&gt;</span></span><span class="hljs-meta">#<span class="hljs-meta-keyword">include</span> <span class="hljs-meta-string">&lt;cmath&gt;</span></span><span class="hljs-meta">#<span class="hljs-meta-keyword">include</span> <span class="hljs-meta-string">&lt;list&gt;</span></span><span class="hljs-keyword">using</span> <span class="hljs-keyword">namespace</span> <span class="hljs-built_in">std</span>;<span class="hljs-keyword">const</span> <span class="hljs-keyword">int</span> maxn=<span class="hljs-number">1e5</span>+<span class="hljs-number">5</span>;<span class="hljs-keyword">const</span> <span class="hljs-keyword">int</span> maxm=<span class="hljs-number">1e5</span>+<span class="hljs-number">5</span>;<span class="hljs-keyword">typedef</span> <span class="hljs-keyword">long</span> <span class="hljs-keyword">long</span> ll;<span class="hljs-keyword">typedef</span> <span class="hljs-keyword">unsigned</span> <span class="hljs-keyword">long</span> <span class="hljs-keyword">long</span> ull;<span class="hljs-keyword">typedef</span> <span class="hljs-built_in">vector</span>&lt;<span class="hljs-keyword">int</span>&gt; vi;<span class="hljs-keyword">typedef</span> pair&lt;<span class="hljs-keyword">int</span>,<span class="hljs-keyword">int</span>&gt; pii;<span class="hljs-keyword">typedef</span> pair&lt;<span class="hljs-built_in">string</span>,<span class="hljs-built_in">string</span>&gt; pss;<span class="hljs-meta">#<span class="hljs-meta-keyword">define</span> rep(i,a,n) for(int i=a;i&lt;n;++i)</span><span class="hljs-meta">#<span class="hljs-meta-keyword">define</span> per(i,a,n) for(int i=n-1;i&gt;=a;--i)</span><span class="hljs-meta">#<span class="hljs-meta-keyword">define</span> fi first</span><span class="hljs-meta">#<span class="hljs-meta-keyword">define</span> se second</span><span class="hljs-meta">#<span class="hljs-meta-keyword">define</span> mp make_pair</span><span class="hljs-meta">#<span class="hljs-meta-keyword">define</span> np next_permutation</span><span class="hljs-meta">#<span class="hljs-meta-keyword">define</span> pb push_back</span><span class="hljs-meta">#<span class="hljs-meta-keyword">define</span> INF 0x3f3f3f3f</span><span class="hljs-meta">#<span class="hljs-meta-keyword">define</span> EPS 1e-8</span><span class="hljs-meta">#<span class="hljs-meta-keyword">define</span> cl(x,a) memset(x,a,sizeof(x))</span><span class="hljs-meta">#<span class="hljs-meta-keyword">define</span> all(x) x.bein(),x.end()</span><span class="hljs-keyword">const</span> <span class="hljs-keyword">int</span> maxl=<span class="hljs-number">26</span>;<span class="hljs-keyword">int</span> n,k,d,x,y;<span class="hljs-keyword">int</span> fa[maxn],relate[maxn];<span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">init</span><span class="hljs-params">()</span></span>&#123;    rep(i,<span class="hljs-number">0</span>,maxn)&#123;        fa[i]=i;        relate[i]=<span class="hljs-number">0</span>;    &#125;&#125;<span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">find</span><span class="hljs-params">(<span class="hljs-keyword">int</span> x)</span></span>&#123;    <span class="hljs-keyword">if</span>(fa[x]==x)&#123;        <span class="hljs-keyword">return</span> x;    &#125;    <span class="hljs-keyword">else</span> &#123;        <span class="hljs-keyword">int</span> temp=fa[x];        fa[x]=find(fa[x]);        relate[x]=(relate[x]+relate[temp])%<span class="hljs-number">3</span>;        <span class="hljs-keyword">return</span> fa[x];    &#125;&#125;<span class="hljs-function"><span class="hljs-keyword">bool</span> <span class="hljs-title">merge</span><span class="hljs-params">(<span class="hljs-keyword">int</span> r, <span class="hljs-keyword">int</span> x, <span class="hljs-keyword">int</span> y)</span></span>&#123;    <span class="hljs-keyword">int</span> fx= find(x);    <span class="hljs-keyword">int</span> fy=find(y);    <span class="hljs-keyword">if</span>(fx==fy)&#123;        <span class="hljs-keyword">if</span>((relate[x]-relate[y]+<span class="hljs-number">3</span>)%<span class="hljs-number">3</span>==d) <span class="hljs-keyword">return</span> <span class="hljs-literal">true</span>;        <span class="hljs-keyword">else</span> <span class="hljs-keyword">return</span> <span class="hljs-literal">false</span>;    &#125;    <span class="hljs-keyword">else</span>&#123;        fa[fx]=fy;        relate[fx]=(r+relate[y]-relate[x]+<span class="hljs-number">3</span>)%<span class="hljs-number">3</span>;        <span class="hljs-keyword">return</span> <span class="hljs-literal">true</span>;    &#125;&#125;<span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span>&#123;    <span class="hljs-built_in">scanf</span>(<span class="hljs-string">"%d%d"</span>,&amp;n,&amp;k);    init();    <span class="hljs-keyword">int</span> a,b,c,ccnt=<span class="hljs-number">0</span>;    rep(i,<span class="hljs-number">0</span>,k)&#123;        <span class="hljs-built_in">scanf</span>(<span class="hljs-string">"%d%d%d"</span>,&amp;d,&amp;x,&amp;y);        d--;        <span class="hljs-keyword">if</span>(x&gt;n || y&gt;n )&#123;            ccnt++;            <span class="hljs-keyword">continue</span>;        &#125;        <span class="hljs-keyword">if</span>(d &amp;&amp; x==y)&#123;            ccnt++;            <span class="hljs-keyword">continue</span>;        &#125;        <span class="hljs-keyword">if</span>(merge(d,x,y)==<span class="hljs-literal">false</span>) ccnt++;    &#125;    <span class="hljs-built_in">printf</span>(<span class="hljs-string">"%d\n"</span>,ccnt);&#125;</code></pre><h1 id="收获与反思"><a href="#收获与反思" class="headerlink" title="收获与反思"></a>收获与反思</h1><ul><li>并查集知识待补充。</li></ul>]]></content>
    
    
    <categories>
      
      <category>Computer Science</category>
      
      <category>ACM</category>
      
      <category>LeetCode</category>
      
    </categories>
    
    
    <tags>
      
      <tag>ACM</tag>
      
      <tag>LeetCode</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>【HDU-1272】解题报告（并查集，集合数量）</title>
    <link href="/post/4dc7502.html"/>
    <url>/post/4dc7502.html</url>
    
    <content type="html"><![CDATA[<h1 id="原始题目"><a href="#原始题目" class="headerlink" title="原始题目"></a>原始题目</h1><h2 id="小希的迷宫"><a href="#小希的迷宫" class="headerlink" title="小希的迷宫"></a>小希的迷宫</h2><ul><li>Time Limit: 2000/1000 MS (Java/Others)</li><li>Memory Limit: 65536/32768 K (Java/Others)</li><li>Total Submission(s): 67235</li><li>Accepted Submission(s): 21092</li></ul><h3 id="Problem-Description"><a href="#Problem-Description" class="headerlink" title="Problem Description"></a>Problem Description</h3><p>上次Gardon的迷宫城堡小希玩了很久（见Problem B），现在她也想设计一个迷宫让Gardon来走。但是她设计迷宫的思路不一样，首先她认为所有的通道都应该是双向连通的，就是说如果有一个通道连通了房间A和B，那么既可以通过它从房间A走到房间B，也可以通过它从房间B走到房间A，为了提高难度，小希希望任意两个房间有且仅有一条路径可以相通（除非走了回头路）。小希现在把她的设计图给你，让你帮忙判断她的设计图是否符合她的设计思路。比如下面的例子，前两个是符合条件的，但是最后一个却有两种方法从5到达8。 </p><p><img src="https://eddyblog.oss-cn-shenzhen.aliyuncs.com/%E3%80%90HDU-1272%E3%80%91%E8%A7%A3%E9%A2%98%E6%8A%A5%E5%91%8A%EF%BC%88%E5%B9%B6%E6%9F%A5%E9%9B%86%EF%BC%8C%E9%9B%86%E5%90%88%E6%95%B0%E9%87%8F%EF%BC%89/1.jpg" srcset="/img/loading.gif" alt="1.jpg"></p><a id="more"></a><h3 id="Input"><a href="#Input" class="headerlink" title="Input"></a>Input</h3><p>输入包含多组数据，每组数据是一个以0 0结尾的整数对列表，表示了一条通道连接的两个房间的编号。房间的编号至少为1，且不超过100000。每两组数据之间有一个空行。<br>整个文件以两个-1结尾。</p><h3 id="Output"><a href="#Output" class="headerlink" title="Output"></a>Output</h3><p>对于输入的每一组数据，输出仅包括一行。如果该迷宫符合小希的思路，那么输出”Yes”，否则输出”No”。</p><h3 id="Sample-Input"><a href="#Sample-Input" class="headerlink" title="Sample Input"></a>Sample Input</h3><pre><code>6 8  5 3  5 2  6 45 6  0 08 1  7 3  6 2  8 9  7 57 4  7 8  7 6  0 03 8  6 8  6 45 3  5 6  5 2  0 0-1 -1</code></pre><h3 id="Sample-Output"><a href="#Sample-Output" class="headerlink" title="Sample Output"></a>Sample Output</h3><pre><code>YesYesNo</code></pre><h3 id="Author"><a href="#Author" class="headerlink" title="Author"></a>Author</h3><p>Gardon</p><h3 id="Source"><a href="#Source" class="headerlink" title="Source"></a>Source</h3><p>HDU 2006-4 Programming Contest</p><h3 id="Recommend"><a href="#Recommend" class="headerlink" title="Recommend"></a>Recommend</h3><p>lxj</p><h1 id="题目大意"><a href="#题目大意" class="headerlink" title="题目大意"></a>题目大意</h1><p>如题</p><h1 id="解题思路"><a href="#解题思路" class="headerlink" title="解题思路"></a>解题思路</h1><p>判定条件：</p><ol><li>是否为一棵树，即两点之间是否只有一条途径。</li><li>是否包含全部点（即并查集森林大小为1）</li></ol><p>条件1判断：用标准并查集对于每次合并检查是否已在一个集合中，若在，说明已有路径，则不满足题意。</p><p>条件2判断：set储存出现的点，$fa[x]==x$来判断是否为根节点。</p><h1 id="解题代码"><a href="#解题代码" class="headerlink" title="解题代码"></a>解题代码</h1><pre><code class="hljs C++"><span class="hljs-meta">#<span class="hljs-meta-keyword">include</span> <span class="hljs-meta-string">&lt;cstdio&gt;</span></span><span class="hljs-meta">#<span class="hljs-meta-keyword">include</span> <span class="hljs-meta-string">&lt;cstring&gt;</span></span><span class="hljs-meta">#<span class="hljs-meta-keyword">include</span> <span class="hljs-meta-string">&lt;iostream&gt;</span></span><span class="hljs-meta">#<span class="hljs-meta-keyword">include</span> <span class="hljs-meta-string">&lt;set&gt;</span></span><span class="hljs-meta">#<span class="hljs-meta-keyword">include</span> <span class="hljs-meta-string">&lt;queue&gt;</span></span><span class="hljs-meta">#<span class="hljs-meta-keyword">include</span> <span class="hljs-meta-string">&lt;vector&gt;</span></span><span class="hljs-meta">#<span class="hljs-meta-keyword">include</span> <span class="hljs-meta-string">&lt;stack&gt;</span></span><span class="hljs-meta">#<span class="hljs-meta-keyword">include</span> <span class="hljs-meta-string">&lt;vector&gt;</span></span><span class="hljs-meta">#<span class="hljs-meta-keyword">include</span> <span class="hljs-meta-string">&lt;algorithm&gt;</span></span><span class="hljs-meta">#<span class="hljs-meta-keyword">include</span> <span class="hljs-meta-string">&lt;string&gt;</span></span><span class="hljs-meta">#<span class="hljs-meta-keyword">include</span> <span class="hljs-meta-string">&lt;iostream&gt;</span></span><span class="hljs-meta">#<span class="hljs-meta-keyword">include</span> <span class="hljs-meta-string">&lt;iomanip&gt;</span></span><span class="hljs-meta">#<span class="hljs-meta-keyword">include</span> <span class="hljs-meta-string">&lt;map&gt;</span></span><span class="hljs-meta">#<span class="hljs-meta-keyword">include</span> <span class="hljs-meta-string">&lt;unordered_map&gt;</span></span><span class="hljs-keyword">using</span> <span class="hljs-keyword">namespace</span> <span class="hljs-built_in">std</span>;<span class="hljs-keyword">const</span> <span class="hljs-keyword">int</span> maxn=<span class="hljs-number">1e5</span>+<span class="hljs-number">5</span>;<span class="hljs-keyword">const</span> <span class="hljs-keyword">int</span> maxm=<span class="hljs-number">1e5</span>+<span class="hljs-number">5</span>;<span class="hljs-keyword">typedef</span> <span class="hljs-keyword">long</span> <span class="hljs-keyword">long</span> ll;<span class="hljs-keyword">typedef</span> <span class="hljs-keyword">unsigned</span> <span class="hljs-keyword">long</span> <span class="hljs-keyword">long</span> ull;<span class="hljs-keyword">typedef</span> <span class="hljs-built_in">vector</span>&lt;<span class="hljs-keyword">int</span>&gt; vi;<span class="hljs-keyword">typedef</span> pair&lt;<span class="hljs-keyword">int</span>,<span class="hljs-keyword">int</span>&gt; pii;<span class="hljs-keyword">typedef</span> pair&lt;<span class="hljs-built_in">string</span>,<span class="hljs-built_in">string</span>&gt; pss;<span class="hljs-meta">#<span class="hljs-meta-keyword">define</span> rep(i,a,n) for(int i=a;i&lt;n;++i)</span><span class="hljs-meta">#<span class="hljs-meta-keyword">define</span> per(i,a,n) for(int i=n-1;i&gt;=a;--i)</span><span class="hljs-meta">#<span class="hljs-meta-keyword">define</span> cl(x,a) memset(x,a,sizeof(x))</span><span class="hljs-meta">#<span class="hljs-meta-keyword">define</span> pb push_back</span><span class="hljs-meta">#<span class="hljs-meta-keyword">define</span> np next_permutation</span><span class="hljs-meta">#<span class="hljs-meta-keyword">define</span> mp make_pair</span><span class="hljs-meta">#<span class="hljs-meta-keyword">define</span> INF 0x3f3f3f3f</span><span class="hljs-meta">#<span class="hljs-meta-keyword">define</span> EPS 1e-8</span><span class="hljs-keyword">int</span> fa[maxn],cnt[maxn];<span class="hljs-built_in">set</span> &lt;<span class="hljs-keyword">int</span>&gt; s;<span class="hljs-keyword">int</span> n,m,k,t;<span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">init</span><span class="hljs-params">()</span></span>&#123;rep(i,<span class="hljs-number">0</span>,maxn)&#123;fa[i]=i;cnt[i]=<span class="hljs-number">1</span>;&#125;s.clear();&#125;<span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">find</span><span class="hljs-params">(<span class="hljs-keyword">int</span> x)</span></span>&#123;<span class="hljs-keyword">if</span>(fa[x]==x) <span class="hljs-keyword">return</span> x;<span class="hljs-keyword">else</span> &#123;fa[x]=find(fa[x]);<span class="hljs-keyword">return</span> fa[x];&#125;&#125;<span class="hljs-function"><span class="hljs-keyword">bool</span> <span class="hljs-title">merge</span><span class="hljs-params">(<span class="hljs-keyword">int</span> x,<span class="hljs-keyword">int</span> y)</span></span>&#123;<span class="hljs-keyword">int</span> fx=find(x),fy=find(y);<span class="hljs-keyword">if</span>(fx==fy) <span class="hljs-keyword">return</span> <span class="hljs-literal">false</span>;<span class="hljs-keyword">else</span> &#123;fa[fy]=fx;cnt[fx]+=cnt[fy];<span class="hljs-keyword">return</span> <span class="hljs-literal">true</span>;&#125;&#125;<span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">check</span><span class="hljs-params">(<span class="hljs-keyword">int</span> x)</span></span>&#123;<span class="hljs-keyword">return</span> cnt[find(x)];&#125;<span class="hljs-keyword">int</span> u,v;<span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span>&#123;ios::sync_with_stdio(<span class="hljs-literal">false</span>);init();<span class="hljs-keyword">bool</span> flag= <span class="hljs-literal">true</span>;<span class="hljs-keyword">while</span>(<span class="hljs-built_in">cin</span>&gt;&gt;u&gt;&gt;v &amp;&amp; u!=<span class="hljs-number">-1</span> &amp;&amp; v!=<span class="hljs-number">-1</span>)&#123;<span class="hljs-keyword">if</span>(!u &amp;&amp; !v)&#123;            <span class="hljs-keyword">if</span>(flag)&#123;                <span class="hljs-keyword">if</span>(s.empty()) <span class="hljs-built_in">cout</span>&lt;&lt;<span class="hljs-string">"Yes"</span>&lt;&lt;<span class="hljs-built_in">endl</span>;                <span class="hljs-keyword">else</span>&#123;                    <span class="hljs-comment">//检查</span>                    <span class="hljs-built_in">set</span> &lt;<span class="hljs-keyword">int</span>&gt;::iterator it;                    <span class="hljs-keyword">int</span> ccnt=<span class="hljs-number">0</span>;                    <span class="hljs-keyword">for</span>(it=s.begin();it!=s.end();it++)&#123;                        <span class="hljs-keyword">if</span>(fa[*it]==*it) ccnt++;                    &#125;                    <span class="hljs-keyword">if</span>(ccnt==<span class="hljs-number">1</span>) <span class="hljs-built_in">cout</span>&lt;&lt;<span class="hljs-string">"Yes"</span>&lt;&lt;<span class="hljs-built_in">endl</span>;                    <span class="hljs-keyword">else</span> <span class="hljs-built_in">cout</span>&lt;&lt;<span class="hljs-string">"No"</span>&lt;&lt;<span class="hljs-built_in">endl</span>;                &#125;            &#125;            <span class="hljs-keyword">else</span> <span class="hljs-built_in">cout</span>&lt;&lt;<span class="hljs-string">"No"</span>&lt;&lt;<span class="hljs-built_in">endl</span>;            init();            flag = <span class="hljs-literal">true</span>;&#125;<span class="hljs-keyword">else</span> &#123;            s.insert(u);s.insert(v);            <span class="hljs-keyword">if</span>(merge(u,v)==<span class="hljs-literal">false</span>) flag=<span class="hljs-literal">false</span>;&#125;&#125;&#125;</code></pre><h1 id="收获与反思"><a href="#收获与反思" class="headerlink" title="收获与反思"></a>收获与反思</h1><ul><li>记录森林大小</li></ul>]]></content>
    
    
    <categories>
      
      <category>Computer Science</category>
      
      <category>ACM</category>
      
      <category>HDU</category>
      
    </categories>
    
    
    <tags>
      
      <tag>ACM</tag>
      
      <tag>HDU</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>【HDU-3172】解题报告（并查集）</title>
    <link href="/post/e78ad34c.html"/>
    <url>/post/e78ad34c.html</url>
    
    <content type="html"><![CDATA[<h1 id="原始题目"><a href="#原始题目" class="headerlink" title="原始题目"></a>原始题目</h1><h2 id="Virtual-Friends"><a href="#Virtual-Friends" class="headerlink" title="Virtual Friends"></a>Virtual Friends</h2><ul><li>Time Limit: 4000/2000 MS (Java/Others)    </li><li>Memory Limit: 32768/32768 K (Java/Others)</li><li>Total Submission(s): 11465    </li><li>Accepted Submission(s): 3345</li></ul><h3 id="Problem-Description"><a href="#Problem-Description" class="headerlink" title="Problem Description"></a>Problem Description</h3><p>These days, you can do all sorts of things online. For example, you can use various websites to make virtual friends. For some people, growing their social network (their friends, their friends’ friends, their friends’ friends’ friends, and so on), has become an addictive hobby. Just as some people collect stamps, other people collect virtual friends. </p><p>Your task is to observe the interactions on such a website and keep track of the size of each person’s network. </p><p>Assume that every friendship is mutual. If Fred is Barney’s friend, then Barney is also Fred’s friend.</p><a id="more"></a><h3 id="Input"><a href="#Input" class="headerlink" title="Input"></a>Input</h3><p>Input file contains multiple test cases. </p><p>The first line of each case indicates the number of test friendship nest.</p><p>Each friendship nest begins with a line containing an integer F, the number of friendships formed in this frindship nest, which is no more than 100 000. Each of the following F lines contains the names of two people who have just become friends, separated by a space. A name is a string of 1 to 20 letters (uppercase or lowercase).</p><h3 id="Output"><a href="#Output" class="headerlink" title="Output"></a>Output</h3><p>Whenever a friendship is formed, print a line containing one integer, the number of people in the social network of the two people who have just become friends.</p><h3 id="Sample-Input"><a href="#Sample-Input" class="headerlink" title="Sample Input"></a>Sample Input</h3><pre><code>13Fred BarneyBarney BettyBetty Wilma</code></pre><h3 id="Sample-Output"><a href="#Sample-Output" class="headerlink" title="Sample Output"></a>Sample Output</h3><pre><code>234</code></pre><h3 id="Source"><a href="#Source" class="headerlink" title="Source"></a>Source</h3><p>University of Waterloo Local Contest 2008.09</p><h3 id="Recommend"><a href="#Recommend" class="headerlink" title="Recommend"></a>Recommend</h3><p>chenrui</p><h1 id="题目大意"><a href="#题目大意" class="headerlink" title="题目大意"></a>题目大意</h1><p>朋友圈，给出$n$组朋友，每次输入两个人名，表示两个人成为朋友，同时输出当下两个人朋友圈的总大小。</p><h1 id="解题思路"><a href="#解题思路" class="headerlink" title="解题思路"></a>解题思路</h1><ul><li>利用map(unordered_map)存储string-&gt;int的映射。</li><li>标准并查集，维护集合的大小。</li><li>每次merge两人所代表的集合，输出大小即可。</li></ul><h1 id="解题代码"><a href="#解题代码" class="headerlink" title="解题代码"></a>解题代码</h1><pre><code class="hljs C++"><span class="hljs-meta">#<span class="hljs-meta-keyword">include</span> <span class="hljs-meta-string">&lt;cstdio&gt;</span></span><span class="hljs-meta">#<span class="hljs-meta-keyword">include</span> <span class="hljs-meta-string">&lt;cstring&gt;</span></span><span class="hljs-meta">#<span class="hljs-meta-keyword">include</span> <span class="hljs-meta-string">&lt;iostream&gt;</span></span><span class="hljs-meta">#<span class="hljs-meta-keyword">include</span> <span class="hljs-meta-string">&lt;set&gt;</span></span><span class="hljs-meta">#<span class="hljs-meta-keyword">include</span> <span class="hljs-meta-string">&lt;queue&gt;</span></span><span class="hljs-meta">#<span class="hljs-meta-keyword">include</span> <span class="hljs-meta-string">&lt;vector&gt;</span></span><span class="hljs-meta">#<span class="hljs-meta-keyword">include</span> <span class="hljs-meta-string">&lt;stack&gt;</span></span><span class="hljs-meta">#<span class="hljs-meta-keyword">include</span> <span class="hljs-meta-string">&lt;vector&gt;</span></span><span class="hljs-meta">#<span class="hljs-meta-keyword">include</span> <span class="hljs-meta-string">&lt;algorithm&gt;</span></span><span class="hljs-meta">#<span class="hljs-meta-keyword">include</span> <span class="hljs-meta-string">&lt;string&gt;</span></span><span class="hljs-meta">#<span class="hljs-meta-keyword">include</span> <span class="hljs-meta-string">&lt;iostream&gt;</span></span><span class="hljs-meta">#<span class="hljs-meta-keyword">include</span> <span class="hljs-meta-string">&lt;iomanip&gt;</span></span><span class="hljs-meta">#<span class="hljs-meta-keyword">include</span> <span class="hljs-meta-string">&lt;map&gt;</span></span><span class="hljs-meta">#<span class="hljs-meta-keyword">include</span> <span class="hljs-meta-string">&lt;unordered_map&gt;</span></span><span class="hljs-keyword">using</span> <span class="hljs-keyword">namespace</span> <span class="hljs-built_in">std</span>;<span class="hljs-keyword">const</span> <span class="hljs-keyword">int</span> maxn=<span class="hljs-number">1e5</span>+<span class="hljs-number">5</span>;<span class="hljs-keyword">const</span> <span class="hljs-keyword">int</span> maxm=<span class="hljs-number">1e5</span>+<span class="hljs-number">5</span>;<span class="hljs-keyword">typedef</span> <span class="hljs-keyword">long</span> <span class="hljs-keyword">long</span> ll;<span class="hljs-keyword">typedef</span> <span class="hljs-keyword">unsigned</span> <span class="hljs-keyword">long</span> <span class="hljs-keyword">long</span> ull;<span class="hljs-keyword">typedef</span> <span class="hljs-built_in">vector</span>&lt;<span class="hljs-keyword">int</span>&gt; vi;<span class="hljs-keyword">typedef</span> pair&lt;<span class="hljs-keyword">int</span>,<span class="hljs-keyword">int</span>&gt; pii;<span class="hljs-keyword">typedef</span> pair&lt;<span class="hljs-built_in">string</span>,<span class="hljs-built_in">string</span>&gt; pss;<span class="hljs-meta">#<span class="hljs-meta-keyword">define</span> rep(i,a,n) for(int i=a;i&lt;n;++i)</span><span class="hljs-meta">#<span class="hljs-meta-keyword">define</span> per(i,a,n) for(int i=n-1;i&gt;=a;--i)</span><span class="hljs-meta">#<span class="hljs-meta-keyword">define</span> cl(x,a) memset(x,a,sizeof(x))</span><span class="hljs-meta">#<span class="hljs-meta-keyword">define</span> pb push_back</span><span class="hljs-meta">#<span class="hljs-meta-keyword">define</span> np next_permutation</span><span class="hljs-meta">#<span class="hljs-meta-keyword">define</span> mp make_pair</span><span class="hljs-meta">#<span class="hljs-meta-keyword">define</span> INF 0x3f3f3f3f</span><span class="hljs-meta">#<span class="hljs-meta-keyword">define</span> EPS 1e-8</span><span class="hljs-built_in">unordered_map</span> &lt;<span class="hljs-built_in">string</span>,<span class="hljs-keyword">int</span>&gt; mmp;<span class="hljs-keyword">int</span> fa[maxn],cnt[maxn];<span class="hljs-keyword">int</span> n,m,k,t;<span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">init</span><span class="hljs-params">()</span></span>&#123;rep(i,<span class="hljs-number">0</span>,maxn)&#123;fa[i]=i;cnt[i]=<span class="hljs-number">1</span>;&#125;mmp.clear();&#125;<span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">find</span><span class="hljs-params">(<span class="hljs-keyword">int</span> x)</span></span>&#123;<span class="hljs-keyword">if</span>(fa[x]==x) <span class="hljs-keyword">return</span> x;<span class="hljs-keyword">else</span> &#123;fa[x]=find(fa[x]);<span class="hljs-keyword">return</span> fa[x];&#125;&#125;<span class="hljs-function"><span class="hljs-keyword">bool</span> <span class="hljs-title">merge</span><span class="hljs-params">(<span class="hljs-keyword">int</span> x,<span class="hljs-keyword">int</span> y)</span></span>&#123;<span class="hljs-keyword">int</span> fx=find(x),fy=find(y);<span class="hljs-keyword">if</span>(fx==fy) <span class="hljs-keyword">return</span> <span class="hljs-literal">false</span>;<span class="hljs-keyword">else</span> &#123;fa[fy]=fx;<span class="hljs-comment">//cout&lt;&lt;"fx="&lt;&lt;fx&lt;&lt;"  fy="&lt;&lt;fy&lt;&lt;endl;</span>cnt[fx]+=cnt[fy];<span class="hljs-keyword">return</span> <span class="hljs-literal">true</span>;&#125;&#125;<span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">check</span><span class="hljs-params">(<span class="hljs-keyword">int</span> x)</span></span>&#123;<span class="hljs-comment">//    cout&lt;&lt;"fa="&lt;&lt;find(x)&lt;&lt;endl;</span><span class="hljs-keyword">return</span> cnt[find(x)];&#125;<span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span>&#123;ios::sync_with_stdio(<span class="hljs-literal">false</span>);<span class="hljs-keyword">while</span>(<span class="hljs-built_in">cin</span>&gt;&gt;t)<span class="hljs-keyword">while</span>(t--)&#123;<span class="hljs-built_in">cin</span>&gt;&gt;n;init();<span class="hljs-built_in">string</span> a,b;<span class="hljs-keyword">int</span> ccnt=<span class="hljs-number">0</span>;rep(i,<span class="hljs-number">0</span>,n)&#123;<span class="hljs-built_in">cin</span>&gt;&gt;a&gt;&gt;b;<span class="hljs-keyword">if</span>(!mmp.count(a)) mmp.insert(mp(a,++ccnt));<span class="hljs-keyword">if</span>(!mmp.count(b)) mmp.insert(mp(b,++ccnt));merge(mmp[a],mmp[b]);<span class="hljs-built_in">cout</span>&lt;&lt;check(mmp[b])&lt;&lt;<span class="hljs-built_in">endl</span>;&#125;&#125;&#125;</code></pre><h1 id="收获与反思"><a href="#收获与反思" class="headerlink" title="收获与反思"></a>收获与反思</h1><ul><li>可利用unordered_map加速</li><li>并查集知识🔗待补充。</li></ul>]]></content>
    
    
    <categories>
      
      <category>Computer Science</category>
      
      <category>ACM</category>
      
      <category>HDU</category>
      
    </categories>
    
    
    <tags>
      
      <tag>ACM</tag>
      
      <tag>HDU</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>【POJ-1611】解题报告（并查集）</title>
    <link href="/post/3d71c64b.html"/>
    <url>/post/3d71c64b.html</url>
    
    <content type="html"><![CDATA[<h1 id="原始题目"><a href="#原始题目" class="headerlink" title="原始题目"></a>原始题目</h1><h2 id="The-Suspects"><a href="#The-Suspects" class="headerlink" title="The Suspects"></a>The Suspects</h2><ul><li>Time Limit: 1000MS        </li><li>Memory Limit: 20000K</li><li>Total Submissions: 51885        </li><li>Accepted: 24803</li></ul><h3 id="Description"><a href="#Description" class="headerlink" title="Description"></a>Description</h3><p>Severe acute respiratory syndrome (SARS), an atypical pneumonia of unknown aetiology, was recognized as a global threat in mid-March 2003. To minimize transmission to others, the best strategy is to separate the suspects from others.<br>In the Not-Spreading-Your-Sickness University (NSYSU), there are many student groups. Students in the same group intercommunicate with each other frequently, and a student may join several groups. To prevent the possible transmissions of SARS, the NSYSU collects the member lists of all student groups, and makes the following rule in their standard operation procedure (SOP).<br>Once a member in a group is a suspect, all members in the group are suspects.<br>However, they find that it is not easy to identify all the suspects when a student is recognized as a suspect. Your job is to write a program which finds all the suspects.</p><a id="more"></a><h3 id="Input"><a href="#Input" class="headerlink" title="Input"></a>Input</h3><p>The input file contains several cases. Each test case begins with two integers n and m in a line, where n is the number of students, and m is the number of groups. You may assume that 0 &lt; n &lt;= 30000 and 0 &lt;= m &lt;= 500. Every student is numbered by a unique integer between 0 and n−1, and initially student 0 is recognized as a suspect in all the cases. This line is followed by m member lists of the groups, one line per group. Each line begins with an integer k by itself representing the number of members in the group. Following the number of members, there are k integers representing the students in this group. All the integers in a line are separated by at least one space.<br>A case with n = 0 and m = 0 indicates the end of the input, and need not be processed.</p><h3 id="Output"><a href="#Output" class="headerlink" title="Output"></a>Output</h3><p>For each case, output the number of suspects in one line.</p><h3 id="Sample-Input"><a href="#Sample-Input" class="headerlink" title="Sample Input"></a>Sample Input</h3><pre><code>100 42 1 25 10 13 11 12 142 0 12 99 2200 21 55 1 2 3 4 51 00 0</code></pre><h3 id="Sample-Output"><a href="#Sample-Output" class="headerlink" title="Sample Output"></a>Sample Output</h3><pre><code>411</code></pre><h3 id="Source"><a href="#Source" class="headerlink" title="Source"></a>Source</h3><p>Asia Kaohsiung 2003</p><h1 id="题目大意"><a href="#题目大意" class="headerlink" title="题目大意"></a>题目大意</h1><p>为了减少SARS传播，最好的方法是将这些疑似患者区分开。现在给定一个学校里有$n$个人，$m$个学生团体，<br>同一学生团体中只要有一个疑似患者，即都被认定为疑似患者。现在统计所有的疑似患者的数量。</p><h1 id="解题思路"><a href="#解题思路" class="headerlink" title="解题思路"></a>解题思路</h1><p>标准并查集，维护一个数组cnt记录集合的大小，根节点的cnt值为集合大小。</p><p>初始化</p><pre><code>fa[i]=i; cnt[i]=1; </code></pre><p>find函数路径压缩</p><pre><code>fa[x]=find(fa[x]);  //加速下一次询问</code></pre><p>merge函数增加维护cnt</p><pre><code>cnt[fx] += cnt[fy]</code></pre><h1 id="解题代码"><a href="#解题代码" class="headerlink" title="解题代码"></a>解题代码</h1><pre><code class="hljs C++"><span class="hljs-meta">#<span class="hljs-meta-keyword">include</span> <span class="hljs-meta-string">&lt;cstdio&gt;</span></span><span class="hljs-meta">#<span class="hljs-meta-keyword">include</span> <span class="hljs-meta-string">&lt;cstring&gt;</span></span><span class="hljs-meta">#<span class="hljs-meta-keyword">include</span> <span class="hljs-meta-string">&lt;iostream&gt;</span></span><span class="hljs-meta">#<span class="hljs-meta-keyword">include</span> <span class="hljs-meta-string">&lt;set&gt;</span></span><span class="hljs-meta">#<span class="hljs-meta-keyword">include</span> <span class="hljs-meta-string">&lt;queue&gt;</span></span><span class="hljs-meta">#<span class="hljs-meta-keyword">include</span> <span class="hljs-meta-string">&lt;vector&gt;</span></span><span class="hljs-meta">#<span class="hljs-meta-keyword">include</span> <span class="hljs-meta-string">&lt;stack&gt;</span></span><span class="hljs-meta">#<span class="hljs-meta-keyword">include</span> <span class="hljs-meta-string">&lt;vector&gt;</span></span><span class="hljs-meta">#<span class="hljs-meta-keyword">include</span> <span class="hljs-meta-string">&lt;algorithm&gt;</span></span><span class="hljs-meta">#<span class="hljs-meta-keyword">include</span> <span class="hljs-meta-string">&lt;string&gt;</span></span><span class="hljs-meta">#<span class="hljs-meta-keyword">include</span> <span class="hljs-meta-string">&lt;iostream&gt;</span></span><span class="hljs-meta">#<span class="hljs-meta-keyword">include</span> <span class="hljs-meta-string">&lt;iomanip&gt;</span></span><span class="hljs-keyword">using</span> <span class="hljs-keyword">namespace</span> <span class="hljs-built_in">std</span>;<span class="hljs-keyword">const</span> <span class="hljs-keyword">int</span> maxn=<span class="hljs-number">1e5</span>+<span class="hljs-number">5</span>;<span class="hljs-keyword">const</span> <span class="hljs-keyword">int</span> maxm=<span class="hljs-number">1e5</span>+<span class="hljs-number">5</span>;<span class="hljs-keyword">typedef</span> <span class="hljs-keyword">long</span> <span class="hljs-keyword">long</span> ll;<span class="hljs-keyword">typedef</span> <span class="hljs-keyword">unsigned</span> <span class="hljs-keyword">long</span> <span class="hljs-keyword">long</span> ull;<span class="hljs-keyword">typedef</span> <span class="hljs-built_in">vector</span>&lt;<span class="hljs-keyword">int</span>&gt; vi;<span class="hljs-keyword">typedef</span> pair&lt;<span class="hljs-keyword">int</span>,<span class="hljs-keyword">int</span>&gt; pii;<span class="hljs-keyword">typedef</span> pair&lt;<span class="hljs-built_in">string</span>,<span class="hljs-built_in">string</span>&gt; pss;<span class="hljs-meta">#<span class="hljs-meta-keyword">define</span> rep(i,a,n) for(int i=a;i&lt;n;++i)</span><span class="hljs-meta">#<span class="hljs-meta-keyword">define</span> per(i,a,n) for(int i=n-1;i&gt;=a;--i)</span><span class="hljs-meta">#<span class="hljs-meta-keyword">define</span> cl(x,a) memset(x,a,sizeof(x))</span><span class="hljs-meta">#<span class="hljs-meta-keyword">define</span> pb push_back</span><span class="hljs-meta">#<span class="hljs-meta-keyword">define</span> np next_permutation</span><span class="hljs-meta">#<span class="hljs-meta-keyword">define</span> mp make_pair</span><span class="hljs-meta">#<span class="hljs-meta-keyword">define</span> INF 0x3f3f3f3f</span><span class="hljs-meta">#<span class="hljs-meta-keyword">define</span> EPS 1e-8 </span><span class="hljs-keyword">int</span> fa[maxn],cnt[maxn];<span class="hljs-keyword">int</span> n,m,k;<span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">init</span><span class="hljs-params">(<span class="hljs-keyword">int</span> n)</span></span>&#123;rep(i,<span class="hljs-number">0</span>,n)&#123;fa[i]=i;cnt[i]=<span class="hljs-number">1</span>;&#125;&#125;<span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">find</span><span class="hljs-params">(<span class="hljs-keyword">int</span> x)</span></span>&#123;<span class="hljs-keyword">if</span>(fa[x]==x) <span class="hljs-keyword">return</span> x;<span class="hljs-keyword">else</span> &#123;fa[x]=find(fa[x]);<span class="hljs-keyword">return</span> fa[x];&#125;&#125;<span class="hljs-function"><span class="hljs-keyword">bool</span> <span class="hljs-title">merge</span><span class="hljs-params">(<span class="hljs-keyword">int</span> x,<span class="hljs-keyword">int</span> y)</span></span>&#123;<span class="hljs-keyword">int</span> fx=find(x),fy=find(y);<span class="hljs-keyword">if</span>(fx==fy) <span class="hljs-keyword">return</span> <span class="hljs-literal">false</span>;<span class="hljs-keyword">else</span> &#123;fa[fy]=fx;cnt[fx]+=cnt[fy];<span class="hljs-keyword">return</span> <span class="hljs-literal">true</span>;&#125;&#125;<span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">check</span><span class="hljs-params">(<span class="hljs-keyword">int</span> x)</span></span>&#123;<span class="hljs-keyword">return</span> cnt[find(x)];&#125;<span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span>&#123;ios::sync_with_stdio(<span class="hljs-literal">false</span>);<span class="hljs-keyword">while</span>(<span class="hljs-built_in">cin</span>&gt;&gt;n&gt;&gt;m &amp;&amp; n+m)&#123;init(n);rep(i,<span class="hljs-number">0</span>,m)&#123;<span class="hljs-built_in">cin</span>&gt;&gt;k;<span class="hljs-keyword">int</span> first,temp;<span class="hljs-built_in">cin</span>&gt;&gt;first;rep(t,<span class="hljs-number">1</span>,k)&#123;<span class="hljs-built_in">cin</span>&gt;&gt;temp;merge(first,temp);&#125;&#125;<span class="hljs-comment">//cout&lt;&lt;"#";</span><span class="hljs-built_in">cout</span>&lt;&lt;check(<span class="hljs-number">0</span>)&lt;&lt;<span class="hljs-built_in">endl</span>;&#125;&#125;</code></pre><h1 id="收获与反思"><a href="#收获与反思" class="headerlink" title="收获与反思"></a>收获与反思</h1><p>待补充</p>]]></content>
    
    
    <categories>
      
      <category>Computer Science</category>
      
      <category>ACM</category>
      
      <category>POJ</category>
      
    </categories>
    
    
    <tags>
      
      <tag>ACM</tag>
      
      <tag>POJ</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>2018-12-01武汉游记</title>
    <link href="/post/a8759852.html"/>
    <url>/post/a8759852.html</url>
    
    <content type="html"><![CDATA[]]></content>
    
    
    <categories>
      
      <category>Life</category>
      
      <category>旅行</category>
      
    </categories>
    
    
    <tags>
      
      <tag>旅行</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>【CSU-2187】解题报告（维护顺序极差）</title>
    <link href="/post/7410a832.html"/>
    <url>/post/7410a832.html</url>
    
    <content type="html"><![CDATA[<h1 id="原始题目"><a href="#原始题目" class="headerlink" title="原始题目"></a>原始题目</h1><h2 id="2187-翻转游戏加强版"><a href="#2187-翻转游戏加强版" class="headerlink" title="2187: 翻转游戏加强版"></a>2187: 翻转游戏加强版</h2><ul><li>Time Limit: 1 Sec</li><li>Memory Limit: 128 Mb</li><li>Submitted: 101</li><li>Solved: 23</li></ul><h3 id="Description"><a href="#Description" class="headerlink" title="Description"></a>Description</h3><p>给当一个01串，最多可以对一段区间里的01取反一次，求最多能取得的1的个数</p><h3 id="Input"><a href="#Input" class="headerlink" title="Input"></a>Input</h3><p>多组数据，第一行为数组组数$T(T≤10)$</p><p>每组数据第一行一个整数$N(1≤N≤{10}^{6})$</p><p>第二行一个长度为$N$的01字符串</p><a id="more"></a><h3 id="Output"><a href="#Output" class="headerlink" title="Output"></a>Output</h3><p>每组数据输出一行代表答案</p><h3 id="Sample-Input"><a href="#Sample-Input" class="headerlink" title="Sample Input"></a>Sample Input</h3><pre><code>24100141111</code></pre><h3 id="Sample-Output"><a href="#Sample-Output" class="headerlink" title="Sample Output"></a>Sample Output</h3><pre><code>44</code></pre><h3 id="Hint"><a href="#Hint" class="headerlink" title="Hint"></a>Hint</h3><h3 id="Source"><a href="#Source" class="headerlink" title="Source"></a>Source</h3><h1 id="题目大意"><a href="#题目大意" class="headerlink" title="题目大意"></a>题目大意</h1><p>如题</p><h1 id="解题思路"><a href="#解题思路" class="headerlink" title="解题思路"></a>解题思路</h1><ul><li>小规模数据采取枚举分界点的方法，时间复杂度$O(n^{2})$</li></ul><ul><li>仔细想一下，我们要找的是一个区间，里面0的数量与1的数量差最大。如果直接寻找区间有点难理解的话，我们<br>可以换一个角度，记录出现0和出现1的差值，求差值在翻转以后的最小值。</li></ul><p>如图</p><p><img src="https://eddyblog.oss-cn-shenzhen.aliyuncs.com/%E3%80%90CSU-2187%E3%80%91%E8%A7%A3%E9%A2%98%E6%8A%A5%E5%91%8A%EF%BC%88%E7%BB%B4%E6%8A%A4%E9%A1%BA%E5%BA%8F%E6%9E%81%E5%B7%AE%EF%BC%89/1.png" srcset="/img/loading.gif" alt="1.png"></p><ul><li><p>那么如何求翻转以后的最小值？如果对每个区间下限进行计数，遇1减减，遇0加加，我们的答案就是不同起点的所有cnt值得最大值。</p></li><li><p>实际上我们就是找图中一个极小值（包括头点）与一个极大值（包括末尾）极差得最大值，而且需要注意得是我们求的是1的翻转次数最大，所以要求是一个极小值在左，极大值在右，左低右高。</p></li></ul><p>再如图</p><p><img src="https://eddyblog.oss-cn-shenzhen.aliyuncs.com/%E3%80%90CSU-2187%E3%80%91%E8%A7%A3%E9%A2%98%E6%8A%A5%E5%91%8A%EF%BC%88%E7%BB%B4%E6%8A%A4%E9%A1%BA%E5%BA%8F%E6%9E%81%E5%B7%AE%EF%BC%89/2.png" srcset="/img/loading.gif" alt="2.png"></p><p><img src="https://eddyblog.oss-cn-shenzhen.aliyuncs.com/%E3%80%90CSU-2187%E3%80%91%E8%A7%A3%E9%A2%98%E6%8A%A5%E5%91%8A%EF%BC%88%E7%BB%B4%E6%8A%A4%E9%A1%BA%E5%BA%8F%E6%9E%81%E5%B7%AE%EF%BC%89/3.png" srcset="/img/loading.gif" alt="3.png"></p><ul><li>线性从头扫一遍，维护最小值，同时重新计数cnt，最后求cnt的最大值。</li></ul><h1 id="解题代码"><a href="#解题代码" class="headerlink" title="解题代码"></a>解题代码</h1><pre><code class="hljs C++"><span class="hljs-meta">#<span class="hljs-meta-keyword">include</span> <span class="hljs-meta-string">&lt;cstdio&gt;</span></span><span class="hljs-meta">#<span class="hljs-meta-keyword">include</span> <span class="hljs-meta-string">&lt;cstring&gt;</span></span><span class="hljs-meta">#<span class="hljs-meta-keyword">include</span> <span class="hljs-meta-string">&lt;queue&gt;</span></span><span class="hljs-meta">#<span class="hljs-meta-keyword">include</span> <span class="hljs-meta-string">&lt;stack&gt;</span></span><span class="hljs-meta">#<span class="hljs-meta-keyword">include</span> <span class="hljs-meta-string">&lt;cstring&gt;</span></span><span class="hljs-meta">#<span class="hljs-meta-keyword">include</span> <span class="hljs-meta-string">&lt;algorithm&gt;</span></span><span class="hljs-meta">#<span class="hljs-meta-keyword">include</span> <span class="hljs-meta-string">&lt;vector&gt;</span></span><span class="hljs-meta">#<span class="hljs-meta-keyword">include</span> <span class="hljs-meta-string">&lt;string&gt;</span></span><span class="hljs-meta">#<span class="hljs-meta-keyword">include</span> <span class="hljs-meta-string">&lt;bits/stdc++.h&gt;</span></span><span class="hljs-keyword">using</span> <span class="hljs-keyword">namespace</span> <span class="hljs-built_in">std</span>;<span class="hljs-keyword">const</span> <span class="hljs-keyword">int</span> maxn=<span class="hljs-number">1e6</span>+<span class="hljs-number">5</span>;<span class="hljs-keyword">const</span> <span class="hljs-keyword">int</span> maxm=<span class="hljs-number">1e6</span>+<span class="hljs-number">5</span>;<span class="hljs-meta">#<span class="hljs-meta-keyword">define</span> INF 0x3f3f3f3f</span><span class="hljs-meta">#<span class="hljs-meta-keyword">define</span> EPS 1e-8</span><span class="hljs-meta">#<span class="hljs-meta-keyword">define</span> rep(i,a,n) for(int i=a;i&lt;n;++i)</span><span class="hljs-meta">#<span class="hljs-meta-keyword">define</span> per(i,a,n) for(int i=n-1;i&gt;=a;--i)</span><span class="hljs-meta">#<span class="hljs-meta-keyword">define</span> fi first</span><span class="hljs-meta">#<span class="hljs-meta-keyword">define</span> se second</span><span class="hljs-meta">#<span class="hljs-meta-keyword">define</span> pb push_back</span><span class="hljs-meta">#<span class="hljs-meta-keyword">define</span> np next_permutation</span><span class="hljs-meta">#<span class="hljs-meta-keyword">define</span> mp make_pair</span><span class="hljs-keyword">typedef</span> <span class="hljs-keyword">long</span> <span class="hljs-keyword">long</span> ll;<span class="hljs-keyword">typedef</span> <span class="hljs-keyword">unsigned</span> <span class="hljs-keyword">long</span> <span class="hljs-keyword">long</span> ull;<span class="hljs-keyword">typedef</span> <span class="hljs-built_in">vector</span> &lt;<span class="hljs-keyword">int</span>&gt; vi;<span class="hljs-keyword">typedef</span> pair&lt;<span class="hljs-built_in">string</span>,<span class="hljs-built_in">string</span>&gt; pss;<span class="hljs-keyword">typedef</span> pair&lt;<span class="hljs-keyword">int</span>, <span class="hljs-keyword">int</span>&gt; pii;<span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span>&#123;    ios::sync_with_stdio(<span class="hljs-literal">false</span>);<span class="hljs-comment">//    freopen("in.txt","r",stdin);</span>    <span class="hljs-keyword">int</span> t;    <span class="hljs-built_in">cin</span>&gt;&gt;t;    <span class="hljs-keyword">while</span>(t--)&#123;   <span class="hljs-keyword">int</span> n;   <span class="hljs-built_in">cin</span>&gt;&gt;n;   <span class="hljs-built_in">string</span> s;   <span class="hljs-built_in">cin</span>&gt;&gt;s;   <span class="hljs-keyword">int</span> ans=<span class="hljs-number">0</span>,cnt=<span class="hljs-number">0</span>,ccnt=<span class="hljs-number">0</span>;   <span class="hljs-keyword">int</span> mmin=<span class="hljs-number">0</span>;   rep(i,<span class="hljs-number">0</span>,n)&#123;  <span class="hljs-keyword">if</span>(s[i]==<span class="hljs-string">'0'</span>) ans++,cnt++;  <span class="hljs-keyword">else</span> ans--,cnt--;  <span class="hljs-keyword">if</span>(i==n<span class="hljs-number">-1</span> &amp;&amp; s[i]==<span class="hljs-string">'0'</span>) ccnt=max(ccnt,cnt);  <span class="hljs-keyword">if</span>(i!=n<span class="hljs-number">-1</span>)&#123; <span class="hljs-keyword">if</span>(s[i]==<span class="hljs-string">'1'</span> &amp;&amp; s[i+<span class="hljs-number">1</span>]==<span class="hljs-string">'0'</span> &amp;&amp; ans&lt;mmin) mmin=ans,cnt=<span class="hljs-number">0</span>; <span class="hljs-keyword">if</span>(s[i]==<span class="hljs-string">'0'</span> &amp;&amp; s[i+<span class="hljs-number">1</span>]==<span class="hljs-string">'1'</span>) ccnt=max(ccnt,cnt);  &#125;   &#125;   <span class="hljs-keyword">if</span>(ccnt==<span class="hljs-number">0</span>) <span class="hljs-built_in">cout</span>&lt;&lt;n&lt;&lt;<span class="hljs-built_in">endl</span>;   <span class="hljs-keyword">else</span>&#123;<span class="hljs-comment">//  cout&lt;&lt;"min="&lt;&lt;mmin&lt;&lt;"  max="&lt;&lt;mmax&lt;&lt;endl;</span>  ans= ans<span class="hljs-number">-2</span>*(ccnt);  <span class="hljs-built_in">cout</span>&lt;&lt;(n-ans)/<span class="hljs-number">2</span>&lt;&lt;<span class="hljs-built_in">endl</span>;   &#125;    &#125;&#125;</code></pre><h1 id="收获与反思"><a href="#收获与反思" class="headerlink" title="收获与反思"></a>收获与反思</h1><p>考虑单调性，维护记录值，最大/最小值。</p>]]></content>
    
    
    <categories>
      
      <category>Computer Science</category>
      
      <category>ACM</category>
      
      <category>CSU</category>
      
    </categories>
    
    
    <tags>
      
      <tag>ACM</tag>
      
      <tag>CSU</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>【CSU-2179】解题报告（水题）</title>
    <link href="/post/6db0d89d.html"/>
    <url>/post/6db0d89d.html</url>
    
    <content type="html"><![CDATA[<h1 id="原始题目"><a href="#原始题目" class="headerlink" title="原始题目"></a>原始题目</h1><h2 id="2179-找众数"><a href="#2179-找众数" class="headerlink" title="2179: 找众数"></a>2179: 找众数</h2><ul><li>Time Limit: 1 Sec     </li><li>Memory Limit: 128 Mb     </li><li>Submitted: 86     </li><li>Solved: 32    </li></ul><h3 id="Description"><a href="#Description" class="headerlink" title="Description"></a>Description</h3><p>由文件给出$N$个$1$到$30000$间无序数正整数，其中$1≤N≤10000$，同一个正整数可能会出现多次，出现次数最多的整数称为众数。求出它的众数及它出现的次数。<br><a id="more"></a></p><h3 id="Input"><a href="#Input" class="headerlink" title="Input"></a>Input</h3><p>输入文件第一行是正整数的个数$N$，第二行开始为$N$个正整数。</p><h3 id="Output"><a href="#Output" class="headerlink" title="Output"></a>Output</h3><p>输出文件有若干行，每行两个数，第一个是众数，第二个是众数出现的次数。</p><h3 id="Sample-Input"><a href="#Sample-Input" class="headerlink" title="Sample Input"></a>Sample Input</h3><pre><code>122  4  2  3  2  5  3  7  2  3  4  3</code></pre><h3 id="Sample-Output"><a href="#Sample-Output" class="headerlink" title="Sample Output"></a>Sample Output</h3><pre><code>2 43 4</code></pre><h3 id="Hint"><a href="#Hint" class="headerlink" title="Hint"></a>Hint</h3><h3 id="Source"><a href="#Source" class="headerlink" title="Source"></a>Source</h3><h1 id="题目大意"><a href="#题目大意" class="headerlink" title="题目大意"></a>题目大意</h1><p>如题</p><h1 id="解题思路"><a href="#解题思路" class="headerlink" title="解题思路"></a>解题思路</h1><p>记录出现次数，加入动态数组中按次数大小快速排序，最后输出（众数多个注意排序的时候按字典序）。</p><h1 id="解题代码"><a href="#解题代码" class="headerlink" title="解题代码"></a>解题代码</h1><pre><code class="hljs C++"><span class="hljs-meta">#<span class="hljs-meta-keyword">include</span> <span class="hljs-meta-string">&lt;cstdio&gt;</span></span><span class="hljs-meta">#<span class="hljs-meta-keyword">include</span><span class="hljs-meta-string">&lt;cstring&gt;</span></span><span class="hljs-meta">#<span class="hljs-meta-keyword">include</span><span class="hljs-meta-string">&lt;iostream&gt;</span></span><span class="hljs-meta">#<span class="hljs-meta-keyword">include</span><span class="hljs-meta-string">&lt;set&gt;</span></span><span class="hljs-meta">#<span class="hljs-meta-keyword">include</span> <span class="hljs-meta-string">&lt;queue&gt;</span></span><span class="hljs-meta">#<span class="hljs-meta-keyword">include</span><span class="hljs-meta-string">&lt;vector&gt;</span></span><span class="hljs-meta">#<span class="hljs-meta-keyword">include</span> <span class="hljs-meta-string">&lt;bits/stdc++.h&gt;</span></span><span class="hljs-keyword">using</span> <span class="hljs-keyword">namespace</span> <span class="hljs-built_in">std</span>;<span class="hljs-keyword">const</span> <span class="hljs-keyword">int</span> maxn=<span class="hljs-number">1e5</span>+<span class="hljs-number">5</span>;<span class="hljs-keyword">const</span> <span class="hljs-keyword">int</span> maxm=<span class="hljs-number">1e5</span>+<span class="hljs-number">5</span>;<span class="hljs-keyword">typedef</span> <span class="hljs-keyword">long</span> <span class="hljs-keyword">long</span> ll;<span class="hljs-keyword">typedef</span> <span class="hljs-keyword">unsigned</span> <span class="hljs-keyword">long</span> <span class="hljs-keyword">long</span> ull;<span class="hljs-keyword">typedef</span> <span class="hljs-built_in">vector</span>&lt;<span class="hljs-keyword">int</span>&gt; vi;<span class="hljs-keyword">typedef</span> pair&lt;<span class="hljs-keyword">int</span>,<span class="hljs-keyword">int</span> &gt; pii;<span class="hljs-keyword">typedef</span> pair&lt;<span class="hljs-built_in">string</span>,<span class="hljs-built_in">string</span>&gt; pss;<span class="hljs-meta">#<span class="hljs-meta-keyword">define</span> rep(i,a,n) for(int i=a;i&lt;n;++i)</span><span class="hljs-meta">#<span class="hljs-meta-keyword">define</span> per(i,a,n) for(int i=n-1;i&gt;=a;--i)</span><span class="hljs-meta">#<span class="hljs-meta-keyword">define</span> fi first</span><span class="hljs-meta">#<span class="hljs-meta-keyword">define</span> se second</span><span class="hljs-meta">#<span class="hljs-meta-keyword">define</span> pb push_back</span><span class="hljs-meta">#<span class="hljs-meta-keyword">define</span> np next_permutation</span><span class="hljs-meta">#<span class="hljs-meta-keyword">define</span> mp make_pair</span><span class="hljs-meta">#<span class="hljs-meta-keyword">define</span> all(x) x.begin(),x.end()</span><span class="hljs-keyword">int</span> n;<span class="hljs-keyword">int</span> a[maxn];<span class="hljs-keyword">int</span> ans1=<span class="hljs-number">0</span>,ans2=<span class="hljs-number">0</span>;vi ans;<span class="hljs-function"><span class="hljs-keyword">bool</span> <span class="hljs-title">cmp</span><span class="hljs-params">(<span class="hljs-keyword">int</span> c,<span class="hljs-keyword">int</span> d)</span></span>&#123;    <span class="hljs-keyword">if</span>(a[c]==a[d]) <span class="hljs-keyword">return</span> c&lt;d;    <span class="hljs-keyword">else</span> <span class="hljs-keyword">return</span> a[c]&gt;a[d];&#125;<span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span>&#123;    ios::sync_with_stdio(<span class="hljs-literal">false</span>);    <span class="hljs-keyword">while</span>(<span class="hljs-built_in">cin</span>&gt;&gt;n)&#123;        <span class="hljs-built_in">memset</span>(a,<span class="hljs-number">0</span>,<span class="hljs-keyword">sizeof</span>(a));        ans.clear();        rep(i,<span class="hljs-number">0</span>,n)&#123;            <span class="hljs-keyword">int</span> temp;            <span class="hljs-built_in">cin</span>&gt;&gt;temp;            <span class="hljs-keyword">if</span>(!a[temp]) ans.pb(temp);            a[temp]++;        &#125;        sort(all(ans),cmp);            <span class="hljs-keyword">int</span> len=ans.size();            <span class="hljs-built_in">cout</span>&lt;&lt;ans[<span class="hljs-number">0</span>]&lt;&lt;<span class="hljs-string">" "</span>&lt;&lt;a[ans[<span class="hljs-number">0</span>]]&lt;&lt;<span class="hljs-built_in">endl</span>;            <span class="hljs-keyword">for</span>(<span class="hljs-keyword">int</span> i=<span class="hljs-number">1</span>;i&lt;len;i++)&#123;                <span class="hljs-keyword">if</span>(a[ans[i]]&lt;a[ans[<span class="hljs-number">0</span>]]) <span class="hljs-keyword">break</span>;                <span class="hljs-built_in">cout</span>&lt;&lt;ans[i]&lt;&lt;<span class="hljs-string">" "</span>&lt;&lt;a[ans[<span class="hljs-number">0</span>]]&lt;&lt;<span class="hljs-built_in">endl</span>;            &#125;    &#125;&#125;</code></pre><h1 id="收获与反思"><a href="#收获与反思" class="headerlink" title="收获与反思"></a>收获与反思</h1><p>出题者没说清楚，应该加个特判的，所以注意排序以字典序为第二关键字。</p>]]></content>
    
    
    <categories>
      
      <category>Computer Science</category>
      
      <category>ACM</category>
      
      <category>CSU</category>
      
    </categories>
    
    
    <tags>
      
      <tag>ACM</tag>
      
      <tag>CSU</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>【CSU-2185】解题报告（水题）</title>
    <link href="/post/3a72081e.html"/>
    <url>/post/3a72081e.html</url>
    
    <content type="html"><![CDATA[<h1 id="原始题目"><a href="#原始题目" class="headerlink" title="原始题目"></a>原始题目</h1><h2 id="2185-a-simple-problem"><a href="#2185-a-simple-problem" class="headerlink" title="2185: a simple problem"></a>2185: a simple problem</h2><ul><li>Time Limit: 1 Sec     </li><li>Memory Limit: 128 Mb     </li><li>Submitted: 78     </li><li>Solved: 46    </li></ul><h3 id="Description"><a href="#Description" class="headerlink" title="Description"></a>Description</h3><p>My girlfriend loves 7 very much, she thinks it is lucky! If an integer contains one or more 7, she will think it is lucky too!<br><a id="more"></a></p><h3 id="Input"><a href="#Input" class="headerlink" title="Input"></a>Input</h3><p>There are multiple test files and each contains one case.<br>The number of cases is at most 100. For each test case, there is only one line with an integer $X ( 1 ≤ X ≤ {10}^{9} )$.</p><h3 id="Output"><a href="#Output" class="headerlink" title="Output"></a>Output</h3><p>For each test case, if $X$ contains one or more 7, output “Lucky”(without quotation marks),<br>otherwise output “Unlucky”(without quotation marks).</p><h3 id="Sample-Input"><a href="#Sample-Input" class="headerlink" title="Sample Input"></a>Sample Input</h3><pre><code>17171</code></pre><h3 id="Sample-Output"><a href="#Sample-Output" class="headerlink" title="Sample Output"></a>Sample Output</h3><pre><code>Lucky</code></pre><h3 id="Hint"><a href="#Hint" class="headerlink" title="Hint"></a>Hint</h3><h3 id="Source"><a href="#Source" class="headerlink" title="Source"></a>Source</h3><h1 id="题目大意"><a href="#题目大意" class="headerlink" title="题目大意"></a>题目大意</h1><p>输入一串字符，字符中有7则输出“Lucky”，否则输出“Unlucky”</p><h1 id="解题思路"><a href="#解题思路" class="headerlink" title="解题思路"></a>解题思路</h1><p>逐位判断</p><h1 id="解题代码"><a href="#解题代码" class="headerlink" title="解题代码"></a>解题代码</h1><pre><code class="hljs C++"><span class="hljs-meta">#<span class="hljs-meta-keyword">include</span> <span class="hljs-meta-string">&lt;cstdio&gt;</span></span><span class="hljs-meta">#<span class="hljs-meta-keyword">include</span><span class="hljs-meta-string">&lt;cstring&gt;</span></span><span class="hljs-meta">#<span class="hljs-meta-keyword">include</span><span class="hljs-meta-string">&lt;cmath&gt;</span></span><span class="hljs-meta">#<span class="hljs-meta-keyword">include</span><span class="hljs-meta-string">&lt;iostream&gt;</span></span><span class="hljs-meta">#<span class="hljs-meta-keyword">include</span><span class="hljs-meta-string">&lt;set&gt;</span></span><span class="hljs-meta">#<span class="hljs-meta-keyword">include</span><span class="hljs-meta-string">&lt;queue&gt;</span></span><span class="hljs-meta">#<span class="hljs-meta-keyword">include</span><span class="hljs-meta-string">&lt;map&gt;</span></span><span class="hljs-meta">#<span class="hljs-meta-keyword">include</span> <span class="hljs-meta-string">&lt;algorithm&gt;</span></span><span class="hljs-meta">#<span class="hljs-meta-keyword">include</span> <span class="hljs-meta-string">&lt;stack&gt;</span></span><span class="hljs-meta">#<span class="hljs-meta-keyword">include</span> <span class="hljs-meta-string">&lt;bits/stdc++.h&gt;</span></span><span class="hljs-meta">#<span class="hljs-meta-keyword">define</span> INF 0x3f3f3f3f</span><span class="hljs-meta">#<span class="hljs-meta-keyword">define</span> EPS 1e-8</span><span class="hljs-meta">#<span class="hljs-meta-keyword">define</span> fi first</span><span class="hljs-meta">#<span class="hljs-meta-keyword">define</span> se second</span><span class="hljs-meta">#<span class="hljs-meta-keyword">define</span> mp make_pair</span><span class="hljs-meta">#<span class="hljs-meta-keyword">define</span> pb push_back</span><span class="hljs-meta">#<span class="hljs-meta-keyword">define</span> np next_permutation</span><span class="hljs-meta">#<span class="hljs-meta-keyword">define</span> cl(x,a) memeset(x,a,sizeof(x))</span><span class="hljs-meta">#<span class="hljs-meta-keyword">define</span> rep(i,a,n) for(int i=a;i&lt;n;++i)</span><span class="hljs-meta">#<span class="hljs-meta-keyword">define</span> per(i,a,n) for(int i=n-1;i&gt;=a;--i)</span><span class="hljs-keyword">using</span> <span class="hljs-keyword">namespace</span> <span class="hljs-built_in">std</span>;<span class="hljs-keyword">const</span> <span class="hljs-keyword">int</span> maxn=<span class="hljs-number">1e5</span>+<span class="hljs-number">5</span>;<span class="hljs-keyword">const</span> <span class="hljs-keyword">int</span> maxm=<span class="hljs-number">1e5</span>+<span class="hljs-number">5</span>;<span class="hljs-keyword">typedef</span> <span class="hljs-keyword">long</span> <span class="hljs-keyword">long</span> ll;<span class="hljs-keyword">typedef</span> <span class="hljs-keyword">unsigned</span> <span class="hljs-keyword">long</span> <span class="hljs-keyword">long</span> ull;<span class="hljs-keyword">typedef</span> <span class="hljs-built_in">vector</span>&lt;<span class="hljs-keyword">int</span>&gt; vi;<span class="hljs-keyword">typedef</span> pair&lt;<span class="hljs-keyword">int</span>,<span class="hljs-keyword">int</span>&gt; pii;<span class="hljs-keyword">typedef</span> pair&lt;<span class="hljs-built_in">string</span>,<span class="hljs-built_in">string</span>&gt; pss;<span class="hljs-keyword">int</span> n,t;<span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span>&#123;    <span class="hljs-keyword">while</span>(~<span class="hljs-built_in">scanf</span>(<span class="hljs-string">"%d"</span>,&amp;n))&#123;        <span class="hljs-keyword">int</span> flag=<span class="hljs-number">0</span>;        <span class="hljs-keyword">while</span>(n)&#123;            <span class="hljs-keyword">if</span>(n%<span class="hljs-number">10</span>==<span class="hljs-number">7</span>)&#123;                flag=<span class="hljs-number">1</span>;                <span class="hljs-keyword">break</span>;            &#125;            n/=<span class="hljs-number">10</span>;        &#125;        <span class="hljs-keyword">if</span>(flag) <span class="hljs-built_in">printf</span>(<span class="hljs-string">"Lucky\n"</span>);        <span class="hljs-keyword">else</span> <span class="hljs-built_in">printf</span>(<span class="hljs-string">"Unlucky\n"</span>);    &#125;&#125;</code></pre><h1 id="收获与反思"><a href="#收获与反思" class="headerlink" title="收获与反思"></a>收获与反思</h1><p>无</p>]]></content>
    
    
    <categories>
      
      <category>Computer Science</category>
      
      <category>ACM</category>
      
      <category>CSU</category>
      
    </categories>
    
    
    <tags>
      
      <tag>ACM</tag>
      
      <tag>CSU</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>【CSU-2163】解题报告（水题）</title>
    <link href="/post/73136b.html"/>
    <url>/post/73136b.html</url>
    
    <content type="html"><![CDATA[<h1 id="原始题目"><a href="#原始题目" class="headerlink" title="原始题目"></a>原始题目</h1><h2 id="2163-字符画"><a href="#2163-字符画" class="headerlink" title="2163: 字符画"></a>2163: 字符画</h2><ul><li>Time Limit: 1 Sec     </li><li>Memory Limit: 128 Mb     </li><li>Submitted: 221     </li><li>Solved: 139    </li></ul><h3 id="Description"><a href="#Description" class="headerlink" title="Description"></a>Description</h3><p>读入 $w$，请输出 2018 的字符画，两个数字之间有 $w$ 个空格。具体格式请参考样例输出。$(1 ≤ w ≤ 2018)$<br><a id="more"></a></p><h3 id="Input"><a href="#Input" class="headerlink" title="Input"></a>Input</h3><p>输入文件只包含 1 个整数 $w$.</p><h3 id="Output"><a href="#Output" class="headerlink" title="Output"></a>Output</h3><p>输出 5 行，每行 $12 + 3w$ 个字符（只包含 o 和 . 两种，字符画的部分用 o，空格的部分用 .），以换行符结尾。</p><h3 id="Sample-Input"><a href="#Sample-Input" class="headerlink" title="Sample Input"></a>Sample Input</h3><pre><code>2</code></pre><h3 id="Sample-Output"><a href="#Sample-Output" class="headerlink" title="Sample Output"></a>Sample Output</h3><pre><code>ooo..ooo..ooo..ooo..o..o.o...o...o.oooo..o.o...o...oooo....o.o...o...o.oooo..ooo..ooo..ooo</code></pre><h3 id="Hint"><a href="#Hint" class="headerlink" title="Hint"></a>Hint</h3><h3 id="Source"><a href="#Source" class="headerlink" title="Source"></a>Source</h3><p>2018湖南省第14届大学生计算机程序设计竞赛</p><h3 id="Author"><a href="#Author" class="headerlink" title="Author"></a>Author</h3><p>ftiasch</p><h1 id="题目大意"><a href="#题目大意" class="headerlink" title="题目大意"></a>题目大意</h1><p>如题</p><h1 id="解题思路"><a href="#解题思路" class="headerlink" title="解题思路"></a>解题思路</h1><p>打输出</p><h1 id="解题代码"><a href="#解题代码" class="headerlink" title="解题代码"></a>解题代码</h1><pre><code class="hljs C++"><span class="hljs-meta">#<span class="hljs-meta-keyword">include</span> <span class="hljs-meta-string">&lt;iostream&gt;</span></span><span class="hljs-meta">#<span class="hljs-meta-keyword">include</span> <span class="hljs-meta-string">&lt;cstdio&gt;</span></span><span class="hljs-meta">#<span class="hljs-meta-keyword">include</span> <span class="hljs-meta-string">&lt;cstring&gt;</span></span><span class="hljs-meta">#<span class="hljs-meta-keyword">include</span> <span class="hljs-meta-string">&lt;sstream&gt;</span></span><span class="hljs-meta">#<span class="hljs-meta-keyword">include</span> <span class="hljs-meta-string">&lt;set&gt;</span></span><span class="hljs-meta">#<span class="hljs-meta-keyword">include</span> <span class="hljs-meta-string">&lt;queue&gt;</span></span><span class="hljs-meta">#<span class="hljs-meta-keyword">include</span> <span class="hljs-meta-string">&lt;cmath&gt;</span></span><span class="hljs-meta">#<span class="hljs-meta-keyword">include</span> <span class="hljs-meta-string">&lt;stack&gt;</span></span><span class="hljs-meta">#<span class="hljs-meta-keyword">include</span> <span class="hljs-meta-string">&lt;map&gt;</span></span><span class="hljs-meta">#<span class="hljs-meta-keyword">include</span> <span class="hljs-meta-string">&lt;set&gt;</span></span><span class="hljs-meta">#<span class="hljs-meta-keyword">include</span> <span class="hljs-meta-string">&lt;algorithm&gt;</span></span><span class="hljs-keyword">using</span> <span class="hljs-keyword">namespace</span> <span class="hljs-built_in">std</span>;<span class="hljs-keyword">const</span> <span class="hljs-keyword">int</span> maxn=<span class="hljs-number">1e5</span>+<span class="hljs-number">5</span>;<span class="hljs-keyword">const</span> <span class="hljs-keyword">int</span> maxm=<span class="hljs-number">1e5</span>+<span class="hljs-number">5</span>;<span class="hljs-meta">#<span class="hljs-meta-keyword">define</span> rep(i,a,n) for(int i=a;i&lt;n;++i)</span><span class="hljs-meta">#<span class="hljs-meta-keyword">define</span> per(i,a,n) for(int i=n-1;i&gt;=a;--i)</span><span class="hljs-meta">#<span class="hljs-meta-keyword">define</span> fi first</span><span class="hljs-meta">#<span class="hljs-meta-keyword">define</span> se second</span><span class="hljs-meta">#<span class="hljs-meta-keyword">define</span> pb push_back</span><span class="hljs-meta">#<span class="hljs-meta-keyword">define</span> np next_permutation</span><span class="hljs-meta">#<span class="hljs-meta-keyword">define</span> mp make_pair</span><span class="hljs-meta">#<span class="hljs-meta-keyword">define</span> INF 0x3f3f3f3f</span><span class="hljs-meta">#<span class="hljs-meta-keyword">define</span> EPS 1e-8</span><span class="hljs-keyword">int</span> n;<span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span>&#123;    ios::sync_with_stdio(<span class="hljs-literal">false</span>);    <span class="hljs-keyword">while</span>(<span class="hljs-built_in">cin</span>&gt;&gt;n)&#123;        &#123;            <span class="hljs-built_in">cout</span>&lt;&lt;<span class="hljs-string">"ooo"</span>;            rep(i,<span class="hljs-number">0</span>,n) <span class="hljs-built_in">cout</span>&lt;&lt;<span class="hljs-string">"."</span>;            <span class="hljs-built_in">cout</span>&lt;&lt;<span class="hljs-string">"ooo"</span>;            rep(i,<span class="hljs-number">0</span>,n) <span class="hljs-built_in">cout</span>&lt;&lt;<span class="hljs-string">"."</span>;            <span class="hljs-built_in">cout</span>&lt;&lt;<span class="hljs-string">"ooo"</span>;            rep(i,<span class="hljs-number">0</span>,n) <span class="hljs-built_in">cout</span>&lt;&lt;<span class="hljs-string">"."</span>;            <span class="hljs-built_in">cout</span>&lt;&lt;<span class="hljs-string">"ooo"</span>&lt;&lt;<span class="hljs-built_in">endl</span>;        &#125;        &#123;            <span class="hljs-built_in">cout</span>&lt;&lt;<span class="hljs-string">"..o"</span>;            rep(i,<span class="hljs-number">0</span>,n) <span class="hljs-built_in">cout</span>&lt;&lt;<span class="hljs-string">"."</span>;            <span class="hljs-built_in">cout</span>&lt;&lt;<span class="hljs-string">"o.o"</span>;            rep(i,<span class="hljs-number">0</span>,n) <span class="hljs-built_in">cout</span>&lt;&lt;<span class="hljs-string">"."</span>;            <span class="hljs-built_in">cout</span>&lt;&lt;<span class="hljs-string">".o."</span>;            rep(i,<span class="hljs-number">0</span>,n) <span class="hljs-built_in">cout</span>&lt;&lt;<span class="hljs-string">"."</span>;            <span class="hljs-built_in">cout</span>&lt;&lt;<span class="hljs-string">"o.o"</span>&lt;&lt;<span class="hljs-built_in">endl</span>;        &#125;        &#123;            <span class="hljs-built_in">cout</span>&lt;&lt;<span class="hljs-string">"ooo"</span>;            rep(i,<span class="hljs-number">0</span>,n) <span class="hljs-built_in">cout</span>&lt;&lt;<span class="hljs-string">"."</span>;            <span class="hljs-built_in">cout</span>&lt;&lt;<span class="hljs-string">"o.o"</span>;            rep(i,<span class="hljs-number">0</span>,n) <span class="hljs-built_in">cout</span>&lt;&lt;<span class="hljs-string">"."</span>;            <span class="hljs-built_in">cout</span>&lt;&lt;<span class="hljs-string">".o."</span>;            rep(i,<span class="hljs-number">0</span>,n) <span class="hljs-built_in">cout</span>&lt;&lt;<span class="hljs-string">"."</span>;            <span class="hljs-built_in">cout</span>&lt;&lt;<span class="hljs-string">"ooo"</span>&lt;&lt;<span class="hljs-built_in">endl</span>;        &#125;        &#123;            <span class="hljs-built_in">cout</span>&lt;&lt;<span class="hljs-string">"o.."</span>;            rep(i,<span class="hljs-number">0</span>,n) <span class="hljs-built_in">cout</span>&lt;&lt;<span class="hljs-string">"."</span>;            <span class="hljs-built_in">cout</span>&lt;&lt;<span class="hljs-string">"o.o"</span>;            rep(i,<span class="hljs-number">0</span>,n) <span class="hljs-built_in">cout</span>&lt;&lt;<span class="hljs-string">"."</span>;            <span class="hljs-built_in">cout</span>&lt;&lt;<span class="hljs-string">".o."</span>;            rep(i,<span class="hljs-number">0</span>,n) <span class="hljs-built_in">cout</span>&lt;&lt;<span class="hljs-string">"."</span>;            <span class="hljs-built_in">cout</span>&lt;&lt;<span class="hljs-string">"o.o"</span>&lt;&lt;<span class="hljs-built_in">endl</span>;        &#125;        &#123;            <span class="hljs-built_in">cout</span>&lt;&lt;<span class="hljs-string">"ooo"</span>;            rep(i,<span class="hljs-number">0</span>,n) <span class="hljs-built_in">cout</span>&lt;&lt;<span class="hljs-string">"."</span>;            <span class="hljs-built_in">cout</span>&lt;&lt;<span class="hljs-string">"ooo"</span>;            rep(i,<span class="hljs-number">0</span>,n) <span class="hljs-built_in">cout</span>&lt;&lt;<span class="hljs-string">"."</span>;            <span class="hljs-built_in">cout</span>&lt;&lt;<span class="hljs-string">"ooo"</span>;            rep(i,<span class="hljs-number">0</span>,n) <span class="hljs-built_in">cout</span>&lt;&lt;<span class="hljs-string">"."</span>;            <span class="hljs-built_in">cout</span>&lt;&lt;<span class="hljs-string">"ooo"</span>&lt;&lt;<span class="hljs-built_in">endl</span>;        &#125;    &#125;&#125;</code></pre><h1 id="收获与反思"><a href="#收获与反思" class="headerlink" title="收获与反思"></a>收获与反思</h1><p>无</p>]]></content>
    
    
    <categories>
      
      <category>Computer Science</category>
      
      <category>ACM</category>
      
      <category>CSU</category>
      
    </categories>
    
    
    <tags>
      
      <tag>ACM</tag>
      
      <tag>CSU</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>【CSU-2184】解题报告（水题）</title>
    <link href="/post/3bc7f503.html"/>
    <url>/post/3bc7f503.html</url>
    
    <content type="html"><![CDATA[<h1 id="原始题目"><a href="#原始题目" class="headerlink" title="原始题目"></a>原始题目</h1><h2 id="2184-解密简单版"><a href="#2184-解密简单版" class="headerlink" title="2184: 解密简单版"></a>2184: 解密简单版</h2><ul><li>Time Limit: 1 Sec     </li><li>Memory Limit: 128 Mb     </li><li>Submitted: 101     </li><li>Solved: 39    </li></ul><h3 id="Description"><a href="#Description" class="headerlink" title="Description"></a>Description</h3><p>小F居住在铁道校区，他想和湘雅校区的同学小L聊天，为了保证沟通安全，他发明了一种加密方式，<br>这种加密方式是这样的：对于一个01串，小F会将其从左到右每8位分成一组，最后一组可能不足8位，<br>对每组进行逆序操作，即如果原来是$ b_{L}b_{L+1}b_{L+2}b_{R-1}b_{R} $,逆序之后变成 $ b_{R}b_{R-1}b_{R-2}b_{L-1}b_{L} $。<br>现在小F已经加密好了一个串，并且将其发给了小L，你能帮助小L得到这串密文对应的原始信息吗？</p><a id="more"></a><h3 id="Input"><a href="#Input" class="headerlink" title="Input"></a>Input</h3><p>单组数据。</p><p>一行一个 01 串，代表加密后的字符串，串长度大于0,小于等于 100。</p><h3 id="Output"><a href="#Output" class="headerlink" title="Output"></a>Output</h3><p>一行字符串，代表加密后的字符串所对应的原始信息。</p><h3 id="Sample-Input"><a href="#Sample-Input" class="headerlink" title="Sample Input"></a>Sample Input</h3><p>100010110011101</p><h3 id="Sample-Output"><a href="#Sample-Output" class="headerlink" title="Sample Output"></a>Sample Output</h3><p>110100011011100</p><h3 id="Hint"><a href="#Hint" class="headerlink" title="Hint"></a>Hint</h3><h3 id="Source"><a href="#Source" class="headerlink" title="Source"></a>Source</h3><h1 id="题目大意"><a href="#题目大意" class="headerlink" title="题目大意"></a>题目大意</h1><p>如题</p><h1 id="解题思路"><a href="#解题思路" class="headerlink" title="解题思路"></a>解题思路</h1><p>模8反转输出</p><h1 id="解题代码"><a href="#解题代码" class="headerlink" title="解题代码"></a>解题代码</h1><pre><code class="hljs C++"><span class="hljs-meta">#<span class="hljs-meta-keyword">include</span> <span class="hljs-meta-string">&lt;iostream&gt;</span></span><span class="hljs-meta">#<span class="hljs-meta-keyword">include</span> <span class="hljs-meta-string">&lt;string&gt;</span></span><span class="hljs-meta">#<span class="hljs-meta-keyword">include</span> <span class="hljs-meta-string">&lt;sstream&gt;</span></span><span class="hljs-meta">#<span class="hljs-meta-keyword">include</span> <span class="hljs-meta-string">&lt;bits/stdc++.h&gt;</span></span><span class="hljs-keyword">using</span> <span class="hljs-keyword">namespace</span> <span class="hljs-built_in">std</span>;<span class="hljs-keyword">const</span> <span class="hljs-keyword">int</span> maxn=<span class="hljs-number">1e5</span>+<span class="hljs-number">5</span>;<span class="hljs-keyword">const</span> <span class="hljs-keyword">int</span> maxm=<span class="hljs-number">1e5</span>+<span class="hljs-number">5</span>;<span class="hljs-meta">#<span class="hljs-meta-keyword">define</span> rep(i,a,n) for(int i=a;i&lt;n;++i)</span><span class="hljs-meta">#<span class="hljs-meta-keyword">define</span> per(i,a,n) for(int i=n-1;i&gt;=a;--i)</span><span class="hljs-keyword">typedef</span> <span class="hljs-keyword">long</span> <span class="hljs-keyword">long</span> ll;<span class="hljs-keyword">typedef</span> <span class="hljs-keyword">unsigned</span> <span class="hljs-keyword">long</span> <span class="hljs-keyword">long</span> ull;<span class="hljs-keyword">typedef</span> <span class="hljs-built_in">vector</span>&lt;<span class="hljs-keyword">int</span>&gt; vi;<span class="hljs-keyword">typedef</span> pair&lt;<span class="hljs-built_in">string</span>,<span class="hljs-built_in">string</span>&gt; pss;<span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span>&#123;    ios::sync_with_stdio(<span class="hljs-literal">false</span>);    <span class="hljs-built_in">string</span> ss;    <span class="hljs-keyword">while</span>(<span class="hljs-built_in">cin</span>&gt;&gt;ss)&#123;        <span class="hljs-keyword">int</span> len= ss.length();        <span class="hljs-keyword">int</span> t=len/<span class="hljs-number">8</span>;        rep(i,<span class="hljs-number">0</span>,t)&#123;            per(j,<span class="hljs-number">0</span>,<span class="hljs-number">8</span>)&#123;                <span class="hljs-built_in">cout</span>&lt;&lt;ss[i*<span class="hljs-number">8</span>+j];            &#125;        &#125;        <span class="hljs-keyword">for</span>(<span class="hljs-keyword">int</span> i=len<span class="hljs-number">-1</span>;i&gt;=t*<span class="hljs-number">8</span>;i--) <span class="hljs-built_in">cout</span>&lt;&lt;ss[i];        <span class="hljs-built_in">cout</span>&lt;&lt;<span class="hljs-built_in">endl</span>;    &#125;&#125;</code></pre><h1 id="收获与反思"><a href="#收获与反思" class="headerlink" title="收获与反思"></a>收获与反思</h1><p>暂无</p>]]></content>
    
    
    <categories>
      
      <category>Computer Science</category>
      
      <category>ACM</category>
      
      <category>CSU</category>
      
    </categories>
    
    
    <tags>
      
      <tag>ACM</tag>
      
      <tag>CSU</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>【CSU-2183】解题报告（水题）</title>
    <link href="/post/3fce0650.html"/>
    <url>/post/3fce0650.html</url>
    
    <content type="html"><![CDATA[<h1 id="原始题目"><a href="#原始题目" class="headerlink" title="原始题目"></a>原始题目</h1><h2 id="2183-击鼓传花简单版"><a href="#2183-击鼓传花简单版" class="headerlink" title="2183: 击鼓传花简单版"></a>2183: 击鼓传花简单版</h2><ul><li>Time Limit: 1 Sec     </li><li>Memory Limit: 128 Mb     </li><li>Submitted: 165     </li><li>Solved: 41    </li></ul><h3 id="Description"><a href="#Description" class="headerlink" title="Description"></a>Description</h3><p>岳麓山下旌旗卷，CSU运动会隆重开幕了，小Q所在的班级参加了“击鼓传花”趣味比赛。</p><p>比赛规则如下，$n$个队员(不包括小Q)围成一个圈，每个人手里拿着一些花束(数量也可能为0)，小Q站在圆圈的中间，队员需要传递花束给小Q，每个鼓点只允许一个人传送一束花，最终要求圆圈上所有人的花束都传递给小Q。请问需要花多少鼓点呢？<br><a id="more"></a></p><h3 id="Input"><a href="#Input" class="headerlink" title="Input"></a>Input</h3><p>多组数据。</p><p>第一行$n$，代表队员数量。</p><p>第2行到第$n+1$行，每行一个整数$a_i$，代表每个队员最开始拿的花束数量。$(0 ≤ a_i ≤ {10}^{6})$<br>所有组的n之和不超过 $ {10}^{3} $</p><h3 id="Output"><a href="#Output" class="headerlink" title="Output"></a>Output</h3><p>一个整数，代表需要的鼓点数。</p><h3 id="Sample-Input"><a href="#Sample-Input" class="headerlink" title="Sample Input"></a>Sample Input</h3><pre><code>41254</code></pre><h3 id="Sample-Output"><a href="#Sample-Output" class="headerlink" title="Sample Output"></a>Sample Output</h3><pre><code>12</code></pre><h3 id="Hint"><a href="#Hint" class="headerlink" title="Hint"></a>Hint</h3><h3 id="Source"><a href="#Source" class="headerlink" title="Source"></a>Source</h3><h1 id="题目大意"><a href="#题目大意" class="headerlink" title="题目大意"></a>题目大意</h1><p>如题</p><h1 id="解题思路"><a href="#解题思路" class="headerlink" title="解题思路"></a>解题思路</h1><p>求和，注意long long。</p><h1 id="解题代码"><a href="#解题代码" class="headerlink" title="解题代码"></a>解题代码</h1><pre><code class="hljs C++"><span class="hljs-meta">#<span class="hljs-meta-keyword">include</span> <span class="hljs-meta-string">&lt;cstdio&gt;</span></span><span class="hljs-meta">#<span class="hljs-meta-keyword">include</span> <span class="hljs-meta-string">&lt;cstring&gt;</span></span><span class="hljs-meta">#<span class="hljs-meta-keyword">include</span> <span class="hljs-meta-string">&lt;iostream&gt;</span></span><span class="hljs-meta">#<span class="hljs-meta-keyword">include</span> <span class="hljs-meta-string">&lt;set&gt;</span></span><span class="hljs-meta">#<span class="hljs-meta-keyword">include</span> <span class="hljs-meta-string">&lt;queue&gt;</span></span><span class="hljs-meta">#<span class="hljs-meta-keyword">include</span> <span class="hljs-meta-string">&lt;stack&gt;</span></span><span class="hljs-meta">#<span class="hljs-meta-keyword">include</span> <span class="hljs-meta-string">&lt;vector&gt;</span></span><span class="hljs-meta">#<span class="hljs-meta-keyword">include</span> <span class="hljs-meta-string">&lt;bits/stdc++.h&gt;</span></span><span class="hljs-keyword">using</span> <span class="hljs-keyword">namespace</span> <span class="hljs-built_in">std</span>;<span class="hljs-keyword">const</span> <span class="hljs-keyword">int</span> maxn=<span class="hljs-number">1e5</span>+<span class="hljs-number">5</span>;<span class="hljs-keyword">const</span> <span class="hljs-keyword">int</span> maxm=<span class="hljs-number">1e5</span>+<span class="hljs-number">5</span>;<span class="hljs-meta">#<span class="hljs-meta-keyword">define</span> rep(i,a,n) for(int i=a;i&lt;n;++i)</span><span class="hljs-meta">#<span class="hljs-meta-keyword">define</span> per(i,a,n) for(int i=n-1;i&gt;=a;--i)</span><span class="hljs-meta">#<span class="hljs-meta-keyword">define</span> fi first</span><span class="hljs-meta">#<span class="hljs-meta-keyword">define</span> se second</span><span class="hljs-meta">#<span class="hljs-meta-keyword">define</span> pb push_back</span><span class="hljs-meta">#<span class="hljs-meta-keyword">define</span> np next_permutation</span><span class="hljs-meta">#<span class="hljs-meta-keyword">define</span> mp make_pair</span><span class="hljs-meta">#<span class="hljs-meta-keyword">define</span> INF 0x3f3f3f3f</span><span class="hljs-meta">#<span class="hljs-meta-keyword">define</span> EPS 1e-8</span><span class="hljs-keyword">typedef</span> <span class="hljs-keyword">long</span> <span class="hljs-keyword">long</span> ll;<span class="hljs-keyword">typedef</span> <span class="hljs-keyword">unsigned</span> <span class="hljs-keyword">long</span> <span class="hljs-keyword">long</span> ull;<span class="hljs-keyword">typedef</span> <span class="hljs-built_in">vector</span>&lt;<span class="hljs-keyword">int</span>&gt; vi;<span class="hljs-keyword">typedef</span> pair&lt;<span class="hljs-keyword">int</span>, <span class="hljs-keyword">int</span>&gt; pii;<span class="hljs-keyword">typedef</span> pair&lt;<span class="hljs-built_in">string</span>,<span class="hljs-built_in">string</span>&gt; pss;<span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span>&#123;    ios::sync_with_stdio(<span class="hljs-literal">false</span>);    ll sum=<span class="hljs-number">0</span>;    <span class="hljs-keyword">int</span> n;    <span class="hljs-keyword">while</span>(<span class="hljs-built_in">cin</span>&gt;&gt;n)&#123;        <span class="hljs-keyword">int</span> temp;        sum=<span class="hljs-number">0</span>;        rep(i,<span class="hljs-number">0</span>,n)&#123;            <span class="hljs-built_in">cin</span>&gt;&gt;temp;            sum+=temp;        &#125;        <span class="hljs-built_in">cout</span>&lt;&lt; sum&lt;&lt;<span class="hljs-built_in">endl</span>;    &#125;&#125;</code></pre><h1 id="收获与反思"><a href="#收获与反思" class="headerlink" title="收获与反思"></a>收获与反思</h1><p>注意long long。</p>]]></content>
    
    
    <categories>
      
      <category>Computer Science</category>
      
      <category>ACM</category>
      
      <category>CSU</category>
      
    </categories>
    
    
    <tags>
      
      <tag>ACM</tag>
      
      <tag>CSU</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>【CSU-2181】解题报告（枚举分界点）</title>
    <link href="/post/c938bbd1.html"/>
    <url>/post/c938bbd1.html</url>
    
    <content type="html"><![CDATA[<p>强化题目和线性做法在这里<br><a href="/post/7410a832.html" title="【CSU-2187】解题报告（维护顺序极差）">【CSU-2187】解题报告（维护顺序极差）</a></p><h1 id="原始题目"><a href="#原始题目" class="headerlink" title="原始题目"></a>原始题目</h1><h2 id="2181-翻转游戏"><a href="#2181-翻转游戏" class="headerlink" title="2181: 翻转游戏"></a>2181: 翻转游戏</h2><ul><li>Time Limit: 1 Sec     </li><li>Memory Limit: 128 Mb     </li><li>Submitted: 115     </li><li>Solved: 34    </li></ul><h3 id="Description"><a href="#Description" class="headerlink" title="Description"></a>Description</h3><p>给当一个01串，最多可以对一段区间里的01取反一次，求最多能取得的1的个数</p><a id="more"></a><h3 id="Input"><a href="#Input" class="headerlink" title="Input"></a>Input</h3><p>多组数据，第一行为数组组数$T(T ≤ 10)$</p><p>每组数据第一行一个整数 $N(1 ≤ N ≤ 100)$</p><p>第二行一个长度为$N$的01字符串</p><h3 id="Output"><a href="#Output" class="headerlink" title="Output"></a>Output</h3><p>每组数据输出一行代表答案</p><h3 id="Sample-Input"><a href="#Sample-Input" class="headerlink" title="Sample Input"></a>Sample Input</h3><pre><code>24100141111</code></pre><h3 id="Sample-Output"><a href="#Sample-Output" class="headerlink" title="Sample Output"></a>Sample Output</h3><pre><code>44</code></pre><h3 id="Hint"><a href="#Hint" class="headerlink" title="Hint"></a>Hint</h3><h3 id="Source"><a href="#Source" class="headerlink" title="Source"></a>Source</h3><h3 id="Author"><a href="#Author" class="headerlink" title="Author"></a>Author</h3><p>Wells</p><h1 id="题目大意"><a href="#题目大意" class="headerlink" title="题目大意"></a>题目大意</h1><p>如题</p><h1 id="解题思路"><a href="#解题思路" class="headerlink" title="解题思路"></a>解题思路</h1><p>枚举分界点，暴力更新最大值</p><h1 id="解题代码"><a href="#解题代码" class="headerlink" title="解题代码"></a>解题代码</h1><pre><code class="hljs C++"><span class="hljs-meta">#<span class="hljs-meta-keyword">include</span> <span class="hljs-meta-string">&lt;cstdio&gt;</span></span><span class="hljs-meta">#<span class="hljs-meta-keyword">include</span> <span class="hljs-meta-string">&lt;cstring&gt;</span></span><span class="hljs-meta">#<span class="hljs-meta-keyword">include</span> <span class="hljs-meta-string">&lt;iostream&gt;</span></span><span class="hljs-meta">#<span class="hljs-meta-keyword">include</span> <span class="hljs-meta-string">&lt;string&gt;</span></span><span class="hljs-meta">#<span class="hljs-meta-keyword">include</span> <span class="hljs-meta-string">&lt;set&gt;</span></span><span class="hljs-meta">#<span class="hljs-meta-keyword">include</span> <span class="hljs-meta-string">&lt;queue&gt;</span></span><span class="hljs-meta">#<span class="hljs-meta-keyword">include</span> <span class="hljs-meta-string">&lt;vector&gt;</span></span><span class="hljs-meta">#<span class="hljs-meta-keyword">include</span> <span class="hljs-meta-string">&lt;bits/stdc++.h&gt;</span></span><span class="hljs-keyword">using</span> <span class="hljs-keyword">namespace</span> <span class="hljs-built_in">std</span>;<span class="hljs-keyword">const</span> <span class="hljs-keyword">int</span> maxn=<span class="hljs-number">1e5</span>+<span class="hljs-number">5</span>;<span class="hljs-keyword">const</span> <span class="hljs-keyword">int</span> maxm=<span class="hljs-number">1e5</span>+<span class="hljs-number">5</span>;<span class="hljs-meta">#<span class="hljs-meta-keyword">define</span> rep(i,a,n) for(int i=a;i&lt;n;++i)</span><span class="hljs-meta">#<span class="hljs-meta-keyword">define</span> per(i,a,n) for(int i=n-1;i&gt;=a;--i)</span><span class="hljs-meta">#<span class="hljs-meta-keyword">define</span> fi first</span><span class="hljs-meta">#<span class="hljs-meta-keyword">define</span> se second</span><span class="hljs-meta">#<span class="hljs-meta-keyword">define</span> INF 0x3f3f3f3f</span><span class="hljs-meta">#<span class="hljs-meta-keyword">define</span> EPS 1e-8</span><span class="hljs-meta">#<span class="hljs-meta-keyword">define</span> mp make_pair</span><span class="hljs-meta">#<span class="hljs-meta-keyword">define</span> np next_permutation</span><span class="hljs-meta">#<span class="hljs-meta-keyword">define</span> pb push_back</span><span class="hljs-keyword">typedef</span> <span class="hljs-keyword">long</span> <span class="hljs-keyword">long</span> ll;<span class="hljs-keyword">typedef</span> <span class="hljs-keyword">unsigned</span> <span class="hljs-keyword">long</span> <span class="hljs-keyword">long</span> ull;<span class="hljs-keyword">typedef</span> <span class="hljs-built_in">vector</span>&lt;<span class="hljs-keyword">int</span>&gt; vi;<span class="hljs-keyword">typedef</span> pair&lt;<span class="hljs-keyword">int</span>,<span class="hljs-keyword">int</span>&gt; pii;<span class="hljs-keyword">typedef</span> pair&lt;<span class="hljs-built_in">string</span>,<span class="hljs-built_in">string</span>&gt; pss;<span class="hljs-keyword">int</span> t,n;vi le,ri;<span class="hljs-keyword">int</span> a[maxn];<span class="hljs-keyword">int</span> b[maxn];<span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span>&#123;    ios::sync_with_stdio(<span class="hljs-literal">false</span>);    <span class="hljs-built_in">cin</span>&gt;&gt;t;    <span class="hljs-keyword">while</span>(t--)&#123;        <span class="hljs-built_in">cin</span>&gt;&gt;n;        <span class="hljs-built_in">string</span> s;        <span class="hljs-built_in">cin</span>&gt;&gt;s;        <span class="hljs-keyword">int</span> len=s.length();        le.clear();        ri.clear();        <span class="hljs-built_in">memset</span>(a,<span class="hljs-number">0</span>,<span class="hljs-keyword">sizeof</span>(a));        <span class="hljs-built_in">memset</span>(b,<span class="hljs-number">0</span>,<span class="hljs-keyword">sizeof</span>(b));        rep(i,<span class="hljs-number">0</span>,n)&#123;            <span class="hljs-keyword">if</span>(s[i]==<span class="hljs-string">'1'</span>)&#123;                a[i+<span class="hljs-number">1</span>]=a[i]+<span class="hljs-number">1</span>;                b[i+<span class="hljs-number">1</span>]=b[i];            &#125;            <span class="hljs-keyword">else</span> &#123;                a[i+<span class="hljs-number">1</span>]=a[i];                b[i+<span class="hljs-number">1</span>]=b[i]+<span class="hljs-number">1</span>;            &#125;            <span class="hljs-keyword">if</span>(s[i]==<span class="hljs-string">'0'</span> &amp;&amp; i==<span class="hljs-number">0</span> || s[i]==<span class="hljs-string">'0'</span> &amp;&amp; s[i<span class="hljs-number">-1</span>]==<span class="hljs-string">'1'</span>) le.push_back(i+<span class="hljs-number">1</span>);            <span class="hljs-keyword">if</span>(s[i]==<span class="hljs-string">'0'</span> &amp;&amp; i==n<span class="hljs-number">-1</span> || s[i]==<span class="hljs-string">'0'</span> &amp;&amp; s[i+<span class="hljs-number">1</span>]==<span class="hljs-string">'1'</span>) ri.push_back(i+<span class="hljs-number">1</span>);        &#125;<span class="hljs-comment">//        rep(i,1,n+1)&#123; cout&lt;&lt;"#"&lt;&lt;a[i]&lt;&lt;"  "&lt;&lt;b[i]&lt;&lt;endl;&#125;</span>        <span class="hljs-keyword">if</span>(le.empty() &amp;&amp; ri.empty())&#123;            <span class="hljs-built_in">cout</span>&lt;&lt;n&lt;&lt;<span class="hljs-built_in">endl</span>;            <span class="hljs-keyword">continue</span>;        &#125;        <span class="hljs-keyword">int</span> all=a[n];        <span class="hljs-keyword">int</span> ans=-INF;        <span class="hljs-keyword">for</span>(<span class="hljs-keyword">int</span> i=<span class="hljs-number">0</span>;i&lt;le.size();i++)&#123;            <span class="hljs-keyword">for</span>(<span class="hljs-keyword">int</span> j=<span class="hljs-number">0</span>;j&lt;ri.size();j++)&#123;                <span class="hljs-keyword">if</span>(le[i]&gt;ri[j]) <span class="hljs-keyword">continue</span>;<span class="hljs-comment">//                cout&lt;&lt;"left="&lt;&lt;le[i]&lt;&lt;"  right="&lt;&lt;ri[j]&lt;&lt;endl;</span>                <span class="hljs-keyword">int</span> temp1=a[ri[j]]-a[le[i]<span class="hljs-number">-1</span>];                <span class="hljs-keyword">int</span> temp0=b[ri[j]]-b[le[i]<span class="hljs-number">-1</span>];<span class="hljs-comment">//                cout&lt;&lt;temp1&lt;&lt;"  "&lt;&lt;temp0&lt;&lt;endl;</span>                ans=max(all-temp1+temp0,ans);<span class="hljs-comment">//                cout&lt;&lt;"tempans="&lt;&lt;ans&lt;&lt;endl;</span>            &#125;        &#125;        <span class="hljs-built_in">cout</span>&lt;&lt;ans&lt;&lt;<span class="hljs-built_in">endl</span>;    &#125;&#125;</code></pre><h1 id="收获与反思"><a href="#收获与反思" class="headerlink" title="收获与反思"></a>收获与反思</h1><p>合理枚举</p>]]></content>
    
    
    <categories>
      
      <category>Computer Science</category>
      
      <category>ACM</category>
      
      <category>CSU</category>
      
    </categories>
    
    
    <tags>
      
      <tag>ACM</tag>
      
      <tag>CSU</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>金融学辅修——金融学笔记（八）</title>
    <link href="/post/c7fb8250.html"/>
    <url>/post/c7fb8250.html</url>
    
    <content type="html"><![CDATA[<h1 id="汇率"><a href="#汇率" class="headerlink" title="汇率"></a>汇率</h1><h2 id="汇率制度的类型"><a href="#汇率制度的类型" class="headerlink" title="汇率制度的类型"></a>汇率制度的类型</h2><ol><li><p>固定汇率类型（金本位和纸本位）</p><p> 共通点：</p><ul><li>各国对本国货币都规定有金平价，中心汇率是按两国货币各自的金平价之比来确定的。</li><li>外汇市场上的汇率水平相对稳定，围绕中心汇率在很小的限度内浮动。<br>不同点：</li><li>金本位制下的固定汇率制时自发形成的，纸币流通条件下，固定汇率时国际协议（布雷顿森林体系）认为建立起来的。</li><li>金本位制度下，各国货币的金平价不会变动，而在纸币流通条件下，各国货币的金平价则是可以调整的。</li></ul></li><li><p>浮动汇率制度</p><ul><li>自由浮动： 情节浮动</li><li>管理浮动： 肮脏浮动</li><li>联合浮动：（原欧洲货币体系各成员国之间保持固定汇率，对体系外，即非成员国货币则采取共同浮动做法，洞中小蛇）<br>（相关，1992年GBP危机）</li><li>单独浮动：（本国货币不与外国任何货币发生固定联系，根据外汇市场的供求状况单独浮动）</li></ul></li></ol><ol><li><p>1999年IMF新的汇率制度分类</p><ul><li>无独立法定货币的汇率安排</li><li>货币局制度（新加坡，香港）</li><li>其他传统固定汇率制</li><li>水平（上下1%）调整的钉住制</li><li>爬行钉住</li><li>爬行带内浮动（目标区）</li><li>不事先公布干预方式的管理浮动</li><li>单独浮动</li></ul></li></ol><p>专栏6-1 我国的金融机构体系——政策性金融机构</p><p>政策性金融机构，政策性金融机构由</p><p>商业金融机构</p><p>我国典当行业概况</p><p>典当实际上是一种融资渠道，典当业作为现代金融业的鼻祖，国外称之为“第二银行”。</p><h1 id="第四节-金融机构的脆弱性"><a href="#第四节-金融机构的脆弱性" class="headerlink" title="第四节 金融机构的脆弱性"></a>第四节 金融机构的脆弱性</h1><ol><li><p>金融机构的内在脆弱性</p><p> 功能有效发挥的两个前提条件</p><ol><li>投资者不能同时提现</li><li><p>银行能够效率原则，选择效益最好的项目</p><p>然而这两个前提条件并不是</p><p>挤兑的案例：海南发展银行案例。塞浦路斯银行破产危机案例。</p></li></ol></li></ol><h1 id="第五节-对金融机构体系的管理"><a href="#第五节-对金融机构体系的管理" class="headerlink" title="第五节 对金融机构体系的管理"></a>第五节 对金融机构体系的管理</h1><p>国外对金融体系的管理（以美国为例）</p><ul><li>证券交易委员会：交易所和金融市场</li><li>商品期货交易委员会：期货市场</li><li>通货监理官办公室：联邦注册的商业银行</li><li>全国信用社管理局：联邦注册的信用社</li><li>联邦存款保险公司（罗斯福时期建立）：商业银行、互助储蓄银行、储蓄贷款协会为10万美元以下的存款<br>账户提供保险</li><li>联邦储备体系：所有存款机构</li></ul><p>管理不慎案例：巴黎银行误操作导致破产。</p>]]></content>
    
    
    <categories>
      
      <category>Finance</category>
      
      <category>金融学</category>
      
    </categories>
    
    
    <tags>
      
      <tag>辅修</tag>
      
      <tag>金融学</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>金融学辅修——微观经济学笔记（四）</title>
    <link href="/post/685bcc20.html"/>
    <url>/post/685bcc20.html</url>
    
    <content type="html"><![CDATA[<h1 id="长期成本曲线"><a href="#长期成本曲线" class="headerlink" title="长期成本曲线"></a>长期成本曲线</h1><p>LTC，LMC，LMC</p><p>分别表示长期总成本，长期平均成本和长期边际成本。</p><p>曲线间的推导</p><p>成本理论的应用-1 产量分配</p><p>等边际效应解释，等边际成本时总生产成本最少。<br>（导数证明）</p><p>成本理论的应用-2 污染控制</p>]]></content>
    
    
    <categories>
      
      <category>Finance</category>
      
      <category>微观经济学</category>
      
    </categories>
    
    
    <tags>
      
      <tag>辅修</tag>
      
      <tag>微观经济学</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>《不得贪胜》读书笔记</title>
    <link href="/post/ab720150.html"/>
    <url>/post/ab720150.html</url>
    
    <content type="html"><![CDATA[<h1 id="引言-人生如棋，不得贪胜"><a href="#引言-人生如棋，不得贪胜" class="headerlink" title="引言 人生如棋，不得贪胜"></a>引言 人生如棋，不得贪胜</h1><p>《围棋十绝》</p><ul><li>不得贪胜：越是对胜利存有贪念，越得不到胜利。</li><li>入界宜缓：穿越警戒线时要缓慢。</li><li>功彼顾我：向外攻击对方的时候要回首自身形势。</li><li>弃子争先：即使丢掉部分棋子也要抢到先手。</li><li>舍小取大：放弃小的利益追求大的收获。</li><li>逢危需弃：遇到危及情况要弃子。</li><li>慎勿轻速：不要轻率快速行棋。</li><li>动须相应：每步行棋需相互配合。</li><li>彼强自保：如果对方势力强大则需先谋求自身安全。</li><li>势孤取和：形势危孤则首选平和。</li></ul><p>《围棋九品》</p><ul><li>九品守拙：方式笨拙愚蠢，但是懂得这种守卫的方法。</li><li>八品若愚：笨拙但是懂得下围棋的方法。</li><li>七品斗力：拥有可以争战的力量，围棋下得有力。</li><li>六品小巧：懂得用小的技巧。</li><li>五品用智：下围棋时略表现出智慧。</li><li>四品通幽：下围棋时仿佛已经进入深奥的围棋世界。</li><li>三品具体：博采众长，了解围棋得远近。</li><li>二品坐照：坐着能够洞察整个围棋世界。</li><li>一品入神：下围棋到达神的境界。</li></ul><blockquote><p>“您认为围棋是什么？”<br>当时我是这样回答的：<br>“我认为围棋就是不断向远方前进。”<br>现在我仍然是这么认为的。</p></blockquote><a id="more"></a><h1 id="第一章-成长"><a href="#第一章-成长" class="headerlink" title="第一章 成长"></a>第一章 成长</h1><blockquote><p>P010 “所以，直到现在，我还是个左撇子。我也记不清是从什么时候开始，我在下围棋的时候刻意用右手了，因为我得知用右手是‘对对方的尊重’，所以，没有经过痛苦的改正和纠结，我很自然地成为了两只手使用起来都很灵活的人。”<br>P011 “能够这样快快乐乐、无忧无虑度过一个阳光的童年，真是我的幸运。因为在这样的环境下，我养成了看待<br>整个世界和人生的积极态度，学会了用肯定的眼光审视周围的一切，乐观地看到事情充满可能的一面，并且从头到脚<br>饱含着走向完美人生的力量。”</p></blockquote><p>怎样的童年才是适合自己的？肆意增长？还是修剪枝叶？我个人认为李昌镐生来有着一份稚童不改的心，又很幸运的得到了<br>适合他这种心境的教育。</p><blockquote><p>P016 “进入了围棋这个成年人的世界，幼小的我内心充满着惶惑。在我眼里，围棋就是魔法的世界，围棋就是宇宙<br>的中心。世界的所有秘密都被呈现在围棋中，而只要稍微开拓一下视野，那无穷无尽的变化就会滚滚涌现。在那如同<br>迷宫般交错的横线和竖线上思索，然后每次解决困局找到新的棋路的欣喜，就如同发现天下至宝。”</p><p>P038 “但是在第二次来全州与我对局时，老师改变了对我的看法。在第二次对局的时候，让子数和第一次一样，<br>老师让我三子，但是内容却跟上次很不一样。在短短不过一个月的时间里，我好像从上次的对局中悟出了什么。我<br>的这种样子让周围的人们感觉到了一种‘深入骨髓的力量’。老师也被那种不知道是什么东西的力量所吸引，最终<br>接收我为弟子。”</p></blockquote><p>虽然昌镐拜师后，总显得下棋迟钝、笨拙，复盘也不会。但是曹薰铉老师从未试图改变他的下棋方式，即便不甚满意，<br>这就是大师识人、做事的不同吧。</p><blockquote><p>P043 “你的围棋是由你自己的气质构成的。”</p></blockquote><!--more--><h1 id="第二章-拼搏"><a href="#第二章-拼搏" class="headerlink" title="第二章 拼搏"></a>第二章 拼搏</h1><p>减少失误即为成功</p><blockquote><p>P060 “这期间，我通过研究和老师的对局不断反推对局，推出了这样的结论：‘围棋竞技的胜利属于失误少的一方’。<br>这便是我尽量回避对杀的本质原因。回避对杀并不是因为害怕对杀，而是害怕对杀过程中的诸多变化会导致不能预见的失误。”</p></blockquote><p>温故而知新——复盘的力量</p><blockquote><p>P070 “围棋有‘复盘’这样一位‘好老师’，如果你获胜了，那么复盘可以让你养成‘胜利的习惯’；如果你<br>失败了，那么复盘可以让你做好‘胜利的准备’。”</p><p>P070 “我虽然没有天才般的才能，但是我有持久力。我不断将失败的对弈重新复盘，找出失败的原因，类似于这样<br>的努力我自认为比任何人付出得都多。持久力和努力是任何人都可以做到的。只要能不懈地努力，就再也没有必要<br>害怕那些天生具有某些才能的人了。”</p></blockquote><p>强迫观念，是李昌镐的特点，而对他在棋局上的发挥而言，则是一把双刃剑。</p><blockquote><p>P073 “如果细究起来，从入段时开始，那支配我的心理，让我不知不觉开始‘认生’，开始寡言的根源，就是<br>‘强迫观念’。在由成年人围成的藩篱中，我需要不停地辗转在心里给自己定下种种规矩，我就这样不知不觉<br>变成一个‘老人般的孩子’。”</p><p>P073 “强迫观念可以说是一把双刃剑。这里说的强迫观念并不同于医学上的那种精神疾病‘强迫症’，因为<br>强迫观念并不是单纯地类似于疾病的坏东西。它包含着两个层面：一方面是不能控制强迫的症状而转变为精神疾病<br>的危险；另一方面则是通过正确的方式和坚强的意志塑造出道德观念和责任感。”</p></blockquote><p>并非单纯的授棋之师，更接近一种为人之师。石佛对老师的态度后来也体现在，婚礼上并没有邀请除老师和<br>师母以外其他围棋界的同僚，其实老师出席本身就已经体现，他对于李昌镐，早已经不单单是围棋上的老师了。</p><blockquote><p>P078 “在我的老师的思想中，老师的精神世界和一般人的层次应是不同的。它应该更接近于道人的世界。在我<br>成为职业棋手之前，他就不断教导我要先学做人。而成为职业棋手继续围棋事业的过程中，他也不断向我强调做人的<br>重要性。通过他的这些教诲，我隐隐感受到了他的为师之道。而他老人家也十分明白地向我展示了什么才是一个老师<br>应有的作为。他曾说过：‘老师就是给弟子打开前行的道路。’回到韩国，收李昌镐为徒后，我便暗下决心：‘一定<br>要按照老师的教会，践行他的为师之道’”</p></blockquote><p>站在巨人的肩膀上，也应给予巨人足够的尊重，因为他原意将肩膀借给你，作为你腾飞的奠基。</p><blockquote><p>P092 “这个世界上充斥着那些没有得到社会承认的天才。这就是世事的原则。而我这个无比犯上不敬的弟子，如果不是<br>拥有了从老师那里借来的巨人的肩膀，飞向更高、飞向更远的这种动力又从何而来呢？”</p></blockquote><h1 id="第三章-腾飞"><a href="#第三章-腾飞" class="headerlink" title="第三章 腾飞"></a>第三章 腾飞</h1><p>不断地反复咀嚼过去，围棋是零和博弈，失败一方本什么都得不到，唯一的慰藉和不幸中的万幸就是可以在失败中探索，<br>去研究，去向自己索取。</p><blockquote><p>P099 “不断地回想自己的胜利是件开心地事情，但是将失败翻来覆去地研究，是给人巨大精神压力地工作。”</p></blockquote><p>“围棋不过如此，但我也只有围棋”</p><blockquote><p>P104 “围棋是全部。能够把并不轻松人生意义通过‘围棋不过如此，但我也只有围棋’这种轻松的言语表达出来，<br>其中的哲学高度并不是每个人都能达到的。”</p><p>P141 “自信真是一种奇妙的东西，有的时候它会带来足以压倒对方的气势，而有的时候，它便回越过应有的位置，<br>成为向对方暴露要害的漫不经心。而在为其中，当必要的精密轰然倒塌时，自己的棋便无法再由自己掌控了。”</p></blockquote><p>日本的经营学者中郁次郎在《战略的本质》一书中对战略这样分析：战略并不单纯指的是桌面上的作战计划，而是与<br>对手的一种相互作用。</p><blockquote><p>P144 “围棋是以战争为模型，双方较量战略的游戏。施行战略的最高指挥官必须对和战争相关的所有因素以及敌人<br>所可能采取的行动进行细致精密的分析，全面分析过后才能确定最终行动方针。这个过程在围棋中便以布局、定式、<br>中盘、终盘、封盘的过程一一展现。”</p></blockquote><p>红皇后效应是指一个人在发生变化的同时，周围环境和竞争对手同样在变化，甚至变化的更快，自身的相对位置不升甚至<br>有可能反而下降。</p><p>红皇后这样呼喊道：“就算是想保持原位不动也要拼命地奔跑才行！”</p><blockquote><p>P155 “变化是必然的。没有进步，保持原位不动就是退步。就算是苟然无目的地向前以动，也有可能出现发展的道路。<br>拜托停滞不前的那第一部路，说不定就会成为前进的道路。”</p></blockquote><h1 id="第四章-危机"><a href="#第四章-危机" class="headerlink" title="第四章 危机"></a>第四章 危机</h1><blockquote><p>P184 “明知道有危险也要不顾一切冲上去并不能算是有勇气。能够克制住自己的冲动，拒绝外界的诱惑，默默地走<br>自己的道路，这种选择才是勇气的表现。这时决胜点在于丧失忍耐力。”</p><p>P184 “危机二字如同其字面的意思，危险和机遇是相伴相生的。”</p></blockquote><p>让一个人安静独处，有时候是最好的关怀方式。</p><h1 id="第五章-不得贪胜"><a href="#第五章-不得贪胜" class="headerlink" title="第五章 不得贪胜"></a>第五章 不得贪胜</h1><blockquote><p>P210 “赵治勋九段不顾人们含着泪的阻止，强行参加棋圣战的迫切意志，原来并不是源自于‘英雄的斗魂’，而是<br>由于急于确认迷茫未来的这种人之常情。”</p></blockquote><p>英雄往往是被媒体塑造的，但是英雄精神的内核往往就是被我们忽略的每个平常人都具有的特质，李敏镐眼里的赵九段，<br>只是用最人性的方法来确认不安中摇摆的自己的存在，外人看来疯狂而决绝，其实这是事中人必然的做法。</p><p>5岁到日本学棋，并且就像前文提到的一样，对于赵九段，围棋就意味着全部，他只有围棋，如果被突然告知不能再下围棋了，<br>无异于天降死刑，所以他不甘。</p><blockquote><p>P211 “赵九段的这个故事，生动而又深刻地向我展示了一个事实，那就是迫切感也会成为一个人再面临胜负时<br>的强大力量。”</p></blockquote><p>迫切感可以化做力量，的确如此。</p>]]></content>
    
    
    <categories>
      
      <category>Life</category>
      
      <category>阅读</category>
      
    </categories>
    
    
    <tags>
      
      <tag>阅读</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>金融学辅修——金融学笔记（七）</title>
    <link href="/post/3090aa13.html"/>
    <url>/post/3090aa13.html</url>
    
    <content type="html"><![CDATA[<h1 id="第四章-金融市场的利率"><a href="#第四章-金融市场的利率" class="headerlink" title="第四章 金融市场的利率"></a>第四章 金融市场的利率</h1><p>继续之前课堂的内容</p><h2 id="第三节-我国利率的市场化改革"><a href="#第三节-我国利率的市场化改革" class="headerlink" title="第三节 我国利率的市场化改革"></a>第三节 我国利率的市场化改革</h2><p>利率市场化进程</p><ul><li>1996.6年放开银行间同业拆借市场利率</li><li>1997.6</li></ul><p>利率机制：央行利率——银行利率——市场利率</p><p>阶段目标：“存款利率管上限，贷款利率管下限”</p><p>二元化的利率调控模式：</p><ul><li>调整存贷款基准利率（上下限）影响金融机构存贷款利率水平</li><li>通过公开市场操作及各类中央银行利率引导市场利率</li></ul><p>问题：</p><ul><li>利率市场化步骤（利率市场化，交易品种丰富化；存贷款利率市场化；法律明确）</li></ul><p>中国特点：政府推进型；渐进型；可控型；谨慎型</p><p>今后突破：贷款下限，存款上限。</p><p>古典学派的储蓄投资理论</p><ul><li>利率是由储蓄函数和投资函数共同决定的，取决于</li></ul>]]></content>
    
    
    <categories>
      
      <category>Finance</category>
      
      <category>金融学</category>
      
    </categories>
    
    
    <tags>
      
      <tag>辅修</tag>
      
      <tag>金融学</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>算法与数据结构学习——最小生成树</title>
    <link href="/post/9d402b32.html"/>
    <url>/post/9d402b32.html</url>
    
    <content type="html"><![CDATA[<h1 id="引入"><a href="#引入" class="headerlink" title="引入"></a>引入</h1><p>在之前的学习中，我们已经介绍了图的储存方式等相关内容。</p><p>（这里待补坑）</p><p>数据结构课本上引入：</p><blockquote><p>“假设要在n个城市之间建立通信联络网，则连通n个城市只需要n-1条线路。这时，自然会考虑<br>这样一个问题，如何在最节省经费的前提下建立这个通信网”</p></blockquote><p>在含有n个结点的连通网中挑选n-1条边构造一颗边权和最小（耗费最小），这个问题就是最小代价生成树（<br>Minimum Cost Spanning Tree）（简称<strong>最小生成树</strong>）构造问题。</p><h2 id="定义补充"><a href="#定义补充" class="headerlink" title="定义补充"></a>定义补充</h2><p>关于图的几个概念定义：</p><p><strong>连通图</strong>：在无向图中，若任意两个顶点vivi与vjvj都有路径相通，则称该无向图为连通图。</p><p><strong>强连通图</strong>：在有向图中，若任意两个顶点vivi与vjvj都有路径相通，则称该有向图为强连通图。</p><p><strong>连通网</strong>：在连通图中，若图的边具有一定的意义，每一条边都对应着一个数，称为权；权代表着连接连个顶点的代价，称这种连通图叫做连通网。</p><p><strong>生成树</strong>：一个连通图的生成树是指一个连通子图，它含有图中全部n个顶点，但只有足以构成一棵树的n-1条边。一颗有n个顶点的生成树有且仅有n-1条边，如果生成树中再添加一条边，则必定成环。</p><p><strong>最小生成树</strong>：在连通网的所有生成树中，所有边的代价和最小的生成树，称为最小生成树。</p><a id="more"></a><h1 id="算法"><a href="#算法" class="headerlink" title="算法"></a>算法</h1><p>构造最小生成树有很多算法，但是他们都是利用了最小生成树的同一种性质：</p><p>MST性质：假设N=(V,{E})是一个连通网，U是顶点集V的一个非空子集，如果（u，v）是一条具有最小权值的边，<br>其中u属于U，v属于V-U，则必定存在一颗包含边（u，v）的最小生成树</p><p>性质证明：</p><blockquote><p>反证法：假设网N的任何一棵最小生成树都不包含（u，v）。设T是连通网上的一棵最小生成树，<br>当将边（u，v）加入到T中时，由生成树的定义，T中必存在一条包含（u，v)的回路。另一方面，由于T是生成树，<br>则在T上必存在另一条边（u’，v’），其中u’∈U，v’∈V - U，且u和u’之间，v和v’之间均有路径相通。<br>删去边（u’，v’），便可消除上述回路，同时得到另一棵生成树T’。因为（u，v）的代价不高于（u’，v’），<br>则T’的代价亦不高于T，T’是包含（u，v）的一棵最小生成树，和假设矛盾。</p></blockquote><p>下面就介绍两种使用MST性质生成最小生成树的算法：普里姆算法（Prim）和克鲁斯卡尔（Kruskal）算法。</p><p>2、普里姆算法—Prim算法</p><p>首先就是从图中的一个起点a开始，把a加入U集合，然后，寻找从与a有关联的边中，<br>权重最小的那条边并且该边的终点b在顶点集合：（V-U）中，我们也把b加入到集合U中，<br>并且输出边（a，b）的信息，这样我们的集合U就有：{a,b}，然后，我们寻找与a关联和b关联的边中，<br>权重最小的那条边并且该边的终点在集合：（V-U）中，我们把c加入到集合U中，并且输出对应的那条边的信息，<br>这样我们的集合U就有：{a,b,c}这三个元素了，一次类推，直到所有顶点都加入到了集合U。</p>]]></content>
    
    
    <categories>
      
      <category>Computer Science</category>
      
      <category>算法与数据结构</category>
      
    </categories>
    
    
    <tags>
      
      <tag>算法与数据结构</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>算法与数据结构学习——线索二叉树</title>
    <link href="/post/4db7e28a.html"/>
    <url>/post/4db7e28a.html</url>
    
    <content type="html"><![CDATA[<h1 id="引入"><a href="#引入" class="headerlink" title="引入"></a>引入</h1><p>在之前的学习中，我们能够感觉到，二叉树的非递归遍历需要用到栈结构的原因是需要之前遍历的信息。</p><p>以<strong>二叉链表</strong>作为存储结构时，只能找到<strong>结点的左、右孩子信息</strong>，而不能直接得到结点在任一序列中的前驱和<br>后继信息，这种信息只能在动态过程中才能得到。</p><p>我们想保存这个信息，该怎么办？</p><p>通过考察各种二叉链表，不管形态如何，空链域的个数总是多过非空链域的个数。<br>准确的说，<strong>n 个结点的二叉链表共有 2n 个链域，非空链域为 n-1 个，其中的空链域必定有 n+1 个</strong>。如下图所示。</p><p><img src="https://eddyblog.oss-cn-shenzhen.aliyuncs.com/%E7%AE%97%E6%B3%95%E4%B8%8E%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E5%AD%A6%E4%B9%A0%E2%80%94%E2%80%94%E7%BA%BF%E7%B4%A2%E4%BA%8C%E5%8F%89%E6%A0%91/1.png" srcset="/img/loading.gif" alt="1.png"></p><p>实际上，我们可以利用好这些空链域来存放结点的前驱和后继信息。</p><h1 id="线索二叉树"><a href="#线索二叉树" class="headerlink" title="线索二叉树"></a>线索二叉树</h1><pre><code class="hljs C++"><span class="hljs-comment">// 二叉树的二叉线索存储表示</span><span class="hljs-keyword">typedef</span> <span class="hljs-keyword">enum</span> PointerTag&#123;    Link,    Thread&#125;; <span class="hljs-comment">//0 为孩子指针  1为线索指针</span><span class="hljs-keyword">typedef</span> <span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">BiThrNode</span>&#123;</span>    TElemType data;    <span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">BiThrNode</span> *<span class="hljs-title">lchild</span>, *<span class="hljs-title">rchild</span>;</span> <span class="hljs-comment">//左右孩子/线索指针</span>    PointerTag LTag, RTag;             <span class="hljs-comment">//左右标识</span></code></pre><p>线索化的实质就是将二叉链表中的空指针改为指向前驱或后继的线索。<br>由于前驱和后继信息只有在遍历该二叉树时才能得到，<br>所以，线索化的过程就是在遍历的过程中修改空指针的过程。<br><strong>遍历即线索化过程</strong>。</p><a id="more"></a><pre><code class="hljs C++">BiThrTree pre; <span class="hljs-comment">//表示遍历的上一点</span><span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">InThreading</span><span class="hljs-params">(BiThrTree p)</span></span>&#123;    <span class="hljs-keyword">if</span> (p)    &#123;        InThreading(p-&gt;lchild); <span class="hljs-comment">//遍历左子树</span>        <span class="hljs-keyword">if</span> (!p-&gt;lchild)         <span class="hljs-comment">//当前点没有左孩子</span>        &#123;            p-&gt;LTag = Thread; <span class="hljs-comment">//前驱线索标记</span>            p-&gt;lchild = pre;  <span class="hljs-comment">//左孩子指针指向前驱</span>        &#125;        <span class="hljs-keyword">if</span> (!pre-&gt;rchild) <span class="hljs-comment">//前驱点没有右孩子</span>        &#123;            pre-&gt;RTag = Thread; <span class="hljs-comment">//后继线索标记</span>            pre-&gt;rchild = p;    <span class="hljs-comment">//右孩子指针指向后继</span>        &#125;        pre = p;        InThreading(p-&gt;rchild); <span class="hljs-comment">//遍历右子树</span>    &#125;&#125;</code></pre><p>中间代码做的事情：</p><p>对中间结点的左孩子判断（是否存在直接前驱），如果不存在的话左孩子的指针并不是空，而是指向保存的前驱结点。<br>同时对前驱结点的右孩子判断（是否存在直接后继），如果不存在的话指向当前的结点。</p><p>如图：</p><p><img src="https://eddyblog.oss-cn-shenzhen.aliyuncs.com/%E7%AE%97%E6%B3%95%E4%B8%8E%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E5%AD%A6%E4%B9%A0%E2%80%94%E2%80%94%E7%BA%BF%E7%B4%A2%E4%BA%8C%E5%8F%89%E6%A0%91/2.png" srcset="/img/loading.gif" alt="2.png"></p><p><img src="https://eddyblog.oss-cn-shenzhen.aliyuncs.com/%E7%AE%97%E6%B3%95%E4%B8%8E%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E5%AD%A6%E4%B9%A0%E2%80%94%E2%80%94%E7%BA%BF%E7%B4%A2%E4%BA%8C%E5%8F%89%E6%A0%91/3.png" srcset="/img/loading.gif" alt="3.png"></p><p>完成前驱和后继以后，线索二叉树的遍历，实际上等于操作一个双向链表结构。</p><p>如图：</p><p><img src="https://eddyblog.oss-cn-shenzhen.aliyuncs.com/%E7%AE%97%E6%B3%95%E4%B8%8E%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E5%AD%A6%E4%B9%A0%E2%80%94%E2%80%94%E7%BA%BF%E7%B4%A2%E4%BA%8C%E5%8F%89%E6%A0%91/4.png" srcset="/img/loading.gif" alt="4.png"></p><h1 id="参考博客"><a href="#参考博客" class="headerlink" title="参考博客"></a>参考博客</h1><p><a href="https://www.cnblogs.com/guweiwei/p/7090050.html" target="_blank" rel="noopener">彻底理解线索二叉树</a></p>]]></content>
    
    
    <categories>
      
      <category>Computer Science</category>
      
      <category>算法与数据结构</category>
      
    </categories>
    
    
    <tags>
      
      <tag>算法与数据结构</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>金融学辅修——金融学笔记（六）</title>
    <link href="/post/e290dd8c.html"/>
    <url>/post/e290dd8c.html</url>
    
    <content type="html"><![CDATA[<h1 id="课前小组分享"><a href="#课前小组分享" class="headerlink" title="课前小组分享"></a>课前小组分享</h1><h2 id="资本市场和衍生品市场"><a href="#资本市场和衍生品市场" class="headerlink" title="资本市场和衍生品市场"></a>资本市场和衍生品市场</h2><h3 id="我国资本市场的发展历程"><a href="#我国资本市场的发展历程" class="headerlink" title="我国资本市场的发展历程"></a>我国资本市场的发展历程</h3><p>探索阶段——成长阶段——协调发展阶段——深化改革依法治市阶段</p><h3 id="股票市场"><a href="#股票市场" class="headerlink" title="股票市场"></a>股票市场</h3><p>股票发行和流通的场所，可以分为一级和二级：一级发行，二级流通。</p><p>职能：<br>积聚 转让 转化 </p><p>基本性质：<br>不可偿还行 参与性 收益性（可以参与流通） 流通性（可以二次流通） 波动性和风险性</p><p>股票的分类：</p><p>股东权利分类：普通股，优先股，后配股</p><p>上市地区分类：A股，B股，H股（香港），N股（纽约），S股</p><p>按业绩分类：绩优股，垃圾股，蓝筹股</p><h3 id="债券市场"><a href="#债券市场" class="headerlink" title="债券市场"></a>债券市场</h3><p>政府、企业、银行，到期还本付息的？？</p><p>基本性质：<br>偿还性，流通性，安全性，</p><p>企业破产时，债权人索取资产优先于股东</p><p>债券融资的优点和缺点：</p><p>优点：<br>资本成本低，具有财务杠杆作用，所筹集资金属于长期资金，债券投资范围广</p><p>缺点：<br>限制条件多，</p><h3 id="衍生品市场"><a href="#衍生品市场" class="headerlink" title="衍生品市场"></a>衍生品市场</h3><p>远期、期货、互换、期权</p><p>是一种金融合约。XXX</p><ol><li><p>远期合约</p><p> 远期利率协议、远期外汇合约、远期股票合约。</p><p> 相关风险：时间跨度大，不确定因素多，规模和持仓量都不如现期。</p></li><li><p>期货</p><p> 期货交易分类：商品期货和金融期货。</p><p> 最大的区别就是双向交易，可以买多也可以卖空。价格上涨时可以低买高卖。</p></li><li><p>互换</p><p> 互换交易</p></li></ol><a id="more"></a><h2 id="非现金支付"><a href="#非现金支付" class="headerlink" title="非现金支付"></a>非现金支付</h2><h3 id="非现金支付分类"><a href="#非现金支付分类" class="headerlink" title="非现金支付分类"></a>非现金支付分类</h3><p>票据，银行卡（信用卡，借记卡），网上支付。</p><h3 id="非现金支付的前世今生"><a href="#非现金支付的前世今生" class="headerlink" title="非现金支付的前世今生"></a>非现金支付的前世今生</h3><ol><li><p>银联诞生，信用卡开启五现金支付第一步</p><ol><li>交易场景变革。改革开放，难以满足线下大额交易。</li><li>支付产业变革 02年银联建立 创立了银联卡，提供线下清算服务。</li></ol></li><li><p>电商时代来临，第三方支付问世</p><ol><li>交易场景变革。互联网发展带动线上交易场景出现，电子商务时代来临。</li><li>支付产业变革。第三方支付，“支付宝”提出<strong>担保支付模式</strong>，虚拟账户概念，推动清算。</li></ol></li><li><p>移动时代来临，再次变革进行中</p><ol><li>移动端入口加入。</li><li>扫码支付迈向渗透线下场景的第一步</li><li>微信红包13年除夕开始发力，推动微信支付打破支付宝一方独霸的场面。</li></ol></li></ol><h3 id="支付产业变革总结"><a href="#支付产业变革总结" class="headerlink" title="支付产业变革总结"></a>支付产业变革总结</h3><h3 id="非现金支付的衍生价值"><a href="#非现金支付的衍生价值" class="headerlink" title="非现金支付的衍生价值"></a>非现金支付的衍生价值</h3><ol><li>消费金融：推动消费金融向长尾客户的渗透。</li><li>财富管理：基于互联网的财富管理新模式，具有无限商机。</li><li>政府监管：互联网信息监管，可以减少洗钱等问题。</li></ol><h3 id="废县及支付的发展现状"><a href="#废县及支付的发展现状" class="headerlink" title="废县及支付的发展现状"></a>废县及支付的发展现状</h3><ol><li><p>我国： 1362.14亿笔，金额规模4024.56万亿元。70%支付比例。</p></li><li><p>国外</p><p> 欧洲地区：</p><p> 美国：信用卡支付比较发达，但是移动支付发展比较缓慢。</p><p> 亚洲地区：新加坡提出“无现金”支付，日本看齐美国。印度发展过8%。</p><p> 非洲地区：非洲肯尼亚，M-pesa。</p></li><li><p>中外非现金支付现状差异</p><ol><li>具体方式不同：中国以移动支付为主，美国等以信用卡消费。 原因，中国没有信用卡消费的习惯和粘性。</li></ol></li><li><p>现金 or 非现金</p><ol><li>如果拒收现金，损害了人民币的法定地位。</li><li>垄断问题，政府参与系统问题。</li></ol></li></ol><h2 id="P2P小额信贷-人人贷"><a href="#P2P小额信贷-人人贷" class="headerlink" title="P2P小额信贷 人人贷"></a>P2P小额信贷 人人贷</h2><p>P2P平台，有钱需要理财和缺钱需要贷款，联络双方的一个平台。</p><p>投标，散标。</p><p>平台概况：8年，700多亿。</p><p>三倍于常规借贷，但是审核，到款快。</p><p>三条红线：资金池模式，非法集资，庞氏骗局模式。</p><h1 id="第四章-金融市场的利率"><a href="#第四章-金融市场的利率" class="headerlink" title="第四章 金融市场的利率"></a>第四章 金融市场的利率</h1><p>继续之前课堂内容</p><h2 id="关于中国的Shibor（2007年1月4日对外公布）"><a href="#关于中国的Shibor（2007年1月4日对外公布）" class="headerlink" title="关于中国的Shibor（2007年1月4日对外公布）"></a>关于中国的Shibor（2007年1月4日对外公布）</h2><ol><li><p>Shibor的定义</p><p> 中国货币市场基准利率，是根据信用等级较高的银行报出的人民币同业拆除利率计算确定的算术平均利率。</p><p> 由上海同业拆借中心进行计算和发布，因而命名为“上海银行间同业拆放利率”（Shanghai Interbank Offered Rate）</p></li><li><p>Shibor报价行名单</p><p> 中工农建交，Shibor报价行的职责：Shibor的报价每日提供基于市场情况的拆入、拆出的双边报价，并且<br> 在当日货币市场的交易中，以其报价利率为基准。报价行的报价行为应是独立的，当日的报价不得在银行间相互参照。</p></li><li><p>如何得到Shibor</p><p> 相关网站链接</p><ul><li><a href="http://www.shibor.org" target="_blank" rel="noopener">http://www.shibor.org</a></li><li><a href="http://www.chinamoney.com.cn" target="_blank" rel="noopener">http://www.chinamoney.com.cn</a></li></ul></li><li><p>利率掉期</p></li></ol><h2 id="第二节-利率的计算"><a href="#第二节-利率的计算" class="headerlink" title="第二节 利率的计算"></a>第二节 利率的计算</h2><ol><li><p>单利和复利</p><p> 单利：存贷期的各期只以本金乘以利率计算的利息</p><script type="math/tex; mode=display">S=P+r*n</script><p> 复利：指数</p></li><li><p>终值和终值洗漱</p><p> 终值是用复利计算的一笔投资在某个时间获得的本利和。</p><script type="math/tex; mode=display">S=P {(1+r)} ^ }n</script><p> 与厨师本金P相乘的系数成为终值系数。</p></li><li><p>关于计息次数</p><p> 常以年度百分率和一定的计息次数（如按月按天计息）表示，在哦同样的时间内。通常使用实际年率l</p></li><li><p>现值与贴现</p><p> 现值（present value）与终值是相对应的概念。现值就是未来收益按照一定的贴现率贴现后的当前价值。</p><ul><li><p>银行贴现：$PV=P-P \dot r \dot n$ </p><p>  现金 = 本金（期满应还）-本金 × 利率 × 时间<br>  扣除利息 = 本金 × 利率 × 时间 </p></li></ul></li></ol>]]></content>
    
    
    <categories>
      
      <category>Finance</category>
      
      <category>金融学</category>
      
    </categories>
    
    
    <tags>
      
      <tag>辅修</tag>
      
      <tag>金融学</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>亚马逊AWS云计算讲座笔记</title>
    <link href="/post/1dc46f40.html"/>
    <url>/post/1dc46f40.html</url>
    
    <content type="html"><![CDATA[<h1 id="亚马逊历史"><a href="#亚马逊历史" class="headerlink" title="亚马逊历史"></a>亚马逊历史</h1><p>1994 年发展起来，除大中华区，电商巨头</p><p>云计算 AWS， Amazon Web Service 2006 年成立</p><p>Gartner IT 行业咨询公司</p><p><strong>市场占有率</strong>：AWS 44.1%，2016 数据，</p><h1 id="正式演讲"><a href="#正式演讲" class="headerlink" title="正式演讲"></a>正式演讲</h1><h2 id="云计算的由来"><a href="#云计算的由来" class="headerlink" title="云计算的由来"></a>云计算的由来</h2><p>工业革命：两次对动力系统的革新</p><p>动力轴对比电网供电：稳定性，可调节性，初始投资，动力成本，可拓展性。</p><p>？？So how about 云计算</p><a id="more"></a><p>第三次工业革命</p><p>企业 IT 系统：办公系统/CRM/ERP/生产销售管理<br>招标建设运维模式：需求-&gt;招标-&gt;厂家选择-&gt;工程建设-&gt;系统运行维护-&gt;再需求</p><p>互联网产业带来新需求</p><ul><li>新需求<ul><li>超大规模</li><li>敏捷（Agile） Emmm 该补功课了（新需求到新产品的滞后期）</li></ul></li></ul><p>互联网企业先有<strong>流量</strong>，再有<strong>变现</strong>。</p><p>变现途径：广告，增值服务，游戏，出租服务。</p><p>先有：</p><ul><li>新需求-&gt;新技术-&gt;新思想-&gt;新组织模式</li></ul><p>以变现作为驱动力：</p><ul><li>技术扩散-&gt;云计算</li></ul><h2 id="案例分析云计算价值"><a href="#案例分析云计算价值" class="headerlink" title="案例分析云计算价值"></a>案例分析云计算价值</h2><p>前例：AWS+JPL NASA 卫星图像的分析，2 小时</p><ol><li><p>案例 1：降低创新门槛</p><p>产品创新一套测试环境：6 服务器+1 交换机</p><ul><li>传统模式需要 2 到 6 周时间</li><li>AWS 云环境？（虚拟服务器配置）</li></ul></li><li><p>案例 2：弹性扩展</p><p>某电信行业软件巨头新功能交付：2~3 月</p><ul><li>需求分析与系统设计：4 周</li><li>代码编写与单元测试：2~3 周</li><li>系统回归测试：4 周<ul><li>测试结果是否和预期一致</li><li>确保软件稳定性：数十万测试用例</li><li>缩短交付周期：自动化测试；集中所有可用硬件设备并行测试</li><li>瓶颈：可用硬件设备有限，继续扩充利用率和成本有问题。</li></ul></li></ul></li></ol><h3 id="云计算的六个优势"><a href="#云计算的六个优势" class="headerlink" title="云计算的六个优势"></a>云计算的六个优势</h3><ol><li>Trade capital expense for variable expensive</li><li>Benefit from massive economies of scale</li><li>Stop guessing about capacity</li><li>Increase speed and agility</li><li>Stop spending money running and maintaining data centers</li><li>Go global in minutes</li></ol><h2 id="AWS-的大数据和-AI-平台"><a href="#AWS-的大数据和-AI-平台" class="headerlink" title="AWS 的大数据和 AI 平台"></a>AWS 的大数据和 AI 平台</h2><p>Amazon 平台可用的开源工具</p><p>数据价值递减曲线 《《待补充</p><p>最近的数据 非常有价值</p><ul><li>如果你及时采取行动</li></ul><p>旧的数据+新的数据 更有价值</p><ul><li>如果你能找到联系他们的方法</li></ul><p>Amazon 机器学习平台堆栈：应用服务 API<br>基础设施框架，平台服务，应用服务。</p><p>平台：Amazon SageMaker<br>大规模构架，直接调优模型，调优算法</p><h2 id="AWS-Academy-Program"><a href="#AWS-Academy-Program" class="headerlink" title="AWS Academy Program"></a>AWS Academy Program</h2><h3 id="AWS-Academy-计划"><a href="#AWS-Academy-计划" class="headerlink" title="AWS Academy 计划"></a>AWS Academy 计划</h3><p>学期课程为一个一个学期，<br>AWS Cloud Practitioner</p><h3 id="AWS-Educate"><a href="#AWS-Educate" class="headerlink" title="AWS Educate"></a>AWS Educate</h3><p>教育优惠</p><h3 id="AWS-认证路径"><a href="#AWS-认证路径" class="headerlink" title="AWS 认证路径"></a>AWS 认证路径</h3><p>job market 不错</p><p>开发者，系统管理员，架构师。</p><p>Dockers 容器</p><h2 id="AWS-Training-and"><a href="#AWS-Training-and" class="headerlink" title="AWS Training and"></a>AWS Training and</h2><h2 id="Q-amp-A"><a href="#Q-amp-A" class="headerlink" title="Q&amp;A"></a>Q&amp;A</h2><ol><li><p>对于 Amazon 的认证</p><p>课程本身应该不是免费的。</p></li><li><p>Amazon 本身需求在 AWS 的占比</p><p>可见比例，但是具体并不知道，另外还有 Netflix 在里面占有比较大的比例（全托管)</p></li><li><p>服务器征用，有可见选项</p><p>折扣比较低</p></li><li><p>对于中国云市场的整体看法</p></li><li><p>Amazon 对于云计算在以后的拓展方向</p><p>最开始只有 S3，对象存储。</p></li><li><p>云平台，信息安全问题</p><p>观念问题落后于实际问题</p></li></ol>]]></content>
    
    
    <categories>
      
      <category>Research</category>
      
      <category>讲座会议</category>
      
    </categories>
    
    
    <tags>
      
      <tag>讲座会议</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>Python学习——《FlaskWeb开发》笔记（一）</title>
    <link href="/post/6cb7680e.html"/>
    <url>/post/6cb7680e.html</url>
    
    <content type="html"><![CDATA[<h1 id="第一部分-Flask-简介"><a href="#第一部分-Flask-简介" class="headerlink" title="第一部分 Flask 简介"></a>第一部分 Flask 简介</h1><h2 id="第-1-章-安装"><a href="#第-1-章-安装" class="headerlink" title="第 1 章 安装"></a>第 1 章 安装</h2><p>Flask 有 3 个主要依赖：</p><ol><li>路由、调试和 Web 服务器网关接口子系统由 Werkzeug 提供；</li><li>模板系统由 Jinja2 提供；</li><li>命令行集成由 Click 提供。</li></ol><p>这些依赖都是 Flask 的开发者 Armin Ronacher 开发的。</p><p>原生不支持数据库访问、Web 表单验证和用户身份验证，但是可通过拓展形式实现。</p><ul><li>虚拟环境安装<br>pip install virtualenv</li></ul><p>Windows 注意修改 PATH 环境变量</p><h2 id="第-2-章-应用的基本架构"><a href="#第-2-章-应用的基本架构" class="headerlink" title="第 2 章 应用的基本架构"></a>第 2 章 应用的基本架构</h2><ol><li><p>初始化应用实例</p><p>所有来自客户端的请求都交由应用实例（Flask 类对象）处理。</p></li><li><p>路由和视图函数</p><p>客户端（Web）浏览器把<strong>请求</strong>发送给 Web 服务器，Web 服务器再把请求发送给 Flask 应用实例。<br>应用实例保存 URL 请求到 Python 函数的映射关系，处理 URL 和函数之间关系的程序称之为<strong>路由</strong>。</p><p>最简单的方法（app.route）装饰器：</p><pre><code class="hljs Python">@app.route('/')def index()    return '&lt;h1&gt;Hello World!&lt;/h1&gt;'</code></pre><p>index()这样处理入站请求的函数称之为<strong>视图函数</strong>，函数的返回值称之为<strong>响应</strong>，是客户端接收到的内容。</p><p>路由 URL 中放在尖括号里面的内容是动态部分，任何能匹配到静态部分的 URL 会映射到这个路由上，调用视图函数时，<br>Flask 会将动态部分作为<strong>参数</strong>传入函数</p><pre><code class="hljs Python"><span class="hljs-meta">@app.route('/user/&lt;name&gt;') # 任何匹配静态部分的URL都走这个路由</span><span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">user</span><span class="hljs-params">(name)</span>:</span> <span class="hljs-comment"># 尖括号里的name作为参数传递进视图函数</span>    <span class="hljs-keyword">return</span> <span class="hljs-string">'&lt;h1&gt;Hello, &#123;&#125;!&lt;/h1&gt;'</span>.format(name)</code></pre></li><li><p>请求-相应循环</p><ol><li><p>应用和请求上下文<br><strong>请求对象</strong>封装了客户端发送的 HTTP 请求。方便使用，会通过上下文变为全局可访问。<br>上下文全局变量：current_app, g, request, session</p></li><li><p>请求分派<br>URL 映射，路由。Flask 为每个路由都制定了请求方法，这样即使不同的请求方法发送到相同 URL 上，也会<br>使用不同的视图函数来处理</p></li><li>请求对象<br>上下文变量 request 对外开放请求对象，包含全部信息。</li><li>请求钩子<br>请求钩子通过装饰器实现，四种钩子：before_request, before_first_request, after_request, teardown_request</li><li>响应<br>多数情况下，视图函数返回值作为响应内容。字符串，状态。response 对象。URL 重定向。</li><li>Flask 扩展</li></ol></li></ol><h2 id="第-3-章-模板"><a href="#第-3-章-模板" class="headerlink" title="第 3 章 模板"></a>第 3 章 模板</h2><p><strong>模板</strong>是包含响应文本的文件，其中包含用占位变量表示的动态部分，其具体值只在请求的上下文中才能知道。<br>使用真实值替换变量，再返回最终得到的响应字符串，这一过程称为<strong>渲染</strong>。Jinja2</p><ol><li><p>变量<br>大括号两层括起来的部分就是变量，可以识别复杂类型，加过滤器（渲染时事变变换），如|capitalize, |lower<br>,|upper, |title, |trim, |striptags:.</p><pre><code>{{ name }} 表示name是等待视图函数传递的变量eg&lt;p&gt; A value from a dictionary : {{ mydict['key'] }}, &lt;/p&gt;&lt;p&gt; A value from a list : {{ mylist[-1] }}, &lt;/p&gt;&lt;p&gt; A value from a dictionary with 过滤器: {{ mydict['key']|striptags: }}, &lt;/p&gt;</code></pre></li><li><p>控制结构</p><p>条件判断</p><pre><code>{% if user %}            Hello, {{ user }}        {% else %}            Hello. Stranger        {% endif %}</code></pre><p>初步尝试</p><pre><code class="hljs html">&#123;% extends "bootstrap/base.html" %&#125; &#123;% block title %&#125;Flasky&#123;% endblock %&#125; &#123;%block navbar %&#125;<span class="hljs-tag">&lt;<span class="hljs-name">div</span> <span class="hljs-attr">class</span>=<span class="hljs-string">"navbar navbar-inverse"</span> <span class="hljs-attr">role</span>=<span class="hljs-string">"navigation"</span>&gt;</span>  <span class="hljs-tag">&lt;<span class="hljs-name">div</span> <span class="hljs-attr">class</span>=<span class="hljs-string">"container"</span>&gt;</span>    <span class="hljs-tag">&lt;<span class="hljs-name">div</span> <span class="hljs-attr">class</span>=<span class="hljs-string">"navbar-header"</span>&gt;</span>      <span class="hljs-tag">&lt;<span class="hljs-name">button</span>        <span class="hljs-attr">type</span>=<span class="hljs-string">"button"</span>        <span class="hljs-attr">class</span>=<span class="hljs-string">"navbar-toggle"</span>        <span class="hljs-attr">data-toggle</span>=<span class="hljs-string">"collapse"</span>        <span class="hljs-attr">data-target</span>=<span class="hljs-string">".navbar-collapse"</span>      &gt;</span>        <span class="hljs-tag">&lt;<span class="hljs-name">span</span> <span class="hljs-attr">class</span>=<span class="hljs-string">"sr-only"</span>&gt;</span>Toggle navigation<span class="hljs-tag">&lt;/<span class="hljs-name">span</span>&gt;</span>        <span class="hljs-tag">&lt;<span class="hljs-name">span</span> <span class="hljs-attr">class</span>=<span class="hljs-string">"icon-bar"</span>&gt;</span><span class="hljs-tag">&lt;/<span class="hljs-name">span</span>&gt;</span>        <span class="hljs-tag">&lt;<span class="hljs-name">span</span> <span class="hljs-attr">class</span>=<span class="hljs-string">"icon-bar"</span>&gt;</span><span class="hljs-tag">&lt;/<span class="hljs-name">span</span>&gt;</span>        <span class="hljs-tag">&lt;<span class="hljs-name">span</span> <span class="hljs-attr">class</span>=<span class="hljs-string">"icon-bar"</span>&gt;</span><span class="hljs-tag">&lt;/<span class="hljs-name">span</span>&gt;</span>      <span class="hljs-tag">&lt;/<span class="hljs-name">button</span>&gt;</span>      <span class="hljs-tag">&lt;<span class="hljs-name">a</span> <span class="hljs-attr">class</span>=<span class="hljs-string">"navbar-brand"</span> <span class="hljs-attr">href</span>=<span class="hljs-string">"/"</span>&gt;</span>Flasky<span class="hljs-tag">&lt;/<span class="hljs-name">a</span>&gt;</span>    <span class="hljs-tag">&lt;/<span class="hljs-name">div</span>&gt;</span>    <span class="hljs-tag">&lt;<span class="hljs-name">div</span> <span class="hljs-attr">class</span>=<span class="hljs-string">"navbar-collapse collapse"</span>&gt;</span>      <span class="hljs-tag">&lt;<span class="hljs-name">ul</span> <span class="hljs-attr">class</span>=<span class="hljs-string">"nav navbar-nav"</span>&gt;</span>        <span class="hljs-tag">&lt;<span class="hljs-name">li</span>&gt;</span><span class="hljs-tag">&lt;<span class="hljs-name">a</span> <span class="hljs-attr">href</span>=<span class="hljs-string">"/"</span>&gt;</span>Home<span class="hljs-tag">&lt;/<span class="hljs-name">a</span>&gt;</span><span class="hljs-tag">&lt;/<span class="hljs-name">li</span>&gt;</span>      <span class="hljs-tag">&lt;/<span class="hljs-name">ul</span>&gt;</span>    <span class="hljs-tag">&lt;/<span class="hljs-name">div</span>&gt;</span>  <span class="hljs-tag">&lt;/<span class="hljs-name">div</span>&gt;</span><span class="hljs-tag">&lt;/<span class="hljs-name">div</span>&gt;</span>&#123;% endblock %&#125; &#123;% block content %&#125;<span class="hljs-tag">&lt;<span class="hljs-name">div</span> <span class="hljs-attr">class</span>=<span class="hljs-string">"container"</span>&gt;</span>  <span class="hljs-tag">&lt;<span class="hljs-name">div</span> <span class="hljs-attr">class</span>=<span class="hljs-string">"page-header"</span>&gt;</span>    &#123;% if name == "ryx" %&#125; &#123;# 注意==符号还有 双引号 #&#125;    <span class="hljs-tag">&lt;<span class="hljs-name">h1</span>&gt;</span>Hello, 大哥 &#123;&#123; name|striptags: &#125;&#125;!<span class="hljs-tag">&lt;/<span class="hljs-name">h1</span>&gt;</span>    &#123;% else %&#125;    <span class="hljs-tag">&lt;<span class="hljs-name">h1</span>&gt;</span>Hello, 小老弟 &#123;&#123; name|striptags:&#125;&#125;!<span class="hljs-tag">&lt;/<span class="hljs-name">h1</span>&gt;</span>    &#123;% endif %&#125;  <span class="hljs-tag">&lt;/<span class="hljs-name">div</span>&gt;</span><span class="hljs-tag">&lt;/<span class="hljs-name">div</span>&gt;</span>&#123;% endblock %&#125;</code></pre></li></ol>]]></content>
    
    
    <categories>
      
      <category>Computer Science</category>
      
      <category>Python</category>
      
    </categories>
    
    
    <tags>
      
      <tag>Python</tag>
      
      <tag>Flask</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>金融学辅修——金融学笔记（五）</title>
    <link href="/post/879e9655.html"/>
    <url>/post/879e9655.html</url>
    
    <content type="html"><![CDATA[<h1 id="课前同学分享"><a href="#课前同学分享" class="headerlink" title="课前同学分享"></a>课前同学分享</h1><p>银监会和保监会</p><p>混业经营，灰色地带。</p><p>2018年3月人大表决通过，设立中国银行保险监督管理委员会，即银监会和保监会合并。<br>4月正式挂牌。</p><p>小微企业的重要性</p><p>企业规模小，生命周期不长，缺乏质押品，信用记录不够完善。</p><p>阶段性成就：</p><p>银保监会措施:</p><ol><li>更好的借贷：降低对小微企业的贷款抵押以来，缩短周期，满足小微企业的资金需求。</li><li>更好的考核：疏通货币政策的传导机制</li></ol><p>银保监会的建议：</p><ol><li>偏离主业，过度融资，高杠杆 去也自身的问题。</li><li></li></ol><h1 id="课堂知识"><a href="#课堂知识" class="headerlink" title="课堂知识"></a>课堂知识</h1><h2 id="信用与中小微企业融资"><a href="#信用与中小微企业融资" class="headerlink" title="信用与中小微企业融资"></a>信用与中小微企业融资</h2><h2 id="普惠金融（额外内容）"><a href="#普惠金融（额外内容）" class="headerlink" title="普惠金融（额外内容）"></a>普惠金融（额外内容）</h2><p>普惠金融的背景、意义、界定、现状等等</p><p>章前引言：十九大报告之——建设现代化经济体系</p><p><strong>六大任务</strong></p><ol><li>深化供给侧结构性改革</li><li>加快建设创新型国家</li><li>实施乡村振兴战略</li><li>实施区域协调发展战略</li><li>加快完善社会主义市场经济体制</li><li>推动形成全面开放格局</li></ol><p>根据乡村振兴战略的目标发展而来<br><a id="more"></a></p><h3 id="章前引例"><a href="#章前引例" class="headerlink" title="章前引例"></a>章前引例</h3><p>实施乡村振兴战略的四大经济手段：</p><ol><li>发展多种习惯是适度规模经营</li><li>培育新型农业经营主体</li><li>促进农产品一二三产业融合发展</li><li>支持和鼓励农民就业创业</li></ol><p>三农市场潜在金融产品和服务需求：</p><ol><li>农业季节性生产特征。（农忙时节）</li><li></li></ol><p>发展的困难，供给不足的障碍：</p><ol><li>缺乏盈利记录和交易信息，难以纳入评估体系</li><li>缺乏可靠的抵押物品，难以得到传统信贷业务覆盖。</li><li>征信问题</li><li>地理分散，增大负担</li></ol><p>小微、三农</p><p>联合国定义：</p><blockquote><p>能<strong>有效、全方位</strong>为社会<strong>所有阶层和群体</strong>，提供服务的金融体系。</p></blockquote><h1 id="第四章-金融市场的利率"><a href="#第四章-金融市场的利率" class="headerlink" title="第四章 金融市场的利率"></a>第四章 金融市场的利率</h1><p>金融市场的利率</p><p>利率与利率的含义/利率的计算/利率市场化/利率理论/利率期限结构</p><h2 id="第一节-利率与利率的含义"><a href="#第一节-利率与利率的含义" class="headerlink" title="第一节 利率与利率的含义"></a>第一节 利率与利率的含义</h2><p>基准利率——金融市场体系中的中枢神经</p><p>美国联邦准备金率——同业拆借利率</p><p>基准利率必须是市场化体制下产生的利率：</p><p>原则：相关性、可测性、可控性、灵敏性。</p><p>伦敦同业拆借利率（Libor）</p><p>利率-利息率</p><p>指借贷期间所形成的利息率额与本金的比率。反映利息水平的高低，一种重要的经济杠杆。</p><p>利率体系：（利率的种类）</p><p>市场利率与基准利率。<br>名义利率与实际利率  r=i+p</p><p>r=(1+i)(1+p)-1</p><ul><li>固定利率与浮动利率（浮动利率提前签好，3%；LIBOR+-0.3%）</li><li>市场利率与官定利率</li><li>一般利率与优惠利率</li><li>平均利率、基准利率和到期收益率</li></ul><p>Shibor ？？？？？？</p><p>利率掉期 利率掉期示意图 兴业银行和花旗银行</p><p>最明显的问题  327国债期货</p>]]></content>
    
    
    <categories>
      
      <category>Finance</category>
      
      <category>金融学</category>
      
    </categories>
    
    
    <tags>
      
      <tag>辅修</tag>
      
      <tag>金融学</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>金融学辅修——微观经济学笔记（三）</title>
    <link href="/post/df76d545.html"/>
    <url>/post/df76d545.html</url>
    
    <content type="html"><![CDATA[<p>承接上一篇</p><h1 id="第二章-需求、价格与供求关系"><a href="#第二章-需求、价格与供求关系" class="headerlink" title="第二章 需求、价格与供求关系"></a>第二章 需求、价格与供求关系</h1><h2 id="第六节-需求弹性和供给弹性"><a href="#第六节-需求弹性和供给弹性" class="headerlink" title="第六节 需求弹性和供给弹性"></a>第六节 需求弹性和供给弹性</h2><p>待补充</p><ol><li>影响需求的价格弹性的因素</li></ol><p>eg：禁毒增加还是减少了与毒品相关的犯罪</p><ul><li>需求弹性小，供给弹性大。</li><li>禁毒是控制供给。</li><li>控制需求更为重要，反毒品教育是控制需求。</li></ul><p>互补、替代</p><p>需求量：互补商品反向变化，替代商品同向变化。</p><ol><li>需求的收入弹性</li></ol><p>Em&gt;1，Em=1，Em&lt;1，Em=0，Em&lt;0（劣质物品，吉芬品）</p><p>恩格尔系数的弹性概念解释</p><h2 id="第七节-运用供求曲线的事例"><a href="#第七节-运用供求曲线的事例" class="headerlink" title="第七节 运用供求曲线的事例"></a>第七节 运用供求曲线的事例</h2><ol><li></li><li><p>价格政策 Price controls</p><ul><li>价格调节有其不完善性，需要价格政策来支持。<strong>短期性和无序性</strong></li><li>支持价格【最低限价】（Price Floor） ：政府为了保护或者扶持某个行业而出台的产品最低价格。</li><li><p>支持农产品的作用：稳定农产品，调整农业结构。</p><p>（属于宏观调控，防止市场调节的滞后性）</p><p>最高限价总是高于市场的均衡价格。目的往往是抑制某些产品的价格上涨，尤其是为了应对通货膨胀。</p><p>最低限价总是低于市场的均衡价格。目的往往是扶持某些行业的发展。</p></li></ul></li><li><p>价格上限的弊端</p><ul><li>价格水平低不利于刺激生产。</li></ul></li></ol><ol><li>限制价格的弊端<ul><li>一般在战争或者自然灾害时期使用。</li></ul></li></ol><p>政府税收对均衡价格的影响</p><p>从量税与从价税：从量税根据<strong>商品销售数量</strong>征税；从价税根据<strong>商品销售收入</strong>征税。</p><p>对消费者征税，需求曲线左移。<br>对生产者征税，供给曲线左移。</p>]]></content>
    
    
    <categories>
      
      <category>Finance</category>
      
      <category>微观经济学</category>
      
    </categories>
    
    
    <tags>
      
      <tag>辅修</tag>
      
      <tag>微观经济学</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>Python学习——《笨方法学Python3》笔记（一）</title>
    <link href="/post/6e80eb1e.html"/>
    <url>/post/6e80eb1e.html</url>
    
    <content type="html"><![CDATA[<h1 id="习题-1-习题-22"><a href="#习题-1-习题-22" class="headerlink" title="习题 1~习题 22"></a>习题 1~习题 22</h1><p>学了什么</p><p>格式化字符串:</p><pre><code class="hljs Python">w = <span class="hljs-string">f"What I want is <span class="hljs-subst">&#123;you&#125;</span>."</span><span class="hljs-comment"># 此处you为变量名，格式化字符串会用变量替换对应的位置</span></code></pre><p>字符串填充：</p><pre><code class="hljs Python">w = <span class="hljs-string">"What I want is &#123;&#125;."</span>w.format(<span class="hljs-string">"R"</span>) <span class="hljs-comment"># 或者其他变量</span><span class="hljs-comment"># 通过字符串的format方法填充对应位置</span><span class="hljs-comment"># '+'可以用来拼接</span></code></pre><p>print()</p><pre><code class="hljs Python"><span class="hljs-comment"># 缺省最后一个参数 end='\n' ，默认是换行</span></code></pre><p>引入模块（库）</p><pre><code class="hljs Python"><span class="hljs-keyword">from</span> sys <span class="hljs-keyword">import</span> argvscript, file_name = argv<span class="hljs-comment"># 解包</span><span class="hljs-comment"># argv[0]为程序运行的名称，后面变量在命令行中输入，个数需要匹配，否则报错</span></code></pre><p>文件操作</p><pre><code class="hljs Python"><span class="hljs-comment"># oepn()第一个参数为字符串，是文件名，第二个参数操作方式，缺省为"r"只读</span><span class="hljs-comment"># open()的返回值为一个文件对象</span>file_name = <span class="hljs-string">"eddy.txt"</span>target = open(file_name, <span class="hljs-string">"r"</span>)in_data = target.read() <span class="hljs-comment"># 读取内容</span>target.close() <span class="hljs-comment"># 最后要关闭</span>file_name = <span class="hljs-string">"eddy.txt"</span>in_data = open(file_name, <span class="hljs-string">"w"</span>).write(<span class="hljs-string">"Well, Allright"</span>)<span class="hljs-comment"># 'w'写入</span><span class="hljs-comment"># 这种操作写入完成后会自动关闭文件，无需再写close（而且也不知道咋写，没名字）</span></code></pre><a id="more"></a><h1 id="习题-23-习题-39"><a href="#习题-23-习题-39" class="headerlink" title="习题 23~习题 39"></a>习题 23~习题 39</h1><h2 id="循环、列表与字典"><a href="#循环、列表与字典" class="headerlink" title="循环、列表与字典"></a>循环、列表与字典</h2><p>循环</p><pre><code class="hljs Python"><span class="hljs-comment"># 少用while多用for，尤其是已知循环次数的时候</span><span class="hljs-keyword">for</span> i <span class="hljs-keyword">in</span> range(<span class="hljs-number">3</span>,<span class="hljs-number">5</span>)<span class="hljs-comment"># range 左闭右开</span><span class="hljs-keyword">for</span> i <span class="hljs-keyword">in</span> change<span class="hljs-comment"># change为列表，后面会介绍</span><span class="hljs-comment"># for虚幻的时候i就被定义了，每次碰到则赋值为当前循环的元素值</span></code></pre><p>列表，有的地方叫做数组，这里按照 python 的习惯说法称之为列表。列表支持按照角标随机访问。</p><pre><code class="hljs Python">_count = [<span class="hljs-number">1</span>,<span class="hljs-number">2</span>,<span class="hljs-number">3</span>,<span class="hljs-number">4</span>,<span class="hljs-number">5</span>]fruits = [<span class="hljs-string">'apples'</span>,<span class="hljs-string">'oranges'</span>,<span class="hljs-string">'pears'</span>,<span class="hljs-string">'apricots'</span>]change = [<span class="hljs-number">1</span>,<span class="hljs-string">'pennies'</span>,<span class="hljs-number">2</span>,<span class="hljs-string">'dimes'</span>,<span class="hljs-number">3</span>,<span class="hljs-string">'quarters'</span>]<span class="hljs-comment"># 列表添加末尾（类似push_back）</span>new_word = <span class="hljs-string">'new'</span>change.append(new_word)<span class="hljs-comment"># 列表中的列表，二维列表</span>[[<span class="hljs-number">1</span>,<span class="hljs-number">2</span>,<span class="hljs-number">3</span>],[<span class="hljs-number">4</span>,<span class="hljs-number">5</span>,<span class="hljs-number">6</span>]]</code></pre><p>字典（类比 C++STL 里的 map）实际上就是映射，不过这里不用在乎类型。</p><pre><code class="hljs Python"><span class="hljs-comment"># 注意大括号</span>states = &#123;  <span class="hljs-string">'Oregon'</span>: <span class="hljs-string">'OR'</span>,  <span class="hljs-string">'Florida'</span>: <span class="hljs-string">'FL'</span>,  <span class="hljs-string">'New York'</span>: <span class="hljs-string">'NY'</span>&#125;<span class="hljs-comment"># 对于字典的循环</span><span class="hljs-keyword">for</span> i,j <span class="hljs-keyword">in</span> list(states.items()):    print(i,j)</code></pre><p>字典的 get 方法（尤其注意第二个参数的缺省值）</p><pre><code class="hljs Python"><span class="hljs-comment"># 描述</span><span class="hljs-comment"># Python 字典 get() 函数返回指定键的值，如果值不在字典中返回默认值。</span><span class="hljs-comment"># 语法</span><span class="hljs-comment"># get()方法语法：</span>dict.get(key, default=<span class="hljs-keyword">None</span>)<span class="hljs-comment"># 参数</span><span class="hljs-comment"># key -- 字典中要查找的键。</span><span class="hljs-comment"># default -- 如果指定键的值不存在时，返回该默认值值</span>city = cities.get(<span class="hljs-string">'TX'</span>, <span class="hljs-string">'Does Not Exist'</span>)<span class="hljs-comment"># 所以书目中cities字典中虽然没有键值为'TX'的映射，但是设置了未查到的返回值。 此时city的值为'Does Not Exist'</span></code></pre><h2 id="关于切片-多说点"><a href="#关于切片-多说点" class="headerlink" title="关于切片 多说点"></a>关于切片 多说点</h2><p>如此，我们会得到从 starting_index 对应元素开始，到 ending_index 对应元素结束，但是不包括 ending_index 对应元素，所组成的子序列的内容。起止索引都是可选的选项，如果没有提供或者为 None，那么开始索引默认为 0，结束索引默认为序列最末尾的索引。切片的访问模式，有第三个值，类似于步长，其访问类似下面代码</p><pre><code class="hljs Python"><span class="hljs-meta">&gt;&gt;&gt; </span>(<span class="hljs-string">'a'</span>,<span class="hljs-string">'b'</span>,<span class="hljs-string">'c'</span>,<span class="hljs-string">'d'</span>)[<span class="hljs-number">0</span>:<span class="hljs-number">3</span>:<span class="hljs-number">2</span>](<span class="hljs-string">'a'</span>, <span class="hljs-string">'c'</span>)food=<span class="hljs-string">'appale pie'</span>print(food[<span class="hljs-number">-3</span>:<span class="hljs-number">7</span>])</code></pre><p>后面，-3 其实是 6 的位置</p><pre><code class="hljs Python"><span class="hljs-keyword">import</span> numpy <span class="hljs-keyword">as</span> npa = np.array([[<span class="hljs-number">-1</span>,<span class="hljs-number">2</span>],[<span class="hljs-number">2</span>,<span class="hljs-number">3</span>]])b = np.array([[<span class="hljs-number">3</span>,<span class="hljs-number">4</span>],[<span class="hljs-number">4</span>,<span class="hljs-number">5</span>]])<span class="hljs-keyword">print</span> <span class="hljs-string">'\n a:\n'</span>,a<span class="hljs-keyword">print</span> <span class="hljs-string">'\n b:\n'</span>,b<span class="hljs-comment">##转置</span><span class="hljs-keyword">print</span> <span class="hljs-string">'\n a transpose:\n'</span>,a.T<span class="hljs-comment">##共扼矩阵</span><span class="hljs-comment">#print '\n a H:\n',a.I</span><span class="hljs-comment">##逆矩阵</span><span class="hljs-keyword">print</span> <span class="hljs-string">'\n a inv:\n'</span>,np.linalg.inv(a) <span class="hljs-comment"># 求逆</span><span class="hljs-comment">##转置</span><span class="hljs-keyword">print</span> <span class="hljs-string">'\n a transpose:\n'</span>,a.T<span class="hljs-comment"># a + b，矩阵相加</span><span class="hljs-keyword">print</span> <span class="hljs-string">"\n a+b: \n"</span>,a+b<span class="hljs-comment"># a - b，矩阵相减</span><span class="hljs-keyword">print</span> <span class="hljs-string">"\n a-b: \n"</span>,a-b<span class="hljs-comment">#2x2 矩阵，矩阵相乘</span><span class="hljs-keyword">print</span> <span class="hljs-string">"\n a mul b:\n"</span>,a.dot(b.T)<span class="hljs-comment">#2x3矩阵，矩阵点乘</span><span class="hljs-keyword">print</span> <span class="hljs-string">"\n a dot b: \n"</span>,a*b<span class="hljs-comment">#2x3矩阵，矩阵点除</span><span class="hljs-keyword">print</span> <span class="hljs-string">"\n a/b \n:"</span>,a/np.linalg.inv(b)<span class="hljs-comment">#求迹</span><span class="hljs-keyword">print</span> <span class="hljs-string">"\n a trace"</span>,np.trace(a)<span class="hljs-comment">#特征，特征向量</span>eigval,eigvec = np.linalg.eig(a)<span class="hljs-comment">#eigval = np.linalg.eigvals(a) #直接求解特征值</span><span class="hljs-keyword">print</span> <span class="hljs-string">"\n a eig value:\n"</span>,eigval,<span class="hljs-keyword">print</span><span class="hljs-string">'\n a eig vector:\n'</span>,eigvec</code></pre>]]></content>
    
    
    <categories>
      
      <category>Computer Science</category>
      
      <category>Python</category>
      
    </categories>
    
    
    <tags>
      
      <tag>Python</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>《金融的本质：伯南克四讲美联储》读书笔记</title>
    <link href="/post/bea42f1e.html"/>
    <url>/post/bea42f1e.html</url>
    
    <content type="html"><![CDATA[<h1 id="第一讲-美联储的起源与使命"><a href="#第一讲-美联储的起源与使命" class="headerlink" title="第一讲 美联储的起源与使命"></a>第一讲 美联储的起源与使命</h1><p>本讲先说说中央银行的定一、职能、以及他是符合在美国出现的，我还会介绍美联储如何应对其第一次重大挑战，即<br>20世纪30年代的经济大萧条。</p><p>第二讲中，回顾二战后美联储的发展状况、80年代如何战胜通胀，格林斯潘任期内的<br>“大缓和”时期，以及1945年后发生的其它一些变化。危机如何形成，以及导致08~009年经济危机的部分原因。</p><p>第三讲中，近期发生的事件，此轮金融危机最严重的阶段，危机发生的原因和后果，还有美联储褐其他政策制定者对<br>危机的应对等。</p><p>第四讲中，危机的后果，危机后的经济衰退和美联储的应对措施（包括货币政策），以及金融监管方面的变革。此外，还会对<br>金融危机如何改变央行的运作方式，以及美联储未来会如何运作，进行一些前瞻性的讨论。</p><h2 id="央行是什么"><a href="#央行是什么" class="headerlink" title="央行是什么"></a>央行是什么</h2><p>中央银行的职能，第一个是维持宏观经济稳定，即追求经济稳定增长，避免大幅度波动（如衰退等），并维持低通胀，<br>经济稳定只能。另一个职能，也是这一系列讲座重点探讨的一个功能，就是金融稳定职能，中央银行要尽可能保证金融系统<br>的正常运作，尤其要尽可能防止金融恐慌，避免发生金融危机。</p><p>稳定经济方面的工具主要是货币政策：公开市场买卖证券来降低或提高短期利率，调整隔夜拆借利率。</p><p>应对金融恐慌的工具主要是流动性供给：短期信贷平息市场情绪，维持金融机构稳定性，“最后贷款人”工具。</p><p>第三个工具是金融监管：评估，非中央银行独有。系列讲座不予以详谈。</p><h2 id="什么是金融恐慌"><a href="#什么是金融恐慌" class="headerlink" title="什么是金融恐慌"></a>什么是金融恐慌</h2><blockquote><p>P007 “总体来说，金融恐慌是由大家对金融机构失去信心而引起的。”</p><p>P009 “如果金融机构持有期限较长的非流动性资产——非流动性意味着出售这些资产（如贷款）需要花费相当多<br>的时间和精力，而支持这些资产的资金（如发放贷款的资金）却主要来自资产负债表另一侧的短期负债（如储蓄），<br>那么金融恐慌随时都有可能发生。”</p></blockquote><p>关于央行职能和相应政策，白芝浩。</p><blockquote><p>P010 “在恐慌时期，中央银行应大量放款，只要找上门来的人有抵押物，就可以放宽给他，中央银行需要持有<br>安全的抵押物，以确保能收回贷款，因此这些抵押必须是优质安全的，否则贷款时就必须带着计算。当然中央银行<br>还应征收惩罚税率，这样人们才不会利用这种恐慌局势来占便宜。人们愿意支付较高水平的利率，这表明他们确实<br>急需现金。”</p></blockquote><h2 id="金本位的利与弊"><a href="#金本位的利与弊" class="headerlink" title="金本位的利与弊"></a>金本位的利与弊</h2><p>南北战争结束到20世纪30年代，美国实行的一直是金本位制。</p><blockquote><p>P013 “真正的金本位制会创造出一个自我管理的货币体系，而这样的货币体系至少能部分替代央行的职能。”</p><p>P013 “不幸的是，金本位制还远非完善的货币体系。比如，金本位制造成了极大的资源浪费，从一处地下（开采处）<br>转移到另一处地下（美联储），除此以外，实际表明金本位制还会导致许多更严重的金融及经济问题。”</p></blockquote><p>金本位带来的还有：央行货币政策工具受到限制，国家间固定汇率体系，投机冲击。</p><h2 id="美联储的起源"><a href="#美联储的起源" class="headerlink" title="美联储的起源"></a>美联储的起源</h2><blockquote><p>P017 “1913年，在所有研究全部完成以后，国会终于通过了《联邦储备法案》，奠定了美联储成立的基础，威尔逊<br>总统把签署《联邦储备法案》看作自己执政期间最重要的国内政治成就。”</p></blockquote><p>之前有过两次尝试，但是由于以商业街为代表的普通民众和以华尔街为代表的资本家之间存在重大分歧，即美联储是否能<br>代表整个国家的利益，前两次尝试均以失败告终。</p><p>威尔逊总统通过在各城市分散建立12个联邦储备银行，而非在华盛顿建立一家中央银行，解决了两大群体的主要纠纷。12个<br>联邦储备区，其中每一个区都有一家联邦储备银行。华盛顿的联邦储备委员会监管着整个系统。</p><blockquote><p>P019 “当美联储制定货币政策时，它会考虑整个国家所有联邦储备银行的意见，再在国家层面上制定相关政策。”</p></blockquote><a id="more"></a><h2 id="美联储的第一次大挑战"><a href="#美联储的第一次大挑战" class="headerlink" title="美联储的第一次大挑战"></a>美联储的第一次大挑战</h2><p>面对“大萧条”，美联储在这个时期做了什么呢？不幸的是，当首次面临此类重大挑战时，美联储无论是在货币政策还是在<br>金融稳定方面都表现得不尽如人意。原因有很多，防止股市投机，信奉清算主义，维护金本位。</p><p>最后贷款人方面，也对银行业挤兑现象反映不足，致使大量银行破产，这种反应迟钝很大程度上还是因为对清算注意的认同。</p><blockquote><p>P027 “尽管罗斯福采取的许多措施并没有奏效，但在我看来，他有两项工作确实有效解决了那些由美联储造成<br>的问题。第一项就是于1934年建立了联邦存款保险公司。从那以后，即便银行倒闭，普通储户仍然可以拿回自己的钱，<br>这样他们就没有动机再去银行挤兑了……罗斯福做的另一件事就是废除了金本位制。废除金本位制后，他允许放松<br>货币政策，扩张货币供给，这就结束了通货紧缩，使经济在1933到1934年间经历了一个短期的有力反弹。”</p></blockquote><p><strong>罗斯福的上述两件措施，根本上解决美联储未尽责而造成或者加重的问题。</strong></p><p>应对首次挑战时两大职能未尽其力，当后来的危机以及2008到2009年的金融危机到来时，<br>我们应该牢牢记住这些曾经的教训。</p><h2 id="对话"><a href="#对话" class="headerlink" title="对话"></a>对话</h2><ol><li>紧缩货币政策防止股票投机的探讨，如何正确应对泡沫？<blockquote><p>P028 “我们当然知道资产价格泡沫十分危险，也想尽可能地化解这些泡沫。但若要通过金融监管途径来解决，<br> 那就应该采用更具针对性的解决办法，而不仅仅是提高利率水平这种带有普遍杀伤力的方法。调整保证金要求的方法<br> 就好得多，因为至少还可以根据业务的不同制定不同的标准。”</p></blockquote></li></ol><ol><li><p>回归金本位制有可能吗？</p><p> 金本位制从长期看可以保持价格稳定，解决通胀问题，但是短期的金矿开采等各种事情都会导致波动，逐年看就不正确了。</p><blockquote><p>P029 “我认为无论从实践还是政策角度来看，金本位制都不可行。在实践方面，一个很简单的事实就是，黄金总量不足以<br> 支持整个国际金本位体系……如今，经济史学家们认为，工人运动在‘一战’后更加强大，使得政府<br> 对失业开始有了更多的担忧，19世纪之前，人们甚至都不会去衡量失业率，但是‘一战’后，人们开始<br> 更多地关注失业和经济周期。”</p></blockquote><p> 承诺金本位制就等于承诺无论失业情况多糟糕，央行都不会采取货币政策干预。不现实也是不可能的，而且民众会因<br> 怀疑而拿现金换黄金，从而引起冲击。</p></li><li><p>关于“大萧条”期间的二次衰退，和我们该注意的问题？</p><p> 未被普遍认可的说法，“大萧条期间”有过两次经济衰退：分别是1929至1933年和1937年至1938年。第二次衰退是由于<br> 政策转向过早，收紧财政和货币政策导致的，当然同期还有其他事情的影响。</p></li><li><p>“大萧条”期间为什么没有更多的全球性合作？</p><p> “一战”留下的不良情绪，德国正面临不得不支付战争赔款的处境，英法在战争债务上一直有政治，国际政治环境糟糕，<br> 并没有理想的合作空间。</p><blockquote><p>P034 “同时，对于实施固定汇率的国家来说，国家间的央行合作更为重要，20世纪20年代，各国因为金本位制形成了<br> 固定汇率体系，这就意味着一国货币政策将影响到其他国家。这是个关于央行非常有必要进行国际合作的很好的例子，但<br> 这种合作并没有出现。”</p></blockquote><p> 当然在今天的灵活汇率制度下，作者认为这种合作是非常必要的。</p></li></ol><h1 id="第二讲-“二战”后的美联储"><a href="#第二讲-“二战”后的美联储" class="headerlink" title="第二讲 “二战”后的美联储"></a>第二讲 “二战”后的美联储</h1><h2 id="货币政策与通货膨胀"><a href="#货币政策与通货膨胀" class="headerlink" title="货币政策与通货膨胀"></a>货币政策与通货膨胀</h2><blockquote><p>P038 “‘二战期间’，美联储与财政部‘合作’，利用自身管利率的职能，使利率保持在低位，从而帮助美国政府以较低成本为“二战”<br>筹资。这就是美联储在二战中扮演的决策。”</p></blockquote><p>如果一国利率长期维持在低水平，尤其是经济增长和复苏时仍是如此，就可能造成经济过热和通货膨胀。</p><p>1951年美国财政部与美联储签署《美联储——财政部协议》，这一协议的重大意义在于使美国政府第一次承认<br>央行（美联储）的独立运行。</p><blockquote><p>P039 “特别是，一个独立运行的央行可以不去理会短期的政治压力，例如为了选举而被迫刺激经济。这样一来，独立的<br>央行就可以采取一些立足长远的举措并且能取得更好的效果。这方面的证据是相当充分的。所以，独立运行是世界各主要<br>央行的典型特征，这意味着它们所做的决定不会受短期政治压力影响。”</p></blockquote><p>20世纪60年代后期和70年代初期，美国财政政策总体上过于宽松。越南战争和其他政府计划增加了政府支出和赤字，<br>使得美国经济雪上加霜。</p><blockquote><p>P042 “我要讲的另一个问题是工资——物价管制政策。在20世纪70年代初期，当通货膨胀率上升到约5%时，理查德·尼克松总统<br>引入了工资——物价管制政策，通过颁布一系列法律，禁止企业提高它们的产品价格。”</p></blockquote><p>实际上即是通过行政手段，破坏了需求对价格的影响（微观），人为限制。</p><p>价格是经济的温控器，是经济赖以运行的机制。所以，管制物资和物价意味着整个经济体系存在短缺及其他各种问题。</p><blockquote><p>P043 “除此之外，正如弗里德曼所说，这项政策就像通过破坏温控器来调节一个过热的炉子。事实上，最根本的问题<br>是需求总量太大推高了价格，简单地通过一项法律来禁止涨价并没有解决货币政策过度宽松和需求过大的根本问题。”</p></blockquote><p>沃尔克的铁腕政策虽然带来了短期（80年代初期）的副作用，即高失业率，但是把通货膨胀水平大幅度压低，经济增长<br>恢复到正常水平，经济形势稳定，国民对政府更加信任，奠定了格林斯潘上任后“大缓和”时代的基础。</p><h2 id="金融危机的前奏"><a href="#金融危机的前奏" class="headerlink" title="金融危机的前奏"></a>金融危机的前奏</h2><p>信贷门槛降低，抵押贷款质量降低，房价大幅上涨，住房抵押贷款清偿率上升。</p><h2 id="房地产泡沫的破灭"><a href="#房地产泡沫的破灭" class="headerlink" title="房地产泡沫的破灭"></a>房地产泡沫的破灭</h2><blockquote><p>P056 “房价崩盘造成了一系列严重的后果。其中之一就是，很多人因为他们的房子价格上涨、<br>手上有很多股票而觉得自己非常富有，但突然发现房价和股票都缩水了，这意味着他们抵押贷款<br>欠的钱已经大大超过房屋的价值。情况颠倒过来了，借款人的房产实际上已经是负责产。07年开始<br>房屋抵押贷款的数字呈现负资产的状况变得越来越明显。”</p></blockquote><p>导致房价暴涨暴跌并演变成严重的经济危机德原因，既存在于私人部门，也存在与公共部门。</p><p>私人部门：</p><ol><li><p>借债过多，杠杆过度，人们过于自信，风险保护措施不够。</p></li><li><p>短期融资方式受到偏爱，但这些负债容易遭受挤兑。</p></li><li><p>投入到风险管理的信息技术和资源不足以帮助人们意识到风险存在和严重程度。</p></li></ol><p>公共部门：</p><ol><li><p>监管未能与时俱进，具体以美联储为关注点来说，一是在监管银行和银行持股公司时，对风险<br>的计量做得不够。二是消费者保护上做得不够好，没有向住房抵押贷款人提供必要的保护。</p></li><li><p>缺少对整个系统的监管，多数只是关注经济系统的某个部分。</p></li></ol><p>争议性话题——货币政策的作用：</p><p>通过低利率刺激房地产需求？说法的合理性待定，几个驳斥的理由：</p><ol><li><p>其他国家/地区的房价降低与飙升和利率的高低并没有太大关系，对于拥有相同中央银行的德国和西班牙，<br>德国危机期间，房价维持的很好，西班牙房价的激增却远超美国。</p></li><li><p>泡沫大小，并没有表现出与利率变化有较大的关系。</p></li><li><p>泡沫的时机，一些经济学家的研究认为，泡沫开始于利率调低之前，而且房价激增的一部分原因还来自于<br>国外对于安全美元资产的需求。</p></li></ol><h2 id="对话-1"><a href="#对话-1" class="headerlink" title="对话"></a>对话</h2><ol><li><p>上一讲中提到“大萧条”时期政策收紧的太早，那么如何判恰当时机？是只有一个恰当的时机还是时机一直在变？</p><p> 预测时机很难，这也是美联储要拥有如此之多的经济学家和模型的原因。预测并不是非常准确，尤其是20世纪70年代，预期<br> 不受任何限制，归功于沃尔克和格林斯潘，在通胀率保持较低水平的情况下，美联储有更大余地，即使一段时间内政策宽松，<br> 也不会陷入工资和物价交替上涨的恶性循环，预期会变得明朗一些。</p></li></ol><ol><li><p>如果01年时您是美联储主席，您会让利率保持在那样低的水平上吗？您认为当时那样做是正确的吗？</p><blockquote><p>P069 “总之，适当的运用货币政策是能实现宏观经济整体稳定的，但也不能忽视金融失衡。<br> 我认为美联储本可以在监管上表现得更为激进，以确保发起的贷款具有更高的质量。”</p></blockquote></li><li><p>低利率会导致私人投资者和银行面临更大的风险，您认为这会不会触发危机？</p><blockquote><p>P071 “这个问题很好。我认为低利率对投资风险加大有一定的影响，但是这有涉及经济平衡的问题，在经济衰退阶段，总的来说，<br> 大多数投资者变得非常谨慎，过去一段时间当然也是如此。人们想要让风险大小合理，不多不少，这需要金融监管<br> 发挥作用，尤其是对大型机构（例如银行）直接监管以确保其风险管理得当。这又回到了‘用合适的政策工具来达成目的<br> ’上来。”</p></blockquote></li><li><p>21世纪初，您在关注经济走势时认为在房价泡沫积累之后会发生什么？您是否认为这将最终导致一次经济衰退。</p><p> 曾在白宫任经济顾问委员会主席时，分析了房价下跌的后果，当时的结论：虽然会导致衰退，但没有预料到<br> 会对金融体系的稳定性产生如此深远的影响。</p><p> 主要原因还是在于房价下跌于01年股票市场下跌表现得并不一致，房价下跌影响抵押贷款彻底暴露出金融体系<br> 的一些漏洞，以影响住房抵押贷款的方式破坏了金融体系的稳健性，造成恐慌，而恐慌情绪又会加剧金融体系的不稳定性。<br> 所以整个事件链条至关重要，并不仅仅时房价下跌，而是整个链条。</p><p> 体系的崩塌，而非单一泡沫的破裂。</p></li></ol><h1 id="第三讲-美联储应对金融危机的政策应对"><a href="#第三讲-美联储应对金融危机的政策应对" class="headerlink" title="第三讲 美联储应对金融危机的政策应对"></a>第三讲 美联储应对金融危机的政策应对</h1><h2 id="金融体系的漏洞"><a href="#金融体系的漏洞" class="headerlink" title="金融体系的漏洞"></a>金融体系的漏洞</h2><p> 政府支持型企业——房利美和房地美的漏洞。自身资本充足率不够，持有缺乏担保或者不受保护的住房抵押贷款。</p><h2 id="金融衍生品的泛滥"><a href="#金融衍生品的泛滥" class="headerlink" title="金融衍生品的泛滥"></a>金融衍生品的泛滥</h2><p>一些奇特的住房抵押贷款，通常是为哪些信用水平较差的人提供的，共同特征就是建立在房价保持上升态势之上。<br>例如：</p><ol><li>只付利息的浮动利率住房抵押贷款；</li><li>含权浮动利率住房抵押贷款（允许借款人改变其每期的还款额）；</li><li>超长期的住房抵押贷款（贷款期限超30年）</li><li>负摊销浮动利率住房抵押贷款（首付甚至可以低于当期利息）；</li><li>无信用证明的住房抵押贷款。</li></ol><h2 id="应对危机的举措"><a href="#应对危机的举措" class="headerlink" title="应对危机的举措"></a>应对危机的举措</h2><p>08年经济危机后，七国集团例行峰会在华盛顿举行，这次会议没有按照以往的惯例来进行，与会人员一直在讨论<br>该如何应对金融危机。</p><p>这次会议拟定了一份原则声明，根据这些原则，各国将会共同采取措施来避免那些具有系统重要性的金融机构破产。</p><blockquote><p>P095 “根据‘白芝浩原则’，缓解2金融恐慌的最佳方式就是为那些缺乏资金的机构提供流动性。但是，<br>美联储发放的所有贷款都是需要抵押担保的，不能拿纳税人的钱当儿戏。最后，资金不仅流向了银行部门，<br>而且更为广泛地流向了整个金融体系。这些政策和措施的目的是增加金融体系的稳定性，使信用再次流动起来。<br>需要强调的是，中央银行作为最后贷款人的这一职能已存在了数百年，只是与传统的银行环境相比，它现在<br>面临的体制环境发生了变化。”</p></blockquote><p>金融危机期间，从最后贷款人理论的视角来看，尽管金融产品公司令美国国际集团严重亏损，但作为世界上最大的<br>保险集团，后者还拥有大量的优质资产。因此，它可以通过将其优质资产抵押给美联储而获得贷款，以补充流动性，<br>维持日常运营。</p><p>以优质资产作为抵押，美联储发挥最后贷款人的功能，为其提供了850亿美元的贷款。</p><p>一些企业<strong>大以致于不能倒</strong>。</p><h2 id="对话-2"><a href="#对话-2" class="headerlink" title="对话"></a>对话</h2><ol><li><p>奇异住房抵押贷款等衍生品数量持续增长，为什么会给信用状况很差的人放贷？<br>如果预见了房价下跌，还会发放吗？</p><p> 对房价上涨的背景下，这种抵押贷款算不上劣质品，人们对于“房价会持续上涨”太过乐观。这是原因之一。<br> 另一个原因是，对资产证券化产品的需求在此期间大幅增长。国际客户大量需求，“精明”的金融机构把<br> 资产捆绑装饰打包后，创设AAA评级证券，出售。</p><blockquote><p>P110 “金融市场上出现的种种倾向：金融机构对自身风险管理能力过度自信，人们坚信房价会迟旭上涨，<br> 银行认为抵押贷款可以轻易转售出去，国际客户对‘安全性’资产存在大量需求。出于上述这些原因，如果<br> 房价确实能持续上涨，那么提供次级住房抵押贷款就是一项利润可观的金融业务。只有当房价下跌时，这项<br> 业务才可能会出现亏损。”</p></blockquote></li><li><p>“大而不倒”，那么对银行施以援助或任其倒闭的界线在哪里？美联储的这种决策是随机的，<br>还是有一套明晰的行事规则？</p><blockquote><p>P115 “这些机构是在全球金融危机背景下才呈现出‘大而不倒’特性的。我们做出‘大而不倒’的判断<br> 是基于这些机构的规模、复杂性和相互关联性等因素。我们从来不认为这是件好事。金融改革的主要目标之一<br> 就是破除‘大而不倒’的怪圈，因为它的存在对整个金融体系不利，对这些机构本身也不利。从许多方面来讲<br> ‘大而不倒’现象都是不公平的。但在当时的情形下，我们不得不做出如此选择，因为在众多可选方案中，<br> 这是危害性最小的一个方案。”</p></blockquote><p> 对一些系统重要性金融机构逐步要求具备额外资本，以及对于影响金融体系稳定性，可能会产生一家系统重要性<br> 银行的并购，也很可能不会被批准。</p></li></ol><h1 id="第四讲-危机的后遗症"><a href="#第四讲-危机的后遗症" class="headerlink" title="第四讲 危机的后遗症"></a>第四讲 危机的后遗症</h1><h2 id="扑灭金融危机之火"><a href="#扑灭金融危机之火" class="headerlink" title="扑灭金融危机之火"></a>扑灭金融危机之火</h2><p>关于“大规模资产购买计划”，即所谓的“量化宽松”。</p><blockquote><p>P128 “为什么美联储要购买这些资产呢？戍边插一句，这是米尔顿·弗里德曼和其他货币学派学者<br>所提到的，他们的基本观点是，当你购买国债或者政府支持型企业证券并把它们写进资产负债表时，市场中<br>可供应的同类证券就减少了。如果投资者想要持有这些证券，就必须接受较低的收益率。换句话说，如果市场中<br>可供应的同类证券减少了，投资者就会原意为这些证券支付更高的价格，这与收益率是相反的。”</p><p>P129 “因而，通过购买国债、写入资产负债表、减少这些国债的有效供给，我们有效地降低了长期国债和政府<br>支持型企业证券的利率。而且，当投资者的投资组合中不再有国债和政府支持型企业证券时，他们就不得不<br>转向其他类型的证券，比如公司债券，而这将提高其他证券的价格，降低其收益率。所以，这些行为的<br>净效应是降低大范围内证券的收益率。通常，较低的利率对经济增长具有有益的刺激效应。”</p></blockquote><p>实际上可以看作另一种货币政策：我们聚焦在长期利率，而不是短期利率上。但是，这里的基本逻辑是一致的，<br>都是降低利率，刺激经济增长。</p><h2 id="政策的指引者"><a href="#政策的指引者" class="headerlink" title="政策的指引者"></a>政策的指引者</h2><p>大规模资产计划并非真正意义上的花钱，算不上政府开支。资产，在未来的某个时间点会出售给市场，所以这些<br>花销会赚回来（在资产负债表上存在一段时间）。事实上，不花钱，不增加赤字，这个项目还可以从持有的证券<br>上获取利息，这些利润直接减少了财政赤字。</p><pre><code>财政政策：联邦政府支出和税收的工具。货币政策：美联储对利率的管控相关。</code></pre><p>美联储已经开始为投资者和公众提供指引，告诉市场认为的利率走向，期望市场更好的理解美联储的计划，<br>从而减少景荣市场的不确定性。</p><h2 id="缓慢复苏"><a href="#缓慢复苏" class="headerlink" title="缓慢复苏"></a>缓慢复苏</h2><p>现在看来，保持金融稳定与保持货币政策和经济稳定显得同等重要。诚然，美联储回到了最初的起点。要知道，<br>美联储的创建就是为了试着减少金融恐慌的影响范围；金融稳定是建立美联储的初衷。因此，现在我们兜了一圈<br>又回到了原地。</p><h1 id="对话-3"><a href="#对话-3" class="headerlink" title="对话"></a>对话</h1><ol><li><p>对金融稳定的重要性理解不深的美国人来说，花钱救助银行的行为非常不受欢迎，您是否看到了美国公众<br>和华尔街在对问题的认识上也无法达成一致？</p><p> 美联储正在通过更多的推官活动，比如新闻发布会以及其他途径，试图解释其所作所为。让外界能更好的<br> 理解美联储的政策用意，这个任务是必要而且艰巨的。</p></li></ol><ol><li><p>对于逐步退出大规模则产购买计划，如何确保投资者未来原意重新买入这些资产？</p><p>还没有理解，待后续填坑。</p></li><li><p>您在讲座中提到了在“大萧条”以及日本通货紧缩的危害，以及将目标通货膨胀率设定在零以上的论据之一<br>就是给通货紧缩的可能性提供缓冲。您认为2%是防止通货紧缩的一个足够缓冲吗？您是否考虑过更高的通胀<br>目标</p><blockquote><p>P154 “这个问题太棒了！对此已有很多学术研究，似乎国际共识是2%。几乎所有设定了通胀目标的<br> 中央银行不是将之设定为2%，就是1%~3%或类似水平。而且这里有个权衡的问题。原因是，一方面正如你所言，<br> 是为了避免或者减少通货紧缩的风险而将之设定为大于零。然而另一方面，如果通货膨胀率太高，市场<br> 就会出问题，经济体的效率会下降。总之，权衡之处在于合适的通货膨胀水平既给了你对抗通货紧缩的合理<br> 缓冲，又不至于太高而导致市场运转不灵。因此如前所述，国际共识是2%左右，这也是长期以来美联储的<br> 非正式目标。这就是我们所公布的目标，在可见的未来我们也计划保持现状。但显然研究者们仍然会<br> 探究这个议题，试图准确定位最优的平衡点。”</p></blockquote></li></ol>]]></content>
    
    
    <categories>
      
      <category>Life</category>
      
      <category>阅读</category>
      
    </categories>
    
    
    <tags>
      
      <tag>阅读</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>金融学辅修——微观经济学笔记（二）</title>
    <link href="/post/92687617.html"/>
    <url>/post/92687617.html</url>
    
    <content type="html"><![CDATA[<h1 id="第二章-需求、价格与供求关系"><a href="#第二章-需求、价格与供求关系" class="headerlink" title="第二章 需求、价格与供求关系"></a>第二章 需求、价格与供求关系</h1><h2 id="需求曲线"><a href="#需求曲线" class="headerlink" title="需求曲线"></a>需求曲线</h2><ol><li>需求 Demand：在一定时期内，各种可能的价格水平，人们愿意并且能够购买的商品量。</li></ol><p>需求表，函数关系，来表示价格与需求量的关系</p><ol><li>需求曲线<ul><li>绘制：横轴需求量，纵轴价格</li><li>一条向右下方的曲线。</li></ul></li><li><p>需求分类</p><ul><li>个人需求曲线与市场需求曲线：市场需求曲线由个人叠加，个人的较为陡直，市场的较平坦（对价格变化更加敏感） </li></ul></li></ol><h2 id="需求定理"><a href="#需求定理" class="headerlink" title="需求定理"></a>需求定理</h2><ol><li>需求需求的因素<ul><li>商品本身的价格</li><li>相关商品的价格</li><li>消费者的收入及社会分配的公平程度</li><li>消费者爱好（嗜好）    </li><li>消费者对未来的预期</li></ul></li></ol><ol><li><p>需求定理的特例</p><p> 吉芬物品 Giffen’s Goods：需求量于价格成同向变动的特殊商品。</p><p> 饥荒时期的土豆</p><p> 炫耀性物品 Consipicuous Goods：</p><p> 特例总结</p><ol><li>曲线上端回归：稀有物品（古书，名画），预期紧俏的商品。</li><li>曲线下端回归：吉芬物品，吃紧时，随价格上升需求量增加。</li><li>S曲线：原本不值钱物品值钱了，原本不值钱的值钱了。</li><li>横线，价格一定，需求无限大：</li><li>竖线，需求一定，价格无限：军需物品。</li></ol></li></ol><h2 id="供给曲线"><a href="#供给曲线" class="headerlink" title="供给曲线"></a>供给曲线</h2><ol><li><p>供给 ：在一定时间内各种可能的价格原意而且能够提供出售的该种商品的数量。</p></li><li><p>需求曲线</p><ul><li>绘制：横轴供给量，纵轴价格。</li><li>一条向右上方的曲线</li><li>单个厂商的供给曲线对比市场供给曲线：市场供给曲线更加平滑（纵轴价格不变，横轴供给量叠加）<h2 id="供给定理"><a href="#供给定理" class="headerlink" title="供给定理"></a>供给定理</h2></li></ul></li><li><p>影响供给的因素</p><ul><li>厂商的目标</li><li>厂商对未来的预期</li><li>商品本身的价格</li><li>相关商品的价格（替代品，互补品？）</li><li>生产要素的价格（商品本身价格不变，成本上升会使利润减小，供给量下降）</li><li>生产技术的变动（一般情况下，生产技术水平的提高可以提高劳动生产率，从而降低成本，增大产量）</li></ul></li></ol><h2 id="需求函数与供给函数"><a href="#需求函数与供给函数" class="headerlink" title="需求函数与供给函数"></a>需求函数与供给函数</h2><p>数学表达</p><pre><code>D=f(a1,b1,c1,d1...n1)a1,b1,c1,d1...n1代表影响需求的因素</code></pre><p>理想情况 Qd=f(P)  关于价格的一元函数</p><pre><code>S=f(a2,b2,c2,d2...n2)a2,b2,c2,d2...n2代表影响供给的因素    </code></pre><p>理想情况 Qs=f(P)  关于价格的一元函数</p><p>价格的变化体现在沿曲线的滑动，除商品自身价格以外的这些其他因素变化所导致的市场需求（供给）数量的变化<br>通常称为需求（供给）的变动。<strong>几何图形中，表示为曲线的平移</strong></p><p>消费者剩余和生产者剩余？？</p><h2 id="均衡价格"><a href="#均衡价格" class="headerlink" title="均衡价格"></a>均衡价格</h2><p>供给曲线和需求曲线的交点，此时达到市场出清的状态。</p><p>供求定理：<strong>在其他条件不变的情况下，需求变动分别引起均衡价格和均衡数量的同方向的变动，供给变动<br>引起均衡价格的反方向的变动，引起均衡数量的同方向的变动。</strong></p>]]></content>
    
    
    <categories>
      
      <category>Finance</category>
      
      <category>微观经济学</category>
      
    </categories>
    
    
    <tags>
      
      <tag>辅修</tag>
      
      <tag>微观经济学</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>【UVA-679】解题报告（二叉树）</title>
    <link href="/post/e6364ca4.html"/>
    <url>/post/e6364ca4.html</url>
    
    <content type="html"><![CDATA[<h1 id="原始题目"><a href="#原始题目" class="headerlink" title="原始题目"></a>原始题目</h1><a id="more"></a><h1 id="题目大意"><a href="#题目大意" class="headerlink" title="题目大意"></a>题目大意</h1><p>一颗完全二叉树（FBT）初始所有结点标记为false，根结点标号1，对于一个小球从根结点释放，<br>遇到false标记向左下，true标记向右下，直至到达叶子结点。每次经过标记后标记翻转。</p><p>给出完全二叉树（FBT）的深度$D$，和小球的次序$I$，求其最终下落的叶子节点标号。</p><h1 id="解题思路"><a href="#解题思路" class="headerlink" title="解题思路"></a>解题思路</h1><ul><li>考虑根节点，发现奇数次序小球向左下，偶数小球向右。</li><li>同理，若为$I$奇数，则其是到达左子树的第$ \frac {I+1}{2}$个小球，序号为$ 2 \times index $。</li><li>若位偶数，则其是到达右子树的第$ \frac {I}{2} $个小球，序号为 $ 2 \times index + 1 $。</li><li>递推n-1次<h1 id="解题代码"><a href="#解题代码" class="headerlink" title="解题代码"></a>解题代码</h1><pre><code class="hljs C++"><span class="hljs-meta">#<span class="hljs-meta-keyword">include</span> <span class="hljs-meta-string">&lt;cstdio&gt;</span></span><span class="hljs-meta">#<span class="hljs-meta-keyword">include</span> <span class="hljs-meta-string">&lt;iostream&gt;</span></span><span class="hljs-meta">#<span class="hljs-meta-keyword">include</span> <span class="hljs-meta-string">&lt;iomanip&gt;</span></span><span class="hljs-meta">#<span class="hljs-meta-keyword">include</span> <span class="hljs-meta-string">&lt;vector&gt;</span></span><span class="hljs-meta">#<span class="hljs-meta-keyword">include</span> <span class="hljs-meta-string">&lt;string&gt;</span></span><span class="hljs-meta">#<span class="hljs-meta-keyword">include</span> <span class="hljs-meta-string">&lt;cstring&gt;</span></span><span class="hljs-meta">#<span class="hljs-meta-keyword">define</span> rep(i,a,n) for(int i=a;i&lt;n;++i)</span><span class="hljs-meta">#<span class="hljs-meta-keyword">define</span> per(i,a,n) for(int i=n-1;i&gt;=a;--i)</span><span class="hljs-meta">#<span class="hljs-meta-keyword">define</span> clint(x,a) memset(x,a,sizeof(int)*n)</span><span class="hljs-meta">#<span class="hljs-meta-keyword">define</span> clll(x,a) memset(x,a,sizeof(ll)*n)</span><span class="hljs-meta">#<span class="hljs-meta-keyword">define</span> pb push_back</span><span class="hljs-meta">#<span class="hljs-meta-keyword">define</span> np next_permutation</span><span class="hljs-meta">#<span class="hljs-meta-keyword">define</span> mp make_pair</span><span class="hljs-meta">#<span class="hljs-meta-keyword">define</span> fi first</span><span class="hljs-meta">#<span class="hljs-meta-keyword">define</span> se second</span><span class="hljs-meta">#<span class="hljs-meta-keyword">define</span> INF 0x3f3f3f3f</span><span class="hljs-meta">#<span class="hljs-meta-keyword">define</span> EPS 1e-8</span><span class="hljs-meta">#<span class="hljs-meta-keyword">define</span> PI acos(-1.0)</span><span class="hljs-keyword">using</span> <span class="hljs-keyword">namespace</span> <span class="hljs-built_in">std</span>;<span class="hljs-keyword">const</span> <span class="hljs-keyword">int</span> maxn=<span class="hljs-number">1e5</span>+<span class="hljs-number">5</span>;<span class="hljs-keyword">const</span> <span class="hljs-keyword">int</span> maxm=<span class="hljs-number">1e5</span>+<span class="hljs-number">5</span>;<span class="hljs-keyword">const</span> <span class="hljs-keyword">int</span> maxl=<span class="hljs-number">26</span>;<span class="hljs-keyword">typedef</span> <span class="hljs-keyword">long</span> <span class="hljs-keyword">long</span> ll;<span class="hljs-keyword">typedef</span> <span class="hljs-keyword">unsigned</span> <span class="hljs-keyword">long</span> <span class="hljs-keyword">long</span> ull;<span class="hljs-keyword">typedef</span> <span class="hljs-built_in">vector</span>&lt;<span class="hljs-keyword">int</span>&gt; vi;<span class="hljs-keyword">typedef</span> pair&lt;<span class="hljs-keyword">int</span>,<span class="hljs-keyword">int</span>&gt; pii;<span class="hljs-keyword">typedef</span> pair&lt;<span class="hljs-built_in">string</span>,<span class="hljs-built_in">string</span>&gt; pss;ll t,d,ii;<span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span>&#123;    ios::sync_with_stdio(<span class="hljs-literal">false</span>);    <span class="hljs-built_in">cin</span>&gt;&gt;t;    rep(tt,<span class="hljs-number">1</span>,t+<span class="hljs-number">1</span>)&#123;        <span class="hljs-built_in">cin</span>&gt;&gt;d&gt;&gt;ii;        ll ans=<span class="hljs-number">1</span>;        <span class="hljs-keyword">for</span>(<span class="hljs-keyword">int</span> i=<span class="hljs-number">1</span>;i&lt;d;i++)&#123;            <span class="hljs-keyword">if</span>(ii&amp;<span class="hljs-number">1</span>)&#123;                ans*=<span class="hljs-number">2</span>;                ii=(ii+<span class="hljs-number">1</span>)/<span class="hljs-number">2</span>;            &#125;            <span class="hljs-keyword">else</span>&#123;                ans=ans*<span class="hljs-number">2</span>+<span class="hljs-number">1</span>;                ii=ii/<span class="hljs-number">2</span>;            &#125;        &#125;        <span class="hljs-built_in">cout</span>&lt;&lt;ans&lt;&lt;<span class="hljs-built_in">endl</span>;    &#125;    <span class="hljs-built_in">cin</span>&gt;&gt;t;&#125;</code></pre></li></ul><h1 id="收获与反思"><a href="#收获与反思" class="headerlink" title="收获与反思"></a>收获与反思</h1><ul><li>注意奇偶性规律</li></ul>]]></content>
    
    
    <categories>
      
      <category>Computer Science</category>
      
      <category>ACM</category>
      
      <category>UVA</category>
      
    </categories>
    
    
    <tags>
      
      <tag>ACM</tag>
      
      <tag>UVA</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>【UVA-12657】解题报告（双端链表）</title>
    <link href="/post/6c71e418.html"/>
    <url>/post/6c71e418.html</url>
    
    <content type="html"><![CDATA[<h1 id="原始题目"><a href="#原始题目" class="headerlink" title="原始题目"></a>原始题目</h1><a id="more"></a><h1 id="题目大意"><a href="#题目大意" class="headerlink" title="题目大意"></a>题目大意</h1><p>有$n$个箱子，初始标号从左到右由$1$到$n$，有以下四种操作</p><ol><li>把X移动到Y左边</li><li>把X移动到Y右边</li><li>交换X和Y的位置</li><li>全体翻转颠倒</li></ol><p>其中1，2若已经符合状态则不操作</p><p>给出$n$和所有的操作，输出从左到右奇数位的和。</p><h1 id="解题思路"><a href="#解题思路" class="headerlink" title="解题思路"></a>解题思路</h1><ul><li>数组形式双端链表 $left[i],right[i]$，模拟实现</li><li>简化实现：3不受4影响，4的翻转可以记录状态，且翻转状态下2-&gt;1，1-&gt;2。</li><li>交换需要分类，相邻时特判</li></ul><h1 id="解题代码"><a href="#解题代码" class="headerlink" title="解题代码"></a>解题代码</h1><pre><code class="hljs C++"><span class="hljs-meta">#<span class="hljs-meta-keyword">include</span> <span class="hljs-meta-string">&lt;cstdio&gt;</span></span><span class="hljs-meta">#<span class="hljs-meta-keyword">include</span> <span class="hljs-meta-string">&lt;iostream&gt;</span></span><span class="hljs-meta">#<span class="hljs-meta-keyword">include</span> <span class="hljs-meta-string">&lt;iomanip&gt;</span></span><span class="hljs-meta">#<span class="hljs-meta-keyword">include</span> <span class="hljs-meta-string">&lt;vector&gt;</span></span><span class="hljs-meta">#<span class="hljs-meta-keyword">include</span> <span class="hljs-meta-string">&lt;string&gt;</span></span><span class="hljs-meta">#<span class="hljs-meta-keyword">include</span> <span class="hljs-meta-string">&lt;cstring&gt;</span></span><span class="hljs-meta">#<span class="hljs-meta-keyword">define</span> rep(i,a,n) for(int i=a;i&lt;n;++i)</span><span class="hljs-meta">#<span class="hljs-meta-keyword">define</span> per(i,a,n) for(int i=n-1;i&gt;=a;--i)</span><span class="hljs-meta">#<span class="hljs-meta-keyword">define</span> clint(x,a) memset(x,a,sizeof(int)*n)</span><span class="hljs-meta">#<span class="hljs-meta-keyword">define</span> clll(x,a) memset(x,a,sizeof(ll)*n)</span><span class="hljs-meta">#<span class="hljs-meta-keyword">define</span> pb push_back</span><span class="hljs-meta">#<span class="hljs-meta-keyword">define</span> np next_permutation</span><span class="hljs-meta">#<span class="hljs-meta-keyword">define</span> mp make_pair</span><span class="hljs-meta">#<span class="hljs-meta-keyword">define</span> fi first</span><span class="hljs-meta">#<span class="hljs-meta-keyword">define</span> se second</span><span class="hljs-meta">#<span class="hljs-meta-keyword">define</span> INF 0x3f3f3f3f</span><span class="hljs-meta">#<span class="hljs-meta-keyword">define</span> EPS 1e-8</span><span class="hljs-meta">#<span class="hljs-meta-keyword">define</span> PI acos(-1.0)</span><span class="hljs-keyword">using</span> <span class="hljs-keyword">namespace</span> <span class="hljs-built_in">std</span>;<span class="hljs-keyword">const</span> <span class="hljs-keyword">int</span> maxn=<span class="hljs-number">1e5</span>+<span class="hljs-number">5</span>;<span class="hljs-keyword">const</span> <span class="hljs-keyword">int</span> maxm=<span class="hljs-number">1e5</span>+<span class="hljs-number">5</span>;<span class="hljs-keyword">const</span> <span class="hljs-keyword">int</span> maxl=<span class="hljs-number">26</span>;<span class="hljs-keyword">typedef</span> <span class="hljs-keyword">long</span> <span class="hljs-keyword">long</span> ll;<span class="hljs-keyword">typedef</span> <span class="hljs-keyword">unsigned</span> <span class="hljs-keyword">long</span> <span class="hljs-keyword">long</span> ull;<span class="hljs-keyword">typedef</span> <span class="hljs-built_in">vector</span>&lt;<span class="hljs-keyword">int</span>&gt; vi;<span class="hljs-keyword">typedef</span> pair&lt;<span class="hljs-keyword">int</span>,<span class="hljs-keyword">int</span>&gt; pii;<span class="hljs-keyword">typedef</span> pair&lt;<span class="hljs-built_in">string</span>,<span class="hljs-built_in">string</span>&gt; pss;<span class="hljs-keyword">int</span> a[maxn],lleft[maxn],rright[maxn];<span class="hljs-keyword">int</span> n,m;<span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">init</span><span class="hljs-params">()</span></span>&#123;    rep(i,<span class="hljs-number">1</span>,n+<span class="hljs-number">1</span>)&#123;        lleft[i]=i<span class="hljs-number">-1</span>;        rright[i]=(i+<span class="hljs-number">1</span>);    &#125;    rright[<span class="hljs-number">0</span>]=<span class="hljs-number">1</span>;    lleft[n+<span class="hljs-number">1</span>]=n;&#125;<span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">link</span><span class="hljs-params">(<span class="hljs-keyword">int</span> l,<span class="hljs-keyword">int</span> r)</span></span>&#123;    rright[l]=r;lleft[r]=l;&#125;<span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span>&#123;    ios::sync_with_stdio(<span class="hljs-literal">false</span>);    <span class="hljs-keyword">int</span> kase=<span class="hljs-number">0</span>;    <span class="hljs-keyword">while</span>(<span class="hljs-built_in">cin</span>&gt;&gt;n&gt;&gt;m)&#123;        init();        <span class="hljs-keyword">int</span> op,aa,bb,status=<span class="hljs-number">0</span>;        rep(i,<span class="hljs-number">0</span>,m)&#123;            <span class="hljs-built_in">cin</span>&gt;&gt;op;            <span class="hljs-keyword">if</span>(op==<span class="hljs-number">4</span>)&#123;                status=!status;            &#125;            <span class="hljs-keyword">else</span>&#123;                <span class="hljs-built_in">cin</span>&gt;&gt;aa&gt;&gt;bb;                <span class="hljs-keyword">if</span>(status &amp;&amp; op!=<span class="hljs-number">3</span>) op=<span class="hljs-number">3</span>-op; <span class="hljs-comment">//改变操作</span>                <span class="hljs-keyword">if</span>(op==<span class="hljs-number">3</span> &amp;&amp; rright[bb]==aa) swap(aa,bb);                <span class="hljs-keyword">int</span> laa=lleft[aa],raa=rright[aa],lbb=lleft[bb],rbb=rright[bb];                <span class="hljs-keyword">if</span>(op==<span class="hljs-number">1</span>)&#123;                    <span class="hljs-keyword">if</span>(aa==lbb) <span class="hljs-keyword">continue</span>;                    <span class="hljs-keyword">else</span> &#123;                        link(laa,raa);                        link(lbb,aa);                        link(aa,bb);                    &#125;                &#125;                <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span>(op==<span class="hljs-number">2</span>)&#123;                    <span class="hljs-keyword">if</span>(aa==rbb) <span class="hljs-keyword">continue</span>;                    <span class="hljs-keyword">else</span> &#123;                        link(laa,raa);                        link(bb,aa);                        link(aa,rbb);                    &#125;                &#125;                <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span>(op==<span class="hljs-number">3</span>)&#123;                    <span class="hljs-keyword">if</span>(raa==bb)&#123;                        link(laa,bb);                        link(bb,aa);                        link(aa,rbb);                    &#125;                    <span class="hljs-keyword">else</span>&#123;                        link(laa,bb);                        link(bb,raa);                        link(lbb,aa);                        link(aa,rbb);                    &#125;                &#125;            &#125;        &#125;        ll sum=<span class="hljs-number">0</span>;        <span class="hljs-keyword">int</span> b;        <span class="hljs-keyword">if</span>(status) b=n+<span class="hljs-number">1</span>;        <span class="hljs-keyword">else</span> b=<span class="hljs-number">0</span>;        <span class="hljs-keyword">for</span>(<span class="hljs-keyword">int</span> i=<span class="hljs-number">1</span>;i&lt;=n;++i)&#123;            <span class="hljs-keyword">if</span>(status)&#123;                b=lleft[b];            &#125;            <span class="hljs-keyword">else</span> b=rright[b];            <span class="hljs-keyword">if</span>(i&amp;<span class="hljs-number">1</span>) sum+=b;        &#125;        <span class="hljs-built_in">cout</span>&lt;&lt;<span class="hljs-string">"Case "</span>&lt;&lt;++kase&lt;&lt;<span class="hljs-string">": "</span>&lt;&lt;sum&lt;&lt;<span class="hljs-built_in">endl</span>;<span class="hljs-comment">//        int c=0;</span><span class="hljs-comment">//        for(int i=1;i&lt;=n;++i)&#123;</span><span class="hljs-comment">//            c=rright[c];</span><span class="hljs-comment">//            cout&lt;&lt;c&lt;&lt;" ";</span><span class="hljs-comment">//        &#125;</span><span class="hljs-comment">//        cout&lt;&lt;endl;</span>    &#125;&#125;</code></pre><h1 id="收获与反思"><a href="#收获与反思" class="headerlink" title="收获与反思"></a>收获与反思</h1><ul><li><p>数组形式双端链表$left[i],right[i]$，分别表示前驱结点和后继结点的指针。</p><p>  //link操作，将两结点连接在一起。<br>  void link(int l,int r){</p><pre><code>  rright[l]=r;lleft[r]=l;</code></pre><p>  }</p></li><li><p>对于1，2操作，需要考虑连接顺序，记录原始的lx，ly，rx，ry，然后从左到右一一link就好。</p></li><li><p>注意记录原始的lx，ly，rx，ry，后面会改变</p></li></ul>]]></content>
    
    
    <categories>
      
      <category>Computer Science</category>
      
      <category>ACM</category>
      
      <category>UVA</category>
      
    </categories>
    
    
    <tags>
      
      <tag>ACM</tag>
      
      <tag>UVA</tag>
      
      <tag>补图</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>【UVA-11988】解题报告（链表）</title>
    <link href="/post/75f986a1.html"/>
    <url>/post/75f986a1.html</url>
    
    <content type="html"><![CDATA[<h1 id="原始题目"><a href="#原始题目" class="headerlink" title="原始题目"></a>原始题目</h1><a id="more"></a><h1 id="题目大意"><a href="#题目大意" class="headerlink" title="题目大意"></a>题目大意</h1><p>给出一段输入，‘[’表示“Home”键，即输入跳转到开头，‘]’表示“End”键，即输入跳至结尾。<br>输出最终实际文字。</p><h1 id="解题思路"><a href="#解题思路" class="headerlink" title="解题思路"></a>解题思路</h1><p>数组形式链表模拟。加空开头和尾。</p><h1 id="解题代码"><a href="#解题代码" class="headerlink" title="解题代码"></a>解题代码</h1><pre><code class="hljs C++"><span class="hljs-meta">#<span class="hljs-meta-keyword">include</span> <span class="hljs-meta-string">&lt;cstdio&gt;</span></span><span class="hljs-meta">#<span class="hljs-meta-keyword">include</span> <span class="hljs-meta-string">&lt;bits/stdc++.h&gt;</span></span><span class="hljs-meta">#<span class="hljs-meta-keyword">define</span> rep(i,a,n) for(int i=a;i&lt;n;++i)</span><span class="hljs-meta">#<span class="hljs-meta-keyword">define</span> per(i,a,n) for(int i=n-1;i&gt;=a;--i)</span><span class="hljs-meta">#<span class="hljs-meta-keyword">define</span> clint(x,a) memset(x,a,sizeof(int)*n)</span><span class="hljs-meta">#<span class="hljs-meta-keyword">define</span> clll(x,a) memset(x,a,sizeof(ll)*n)</span><span class="hljs-meta">#<span class="hljs-meta-keyword">define</span> pb push_back</span><span class="hljs-meta">#<span class="hljs-meta-keyword">define</span> np next_permutation</span><span class="hljs-meta">#<span class="hljs-meta-keyword">define</span> mp make_pair</span><span class="hljs-meta">#<span class="hljs-meta-keyword">define</span> fi first</span><span class="hljs-meta">#<span class="hljs-meta-keyword">define</span> se second</span><span class="hljs-meta">#<span class="hljs-meta-keyword">define</span> INF 0x3f3f3f3f</span><span class="hljs-meta">#<span class="hljs-meta-keyword">define</span> EPS 1e-8</span><span class="hljs-meta">#<span class="hljs-meta-keyword">define</span> PI acos(-1.0)</span><span class="hljs-keyword">using</span> <span class="hljs-keyword">namespace</span> <span class="hljs-built_in">std</span>;<span class="hljs-keyword">const</span> <span class="hljs-keyword">int</span> maxn=<span class="hljs-number">1e5</span>+<span class="hljs-number">5</span>;<span class="hljs-keyword">const</span> <span class="hljs-keyword">int</span> maxm=<span class="hljs-number">1e5</span>+<span class="hljs-number">5</span>;<span class="hljs-keyword">const</span> <span class="hljs-keyword">int</span> maxl=<span class="hljs-number">26</span>;<span class="hljs-keyword">char</span> ss[maxn];<span class="hljs-keyword">int</span> nextt[maxn];<span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span>&#123;    ios::sync_with_stdio(<span class="hljs-literal">false</span>);    <span class="hljs-keyword">while</span>(<span class="hljs-built_in">cin</span>&gt;&gt;ss+<span class="hljs-number">1</span>)&#123;        <span class="hljs-keyword">int</span> last=<span class="hljs-number">0</span>,cur=<span class="hljs-number">0</span>;        <span class="hljs-built_in">memset</span>(nextt,<span class="hljs-number">0</span>,<span class="hljs-keyword">sizeof</span>(nextt));        <span class="hljs-keyword">int</span> len=<span class="hljs-built_in">strlen</span>(ss+<span class="hljs-number">1</span>);        rep(i,<span class="hljs-number">1</span>,len+<span class="hljs-number">1</span>)&#123;            <span class="hljs-keyword">if</span>(ss[i]==<span class="hljs-string">'['</span>)&#123;                cur=<span class="hljs-number">0</span>;            &#125;            <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span>(ss[i]==<span class="hljs-string">']'</span>) &#123;                cur=last;            &#125;            <span class="hljs-keyword">else</span> &#123;                nextt[i]=nextt[cur];                nextt[cur]=i;                <span class="hljs-keyword">if</span>(cur==last) last=i;                cur=i;            &#125;        &#125;        <span class="hljs-keyword">for</span>(<span class="hljs-keyword">int</span> i=nextt[<span class="hljs-number">0</span>];i!=<span class="hljs-number">0</span>;i=nextt[i])&#123;            <span class="hljs-built_in">cout</span>&lt;&lt;ss[i];        &#125;        <span class="hljs-built_in">cout</span>&lt;&lt;<span class="hljs-built_in">endl</span>;    &#125;&#125;</code></pre><h1 id="收获与反思"><a href="#收获与反思" class="headerlink" title="收获与反思"></a>收获与反思</h1><ol><li>数组形式链表，数组标号0作为空头结点，next[0]作为头节点的指针。</li><li><p>添加结点的操作为</p><p> next[i]=next[cur] //加入结点的指针与前一结点的指针相同<br> next[cur]=i; //前一结点指针指向新结点<br> //由于本题还需要记录尾结点的序号所以有<br> //if(cur==last) last=i;<br> cur=i; //指针移向当前结点</p></li></ol>]]></content>
    
    
    <categories>
      
      <category>Computer Science</category>
      
      <category>ACM</category>
      
      <category>UVA</category>
      
    </categories>
    
    
    <tags>
      
      <tag>ACM</tag>
      
      <tag>UVA</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>【UVA-442】解题报告（STL，栈）</title>
    <link href="/post/ca14c5df.html"/>
    <url>/post/ca14c5df.html</url>
    
    <content type="html"><![CDATA[<h1 id="原始题目"><a href="#原始题目" class="headerlink" title="原始题目"></a>原始题目</h1><a id="more"></a><h1 id="题目大意"><a href="#题目大意" class="headerlink" title="题目大意"></a>题目大意</h1><p>给出$n$个矩阵的行数和列数（矩阵名为A到Z），再给出一些表达式，根据表达式的运算规则计算是否合法，若合法<br>计算出乘法次数。</p><h1 id="解题思路"><a href="#解题思路" class="headerlink" title="解题思路"></a>解题思路</h1><p>简单的表达式解析可以通过栈实现，输入右括号时计算，输入字母时压入栈。</p><h1 id="解题代码"><a href="#解题代码" class="headerlink" title="解题代码"></a>解题代码</h1><pre><code class="hljs C++"><span class="hljs-meta">#<span class="hljs-meta-keyword">include</span> <span class="hljs-meta-string">&lt;cstdio&gt;</span></span><span class="hljs-meta">#<span class="hljs-meta-keyword">include</span> <span class="hljs-meta-string">&lt;bits/stdc++.h&gt;</span></span><span class="hljs-meta">#<span class="hljs-meta-keyword">define</span> rep(i,a,n) for(int i=a;i&lt;n;++i)</span><span class="hljs-meta">#<span class="hljs-meta-keyword">define</span> per(i,a,n) for(int i=n-1;i&gt;=a;--i)</span><span class="hljs-meta">#<span class="hljs-meta-keyword">define</span> clint(x,a) memset(x,a,sizeof(int)*n)</span><span class="hljs-meta">#<span class="hljs-meta-keyword">define</span> clll(x,a) memset(x,a,sizeof(ll)*n)</span><span class="hljs-meta">#<span class="hljs-meta-keyword">define</span> pb push_back</span><span class="hljs-meta">#<span class="hljs-meta-keyword">define</span> np next_permutation</span><span class="hljs-meta">#<span class="hljs-meta-keyword">define</span> mp make_pair</span><span class="hljs-meta">#<span class="hljs-meta-keyword">define</span> fi first</span><span class="hljs-meta">#<span class="hljs-meta-keyword">define</span> se second</span><span class="hljs-meta">#<span class="hljs-meta-keyword">define</span> INF 0x3f3f3f3f</span><span class="hljs-meta">#<span class="hljs-meta-keyword">define</span> EPS 1e-8</span><span class="hljs-meta">#<span class="hljs-meta-keyword">define</span> PI acos(-1.0)</span><span class="hljs-keyword">using</span> <span class="hljs-keyword">namespace</span> <span class="hljs-built_in">std</span>;<span class="hljs-keyword">const</span> <span class="hljs-keyword">int</span> maxn=<span class="hljs-number">1e5</span>+<span class="hljs-number">5</span>;<span class="hljs-keyword">const</span> <span class="hljs-keyword">int</span> maxm=<span class="hljs-number">1e5</span>+<span class="hljs-number">5</span>;<span class="hljs-keyword">const</span> <span class="hljs-keyword">int</span> maxl=<span class="hljs-number">26</span>;<span class="hljs-keyword">typedef</span> <span class="hljs-keyword">long</span> <span class="hljs-keyword">long</span> ll;<span class="hljs-keyword">typedef</span> <span class="hljs-keyword">unsigned</span> <span class="hljs-keyword">long</span> <span class="hljs-keyword">long</span> ull;<span class="hljs-keyword">typedef</span> <span class="hljs-built_in">vector</span>&lt;<span class="hljs-keyword">int</span>&gt; vi;<span class="hljs-keyword">typedef</span> pair&lt;<span class="hljs-keyword">int</span>,<span class="hljs-keyword">int</span>&gt; pii;<span class="hljs-keyword">typedef</span> pair&lt;<span class="hljs-built_in">string</span>,<span class="hljs-built_in">string</span>&gt; pss;<span class="hljs-keyword">int</span> t,n;<span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">Matrix</span>&#123;</span>    <span class="hljs-keyword">int</span> a,b;    Matrix(<span class="hljs-keyword">int</span> a=<span class="hljs-number">0</span>,<span class="hljs-keyword">int</span> b=<span class="hljs-number">0</span>):a(a),b(b)&#123;&#125;&#125;m[<span class="hljs-number">26</span>];<span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span>&#123;    ios::sync_with_stdio(<span class="hljs-literal">false</span>);    <span class="hljs-built_in">cin</span>&gt;&gt;n;    rep(i,<span class="hljs-number">0</span>,n)&#123;        <span class="hljs-keyword">char</span> c;        <span class="hljs-built_in">cin</span>&gt;&gt;c;        <span class="hljs-built_in">cin</span>&gt;&gt;m[c-<span class="hljs-string">'A'</span>].a&gt;&gt;m[c-<span class="hljs-string">'A'</span>].b;    &#125;    <span class="hljs-built_in">string</span> str;    <span class="hljs-keyword">while</span>(<span class="hljs-built_in">cin</span>&gt;&gt;str)&#123;        <span class="hljs-built_in">stack</span> &lt;Matrix&gt; s;        <span class="hljs-keyword">bool</span> flag=<span class="hljs-number">0</span>;        <span class="hljs-keyword">int</span> ans=<span class="hljs-number">0</span>;        <span class="hljs-keyword">int</span> len=str.length();        rep(i,<span class="hljs-number">0</span>,len)&#123;            <span class="hljs-keyword">if</span>(<span class="hljs-built_in">isalpha</span>(str[i]))&#123;                <span class="hljs-keyword">if</span>(flag) <span class="hljs-keyword">break</span>;                s.push(m[str[i]-<span class="hljs-string">'A'</span>]);            &#125;            <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span>(str[i]==<span class="hljs-string">')'</span>)&#123;                Matrix m1,m2;                <span class="hljs-keyword">if</span>(flag) <span class="hljs-keyword">break</span>;                m1=s.top();s.pop();                m2=s.top();s.pop();                    <span class="hljs-keyword">if</span>(m1.a!=m2.b)&#123;                        flag=<span class="hljs-number">1</span>;                        <span class="hljs-keyword">break</span>;                    &#125;                    <span class="hljs-keyword">else</span>&#123;                        ans+=m2.a*m1.b*m1.a;                        s.push(Matrix(m2.a,m1.b));                    &#125;            &#125;        &#125;        <span class="hljs-keyword">if</span>(flag) <span class="hljs-built_in">cout</span>&lt;&lt;<span class="hljs-string">"error"</span>&lt;&lt;<span class="hljs-built_in">endl</span>;        <span class="hljs-keyword">else</span> <span class="hljs-built_in">cout</span>&lt;&lt;ans&lt;&lt;<span class="hljs-built_in">endl</span>;    &#125;&#125;</code></pre><h1 id="收获与反思"><a href="#收获与反思" class="headerlink" title="收获与反思"></a>收获与反思</h1><p>注意读题，表达式的范式。</p>]]></content>
    
    
    <categories>
      
      <category>Computer Science</category>
      
      <category>ACM</category>
      
      <category>UVA</category>
      
    </categories>
    
    
    <tags>
      
      <tag>ACM</tag>
      
      <tag>UVA</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>【UVA-10474】解题报告（STL，排序，二分）</title>
    <link href="/post/bcb02c2b.html"/>
    <url>/post/bcb02c2b.html</url>
    
    <content type="html"><![CDATA[<h1 id="原始题目"><a href="#原始题目" class="headerlink" title="原始题目"></a>原始题目</h1><a id="more"></a><h1 id="题目大意"><a href="#题目大意" class="headerlink" title="题目大意"></a>题目大意</h1><p>有许多$N$个标有不同数字的大理石，每次按1，2，3这样从小到大的次序数。有$Q$个询问，对于每个询问，<br>是否能数到指定数，若能输出数的次数，若不能输出not found.</p><h1 id="解题思路"><a href="#解题思路" class="headerlink" title="解题思路"></a>解题思路</h1><p>排序以后利用二分查找，输出位置+1即可。</p><h1 id="解题代码"><a href="#解题代码" class="headerlink" title="解题代码"></a>解题代码</h1><pre><code class="hljs C++"><span class="hljs-meta">#<span class="hljs-meta-keyword">include</span> <span class="hljs-meta-string">&lt;bits/stdc++.h&gt;</span></span><span class="hljs-meta">#<span class="hljs-meta-keyword">define</span> rep(i,a,n) for(int i=a;i&lt;n;++i)</span><span class="hljs-meta">#<span class="hljs-meta-keyword">define</span> per(i,a,n) for(int i=n-1;i&gt;=a;--i)</span><span class="hljs-meta">#<span class="hljs-meta-keyword">define</span> fi first</span><span class="hljs-meta">#<span class="hljs-meta-keyword">define</span> se second</span><span class="hljs-meta">#<span class="hljs-meta-keyword">define</span> mp make_pair</span><span class="hljs-meta">#<span class="hljs-meta-keyword">define</span> pb push_back</span><span class="hljs-meta">#<span class="hljs-meta-keyword">define</span> np next_permutation</span><span class="hljs-meta">#<span class="hljs-meta-keyword">define</span> cl(x,a,n) memset(x,a,sizeof(int)*n)</span><span class="hljs-keyword">using</span> <span class="hljs-keyword">namespace</span> <span class="hljs-built_in">std</span>;<span class="hljs-keyword">typedef</span> <span class="hljs-keyword">long</span> <span class="hljs-keyword">long</span> ll;<span class="hljs-keyword">typedef</span> <span class="hljs-keyword">unsigned</span> <span class="hljs-keyword">long</span> <span class="hljs-keyword">long</span> ull;<span class="hljs-keyword">typedef</span> <span class="hljs-keyword">long</span> <span class="hljs-keyword">double</span> ld;<span class="hljs-keyword">typedef</span> <span class="hljs-built_in">vector</span>&lt;<span class="hljs-keyword">int</span>&gt; vi;<span class="hljs-keyword">typedef</span> pair&lt;<span class="hljs-keyword">int</span>,<span class="hljs-keyword">int</span>&gt; pii;<span class="hljs-keyword">typedef</span> pair&lt;<span class="hljs-built_in">string</span>,<span class="hljs-built_in">string</span>&gt; pss;<span class="hljs-keyword">const</span> <span class="hljs-keyword">int</span> maxn=<span class="hljs-number">1e5</span>+<span class="hljs-number">5</span>;<span class="hljs-keyword">int</span> n,q;<span class="hljs-keyword">int</span> cnt,a[maxn];<span class="hljs-built_in">vector</span>&lt; pii &gt; v;<span class="hljs-function"><span class="hljs-keyword">bool</span> <span class="hljs-title">cmp</span><span class="hljs-params">( pii a, pii b)</span></span>&#123;    <span class="hljs-keyword">if</span>(a.se!=b.se) <span class="hljs-keyword">return</span> a.se&lt;b.se;    <span class="hljs-keyword">else</span> <span class="hljs-keyword">return</span> a.fi&lt;b.fi;&#125;<span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span>&#123;    ios::sync_with_stdio(<span class="hljs-literal">false</span>);    <span class="hljs-keyword">while</span>(<span class="hljs-built_in">cin</span>&gt;&gt;n&gt;&gt;q &amp;&amp; n+q)&#123;        rep(i,<span class="hljs-number">0</span>,n)&#123;            <span class="hljs-built_in">cin</span>&gt;&gt;a[i];        &#125;        <span class="hljs-built_in">cout</span>&lt;&lt;<span class="hljs-string">"CASE# "</span>&lt;&lt;++cnt&lt;&lt;<span class="hljs-string">":"</span>&lt;&lt;<span class="hljs-built_in">endl</span>;        sort(a,a+n);        rep(i,<span class="hljs-number">0</span>,q)&#123;            <span class="hljs-keyword">int</span> x;            <span class="hljs-built_in">cin</span>&gt;&gt;x;            <span class="hljs-keyword">int</span> index=lower_bound(a,a+n,x)-a;            <span class="hljs-keyword">if</span>(a[index]==x) <span class="hljs-built_in">cout</span>&lt;&lt;x&lt;&lt;<span class="hljs-string">" found at "</span>&lt;&lt;index+<span class="hljs-number">1</span>&lt;&lt;<span class="hljs-built_in">endl</span>;            <span class="hljs-keyword">else</span> <span class="hljs-built_in">cout</span>&lt;&lt;x&lt;&lt;<span class="hljs-string">" not found"</span>&lt;&lt;<span class="hljs-built_in">endl</span>;        &#125;    &#125;&#125;</code></pre><h1 id="收获与反思"><a href="#收获与反思" class="headerlink" title="收获与反思"></a>收获与反思</h1><p>排序，二分</p>]]></content>
    
    
    <categories>
      
      <category>Computer Science</category>
      
      <category>ACM</category>
      
      <category>UVA</category>
      
    </categories>
    
    
    <tags>
      
      <tag>ACM</tag>
      
      <tag>UVA</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>金融学辅修——金融学笔记（四）</title>
    <link href="/post/e8005312.html"/>
    <url>/post/e8005312.html</url>
    
    <content type="html"><![CDATA[<h1 id="课前同学分享"><a href="#课前同学分享" class="headerlink" title="课前同学分享"></a>课前同学分享</h1><ol><li><p>金融衍生品</p><ol><li>期权</li></ol></li><li><p>八大特点</p></li></ol><p>零和博弈：金融衍生品交易净损益之和等于零<br>跨期性：未来交易<br>联动性<br>高风险性<br>高杠杆性<br>交易的保值性</p><ol><li>金融衍生品在我国的发展情况</li></ol><p>过去——1992年——国债期货</p><p>1994年——1998年——金融衍生品市场</p><p>发展现况<br>市场经济的推进 对外开放和国际经济接轨</p><p>金融衍生品的功能<br>1.风险转移<br>2.价格发现：可以预测未来现货价格的变化<br>3.增强流动<br>4.</p><p>存在的问题</p>]]></content>
    
    
    <categories>
      
      <category>Finance</category>
      
      <category>金融学</category>
      
    </categories>
    
    
    <tags>
      
      <tag>辅修</tag>
      
      <tag>金融学</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>金融学辅修——微观经济学笔记（一）</title>
    <link href="/post/a27e9acf.html"/>
    <url>/post/a27e9acf.html</url>
    
    <content type="html"><![CDATA[<h1 id="第一章-导论"><a href="#第一章-导论" class="headerlink" title="第一章 导论"></a>第一章 导论</h1><h2 id="第一节-什么是西方经济学"><a href="#第一节-什么是西方经济学" class="headerlink" title="第一节 什么是西方经济学"></a>第一节 什么是西方经济学</h2><h2 id="第四节-西方经济学的主要分析方法"><a href="#第四节-西方经济学的主要分析方法" class="headerlink" title="第四节 西方经济学的主要分析方法"></a>第四节 西方经济学的主要分析方法</h2><p>任何一门学科都有一定的研究和分析方法。</p><h3 id="边际分析法"><a href="#边际分析法" class="headerlink" title="边际分析法"></a>边际分析法</h3><h4 id="边际分析法的特点"><a href="#边际分析法的特点" class="headerlink" title="边际分析法的特点"></a>边际分析法的特点</h4><ol><li>其一，边际分析是一种数量分析，尤其是变量分析，运用这一方法研究数量的变动和相互关系。</li><li>边际分析法研究微增量的变化及变量之间的关系，可使经济理论精细化（差分，微分）。</li></ol><h4 id="边际分析法的意义"><a href="#边际分析法的意义" class="headerlink" title="边际分析法的意义"></a>边际分析法的意义</h4><ol><li>经济学研究重心发生改变，由社会性、历史性的政治学经济学转为纯粹研究如何抉择稀缺资源分<br>配给无限而又有竞争性的用途上，以有效利用。</li><li>开创了经济学“数量化”的时代。</li><li>导致了微观经济学的形成，“个量分析”的微观经济学的诞生。</li><li>奠定了最优化理论的基础。</li><li>使实证经济学得到发展。</li></ol><h3 id="经济模型与抽象分析"><a href="#经济模型与抽象分析" class="headerlink" title="经济模型与抽象分析"></a>经济模型与抽象分析</h3><p>经济模型：</p><h3 id="实证分析和规范分析"><a href="#实证分析和规范分析" class="headerlink" title="实证分析和规范分析"></a>实证分析和规范分析</h3><ol><li><p>规范经济学 Normative economics</p><ul><li>以一定的主观价值判断为基础，提出某些标准作为分析处理经济问题的根据，作为建立经济理论的前提和<br>制定经济政策的依据，并研究如何才能符合这些标准。回答“<strong>应该是什么</strong>”的问题。（标准，应有的样子）</li></ul></li><li><p>实证经济学 Positive economics</p><ul><li>对经济现象进行客观描述，企图超脱或排斥一切主观价值判断。回答“<strong>是什么</strong>”的问题。</li></ul></li></ol><a id="more"></a>    <h3 id="均衡分析"><a href="#均衡分析" class="headerlink" title="均衡分析"></a>均衡分析</h3><p>均衡即平衡，本是物理学的一个概念</p><p>博弈论：纳什均衡</p><ol><li><p>经济学中的均衡状态：各个经济决策者（消费者、生产者等等）所做出的决策正好相容，并且在外界条件不变的<br>情况下，每个人都不愿意再调整自己的决策，从而不再改变其经济行为。（环境不改变，博弈均衡）</p></li><li><p>均衡分析就是假定经济变量达到均衡状态时所出现的情况以及实现均衡的条件。局部/一般均衡分析。</p><ul><li><p>局部均衡分析：假定其他条件不变，只考虑本身的各相关变量的作用（部分忽略，考虑局部），研究该种<br>变量如何实现均衡。局限在一个局部范围。</p></li><li><p>一般均衡分析：考虑在各种因素和变量的作用下，如何实现均衡。</p></li></ul></li></ol><h3 id="静态分析、比较静态分析与动态分析"><a href="#静态分析、比较静态分析与动态分析" class="headerlink" title="静态分析、比较静态分析与动态分析"></a>静态分析、比较静态分析与动态分析</h3><ol><li>静态分析：分析均衡状态和所需要的条件，不考虑实现的过程。</li><li>比较静态分析：分析在已知条件发生后，均衡状态如何变化。（方向）</li><li>动态分析：论述均衡调整变化的实际过程，通常把经济运动过程划分为连续的分析期间，考察有关经济变量在连续时间段的变化。<br>（加时间变量的分析）</li></ol><h3 id="外生变量与内生变量"><a href="#外生变量与内生变量" class="headerlink" title="外生变量与内生变量"></a>外生变量与内生变量</h3><table><tr><td>内生变量（Endogenous Variables）</td><td>经济模型内部结构决定的变量</td></tr><tr><td>外生变量（Exogenous Variable）</td><td>经济模型外部的因素决定的变量</td></tr><tr><td>存量（Stock）</td><td>一定时间存在的量</td></tr><tr><td>流量（Flow）</td><td>一定时间内变化的量</td></tr></table><h2 id="第五节-为关于宏观经济学的基本框架"><a href="#第五节-为关于宏观经济学的基本框架" class="headerlink" title="第五节 为关于宏观经济学的基本框架"></a>第五节 为关于宏观经济学的基本框架</h2><h3 id="微观经济学"><a href="#微观经济学" class="headerlink" title="微观经济学"></a>微观经济学</h3><p><strong>微观经济学（Micro-Economics）</strong>：研究市场经济中单个经济主体——居民与企业的经济行为以及相应的经济变量<br>的决定。</p><ol><li>应有内容：个量分析/单个经济单位/目标最大化/资源配置/价格理论为核心</li><li>微观经济学的假设：理性经济人假设/充分就业假设/市场出清假设/完全信息假设</li><li>微观经济学的基本内容：<ul><li>价格的决定：需求和供给决定价格</li><li>需求分析：消费者行为理论</li><li>攻击分析： 生产与成本理论</li><li>市场理论：市场类型对价格和产量决定的影响</li><li>要素价格的决定：分配理论</li><li>信息经济学</li><li>一般均衡与福利经济学</li><li>市场失灵与政府失灵</li></ul></li></ol><h4 id="理性人假设"><a href="#理性人假设" class="headerlink" title="理性人假设"></a>理性人假设</h4><p>基本动力：利益最大化。<br>基本准则：既定目标的最优化。<br>（非理性因素：目标队员，限制性，习惯，社会政治道德等方面呢约束）</p><h2 id="第六节-学习经济学容易犯的错误"><a href="#第六节-学习经济学容易犯的错误" class="headerlink" title="第六节 学习经济学容易犯的错误"></a>第六节 学习经济学容易犯的错误</h2><p>基本研究方法：给定假设，简化关系，放松假设，逼近现实</p><p>容易犯的错误：经验主义，合成谬误</p>]]></content>
    
    
    <categories>
      
      <category>Finance</category>
      
      <category>微观经济学</category>
      
    </categories>
    
    
    <tags>
      
      <tag>辅修</tag>
      
      <tag>微观经济学</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>【HDU-6222】解题报告（大数，打表）</title>
    <link href="/post/d120bd8e.html"/>
    <url>/post/d120bd8e.html</url>
    
    <content type="html"><![CDATA[<h1 id="原始题目"><a href="#原始题目" class="headerlink" title="原始题目"></a>原始题目</h1><h2 id="Heron-and-His-Triangle"><a href="#Heron-and-His-Triangle" class="headerlink" title="Heron and His Triangle"></a>Heron and His Triangle</h2><ul><li>Time Limit: 2000/1000 MS (Java/Others)    </li><li>Memory Limit: 262144/262144 K (Java/Others)</li><li>Total Submission(s): 2123    </li><li>Accepted Submission(s): 892</li></ul><h3 id="Problem-Description"><a href="#Problem-Description" class="headerlink" title="Problem Description"></a>Problem Description</h3><p>A triangle is a Heron’s triangle if it satisfies that the side lengths of it are consecutive integers  $ t-1, t, t+1 $ and that its area is an integer. Now, for given n you need to find a Heron’s triangle associated with the smallest $t$ bigger<br>than or equal to $n$.</p><a id="more"></a><h3 id="Input"><a href="#Input" class="headerlink" title="Input"></a>Input</h3><p>The input contains multiple test cases. The first line of a multiple input is an integer $T (1 ≤ T ≤ 30000)$ followedby T lines. Each line contains an integer $N (1 ≤ N ≤ {10}^{30}) $.</p><h3 id="Output"><a href="#Output" class="headerlink" title="Output"></a>Output</h3><p>For each test case, output the smallest $t$ in a line. If the Heron’s triangle required does not exist, output $-1$.</p><h3 id="Sample-Input"><a href="#Sample-Input" class="headerlink" title="Sample Input"></a>Sample Input</h3><pre><code>41234</code></pre><h3 id="Sample-Output"><a href="#Sample-Output" class="headerlink" title="Sample Output"></a>Sample Output</h3><pre><code>4444</code></pre><h3 id="Source"><a href="#Source" class="headerlink" title="Source"></a>Source</h3><p>2017ACM/ICPC亚洲区沈阳站-重现赛（感谢东北大学）</p><h3 id="Recommend"><a href="#Recommend" class="headerlink" title="Recommend"></a>Recommend</h3><p>jiangzijing2015</p><h1 id="题目大意"><a href="#题目大意" class="headerlink" title="题目大意"></a>题目大意</h1><p>输入$n$，求大于等于$n$的最小$t$满足由$t-1,t,t+1$构成的三角形面积为整数。</p><h1 id="解题思路"><a href="#解题思路" class="headerlink" title="解题思路"></a>解题思路</h1><p>打表发现$t$构成数列</p><script type="math/tex; mode=display">t[i]=4 \times t[i-1] -t[i-2]</script><p>大数板子打表输出。</p><p>标程证明还没有想，待补充。</p><h1 id="解题代码"><a href="#解题代码" class="headerlink" title="解题代码"></a>解题代码</h1><pre><code class="hljs C++">#include &lt;bits/stdc++.h&gt;#define rep(i,a,n) for(int i=a;i&lt;n;++i)#define per(i,a,n) for(int i=n-1;i&gt;=a;--i)#define fi first#define se secondusing namespace std;// base and base_digits must be consistentconstexpr int base = 1000000000;constexpr int base_digits = 9;struct bigint&#123;    vector&lt;int&gt; z;    int sign;    bigint() : sign(1) &#123;&#125;    bigint(long long v) &#123; *this = v; &#125;    bigint&amp; operator=(long long v)    &#123;        sign = v &lt; 0 ? -1 : 1;        v*=sign;        z.clear();        for(; v &gt; 0; v = v / base) z.push_back((int)(v % base));        return *this;    &#125;    bigint(const string&amp; s) &#123; read(s); &#125;    bigint&amp; operator+=(const bigint&amp; other)    &#123;        if (sign == other.sign)        &#123;            for (int i = 0, carry = 0; i &lt; other.z.size() || carry; ++i)            &#123;                if(i==z.size()) z.push_back(0);                z[i] += carry + (i &lt; other.z.size() ? other.z[i] : 0);                carry = z[i] &gt;= base;                if(carry) z[i] -= base;            &#125;        &#125;        else if (other != 0 /* prevent infinite loop */)        &#123;            *this -= -other;        &#125;        return *this;    &#125;    friend bigint operator+(bigint a, const bigint&amp; b)    &#123;        return a += b;    &#125;    bigint&amp; operator-=(const bigint&amp; other)    &#123;        if (sign == other.sign)        &#123;            if (sign == 1 &amp;&amp; *this &gt;= other || sign == -1 &amp;&amp; *this &lt;= other)            &#123;                for (int i = 0, carry = 0; i &lt; other.z.size() || carry; ++i)                &#123;                    z[i] -= carry + (i &lt; other.z.size() ? other.z[i] : 0);                    carry = z[i] &lt; 0;                    if(carry) z[i] += base;                &#125;                trim();            &#125;            else            &#123;                *this = other - *this;                this-&gt;sign = -this-&gt;sign;            &#125;        &#125;        else *this += -other;        return *this;    &#125;    friend bigint operator - (bigint a,const bigint&amp; b)    &#123;        return a -= b;    &#125;    bigint&amp; operator*=(int v)    &#123;        if(v&lt;0) sign=-sign,v=-v;        for(int i=0,carry=0;i&lt;z.size() || carry;++i)        &#123;            if(i==z.size()) z.push_back(0);            long long cur = (long long)z[i] * v + carry;            carry = (int)(cur / base);            z[i] = (int)(cur % base);        &#125;        trim();        return *this;    &#125;    bigint operator*(int v) const    &#123;        return bigint(*this) *= v;    &#125;    friend pair&lt;bigint, bigint&gt; divmod(const bigint&amp; a1, const bigint&amp; b1)    &#123;        int norm = base / (b1.z.back() + 1);        bigint a = a1.abs() * norm;        bigint b = b1.abs() * norm;        bigint q, r;        q.z.resize(a.z.size());        for (int i = (int)a.z.size() - 1; i &gt;= 0; i--)        &#123;            r*=base; r+=a.z[i];            int s1 = b.z.size() &lt; r.z.size() ? r.z[b.z.size()] : 0;            int s2 = b.z.size() - 1 &lt; r.z.size() ? r.z[b.z.size() - 1] : 0;            int d = (int)(((long long)s1 * base + s2) / b.z.back());            r -= b * d;            while(r &lt; 0) r+=b,--d;            q.z[i] = d;        &#125;        q.sign = a1.sign * b1.sign;        r.sign = a1.sign;        q.trim();        r.trim();        return &#123;q, r / norm&#125;;    &#125;    friend bigint sqrt(const bigint&amp; a1)    &#123;        bigint a=a1;        while(a.z.empty()||a.z.size()%2==1) a.z.push_back(0);        int n = a.z.size();        int firstDigit = (int)::sqrt((double)a.z[n - 1] * base + a.z[n - 2]);        int norm = base / (firstDigit + 1);        a *= norm;        a *= norm;        while(a.z.empty()||a.z.size()%2==1) a.z.push_back(0);        bigint r = (long long)a.z[n - 1] * base + a.z[n - 2];        firstDigit = (int)::sqrt((double)a.z[n - 1] * base + a.z[n - 2]);        int q = firstDigit;        bigint res;        for (int j = n / 2 - 1; j &gt;= 0; j--)        &#123;            for(;;--q)            &#123;                bigint r1=(r-(res*2*base+q)*q)*base*base+(j&gt;0?(long long)a.z[2*j-1]*base+a.z[2*j-2]:0);                if(r1&gt;=0) &#123; r=r1; break; &#125;            &#125;            res*=base;res+=q;            if(j&gt;0)            &#123;                int d1 = res.z.size() + 2 &lt; r.z.size() ? r.z[res.z.size() + 2] : 0;                int d2 = res.z.size() + 1 &lt; r.z.size() ? r.z[res.z.size() + 1] : 0;                int d3 = res.z.size() &lt; r.z.size() ? r.z[res.z.size()]:0;                q = (int)(((long long)d1*base*base+(long long)d2*base+d3)/(firstDigit*2));            &#125;        &#125;        res.trim();        return res / norm;    &#125;    bigint operator/(const bigint&amp; v) const    &#123;        return divmod(*this, v).first;    &#125;    bigint operator%(const bigint&amp; v) const    &#123;        return divmod(*this, v).second;    &#125;    bigint&amp; operator/=(int v)    &#123;        if(v&lt;0) sign=-sign,v=-v;        for (int i = (int)z.size() - 1, rem = 0; i &gt;= 0; --i)        &#123;            long long cur = z[i] + rem * (long long)base;            z[i] = (int)(cur / v);            rem = (int)(cur % v);        &#125;        trim();        return *this;    &#125;    bigint operator/(int v) const    &#123;        return bigint(*this) /= v;    &#125;    int operator%(int v) const    &#123;        if(v&lt;0) v=-v;        int m=0;        for(int i=(int)z.size()-1;i&gt;=0;--i) m=(int)((z[i]+m*(long long)base)%v);        return m * sign;    &#125;    bigint&amp; operator*=(const bigint&amp; v)    &#123;        *this = *this * v;        return *this;    &#125;    bigint&amp; operator/=(const bigint&amp; v)    &#123;        *this = *this / v;        return *this;    &#125;    bool operator&lt;(const bigint&amp; v) const    &#123;        if(sign!=v.sign) return sign &lt; v.sign;        if(z.size()!=v.z.size()) return z.size()*sign&lt;v.z.size()*v.sign;        for(int i = (int)z.size() - 1; i &gt;= 0; i--)            if(z[i] != v.z[i])  return z[i] * sign &lt; v.z[i] * sign;        return false;    &#125;    bool operator&gt;(const bigint&amp; v) const &#123; return v &lt; *this; &#125;    bool operator&lt;=(const bigint&amp; v) const &#123; return !(v &lt; *this); &#125;    bool operator&gt;=(const bigint&amp; v) const &#123; return !(*this &lt; v); &#125;    bool operator==(const bigint&amp; v) const &#123; return !(*this &lt; v) &amp;&amp; !(v &lt; *this); &#125;    bool operator!=(const bigint&amp; v) const &#123; return *this &lt; v || v &lt; *this; &#125;    void trim()    &#123;        while(!z.empty() &amp;&amp; z.back() == 0) z.pop_back();        if(z.empty()) sign = 1;    &#125;    bool isZero() const &#123; return z.empty(); &#125;    friend bigint operator-(bigint v)    &#123;        if(!v.z.empty()) v.sign = -v.sign;        return v;    &#125;    bigint abs() const    &#123;        return sign == 1 ? *this : -*this;    &#125;    long long longValue() const    &#123;        long long res = 0;        for(int i = (int)z.size() - 1; i &gt;= 0; i--) res = res * base + z[i];        return res * sign;    &#125;    friend bigint gcd(const bigint&amp; a, const bigint&amp; b)    &#123;        return b.isZero() ? a : gcd(b, a % b);    &#125;    friend bigint lcm(const bigint&amp; a, const bigint&amp; b)    &#123;        return a / gcd(a, b) * b;    &#125;    void read(const string&amp; s)    &#123;        sign = 1;        z.clear();        int pos = 0;        while(pos &lt; s.size() &amp;&amp; (s[pos] == '-' || s[pos] == '+'))        &#123;            if(s[pos] == '-') sign = -sign;            ++pos;        &#125;        for(int i=(int)s.size()-1;i&gt;=pos;i-=base_digits)        &#123;            int x=0;            for(int j=max(pos,i-base_digits+1);j&lt;=i;j++) x=x*10+s[j]-'0';            z.push_back(x);        &#125;        trim();    &#125;    friend istream&amp; operator&gt;&gt;(istream&amp; stream, bigint&amp; v)    &#123;        string s;        stream &gt;&gt; s;        v.read(s);        return stream;    &#125;    friend ostream&amp; operator&lt;&lt;(ostream&amp; stream, const bigint&amp; v)    &#123;        if(v.sign == -1) stream &lt;&lt; '-';        stream &lt;&lt; (v.z.empty() ? 0 : v.z.back());        for(int i = (int)v.z.size() - 2; i &gt;= 0; --i)            stream &lt;&lt; setw(base_digits) &lt;&lt; setfill('0') &lt;&lt; v.z[i];        return stream;    &#125;    static vector&lt;int&gt; convert_base(const vector&lt;int&gt;&amp; a, int old_digits, int new_digits)    &#123;        vector&lt;long long&gt; p(max(old_digits, new_digits) + 1);        p[0] = 1;        for(int i=1;i&lt;p.size();i++) p[i]=p[i-1]*10;        vector&lt;int&gt; res;        long long cur = 0;        int cur_digits = 0;        for(int v : a)        &#123;            cur += v * p[cur_digits];            cur_digits += old_digits;            while (cur_digits &gt;= new_digits)            &#123;                res.push_back(int(cur % p[new_digits]));                cur /= p[new_digits];                cur_digits -= new_digits;            &#125;        &#125;        res.push_back((int)cur);        while(!res.empty() &amp;&amp; res.back()==0)            res.pop_back();        return res;    &#125;    typedef vector&lt;long long&gt; vll;    static vll karatsubaMultiply(const vll&amp; a, const vll&amp; b)    &#123;        int n=a.size();        vll res(n + n);        if(n &lt;= 32)        &#123;            for (int i = 0; i &lt; n; i++)                for (int j = 0; j &lt; n; j++)                    res[i + j] += a[i] * b[j];            return res;        &#125;        int k = n &gt;&gt; 1;        vll a1(a.begin(), a.begin() + k);        vll a2(a.begin() + k, a.end());        vll b1(b.begin(), b.begin() + k);        vll b2(b.begin() + k, b.end());        vll a1b1 = karatsubaMultiply(a1, b1);        vll a2b2 = karatsubaMultiply(a2, b2);        for(int i=0;i&lt;k;i++) a2[i]+=a1[i];        for(int i=0;i&lt;k;i++) b2[i]+=b1[i];        vll r = karatsubaMultiply(a2, b2);        for(int i=0;i&lt;a1b1.size();i++) r[i]-=a1b1[i];        for(int i=0;i&lt;a2b2.size();i++) r[i]-=a2b2[i];        for(int i=0;i&lt;r.size();i++) res[i+k]+=r[i];        for(int i=0;i&lt;a1b1.size();i++) res[i]+=a1b1[i];        for(int i = 0;i&lt;a2b2.size();i++) res[i+n]+=a2b2[i];        return res;    &#125;    bigint operator*(const bigint&amp; v) const    &#123;        vector&lt;int&gt; a6=convert_base(this-&gt;z,base_digits,6);        vector&lt;int&gt; b6=convert_base(v.z,base_digits,6);        vll a(a6.begin(),a6.end());        vll b(b6.begin(),b6.end());        while(a.size()&lt;b.size()) a.push_back(0);        while(b.size()&lt;a.size()) b.push_back(0);        while(a.size()&amp;(a.size()-1)) a.push_back(0),b.push_back(0);        vll c=karatsubaMultiply(a, b);        bigint res;        res.sign = sign * v.sign;        for (int i = 0, carry = 0; i &lt; c.size(); i++)        &#123;            long long cur = c[i] + carry;            res.z.push_back((int)(cur % 1000000));            carry = (int)(cur / 1000000);        &#125;        res.z = convert_base(res.z, 6, base_digits);        res.trim();        return res;    &#125;&#125;;bigint qpow(bigint a,bigint b)&#123;    bigint ans=1;    while(b!=0)&#123;        if(b%2)&#123;            ans= ans*a;        &#125;        b/=2;        a= a*a;    &#125;    return ans;&#125;struct Matrix&#123;bigint a[2][2];Matrix()&#123;rep(i,0,2)&#123;    rep(j,0,2)&#123;        a[i][j]=0;            &#125;&#125;&#125;Matrix operator * (const Matrix y)&#123;        Matrix ans;        for(int i = 0; i &lt; 2; i++)            for(int j = 0; j &lt; 2; j++)                for(int k = 0; k &lt; 2; k++)                    ans.a[i][j] = ans.a[i][j] + (a[i][k]*y.a[k][j]);        return ans;    &#125;Matrix operator = (const Matrix y)&#123;for(int i=0;i&lt;2;i++)for(int j=0;j&lt;2;j++)a[i][j]=y.a[i][j];&#125;Matrix operator *= (const Matrix y)&#123;Matrix ans;for(int i=0;i&lt;2;i++)for(int j=0;j&lt;2;j++)for(int k=0;k&lt;2;k++)ans.a[i][j] = ans.a[i][j] + (a[i][k]*y.a[k][j]);for(int i=0;i&lt;2;i++)for(int j=0;j&lt;2;j++)a[i][j]=ans.a[i][j];&#125;&#125;;Matrix qpow(bigint x)&#123;Matrix ans;ans.a[0][0]=ans.a[1][1]=1; //单位矩阵Matrix mul;mul.a[0][0]=4;mul.a[0][1]=-1;mul.a[1][0]=1;mul.a[1][1]=0;while(x!=0)&#123;if(x%2!=0)ans = ans*mul;mul = mul* mul;x/=2;&#125;return ans;&#125;bigint ans[1005];void solve()&#123;    ans[0]=(bigint)4;    ans[1]=(bigint)14;    ans[2]=(bigint)52;    rep(i,2,200)&#123;        ans[i]=(bigint)4*ans[i-1]-ans[i-2];//        cout&lt;&lt;ans[i]&lt;&lt;endl;    &#125;&#125;int main()&#123;    solve();    int t;cin&gt;&gt;t;    while(t--)&#123;        bigint n;        cin&gt;&gt;n;        rep(i,0,200)&#123;            if(ans[i]&gt;=n)&#123;                cout&lt;&lt;ans[i]&lt;&lt;endl;                break;            &#125;        &#125;    &#125;&#125;</code></pre><h1 id="收获与反思"><a href="#收获与反思" class="headerlink" title="收获与反思"></a>收获与反思</h1><p>证明待补充</p>]]></content>
    
    
    <categories>
      
      <category>Computer Science</category>
      
      <category>ACM</category>
      
      <category>HDU</category>
      
    </categories>
    
    
    <tags>
      
      <tag>ACM</tag>
      
      <tag>HDU</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>金融学辅修——金融学笔记（三）</title>
    <link href="/post/5f2d4a77.html"/>
    <url>/post/5f2d4a77.html</url>
    
    <content type="html"><![CDATA[<h1 id="课前同学分享"><a href="#课前同学分享" class="headerlink" title="课前同学分享"></a>课前同学分享</h1><ol><li><p>庞氏骗局</p><p> 新用户的资金补贴旧用户，没有新用户加入进来的时候，资金链断裂 </p></li><li><p>江小白发展困境与银行的最后贷款人功能</p><p> 白芝浩</p></li><li><p>资管行业三十年蝶变</p><ul><li><p>资产管理：管理资产和风险</p></li><li><p>基金崛起：公募基金<br>2000年以前以封闭式基金为主，01年-07年黄金发展期，迅速发展，08年-13年股票型和股票型发展势头迅猛。</p><p>信托行业转向主动管理。07年至今规范化。</p></li><li><p>定位与发展</p><p>基金：<br>银行理财：<br>信托：</p></li></ul></li></ol><h1 id="第三章-信用与信用工具"><a href="#第三章-信用与信用工具" class="headerlink" title="第三章 信用与信用工具"></a>第三章 信用与信用工具</h1><p>什么是信用，信用形式，信用工具，信用与经济（普惠金融）。</p><h2 id="第一节-什么是信用"><a href="#第一节-什么是信用" class="headerlink" title="第一节 什么是信用"></a>第一节 什么是信用</h2><h3 id="信用的含义"><a href="#信用的含义" class="headerlink" title="信用的含义"></a>信用的含义</h3><ol><li>Credit，就是相信，信托和声誉。</li><li>日常生活中的信用是诚实、守信。</li><li><p>经济学含义是<strong>借贷活动的总称，就是债</strong>。</p><p> 指不同所有者之间以偿还本金和支付利息为条件的借贷行为。是市场经济运行规则、市场经济交易方式、一种经济关系。</p><p> “信用经济”：</p></li></ol><h3 id="信用与借贷"><a href="#信用与借贷" class="headerlink" title="信用与借贷"></a>信用与借贷</h3><p>信用与债权债务时同时发生的，时借贷活动的两个方面：在借贷活动中，当事人一方为债权人，他将商品或货币贷出，称为<strong>授信</strong>；<br>另一方面为债务人，他接受债权人的商品或货币，称为<strong>受信</strong>；债务人遵守承诺按期偿还商品或货币并支付利息，称为<strong>守信</strong>。<br><strong>任何时期的债务总额等于信用总量</strong>。</p><p>社会信用体系：政府信用，企业信用，个人信用。</p><h3 id="信用的特点"><a href="#信用的特点" class="headerlink" title="信用的特点"></a>信用的特点</h3><ol><li>以所有权与使用权相分离的资金为信用的标的</li><li>以还本付息为条件</li><li>以相互信任为基础</li><li><p>以收益最大化为目标</p><p> 借贷双方利益最大化</p></li></ol><h3 id="信用的构成要素"><a href="#信用的构成要素" class="headerlink" title="信用的构成要素"></a>信用的构成要素</h3><ol><li>信用的主体：债权人（creditor）与债务人（debtor）</li><li>信用标的物：货币资金与实物资金</li><li>信用条件：期限与利息</li><li>信用工具：（金融工具：记载信用标的，保护债权人权利，具备法律效力的书面凭证）<ul><li>以口头承诺，账面信用为依据。（没有工具化）</li><li>以正式的书面凭证为依据，如借贷契约。（没有流动化）</li><li>可在流通市场上转让的信用，如债券（流动化）</li></ul></li></ol><a id="more"></a>    <h4 id="信用的基本功能与基本形式"><a href="#信用的基本功能与基本形式" class="headerlink" title="信用的基本功能与基本形式"></a>信用的基本功能与基本形式</h4><ol><li>基本功能</li></ol><ul><li>资金配置</li><li>信用创造</li><li>信息传播</li><li>宏观调控</li></ul><ol><li>信用形式</li></ol><ul><li>以期限为标准——长期信用与短期信用</li><li>以低于为标准——国内信用与国际信用</li><li>以信用主体为标准——商业信用/银行信用/消费信用/国家信用/合作信用/高利贷信用/国际信用等调控</li></ul><p>关于高利贷信用，并非政治经济学里面贬义的意思。</p><p>官方界定上有正规、非正规、非法。<br>高利贷信用处于非正规和非法的灰色地带。评价注意客观性。</p><ol><li>一个企业可能取得的融资方式<ol><li>企业通过签发商业票据赊账——商业信用</li><li>企业以土地等抵押给银行取得商业性贷款，或者政府取得政策性贷款——银行信用</li><li>捆包优质资产上市，以固定资产为抵押，企业债券——证券信用</li><li>股东同意，减少红利获得更多公积金——内源融资</li><li>其他国家发行外国，国际市场发行欧洲债券，背对背协议——国际融资</li></ol></li></ol><!--more--><h2 id="第二节-信用的形式"><a href="#第二节-信用的形式" class="headerlink" title="第二节 信用的形式"></a>第二节 信用的形式</h2><h3 id="商业信用"><a href="#商业信用" class="headerlink" title="商业信用"></a>商业信用</h3><ol><li><p>含义</p><p> 工商企业之间相互提供的，与商品交易直接向联系的信用形式。</p></li><li><p>方式</p><p> 赊销，赊购，分期付款。</p></li></ol><h3 id="银行信用"><a href="#银行信用" class="headerlink" title="银行信用"></a>银行信用</h3><ol><li><p>含义<br> 银行信用是指各种金融机构，特别是银行，以存、放款等多种业务形式向工商企业和个人提供的货币形态<br> 的信用，它是在商业信用基础上发展起来的一种更高层次的信用。</p></li><li><p>地位</p><p> 克服了资金力量、资信程度、提供方向方面的局限性，能通过对商业票据贴现为商业信用的进一步发展提供了条件，<br> 从而能使它成为整个经济社会信用体系中占据<strong>核心地位</strong>，成为<strong>一国信用关系中的主体</strong>。</p></li><li><p>主要作用</p></li></ol><h3 id="国家信用"><a href="#国家信用" class="headerlink" title="国家信用"></a>国家信用</h3><ol><li><p>国家信用</p><p> 是国家（包括各级政府）作为债务人，以发行政府债券或借款的方式向国内外企事业单位、团体、居民个人等筹集资金的借贷行为。</p></li><li><p>基本方式</p><p> 发行债券（国内债务和国际债务）借款</p></li><li><p>国债的主要作用</p><ul><li>筹措战争费用（战争时期）</li><li>平衡财政赤字，缓解货币流通，保持物价稳定（赤字国债）</li><li>筹措国家建设资金，举借内债影响经济增长（建设国债）    </li><li>偿还到期国债（借换国债）</li></ul></li></ol><p>财政支出=财政收入+</p>]]></content>
    
    
    <categories>
      
      <category>Finance</category>
      
      <category>金融学</category>
      
    </categories>
    
    
    <tags>
      
      <tag>辅修</tag>
      
      <tag>金融学</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>金融学辅修——金融学笔记（二）</title>
    <link href="/post/1233e925.html"/>
    <url>/post/1233e925.html</url>
    
    <content type="html"><![CDATA[<h1 id="课前同学分享"><a href="#课前同学分享" class="headerlink" title="课前同学分享"></a>课前同学分享</h1><ol><li>离岸人民币市场<br><strong>离岸市场：目标货币发行国境外的货币交易中心</strong></li></ol><p>课后补充，美元本位？马歇尔计划？欧洲美元市场。伦敦拆借市场-&gt;欧洲货币市场。</p><ol><li>租房贷<br>房东，中介，用户，传统三元模式随着互联网的发展，中介的传统职能被互联网有所替代。<br>不过新的房东，用户二元模式，又存在一些问题。</li></ol><p>新三元模式中介面临资金链紧张的问题，故金融机构逐渐引入。<br>租房贷的实质：中介公司</p><p>解决方式：</p><ol><li>加强监管：透明化和规范化<br> 风险主要分为信用风险和流动风险，信用风险一方面涉及</li></ol><h1 id="第四节-货币制度"><a href="#第四节-货币制度" class="headerlink" title="第四节 货币制度"></a>第四节 货币制度</h1><h2 id="我国的货币制度"><a href="#我国的货币制度" class="headerlink" title="我国的货币制度"></a>我国的货币制度</h2><ol><li>我国的法定货币是人民币。</li><li>人民币是我国唯一合法流通货币。</li><li>人民币的发行实行高度集中统一于中国人民银行。</li><li>人民币的发行保证是国家拥有的商品物资，黄金外汇储备主要是作为国际支付的准备金。</li></ol><a id="more"></a><h2 id="纸币发行准备制度的方式："><a href="#纸币发行准备制度的方式：" class="headerlink" title="纸币发行准备制度的方式："></a>纸币发行准备制度的方式：</h2><ol><li>以黄金或外汇储备准备的发行</li><li>无准备发行</li></ol><p>第二钟以港币发行为例。<br>香港地方三家银行汇丰，</p><p>央行可以通过行政命令，直接宣布汇率变化，来影响</p><h2 id="金属本位"><a href="#金属本位" class="headerlink" title="金属本位"></a>金属本位</h2><h3 id="金银复本位"><a href="#金银复本位" class="headerlink" title="金银复本位"></a>金银复本位</h3><ol><li><p>平行本位：即金银币平等，同事都是本位币，都可以自由铸造和融化自由地输出入国境，金银币的交易比率由<br>市场决定，国家没有法律规定。</p><p> 问题：由于任一商品都拥有两个价格，比例随金银比价波动，造成价格混乱，给交易带来了很多麻烦。</p></li><li><p>双本位：格雷欣法则，劣币驱逐良币</p><p> 劣币驱逐良币律Gresham’s Law：金银复本位制下，两种实际价值不同而含义相同的金属铸币流通时，实际价值高的会通过熔化，<br> 储藏或者到国外而退出流通。</p></li><li><p>跛行本位</p><p> 金币可以自由铸造，但是银币不能自由铸造，只可以无限偿还。</p></li></ol><h3 id="金本位制的三种形式"><a href="#金本位制的三种形式" class="headerlink" title="金本位制的三种形式"></a>金本位制的三种形式</h3><ol><li><p>金币本位：纯粹的金币本为：<br> <strong>自由铸造，自由兑换，自由输出入国境</strong></p></li><li><p>金块本位：金币不再流通，黄金纸币不可自由兑换，一定限额。<br> 两次世界大战期间英法实行，黄金储备不够不足以支持自由兑换（富人本位）。</p></li><li><p>金汇兑本位：不铸造金币，市场上不流通，本币不可兑换黄金，但本币可以以固定汇率兑换成<strong>某一实行金币或金块本位的国家<br>的货币</strong>，并在该国兑换黄金。（无法兑换，提供其他两种本位的一个固定汇率关系）<br> 纸币与黄金的关系进一步弱化。</p></li></ol><h1 id="第五节-国际货币体系"><a href="#第五节-国际货币体系" class="headerlink" title="第五节 国际货币体系"></a>第五节 国际货币体系</h1><p>“黄金——美元”本位制的布雷顿森立体系，美元本位制牙买加体系。</p><h2 id="国际货币制度的研边"><a href="#国际货币制度的研边" class="headerlink" title="国际货币制度的研边"></a>国际货币制度的研边</h2><p>国际金本位制度（1880-1913） =&gt;  浮动汇率制度（1914-1944） =&gt; 布雷顿森林体系（1945-1973） =&gt; 牙买加体系（1978）</p><h2 id="国际金本位制"><a href="#国际金本位制" class="headerlink" title="国际金本位制"></a>国际金本位制</h2><p>特点：</p><p>原因</p><ol><li>黄金产量不足，长期通货紧缩</li><li>黄金产品分布不均</li><li>第一次世界大战爆发的刺激</li></ol><h2 id="布雷顿森林体系的建立"><a href="#布雷顿森林体系的建立" class="headerlink" title="布雷顿森林体系的建立"></a>布雷顿森林体系的建立</h2><p>“双挂钩一固定” 美元同黄金挂钩，其他货币与美元挂钩。美元与黄金兑换固定（35美元1盎司）。</p>]]></content>
    
    
    <categories>
      
      <category>Finance</category>
      
      <category>金融学</category>
      
    </categories>
    
    
    <tags>
      
      <tag>辅修</tag>
      
      <tag>金融学</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>【UVALive-7734】解题报告（水题）</title>
    <link href="/post/47b391f2.html"/>
    <url>/post/47b391f2.html</url>
    
    <content type="html"><![CDATA[<h1 id="原始题目"><a href="#原始题目" class="headerlink" title="原始题目"></a>原始题目</h1><a id="more"></a><h1 id="题目大意"><a href="#题目大意" class="headerlink" title="题目大意"></a>题目大意</h1><p>给出$n$种物品每种的个数和价值，求价值总和。</p><h1 id="解题思路"><a href="#解题思路" class="headerlink" title="解题思路"></a>解题思路</h1><p>求和</p><h1 id="解题代码"><a href="#解题代码" class="headerlink" title="解题代码"></a>解题代码</h1><pre><code class="hljs C++"><span class="hljs-meta">#<span class="hljs-meta-keyword">include</span><span class="hljs-meta-string">&lt;bits/stdc++.h&gt;</span></span><span class="hljs-meta">#<span class="hljs-meta-keyword">include</span><span class="hljs-meta-string">&lt;algorithm&gt;</span></span><span class="hljs-meta">#<span class="hljs-meta-keyword">define</span> rep(i,a,n) for(int i=a;i&lt;n;++i)</span><span class="hljs-meta">#<span class="hljs-meta-keyword">define</span> per(i,a,n) for(int i=n-a;i&gt;=a;--i)</span><span class="hljs-meta">#<span class="hljs-meta-keyword">define</span> fi first</span><span class="hljs-meta">#<span class="hljs-meta-keyword">define</span> se second</span><span class="hljs-meta">#<span class="hljs-meta-keyword">define</span> cl(x,a) memset(x,a,sizeof(x))</span><span class="hljs-meta">#<span class="hljs-meta-keyword">define</span> all(x) x.begin(),x.end()</span><span class="hljs-meta">#<span class="hljs-meta-keyword">define</span> INF 0x3f3f3f3f</span><span class="hljs-meta">#<span class="hljs-meta-keyword">define</span> EPS 1e-9</span><span class="hljs-meta">#<span class="hljs-meta-keyword">define</span> mod 1000000007</span><span class="hljs-keyword">using</span> <span class="hljs-keyword">namespace</span> <span class="hljs-built_in">std</span>;<span class="hljs-keyword">const</span> <span class="hljs-keyword">int</span> maxn=<span class="hljs-number">1e5</span>+<span class="hljs-number">5</span>;<span class="hljs-keyword">const</span> <span class="hljs-keyword">int</span> maxm=<span class="hljs-number">1e5</span>+<span class="hljs-number">5</span>;<span class="hljs-keyword">typedef</span> <span class="hljs-keyword">long</span> <span class="hljs-keyword">long</span> ll;<span class="hljs-keyword">typedef</span> <span class="hljs-keyword">unsigned</span> <span class="hljs-keyword">long</span> <span class="hljs-keyword">long</span> ull;<span class="hljs-keyword">typedef</span> <span class="hljs-built_in">vector</span>&lt;<span class="hljs-keyword">int</span>&gt; vi;<span class="hljs-keyword">typedef</span> pair&lt;<span class="hljs-keyword">int</span>,<span class="hljs-keyword">int</span>&gt; pii;<span class="hljs-keyword">int</span> t,n,m;<span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span>&#123;    ios::sync_with_stdio(<span class="hljs-literal">false</span>);    <span class="hljs-built_in">cin</span>&gt;&gt;t;    <span class="hljs-keyword">while</span>(t--)&#123;        <span class="hljs-built_in">cin</span>&gt;&gt;n;        ll ans=<span class="hljs-number">0</span>;        rep(i,<span class="hljs-number">0</span>,n)&#123;            <span class="hljs-keyword">int</span> a,b;            <span class="hljs-built_in">cin</span>&gt;&gt;a&gt;&gt;b;            ans+=a*b;        &#125;        <span class="hljs-built_in">cout</span>&lt;&lt;ans&lt;&lt;<span class="hljs-built_in">endl</span>;    &#125;&#125;</code></pre><h1 id="收获与反思"><a href="#收获与反思" class="headerlink" title="收获与反思"></a>收获与反思</h1><p>暂无</p>]]></content>
    
    
    <categories>
      
      <category>Computer Science</category>
      
      <category>ACM</category>
      
      <category>UVA</category>
      
    </categories>
    
    
    <tags>
      
      <tag>ACM</tag>
      
      <tag>UVA</tag>
      
      <tag>补图</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>【UVALive-7737】解题报告（概率，时间独立性，暴力）</title>
    <link href="/post/273ced06.html"/>
    <url>/post/273ced06.html</url>
    
    <content type="html"><![CDATA[<h1 id="原始题目"><a href="#原始题目" class="headerlink" title="原始题目"></a>原始题目</h1><a id="more"></a><h1 id="题目大意"><a href="#题目大意" class="headerlink" title="题目大意"></a>题目大意</h1><p>Bob想从$n$种硬币中选出一种幸运硬币。选择策略如下：</p><ul><li>如果当前没有剩下的硬币或者只剩下一种硬币，则该硬币为幸运硬币。</li><li>否则，将现有硬币抛出后，保留所有正面朝上的硬币。</li></ul><p>给出每种硬币抛出后正面朝上的概率，计算各种硬币成为幸运硬币的概率。</p><h1 id="解题思路"><a href="#解题思路" class="headerlink" title="解题思路"></a>解题思路</h1><p>由于题目中更说明：<strong>每种硬币抛出后正面朝上的概率在0.4和0.6之间</strong></p><p>易分析知抛得次数可能是无限的，但连续一百次正面朝上的概率已经很小（精度要求内可忽略不计），想到打表。</p><ul><li>$alive[i][j]$ 表示第i种硬币能存留到第j次抛出之前。</li><li>$dead[i][j]$ 表示第i种硬币不能存留到第j次抛出之前。</li></ul><p>则最终答案为 $ans[i]= \sum (alive[i][j]-alive[i][j+1])*( \sum dead[k][j]) $</p><h1 id="解题代码"><a href="#解题代码" class="headerlink" title="解题代码"></a>解题代码</h1><pre><code class="hljs C++"><span class="hljs-meta">#<span class="hljs-meta-keyword">include</span><span class="hljs-meta-string">&lt;bits/stdc++.h&gt;</span></span><span class="hljs-meta">#<span class="hljs-meta-keyword">include</span><span class="hljs-meta-string">&lt;algorithm&gt;</span></span><span class="hljs-meta">#<span class="hljs-meta-keyword">define</span> rep(i,a,n) for(int i=a;i&lt;n;++i)</span><span class="hljs-meta">#<span class="hljs-meta-keyword">define</span> per(i,a,n) for(int i=n-a;i&gt;=a;--i)</span><span class="hljs-meta">#<span class="hljs-meta-keyword">define</span> fi first</span><span class="hljs-meta">#<span class="hljs-meta-keyword">define</span> se second</span><span class="hljs-meta">#<span class="hljs-meta-keyword">define</span> cl(x,a) memset(x,a,sizeof(x))</span><span class="hljs-meta">#<span class="hljs-meta-keyword">define</span> all(x) x.begin(),x.end()</span><span class="hljs-meta">#<span class="hljs-meta-keyword">define</span> INF 0x3f3f3f3f</span><span class="hljs-meta">#<span class="hljs-meta-keyword">define</span> EPS 1e-9</span><span class="hljs-meta">#<span class="hljs-meta-keyword">define</span> mod 1000000007</span><span class="hljs-meta">#<span class="hljs-meta-keyword">define</span> FF 150</span><span class="hljs-keyword">using</span> <span class="hljs-keyword">namespace</span> <span class="hljs-built_in">std</span>;<span class="hljs-keyword">const</span> <span class="hljs-keyword">int</span> maxn=<span class="hljs-number">1e3</span>+<span class="hljs-number">5</span>;<span class="hljs-keyword">const</span> <span class="hljs-keyword">int</span> maxm=<span class="hljs-number">1e5</span>+<span class="hljs-number">5</span>;<span class="hljs-keyword">typedef</span> <span class="hljs-keyword">long</span> <span class="hljs-keyword">long</span> ll;<span class="hljs-keyword">typedef</span> <span class="hljs-keyword">unsigned</span> <span class="hljs-keyword">long</span> <span class="hljs-keyword">long</span> ull;<span class="hljs-keyword">typedef</span> <span class="hljs-built_in">vector</span>&lt;<span class="hljs-keyword">int</span>&gt; vi;<span class="hljs-keyword">typedef</span> pair&lt;<span class="hljs-keyword">int</span>,<span class="hljs-keyword">int</span>&gt; pii;<span class="hljs-keyword">int</span> t,n,m;<span class="hljs-keyword">int</span> num[maxn];<span class="hljs-keyword">double</span> p[maxn];<span class="hljs-keyword">double</span> dead[maxn][FF];<span class="hljs-keyword">double</span> alive[maxn][FF];<span class="hljs-keyword">double</span> ans[maxn];<span class="hljs-function"><span class="hljs-keyword">double</span> <span class="hljs-title">qpow</span><span class="hljs-params">(<span class="hljs-keyword">double</span> a,<span class="hljs-keyword">int</span> x)</span></span>&#123;    <span class="hljs-keyword">double</span> ans=<span class="hljs-number">1.0</span>;    <span class="hljs-keyword">while</span>(x)&#123;        <span class="hljs-keyword">if</span>(x&amp;<span class="hljs-number">1</span>) ans *=a;        a*=a;        x&gt;&gt;=<span class="hljs-number">1</span>;    &#125;    <span class="hljs-keyword">return</span> ans;&#125;<span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">solve</span><span class="hljs-params">()</span></span>&#123;    rep(i,<span class="hljs-number">1</span>,n+<span class="hljs-number">1</span>)&#123;        rep(j,<span class="hljs-number">1</span>,FF)&#123;            <span class="hljs-keyword">double</span> temp=qpow(p[i],j);            dead[i][j]=qpow((<span class="hljs-number">1.0</span>-temp),num[i]);            alive[i][j]=<span class="hljs-number">1.0</span>-dead[i][j];        &#125;    &#125;&#125;<span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span>&#123;    ios::sync_with_stdio(<span class="hljs-literal">false</span>);    <span class="hljs-built_in">cin</span>&gt;&gt;t;    <span class="hljs-keyword">while</span>(t--)&#123;        <span class="hljs-built_in">cin</span>&gt;&gt;n;        rep(i,<span class="hljs-number">1</span>,n+<span class="hljs-number">1</span>)&#123;            <span class="hljs-built_in">cin</span>&gt;&gt;num[i]&gt;&gt;p[i];        &#125;        <span class="hljs-keyword">if</span>(n==<span class="hljs-number">1</span>)&#123;            <span class="hljs-built_in">cout</span>&lt;&lt;fixed&lt;&lt;setprecision(<span class="hljs-number">6</span>)&lt;&lt;<span class="hljs-number">1.0</span>&lt;&lt;<span class="hljs-built_in">endl</span>;            <span class="hljs-keyword">continue</span>;        &#125;        <span class="hljs-built_in">memset</span>(alive,<span class="hljs-number">0</span>,<span class="hljs-keyword">sizeof</span>(alive));        <span class="hljs-built_in">memset</span>(dead,<span class="hljs-number">0</span>,<span class="hljs-keyword">sizeof</span>(dead));        solve();        rep(i,<span class="hljs-number">1</span>,n+<span class="hljs-number">1</span>)&#123;            ans[i]=<span class="hljs-number">0</span>;            rep(j,<span class="hljs-number">1</span>,FF)&#123;                <span class="hljs-keyword">double</span> temp=<span class="hljs-number">1.0</span>;                rep(k,<span class="hljs-number">1</span>,n+<span class="hljs-number">1</span>)&#123;                    <span class="hljs-keyword">if</span>(i==k) <span class="hljs-keyword">continue</span>;                    <span class="hljs-keyword">else</span>&#123;                        temp*=dead[k][j];                    &#125;                &#125;                ans[i]+=temp*(alive[i][j]-alive[i][j+<span class="hljs-number">1</span>]);            &#125;        &#125;        <span class="hljs-built_in">cout</span>&lt;&lt;fixed&lt;&lt;setprecision(<span class="hljs-number">6</span>)&lt;&lt;ans[<span class="hljs-number">1</span>];        rep(i,<span class="hljs-number">2</span>,n+<span class="hljs-number">1</span>)&#123;            <span class="hljs-built_in">cout</span>&lt;&lt;<span class="hljs-string">" "</span>&lt;&lt;fixed&lt;&lt;setprecision(<span class="hljs-number">6</span>)&lt;&lt;ans[i];        &#125;        <span class="hljs-built_in">cout</span>&lt;&lt;<span class="hljs-built_in">endl</span>;    &#125;&#125;</code></pre><h1 id="收获与反思"><a href="#收获与反思" class="headerlink" title="收获与反思"></a>收获与反思</h1><p>注意分析概率的公式。</p>]]></content>
    
    
    <categories>
      
      <category>Computer Science</category>
      
      <category>ACM</category>
      
      <category>UVA</category>
      
    </categories>
    
    
    <tags>
      
      <tag>ACM</tag>
      
      <tag>UVA</tag>
      
      <tag>补图</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>【CSU-1112】解题报告（模拟，水题）</title>
    <link href="/post/1c52564f.html"/>
    <url>/post/1c52564f.html</url>
    
    <content type="html"><![CDATA[<h1 id="原始题目"><a href="#原始题目" class="headerlink" title="原始题目"></a>原始题目</h1><h2 id="1112-机器人的指令"><a href="#1112-机器人的指令" class="headerlink" title="1112: 机器人的指令"></a>1112: 机器人的指令</h2><ul><li>Time Limit: 1 Sec     </li><li>Memory Limit: 128 Mb     </li><li>Submitted: 3392     </li><li>Solved: 1245    </li></ul><h3 id="Description"><a href="#Description" class="headerlink" title="Description"></a>Description</h3><p>数轴原点有一个机器人。该机器人将执行一系列指令，你的任务是预测所有指令执行完毕之后它的位置。</p><ul><li><p>LEFT：往左移动一个单位</p></li><li><p>RIGHT: 往右移动一个单位</p></li><li><p>SAME AS i: 和第i 条执行相同的动作。输入保证i 是一个正整数，且不超过之前执行指令数</p></li></ul><a id="more"></a><h3 id="Input"><a href="#Input" class="headerlink" title="Input"></a>Input</h3><p>输入第一行为数据组数$T (T≤100)$。每组数据第一行为整数 $n (1≤n≤100) $，即指令条数。以下每行一条指令。指令按照输入顺序编号为$1 \cdots n$。</p><h3 id="Output"><a href="#Output" class="headerlink" title="Output"></a>Output</h3><p>对于每组数据，输出机器人的最终位置。每处理完一组数据，机器人应复位到数轴原点。</p><h3 id="Sample-Input"><a href="#Sample-Input" class="headerlink" title="Sample Input"></a>Sample Input</h3><pre><code>23LEFTRIGHTSAME AS 25LEFTSAME AS 1SAME AS 2SAME AS 1SAME AS 4</code></pre><h3 id="Sample-Output"><a href="#Sample-Output" class="headerlink" title="Sample Output"></a>Sample Output</h3><pre><code>1-5</code></pre><h3 id="Hint"><a href="#Hint" class="headerlink" title="Hint"></a>Hint</h3><h3 id="Source"><a href="#Source" class="headerlink" title="Source"></a>Source</h3><p>湖南省第八届大学生计算机程序设计竞赛</p><h1 id="题目大意"><a href="#题目大意" class="headerlink" title="题目大意"></a>题目大意</h1><p>如题</p><h1 id="解题思路"><a href="#解题思路" class="headerlink" title="解题思路"></a>解题思路</h1><p>储存每一操作，线性扫。</p><h1 id="解题代码"><a href="#解题代码" class="headerlink" title="解题代码"></a>解题代码</h1><pre><code class="hljs C++"><span class="hljs-meta">#<span class="hljs-meta-keyword">include</span> <span class="hljs-meta-string">&lt;cstdio&gt;</span></span><span class="hljs-meta">#<span class="hljs-meta-keyword">include</span><span class="hljs-meta-string">&lt;cstring&gt;</span></span><span class="hljs-meta">#<span class="hljs-meta-keyword">include</span> <span class="hljs-meta-string">&lt;set&gt;</span></span><span class="hljs-meta">#<span class="hljs-meta-keyword">include</span> <span class="hljs-meta-string">&lt;string&gt;</span></span><span class="hljs-meta">#<span class="hljs-meta-keyword">include</span> <span class="hljs-meta-string">&lt;iostream&gt;</span></span><span class="hljs-meta">#<span class="hljs-meta-keyword">include</span> <span class="hljs-meta-string">&lt;iomanip&gt;</span></span><span class="hljs-meta">#<span class="hljs-meta-keyword">include</span> <span class="hljs-meta-string">&lt;queue&gt;</span></span><span class="hljs-meta">#<span class="hljs-meta-keyword">include</span> <span class="hljs-meta-string">&lt;vector&gt;</span></span><span class="hljs-meta">#<span class="hljs-meta-keyword">include</span> <span class="hljs-meta-string">&lt;map&gt;</span></span><span class="hljs-meta">#<span class="hljs-meta-keyword">include</span> <span class="hljs-meta-string">&lt;algorithm&gt;</span></span><span class="hljs-meta">#<span class="hljs-meta-keyword">define</span> rep(i,a,n) for(int i=a;i&lt;n;++i)</span><span class="hljs-meta">#<span class="hljs-meta-keyword">define</span> per(i,a,n) for(int i=n-1;i&gt;=a;--i)</span><span class="hljs-meta">#<span class="hljs-meta-keyword">define</span> cl(x,a) memset(x,a,sizeof(x))</span><span class="hljs-meta">#<span class="hljs-meta-keyword">define</span> all(x) x.begin(),x.end()</span><span class="hljs-meta">#<span class="hljs-meta-keyword">define</span> INF 0x3f3f3f3f</span><span class="hljs-meta">#<span class="hljs-meta-keyword">define</span> EPS 1e-9</span><span class="hljs-meta">#<span class="hljs-meta-keyword">define</span> mod 1000000007</span><span class="hljs-meta">#<span class="hljs-meta-keyword">define</span> fi first</span><span class="hljs-meta">#<span class="hljs-meta-keyword">define</span> se second</span><span class="hljs-keyword">using</span> <span class="hljs-keyword">namespace</span> <span class="hljs-built_in">std</span>;<span class="hljs-keyword">const</span> <span class="hljs-keyword">int</span> maxn=<span class="hljs-number">1e5</span>+<span class="hljs-number">5</span>;<span class="hljs-keyword">typedef</span> <span class="hljs-keyword">long</span> <span class="hljs-keyword">long</span> ll;<span class="hljs-keyword">typedef</span> <span class="hljs-keyword">unsigned</span> <span class="hljs-keyword">long</span> <span class="hljs-keyword">long</span> ull;<span class="hljs-keyword">typedef</span> <span class="hljs-built_in">vector</span>&lt;<span class="hljs-keyword">int</span>&gt; vi;<span class="hljs-keyword">typedef</span> pair&lt;<span class="hljs-keyword">int</span>,<span class="hljs-keyword">int</span>&gt; pii;<span class="hljs-keyword">int</span> t,n,m,a;<span class="hljs-keyword">int</span> num[maxn];<span class="hljs-built_in">string</span> ctl;<span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span>&#123;    ios::sync_with_stdio(<span class="hljs-literal">false</span>);    <span class="hljs-built_in">cin</span>&gt;&gt;t;    <span class="hljs-keyword">while</span>(t--)&#123;        <span class="hljs-keyword">int</span> temp=<span class="hljs-number">0</span>;        <span class="hljs-built_in">cin</span>&gt;&gt;n;        rep(i,<span class="hljs-number">1</span>,n+<span class="hljs-number">1</span>)&#123;            <span class="hljs-built_in">cin</span>&gt;&gt;ctl;            <span class="hljs-keyword">if</span>(ctl[<span class="hljs-number">0</span>]==<span class="hljs-string">'S'</span>)&#123;                <span class="hljs-built_in">cin</span>&gt;&gt;ctl&gt;&gt;a;                num[i]=num[a];            &#125;            <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span>(ctl[<span class="hljs-number">0</span>]==<span class="hljs-string">'L'</span>)&#123;                num[i]=<span class="hljs-number">-1</span>;            &#125;            <span class="hljs-keyword">else</span> num[i]=<span class="hljs-number">1</span>;        &#125;        rep(i,<span class="hljs-number">1</span>,n+<span class="hljs-number">1</span>)&#123;            temp+=num[i];        &#125;        <span class="hljs-built_in">cout</span>&lt;&lt;temp&lt;&lt;<span class="hljs-built_in">endl</span>;    &#125;&#125;</code></pre><h1 id="收获与反思"><a href="#收获与反思" class="headerlink" title="收获与反思"></a>收获与反思</h1><p>暂无</p>]]></content>
    
    
    <categories>
      
      <category>Computer Science</category>
      
      <category>ACM</category>
      
      <category>CSU</category>
      
    </categories>
    
    
    <tags>
      
      <tag>ACM</tag>
      
      <tag>CSU</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>【CSU-1104】解题报告（博弈游戏，找规律）</title>
    <link href="/post/feaebfb5.html"/>
    <url>/post/feaebfb5.html</url>
    
    <content type="html"><![CDATA[<h1 id="原始题目"><a href="#原始题目" class="headerlink" title="原始题目"></a>原始题目</h1>]]></content>
    
    
    <categories>
      
      <category>Computer Science</category>
      
      <category>ACM</category>
      
      <category>CSU</category>
      
    </categories>
    
    
    <tags>
      
      <tag>ACM</tag>
      
      <tag>CSU</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>金融学辅修——金融学笔记（一）</title>
    <link href="/post/222505fd.html"/>
    <url>/post/222505fd.html</url>
    
    <content type="html"><![CDATA[<h1 id="第一节-什么是货币"><a href="#第一节-什么是货币" class="headerlink" title="第一节 什么是货币"></a>第一节 什么是货币</h1><p>金融学的起点，也是金融学的终点。所有金融现象、金融行为都是某种程度的或大或小的货币事件。</p><blockquote><p>货币就是金钱，信用就是金钱，金钱可生金钱。货币决定未来世界格局。</p></blockquote><p>IMF，国际货币基金组织，成员国，运行“份子”根据本国对外贸易占世界贸易中的比重，以及GDP水平等来衡量。投票权重<br>与“份子”相关，百分之十五决议通过，而目前美元比重占比17%，所以几乎等于断言。IMF也是随着布雷顿森林体系的建立而崛起的。</p><h2 id="货币的产生"><a href="#货币的产生" class="headerlink" title="货币的产生"></a>货币的产生</h2><p>中国古代货币起源说（解决民间秒换困难，沟通产品交换的手段）。</p><p>西方货币起源说（创造发明说，便于交换说，保存财富说）。</p><p>马克思货币起源说（货币是商品生产和商品交换发展的必然产物，是商品经济内在矛盾发展的必然结果）。</p><p>进一步解释马克思的解释： 简单的物物交换=&gt;复杂的物物交换=&gt;（规模逐渐发展，信用，复杂程度等多方面影响）=&gt;货币的产生</p><h2 id="货币的本质"><a href="#货币的本质" class="headerlink" title="货币的本质"></a>货币的本质</h2><p>货币金属说，货币名目说，劳动价值说。</p><h2 id="货币的定义"><a href="#货币的定义" class="headerlink" title="货币的定义"></a>货币的定义</h2><p>经济学中成为货币的东西，就是人们日常生活中的钱的东西。由于时代背景，观察角度、观察深度不同以及侧重于<br>理论剖析与侧重于解决实际问题需要不同，定义表述不同。</p><p><strong>本质定义：从商品交换中分离出来固定地充当一般等价物的特殊商品。</strong></p><p><strong>经济学定义：在商品或劳务支付中或债务偿还中被普遍接受的任何东西。</strong></p><p><strong>法定货币（法律定义）：通过立法授予某种物品具有清偿债务的合法权利。</strong></p><p><strong>层次定义（计量定义）：</strong></p><a id="more"></a><table><tr><td>M0=流通中现金（通货）</td></tr><tr><td>M1=M0+企业活期存款+农业存款+</td></tr><tr><td></td></tr></table>]]></content>
    
    
    <categories>
      
      <category>Finance</category>
      
      <category>金融学</category>
      
    </categories>
    
    
    <tags>
      
      <tag>辅修</tag>
      
      <tag>金融学</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>【CSU-1111】解题报告（水题）</title>
    <link href="/post/e256d99f.html"/>
    <url>/post/e256d99f.html</url>
    
    <content type="html"><![CDATA[<h1 id="原始题目"><a href="#原始题目" class="headerlink" title="原始题目"></a>原始题目</h1><h2 id="1111-三家人"><a href="#1111-三家人" class="headerlink" title="1111: 三家人"></a>1111: 三家人</h2><ul><li>Time Limit: 1 Sec     </li><li>Memory Limit: 128 Mb     </li><li>Submitted: 4053     </li><li>Solved: 1606    </li></ul><h3 id="Description"><a href="#Description" class="headerlink" title="Description"></a>Description</h3><p>有三户人家共拥有一座花园，每户人家的太太均需帮忙整理花园。A 太太工作了5 天，B 太太则工作了4 天，才将花园整理完毕。C 太太因为正身怀六甲无法加入她们的行列，便出了90元。请问这笔钱如何分给A、B 二位太太较为恰当？A 应得多少元？$ 5 \times \frac {90} {5+4}= 50 $？如果这么想你就上当了！正确答案是60 元。如果没想通的话再想想吧。</p><p>下面回答一个一般性的问题：假定A 太太工作了x 天，B 太太工作了y 天，C 太太出了90元，则A 太太应得多少元？输入保证二位太太均应得到非负整数元钱。三个太太工作效率相同。</p><p>友情提示：本题有个小小的陷阱哦。如果答案错的话，认真检查一下代码吧。</p><a id="more"></a><h3 id="Input"><a href="#Input" class="headerlink" title="Input"></a>Input</h3><p>输入第一行为数据组数$T (T ≤ 20) $。每组数据仅一行，包含三个整数 $x, y, z (1 ≤ x, y ≤10,1 ≤ z ≤1000) $。</p><h3 id="Output"><a href="#Output" class="headerlink" title="Output"></a>Output</h3><p>对于每组数据，输出一个整数，即A 太太应得的金额（单位：元）。</p><h3 id="Sample-Input"><a href="#Sample-Input" class="headerlink" title="Sample Input"></a>Sample Input</h3><pre><code>25 4 908 4 123</code></pre><h3 id="Sample-Output"><a href="#Sample-Output" class="headerlink" title="Sample Output"></a>Sample Output</h3><pre><code>60123</code></pre><h3 id="Hint"><a href="#Hint" class="headerlink" title="Hint"></a>Hint</h3><p>如果使用浮点数，请小心误差，输出时尽量用四舍五入。</p><h3 id="Source"><a href="#Source" class="headerlink" title="Source"></a>Source</h3><p>湖南省第八届大学生计算机程序设计竞赛</p><h1 id="题目大意"><a href="#题目大意" class="headerlink" title="题目大意"></a>题目大意</h1><p>如题</p><h1 id="解题思路"><a href="#解题思路" class="headerlink" title="解题思路"></a>解题思路</h1><p>考虑每个人都应该完成$ \frac {1}{3} $ 的工作量。再按多余完成量分配钱，注意考虑工作量不够自己应该完成的情况。</p><h1 id="解题代码"><a href="#解题代码" class="headerlink" title="解题代码"></a>解题代码</h1><pre><code class="hljs C++"><span class="hljs-meta">#<span class="hljs-meta-keyword">include</span> <span class="hljs-meta-string">&lt;cstdio&gt;</span></span><span class="hljs-meta">#<span class="hljs-meta-keyword">include</span> <span class="hljs-meta-string">&lt;cstring&gt;</span></span><span class="hljs-meta">#<span class="hljs-meta-keyword">include</span> <span class="hljs-meta-string">&lt;iostream&gt;</span></span><span class="hljs-meta">#<span class="hljs-meta-keyword">include</span> <span class="hljs-meta-string">&lt;iomanip&gt;</span></span><span class="hljs-meta">#<span class="hljs-meta-keyword">include</span> <span class="hljs-meta-string">&lt;cstdlib&gt;</span></span><span class="hljs-meta">#<span class="hljs-meta-keyword">include</span> <span class="hljs-meta-string">&lt;set&gt;</span></span><span class="hljs-meta">#<span class="hljs-meta-keyword">include</span> <span class="hljs-meta-string">&lt;string&gt;</span></span><span class="hljs-meta">#<span class="hljs-meta-keyword">include</span> <span class="hljs-meta-string">&lt;cstring&gt;</span></span><span class="hljs-meta">#<span class="hljs-meta-keyword">include</span> <span class="hljs-meta-string">&lt;stack&gt;</span></span><span class="hljs-meta">#<span class="hljs-meta-keyword">define</span> rep(i,a,n) for(int i=a;i&lt;n;++i)</span><span class="hljs-meta">#<span class="hljs-meta-keyword">define</span> per(i,a,n) for(int i=n-1;i&gt;=a;--i)</span><span class="hljs-keyword">using</span> <span class="hljs-keyword">namespace</span> <span class="hljs-built_in">std</span>;<span class="hljs-keyword">const</span> <span class="hljs-keyword">int</span> maxn=<span class="hljs-number">1e5</span>+<span class="hljs-number">5</span>;<span class="hljs-keyword">const</span> <span class="hljs-keyword">int</span> maxl=<span class="hljs-number">26</span>;<span class="hljs-keyword">int</span> t,n;<span class="hljs-keyword">double</span> x,y,z; <span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span>&#123;ios::sync_with_stdio(<span class="hljs-literal">false</span>);<span class="hljs-built_in">cin</span>&gt;&gt;t;<span class="hljs-keyword">while</span>(t--)&#123;<span class="hljs-built_in">cin</span>&gt;&gt;x&gt;&gt;y&gt;&gt;z;<span class="hljs-keyword">double</span> ans=(x+y)/<span class="hljs-number">3.0</span>;<span class="hljs-keyword">if</span>(ans&gt;(<span class="hljs-keyword">double</span>)x) <span class="hljs-built_in">cout</span>&lt;&lt;<span class="hljs-number">0</span>&lt;&lt;<span class="hljs-built_in">endl</span>;<span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span>(ans&gt;(<span class="hljs-keyword">double</span>)y) <span class="hljs-built_in">cout</span>&lt;&lt;fixed&lt;&lt;setprecision(<span class="hljs-number">0</span>)&lt;&lt;z&lt;&lt;<span class="hljs-built_in">endl</span>;<span class="hljs-keyword">else</span> &#123;x-=ans;y-=ans;<span class="hljs-built_in">cout</span>&lt;&lt;fixed&lt;&lt;setprecision(<span class="hljs-number">0</span>)&lt;&lt;z*x/(x+y)&lt;&lt;<span class="hljs-built_in">endl</span>;&#125;&#125;&#125;</code></pre><h1 id="收获与反思"><a href="#收获与反思" class="headerlink" title="收获与反思"></a>收获与反思</h1><p>水题</p>]]></content>
    
    
    <categories>
      
      <category>Computer Science</category>
      
      <category>ACM</category>
      
      <category>CSU</category>
      
    </categories>
    
    
    <tags>
      
      <tag>ACM</tag>
      
      <tag>CSU</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>【CSU-1115】解题报告（字典树）</title>
    <link href="/post/e5d75450.html"/>
    <url>/post/e5d75450.html</url>
    
    <content type="html"><![CDATA[<h1 id="原始题目"><a href="#原始题目" class="headerlink" title="原始题目"></a>原始题目</h1><h2 id="1115-最短的名字"><a href="#1115-最短的名字" class="headerlink" title="1115: 最短的名字"></a>1115: 最短的名字</h2><ul><li>Time Limit: 5 Sec</li><li>Memory Limit: 64 Mb</li><li>Submitted: 2057</li><li>Solved: 801</li></ul><h3 id="Description"><a href="#Description" class="headerlink" title="Description"></a>Description</h3><p>在一个奇怪的村子中，很多人的名字都很长，比如 aaaaa, bbb and abababab。</p><p>名字这么长，叫全名显然起来很不方便。所以村民之间一般只叫名字的前缀。比如叫’aaaaa’的时候可以只叫’aaa’，因为没有第二个人名字的前三个字母是’aaa’。不过你不能叫’a’，因为有两个人的名字都以’a’开头。村里的人都很聪明，他们总是用最短的称呼叫人。输入保证村里不会有一个人的名字是另外一个人名字的前缀（作为推论，任意两个人的名字都不会相同）。</p><p>如果村里的某个人要叫所有人的名字（包括他自己），他一共会说多少个字母？</p><a id="more"></a><h3 id="Input"><a href="#Input" class="headerlink" title="Input"></a>Input</h3><p>输入第一行为数据组数$T (T≤10)$。每组数据第一行为一个整数 n$(1≤n≤1000)$ ，即村里的人数。以下$n$行每行为一个人的名字（仅有小写字母组成）。输入保证一个村里所有人名字的长度之和不超过 $10^{6}$。</p><h3 id="Output"><a href="#Output" class="headerlink" title="Output"></a>Output</h3><p>对于每组数据，输出所有人名字的字母总数。</p><h3 id="Sample-Input"><a href="#Sample-Input" class="headerlink" title="Sample Input"></a>Sample Input</h3><pre><code>13aaaaabbbabababab</code></pre><h3 id="Sample-Output"><a href="#Sample-Output" class="headerlink" title="Sample Output"></a>Sample Output</h3><pre><code>5</code></pre><h3 id="Hint"><a href="#Hint" class="headerlink" title="Hint"></a>Hint</h3><h3 id="Source"><a href="#Source" class="headerlink" title="Source"></a>Source</h3><p>湖南省第八届大学生计算机程序设计竞赛</p><h1 id="题目大意"><a href="#题目大意" class="headerlink" title="题目大意"></a>题目大意</h1><p>如题</p><h1 id="解题思路"><a href="#解题思路" class="headerlink" title="解题思路"></a>解题思路</h1><p>建立字典树，每个结点的 value 值储存单词字母的出现次数。</p><ul><li>对于每个单词，统计第一个出现 value 值为 1 的位置（表示到这里后面没有相同单词前缀）</li><li>求和，完成任务</li></ul><h1 id="解题代码"><a href="#解题代码" class="headerlink" title="解题代码"></a>解题代码</h1><pre><code class="hljs C++"><span class="hljs-meta">#<span class="hljs-meta-keyword">include</span> <span class="hljs-meta-string">&lt;cstdio&gt;</span></span><span class="hljs-meta">#<span class="hljs-meta-keyword">include</span> <span class="hljs-meta-string">&lt;cstring&gt;</span></span><span class="hljs-meta">#<span class="hljs-meta-keyword">include</span> <span class="hljs-meta-string">&lt;iostream&gt;</span></span><span class="hljs-meta">#<span class="hljs-meta-keyword">include</span> <span class="hljs-meta-string">&lt;cstdlib&gt;</span></span><span class="hljs-meta">#<span class="hljs-meta-keyword">include</span> <span class="hljs-meta-string">&lt;set&gt;</span></span><span class="hljs-meta">#<span class="hljs-meta-keyword">include</span> <span class="hljs-meta-string">&lt;string&gt;</span></span><span class="hljs-meta">#<span class="hljs-meta-keyword">include</span> <span class="hljs-meta-string">&lt;cstring&gt;</span></span><span class="hljs-meta">#<span class="hljs-meta-keyword">include</span> <span class="hljs-meta-string">&lt;stack&gt;</span></span><span class="hljs-meta">#<span class="hljs-meta-keyword">define</span> rep(i,a,n) for(int i=a;i&lt;n;++i)</span><span class="hljs-meta">#<span class="hljs-meta-keyword">define</span> per(i,a,n) for(int i=n-1;i&gt;=a;--i)</span><span class="hljs-keyword">using</span> <span class="hljs-keyword">namespace</span> <span class="hljs-built_in">std</span>;<span class="hljs-keyword">const</span> <span class="hljs-keyword">int</span> maxn=<span class="hljs-number">1e5</span>+<span class="hljs-number">5</span>;<span class="hljs-keyword">const</span> <span class="hljs-keyword">int</span> maxl=<span class="hljs-number">26</span>;<span class="hljs-keyword">typedef</span> <span class="hljs-keyword">long</span> <span class="hljs-keyword">long</span> ll;<span class="hljs-keyword">typedef</span> <span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">Trie</span>&#123;</span><span class="hljs-keyword">int</span> v;Trie* next[maxl];&#125;Trie;Trie *root;<span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">iniTrie</span><span class="hljs-params">()</span></span>&#123;root=(Trie*)<span class="hljs-built_in">malloc</span>(<span class="hljs-keyword">sizeof</span>(Trie));<span class="hljs-keyword">for</span>(<span class="hljs-keyword">int</span> i=<span class="hljs-number">0</span>;i&lt;maxl;i++)root-&gt;next[i]=<span class="hljs-literal">NULL</span>;root-&gt;v=<span class="hljs-number">-1</span>;&#125;<span class="hljs-function"><span class="hljs-keyword">bool</span> <span class="hljs-title">creTrie</span><span class="hljs-params">(<span class="hljs-built_in">string</span> a)</span></span>&#123;<span class="hljs-keyword">int</span> l=a.length();Trie *p=root,*q;<span class="hljs-keyword">for</span>(<span class="hljs-keyword">int</span> i=<span class="hljs-number">0</span>;i&lt;l;i++)&#123;<span class="hljs-keyword">int</span> id=a[i]-<span class="hljs-string">'a'</span>;<span class="hljs-comment">//并非前缀不能有相同，而是不能在相同的分支上。</span><span class="hljs-comment">//if(i==l-1)&#123;</span><span class="hljs-comment">//if(p-&gt;next[id]!=NULL) return 0;</span><span class="hljs-comment">//&#125;</span><span class="hljs-keyword">if</span>(p-&gt;next[id]==<span class="hljs-literal">NULL</span>)&#123;q=(Trie*) <span class="hljs-built_in">malloc</span>(<span class="hljs-keyword">sizeof</span>(Trie));q-&gt;v=<span class="hljs-number">1</span>;<span class="hljs-keyword">for</span>(<span class="hljs-keyword">int</span> j=<span class="hljs-number">0</span>;j&lt;maxl;j++)q-&gt;next[j]=<span class="hljs-literal">NULL</span>;<span class="hljs-comment">//</span><span class="hljs-comment">//结点连接到树上</span>p-&gt;next[id]=q;p=p-&gt;next[id];&#125;<span class="hljs-keyword">else</span>&#123;p=p-&gt;next[id];p-&gt;v++;&#125;&#125;<span class="hljs-keyword">return</span> <span class="hljs-number">1</span>;&#125;<span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">cntTrie</span><span class="hljs-params">(<span class="hljs-built_in">string</span> ss)</span></span>&#123;<span class="hljs-keyword">int</span> l=ss.length();Trie *p=root,*q;<span class="hljs-keyword">for</span>(<span class="hljs-keyword">int</span> i=<span class="hljs-number">0</span>;i&lt;l;i++)&#123;<span class="hljs-keyword">int</span> id=ss[i]-<span class="hljs-string">'a'</span>;p=p-&gt;next[id];<span class="hljs-keyword">if</span>(p-&gt;v==<span class="hljs-number">1</span>) <span class="hljs-keyword">return</span> i+<span class="hljs-number">1</span>;&#125;&#125;<span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">delTrie</span><span class="hljs-params">(Trie *p)</span></span>&#123;    <span class="hljs-keyword">int</span> i;    <span class="hljs-keyword">for</span>(i=<span class="hljs-number">0</span>;i&lt;maxl;i++)    &#123;        <span class="hljs-keyword">if</span>(p-&gt;next[i] != <span class="hljs-literal">NULL</span>)            delTrie(p-&gt;next[i]);    &#125;    <span class="hljs-built_in">free</span>(p);<span class="hljs-comment">//    printf("1");</span>p==<span class="hljs-literal">NULL</span>;<span class="hljs-keyword">return</span> ;&#125;<span class="hljs-built_in">string</span> s[maxn];<span class="hljs-keyword">int</span> t,ccount,n;<span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span>&#123;ios::sync_with_stdio(<span class="hljs-literal">false</span>);<span class="hljs-built_in">cin</span>&gt;&gt;t;<span class="hljs-keyword">while</span>(t--)&#123;iniTrie();<span class="hljs-built_in">cin</span>&gt;&gt;n;rep(i,<span class="hljs-number">0</span>,n)&#123;<span class="hljs-built_in">cin</span>&gt;&gt;s[i];creTrie(s[i]);&#125;<span class="hljs-keyword">int</span> aans=<span class="hljs-number">0</span>;rep(i,<span class="hljs-number">0</span>,n)&#123;aans+=cntTrie(s[i]);&#125;<span class="hljs-built_in">cout</span>&lt;&lt;aans&lt;&lt;<span class="hljs-built_in">endl</span>;delTrie(root);&#125;&#125;</code></pre><h1 id="收获与反思"><a href="#收获与反思" class="headerlink" title="收获与反思"></a>收获与反思</h1><p>灵活运用字典树的染色和统计功能</p>]]></content>
    
    
    <categories>
      
      <category>Computer Science</category>
      
      <category>ACM</category>
      
      <category>CSU</category>
      
    </categories>
    
    
    <tags>
      
      <tag>ACM</tag>
      
      <tag>CSU</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>【CSU-1101】解题报告（水题，模拟）</title>
    <link href="/post/d6a5bd15.html"/>
    <url>/post/d6a5bd15.html</url>
    
    <content type="html"><![CDATA[<h1 id="原始题目"><a href="#原始题目" class="headerlink" title="原始题目"></a>原始题目</h1><h2 id="1101-报数游戏"><a href="#1101-报数游戏" class="headerlink" title="1101: 报数游戏"></a>1101: 报数游戏</h2><ul><li>Time Limit: 1 Sec</li><li>Memory Limit: 128 Mb</li><li>Submitted: 1400</li><li>Solved: 474</li></ul><h2 id="Description"><a href="#Description" class="headerlink" title="Description"></a>Description</h2><p>n个人站成一行玩一个报数游戏。所有人从左到右编号为1到n。游戏开始时，最左边的人报1，他右边的人报2，编号为3的人报3，等等。当编号为n的人（即最右边的人）报完n之后，轮到他左边的人（即编号为n-1的人）报n+1，然后编号为n-2的人报n+2，以此类推。当最左边的人再次报数之后，报数方向又变成从左到右，依次类推。<br>为了防止游戏太无聊，报数时有一个特例：如果应该报的数包含数字7或者是7的倍数，他应当用拍手代替报数。下表是n=4的报数情况（X表示拍手）。当编号为3的人第4次拍手的时候，他实际上数到了35。 </p><p><img src="https://eddyblog.oss-cn-shenzhen.aliyuncs.com/%E3%80%90CSU-1101%E3%80%91%E8%A7%A3%E9%A2%98%E6%8A%A5%E5%91%8A%EF%BC%88%E6%B0%B4%E9%A2%98%EF%BC%8C%E6%A8%A1%E6%8B%9F%EF%BC%89/1.png" srcset="/img/loading.gif" alt="1.png"></p><p>给定$n,m,k$，你的任务是计算当编号为 $m$ 的人第 $k$ 次拍手时，他实际上数到了几。 </p><a id="more"></a><h3 id="Input"><a href="#Input" class="headerlink" title="Input"></a>Input</h3><p>输入包含不超过10组数据。每组数据占一行，包含三个整数 $n,m$ 和 $k$ $( 2 ≤ n ≤ 100, 1 ≤ m ≤n,  1 ≤ k  ≤ 100)$。输入结束标志为 $n=m=k=0$。</p><h3 id="Output"><a href="#Output" class="headerlink" title="Output"></a>Output</h3><p>对于每组数据，输出一行，即编号为 $m$ 的人第 $k$ 次拍手时，他实际上数到的那个整数。 </p><h3 id="Sample-Input"><a href="#Sample-Input" class="headerlink" title="Sample Input"></a>Sample Input</h3><pre><code>4 3 14 3 24 3 34 3 40 0 0</code></pre><h3 id="Sample-Output"><a href="#Sample-Output" class="headerlink" title="Sample Output"></a>Sample Output</h3><pre><code>17212735</code></pre><h3 id="Hint"><a href="#Hint" class="headerlink" title="Hint"></a>Hint</h3><h3 id="Source"><a href="#Source" class="headerlink" title="Source"></a>Source</h3><p>湖南省第七届大学生计算机程序设计竞赛</p><h1 id="题目大意"><a href="#题目大意" class="headerlink" title="题目大意"></a>题目大意</h1><p>如题</p><h1 id="解题思路"><a href="#解题思路" class="headerlink" title="解题思路"></a>解题思路</h1><p>直接模拟</p><h1 id="解题代码"><a href="#解题代码" class="headerlink" title="解题代码"></a>解题代码</h1><pre><code class="hljs C++"><span class="hljs-meta">#<span class="hljs-meta-keyword">include</span> <span class="hljs-meta-string">&lt;cstdio&gt;</span></span><span class="hljs-meta">#<span class="hljs-meta-keyword">include</span> <span class="hljs-meta-string">&lt;cstring&gt;</span></span><span class="hljs-meta">#<span class="hljs-meta-keyword">include</span> <span class="hljs-meta-string">&lt;cstdlib&gt;</span></span><span class="hljs-meta">#<span class="hljs-meta-keyword">include</span> <span class="hljs-meta-string">&lt;string&gt;</span></span><span class="hljs-meta">#<span class="hljs-meta-keyword">include</span> <span class="hljs-meta-string">&lt;iostream&gt;</span></span><span class="hljs-meta">#<span class="hljs-meta-keyword">include</span> <span class="hljs-meta-string">&lt;iomanip&gt;</span></span><span class="hljs-meta">#<span class="hljs-meta-keyword">include</span> <span class="hljs-meta-string">&lt;queue&gt;</span></span><span class="hljs-meta">#<span class="hljs-meta-keyword">include</span> <span class="hljs-meta-string">&lt;stack&gt;</span></span><span class="hljs-meta">#<span class="hljs-meta-keyword">include</span> <span class="hljs-meta-string">&lt;vector&gt;</span></span><span class="hljs-meta">#<span class="hljs-meta-keyword">include</span> <span class="hljs-meta-string">&lt;set&gt;</span></span><span class="hljs-meta">#<span class="hljs-meta-keyword">include</span> <span class="hljs-meta-string">&lt;map&gt;</span></span><span class="hljs-meta">#<span class="hljs-meta-keyword">include</span> <span class="hljs-meta-string">&lt;algorithm&gt;</span></span><span class="hljs-meta">#<span class="hljs-meta-keyword">include</span> <span class="hljs-meta-string">&lt;bits/stdc++.h&gt;</span></span><span class="hljs-meta">#<span class="hljs-meta-keyword">define</span> fi first</span><span class="hljs-meta">#<span class="hljs-meta-keyword">define</span> se second</span><span class="hljs-meta">#<span class="hljs-meta-keyword">define</span> rep(i,a,n) for(int i=a;i&lt;n;++i)</span><span class="hljs-meta">#<span class="hljs-meta-keyword">define</span> per(i,a,n) for(int i=n-1;i&gt;=a;--i)</span><span class="hljs-meta">#<span class="hljs-meta-keyword">define</span> cl(x,a) memset(x,a,sizeof(x)) </span><span class="hljs-meta">#<span class="hljs-meta-keyword">define</span> all(x) x.begin,x.end()</span><span class="hljs-meta">#<span class="hljs-meta-keyword">define</span> INF 0x3f3f3f3f</span><span class="hljs-meta">#<span class="hljs-meta-keyword">define</span> eps 1e-8</span><span class="hljs-keyword">using</span> <span class="hljs-keyword">namespace</span> <span class="hljs-built_in">std</span>;<span class="hljs-keyword">typedef</span> <span class="hljs-keyword">long</span> <span class="hljs-keyword">long</span> ll;<span class="hljs-keyword">typedef</span> <span class="hljs-keyword">unsigned</span> <span class="hljs-keyword">long</span> <span class="hljs-keyword">long</span> ull;<span class="hljs-keyword">typedef</span> <span class="hljs-built_in">vector</span>&lt;<span class="hljs-keyword">int</span>&gt; vi;<span class="hljs-keyword">typedef</span> pair&lt;<span class="hljs-keyword">int</span>,<span class="hljs-keyword">int</span>&gt; pii;<span class="hljs-keyword">typedef</span> pair&lt;<span class="hljs-built_in">string</span>,<span class="hljs-built_in">string</span>&gt; pss;<span class="hljs-keyword">const</span> <span class="hljs-keyword">int</span> maxn=<span class="hljs-number">1e5</span>+<span class="hljs-number">5</span>;<span class="hljs-keyword">const</span> <span class="hljs-keyword">int</span> maxm=<span class="hljs-number">1e5</span>+<span class="hljs-number">5</span>;<span class="hljs-keyword">const</span> <span class="hljs-keyword">int</span> maxl=<span class="hljs-number">26</span>;<span class="hljs-keyword">int</span> vis[maxn];<span class="hljs-function"><span class="hljs-keyword">bool</span> <span class="hljs-title">check</span><span class="hljs-params">(ll num)</span></span>&#123;<span class="hljs-keyword">while</span>(num)&#123;<span class="hljs-keyword">int</span> temp=num%<span class="hljs-number">10</span>;<span class="hljs-keyword">if</span>(temp==<span class="hljs-number">7</span>) <span class="hljs-keyword">return</span> <span class="hljs-number">1</span>;num/=<span class="hljs-number">10</span>;&#125;<span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;&#125;<span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span>&#123;ll n,m,k,cnt=<span class="hljs-number">0</span>;<span class="hljs-keyword">int</span> flag=<span class="hljs-number">0</span>;<span class="hljs-keyword">while</span>(~<span class="hljs-built_in">scanf</span>(<span class="hljs-string">"%lld%lld%lld"</span>,&amp;n,&amp;m,&amp;k) &amp;&amp; n+m+k)&#123;<span class="hljs-built_in">memset</span>(vis,<span class="hljs-number">0</span>,<span class="hljs-keyword">sizeof</span>(vis));flag=<span class="hljs-number">0</span>,cnt=<span class="hljs-number">0</span>;<span class="hljs-keyword">while</span>(vis[m]&lt;k)&#123;rep(i,<span class="hljs-number">1</span>,n)&#123;<span class="hljs-keyword">if</span>((++cnt )%<span class="hljs-number">7</span>==<span class="hljs-number">0</span>  || check(cnt)) &#123;<span class="hljs-comment">//cout&lt;&lt;"i="&lt;&lt;i&lt;&lt;"   cnt="&lt;&lt;cnt&lt;&lt;endl; </span>vis[i]++;&#125;<span class="hljs-keyword">if</span>(vis[m]==k) <span class="hljs-keyword">break</span>;&#125;<span class="hljs-keyword">if</span>(vis[m]==k) <span class="hljs-keyword">break</span>;per(i,<span class="hljs-number">2</span>,n+<span class="hljs-number">1</span>)&#123;<span class="hljs-keyword">if</span>((++cnt)%<span class="hljs-number">7</span>==<span class="hljs-number">0</span> || check(cnt)) &#123;<span class="hljs-comment">//cout&lt;&lt;"i="&lt;&lt;i&lt;&lt;"   cnt="&lt;&lt;cnt&lt;&lt;endl; </span>vis[i]++;&#125;<span class="hljs-keyword">if</span>(vis[m]==k) <span class="hljs-keyword">break</span>;&#125;&#125;<span class="hljs-built_in">cout</span>&lt;&lt;cnt&lt;&lt;<span class="hljs-built_in">endl</span>;&#125; &#125;</code></pre><h1 id="收获与反思"><a href="#收获与反思" class="headerlink" title="收获与反思"></a>收获与反思</h1><p>直接模拟即可</p>]]></content>
    
    
    <categories>
      
      <category>Computer Science</category>
      
      <category>ACM</category>
      
      <category>CSU</category>
      
    </categories>
    
    
    <tags>
      
      <tag>ACM</tag>
      
      <tag>CSU</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>【CSU-1315】解题报告（排序，前缀和）</title>
    <link href="/post/e7058b47.html"/>
    <url>/post/e7058b47.html</url>
    
    <content type="html"><![CDATA[<h1 id="原始题目"><a href="#原始题目" class="headerlink" title="原始题目"></a>原始题目</h1><h2 id="1315-全场最水题之陈兴老师与比赛"><a href="#1315-全场最水题之陈兴老师与比赛" class="headerlink" title="1315: 全场最水题之陈兴老师与比赛"></a>1315: 全场最水题之陈兴老师与比赛</h2><ul><li>Time Limit: 1 Sec     </li><li>Memory Limit: 128 Mb     </li><li>Submitted: 841     </li><li>Solved: 280    </li></ul><h3 id="Description"><a href="#Description" class="headerlink" title="Description"></a>Description</h3><p>大家都知道ACM比赛罚时很重要。比如说你做A题要10分钟，B题要15分钟，如果先做A题再做B题，那么在ranking上的时间就是10 + （10）+ 15 = 35。如果先做B题再做A题总罚时就是15+(15)+<br>10=40.现在陈兴老师要做一场比赛，比赛有$n$道题， 总时间是$300$分钟。<br>我们的陈兴老师仅仅看题目就可以知道他做每道题需要的时间，所以他想在比赛刚开始时就计算出自己的最大总做题数，以及对应的总罚时和做题顺序（当然，做题数相等时当然希望总罚时最少咯）。<br>比如一般的比赛，陈兴老师做第一题需要1分钟，第二题2分钟，依此类推，陈兴老师只需要66分钟就可以AK一场11道题的比赛。PS: 陈兴老师做题都是1Y，膜拜陈兴老师Orz！</p><a id="more"></a><h3 id="Input"><a href="#Input" class="headerlink" title="Input"></a>Input</h3><p>第一行是一个数字 $n  (0&lt;n ≤25)$ 。</p><p>第二行是$n$个数字，第$i$个数字代表陈兴老师出编号为$i$的题所需要的时间 $t_i( 0 &lt; t_i ≤ 80)$。</p><h3 id="Output"><a href="#Output" class="headerlink" title="Output"></a>Output</h3><p>第一行输出陈兴老师的出题数和Penalty（总时间）</p><p>以下按照顺序输出陈兴老师出题的顺序,每行一个编号。（详见输出样例）PS：时间一样的按编号升序输出。</p><h3 id="Sample-Input"><a href="#Sample-Input" class="headerlink" title="Sample Input"></a>Sample Input</h3><pre><code>31 2 341 2 3 4660 60 60 60 60 60</code></pre><h3 id="Sample-Output"><a href="#Sample-Output" class="headerlink" title="Sample Output"></a>Sample Output</h3><pre><code>3 101234 2012345 90012345</code></pre><h3 id="Hint"><a href="#Hint" class="headerlink" title="Hint"></a>Hint</h3><h3 id="Source"><a href="#Source" class="headerlink" title="Source"></a>Source</h3><h1 id="题目大意"><a href="#题目大意" class="headerlink" title="题目大意"></a>题目大意</h1><p>原题说的不大清楚，实际上对于每到AC题目罚时累加上从开始到完成该题目的时间，比赛一共300分钟，<br>求解题数，罚时，并输出接替顺序。（感觉整理CSU题面的时候应该再完善一下题目意思）</p><h1 id="解题思路"><a href="#解题思路" class="headerlink" title="解题思路"></a>解题思路</h1><p>排序以后求前缀和，当前缀和超过300时输出</p><h1 id="解题代码"><a href="#解题代码" class="headerlink" title="解题代码"></a>解题代码</h1><pre><code class="hljs C++"><span class="hljs-meta">#<span class="hljs-meta-keyword">include</span> <span class="hljs-meta-string">&lt;cstdio&gt;</span></span><span class="hljs-meta">#<span class="hljs-meta-keyword">include</span> <span class="hljs-meta-string">&lt;cstring&gt;</span></span><span class="hljs-meta">#<span class="hljs-meta-keyword">include</span> <span class="hljs-meta-string">&lt;iostream&gt;</span></span><span class="hljs-meta">#<span class="hljs-meta-keyword">include</span> <span class="hljs-meta-string">&lt;iomanip&gt;</span></span><span class="hljs-meta">#<span class="hljs-meta-keyword">include</span> <span class="hljs-meta-string">&lt;set&gt;</span></span><span class="hljs-meta">#<span class="hljs-meta-keyword">include</span> <span class="hljs-meta-string">&lt;queue&gt;</span></span><span class="hljs-meta">#<span class="hljs-meta-keyword">include</span> <span class="hljs-meta-string">&lt;map&gt;</span></span><span class="hljs-meta">#<span class="hljs-meta-keyword">include</span> <span class="hljs-meta-string">&lt;sstream&gt;</span></span><span class="hljs-meta">#<span class="hljs-meta-keyword">include</span> <span class="hljs-meta-string">&lt;algorithm&gt;</span></span><span class="hljs-meta">#<span class="hljs-meta-keyword">include</span> <span class="hljs-meta-string">&lt;vector&gt;</span></span><span class="hljs-meta">#<span class="hljs-meta-keyword">include</span> <span class="hljs-meta-string">&lt;stack&gt;</span></span><span class="hljs-meta">#<span class="hljs-meta-keyword">include</span> <span class="hljs-meta-string">&lt;cmath&gt;</span></span><span class="hljs-meta">#<span class="hljs-meta-keyword">define</span> rep(i,a,n) for(int i=a;i&lt;n;++i)</span><span class="hljs-meta">#<span class="hljs-meta-keyword">define</span> per(i,a,n) for(int i=n-1;i&gt;=a;--i)</span><span class="hljs-meta">#<span class="hljs-meta-keyword">define</span> fi first</span><span class="hljs-meta">#<span class="hljs-meta-keyword">define</span> se second</span><span class="hljs-meta">#<span class="hljs-meta-keyword">define</span> mp make_pair</span><span class="hljs-meta">#<span class="hljs-meta-keyword">define</span> pb push_back</span><span class="hljs-meta">#<span class="hljs-meta-keyword">define</span> np next_permutation</span><span class="hljs-meta">#<span class="hljs-meta-keyword">define</span> all(x) x.begin(),x.end()</span><span class="hljs-meta">#<span class="hljs-meta-keyword">define</span> insert(x) x,x.begin()</span><span class="hljs-meta">#<span class="hljs-meta-keyword">define</span> cl(x,a) memset(x,a,sizeof(x))</span><span class="hljs-keyword">using</span> <span class="hljs-keyword">namespace</span> <span class="hljs-built_in">std</span>;<span class="hljs-keyword">const</span> <span class="hljs-keyword">int</span> maxn=<span class="hljs-number">1e5</span>+<span class="hljs-number">5</span>;<span class="hljs-keyword">const</span> <span class="hljs-keyword">int</span> maxm=<span class="hljs-number">1e5</span>+<span class="hljs-number">5</span>;<span class="hljs-keyword">const</span> <span class="hljs-keyword">int</span> maxl=<span class="hljs-number">26</span>;<span class="hljs-keyword">typedef</span> <span class="hljs-keyword">long</span> <span class="hljs-keyword">long</span> ll;<span class="hljs-keyword">typedef</span> <span class="hljs-keyword">unsigned</span> <span class="hljs-keyword">long</span> <span class="hljs-keyword">long</span> ull;<span class="hljs-keyword">typedef</span> <span class="hljs-built_in">vector</span>&lt;<span class="hljs-keyword">int</span>&gt; vi;<span class="hljs-keyword">typedef</span> pair&lt;<span class="hljs-keyword">int</span>,<span class="hljs-keyword">int</span>&gt; pii;<span class="hljs-keyword">typedef</span> pair&lt;<span class="hljs-built_in">string</span>,<span class="hljs-built_in">string</span>&gt; pss;<span class="hljs-function"><span class="hljs-keyword">bool</span> <span class="hljs-title">cmp</span><span class="hljs-params">(pii a,pii b)</span></span>&#123;<span class="hljs-keyword">if</span>(a.second!=b.second) <span class="hljs-keyword">return</span> a.second&lt;b.second;<span class="hljs-keyword">else</span> <span class="hljs-keyword">return</span> a.first&lt;b.first;&#125;<span class="hljs-keyword">int</span> n,t,a[maxn];<span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span>&#123;<span class="hljs-comment">//ios::sync_with_stdio(false);</span><span class="hljs-keyword">while</span>(~<span class="hljs-built_in">scanf</span>(<span class="hljs-string">"%d"</span>,&amp;n))&#123;<span class="hljs-built_in">vector</span>&lt;pii&gt; v;rep(i,<span class="hljs-number">1</span>,n+<span class="hljs-number">1</span>)&#123;<span class="hljs-keyword">int</span> temp;<span class="hljs-built_in">scanf</span>(<span class="hljs-string">"%d"</span>,&amp;temp);v.pb(mp(i,temp));&#125;sort(all(v),cmp);a[<span class="hljs-number">0</span>]=v[<span class="hljs-number">0</span>].second;rep(i,<span class="hljs-number">1</span>,n) &#123;a[i]=a[i<span class="hljs-number">-1</span>]+v[i].second;<span class="hljs-comment">//cout&lt;&lt;"a["&lt;&lt;i&lt;&lt;"] = "&lt;&lt;a[i]&lt;&lt;endl;</span>&#125;<span class="hljs-keyword">int</span> panality=<span class="hljs-number">0</span>,i=<span class="hljs-number">0</span>,caltime=<span class="hljs-number">0</span>;<span class="hljs-keyword">for</span>(;i&lt;n&amp;&amp;caltime&lt;=<span class="hljs-number">300</span>;i++)&#123;panality+=a[i];caltime+=v[i].second;&#125;<span class="hljs-keyword">if</span>(caltime&lt;=<span class="hljs-number">300</span>) &#123;<span class="hljs-comment">//cout&lt;&lt;n&lt;&lt;" "&lt;&lt;panality&lt;&lt;endl;</span><span class="hljs-built_in">printf</span>(<span class="hljs-string">"%d %d\n"</span>,n,panality);<span class="hljs-comment">//rep(i,0,n) cout&lt;&lt;v[i].fi&lt;&lt;endl;</span>rep(i,<span class="hljs-number">0</span>,n) <span class="hljs-built_in">printf</span>(<span class="hljs-string">"%d\n"</span>,v[i].fi);&#125;<span class="hljs-keyword">else</span> &#123;panality-=a[--i];<span class="hljs-comment">//cout&lt;&lt;i&lt;&lt;" "&lt;&lt;panality&lt;&lt;endl;</span><span class="hljs-built_in">printf</span>(<span class="hljs-string">"%d %d\n"</span>,i,panality);<span class="hljs-comment">//rep(i,0,n) cout&lt;&lt;v[i].fi&lt;&lt;endl;</span>rep(j,<span class="hljs-number">0</span>,i) <span class="hljs-built_in">printf</span>(<span class="hljs-string">"%d\n"</span>,v[j].fi);&#125;&#125;&#125;</code></pre><h1 id="收获与反思"><a href="#收获与反思" class="headerlink" title="收获与反思"></a>收获与反思</h1><p>排序一下</p>]]></content>
    
    
    <categories>
      
      <category>Computer Science</category>
      
      <category>ACM</category>
      
      <category>CSU</category>
      
    </categories>
    
    
    <tags>
      
      <tag>ACM</tag>
      
      <tag>CSU</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>【CSU-1321】解题报告（最短路，dij）</title>
    <link href="/post/4773b69c.html"/>
    <url>/post/4773b69c.html</url>
    
    <content type="html"><![CDATA[<h1 id="原始题目"><a href="#原始题目" class="headerlink" title="原始题目"></a>原始题目</h1><h2 id="1321-CX-and-girls"><a href="#1321-CX-and-girls" class="headerlink" title="1321: CX and girls"></a>1321: CX and girls</h2><ul><li>Time Limit: 1 Sec     </li><li>Memory Limit: 128 Mb     </li><li>Submitted: 597     </li><li>Solved: 181    </li></ul><h3 id="Description"><a href="#Description" class="headerlink" title="Description"></a>Description</h3><p>CX是要赶去上课，为了不迟到必须要以最短的路径到达教室，同时CX希望经过的路上能看到的学妹越多越好。<br>现在把地图抽象成一个无向图，CX从$1$点出发，教室在$N$号点，告诉每个点上学妹的数量，每条边的长度。</p><p>请你求出CX以最短路径赶到教室最多能看到多少学妹。<br><a id="more"></a></p><h3 id="Input"><a href="#Input" class="headerlink" title="Input"></a>Input</h3><p>多组输入数据(最多20组)，输入到文件结束。</p><p>每组数据第一行两个正整数$N,M$其中$N$代表点的个数$( 2 ≤ N ≤ 1000)$，$M$代表边的个数$(1 ≤ M ≤ 10000)$。</p><p>接下来一行$N$个数，代表着$1 \cdots N$每个点上学妹的个数，$(0 ≤  N_i \le  50)$。 接下来$M$行，每行三个数$A,B,C (1 \le  A , B \le  N , 0 &lt; C \le  100 )$ 代表$A,B$两点间有边，长度为$C$。(可能存在重边)</p><h3 id="Output"><a href="#Output" class="headerlink" title="Output"></a>Output</h3><p>输出CX以最短距离从$1$到$n$的情况下能看到的最多学妹数量，若从点$1$无法到达点$N$输出$-1$。</p><h3 id="Sample-Input"><a href="#Sample-Input" class="headerlink" title="Sample Input"></a>Sample Input</h3><pre><code>4 41 2 3 41 2 11 3 1   2 4 23 4 2</code></pre><h3 id="Sample-Output"><a href="#Sample-Output" class="headerlink" title="Sample Output"></a>Sample Output</h3><pre><code>8</code></pre><h3 id="Author"><a href="#Author" class="headerlink" title="Author"></a>Author</h3><p>CSU_ZZY</p><h3 id="Source"><a href="#Source" class="headerlink" title="Source"></a>Source</h3><p>CSU Monthly 2013 Oct.</p><h1 id="题目大意"><a href="#题目大意" class="headerlink" title="题目大意"></a>题目大意</h1><p>如题</p><h1 id="解题思路"><a href="#解题思路" class="headerlink" title="解题思路"></a>解题思路</h1><p>最短路加上对结点值的判断</p><h1 id="解题代码"><a href="#解题代码" class="headerlink" title="解题代码"></a>解题代码</h1><pre><code class="hljs C++"><span class="hljs-meta">#<span class="hljs-meta-keyword">include</span> <span class="hljs-meta-string">&lt;cstdio&gt;</span></span><span class="hljs-meta">#<span class="hljs-meta-keyword">include</span> <span class="hljs-meta-string">&lt;cstring&gt;</span></span><span class="hljs-meta">#<span class="hljs-meta-keyword">include</span> <span class="hljs-meta-string">&lt;string&gt;</span></span><span class="hljs-meta">#<span class="hljs-meta-keyword">include</span> <span class="hljs-meta-string">&lt;algorithm&gt;</span></span><span class="hljs-meta">#<span class="hljs-meta-keyword">include</span> <span class="hljs-meta-string">&lt;iostream&gt;</span></span><span class="hljs-meta">#<span class="hljs-meta-keyword">include</span> <span class="hljs-meta-string">&lt;stack&gt;</span></span><span class="hljs-meta">#<span class="hljs-meta-keyword">include</span> <span class="hljs-meta-string">&lt;set&gt;</span></span><span class="hljs-meta">#<span class="hljs-meta-keyword">include</span> <span class="hljs-meta-string">&lt;vector&gt;</span></span><span class="hljs-meta">#<span class="hljs-meta-keyword">include</span> <span class="hljs-meta-string">&lt;queue&gt;</span></span><span class="hljs-meta">#<span class="hljs-meta-keyword">include</span> <span class="hljs-meta-string">&lt;cmath&gt;</span></span><span class="hljs-meta">#<span class="hljs-meta-keyword">include</span> <span class="hljs-meta-string">&lt;cstdlib&gt;</span></span><span class="hljs-meta">#<span class="hljs-meta-keyword">include</span> <span class="hljs-meta-string">&lt;bits/stdc++.h&gt; </span></span><span class="hljs-keyword">using</span> <span class="hljs-keyword">namespace</span> <span class="hljs-built_in">std</span>;<span class="hljs-meta">#<span class="hljs-meta-keyword">define</span> eps 1e-8</span><span class="hljs-meta">#<span class="hljs-meta-keyword">define</span> INF 0x3f3f3f3f</span><span class="hljs-meta">#<span class="hljs-meta-keyword">define</span> rep(i,a,n) for(int i=a;i&lt;n;i++)</span><span class="hljs-meta">#<span class="hljs-meta-keyword">define</span> per(i,a,n) for(int i=n-1;i&gt;=a;i--)</span><span class="hljs-meta">#<span class="hljs-meta-keyword">define</span> all(x) x.begin(),x.end()</span><span class="hljs-meta">#<span class="hljs-meta-keyword">define</span> pb push_back</span><span class="hljs-meta">#<span class="hljs-meta-keyword">define</span> np next_permutation</span><span class="hljs-meta">#<span class="hljs-meta-keyword">define</span> ms(x,a) memset((x),(a),sizeof(x))</span><span class="hljs-comment">//优先队列迪杰斯特拉 </span><span class="hljs-keyword">const</span> <span class="hljs-keyword">int</span> maxn=<span class="hljs-number">1e5</span>+<span class="hljs-number">5</span>;<span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">Edge</span>&#123;</span><span class="hljs-keyword">int</span> u,v,w;Edge(<span class="hljs-keyword">int</span> _u,<span class="hljs-keyword">int</span> _v,<span class="hljs-keyword">int</span> _w):u(_u),v(_v),w(_w)&#123;&#125;;&#125;;<span class="hljs-built_in">vector</span> &lt;Edge&gt; edges[maxn];<span class="hljs-keyword">int</span> dis[maxn],meizi[maxn],mei[maxn];<span class="hljs-keyword">bool</span> vis[maxn];<span class="hljs-keyword">int</span> n,m,uu,vv,ww;<span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">init</span><span class="hljs-params">(<span class="hljs-keyword">int</span> n)</span></span>&#123; <span class="hljs-comment">//n个结点的边集都清空 </span>rep(i,<span class="hljs-number">0</span>,maxn)&#123;edges[i].clear();&#125;&#125;<span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">addEdge</span><span class="hljs-params">(<span class="hljs-keyword">int</span> u,<span class="hljs-keyword">int</span> v,<span class="hljs-keyword">int</span> w)</span></span>&#123;edges[u].pb(Edge(u,v,w));&#125;<span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">Node</span>&#123;</span><span class="hljs-keyword">int</span> Id,W;Node(<span class="hljs-keyword">int</span> _Id,<span class="hljs-keyword">int</span> _W):Id(_Id),W(_W)&#123;&#125;;<span class="hljs-keyword">bool</span> <span class="hljs-keyword">operator</span> &lt; (<span class="hljs-keyword">const</span> Node &amp;b) <span class="hljs-keyword">const</span> &#123;<span class="hljs-keyword">return</span> W&gt;b.W;<span class="hljs-comment">//else return Id&lt;b.Id;</span>&#125;&#125;;<span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">Dijkstra</span><span class="hljs-params">(<span class="hljs-keyword">int</span> s)</span></span>&#123;ms(vis,<span class="hljs-number">0</span>);ms(meizi,<span class="hljs-number">0</span>);ms(dis,INF);priority_queue &lt;Node&gt; q;q.push(Node(s,<span class="hljs-number">0</span>)) ;dis[s]=<span class="hljs-number">0</span>;meizi[s]=mei[s];<span class="hljs-keyword">while</span>(!q.empty())&#123;Node now=q.top();q.pop();<span class="hljs-keyword">int</span> index=now.Id;<span class="hljs-keyword">if</span>(vis[index]) <span class="hljs-keyword">continue</span>;<span class="hljs-comment">//if(index==end) return;</span>vis[index]=<span class="hljs-number">1</span>;rep(i,<span class="hljs-number">0</span>,edges[index].size())&#123;Edge temp=edges[index][i];<span class="hljs-keyword">if</span>(dis[temp.v]&gt;dis[index]+temp.w)&#123;dis[temp.v]=dis[index]+temp.w;meizi[temp.v]=meizi[index]+mei[temp.v];q.push(Node(temp.v,dis[temp.v]));&#125;<span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span>(dis[temp.v]==dis[index]+temp.w)&#123;<span class="hljs-keyword">if</span>(meizi[temp.v]&lt;meizi[index]+mei[temp.v])&#123;meizi[temp.v]=meizi[index]+mei[temp.v];q.push(Node(temp.v,dis[temp.v]));&#125;&#125;&#125;&#125;&#125;<span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span>&#123;ios::sync_with_stdio(<span class="hljs-literal">false</span>);<span class="hljs-keyword">while</span>(<span class="hljs-built_in">cin</span>&gt;&gt;n&gt;&gt;m)&#123;init(n);rep(i,<span class="hljs-number">1</span>,n+<span class="hljs-number">1</span>)&#123;<span class="hljs-built_in">cin</span>&gt;&gt;mei[i];&#125;rep(i,<span class="hljs-number">1</span>,m+<span class="hljs-number">1</span>)&#123;<span class="hljs-built_in">cin</span>&gt;&gt;uu&gt;&gt;vv&gt;&gt;ww;addEdge(uu,vv,ww);addEdge(vv,uu,ww);&#125; Dijkstra(<span class="hljs-number">1</span>);<span class="hljs-keyword">if</span>(dis[n]&gt;<span class="hljs-number">100000000</span>) <span class="hljs-built_in">cout</span>&lt;&lt;<span class="hljs-string">"-1"</span>&lt;&lt;<span class="hljs-built_in">endl</span>;<span class="hljs-keyword">else</span> <span class="hljs-built_in">cout</span>&lt;&lt;meizi[n]&lt;&lt;<span class="hljs-built_in">endl</span>;&#125; &#125;</code></pre><h1 id="收获与反思"><a href="#收获与反思" class="headerlink" title="收获与反思"></a>收获与反思</h1><ul><li>模板开始错了，少了return，WA了一晚上。</li></ul>]]></content>
    
    
    <categories>
      
      <category>Computer Science</category>
      
      <category>ACM</category>
      
      <category>CSU</category>
      
    </categories>
    
    
    <tags>
      
      <tag>ACM</tag>
      
      <tag>CSU</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>【CSU-1323】解题报告（字典树）</title>
    <link href="/post/677d0fef.html"/>
    <url>/post/677d0fef.html</url>
    
    <content type="html"><![CDATA[<h1 id="原始题目"><a href="#原始题目" class="headerlink" title="原始题目"></a>原始题目</h1><h2 id="1323-ZZY-and-his-little-friends"><a href="#1323-ZZY-and-his-little-friends" class="headerlink" title="1323: ZZY and his little friends"></a>1323: ZZY and his little friends</h2><ul><li>Time Limit: 5 Sec     </li><li>Memory Limit: 256 Mb     </li><li>Submitted: 708     </li><li>Solved: 258    </li></ul><h3 id="Description"><a href="#Description" class="headerlink" title="Description"></a>Description</h3><p>zzy养了一只小怪兽和N只凹凸曼，单挑的话每只凹凸曼都不是小怪兽的对手，<br>所以必须由两只凹凸曼合作来和小怪兽战斗。凹凸曼A和凹凸曼B合作的战斗力为他们战斗力的异或值。<br>现在由zzy从N只凹凸曼中选出两只来和小怪兽战斗。</p><p>请问zzy能否选出两只凹凸曼使他们能够战胜小怪兽(他们的战斗力比小怪兽大)。</p><a id="more"></a><h3 id="Input"><a href="#Input" class="headerlink" title="Input"></a>Input</h3><p>输入有多个例子，直到文件结束。 每个例子的第一行含两个数N和M，表示有 $ N ( 2 \le N \le 10^5 )$只凹凸曼，小怪兽的战斗力为$ M (0 &lt; M \le 10^9 )$。接着有一行N个数，每个数 $ A_i ( 0 &lt; A_i &lt; M )$表示每只凹凸曼的战斗力。</p><h3 id="Output"><a href="#Output" class="headerlink" title="Output"></a>Output</h3><p>对于每个例子输出一行，如果能选出两只凹凸曼使他们战胜小怪兽输出”YES”, 否则输出”NO”(不含引号)</p><h3 id="Sample-Input"><a href="#Sample-Input" class="headerlink" title="Sample Input"></a>Sample Input</h3><pre><code>2 51 12 65 2</code></pre><h3 id="Sample-Output"><a href="#Sample-Output" class="headerlink" title="Sample Output"></a>Sample Output</h3><pre><code>NOYES</code></pre><h3 id="Author"><a href="#Author" class="headerlink" title="Author"></a>Author</h3><p> CSU_CX</p><h3 id="Source"><a href="#Source" class="headerlink" title="Source"></a>Source</h3><p>CSU Monthly 2013 Oct.</p><h1 id="题目大意"><a href="#题目大意" class="headerlink" title="题目大意"></a>题目大意</h1><p>如题</p><h1 id="解题思路"><a href="#解题思路" class="headerlink" title="解题思路"></a>解题思路</h1><p>01字典树，将数字转换为32位的01数字串（高位在前）储存到树中。然后扫一遍求异最大值，与题目给定的$M$比较。</p><h1 id="接替代码"><a href="#接替代码" class="headerlink" title="接替代码"></a>接替代码</h1><pre><code class="hljs C++"><span class="hljs-meta">#<span class="hljs-meta-keyword">include</span> <span class="hljs-meta-string">&lt;cstdio&gt;</span></span><span class="hljs-meta">#<span class="hljs-meta-keyword">include</span> <span class="hljs-meta-string">&lt;cstring&gt;</span></span><span class="hljs-meta">#<span class="hljs-meta-keyword">include</span> <span class="hljs-meta-string">&lt;cmath&gt;</span></span><span class="hljs-meta">#<span class="hljs-meta-keyword">include</span> <span class="hljs-meta-string">&lt;set&gt;</span></span><span class="hljs-meta">#<span class="hljs-meta-keyword">include</span> <span class="hljs-meta-string">&lt;queue&gt;</span></span><span class="hljs-meta">#<span class="hljs-meta-keyword">include</span> <span class="hljs-meta-string">&lt;map&gt;</span></span><span class="hljs-meta">#<span class="hljs-meta-keyword">include</span> <span class="hljs-meta-string">&lt;set&gt;</span></span><span class="hljs-meta">#<span class="hljs-meta-keyword">include</span> <span class="hljs-meta-string">&lt;string&gt;</span></span><span class="hljs-meta">#<span class="hljs-meta-keyword">include</span> <span class="hljs-meta-string">&lt;iostream&gt;</span></span><span class="hljs-meta">#<span class="hljs-meta-keyword">include</span> <span class="hljs-meta-string">&lt;iomanip&gt;</span></span><span class="hljs-meta">#<span class="hljs-meta-keyword">include</span> <span class="hljs-meta-string">&lt;stack&gt;</span></span><span class="hljs-meta">#<span class="hljs-meta-keyword">define</span> rep(i,a,n) for(int i=a ; i&lt;n;++i)</span><span class="hljs-meta">#<span class="hljs-meta-keyword">define</span> per(i,a,n) for(int i=n-1;i&gt;=a;--i)</span><span class="hljs-meta">#<span class="hljs-meta-keyword">define</span> fi first</span><span class="hljs-meta">#<span class="hljs-meta-keyword">define</span> se second</span><span class="hljs-meta">#<span class="hljs-meta-keyword">define</span> cl(x,a) memset(x,a,sizeof(x)) </span><span class="hljs-meta">#<span class="hljs-meta-keyword">define</span> all(x) x.begin(),x.end()</span><span class="hljs-meta">#<span class="hljs-meta-keyword">define</span> insert(x) x,x.begin()</span><span class="hljs-meta">#<span class="hljs-meta-keyword">define</span> debug printf(<span class="hljs-meta-string">"======================\n"</span>);</span><span class="hljs-meta">#<span class="hljs-meta-keyword">define</span> mp make_pair</span><span class="hljs-meta">#<span class="hljs-meta-keyword">define</span> np next_permutation</span><span class="hljs-meta">#<span class="hljs-meta-keyword">define</span> pb push_back</span><span class="hljs-meta">#<span class="hljs-meta-keyword">define</span> INF 0x3f3f3f3f</span><span class="hljs-meta">#<span class="hljs-meta-keyword">define</span> eps 1e-8</span><span class="hljs-keyword">using</span> <span class="hljs-keyword">namespace</span> <span class="hljs-built_in">std</span>;<span class="hljs-keyword">const</span> <span class="hljs-keyword">int</span> maxn=<span class="hljs-number">1e5</span>+<span class="hljs-number">5</span>;<span class="hljs-keyword">const</span> <span class="hljs-keyword">int</span> maxm=<span class="hljs-number">1e5</span>+<span class="hljs-number">5</span>;<span class="hljs-keyword">const</span> <span class="hljs-keyword">int</span> maxl=<span class="hljs-number">2</span>;<span class="hljs-keyword">const</span> <span class="hljs-keyword">int</span> K=<span class="hljs-number">32</span>;<span class="hljs-keyword">typedef</span> <span class="hljs-keyword">long</span> <span class="hljs-keyword">long</span> ll;<span class="hljs-keyword">typedef</span> <span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">Trie</span>&#123;</span><span class="hljs-keyword">int</span> v;Trie* next[maxl];&#125;Trie;Trie *root;<span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">iniTrie</span><span class="hljs-params">()</span></span>&#123;root=(Trie*) <span class="hljs-built_in">malloc</span>(<span class="hljs-keyword">sizeof</span>(Trie));rep(i,<span class="hljs-number">0</span>,maxl) root-&gt;next[i]=<span class="hljs-literal">NULL</span>;root-&gt;v=<span class="hljs-number">-1</span>; &#125;<span class="hljs-function"><span class="hljs-keyword">bool</span> <span class="hljs-title">creTrie</span><span class="hljs-params">(<span class="hljs-keyword">int</span> a)</span></span>&#123;<span class="hljs-comment">//预处理整数为01数组 </span><span class="hljs-keyword">int</span> temp[<span class="hljs-number">35</span>];<span class="hljs-keyword">int</span> id=K<span class="hljs-number">-1</span>;<span class="hljs-keyword">while</span>(a)&#123;temp[id--]=(a&amp;<span class="hljs-number">1</span>);a&gt;&gt;=<span class="hljs-number">1</span>;&#125;rep(i,<span class="hljs-number">0</span>,id+<span class="hljs-number">1</span>) temp[i]=<span class="hljs-number">0</span>;<span class="hljs-keyword">int</span> l=K;Trie *p=root,*q;rep(i,<span class="hljs-number">0</span>,l)&#123;<span class="hljs-keyword">int</span> id=temp[i];<span class="hljs-keyword">if</span>(p-&gt;next[id]!=<span class="hljs-literal">NULL</span>)&#123;p=p-&gt;next[id];&#125; <span class="hljs-keyword">else</span> &#123;q=(Trie*) <span class="hljs-built_in">malloc</span>(<span class="hljs-keyword">sizeof</span>(Trie));q-&gt;v=<span class="hljs-number">1</span>;  <span class="hljs-comment">//新建节点染色</span><span class="hljs-keyword">for</span>(<span class="hljs-keyword">int</span> j=<span class="hljs-number">0</span>;j&lt;maxl;j++) q-&gt;next[j]=<span class="hljs-literal">NULL</span>;p-&gt;next[id]=q;p=p-&gt;next[id]; &#125;&#125;  &#125;<span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">findTrie</span><span class="hljs-params">(<span class="hljs-keyword">int</span> a)</span></span>&#123;<span class="hljs-keyword">int</span> aa=a;<span class="hljs-keyword">int</span> temp[<span class="hljs-number">35</span>];<span class="hljs-keyword">int</span> id=K<span class="hljs-number">-1</span>;<span class="hljs-keyword">while</span>(a)&#123;temp[id--]=(a&amp;<span class="hljs-number">1</span>);a&gt;&gt;=<span class="hljs-number">1</span>;&#125;rep(i,<span class="hljs-number">0</span>,id+<span class="hljs-number">1</span>) temp[i]=<span class="hljs-number">0</span>;  <span class="hljs-comment">//前面位置补0</span><span class="hljs-keyword">int</span> aans=<span class="hljs-number">0</span>;Trie *p=root;<span class="hljs-keyword">int</span> l=K;<span class="hljs-keyword">for</span>(<span class="hljs-keyword">int</span> i=<span class="hljs-number">0</span>;i&lt;l;i++)&#123;<span class="hljs-keyword">int</span> index= !temp[i];<span class="hljs-keyword">if</span>(p-&gt;next[index] !=<span class="hljs-literal">NULL</span> )&#123;aans=(aans&lt;&lt;<span class="hljs-number">1</span>)+index;p=p-&gt;next[index];&#125;<span class="hljs-keyword">else</span> &#123;aans=(aans&lt;&lt;<span class="hljs-number">1</span>)+temp[i];p=p-&gt;next[temp[i]];&#125;&#125; <span class="hljs-keyword">return</span> aans^aa;&#125;<span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">delTrie</span><span class="hljs-params">(Trie *p)</span></span>&#123;<span class="hljs-keyword">int</span> i;<span class="hljs-keyword">for</span>(<span class="hljs-keyword">int</span> i=<span class="hljs-number">0</span>;i&lt;maxl;i++)&#123;<span class="hljs-keyword">if</span>(p-&gt;next[i]!= <span class="hljs-literal">NULL</span>)delTrie(p-&gt;next[i]);&#125;<span class="hljs-built_in">free</span>(p);p=<span class="hljs-literal">NULL</span>;<span class="hljs-keyword">return</span> ;&#125;<span class="hljs-keyword">int</span> a[maxn],n,m;<span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span>&#123;ios::sync_with_stdio(<span class="hljs-literal">false</span>);<span class="hljs-keyword">while</span>(<span class="hljs-built_in">cin</span>&gt;&gt;n&gt;&gt;m)&#123;iniTrie();rep(i,<span class="hljs-number">0</span>,n)&#123;<span class="hljs-built_in">cin</span>&gt;&gt;a[i];creTrie(a[i]);&#125;<span class="hljs-keyword">int</span> fans=<span class="hljs-number">0</span>;rep(i,<span class="hljs-number">0</span>,n)&#123;fans=max(fans,findTrie(a[i]));&#125;<span class="hljs-keyword">if</span>(fans&gt;m) <span class="hljs-built_in">cout</span>&lt;&lt;<span class="hljs-string">"YES"</span>&lt;&lt;<span class="hljs-built_in">endl</span>;<span class="hljs-keyword">else</span> <span class="hljs-built_in">cout</span>&lt;&lt;<span class="hljs-string">"NO"</span>&lt;&lt;<span class="hljs-built_in">endl</span>;&#125; &#125;</code></pre><h1 id="收获与反思"><a href="#收获与反思" class="headerlink" title="收获与反思"></a>收获与反思</h1><p>熟悉求异或最大值01字典树的操作。</p>]]></content>
    
    
    <categories>
      
      <category>Computer Science</category>
      
      <category>ACM</category>
      
      <category>CSU</category>
      
    </categories>
    
    
    <tags>
      
      <tag>ACM</tag>
      
      <tag>CSU</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>【CSU-1330】解题报告（水题，字符串）</title>
    <link href="/post/bba462fb.html"/>
    <url>/post/bba462fb.html</url>
    
    <content type="html"><![CDATA[<h1 id="原始题目"><a href="#原始题目" class="headerlink" title="原始题目"></a>原始题目</h1><h2 id="1330-字符识别？"><a href="#1330-字符识别？" class="headerlink" title="1330: 字符识别？"></a>1330: 字符识别？</h2><ul><li>Time Limit: 1 Sec     </li><li>Memory Limit: 128 Mb     </li><li>Submitted: 885     </li><li>Solved: 595    </li></ul><h3 id="Description"><a href="#Description" class="headerlink" title="Description"></a>Description</h3><p>你的任务是写一个程序进行字符识别。别担心，你只需要识别1, 2, 3，如下：</p><pre><code>.*.  ***  ***.*.  ..*  ..*.*.  ***  ***.*.  *..  ..*.*.  ***  ***</code></pre><a id="more"></a><h3 id="Input"><a href="#Input" class="headerlink" title="Input"></a>Input</h3><p>输入仅包含一组数据，由$6$行组成。第一行为字符的个数 $n ( 1 \le n \le 10)$。以下$5$行每行包含$4n$个字符。每个字符恰好占$5$行$3$列，然后是一个空列（用”.”填充）。</p><h3 id="Output"><a href="#Output" class="headerlink" title="Output"></a>Output</h3><p>输出应包含一行，即识别出的各个字符。</p><h3 id="Sample-Input"><a href="#Sample-Input" class="headerlink" title="Sample Input"></a>Sample Input</h3><pre><code>3.*..***.***..*....*...*..*..***.***..*..*.....*..*..***.***.</code></pre><h3 id="Sample-Output"><a href="#Sample-Output" class="headerlink" title="Sample Output"></a>Sample Output</h3><pre><code>123</code></pre><h3 id="Hint"><a href="#Hint" class="headerlink" title="Hint"></a>Hint</h3><h3 id="Source"><a href="#Source" class="headerlink" title="Source"></a>Source</h3><p>湖南省第九届大学生计算机程序设计竞赛</p><h1 id="题目大意"><a href="#题目大意" class="headerlink" title="题目大意"></a>题目大意</h1><p>将一个五行宽的字符串替换成所代表的1，2，3。</p><h1 id="解题思路"><a href="#解题思路" class="headerlink" title="解题思路"></a>解题思路</h1><p>水题，字符串判断一下特征字符区间即可。</p><h1 id="解题代码"><a href="#解题代码" class="headerlink" title="解题代码"></a>解题代码</h1><pre><code class="hljs C++"><span class="hljs-meta">#<span class="hljs-meta-keyword">include</span> <span class="hljs-meta-string">&lt;cstdio&gt;</span></span><span class="hljs-meta">#<span class="hljs-meta-keyword">include</span> <span class="hljs-meta-string">&lt;cstring&gt;</span></span><span class="hljs-meta">#<span class="hljs-meta-keyword">include</span> <span class="hljs-meta-string">&lt;cmath&gt;</span></span><span class="hljs-meta">#<span class="hljs-meta-keyword">include</span> <span class="hljs-meta-string">&lt;set&gt;</span></span><span class="hljs-meta">#<span class="hljs-meta-keyword">include</span> <span class="hljs-meta-string">&lt;queue&gt;</span></span><span class="hljs-meta">#<span class="hljs-meta-keyword">include</span> <span class="hljs-meta-string">&lt;map&gt;</span></span><span class="hljs-meta">#<span class="hljs-meta-keyword">include</span> <span class="hljs-meta-string">&lt;set&gt;</span></span><span class="hljs-meta">#<span class="hljs-meta-keyword">include</span> <span class="hljs-meta-string">&lt;string&gt;</span></span><span class="hljs-meta">#<span class="hljs-meta-keyword">include</span> <span class="hljs-meta-string">&lt;iostream&gt;</span></span><span class="hljs-meta">#<span class="hljs-meta-keyword">include</span> <span class="hljs-meta-string">&lt;iomanip&gt;</span></span><span class="hljs-meta">#<span class="hljs-meta-keyword">include</span> <span class="hljs-meta-string">&lt;stack&gt;</span></span><span class="hljs-meta">#<span class="hljs-meta-keyword">define</span> rep(i,a,n) for(int i=a ; i&lt;n;++i)</span><span class="hljs-meta">#<span class="hljs-meta-keyword">define</span> per(i,a,n) for(int i=n-1;i&gt;=a;--i)</span><span class="hljs-meta">#<span class="hljs-meta-keyword">define</span> fi first</span><span class="hljs-meta">#<span class="hljs-meta-keyword">define</span> se second</span><span class="hljs-meta">#<span class="hljs-meta-keyword">define</span> cl(x,a) memset(x,a,sizeof(x)) </span><span class="hljs-meta">#<span class="hljs-meta-keyword">define</span> all(x) x.begin(),x.end()</span><span class="hljs-meta">#<span class="hljs-meta-keyword">define</span> insert(x) x,x.begin()</span><span class="hljs-meta">#<span class="hljs-meta-keyword">define</span> debug printf(<span class="hljs-meta-string">"======================\n"</span>);</span><span class="hljs-meta">#<span class="hljs-meta-keyword">define</span> mp make_pair</span><span class="hljs-meta">#<span class="hljs-meta-keyword">define</span> np next_permutation</span><span class="hljs-meta">#<span class="hljs-meta-keyword">define</span> pb push_back</span><span class="hljs-meta">#<span class="hljs-meta-keyword">define</span> INF 0x3f3f3f3f</span><span class="hljs-meta">#<span class="hljs-meta-keyword">define</span> eps 1e-8</span><span class="hljs-keyword">using</span> <span class="hljs-keyword">namespace</span> <span class="hljs-built_in">std</span>;<span class="hljs-keyword">const</span> <span class="hljs-keyword">int</span> maxn=<span class="hljs-number">1e5</span>+<span class="hljs-number">5</span>;<span class="hljs-keyword">const</span> <span class="hljs-keyword">int</span> maxm=<span class="hljs-number">1e5</span>+<span class="hljs-number">5</span>;<span class="hljs-keyword">const</span> <span class="hljs-keyword">int</span> maxl=<span class="hljs-number">2</span>;<span class="hljs-keyword">const</span> <span class="hljs-keyword">int</span> K=<span class="hljs-number">32</span>;<span class="hljs-built_in">string</span> word[<span class="hljs-number">5</span>]; <span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span>&#123;ios::sync_with_stdio(<span class="hljs-literal">false</span>);<span class="hljs-keyword">int</span> n;<span class="hljs-keyword">while</span>(<span class="hljs-built_in">cin</span>&gt;&gt;n)&#123;rep(i,<span class="hljs-number">0</span>,<span class="hljs-number">5</span>) <span class="hljs-built_in">cin</span>&gt;&gt;word[i];rep(i,<span class="hljs-number">0</span>,n)&#123;<span class="hljs-keyword">int</span> ii=i*<span class="hljs-number">4</span>;<span class="hljs-keyword">if</span>(word[<span class="hljs-number">2</span>][ii]==<span class="hljs-string">'.'</span> &amp;&amp; word[<span class="hljs-number">2</span>][ii+<span class="hljs-number">1</span>]==<span class="hljs-string">'*'</span> &amp;&amp; word[<span class="hljs-number">2</span>][ii+<span class="hljs-number">2</span>]==<span class="hljs-string">'.'</span>) <span class="hljs-built_in">cout</span>&lt;&lt;<span class="hljs-number">1</span>;<span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span>(word[<span class="hljs-number">3</span>][ii]==<span class="hljs-string">'*'</span> &amp;&amp; word[<span class="hljs-number">3</span>][ii+<span class="hljs-number">1</span>]==<span class="hljs-string">'.'</span> &amp;&amp; word[<span class="hljs-number">3</span>][ii+<span class="hljs-number">2</span>]==<span class="hljs-string">'.'</span>) <span class="hljs-built_in">cout</span>&lt;&lt;<span class="hljs-number">2</span>;<span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span>(word[<span class="hljs-number">3</span>][ii]==<span class="hljs-string">'.'</span> &amp;&amp; word[<span class="hljs-number">3</span>][ii+<span class="hljs-number">1</span>]==<span class="hljs-string">'.'</span> &amp;&amp; word[<span class="hljs-number">3</span>][ii+<span class="hljs-number">2</span>]==<span class="hljs-string">'*'</span>) <span class="hljs-built_in">cout</span>&lt;&lt;<span class="hljs-number">3</span>;       &#125;<span class="hljs-built_in">cout</span>&lt;&lt;<span class="hljs-built_in">endl</span>;&#125;&#125;</code></pre><h1 id="收获与反思"><a href="#收获与反思" class="headerlink" title="收获与反思"></a>收获与反思</h1><p>无</p>]]></content>
    
    
    <categories>
      
      <category>Computer Science</category>
      
      <category>ACM</category>
      
      <category>CSU</category>
      
    </categories>
    
    
    <tags>
      
      <tag>ACM</tag>
      
      <tag>CSU</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>【CSU-1340】结题报告（水题）</title>
    <link href="/post/6ca1eed5.html"/>
    <url>/post/6ca1eed5.html</url>
    
    <content type="html"><![CDATA[<h1 id="原始题目"><a href="#原始题目" class="headerlink" title="原始题目"></a>原始题目</h1><h2 id="1340-A-Sample-Problem"><a href="#1340-A-Sample-Problem" class="headerlink" title="1340: A Sample Problem"></a>1340: A Sample Problem</h2><ul><li>Time Limit: 1 Sec     </li><li>Memory Limit: 128 Mb     </li><li>Submitted: 706     </li><li>Solved: 322    </li></ul><h3 id="Description"><a href="#Description" class="headerlink" title="Description"></a>Description</h3><p>My girlfriend loves 7 very much, she thinks it is lucky! If an integer contains one or more 7, she will think it is lucky too!</p><a id="more"></a><h3 id="Input"><a href="#Input" class="headerlink" title="Input"></a>Input</h3><p>The first line has one integer $T (1 \le T \le 100)$, means there are T test cases.</p><p>For each test case, there is only one line with an integer $X (1 \le X \le  10^{9} )$.</p><h3 id="Output"><a href="#Output" class="headerlink" title="Output"></a>Output</h3><p>For each test case, if X contains one or more 7, output “Lucky” (without quotation marks), otherwise output “Unlucky” (without quotation marks).</p><h3 id="Sample-Input"><a href="#Sample-Input" class="headerlink" title="Sample Input"></a>Sample Input</h3><pre><code>471156817171</code></pre><h3 id="Sample-Output"><a href="#Sample-Output" class="headerlink" title="Sample Output"></a>Sample Output</h3><pre><code>LuckyUnluckyUnluckyLucky</code></pre><h3 id="Hint"><a href="#Hint" class="headerlink" title="Hint"></a>Hint</h3><p>我们主要通过这个题目来感受一下一个完整的ACM竞赛的题目应当是什么样的。</p><p>ACM竞赛题目本身的“格式” 很明显：    </p><ul><li><p>第一部分是对题目的描述，会交待题目的背景，以及你需要编程完成哪些任务等等。</p></li><li><p>第二部分是对输入的约定，会告诉你题目是否有多组测试数据，每组测试数据的格式，每个参数的类型（整数，浮点数，字符串等）以及取值范围等等。</p></li><li><p>第三部分是对输出的约定，也就是你的程序应当输出哪些内容以及具体的格式是什么。</p></li><li><p>第四部分是一些样例，这些例子只是向你展示一部分测试数据以及对应的答案，目的是更好地帮助你理解题意，以及了解对输出格式的要求等。</p></li></ul><p>大家也许会和我当初刚接触ACM时一样心中充满了疑问，在这里我就为大家列举几个常见的问题：</p><ol><li><p><strong>如果题目有多组数据，我们是不是也要像样例那样把所有的结果先都计算出来，然后再一起输出？</strong></p><p> 这个是没必要的，你完全可以每处理完一组数据之后就立刻将这组数据对应的结果输出出来。<br> 但如果你是手动去敲这些样例的话，你会发现在屏幕上输入和输出是混在一起的，并不像样例那样输入和输出是分离的，这样会不会不符合要求呢？那么请看<2>，相信你的疑问就会被解答了。</2></p></li><li><p><strong>OJ (Online Judge)怎么知道我的程序是不是写对了？</strong><br> OJ并不会去智能化地分析你的代码正确与否，而是用另一种巧妙的思路来判断你的程序是否符合要求：“喂”给你的程序一些输入数据（就像你在键盘上敲一些东西后敲回车一样），之后再将你的程序“产出”的东西（就像你在屏幕上看到的你的程序输出的东西一样）和标准的答案进行对比，如果你的程序得到的答案和标准的答案一模一样，那么就算你通过了这个题目。<br> 因此，即使你手动输入样例时屏幕上的输入和输出是混在一起也没关系，只要你的程序“产出”的东西和标准答案一模一样就可以了。<br> 也正是这种评判机制的关系，你不应当让程序打印一些提示语句，如“Please input two integers”等等，因为凡是你的程序输出的内容都会被拿来和标准答案进行对比，一旦输出了类似这样的题目没有要求输出的语句，就会和标准答案大相径庭了，自然就会认为你的程序是不正确的了。<br> 值得一提的是，尽管这样的评判机制似乎并不能完美地知道你的程序究竟是不是对的（想想看为什么？），不过如果测试数据足够强大的话，“你的程序是对的”的概率就会很高很高了。</p></li><li><p><strong>为什么我的程序通过了所有的样例，但是最后还是过不了这个题目？</strong></p><p> 题目的样例只是一小部分测试数据，目的是为了更好地帮助你理解题意，以及了解对输出格式的要求等，因此通过了样例并不能够代表能通过所有的测试数据。只有通过了所有的测试数据才能得到“Accept”，也就是通过了这个题目。</p></li><li><p><strong>每组测试数据的答案输出完之后，是否都要换行？</strong></p><p> 是的，即使题目里面没有明确说明，我们也应该在每组测试数据的答案输出完之后再输出一个“换行”（也就是“\n”），就像样例示意的那样。</p></li></ol><p>接下来我们谈谈这个题目的思路吧，相信大家应该都想到算法了：只要依次判断读入的整数的每一位是否是7就可以了。如果觉得代码写起来会有困难的话，可以参考一下我在下面给出的示例代码，不过最后一定要按自己的思路写一个完整的代码（编写自己的代码时就不要再参考示例代码了，要一气呵成~）并获得“Accept”哟！O(∩_∩)O~</p><h3 id="Source"><a href="#Source" class="headerlink" title="Source"></a>Source</h3><p>ACM入门示例（第一季）</p><h1 id="题目大意"><a href="#题目大意" class="headerlink" title="题目大意"></a>题目大意</h1><p>如题</p><h1 id="解题思路"><a href="#解题思路" class="headerlink" title="解题思路"></a>解题思路</h1><p>水题</p><h1 id="解题代码"><a href="#解题代码" class="headerlink" title="解题代码"></a>解题代码</h1><pre><code class="hljs C++"><span class="hljs-meta">#<span class="hljs-meta-keyword">include</span> <span class="hljs-meta-string">&lt;cstdio&gt;</span></span><span class="hljs-meta">#<span class="hljs-meta-keyword">include</span> <span class="hljs-meta-string">&lt;cstring&gt;</span></span><span class="hljs-meta">#<span class="hljs-meta-keyword">include</span> <span class="hljs-meta-string">&lt;iostream&gt;</span></span><span class="hljs-meta">#<span class="hljs-meta-keyword">include</span> <span class="hljs-meta-string">&lt;set&gt;</span></span><span class="hljs-meta">#<span class="hljs-meta-keyword">include</span> <span class="hljs-meta-string">&lt;queue&gt;</span></span><span class="hljs-meta">#<span class="hljs-meta-keyword">include</span> <span class="hljs-meta-string">&lt;algorithm&gt;</span></span><span class="hljs-meta">#<span class="hljs-meta-keyword">define</span> INF 0x3f3f3f3f</span><span class="hljs-meta">#<span class="hljs-meta-keyword">define</span> rep(i,a,n) for(int i=a;i&lt;n;++i)</span><span class="hljs-meta">#<span class="hljs-meta-keyword">define</span> per(i,a,n) for(int i=n-1;i&gt;=a;--i)</span><span class="hljs-keyword">using</span> <span class="hljs-keyword">namespace</span> <span class="hljs-built_in">std</span>;<span class="hljs-keyword">const</span> <span class="hljs-keyword">int</span> maxn=<span class="hljs-number">1e5</span>+<span class="hljs-number">5</span>;<span class="hljs-keyword">typedef</span> <span class="hljs-keyword">long</span> <span class="hljs-keyword">long</span> ll;ll t,n,m;<span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span>&#123;<span class="hljs-built_in">scanf</span>(<span class="hljs-string">"%lld"</span>,&amp;t);<span class="hljs-keyword">while</span>(t--)&#123;<span class="hljs-built_in">scanf</span>(<span class="hljs-string">"%lld"</span>,&amp;n);<span class="hljs-keyword">int</span> flag=<span class="hljs-number">0</span>;<span class="hljs-keyword">while</span>(n)&#123;<span class="hljs-keyword">if</span>(n%<span class="hljs-number">10</span>==<span class="hljs-number">7</span>)&#123;<span class="hljs-comment">//printf("now=%d\n",n);</span>flag=<span class="hljs-number">1</span>;<span class="hljs-keyword">break</span>;&#125;n/=<span class="hljs-number">10</span>;&#125;<span class="hljs-keyword">if</span>(flag) <span class="hljs-built_in">printf</span>(<span class="hljs-string">"Lucky\n"</span>);<span class="hljs-keyword">else</span> <span class="hljs-built_in">printf</span>(<span class="hljs-string">"Unlucky\n"</span>);&#125;&#125;</code></pre><h1 id="收获与反思"><a href="#收获与反思" class="headerlink" title="收获与反思"></a>收获与反思</h1><p>无</p>]]></content>
    
    
    <categories>
      
      <category>Computer Science</category>
      
      <category>ACM</category>
      
      <category>CSU</category>
      
    </categories>
    
    
    <tags>
      
      <tag>ACM</tag>
      
      <tag>CSU</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>【CSU-2158】解题报告（水题）</title>
    <link href="/post/aa0a97c8.html"/>
    <url>/post/aa0a97c8.html</url>
    
    <content type="html"><![CDATA[<h1 id="原始题目"><a href="#原始题目" class="headerlink" title="原始题目"></a>原始题目</h1><h2 id="2158-长门的运动会"><a href="#2158-长门的运动会" class="headerlink" title="2158: 长门的运动会"></a>2158: 长门的运动会</h2><ul><li>Time Limit: 1 Sec</li><li>Memory Limit: 128 Mb</li><li>Submitted: 2</li><li>Solved: 2</li><li>SpecialJudge</li></ul><h3 id="Description"><a href="#Description" class="headerlink" title="Description"></a>Description</h3><p>运动会，好开心~</p><p>CSU (California State University) 正在举行一场特殊的接力跑比赛，比赛在环形跑道上进行，同一支队伍的所有人从同一个位置向相同的方向出发，当需要接力的两个人再次相遇时，他们就要交接棒。最后总成绩是以队伍跑的总路程计算的</p><p><img src="https://eddyblog.oss-cn-shenzhen.aliyuncs.com/%E3%80%90CSU-2158%E3%80%91%E8%A7%A3%E9%A2%98%E6%8A%A5%E5%91%8A%EF%BC%88%E6%B0%B4%E9%A2%98%EF%BC%89/1.png" srcset="/img/loading.gif" alt="1.png"></p><p>现在接力的第一棒在Nagato手中，需要把它交给Kyon。在长度为C的环形跑道上，他们出发了！Nagato以速度A匀速跑动，Kyon以速度B匀速跑动。他们在经过多长时间后可以再次相遇？</p><a id="more"></a><h3 id="Input"><a href="#Input" class="headerlink" title="Input"></a>Input</h3><p>多组数据，第一行为一个整数T (1 ≤ T ≤ 106)，表示数据组数。</p><p>之后每行是一组数据，有三个整数C, A, B (1 ≤ C, A, B ≤ 109, A ≠ B)，分别表示环形跑道的长度，Nagato的速度和Kyon的速度。</p><h3 id="Output"><a href="#Output" class="headerlink" title="Output"></a>Output</h3><p>每行输出一个数，表示再次相遇所需的时间。绝对误差或相对误差小于10−5则认为是正确的。</p><h3 id="Sample-Input"><a href="#Sample-Input" class="headerlink" title="Sample Input"></a>Sample Input</h3><pre><code>23 1 25 10 7</code></pre><h3 id="Sample-Output"><a href="#Sample-Output" class="headerlink" title="Sample Output"></a>Sample Output</h3><pre><code>3.000000001.66666667</code></pre><h3 id="Hint"><a href="#Hint" class="headerlink" title="Hint"></a>Hint</h3><h3 id="Source"><a href="#Source" class="headerlink" title="Source"></a>Source</h3><h3 id="Author"><a href="#Author" class="headerlink" title="Author"></a>Author</h3><p>Yuki Nagato</p><h1 id="题目大意"><a href="#题目大意" class="headerlink" title="题目大意"></a>题目大意</h1><p>如题</p><h1 id="解题思路"><a href="#解题思路" class="headerlink" title="解题思路"></a>解题思路</h1><p>水题，追击运动一圈</p><h1 id="解题代码"><a href="#解题代码" class="headerlink" title="解题代码"></a>解题代码</h1><pre><code class="hljs C++"><span class="hljs-meta">#<span class="hljs-meta-keyword">include</span> <span class="hljs-meta-string">&lt;cstdio&gt;</span></span><span class="hljs-meta">#<span class="hljs-meta-keyword">include</span> <span class="hljs-meta-string">&lt;cstring&gt;</span></span><span class="hljs-meta">#<span class="hljs-meta-keyword">include</span> <span class="hljs-meta-string">&lt;iostream&gt;</span></span><span class="hljs-meta">#<span class="hljs-meta-keyword">include</span> <span class="hljs-meta-string">&lt;iomanip&gt;</span></span><span class="hljs-meta">#<span class="hljs-meta-keyword">include</span> <span class="hljs-meta-string">&lt;cmath&gt;</span></span><span class="hljs-meta">#<span class="hljs-meta-keyword">include</span> <span class="hljs-meta-string">&lt;sstream&gt;</span></span><span class="hljs-meta">#<span class="hljs-meta-keyword">include</span> <span class="hljs-meta-string">&lt;set&gt;</span></span><span class="hljs-meta">#<span class="hljs-meta-keyword">include</span> <span class="hljs-meta-string">&lt;vector&gt;</span></span><span class="hljs-meta">#<span class="hljs-meta-keyword">include</span> <span class="hljs-meta-string">&lt;stack&gt;</span></span><span class="hljs-meta">#<span class="hljs-meta-keyword">include</span> <span class="hljs-meta-string">&lt;queue&gt;</span></span><span class="hljs-meta">#<span class="hljs-meta-keyword">include</span> <span class="hljs-meta-string">&lt;map&gt;</span></span><span class="hljs-meta">#<span class="hljs-meta-keyword">include</span> <span class="hljs-meta-string">&lt;algorithm&gt;</span></span><span class="hljs-meta">#<span class="hljs-meta-keyword">define</span> rep(i,a,n) for(int i=a;i&lt;n;++i) </span><span class="hljs-meta">#<span class="hljs-meta-keyword">define</span> per(i,a,n) for(int i=n-1;i&gt;=a;--i)</span><span class="hljs-meta">#<span class="hljs-meta-keyword">define</span> ms(x,a) memset((x),a,sizeof(x))</span><span class="hljs-meta">#<span class="hljs-meta-keyword">define</span> pb push_back</span><span class="hljs-meta">#<span class="hljs-meta-keyword">define</span> np next_permutation</span><span class="hljs-meta">#<span class="hljs-meta-keyword">define</span> mp make_pair</span><span class="hljs-meta">#<span class="hljs-meta-keyword">define</span> INF 0x3f3f3f3f</span><span class="hljs-meta">#<span class="hljs-meta-keyword">define</span> eps 1e-8</span><span class="hljs-meta">#<span class="hljs-meta-keyword">define</span> all(x) x.begin(),x.end()</span><span class="hljs-meta">#<span class="hljs-meta-keyword">define</span> ins(x) inserter(x,x.begin())</span><span class="hljs-meta">#<span class="hljs-meta-keyword">define</span> mod 1000000005</span><span class="hljs-meta">#<span class="hljs-meta-keyword">define</span> K 20</span><span class="hljs-keyword">using</span> <span class="hljs-keyword">namespace</span> <span class="hljs-built_in">std</span>;<span class="hljs-keyword">const</span> <span class="hljs-keyword">int</span> maxn=<span class="hljs-number">1e2</span>+<span class="hljs-number">5</span>;<span class="hljs-keyword">const</span> <span class="hljs-keyword">int</span> maxl=<span class="hljs-number">26</span>;<span class="hljs-keyword">const</span> <span class="hljs-keyword">int</span> maxm=<span class="hljs-number">1e5</span>+<span class="hljs-number">5</span>;<span class="hljs-keyword">typedef</span> <span class="hljs-keyword">long</span> <span class="hljs-keyword">long</span> ll;ll t,n,a;<span class="hljs-keyword">int</span> c[K];<span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span>&#123;<span class="hljs-built_in">scanf</span>(<span class="hljs-string">"%lld"</span>,&amp;t);<span class="hljs-keyword">while</span>(t--)&#123;<span class="hljs-keyword">int</span> a,b,c;<span class="hljs-built_in">scanf</span>(<span class="hljs-string">"%d%d%d"</span>,&amp;a,&amp;b,&amp;c);<span class="hljs-keyword">if</span>(b&lt;c) swap(b,c);<span class="hljs-keyword">double</span> ans=<span class="hljs-keyword">double</span>(a)/(b-c);<span class="hljs-built_in">printf</span>(<span class="hljs-string">"%f\n"</span>,ans);&#125;&#125;</code></pre><h1 id="收获与反思"><a href="#收获与反思" class="headerlink" title="收获与反思"></a>收获与反思</h1><p>水题</p>]]></content>
    
    
    <categories>
      
      <category>Computer Science</category>
      
      <category>ACM</category>
      
      <category>CSU</category>
      
    </categories>
    
    
    <tags>
      
      <tag>ACM</tag>
      
      <tag>CSU</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>【UVA-12100】解题报告（STL，queue）</title>
    <link href="/post/c1864474.html"/>
    <url>/post/c1864474.html</url>
    
    <content type="html"><![CDATA[<h1 id="原始题目"><a href="#原始题目" class="headerlink" title="原始题目"></a>原始题目</h1><a id="more"></a><h1 id="题目大意"><a href="#题目大意" class="headerlink" title="题目大意"></a>题目大意</h1><p>学生会里的打印机打印量巨大。现在给打印任务分配一个1到9的优先级，优先级越高表示任务越着急。</p><p>打印机的工作方式如下：首先从打印队列里取出一个任务J，如果队列里有比J更急的任务，则直接把J<br>放到打印队列尾部，否则打印任务J（此时不会把它放到打印队列）</p><p>输入打印队列中各个任务的优先级，给定你的任务的序号，假定只有打印每个任务的时候耗时1分钟，问<br>完成你的任务时总耗时是多少。</p><h1 id="解题思路"><a href="#解题思路" class="headerlink" title="解题思路"></a>解题思路</h1><ul><li>利用set模拟，维护一下当前最大优先级和各优先级的任务数即可。</li></ul><h1 id="解题代码"><a href="#解题代码" class="headerlink" title="解题代码"></a>解题代码</h1><pre><code class="hljs C++"><span class="hljs-meta">#<span class="hljs-meta-keyword">include</span> <span class="hljs-meta-string">&lt;cstdio&gt;</span></span><span class="hljs-meta">#<span class="hljs-meta-keyword">include</span> <span class="hljs-meta-string">&lt;cstring&gt;</span></span><span class="hljs-meta">#<span class="hljs-meta-keyword">include</span> <span class="hljs-meta-string">&lt;cmath&gt;</span></span><span class="hljs-meta">#<span class="hljs-meta-keyword">include</span> <span class="hljs-meta-string">&lt;iostream&gt;</span></span><span class="hljs-meta">#<span class="hljs-meta-keyword">include</span> <span class="hljs-meta-string">&lt;iomanip&gt;</span></span><span class="hljs-meta">#<span class="hljs-meta-keyword">include</span> <span class="hljs-meta-string">&lt;set&gt;</span></span><span class="hljs-meta">#<span class="hljs-meta-keyword">include</span> <span class="hljs-meta-string">&lt;queue&gt;</span></span><span class="hljs-meta">#<span class="hljs-meta-keyword">include</span> <span class="hljs-meta-string">&lt;map&gt;</span></span><span class="hljs-meta">#<span class="hljs-meta-keyword">include</span> <span class="hljs-meta-string">&lt;algorithm&gt;</span></span><span class="hljs-meta">#<span class="hljs-meta-keyword">include</span> <span class="hljs-meta-string">&lt;vector&gt;</span></span><span class="hljs-meta">#<span class="hljs-meta-keyword">define</span> rep(i,a,n) for(int i=a;i&lt;n;++i)</span><span class="hljs-meta">#<span class="hljs-meta-keyword">define</span> per(i,a,n) for(int i=n-1;i&gt;=a;--i)</span><span class="hljs-meta">#<span class="hljs-meta-keyword">define</span> cl(x,a) memset(x,a,sizeof(x))</span><span class="hljs-meta">#<span class="hljs-meta-keyword">define</span> all(x) x.begin(),x.end()</span><span class="hljs-meta">#<span class="hljs-meta-keyword">define</span> pb push_back</span><span class="hljs-meta">#<span class="hljs-meta-keyword">define</span> np next_permutation</span><span class="hljs-meta">#<span class="hljs-meta-keyword">define</span> mp make_pair</span><span class="hljs-meta">#<span class="hljs-meta-keyword">define</span> fi first</span><span class="hljs-meta">#<span class="hljs-meta-keyword">define</span> se second</span><span class="hljs-meta">#<span class="hljs-meta-keyword">define</span> INF 0x3f3f3f3f</span><span class="hljs-meta">#<span class="hljs-meta-keyword">define</span> eps 1e-8</span><span class="hljs-keyword">using</span> <span class="hljs-keyword">namespace</span> <span class="hljs-built_in">std</span>;<span class="hljs-keyword">const</span> <span class="hljs-keyword">int</span> maxn=<span class="hljs-number">1e5</span>+<span class="hljs-number">5</span>;<span class="hljs-keyword">const</span> <span class="hljs-keyword">int</span> maxl=<span class="hljs-number">26</span>;<span class="hljs-keyword">const</span> <span class="hljs-keyword">int</span> maxm=<span class="hljs-number">1e5</span>+<span class="hljs-number">5</span>;<span class="hljs-keyword">typedef</span> <span class="hljs-keyword">long</span> <span class="hljs-keyword">long</span> ll;<span class="hljs-keyword">typedef</span> <span class="hljs-built_in">vector</span>&lt;<span class="hljs-keyword">int</span>&gt; vi;<span class="hljs-keyword">typedef</span> pair&lt;<span class="hljs-keyword">int</span>,<span class="hljs-keyword">int</span>&gt; pii;<span class="hljs-keyword">int</span> num[<span class="hljs-number">100</span>];<span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span>&#123;ios::sync_with_stdio(<span class="hljs-literal">false</span>);<span class="hljs-keyword">int</span> t,n,m,l,mmax=<span class="hljs-number">0</span>;<span class="hljs-built_in">cin</span>&gt;&gt;t;<span class="hljs-keyword">while</span>(t--)&#123;<span class="hljs-built_in">cin</span>&gt;&gt;n&gt;&gt;m;<span class="hljs-comment">//自己得任务是m号 </span><span class="hljs-built_in">queue</span>&lt;pii&gt; q;cl(num,<span class="hljs-number">0</span>);rep(i,<span class="hljs-number">0</span>,n)&#123;<span class="hljs-built_in">cin</span>&gt;&gt;l;mmax=max(mmax,l);q.push(mp(i,l));num[l]++;&#125;<span class="hljs-keyword">int</span> ans=<span class="hljs-number">0</span>;<span class="hljs-keyword">while</span>(!q.empty())&#123;pii temp=q.front();q.pop();<span class="hljs-keyword">if</span>(temp.second&lt;mmax)&#123;q.push(temp);&#125;<span class="hljs-keyword">else</span>&#123;ans++;<span class="hljs-keyword">if</span>(!(--num[mmax])) <span class="hljs-keyword">while</span>(!(num[mmax]) &amp;&amp; mmax)&#123;mmax--;&#125;<span class="hljs-keyword">if</span>(temp.first==m) &#123;<span class="hljs-built_in">cout</span>&lt;&lt;ans&lt;&lt;<span class="hljs-built_in">endl</span>;<span class="hljs-keyword">break</span>;&#125;&#125;&#125;&#125; &#125;</code></pre><h1 id="收获与反思"><a href="#收获与反思" class="headerlink" title="收获与反思"></a>收获与反思</h1><ul><li>加快码速，秒之s</li></ul>]]></content>
    
    
    <categories>
      
      <category>Computer Science</category>
      
      <category>ACM</category>
      
      <category>UVA</category>
      
    </categories>
    
    
    <tags>
      
      <tag>ACM</tag>
      
      <tag>UVA</tag>
      
      <tag>补图</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>【UVA-1595】解题报告（STL,Vector）</title>
    <link href="/post/a7528411.html"/>
    <url>/post/a7528411.html</url>
    
    <content type="html"><![CDATA[<h1 id="原始题目"><a href="#原始题目" class="headerlink" title="原始题目"></a>原始题目</h1><a id="more"></a><h1 id="题目大意"><a href="#题目大意" class="headerlink" title="题目大意"></a>题目大意</h1><p>给出平面上N个点，问是否可以找到一条竖线，使得所有点左右对称。</p><h1 id="解题思路"><a href="#解题思路" class="headerlink" title="解题思路"></a>解题思路</h1><p>纵坐标离散化后求每行得平均数，判断一下</p><h1 id="解题代码"><a href="#解题代码" class="headerlink" title="解题代码"></a>解题代码</h1><pre><code class="hljs C++"><span class="hljs-meta">#<span class="hljs-meta-keyword">include</span> <span class="hljs-meta-string">&lt;cstdio&gt;</span></span><span class="hljs-meta">#<span class="hljs-meta-keyword">include</span> <span class="hljs-meta-string">&lt;cstring&gt;</span></span><span class="hljs-meta">#<span class="hljs-meta-keyword">include</span> <span class="hljs-meta-string">&lt;cmath&gt;</span></span><span class="hljs-meta">#<span class="hljs-meta-keyword">include</span> <span class="hljs-meta-string">&lt;iostream&gt;</span></span><span class="hljs-meta">#<span class="hljs-meta-keyword">include</span> <span class="hljs-meta-string">&lt;iomanip&gt;</span></span><span class="hljs-meta">#<span class="hljs-meta-keyword">include</span> <span class="hljs-meta-string">&lt;set&gt;</span></span><span class="hljs-meta">#<span class="hljs-meta-keyword">include</span> <span class="hljs-meta-string">&lt;queue&gt;</span></span><span class="hljs-meta">#<span class="hljs-meta-keyword">include</span> <span class="hljs-meta-string">&lt;map&gt;</span></span><span class="hljs-meta">#<span class="hljs-meta-keyword">include</span> <span class="hljs-meta-string">&lt;algorithm&gt;</span></span><span class="hljs-meta">#<span class="hljs-meta-keyword">include</span> <span class="hljs-meta-string">&lt;vector&gt;</span></span><span class="hljs-meta">#<span class="hljs-meta-keyword">define</span> rep(i,a,n) for(int i=a;i&lt;n;++i)</span><span class="hljs-meta">#<span class="hljs-meta-keyword">define</span> per(i,a,n) for(int i=n-1;i&gt;=a;--i)</span><span class="hljs-meta">#<span class="hljs-meta-keyword">define</span> cl(x,a) memset(x,a,sizeof(x))</span><span class="hljs-meta">#<span class="hljs-meta-keyword">define</span> all(x) x.begin(),x.end()</span><span class="hljs-meta">#<span class="hljs-meta-keyword">define</span> pb push_back</span><span class="hljs-meta">#<span class="hljs-meta-keyword">define</span> np next_permutation</span><span class="hljs-meta">#<span class="hljs-meta-keyword">define</span> mp make_pair</span><span class="hljs-meta">#<span class="hljs-meta-keyword">define</span> fi first</span><span class="hljs-meta">#<span class="hljs-meta-keyword">define</span> se second</span><span class="hljs-meta">#<span class="hljs-meta-keyword">define</span> INF 0x3f3f3f3f</span><span class="hljs-meta">#<span class="hljs-meta-keyword">define</span> eps 1e-8</span><span class="hljs-keyword">using</span> <span class="hljs-keyword">namespace</span> <span class="hljs-built_in">std</span>;<span class="hljs-keyword">const</span> <span class="hljs-keyword">int</span> maxn=<span class="hljs-number">1e5</span>+<span class="hljs-number">5</span>;<span class="hljs-keyword">const</span> <span class="hljs-keyword">int</span> maxl=<span class="hljs-number">26</span>;<span class="hljs-keyword">typedef</span> <span class="hljs-keyword">long</span> <span class="hljs-keyword">long</span> ll;<span class="hljs-keyword">typedef</span> <span class="hljs-built_in">vector</span>&lt;<span class="hljs-keyword">int</span>&gt; vi;<span class="hljs-keyword">typedef</span> pair&lt;<span class="hljs-keyword">int</span>,<span class="hljs-keyword">int</span>&gt; pii;<span class="hljs-built_in">vector</span>&lt;pii&gt; v0;vi v[<span class="hljs-number">1005</span>];<span class="hljs-keyword">double</span> ans[<span class="hljs-number">1005</span>];<span class="hljs-function"><span class="hljs-keyword">bool</span> <span class="hljs-title">cmp</span><span class="hljs-params">(pii a,pii b)</span></span>&#123;<span class="hljs-keyword">if</span>(a.first!=b.first) <span class="hljs-keyword">return</span> a.first&lt;b.first;<span class="hljs-keyword">else</span> <span class="hljs-keyword">return</span> a.second&lt;b.second;&#125;<span class="hljs-keyword">int</span> t,n,a,b;<span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span>&#123;ios::sync_with_stdio(<span class="hljs-literal">false</span>);<span class="hljs-built_in">cin</span>&gt;&gt;t;<span class="hljs-keyword">while</span>(t--)&#123;rep(i,<span class="hljs-number">0</span>,<span class="hljs-number">1005</span>) v[i].clear();v0.clear();<span class="hljs-built_in">cin</span>&gt;&gt;n;rep(i,<span class="hljs-number">0</span>,n) &#123;<span class="hljs-built_in">cin</span>&gt;&gt;b&gt;&gt;a; v0.pb(mp(a,b));&#125;sort(all(v0),cmp);<span class="hljs-comment">//rep(i,0,n) </span><span class="hljs-comment">//&#123;</span><span class="hljs-comment">//cout&lt;&lt;v0[i].fi&lt;&lt;"  "&lt;&lt;v0[i].se&lt;&lt;endl;</span><span class="hljs-comment">//&#125;</span><span class="hljs-keyword">int</span> temp=INF,cnt=<span class="hljs-number">-1</span>,sum=<span class="hljs-number">0</span>;rep(i,<span class="hljs-number">0</span>,n)&#123;<span class="hljs-keyword">if</span>(temp!=v0[i].first)&#123;<span class="hljs-keyword">if</span>(cnt!=<span class="hljs-number">-1</span>)&#123;ans[cnt]=(<span class="hljs-keyword">double</span>)sum/v[cnt].size();<span class="hljs-comment">//cout&lt;&lt;"ave["&lt;&lt;cnt&lt;&lt;"]="&lt;&lt;ans[cnt]&lt;&lt;endl;</span>&#125;temp=v0[i].first;cnt++;v[cnt].pb(v0[i].second);sum=v0[i].second;&#125;<span class="hljs-keyword">else</span> &#123;v[cnt].pb(v0[i].second);sum+=v0[i].second;&#125;&#125;ans[cnt]=(<span class="hljs-keyword">double</span>)sum/v[cnt].size();cnt++;<span class="hljs-keyword">int</span> flag=<span class="hljs-number">1</span>;rep(i,<span class="hljs-number">1</span>,cnt)&#123;<span class="hljs-comment">//cout&lt;&lt;"ave["&lt;&lt;i&lt;&lt;"]="&lt;&lt;ans[i]&lt;&lt;endl;</span><span class="hljs-keyword">if</span>(<span class="hljs-built_in">abs</span>(ans[i]-ans[i<span class="hljs-number">-1</span>])&gt;eps)&#123;flag=<span class="hljs-number">0</span>;<span class="hljs-built_in">cout</span>&lt;&lt;<span class="hljs-string">"NO"</span>&lt;&lt;<span class="hljs-built_in">endl</span>;<span class="hljs-keyword">break</span>; &#125;&#125;<span class="hljs-keyword">if</span>(flag) <span class="hljs-built_in">cout</span>&lt;&lt;<span class="hljs-string">"YES"</span>&lt;&lt;<span class="hljs-built_in">endl</span>;&#125;&#125;</code></pre><h1 id="收获与反思"><a href="#收获与反思" class="headerlink" title="收获与反思"></a>收获与反思</h1><ul><li>加快码速，秒之</li></ul>]]></content>
    
    
    <categories>
      
      <category>Computer Science</category>
      
      <category>ACM</category>
      
      <category>UVA</category>
      
    </categories>
    
    
    <tags>
      
      <tag>ACM</tag>
      
      <tag>UVA</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>【UVA-10391】解题报告（STL）</title>
    <link href="/post/4d6a6b27.html"/>
    <url>/post/4d6a6b27.html</url>
    
    <content type="html"><![CDATA[<h1 id="原始题目"><a href="#原始题目" class="headerlink" title="原始题目"></a>原始题目</h1><a id="more"></a><h1 id="题目大意"><a href="#题目大意" class="headerlink" title="题目大意"></a>题目大意</h1><p>给出一个字典，找出所有的复合单词，即恰好有两个单词连接而成的单词。<br>输入已按照字典序从小到大排序，且不超过120000个单词，输出所有复合词，按照字典序从小到大排序。</p><h1 id="解题思路"><a href="#解题思路" class="headerlink" title="解题思路"></a>解题思路</h1><p>substring秒过</p><h1 id="解题代码"><a href="#解题代码" class="headerlink" title="解题代码"></a>解题代码</h1><pre><code class="hljs C++"><span class="hljs-meta">#<span class="hljs-meta-keyword">include</span> <span class="hljs-meta-string">&lt;cstdio&gt;</span></span><span class="hljs-meta">#<span class="hljs-meta-keyword">include</span> <span class="hljs-meta-string">&lt;cstring&gt;</span></span><span class="hljs-meta">#<span class="hljs-meta-keyword">include</span> <span class="hljs-meta-string">&lt;string&gt;</span></span><span class="hljs-meta">#<span class="hljs-meta-keyword">include</span> <span class="hljs-meta-string">&lt;iostream&gt;</span></span><span class="hljs-meta">#<span class="hljs-meta-keyword">include</span> <span class="hljs-meta-string">&lt;set&gt;</span></span><span class="hljs-meta">#<span class="hljs-meta-keyword">include</span> <span class="hljs-meta-string">&lt;queue&gt;</span></span><span class="hljs-meta">#<span class="hljs-meta-keyword">include</span> <span class="hljs-meta-string">&lt;algorithm&gt;</span></span><span class="hljs-meta">#<span class="hljs-meta-keyword">include</span> <span class="hljs-meta-string">&lt;map&gt;</span></span><span class="hljs-meta">#<span class="hljs-meta-keyword">include</span> <span class="hljs-meta-string">&lt;vector&gt;</span></span><span class="hljs-meta">#<span class="hljs-meta-keyword">include</span> <span class="hljs-meta-string">&lt;iomanip&gt;</span></span><span class="hljs-meta">#<span class="hljs-meta-keyword">include</span> <span class="hljs-meta-string">&lt;cmath&gt;</span></span><span class="hljs-keyword">using</span> <span class="hljs-keyword">namespace</span> <span class="hljs-built_in">std</span>;<span class="hljs-keyword">const</span> <span class="hljs-keyword">int</span> maxn=<span class="hljs-number">2e5</span>+<span class="hljs-number">5</span>;<span class="hljs-built_in">set</span> &lt;<span class="hljs-built_in">string</span>&gt; s;<span class="hljs-built_in">vector</span> &lt;<span class="hljs-built_in">string</span>&gt; all;<span class="hljs-built_in">string</span> a;<span class="hljs-keyword">int</span> n; <span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span>&#123;<span class="hljs-keyword">while</span>(<span class="hljs-built_in">cin</span>&gt;&gt;a)&#123;s.insert(a);&#125;<span class="hljs-built_in">set</span> &lt;<span class="hljs-built_in">string</span>&gt; ::iterator it;<span class="hljs-keyword">for</span>(it=s.begin();it!=s.end();it++)&#123;<span class="hljs-keyword">int</span> len=(*it).size(); <span class="hljs-keyword">for</span>(<span class="hljs-keyword">int</span> i=<span class="hljs-number">1</span>;i&lt;len;i++)&#123;<span class="hljs-comment">//遍历每个单词从头到尾</span><span class="hljs-built_in">string</span> pre=(*it).substr(<span class="hljs-number">0</span>,i);<span class="hljs-built_in">string</span> sub=(*it).substr(i,len-i);<span class="hljs-keyword">if</span>(s.count(pre) &amp;&amp; s.count(sub))&#123;<span class="hljs-built_in">cout</span>&lt;&lt;*it&lt;&lt;<span class="hljs-built_in">endl</span>;<span class="hljs-keyword">break</span>;&#125;&#125;&#125;&#125;</code></pre><h1 id="收获与反思"><a href="#收获与反思" class="headerlink" title="收获与反思"></a>收获与反思</h1><ul><li>熟悉函数 string::substr()  第一个参数为起始位置，第二个参数为长度。</li></ul>]]></content>
    
    
    <categories>
      
      <category>Computer Science</category>
      
      <category>ACM</category>
      
      <category>UVA</category>
      
    </categories>
    
    
    <tags>
      
      <tag>ACM</tag>
      
      <tag>UVA</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>【UVA-10763】解题报告（STL）</title>
    <link href="/post/31a770a5.html"/>
    <url>/post/31a770a5.html</url>
    
    <content type="html"><![CDATA[<h1 id="原始题目"><a href="#原始题目" class="headerlink" title="原始题目"></a>原始题目</h1><a id="more"></a><h1 id="题目大意"><a href="#题目大意" class="headerlink" title="题目大意"></a>题目大意</h1><p>有n个学生想交换到其他学校学习。为了简单起见，规定每个象从A学校换到B学校的学生必须找一个<br>想从B学校换到A的“搭档”。如果每个人都能找到搭档（一个人不能找多个搭档），学校就会同意他们交换。<br>每个学生用两个整数A、B表示，你的任务是判断交换是否可以进行。</p><h1 id="解题思路"><a href="#解题思路" class="headerlink" title="解题思路"></a>解题思路</h1><ul><li><p>利用multimap（多重映射）对于一组键、值对，查找有没有对应值为键，键为值得的映射，有则删除，没有的话把当前<br>的键、值对加入multimap。最后检查是否为空</p></li><li><p>网上还有一种虽然简单优雅但是有漏洞的解法，初始赋值$ans[i]=i$输入一组$a,b$，$swap(ans[a],ans[b])$，<br>最后检查是否复合原状态（一一匹配的话两次反转复原），不过这个解法没有考虑到三方交换的情况（即$swap(a,b),swap(b,c),swap(c,a)$）<br>其实这是不满足题意的，但也会判YES。所以说有漏洞。</p></li></ul><h1 id="解题代码"><a href="#解题代码" class="headerlink" title="解题代码"></a>解题代码</h1><ul><li><p>multimap</p>  <pre><code class="hljs C++"><span class="hljs-meta">#<span class="hljs-meta-keyword">include</span> <span class="hljs-meta-string">&lt;cstdio&gt;</span></span><span class="hljs-meta">#<span class="hljs-meta-keyword">include</span> <span class="hljs-meta-string">&lt;cstring&gt;</span></span><span class="hljs-meta">#<span class="hljs-meta-keyword">include</span> <span class="hljs-meta-string">&lt;iostream&gt;</span></span><span class="hljs-meta">#<span class="hljs-meta-keyword">include</span> <span class="hljs-meta-string">&lt;iomanip&gt;</span></span><span class="hljs-meta">#<span class="hljs-meta-keyword">include</span> <span class="hljs-meta-string">&lt;cmath&gt; </span></span><span class="hljs-meta">#<span class="hljs-meta-keyword">include</span> <span class="hljs-meta-string">&lt;set&gt;</span></span><span class="hljs-meta">#<span class="hljs-meta-keyword">include</span> <span class="hljs-meta-string">&lt;vector&gt;</span></span><span class="hljs-meta">#<span class="hljs-meta-keyword">include</span> <span class="hljs-meta-string">&lt;string&gt;</span></span><span class="hljs-meta">#<span class="hljs-meta-keyword">include</span> <span class="hljs-meta-string">&lt;algorithm&gt;</span></span><span class="hljs-meta">#<span class="hljs-meta-keyword">include</span> <span class="hljs-meta-string">&lt;map&gt;</span></span><span class="hljs-meta">#<span class="hljs-meta-keyword">include</span> <span class="hljs-meta-string">&lt;sstream&gt;</span></span><span class="hljs-meta">#<span class="hljs-meta-keyword">include</span> <span class="hljs-meta-string">&lt;bits/stdc++.h&gt;</span></span><span class="hljs-meta">#<span class="hljs-meta-keyword">define</span> rep(i,a,n) for(int i=a;i&lt;n;++i)</span><span class="hljs-meta">#<span class="hljs-meta-keyword">define</span> per(i,a,n) for(int i=n-a;i&gt;=a;--i)</span><span class="hljs-meta">#<span class="hljs-meta-keyword">define</span> cl(x,a) memset(x,a,sizeof(x))</span><span class="hljs-meta">#<span class="hljs-meta-keyword">define</span> all(x) x.begin(),x.end()</span><span class="hljs-meta">#<span class="hljs-meta-keyword">define</span> pb push_back</span><span class="hljs-meta">#<span class="hljs-meta-keyword">define</span> np next_permutation</span><span class="hljs-meta">#<span class="hljs-meta-keyword">define</span> mp make_pair</span><span class="hljs-meta">#<span class="hljs-meta-keyword">define</span> INF 0x3f3f3f3f</span><span class="hljs-meta">#<span class="hljs-meta-keyword">define</span> eps 1e-8</span><span class="hljs-meta">#<span class="hljs-meta-keyword">define</span> K 1001</span><span class="hljs-meta">#<span class="hljs-meta-keyword">define</span> fi first</span><span class="hljs-meta">#<span class="hljs-meta-keyword">define</span> se second</span><span class="hljs-keyword">using</span> <span class="hljs-keyword">namespace</span> <span class="hljs-built_in">std</span>;<span class="hljs-keyword">const</span> <span class="hljs-keyword">int</span> maxn=<span class="hljs-number">1e5</span>+<span class="hljs-number">5</span>;<span class="hljs-keyword">typedef</span> <span class="hljs-built_in">vector</span>&lt;<span class="hljs-keyword">int</span>&gt; vi;<span class="hljs-keyword">typedef</span> <span class="hljs-built_in">multimap</span> &lt;<span class="hljs-keyword">int</span>,<span class="hljs-keyword">int</span>&gt;::const_iterator cit;<span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span>&#123;ios::sync_with_stdio(<span class="hljs-literal">false</span>);<span class="hljs-keyword">int</span> n,a,b;<span class="hljs-keyword">while</span>(<span class="hljs-built_in">cin</span>&gt;&gt;n &amp;&amp; n)&#123;<span class="hljs-built_in">multimap</span> &lt;<span class="hljs-keyword">int</span>,<span class="hljs-keyword">int</span>&gt; mmp;rep(i,<span class="hljs-number">0</span>,n)&#123;<span class="hljs-built_in">cin</span>&gt;&gt;a&gt;&gt;b;<span class="hljs-keyword">typedef</span> pair&lt;cit,cit&gt; Range;Range range=mmp.equal_range(b);<span class="hljs-keyword">int</span> flag=<span class="hljs-number">0</span>;cit j=range.first;<span class="hljs-keyword">for</span>(;j!=range.second;++j)&#123;<span class="hljs-keyword">if</span>(j-&gt;second==a)&#123;flag=<span class="hljs-number">1</span>;<span class="hljs-keyword">break</span>;&#125;&#125;<span class="hljs-keyword">if</span>(flag) mmp.erase(j);<span class="hljs-keyword">else</span> mmp.insert(mp(a,b));&#125;<span class="hljs-keyword">if</span>(mmp.size()==<span class="hljs-number">0</span>) <span class="hljs-built_in">cout</span>&lt;&lt;<span class="hljs-string">"YES"</span>&lt;&lt;<span class="hljs-built_in">endl</span>;<span class="hljs-keyword">else</span> <span class="hljs-built_in">cout</span>&lt;&lt;<span class="hljs-string">"NO"</span>&lt;&lt;<span class="hljs-built_in">endl</span>;&#125;&#125;</code></pre></li><li><p>朴素法（有漏洞）</p>  <pre><code class="hljs C++"><span class="hljs-meta">#<span class="hljs-meta-keyword">include</span> <span class="hljs-meta-string">&lt;cstdio&gt;</span></span><span class="hljs-meta">#<span class="hljs-meta-keyword">include</span> <span class="hljs-meta-string">&lt;cstring&gt;</span></span><span class="hljs-meta">#<span class="hljs-meta-keyword">include</span> <span class="hljs-meta-string">&lt;iostream&gt;</span></span><span class="hljs-meta">#<span class="hljs-meta-keyword">include</span> <span class="hljs-meta-string">&lt;iomanip&gt;</span></span><span class="hljs-meta">#<span class="hljs-meta-keyword">include</span> <span class="hljs-meta-string">&lt;cmath&gt; </span></span><span class="hljs-meta">#<span class="hljs-meta-keyword">include</span> <span class="hljs-meta-string">&lt;set&gt;</span></span><span class="hljs-meta">#<span class="hljs-meta-keyword">include</span> <span class="hljs-meta-string">&lt;vector&gt;</span></span><span class="hljs-meta">#<span class="hljs-meta-keyword">include</span> <span class="hljs-meta-string">&lt;string&gt;</span></span><span class="hljs-meta">#<span class="hljs-meta-keyword">include</span> <span class="hljs-meta-string">&lt;algorithm&gt;</span></span><span class="hljs-meta">#<span class="hljs-meta-keyword">include</span> <span class="hljs-meta-string">&lt;map&gt;</span></span><span class="hljs-meta">#<span class="hljs-meta-keyword">include</span> <span class="hljs-meta-string">&lt;sstream&gt;</span></span><span class="hljs-meta">#<span class="hljs-meta-keyword">include</span> <span class="hljs-meta-string">&lt;bits/stdc++.h&gt;</span></span><span class="hljs-meta">#<span class="hljs-meta-keyword">define</span> rep(i,a,n) for(int i=a;i&lt;n;++i)</span><span class="hljs-meta">#<span class="hljs-meta-keyword">define</span> per(i,a,n) for(int i=n-a;i&gt;=a;--i)</span><span class="hljs-meta">#<span class="hljs-meta-keyword">define</span> cl(x,a) memset(x,a,sizeof(x))</span><span class="hljs-meta">#<span class="hljs-meta-keyword">define</span> all(x) x.begin(),x.end()</span><span class="hljs-meta">#<span class="hljs-meta-keyword">define</span> pb push_back</span><span class="hljs-meta">#<span class="hljs-meta-keyword">define</span> np next_permutation</span><span class="hljs-meta">#<span class="hljs-meta-keyword">define</span> mp make_pair</span><span class="hljs-meta">#<span class="hljs-meta-keyword">define</span> INF 0x3f3f3f3f</span><span class="hljs-meta">#<span class="hljs-meta-keyword">define</span> eps 1e-8</span><span class="hljs-meta">#<span class="hljs-meta-keyword">define</span> K 1001</span><span class="hljs-meta">#<span class="hljs-meta-keyword">define</span> fi first</span><span class="hljs-meta">#<span class="hljs-meta-keyword">define</span> se second</span><span class="hljs-keyword">using</span> <span class="hljs-keyword">namespace</span> <span class="hljs-built_in">std</span>;<span class="hljs-keyword">const</span> <span class="hljs-keyword">int</span> maxn=<span class="hljs-number">5e5</span>+<span class="hljs-number">5</span>;<span class="hljs-keyword">int</span> ans[maxn];<span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span>&#123;ios::sync_with_stdio(<span class="hljs-literal">false</span>);<span class="hljs-keyword">int</span> n;<span class="hljs-keyword">while</span>(<span class="hljs-built_in">cin</span>&gt;&gt;n &amp;&amp; n)&#123;<span class="hljs-keyword">int</span> flag=<span class="hljs-number">0</span>;rep(i,<span class="hljs-number">1</span>,n+<span class="hljs-number">1</span>) ans[i]=i;rep(i,<span class="hljs-number">1</span>,n+<span class="hljs-number">1</span>) &#123;<span class="hljs-keyword">int</span> a,b; <span class="hljs-built_in">cin</span>&gt;&gt;a&gt;&gt;b; swap(ans[a],ans[b]);&#125;rep(i,<span class="hljs-number">1</span>,n+<span class="hljs-number">1</span>) &#123;<span class="hljs-keyword">if</span>(ans[i]!=i) &#123;flag=<span class="hljs-number">1</span>;<span class="hljs-keyword">break</span>;&#125;&#125;<span class="hljs-keyword">if</span>(flag) <span class="hljs-built_in">cout</span>&lt;&lt;<span class="hljs-string">"NO"</span>&lt;&lt;<span class="hljs-built_in">endl</span>;<span class="hljs-keyword">else</span> <span class="hljs-built_in">cout</span>&lt;&lt;<span class="hljs-string">"YES"</span>&lt;&lt;<span class="hljs-built_in">endl</span>;&#125;&#125;</code></pre></li></ul><h1 id="收获与反思"><a href="#收获与反思" class="headerlink" title="收获与反思"></a>收获与反思</h1><ul><li>交换复原思想值得学习</li></ul>]]></content>
    
    
    <categories>
      
      <category>Computer Science</category>
      
      <category>ACM</category>
      
      <category>UVA</category>
      
    </categories>
    
    
    <tags>
      
      <tag>ACM</tag>
      
      <tag>UVA</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>【UVA-10935】解题报告（STL，模拟）</title>
    <link href="/post/26fa4dfc.html"/>
    <url>/post/26fa4dfc.html</url>
    
    <content type="html"><![CDATA[<h1 id="原始题目"><a href="#原始题目" class="headerlink" title="原始题目"></a>原始题目</h1><a id="more"></a><h1 id="题目大意"><a href="#题目大意" class="headerlink" title="题目大意"></a>题目大意</h1><p>桌上有n(n≤50) 张牌，从顶面开始，从上往下编号1到n。当至少剩下两张牌时进行以下操作：</p><ul><li>把第一张牌扔掉，然后把新的第一张牌放到整叠牌的最后。</li></ul><p>输入每行一个n，输出每次扔掉的牌以及最后剩下的牌。</p><h1 id="解题思路"><a href="#解题思路" class="headerlink" title="解题思路"></a>解题思路</h1><ul><li>利用queue模拟操作，注意只有1张牌的时候特判。</li></ul><h1 id="解题代码"><a href="#解题代码" class="headerlink" title="解题代码"></a>解题代码</h1><pre><code class="hljs C++"><span class="hljs-meta">#<span class="hljs-meta-keyword">include</span> <span class="hljs-meta-string">&lt;cstdio&gt;</span></span><span class="hljs-meta">#<span class="hljs-meta-keyword">include</span> <span class="hljs-meta-string">&lt;cstring&gt;</span></span><span class="hljs-meta">#<span class="hljs-meta-keyword">include</span> <span class="hljs-meta-string">&lt;iostream&gt;</span></span><span class="hljs-meta">#<span class="hljs-meta-keyword">include</span> <span class="hljs-meta-string">&lt;iomanip&gt;</span></span><span class="hljs-meta">#<span class="hljs-meta-keyword">include</span> <span class="hljs-meta-string">&lt;cmath&gt; </span></span><span class="hljs-meta">#<span class="hljs-meta-keyword">include</span> <span class="hljs-meta-string">&lt;set&gt;</span></span><span class="hljs-meta">#<span class="hljs-meta-keyword">include</span> <span class="hljs-meta-string">&lt;vector&gt;</span></span><span class="hljs-meta">#<span class="hljs-meta-keyword">include</span> <span class="hljs-meta-string">&lt;string&gt;</span></span><span class="hljs-meta">#<span class="hljs-meta-keyword">include</span> <span class="hljs-meta-string">&lt;algorithm&gt;</span></span><span class="hljs-meta">#<span class="hljs-meta-keyword">include</span> <span class="hljs-meta-string">&lt;map&gt;</span></span><span class="hljs-meta">#<span class="hljs-meta-keyword">include</span> <span class="hljs-meta-string">&lt;sstream&gt;</span></span><span class="hljs-meta">#<span class="hljs-meta-keyword">include</span> <span class="hljs-meta-string">&lt;bits/stdc++.h&gt;</span></span><span class="hljs-meta">#<span class="hljs-meta-keyword">define</span> rep(i,a,n) for(int i=a;i&lt;n;++i)</span><span class="hljs-meta">#<span class="hljs-meta-keyword">define</span> per(i,a,n) for(int i=n-a;i&gt;=a;--i)</span><span class="hljs-meta">#<span class="hljs-meta-keyword">define</span> cl(x,a) memset(x,a,sizeof(x))</span><span class="hljs-meta">#<span class="hljs-meta-keyword">define</span> all(x) x.begin(),x.end()</span><span class="hljs-meta">#<span class="hljs-meta-keyword">define</span> pb push_back</span><span class="hljs-meta">#<span class="hljs-meta-keyword">define</span> np next_permutation</span><span class="hljs-meta">#<span class="hljs-meta-keyword">define</span> mp make_pair</span><span class="hljs-meta">#<span class="hljs-meta-keyword">define</span> INF 0x3f3f3f3f</span><span class="hljs-meta">#<span class="hljs-meta-keyword">define</span> eps 1e-8</span><span class="hljs-meta">#<span class="hljs-meta-keyword">define</span> K 1001</span><span class="hljs-meta">#<span class="hljs-meta-keyword">define</span> fi first</span><span class="hljs-meta">#<span class="hljs-meta-keyword">define</span> se second</span><span class="hljs-keyword">using</span> <span class="hljs-keyword">namespace</span> <span class="hljs-built_in">std</span>;<span class="hljs-keyword">const</span> <span class="hljs-keyword">int</span> maxn=<span class="hljs-number">1e5</span>+<span class="hljs-number">5</span>;<span class="hljs-keyword">int</span> n;<span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span>&#123;ios::sync_with_stdio(<span class="hljs-literal">false</span>);<span class="hljs-keyword">while</span>(<span class="hljs-built_in">cin</span>&gt;&gt;n &amp;&amp;n)&#123;<span class="hljs-keyword">if</span>(n==<span class="hljs-number">1</span>)&#123;<span class="hljs-comment">//1的时候特判 </span><span class="hljs-built_in">cout</span>&lt;&lt;<span class="hljs-string">"Discarded cards:"</span>&lt;&lt;<span class="hljs-built_in">endl</span>;<span class="hljs-built_in">cout</span>&lt;&lt;<span class="hljs-string">"Remaining card: 1"</span>&lt;&lt;<span class="hljs-built_in">endl</span>;<span class="hljs-keyword">continue</span>;&#125;<span class="hljs-built_in">cout</span>&lt;&lt;<span class="hljs-string">"Discarded cards: "</span>;<span class="hljs-built_in">queue</span> &lt;<span class="hljs-keyword">int</span>&gt; q;rep(i,<span class="hljs-number">1</span>,n+<span class="hljs-number">1</span>) q.push(i);<span class="hljs-keyword">while</span>(q.size()&gt;<span class="hljs-number">2</span>)&#123;<span class="hljs-keyword">int</span> top=q.front(); q.pop();<span class="hljs-built_in">cout</span>&lt;&lt;top&lt;&lt;<span class="hljs-string">", "</span>;top=q.front();q.pop();q.push(top);&#125;<span class="hljs-keyword">int</span> top=q.front();q.pop();<span class="hljs-built_in">cout</span>&lt;&lt;top&lt;&lt;<span class="hljs-built_in">endl</span>&lt;&lt;<span class="hljs-string">"Remaining card: "</span>&lt;&lt;q.front()&lt;&lt;<span class="hljs-built_in">endl</span>;&#125;&#125;</code></pre>]]></content>
    
    
    <categories>
      
      <category>Computer Science</category>
      
      <category>ACM</category>
      
      <category>UVA</category>
      
    </categories>
    
    
    <tags>
      
      <tag>ACM</tag>
      
      <tag>UVA</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>【UVA-11401】解题报告（数学，求和公式）</title>
    <link href="/post/23f72a93.html"/>
    <url>/post/23f72a93.html</url>
    
    <content type="html"><![CDATA[<h1 id="原始题目"><a href="#原始题目" class="headerlink" title="原始题目"></a>原始题目</h1><a id="more"></a><h1 id="题目大意"><a href="#题目大意" class="headerlink" title="题目大意"></a>题目大意</h1><p>有长度分别为$1,2,3,4 \cdots n$ 的木杆各一根，问共可以组成多少个三角形。</p><h1 id="解题思路"><a href="#解题思路" class="headerlink" title="解题思路"></a>解题思路</h1><ul><li>设$f[x]$ 表示以$x$为最长边的三角形的个数。</li><li>设另两条边为$y,z$，易知$y+z&gt;x$，所以$x-z<y<x$，当$z>=2$时有解。</y<x$，当$z></li><li>解的情况总数为$\sum {i=2}^{x-1} { \frac {(x-2)(x-1)}{2}}$。但里面包括 y,z 互换以及 y=z 的情况</li></ul><p>故还需要减去等腰三角形数再除以 2</p><h1 id="解题代码"><a href="#解题代码" class="headerlink" title="解题代码"></a>解题代码</h1><pre><code class="hljs C++"><span class="hljs-meta">#<span class="hljs-meta-keyword">include</span> <span class="hljs-meta-string">&lt;cstdio&gt;</span></span><span class="hljs-meta">#<span class="hljs-meta-keyword">include</span> <span class="hljs-meta-string">&lt;cstring&gt;</span></span><span class="hljs-meta">#<span class="hljs-meta-keyword">include</span> <span class="hljs-meta-string">&lt;cmath&gt;</span></span><span class="hljs-meta">#<span class="hljs-meta-keyword">include</span> <span class="hljs-meta-string">&lt;iostream&gt;</span></span><span class="hljs-meta">#<span class="hljs-meta-keyword">include</span> <span class="hljs-meta-string">&lt;iomanip&gt;</span></span><span class="hljs-meta">#<span class="hljs-meta-keyword">include</span> <span class="hljs-meta-string">&lt;set&gt;</span></span><span class="hljs-meta">#<span class="hljs-meta-keyword">include</span> <span class="hljs-meta-string">&lt;queue&gt;</span></span><span class="hljs-meta">#<span class="hljs-meta-keyword">include</span> <span class="hljs-meta-string">&lt;map&gt;</span></span><span class="hljs-meta">#<span class="hljs-meta-keyword">include</span> <span class="hljs-meta-string">&lt;stack&gt;</span></span><span class="hljs-meta">#<span class="hljs-meta-keyword">include</span> <span class="hljs-meta-string">&lt;algorithm&gt;</span></span><span class="hljs-meta">#<span class="hljs-meta-keyword">include</span> <span class="hljs-meta-string">&lt;vector&gt;</span></span><span class="hljs-meta">#<span class="hljs-meta-keyword">include</span> <span class="hljs-meta-string">&lt;string&gt;</span></span><span class="hljs-meta">#<span class="hljs-meta-keyword">include</span> <span class="hljs-meta-string">&lt;sstream&gt;</span></span><span class="hljs-meta">#<span class="hljs-meta-keyword">define</span> rep(i,a,n) for(int i=a;i&lt;n;++i)</span><span class="hljs-meta">#<span class="hljs-meta-keyword">define</span> per(i,a,n) for(int i=n-a;i&gt;=a;--i)</span><span class="hljs-meta">#<span class="hljs-meta-keyword">define</span> se second</span><span class="hljs-meta">#<span class="hljs-meta-keyword">define</span> fi first</span><span class="hljs-meta">#<span class="hljs-meta-keyword">define</span> eps 1e-8</span><span class="hljs-meta">#<span class="hljs-meta-keyword">define</span> INF 0x3f3f3f3f</span><span class="hljs-keyword">using</span> <span class="hljs-keyword">namespace</span> <span class="hljs-built_in">std</span>;<span class="hljs-keyword">const</span> <span class="hljs-keyword">int</span> maxn=<span class="hljs-number">1e6</span>+<span class="hljs-number">5</span>;<span class="hljs-keyword">const</span> <span class="hljs-keyword">int</span> maxl=<span class="hljs-number">26</span>;<span class="hljs-keyword">const</span> <span class="hljs-keyword">int</span> maxm=<span class="hljs-number">1e6</span>+<span class="hljs-number">5</span>;<span class="hljs-keyword">typedef</span> <span class="hljs-keyword">long</span> <span class="hljs-keyword">long</span> ll;<span class="hljs-keyword">typedef</span> <span class="hljs-keyword">unsigned</span> <span class="hljs-keyword">long</span> <span class="hljs-keyword">long</span> ull;<span class="hljs-keyword">typedef</span> <span class="hljs-built_in">vector</span>&lt;<span class="hljs-keyword">int</span>&gt; vi;<span class="hljs-keyword">typedef</span> pair&lt;<span class="hljs-keyword">int</span>,<span class="hljs-keyword">int</span>&gt; pii;ll n,m;ll f[maxn],sum[maxn];<span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">solve</span><span class="hljs-params">()</span></span>&#123;f[<span class="hljs-number">0</span>]=f[<span class="hljs-number">1</span>]=f[<span class="hljs-number">2</span>]=<span class="hljs-number">0</span>;<span class="hljs-keyword">for</span>(ll i=<span class="hljs-number">3</span>;i&lt;=maxn<span class="hljs-number">-1</span>;i++)&#123;f[i]=(i<span class="hljs-number">-2</span>)*(i<span class="hljs-number">-1</span>)/<span class="hljs-number">2</span>;f[i]=(f[i]-(i-i/<span class="hljs-number">2</span><span class="hljs-number">-1</span>))/<span class="hljs-number">2</span>;sum[i]=sum[i<span class="hljs-number">-1</span>]+f[i];&#125;&#125;<span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span>&#123;ios::sync_with_stdio(<span class="hljs-literal">false</span>);solve();<span class="hljs-keyword">while</span>(<span class="hljs-built_in">cin</span>&gt;&gt;n&amp;&amp;n&gt;=<span class="hljs-number">3</span>)&#123;<span class="hljs-built_in">cout</span>&lt;&lt;sum[n]&lt;&lt;<span class="hljs-built_in">endl</span>;&#125;&#125;</code></pre><h1 id="收获与反思"><a href="#收获与反思" class="headerlink" title="收获与反思"></a>收获与反思</h1><ul><li>学习推导公式</li></ul>]]></content>
    
    
    <categories>
      
      <category>Computer Science</category>
      
      <category>ACM</category>
      
      <category>UVA</category>
      
    </categories>
    
    
    <tags>
      
      <tag>ACM</tag>
      
      <tag>UVA</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>【UVA-11538】解题报告（数学，组合数）</title>
    <link href="/post/89873dd3.html"/>
    <url>/post/89873dd3.html</url>
    
    <content type="html"><![CDATA[<h1 id="原始题目"><a href="#原始题目" class="headerlink" title="原始题目"></a>原始题目</h1><a id="more"></a><h1 id="题目大意"><a href="#题目大意" class="headerlink" title="题目大意"></a>题目大意</h1><p>在$n \times m$的棋盘上放置$2$个皇后（一黑一白），问相互攻击的情况共有多少种。</p><h1 id="解题思路"><a href="#解题思路" class="headerlink" title="解题思路"></a>解题思路</h1><ul><li><p>根据加法原理，总情况由下面三种子情况构成（覆盖全部切不重复）（n&lt;m)</p><p>  两个皇后在同一行，情况数为$nm(m-1)$</p><p>  两个皇后在同一列，情况数为$mn(n-1)$</p><p>  两个皇后在同一斜行，情况数为$2 \times (2 \sum_{i=1}^{n-1}{i(i-1)} + (m+1-n)n(n-1)) = 2 \times( (2  \frac {n(n-1)(2n-4)}{6} )+(m-n+1)n(n-1))$</p><p>  相加即可</p></li></ul><h1 id="解题代码"><a href="#解题代码" class="headerlink" title="解题代码"></a>解题代码</h1><pre><code class="hljs C++"><span class="hljs-meta">#<span class="hljs-meta-keyword">include</span> <span class="hljs-meta-string">&lt;cstdio&gt;</span></span><span class="hljs-meta">#<span class="hljs-meta-keyword">include</span> <span class="hljs-meta-string">&lt;cstring&gt;</span></span><span class="hljs-meta">#<span class="hljs-meta-keyword">include</span> <span class="hljs-meta-string">&lt;cmath&gt;</span></span><span class="hljs-meta">#<span class="hljs-meta-keyword">include</span> <span class="hljs-meta-string">&lt;iostream&gt;</span></span><span class="hljs-meta">#<span class="hljs-meta-keyword">include</span> <span class="hljs-meta-string">&lt;iomanip&gt;</span></span><span class="hljs-meta">#<span class="hljs-meta-keyword">include</span> <span class="hljs-meta-string">&lt;set&gt;</span></span><span class="hljs-meta">#<span class="hljs-meta-keyword">include</span> <span class="hljs-meta-string">&lt;queue&gt;</span></span><span class="hljs-meta">#<span class="hljs-meta-keyword">include</span> <span class="hljs-meta-string">&lt;map&gt;</span></span><span class="hljs-meta">#<span class="hljs-meta-keyword">include</span> <span class="hljs-meta-string">&lt;stack&gt;</span></span><span class="hljs-meta">#<span class="hljs-meta-keyword">include</span> <span class="hljs-meta-string">&lt;algorithm&gt;</span></span><span class="hljs-meta">#<span class="hljs-meta-keyword">include</span> <span class="hljs-meta-string">&lt;vector&gt;</span></span><span class="hljs-meta">#<span class="hljs-meta-keyword">include</span> <span class="hljs-meta-string">&lt;string&gt;</span></span><span class="hljs-meta">#<span class="hljs-meta-keyword">include</span> <span class="hljs-meta-string">&lt;sstream&gt;</span></span><span class="hljs-meta">#<span class="hljs-meta-keyword">define</span> rep(i,a,n) for(int i=a;i&lt;n;++i)</span><span class="hljs-meta">#<span class="hljs-meta-keyword">define</span> per(i,a,n) for(int i=n-a;i&gt;=a;--i)</span><span class="hljs-meta">#<span class="hljs-meta-keyword">define</span> se second</span><span class="hljs-meta">#<span class="hljs-meta-keyword">define</span> fi first</span><span class="hljs-meta">#<span class="hljs-meta-keyword">define</span> eps 1e-8</span><span class="hljs-meta">#<span class="hljs-meta-keyword">define</span> INF 0x3f3f3f3f</span><span class="hljs-keyword">using</span> <span class="hljs-keyword">namespace</span> <span class="hljs-built_in">std</span>;<span class="hljs-keyword">const</span> <span class="hljs-keyword">int</span> maxn=<span class="hljs-number">1e5</span>+<span class="hljs-number">5</span>;<span class="hljs-keyword">const</span> <span class="hljs-keyword">int</span> maxl=<span class="hljs-number">26</span>;<span class="hljs-keyword">const</span> <span class="hljs-keyword">int</span> maxm=<span class="hljs-number">1e5</span>+<span class="hljs-number">5</span>;<span class="hljs-keyword">typedef</span> <span class="hljs-keyword">long</span> <span class="hljs-keyword">long</span> ll;<span class="hljs-keyword">typedef</span> <span class="hljs-keyword">unsigned</span> <span class="hljs-keyword">long</span> <span class="hljs-keyword">long</span> ull;<span class="hljs-keyword">typedef</span> <span class="hljs-built_in">vector</span>&lt;<span class="hljs-keyword">int</span>&gt; vi;<span class="hljs-keyword">typedef</span> pair&lt;<span class="hljs-keyword">int</span>,<span class="hljs-keyword">int</span>&gt; pii;ll n,m;<span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span>&#123;ios::sync_with_stdio(<span class="hljs-literal">false</span>);<span class="hljs-keyword">while</span>(<span class="hljs-built_in">cin</span>&gt;&gt;n&gt;&gt;m&amp;&amp;n+m)&#123;<span class="hljs-keyword">if</span>(n&gt;m) swap(n,m);ll ans=(n*m*(m<span class="hljs-number">-1</span>) );ans+=(m*n*(n<span class="hljs-number">-1</span>));ans+=(<span class="hljs-number">2</span>*(n*(n<span class="hljs-number">-1</span>)*(<span class="hljs-number">2</span>*n<span class="hljs-number">-4</span>)/<span class="hljs-number">6</span>)+(m-n+<span class="hljs-number">1</span>)*n*(n<span class="hljs-number">-1</span>))*<span class="hljs-number">2</span>;<span class="hljs-built_in">cout</span>&lt;&lt;ans&lt;&lt;<span class="hljs-built_in">endl</span>;&#125;&#125;</code></pre><h1 id="收获与反思"><a href="#收获与反思" class="headerlink" title="收获与反思"></a>收获与反思</h1><ul><li>熟悉排列组合的加法原理与乘法原理</li><li>两个求和公式以及简单叠加</li></ul><script type="math/tex; mode=display">\sum {i=1}^n i = \frac {n(n+1)}{2}</script><script type="math/tex; mode=display">\sum {i=1}^n {i^2} = \frac {n(n+1)(2n+1)}{6}</script><p>推导出</p><script type="math/tex; mode=display">\sum {i=1}^n {i(i-1)} = \frac {n(n+1)(n-1)}{3}</script>]]></content>
    
    
    <categories>
      
      <category>Computer Science</category>
      
      <category>ACM</category>
      
      <category>UVA</category>
      
    </categories>
    
    
    <tags>
      
      <tag>ACM</tag>
      
      <tag>UVA</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>【HDU-1808】解题报告（数论，鸽巢定理）</title>
    <link href="/post/e583ed8d.html"/>
    <url>/post/e583ed8d.html</url>
    
    <content type="html"><![CDATA[<h1 id="原始题目"><a href="#原始题目" class="headerlink" title="原始题目"></a>原始题目</h1><h2 id="Halloween-treats"><a href="#Halloween-treats" class="headerlink" title="Halloween treats"></a>Halloween treats</h2><ul><li>Time Limit: 1000/1000 MS (Java/Others)    </li><li>Memory Limit: 32768/32768 K (Java/Others)</li><li>Total Submission(s): 1366    </li><li>Accepted Submission(s): 560</li><li>Special Judge</li></ul><h3 id="Problem-Description"><a href="#Problem-Description" class="headerlink" title="Problem Description"></a>Problem Description</h3><p>Every year there is the same problem at Halloween: Each neighbour is only willing to give a certain total number of sweets on that day, no matter how many children call on him, so it may happen that a child will get nothing if it is too late. To avoid conflicts, the children have decided they will put all sweets together and then divide them evenly among themselves. From last year’s experience of Halloween they know how many sweets they get from each neighbour. Since they care more about justice than about the number of sweets they get, they want to select a subset of the neighbours to visit, so that in sharing every child receives the same number of sweets. They will not be satisfied if they have any sweets left which cannot be divided. </p><p>Your job is to help the children and present a solution. </p><a id="more"></a><h3 id="Input"><a href="#Input" class="headerlink" title="Input"></a>Input</h3><p>The input contains several test cases. </p><p>The first line of each test case contains two integers c and n (1 ≤ c ≤ n ≤ 100000), the number of children and the number of neighbours, respectively. The next line contains n space separated integers a1 , … , an (1 ≤ ai ≤ 100000 ), where ai represents the number of sweets the children get if they visit neighbour i. </p><p>The last test case is followed by two zeros. </p><h3 id="Output"><a href="#Output" class="headerlink" title="Output"></a>Output</h3><p>For each test case output one line with the indices of the neighbours the children should select (here, index i corresponds to neighbour i who gives a total number of ai sweets). If there is no solution where each child gets at least one sweet, print “no sweets” instead. Note that if there are several solutions where each child gets at least one sweet, you may print any of them.</p><h3 id="Sample-Input"><a href="#Sample-Input" class="headerlink" title="Sample Input"></a>Sample Input</h3><pre><code>4 51 2 3 7 53 67 11 2 5 13 170 0</code></pre><h3 id="Sample-Output"><a href="#Sample-Output" class="headerlink" title="Sample Output"></a>Sample Output</h3><pre><code>3 52 3 4</code></pre><h3 id="Source"><a href="#Source" class="headerlink" title="Source"></a>Source</h3><p>HDOJ 2007 Summer Exercise（1）</p><h3 id="Recommend"><a href="#Recommend" class="headerlink" title="Recommend"></a>Recommend</h3><p>linle</p><h1 id="题目大意"><a href="#题目大意" class="headerlink" title="题目大意"></a>题目大意</h1><p>题目大意，万圣节孩子们去要糖果。给定孩子数$c$，和邻居数$n$，且$n&gt;c$。每个邻居家里有糖果$a_i$，孩子们希望能<br>找到一些家庭他们的糖果数恰好时能被$c$整除，问是否存在，不存在输出“no sweets”，存在的话输出邻居的编号。</p><h1 id="解题思路"><a href="#解题思路" class="headerlink" title="解题思路"></a>解题思路</h1><p>由于$n&gt;c$，求前缀和数组sum，对于严格单调增的n个前缀和，由于鸽巢原理，必然存在至少两个模c同余。</p><h1 id="解题代码"><a href="#解题代码" class="headerlink" title="解题代码"></a>解题代码</h1>]]></content>
    
    
    <categories>
      
      <category>Computer Science</category>
      
      <category>ACM</category>
      
      <category>HDU</category>
      
    </categories>
    
    
    <tags>
      
      <tag>ACM</tag>
      
      <tag>HDU</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>【UVA-12096】解题报告（STL，stack，模拟）</title>
    <link href="/post/a1cef007.html"/>
    <url>/post/a1cef007.html</url>
    
    <content type="html"><![CDATA[<h1 id="原始题目"><a href="#原始题目" class="headerlink" title="原始题目"></a>原始题目</h1><a id="more"></a><h1 id="题目大意"><a href="#题目大意" class="headerlink" title="题目大意"></a>题目大意</h1><p>有一个储存集合的栈，有五种操作。</p><ul><li>压入空集合</li><li>将栈顶集合复制再加入栈</li><li>出栈栈顶两个集合，取交集后入栈</li><li>出栈栈顶两个集合，取并集后入栈</li><li>出栈栈顶两个集合，将最顶端的集合加入到次顶的集合中</li></ul><p>给出操作，最后输出栈顶集合的元素个数。</p><h1 id="解题思路"><a href="#解题思路" class="headerlink" title="解题思路"></a>解题思路</h1><p>利用set的数据结构+模拟</p><ul><li>集合储存内部集合的编号，空集合就没有编号。</li><li>利用map把集合映射成ID，对于每个ADD操作后的新集合查找映射，没有就赋值。</li><li>模拟操作最后输出栈顶的size即可。</li></ul><h1 id="解题代码"><a href="#解题代码" class="headerlink" title="解题代码"></a>解题代码</h1><pre><code class="hljs C++"><span class="hljs-meta">#<span class="hljs-meta-keyword">include</span> <span class="hljs-meta-string">&lt;cstdio&gt;</span></span><span class="hljs-meta">#<span class="hljs-meta-keyword">include</span> <span class="hljs-meta-string">&lt;cstring&gt;</span></span><span class="hljs-meta">#<span class="hljs-meta-keyword">include</span> <span class="hljs-meta-string">&lt;cmath&gt;</span></span><span class="hljs-meta">#<span class="hljs-meta-keyword">include</span> <span class="hljs-meta-string">&lt;iostream&gt;</span></span><span class="hljs-meta">#<span class="hljs-meta-keyword">include</span> <span class="hljs-meta-string">&lt;iomanip&gt;</span></span><span class="hljs-meta">#<span class="hljs-meta-keyword">include</span> <span class="hljs-meta-string">&lt;set&gt;</span></span><span class="hljs-meta">#<span class="hljs-meta-keyword">include</span> <span class="hljs-meta-string">&lt;queue&gt;</span></span><span class="hljs-meta">#<span class="hljs-meta-keyword">include</span> <span class="hljs-meta-string">&lt;stack&gt;</span></span><span class="hljs-meta">#<span class="hljs-meta-keyword">include</span> <span class="hljs-meta-string">&lt;vector&gt;</span></span><span class="hljs-meta">#<span class="hljs-meta-keyword">include</span> <span class="hljs-meta-string">&lt;map&gt;</span></span><span class="hljs-meta">#<span class="hljs-meta-keyword">include</span> <span class="hljs-meta-string">&lt;string&gt;</span></span><span class="hljs-meta">#<span class="hljs-meta-keyword">include</span> <span class="hljs-meta-string">&lt;sstream&gt;</span></span><span class="hljs-meta">#<span class="hljs-meta-keyword">include</span> <span class="hljs-meta-string">&lt;bits/stdc++.h&gt;</span></span><span class="hljs-meta">#<span class="hljs-meta-keyword">define</span> rep(i,a,n) for(int i=a;i&lt;n;++i)</span><span class="hljs-meta">#<span class="hljs-meta-keyword">define</span> per(i,a,n) for(int i=n-1;i&gt;=a;--i);</span><span class="hljs-meta">#<span class="hljs-meta-keyword">define</span> ms(x,a) memset((x),a,sizeof((x))) </span><span class="hljs-meta">#<span class="hljs-meta-keyword">define</span> all(x) x.begin(),x.end()</span><span class="hljs-meta">#<span class="hljs-meta-keyword">define</span> ins(x) inserter(x,x.begin()) </span><span class="hljs-meta">#<span class="hljs-meta-keyword">define</span> INF 0x3f3f3f3f</span><span class="hljs-meta">#<span class="hljs-meta-keyword">define</span> eps 1e-8</span><span class="hljs-meta">#<span class="hljs-meta-keyword">define</span> fi first</span><span class="hljs-meta">#<span class="hljs-meta-keyword">define</span> e 2.718281828459045235360287471352662497757247093699959574966967627724076630353 </span><span class="hljs-meta">#<span class="hljs-meta-keyword">define</span> se second</span><span class="hljs-meta">#<span class="hljs-meta-keyword">define</span> mp make_pair</span><span class="hljs-meta">#<span class="hljs-meta-keyword">define</span> pb push_back</span><span class="hljs-meta">#<span class="hljs-meta-keyword">define</span> np next_permutation</span><span class="hljs-meta">#<span class="hljs-meta-keyword">define</span> gapline cout&lt;&lt;<span class="hljs-meta-string">"##======================##"</span>&lt;&lt;endl</span><span class="hljs-keyword">using</span> <span class="hljs-keyword">namespace</span> <span class="hljs-built_in">std</span>;<span class="hljs-keyword">const</span> <span class="hljs-keyword">int</span> maxn=<span class="hljs-number">1e5</span>+<span class="hljs-number">5</span>;<span class="hljs-keyword">const</span> <span class="hljs-keyword">int</span> maxl=<span class="hljs-number">26</span>;<span class="hljs-keyword">const</span> <span class="hljs-keyword">int</span> maxm=<span class="hljs-number">1e5</span>+<span class="hljs-number">5</span>;<span class="hljs-keyword">typedef</span> <span class="hljs-keyword">long</span> <span class="hljs-keyword">long</span> ll;<span class="hljs-keyword">typedef</span> <span class="hljs-keyword">unsigned</span> <span class="hljs-keyword">long</span> <span class="hljs-keyword">long</span> ull;<span class="hljs-keyword">typedef</span> <span class="hljs-built_in">set</span>&lt;<span class="hljs-keyword">int</span>&gt; si;<span class="hljs-built_in">map</span> &lt;si,<span class="hljs-keyword">int</span>&gt; IDcache; <span class="hljs-comment">//把集合映射成ID</span><span class="hljs-built_in">vector</span> &lt;si&gt; sicache;<span class="hljs-keyword">int</span> t,n;<span class="hljs-comment">// 查找给定集合x的ID。如果找不到，分配一个新的ID</span><span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">ID</span><span class="hljs-params">(si x)</span></span>&#123;<span class="hljs-keyword">if</span>(IDcache.count(x)) <span class="hljs-keyword">return</span> IDcache[x];sicache.pb(x); <span class="hljs-comment">//添加新的集合</span><span class="hljs-comment">//cout&lt;&lt;"new="&lt;&lt;sicache.size()-1&lt;&lt;endl;</span><span class="hljs-keyword">return</span> IDcache[x]=sicache.size()<span class="hljs-number">-1</span>; <span class="hljs-comment">//返回新的id  </span><span class="hljs-comment">// id 都是从 0 开始的 </span>&#125; <span class="hljs-built_in">stack</span> &lt;<span class="hljs-keyword">int</span>&gt; s;<span class="hljs-comment">//建立栈s，   里面储存不同集合的id</span><span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span>&#123;ios::sync_with_stdio(<span class="hljs-literal">false</span>);<span class="hljs-built_in">cin</span>&gt;&gt;t;<span class="hljs-keyword">while</span>(t--)&#123;<span class="hljs-keyword">while</span>(!s.empty()) s.pop();sicache.clear();IDcache.clear();<span class="hljs-built_in">cin</span>&gt;&gt;n;<span class="hljs-built_in">string</span> op;rep(i,<span class="hljs-number">0</span>,n)&#123;<span class="hljs-built_in">cin</span>&gt;&gt;op;<span class="hljs-keyword">if</span>(op[<span class="hljs-number">0</span>]==<span class="hljs-string">'P'</span>) s.push(ID(si()));  <span class="hljs-comment">//调用默认构造函数构造空集合，作为参数传给ID，判断有没有该集合，然后返回id </span><span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span>(op[<span class="hljs-number">0</span>]==<span class="hljs-string">'D'</span>) s.push(s.top()); <span class="hljs-comment">//复制一个添加到栈顶</span><span class="hljs-keyword">else</span>&#123;si x1=sicache[s.top()];s.pop();si x2=sicache[s.top()];s.pop();si x;<span class="hljs-comment">//cout&lt;&lt;"x1="&lt;&lt;ID(x1)&lt;&lt;"  x2="&lt;&lt;ID(x2)&lt;&lt;endl;</span><span class="hljs-keyword">if</span>(op[<span class="hljs-number">0</span>]==<span class="hljs-string">'U'</span>) set_union(all(x1),all(x2),ins(x));<span class="hljs-keyword">if</span>(op[<span class="hljs-number">0</span>]==<span class="hljs-string">'I'</span>) set_intersection(all(x1),all(x2),ins(x));<span class="hljs-keyword">if</span>(op[<span class="hljs-number">0</span>]==<span class="hljs-string">'A'</span>) &#123;x=x2;x.insert(ID(x1));&#125; s.push(ID(x));&#125; <span class="hljs-built_in">cout</span>&lt;&lt;sicache[s.top()].size()&lt;&lt;<span class="hljs-built_in">endl</span>;&#125;<span class="hljs-built_in">cout</span>&lt;&lt;<span class="hljs-string">"***"</span>&lt;&lt;<span class="hljs-built_in">endl</span>;&#125;&#125;</code></pre><h1 id="收获与反思"><a href="#收获与反思" class="headerlink" title="收获与反思"></a>收获与反思</h1><ul><li>紫书说思想很重要</li></ul>]]></content>
    
    
    <categories>
      
      <category>Computer Science</category>
      
      <category>ACM</category>
      
      <category>UVA</category>
      
    </categories>
    
    
    <tags>
      
      <tag>ACM</tag>
      
      <tag>UVA</tag>
      
      <tag>补图</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>【UVA-540】解题报告（STL，queue，模拟）</title>
    <link href="/post/686dc27c.html"/>
    <url>/post/686dc27c.html</url>
    
    <content type="html"><![CDATA[<h1 id="原始题目"><a href="#原始题目" class="headerlink" title="原始题目"></a>原始题目</h1><a id="more"></a><h1 id="题目大意"><a href="#题目大意" class="headerlink" title="题目大意"></a>题目大意</h1><p>团队队列，给定n个团队每个团队的人员，对于一个整体队列，有入队出队两种操作。</p><ul><li>入队：如果长队列中有将要入队成员的同团队成员，则该成员插入到同团队成员的最后方，如果没有，则插入整个队伍最后方。</li><li>出队：整体队列的队首人员出列。</li></ul><h1 id="解题思路"><a href="#解题思路" class="headerlink" title="解题思路"></a>解题思路</h1><ul><li>先map到自己的团队号。</li><li>建立不同团队的人员队列和团队队列（储存团队号），入队操作时检查本团队的人员队列是否为空，如果为空。<br>那么就在团队队列插入该成员的团队号，然后本队队列入队该成员。不为空的话只在本队队列入队即可。出队操作检查出队成员所在本队<br>队列是否为空，为空就在团队队列中也出队队伍号。</li></ul><h1 id="解题代码"><a href="#解题代码" class="headerlink" title="解题代码"></a>解题代码</h1><pre><code class="hljs C++"><span class="hljs-meta">#<span class="hljs-meta-keyword">include</span> <span class="hljs-meta-string">&lt;cstdio&gt;</span></span><span class="hljs-meta">#<span class="hljs-meta-keyword">include</span> <span class="hljs-meta-string">&lt;cstring&gt;</span></span><span class="hljs-meta">#<span class="hljs-meta-keyword">include</span> <span class="hljs-meta-string">&lt;cmath&gt;</span></span><span class="hljs-meta">#<span class="hljs-meta-keyword">include</span> <span class="hljs-meta-string">&lt;iostream&gt;</span></span><span class="hljs-meta">#<span class="hljs-meta-keyword">include</span> <span class="hljs-meta-string">&lt;iomanip&gt;</span></span><span class="hljs-meta">#<span class="hljs-meta-keyword">include</span> <span class="hljs-meta-string">&lt;set&gt;</span></span><span class="hljs-meta">#<span class="hljs-meta-keyword">include</span> <span class="hljs-meta-string">&lt;queue&gt;</span></span><span class="hljs-meta">#<span class="hljs-meta-keyword">include</span> <span class="hljs-meta-string">&lt;stack&gt;</span></span><span class="hljs-meta">#<span class="hljs-meta-keyword">include</span> <span class="hljs-meta-string">&lt;vector&gt;</span></span><span class="hljs-meta">#<span class="hljs-meta-keyword">include</span> <span class="hljs-meta-string">&lt;map&gt;</span></span><span class="hljs-meta">#<span class="hljs-meta-keyword">include</span> <span class="hljs-meta-string">&lt;string&gt;</span></span><span class="hljs-meta">#<span class="hljs-meta-keyword">include</span> <span class="hljs-meta-string">&lt;sstream&gt;</span></span><span class="hljs-meta">#<span class="hljs-meta-keyword">include</span> <span class="hljs-meta-string">&lt;bits/stdc++.h&gt;</span></span><span class="hljs-meta">#<span class="hljs-meta-keyword">define</span> rep(i,a,n) for(int i=a;i&lt;n;++i)</span><span class="hljs-meta">#<span class="hljs-meta-keyword">define</span> per(i,a,n) for(int i=n-1;i&gt;=a;--i);</span><span class="hljs-meta">#<span class="hljs-meta-keyword">define</span> ms(x,a) memset((x),a,sizeof((x))) </span><span class="hljs-meta">#<span class="hljs-meta-keyword">define</span> all(x) x.begin(),x.end()</span><span class="hljs-meta">#<span class="hljs-meta-keyword">define</span> ins(x) inserter(x,x.begin()) </span><span class="hljs-meta">#<span class="hljs-meta-keyword">define</span> INF 0x3f3f3f3f</span><span class="hljs-meta">#<span class="hljs-meta-keyword">define</span> eps 1e-8</span><span class="hljs-meta">#<span class="hljs-meta-keyword">define</span> fi first</span><span class="hljs-meta">#<span class="hljs-meta-keyword">define</span> e 2.718281828459045235360287471352662497757247093699959574966967627724076630353 </span><span class="hljs-meta">#<span class="hljs-meta-keyword">define</span> se second</span><span class="hljs-meta">#<span class="hljs-meta-keyword">define</span> mp make_pair</span><span class="hljs-meta">#<span class="hljs-meta-keyword">define</span> pb push_back</span><span class="hljs-meta">#<span class="hljs-meta-keyword">define</span> np next_permutation</span><span class="hljs-meta">#<span class="hljs-meta-keyword">define</span> gapline cout&lt;&lt;<span class="hljs-meta-string">"##======================##"</span>&lt;&lt;endl</span><span class="hljs-keyword">using</span> <span class="hljs-keyword">namespace</span> <span class="hljs-built_in">std</span>;<span class="hljs-keyword">const</span> <span class="hljs-keyword">int</span> maxn=<span class="hljs-number">1e3</span>+<span class="hljs-number">5</span>;<span class="hljs-keyword">const</span> <span class="hljs-keyword">int</span> maxl=<span class="hljs-number">26</span>;<span class="hljs-keyword">const</span> <span class="hljs-keyword">int</span> maxm=<span class="hljs-number">1e5</span>+<span class="hljs-number">5</span>;<span class="hljs-keyword">typedef</span> <span class="hljs-keyword">long</span> <span class="hljs-keyword">long</span> ll;<span class="hljs-keyword">typedef</span> <span class="hljs-keyword">unsigned</span> <span class="hljs-keyword">long</span> <span class="hljs-keyword">long</span> ull;<span class="hljs-comment">//团体队列  一个q储存团体序号， q2[i]表示i团体内的队列 </span><span class="hljs-comment">// 出队时  q2[q[front]] 为空时 q.pop();</span><span class="hljs-comment">// 入队时  q2[mp[number]]非空时直接插队尾，  空时  插队尾同时q.push(mp[number]) </span><span class="hljs-keyword">int</span> t,n,kase;<span class="hljs-built_in">map</span>&lt;<span class="hljs-keyword">int</span>,<span class="hljs-keyword">int</span>&gt; mmp;<span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span>&#123;ios::sync_with_stdio(<span class="hljs-literal">false</span>);<span class="hljs-keyword">while</span>(<span class="hljs-built_in">cin</span>&gt;&gt;t&amp;&amp;t)&#123;<span class="hljs-built_in">cout</span>&lt;&lt;<span class="hljs-string">"Scenario #"</span>&lt;&lt;++kase&lt;&lt;<span class="hljs-built_in">endl</span>;mmp.clear();<span class="hljs-keyword">int</span> x;rep(i,<span class="hljs-number">0</span>,t)&#123;<span class="hljs-built_in">cin</span>&gt;&gt;n;rep(j,<span class="hljs-number">0</span>,n)&#123;<span class="hljs-built_in">cin</span>&gt;&gt;x;mmp[x]=i;&#125;&#125;<span class="hljs-built_in">queue</span>&lt;<span class="hljs-keyword">int</span>&gt; q,q2[maxn];<span class="hljs-comment">//q为团队队列   q2[i] 为i团队队内队列</span><span class="hljs-built_in">string</span> c;<span class="hljs-keyword">while</span>(<span class="hljs-built_in">cin</span>&gt;&gt;c &amp;&amp; c[<span class="hljs-number">0</span>]!=<span class="hljs-string">'S'</span>)&#123;<span class="hljs-keyword">if</span>(c[<span class="hljs-number">0</span>]==<span class="hljs-string">'E'</span>)&#123;<span class="hljs-built_in">cin</span>&gt;&gt;x;<span class="hljs-keyword">int</span> id=mmp[x];<span class="hljs-keyword">if</span>(q2[id].empty())&#123;q.push(id);&#125;q2[id].push(x);&#125;<span class="hljs-keyword">else</span>&#123;<span class="hljs-keyword">int</span> num=q2[q.front()].front();<span class="hljs-built_in">cout</span>&lt;&lt;num&lt;&lt;<span class="hljs-built_in">endl</span>;q2[q.front()].pop();<span class="hljs-keyword">if</span>(q2[q.front()].empty()) q.pop();&#125;&#125; <span class="hljs-built_in">cout</span>&lt;&lt;<span class="hljs-built_in">endl</span>;&#125;&#125;</code></pre><h1 id="收获与反思"><a href="#收获与反思" class="headerlink" title="收获与反思"></a>收获与反思</h1><p>合理利用已有的数据结构</p>]]></content>
    
    
    <categories>
      
      <category>Computer Science</category>
      
      <category>ACM</category>
      
      <category>UVA</category>
      
    </categories>
    
    
    <tags>
      
      <tag>ACM</tag>
      
      <tag>UVA</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>【UVA-136】解题报告（STL，set，优先队列）</title>
    <link href="/post/1b7db6f0.html"/>
    <url>/post/1b7db6f0.html</url>
    
    <content type="html"><![CDATA[<h1 id="原始题目"><a href="#原始题目" class="headerlink" title="原始题目"></a>原始题目</h1><a id="more"></a><h1 id="题目大意"><a href="#题目大意" class="headerlink" title="题目大意"></a>题目大意</h1><p>因子只包含2，3，5的称为丑数，打印第1500个丑数。</p><h1 id="解题思路"><a href="#解题思路" class="headerlink" title="解题思路"></a>解题思路</h1><ul><li>优先队列维护，每次拓展2，3，5添加到优先队列中。</li></ul><h1 id="解题代码"><a href="#解题代码" class="headerlink" title="解题代码"></a>解题代码</h1><pre><code class="hljs C++"><span class="hljs-meta">#<span class="hljs-meta-keyword">include</span> <span class="hljs-meta-string">&lt;cstdio&gt;</span></span><span class="hljs-meta">#<span class="hljs-meta-keyword">include</span> <span class="hljs-meta-string">&lt;cstring&gt;</span></span><span class="hljs-meta">#<span class="hljs-meta-keyword">include</span> <span class="hljs-meta-string">&lt;cmath&gt;</span></span><span class="hljs-meta">#<span class="hljs-meta-keyword">include</span> <span class="hljs-meta-string">&lt;iostream&gt;</span></span><span class="hljs-meta">#<span class="hljs-meta-keyword">include</span> <span class="hljs-meta-string">&lt;iomanip&gt;</span></span><span class="hljs-meta">#<span class="hljs-meta-keyword">include</span> <span class="hljs-meta-string">&lt;set&gt;</span></span><span class="hljs-meta">#<span class="hljs-meta-keyword">include</span> <span class="hljs-meta-string">&lt;queue&gt;</span></span><span class="hljs-meta">#<span class="hljs-meta-keyword">include</span> <span class="hljs-meta-string">&lt;stack&gt;</span></span><span class="hljs-meta">#<span class="hljs-meta-keyword">include</span> <span class="hljs-meta-string">&lt;vector&gt;</span></span><span class="hljs-meta">#<span class="hljs-meta-keyword">include</span> <span class="hljs-meta-string">&lt;map&gt;</span></span><span class="hljs-meta">#<span class="hljs-meta-keyword">include</span> <span class="hljs-meta-string">&lt;string&gt;</span></span><span class="hljs-meta">#<span class="hljs-meta-keyword">include</span> <span class="hljs-meta-string">&lt;sstream&gt;</span></span><span class="hljs-meta">#<span class="hljs-meta-keyword">include</span> <span class="hljs-meta-string">&lt;bits/stdc++.h&gt;</span></span><span class="hljs-meta">#<span class="hljs-meta-keyword">define</span> rep(i,a,n) for(int i=a;i&lt;n;++i)</span><span class="hljs-meta">#<span class="hljs-meta-keyword">define</span> per(i,a,n) for(int i=n-1;i&gt;=a;--i);</span><span class="hljs-meta">#<span class="hljs-meta-keyword">define</span> ms(x,a) memset((x),a,sizeof((x))) </span><span class="hljs-meta">#<span class="hljs-meta-keyword">define</span> all(x) x.begin(),x.end()</span><span class="hljs-meta">#<span class="hljs-meta-keyword">define</span> ins(x) inserter(x,x.begin()) </span><span class="hljs-meta">#<span class="hljs-meta-keyword">define</span> INF 0x3f3f3f3f</span><span class="hljs-meta">#<span class="hljs-meta-keyword">define</span> eps 1e-8</span><span class="hljs-meta">#<span class="hljs-meta-keyword">define</span> fi first</span><span class="hljs-meta">#<span class="hljs-meta-keyword">define</span> e 2.718281828459045235360287471352662497757247093699959574966967627724076630353 </span><span class="hljs-meta">#<span class="hljs-meta-keyword">define</span> se second</span><span class="hljs-meta">#<span class="hljs-meta-keyword">define</span> mp make_pair</span><span class="hljs-meta">#<span class="hljs-meta-keyword">define</span> pb push_back</span><span class="hljs-meta">#<span class="hljs-meta-keyword">define</span> np next_permutation</span><span class="hljs-meta">#<span class="hljs-meta-keyword">define</span> gapline cout&lt;&lt;<span class="hljs-meta-string">"##======================##"</span>&lt;&lt;endl</span><span class="hljs-keyword">using</span> <span class="hljs-keyword">namespace</span> <span class="hljs-built_in">std</span>;<span class="hljs-keyword">const</span> <span class="hljs-keyword">int</span> maxn=<span class="hljs-number">1e5</span>+<span class="hljs-number">5</span>;<span class="hljs-keyword">typedef</span> <span class="hljs-keyword">long</span> <span class="hljs-keyword">long</span> ll;<span class="hljs-keyword">const</span> <span class="hljs-keyword">int</span> coeff[<span class="hljs-number">3</span>]=&#123;<span class="hljs-number">2</span>,<span class="hljs-number">3</span>,<span class="hljs-number">5</span>&#125;;<span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span>&#123;priority_queue&lt;ll,<span class="hljs-built_in">vector</span>&lt;ll&gt;, greater&lt;ll&gt; &gt; pq;<span class="hljs-built_in">set</span>&lt;ll&gt;s;pq.push(<span class="hljs-number">1</span>);s.insert(<span class="hljs-number">1</span>);<span class="hljs-keyword">for</span>(<span class="hljs-keyword">int</span> i=<span class="hljs-number">1</span>;;i++)&#123;ll x=pq.top();pq.pop();<span class="hljs-keyword">if</span>(i==<span class="hljs-number">1500</span>)&#123;<span class="hljs-built_in">cout</span>&lt;&lt;<span class="hljs-string">"The 1500'th ugly number is "</span>&lt;&lt;x&lt;&lt;<span class="hljs-string">".\n"</span>;<span class="hljs-keyword">break</span>;&#125; rep(j,<span class="hljs-number">0</span>,<span class="hljs-number">3</span>)&#123;ll x2=coeff[j]*x;<span class="hljs-keyword">if</span>(!s.count(x2)) &#123;pq.push(x2);s.insert(x2);&#125;&#125;&#125;&#125;</code></pre><h1 id="收获与反思"><a href="#收获与反思" class="headerlink" title="收获与反思"></a>收获与反思</h1><ul><li>水题</li></ul>]]></content>
    
    
    <categories>
      
      <category>Computer Science</category>
      
      <category>ACM</category>
      
      <category>UVA</category>
      
    </categories>
    
    
    <tags>
      
      <tag>ACM</tag>
      
      <tag>UVA</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>【UVA-156】解题报告（STL，map）</title>
    <link href="/post/eb9ab36.html"/>
    <url>/post/eb9ab36.html</url>
    
    <content type="html"><![CDATA[<h1 id="原始题目"><a href="#原始题目" class="headerlink" title="原始题目"></a>原始题目</h1><a id="more"></a><h1 id="题目大意"><a href="#题目大意" class="headerlink" title="题目大意"></a>题目大意</h1><p>输入一些单词，找出所有满足下列条件的单词：不区分大小写后不能通过重排得到文本中另一个单词。<br>，按字典序输出复合条件的原单词。</p><h1 id="解题思路"><a href="#解题思路" class="headerlink" title="解题思路"></a>解题思路</h1><ul><li>利用set储存每个输入单词（自动按字典序排序），将每个单词标准化后其映射值+1。</li><li>遍历set输出标准化后映射值为1（只出现过一次）的单词。</li></ul><h1 id="解题代码"><a href="#解题代码" class="headerlink" title="解题代码"></a>解题代码</h1><pre><code class="hljs C++"><span class="hljs-meta">#<span class="hljs-meta-keyword">include</span> <span class="hljs-meta-string">&lt;cstdio&gt;</span></span><span class="hljs-meta">#<span class="hljs-meta-keyword">include</span> <span class="hljs-meta-string">&lt;cstring&gt;</span></span><span class="hljs-meta">#<span class="hljs-meta-keyword">include</span> <span class="hljs-meta-string">&lt;cmath&gt;</span></span><span class="hljs-meta">#<span class="hljs-meta-keyword">include</span> <span class="hljs-meta-string">&lt;iostream&gt;</span></span><span class="hljs-meta">#<span class="hljs-meta-keyword">include</span> <span class="hljs-meta-string">&lt;iomanip&gt;</span></span><span class="hljs-meta">#<span class="hljs-meta-keyword">include</span> <span class="hljs-meta-string">&lt;set&gt;</span></span><span class="hljs-meta">#<span class="hljs-meta-keyword">include</span> <span class="hljs-meta-string">&lt;queue&gt;</span></span><span class="hljs-meta">#<span class="hljs-meta-keyword">include</span> <span class="hljs-meta-string">&lt;stack&gt;</span></span><span class="hljs-meta">#<span class="hljs-meta-keyword">include</span> <span class="hljs-meta-string">&lt;vector&gt;</span></span><span class="hljs-meta">#<span class="hljs-meta-keyword">include</span> <span class="hljs-meta-string">&lt;string&gt;</span></span><span class="hljs-meta">#<span class="hljs-meta-keyword">include</span> <span class="hljs-meta-string">&lt;sstream&gt;</span></span><span class="hljs-meta">#<span class="hljs-meta-keyword">include</span> <span class="hljs-meta-string">&lt;bits/stdc++.h&gt;</span></span><span class="hljs-meta">#<span class="hljs-meta-keyword">define</span> rep(i,a,n) for(int i=a;i&lt;n;++i)</span><span class="hljs-meta">#<span class="hljs-meta-keyword">define</span> per(i,a,n) for(int i=n-1;i&gt;=a;--i);</span><span class="hljs-meta">#<span class="hljs-meta-keyword">define</span> ms(x,a) memset((x),a,sizeof((x))) </span><span class="hljs-meta">#<span class="hljs-meta-keyword">define</span> INF 0x3f3f3f3f</span><span class="hljs-meta">#<span class="hljs-meta-keyword">define</span> eps 1e-8</span><span class="hljs-meta">#<span class="hljs-meta-keyword">define</span> fi first</span><span class="hljs-meta">#<span class="hljs-meta-keyword">define</span> e 2.718281828459045235360287471352662497757247093699959574966967627724076630353 </span><span class="hljs-meta">#<span class="hljs-meta-keyword">define</span> se second</span><span class="hljs-meta">#<span class="hljs-meta-keyword">define</span> mp make_pair</span><span class="hljs-meta">#<span class="hljs-meta-keyword">define</span> pb push_back</span><span class="hljs-meta">#<span class="hljs-meta-keyword">define</span> np next_permutation</span><span class="hljs-meta">#<span class="hljs-meta-keyword">define</span> gapline cout&lt;&lt;<span class="hljs-meta-string">"##======================##"</span>&lt;&lt;endl</span><span class="hljs-keyword">using</span> <span class="hljs-keyword">namespace</span> <span class="hljs-built_in">std</span>;<span class="hljs-keyword">const</span> <span class="hljs-keyword">int</span> maxn=<span class="hljs-number">1e5</span>+<span class="hljs-number">5</span>;<span class="hljs-keyword">const</span> <span class="hljs-keyword">int</span> maxl=<span class="hljs-number">26</span>;<span class="hljs-keyword">const</span> <span class="hljs-keyword">int</span> maxm=<span class="hljs-number">1e5</span>+<span class="hljs-number">5</span>;<span class="hljs-built_in">string</span> s;<span class="hljs-built_in">set</span>&lt;<span class="hljs-built_in">string</span>&gt; ans;<span class="hljs-built_in">map</span>&lt;<span class="hljs-built_in">string</span>,<span class="hljs-keyword">int</span>&gt; mmp;<span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span>&#123;ios::sync_with_stdio(<span class="hljs-literal">false</span>);<span class="hljs-keyword">while</span>(<span class="hljs-built_in">cin</span>&gt;&gt;s&amp;&amp;s[<span class="hljs-number">0</span>]!=<span class="hljs-string">'#'</span>)&#123;ans.insert(s);<span class="hljs-built_in">string</span> temp=s;rep(i,<span class="hljs-number">0</span>,temp.length())&#123;<span class="hljs-keyword">if</span>(<span class="hljs-built_in">isupper</span>(temp[i])) temp[i]=temp[i]-<span class="hljs-string">'A'</span>+<span class="hljs-string">'a'</span>;&#125;sort(temp.begin(),temp.end());mmp[temp]++;&#125;<span class="hljs-built_in">set</span>&lt;<span class="hljs-built_in">string</span>&gt;::iterator it;<span class="hljs-keyword">for</span>(it=ans.begin();it!=ans.end();it++)&#123;<span class="hljs-built_in">string</span> temp=*it;rep(i,<span class="hljs-number">0</span>,temp.length())&#123;<span class="hljs-keyword">if</span>(<span class="hljs-built_in">isupper</span>(temp[i])) temp[i]=temp[i]-<span class="hljs-string">'A'</span>+<span class="hljs-string">'a'</span>;&#125;sort(temp.begin(),temp.end());<span class="hljs-keyword">if</span>(mmp[temp]==<span class="hljs-number">1</span>) <span class="hljs-built_in">cout</span>&lt;&lt;*it&lt;&lt;<span class="hljs-built_in">endl</span>;&#125;&#125;</code></pre><h1 id="收获与反思"><a href="#收获与反思" class="headerlink" title="收获与反思"></a>收获与反思</h1><ul><li>寒假入门的时候做过，现在回来再快速秒之</li></ul>]]></content>
    
    
    <categories>
      
      <category>Computer Science</category>
      
      <category>ACM</category>
      
      <category>UVA</category>
      
    </categories>
    
    
    <tags>
      
      <tag>ACM</tag>
      
      <tag>UVA</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>【HDU-2048】解题报告（递推，DP，数论，错排）</title>
    <link href="/post/184fc5c7.html"/>
    <url>/post/184fc5c7.html</url>
    
    <content type="html"><![CDATA[<h1 id="原始题目"><a href="#原始题目" class="headerlink" title="原始题目"></a>原始题目</h1><h2 id="神、上帝以及老天爷"><a href="#神、上帝以及老天爷" class="headerlink" title="神、上帝以及老天爷"></a>神、上帝以及老天爷</h2><ul><li>Time Limit: 2000/1000 MS (Java/Others)    </li><li>Memory Limit: 65536/32768 K (Java/Others)</li><li>Total Submission(s): 50425    </li><li>Accepted Submission(s): 20379</li></ul><h3 id="Problem-Description"><a href="#Problem-Description" class="headerlink" title="Problem Description"></a>Problem Description</h3><p>HDU 2006’10 ACM contest的颁奖晚会隆重开始了！<br>为了活跃气氛，组织者举行了一个别开生面、奖品丰厚的抽奖活动，这个活动的具体要求是这样的：</p><p>首先，所有参加晚会的人员都将一张写有自己名字的字条放入抽奖箱中；<br>然后，待所有字条加入完毕，每人从箱中取一个字条；<br>最后，如果取得的字条上写的就是自己的名字，那么“恭喜你，中奖了！”<br><a id="more"></a><br>大家可以想象一下当时的气氛之热烈，毕竟中奖者的奖品是大家梦寐以求的Twins签名照呀！不过，正如所有试图设计的喜剧往往以悲剧结尾，这次抽奖活动最后竟然没有一个人中奖！</p><p>我的神、上帝以及老天爷呀，怎么会这样呢？</p><p>不过，先不要激动，现在问题来了，你能计算一下发生这种情况的概率吗？</p><p>不会算？难道你也想以悲剧结尾？！</p><h3 id="Input"><a href="#Input" class="headerlink" title="Input"></a>Input</h3><p>输入数据的第一行是一个整数C,表示测试实例的个数，然后是C 行数据，每行包含一个整数$n(1&lt;n≤20)$,表示参加抽奖的人数。</p><h3 id="Output"><a href="#Output" class="headerlink" title="Output"></a>Output</h3><p>对于每个测试实例，请输出发生这种情况的百分比，每个实例的输出占一行, 结果保留两位小数(四舍五入)，具体格式请参照sample output。</p><h3 id="Sample-Input"><a href="#Sample-Input" class="headerlink" title="Sample Input"></a>Sample Input</h3><pre><code>12</code></pre><h3 id="Sample-Output"><a href="#Sample-Output" class="headerlink" title="Sample Output"></a>Sample Output</h3><pre><code>50.00%</code></pre><h3 id="Author"><a href="#Author" class="headerlink" title="Author"></a>Author</h3><p>lcy</p><h3 id="Source"><a href="#Source" class="headerlink" title="Source"></a>Source</h3><p>递推求解专题练习（For Beginner）</p><h3 id="Recommend"><a href="#Recommend" class="headerlink" title="Recommend"></a>Recommend</h3><p>lcy</p><h1 id="题目大意"><a href="#题目大意" class="headerlink" title="题目大意"></a>题目大意</h1><p>如题</p><h1 id="解题思路"><a href="#解题思路" class="headerlink" title="解题思路"></a>解题思路</h1><ul><li><p>DP</p><p>  手动写一下如何安排参加人员都不中奖就可以发现规律。$D[i]$表示i个人符合要求的方案数目</p><p>  比如计算dp[4]时，将1的纸条分给2或3或4，这三种情况下，可以变为解决子问题，比如将1的纸条分给2，之后将2、3、4的纸条分给1、3、4，与dp[3]接近，但是1位置不受限制，即1位置可以放2的纸条，这样又变为dp[2]。</p><p>  故得到状态转移方程。</p><script type="math/tex; mode=display">D[n]=(n-1)(D[n-1]+D[n-2])</script><p>  最后除以总情况数（排列），计算百分数即可。</p></li><li><p>错排公式</p><p>  其实本题是一个错排公式题目，我们上面推导出来的$ D[i]=(i-1)(D[i-1]+D[i-2]) $，实际上就是错排公式的一个递推关系。</p><p>  又因为$D[1]=0,D[2]=1$ 继续推导</p><script type="math/tex; mode=display">  \begin{align}  D[n] & =(n-1)(D[n-1]+D[n-2]) \\  D[n] - n D[n-1] & = (-1) (D[n-1] - (n-1) D[n-2])\\  D[n] - n D[n-1] & = (-1)^{n-2} (D[2] - 2 D[1]) \\  D[n] & = n D[n-1] + (-1)^{n}  \end{align}</script><p>  如此我们得到了递推关系式，那么求通项公式可以用下面几种方法：</p><ul><li><p>可以用母函数方法求出通项公式（还不会，待学了母函数填坑）</p></li><li><p>可以用容斥原理</p><p>最后得到错排公式为</p><script type="math/tex; mode=display">D[n] = n!( \frac{1}{0!} - \frac{1}{1!} + \frac{1}{2!} - \cdots (-1)^{n} \frac{1}{n!} )</script></li></ul></li><li><p>再补充</p><p>  简化公式</p><script type="math/tex; mode=display">D(n) = [ \frac{n!}{e} + 0.5 ]</script><p>  证明相见百度，e是自然对数的底，[x]为x的整数部分。</p></li></ul><h1 id="解题代码"><a href="#解题代码" class="headerlink" title="解题代码"></a>解题代码</h1><ul><li><p>DP</p>  <pre><code class="hljs C++"><span class="hljs-meta">#<span class="hljs-meta-keyword">include</span> <span class="hljs-meta-string">&lt;cstdio&gt;</span></span><span class="hljs-meta">#<span class="hljs-meta-keyword">include</span> <span class="hljs-meta-string">&lt;cstring&gt;</span></span><span class="hljs-meta">#<span class="hljs-meta-keyword">include</span> <span class="hljs-meta-string">&lt;iostream&gt;</span></span><span class="hljs-meta">#<span class="hljs-meta-keyword">include</span> <span class="hljs-meta-string">&lt;set&gt;</span></span><span class="hljs-meta">#<span class="hljs-meta-keyword">include</span> <span class="hljs-meta-string">&lt;algorithm&gt;</span></span><span class="hljs-meta">#<span class="hljs-meta-keyword">include</span> <span class="hljs-meta-string">&lt;queue&gt;</span></span><span class="hljs-meta">#<span class="hljs-meta-keyword">include</span> <span class="hljs-meta-string">&lt;map&gt;</span></span><span class="hljs-meta">#<span class="hljs-meta-keyword">include</span> <span class="hljs-meta-string">&lt;string&gt;</span></span><span class="hljs-meta">#<span class="hljs-meta-keyword">define</span> eps 1e-8</span><span class="hljs-meta">#<span class="hljs-meta-keyword">define</span> INF 0x3f3f3f3f</span><span class="hljs-meta">#<span class="hljs-meta-keyword">define</span> rep(i,a,n) for(int i=a;i&lt;n;i++)</span><span class="hljs-meta">#<span class="hljs-meta-keyword">define</span> per(i,a,n) for(int i=n-1;i&gt;=a;i--)</span><span class="hljs-keyword">using</span> <span class="hljs-keyword">namespace</span> <span class="hljs-built_in">std</span>;<span class="hljs-keyword">const</span> <span class="hljs-keyword">int</span> maxn=<span class="hljs-number">1e5</span>+<span class="hljs-number">5</span>;<span class="hljs-keyword">typedef</span> <span class="hljs-keyword">long</span> <span class="hljs-keyword">long</span> ll;ll dp[maxn],A[maxn];<span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">solve</span><span class="hljs-params">()</span></span>&#123;<span class="hljs-built_in">memset</span>(dp,<span class="hljs-number">0</span>,<span class="hljs-keyword">sizeof</span>(dp));dp[<span class="hljs-number">1</span>]=<span class="hljs-number">0</span>;dp[<span class="hljs-number">2</span>]=<span class="hljs-number">1</span>;A[<span class="hljs-number">1</span>]=<span class="hljs-number">1</span>;A[<span class="hljs-number">2</span>]=<span class="hljs-number">2</span>;<span class="hljs-keyword">for</span>(ll i=<span class="hljs-number">3</span>;i&lt;=<span class="hljs-number">20</span>;i++)&#123;dp[i]=(i<span class="hljs-number">-1</span>)*(dp[i<span class="hljs-number">-1</span>]+dp[i<span class="hljs-number">-2</span>]);A[i]=A[i<span class="hljs-number">-1</span>]*i; <span class="hljs-comment">//cout&lt;&lt;dp[i]&lt;&lt;"  "&lt;&lt;A[i]&lt;&lt;endl;</span>&#125;&#125;<span class="hljs-keyword">using</span> <span class="hljs-keyword">namespace</span> <span class="hljs-built_in">std</span>;<span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span>&#123;<span class="hljs-keyword">int</span> t;solve();<span class="hljs-keyword">while</span>(<span class="hljs-built_in">cin</span>&gt;&gt;t)&#123;rep(i,<span class="hljs-number">0</span>,t)&#123;ll a;<span class="hljs-built_in">cin</span>&gt;&gt;a;<span class="hljs-keyword">double</span> ans=(<span class="hljs-keyword">double</span>)dp[a]/(<span class="hljs-keyword">double</span>)A[a];<span class="hljs-comment">//cout&lt;&lt;"dp[i]"&lt;&lt;dp[a]&lt;&lt;" "&lt;&lt;"A[i]"&lt;&lt;A[a]&lt;&lt;endl;</span><span class="hljs-built_in">printf</span>(<span class="hljs-string">"%.2lf%%\n"</span>,ans*<span class="hljs-number">100</span>); &#125;&#125;&#125;</code></pre></li></ul><ul><li><p>错排简化公式</p>  <pre><code class="hljs C++"><span class="hljs-meta">#<span class="hljs-meta-keyword">include</span> <span class="hljs-meta-string">&lt;cstdio&gt;</span></span><span class="hljs-meta">#<span class="hljs-meta-keyword">include</span> <span class="hljs-meta-string">&lt;cstring&gt;</span></span><span class="hljs-meta">#<span class="hljs-meta-keyword">include</span> <span class="hljs-meta-string">&lt;cmath&gt;</span></span><span class="hljs-meta">#<span class="hljs-meta-keyword">include</span> <span class="hljs-meta-string">&lt;iostream&gt;</span></span><span class="hljs-meta">#<span class="hljs-meta-keyword">include</span> <span class="hljs-meta-string">&lt;iomanip&gt;</span></span><span class="hljs-meta">#<span class="hljs-meta-keyword">include</span> <span class="hljs-meta-string">&lt;set&gt;</span></span><span class="hljs-meta">#<span class="hljs-meta-keyword">include</span> <span class="hljs-meta-string">&lt;queue&gt;</span></span><span class="hljs-meta">#<span class="hljs-meta-keyword">include</span> <span class="hljs-meta-string">&lt;stack&gt;</span></span><span class="hljs-meta">#<span class="hljs-meta-keyword">include</span> <span class="hljs-meta-string">&lt;vector&gt;</span></span><span class="hljs-meta">#<span class="hljs-meta-keyword">include</span> <span class="hljs-meta-string">&lt;string&gt;</span></span><span class="hljs-meta">#<span class="hljs-meta-keyword">include</span> <span class="hljs-meta-string">&lt;sstream&gt;</span></span><span class="hljs-meta">#<span class="hljs-meta-keyword">include</span> <span class="hljs-meta-string">&lt;bits/stdc++.h&gt;</span></span><span class="hljs-meta">#<span class="hljs-meta-keyword">define</span> rep(i,a,n) for(int i=a;i&lt;n;++i)</span><span class="hljs-meta">#<span class="hljs-meta-keyword">define</span> per(i,a,n) for(int i=n-1;i&gt;=a;--i);</span><span class="hljs-meta">#<span class="hljs-meta-keyword">define</span> ms(x,a) memset((x),a,sizeof((x))) </span><span class="hljs-meta">#<span class="hljs-meta-keyword">define</span> INF 0x3f3f3f3f</span><span class="hljs-meta">#<span class="hljs-meta-keyword">define</span> eps 1e-8</span><span class="hljs-meta">#<span class="hljs-meta-keyword">define</span> fi first</span><span class="hljs-meta">#<span class="hljs-meta-keyword">define</span> e 2.718281828459045235360287471352662497757247093699959574966967627724076630353 </span><span class="hljs-meta">#<span class="hljs-meta-keyword">define</span> se second</span><span class="hljs-meta">#<span class="hljs-meta-keyword">define</span> mp make_pair</span><span class="hljs-meta">#<span class="hljs-meta-keyword">define</span> pb push_back</span><span class="hljs-meta">#<span class="hljs-meta-keyword">define</span> np next_permutation</span><span class="hljs-meta">#<span class="hljs-meta-keyword">define</span> gapline cout&lt;&lt;<span class="hljs-meta-string">"##======================##"</span>&lt;&lt;endl</span><span class="hljs-keyword">using</span> <span class="hljs-keyword">namespace</span> <span class="hljs-built_in">std</span>;<span class="hljs-keyword">const</span> <span class="hljs-keyword">int</span> maxn=<span class="hljs-number">1e5</span>+<span class="hljs-number">5</span>;<span class="hljs-keyword">const</span> <span class="hljs-keyword">int</span> maxl=<span class="hljs-number">26</span>;<span class="hljs-keyword">const</span> <span class="hljs-keyword">int</span> maxm=<span class="hljs-number">1e5</span>+<span class="hljs-number">5</span>;<span class="hljs-keyword">typedef</span> <span class="hljs-keyword">long</span> <span class="hljs-keyword">long</span> ll;<span class="hljs-keyword">typedef</span> <span class="hljs-keyword">unsigned</span> <span class="hljs-keyword">long</span> <span class="hljs-keyword">long</span> ull;<span class="hljs-keyword">typedef</span> <span class="hljs-built_in">vector</span>&lt;<span class="hljs-keyword">int</span>&gt; vi;<span class="hljs-keyword">typedef</span> pair&lt;<span class="hljs-keyword">int</span>,<span class="hljs-keyword">int</span>&gt; pii;ll A[maxl];<span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">solve</span><span class="hljs-params">()</span></span>&#123;A[<span class="hljs-number">0</span>]=<span class="hljs-number">1</span>;A[<span class="hljs-number">1</span>]=<span class="hljs-number">1</span>;rep(i,<span class="hljs-number">2</span>,maxl) A[i]=A[i<span class="hljs-number">-1</span>]*i;&#125;<span class="hljs-keyword">int</span> n; <span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span>&#123;ios::sync_with_stdio(<span class="hljs-literal">false</span>);solve();ll t;<span class="hljs-built_in">cin</span>&gt;&gt;t;<span class="hljs-keyword">while</span>(t--)&#123;<span class="hljs-built_in">cin</span>&gt;&gt;n;<span class="hljs-keyword">double</span> ans=<span class="hljs-built_in">floor</span>((<span class="hljs-keyword">double</span>)A[n]/e+<span class="hljs-number">0.5</span>);<span class="hljs-built_in">cout</span>&lt;&lt;fixed&lt;&lt;setprecision(<span class="hljs-number">2</span>)&lt;&lt;ans*<span class="hljs-number">100</span>/A[n]&lt;&lt;<span class="hljs-string">"%"</span>&lt;&lt;<span class="hljs-built_in">endl</span>;&#125; &#125;</code></pre></li></ul><h1 id="收获与反思"><a href="#收获与反思" class="headerlink" title="收获与反思"></a>收获与反思</h1><ul><li><p>注意分析递推公式。手写前几项找规律也可以。</p></li><li><p>错排公式推导学习</p></li><li><p>挖坑母函数</p></li></ul>]]></content>
    
    
    <categories>
      
      <category>Computer Science</category>
      
      <category>ACM</category>
      
      <category>HDU</category>
      
    </categories>
    
    
    <tags>
      
      <tag>ACM</tag>
      
      <tag>HDU</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>【CSU-1828】解题报告（数论，康托展开逆展开）</title>
    <link href="/post/3e6878ac.html"/>
    <url>/post/3e6878ac.html</url>
    
    <content type="html"><![CDATA[<h1 id="原始题目"><a href="#原始题目" class="headerlink" title="原始题目"></a>原始题目</h1><h2 id="1828-Dictionary"><a href="#1828-Dictionary" class="headerlink" title="1828: Dictionary"></a>1828: Dictionary</h2><ul><li>Time Limit: 2 Sec     </li><li>Memory Limit: 128 Mb     </li><li>Submitted: 202     </li><li>Solved: 146    </li></ul><h3 id="Description"><a href="#Description" class="headerlink" title="Description"></a>Description</h3><p>The isolated people of MacGuffin Island have a unique culture, and one of the most interesting things about them is their language. Their alphabet consists of the first 9 letters of the Roman alphabet (a, b, c, d, e, f, g, h, i). All of their words are exactly 9 letters long and use each of these 9 letters exactly once. They have a word for every possible permutation of these letters. In the library of their most sacred temple is a dictionary, and each word in their language has its own page. By coincidence they order their words exactly as they would be in ordered in English, so the word ‘abcdefghi’ is on the first page, and the word ‘ihgfedcba’ is on the last. The question is, given a list of random words from the MacGuffin language, can you say on which page of the MacGuffin dictionary each appears?</p><a id="more"></a><h3 id="Input"><a href="#Input" class="headerlink" title="Input"></a>Input</h3><p>The first line of the input file is a positive integer. This integer tells you how many words will follow. The upper limit for this number is 6000. Every subsequent line contains a single word from the MacGuffin language, so if the first number is 1000 there will be 1000 lines after it, each containing a single word.</p><h3 id="Output"><a href="#Output" class="headerlink" title="Output"></a>Output</h3><p>Each line of output will contain an integer. This integer should be the page number for the corresponding word.</p><h3 id="Sample-Input"><a href="#Sample-Input" class="headerlink" title="Sample Input"></a>Sample Input</h3><pre><code>4abcdefgihabcdefghiabcdefgihihgfedcba</code></pre><h3 id="Sample-Output"><a href="#Sample-Output" class="headerlink" title="Sample Output"></a>Sample Output</h3><pre><code>212362880</code></pre><h3 id="Hint"><a href="#Hint" class="headerlink" title="Hint"></a>Hint</h3><h3 id="Source"><a href="#Source" class="headerlink" title="Source"></a>Source</h3><p>ACM-ICPC Asia Thailand National On-Site Programming Contest 2015</p><h1 id="题目大意"><a href="#题目大意" class="headerlink" title="题目大意"></a>题目大意</h1><p>输入一个由(a, b, c, d, e, f, g, h, i)各出现一次构成的八位字符串，求其在按字典序排列中的序号。</p><h1 id="解题思路"><a href="#解题思路" class="headerlink" title="解题思路"></a>解题思路</h1><p>看作1-8的排列，利用康托展开输出序号，模板题。</p><h1 id="解题代码"><a href="#解题代码" class="headerlink" title="解题代码"></a>解题代码</h1><pre><code class="hljs C++"><span class="hljs-meta">#<span class="hljs-meta-keyword">include</span> <span class="hljs-meta-string">&lt;cstdio&gt;</span></span><span class="hljs-meta">#<span class="hljs-meta-keyword">include</span> <span class="hljs-meta-string">&lt;cstring&gt;</span></span><span class="hljs-meta">#<span class="hljs-meta-keyword">include</span> <span class="hljs-meta-string">&lt;cmath&gt;</span></span><span class="hljs-meta">#<span class="hljs-meta-keyword">include</span> <span class="hljs-meta-string">&lt;string&gt;</span></span><span class="hljs-meta">#<span class="hljs-meta-keyword">include</span> <span class="hljs-meta-string">&lt;iostream&gt;</span></span><span class="hljs-meta">#<span class="hljs-meta-keyword">include</span> <span class="hljs-meta-string">&lt;iomanip&gt;</span></span><span class="hljs-meta">#<span class="hljs-meta-keyword">include</span> <span class="hljs-meta-string">&lt;sstream&gt;</span></span><span class="hljs-meta">#<span class="hljs-meta-keyword">include</span> <span class="hljs-meta-string">&lt;set&gt;</span></span><span class="hljs-meta">#<span class="hljs-meta-keyword">include</span> <span class="hljs-meta-string">&lt;map&gt;</span></span><span class="hljs-meta">#<span class="hljs-meta-keyword">include</span> <span class="hljs-meta-string">&lt;queue&gt;</span></span><span class="hljs-meta">#<span class="hljs-meta-keyword">include</span> <span class="hljs-meta-string">&lt;vector&gt;</span></span><span class="hljs-meta">#<span class="hljs-meta-keyword">include</span> <span class="hljs-meta-string">&lt;bits/stdc++.h&gt;</span></span><span class="hljs-meta">#<span class="hljs-meta-keyword">define</span> INF 0x3f3f3f3f</span><span class="hljs-meta">#<span class="hljs-meta-keyword">define</span> eps 1e-8</span><span class="hljs-meta">#<span class="hljs-meta-keyword">define</span> mp make_pair</span><span class="hljs-meta">#<span class="hljs-meta-keyword">define</span> np next_permutation</span><span class="hljs-meta">#<span class="hljs-meta-keyword">define</span> pb push_back</span><span class="hljs-meta">#<span class="hljs-meta-keyword">define</span> all(x) x.begin(),x.end()</span><span class="hljs-meta">#<span class="hljs-meta-keyword">define</span> rep(i,a,n) for(int i=a;i&lt;n;++i)</span><span class="hljs-meta">#<span class="hljs-meta-keyword">define</span> per(i,a,n) for(int i=n-1;i&gt;=a;--i)</span><span class="hljs-meta">#<span class="hljs-meta-keyword">define</span> ms(x,a) memset((x),a,sizeof((x))) </span><span class="hljs-meta">#<span class="hljs-meta-keyword">define</span> mod 998244353 </span><span class="hljs-keyword">using</span> <span class="hljs-keyword">namespace</span> <span class="hljs-built_in">std</span>;<span class="hljs-keyword">typedef</span> <span class="hljs-keyword">long</span> <span class="hljs-keyword">long</span> ll;<span class="hljs-keyword">typedef</span> <span class="hljs-keyword">unsigned</span> <span class="hljs-keyword">long</span> <span class="hljs-keyword">long</span> ull;<span class="hljs-keyword">typedef</span> <span class="hljs-built_in">vector</span>&lt;<span class="hljs-keyword">int</span>&gt; vi;<span class="hljs-keyword">typedef</span> pair&lt;<span class="hljs-keyword">int</span>,<span class="hljs-keyword">int</span>&gt; pii;<span class="hljs-keyword">const</span> <span class="hljs-keyword">int</span> maxl=<span class="hljs-number">10</span>;<span class="hljs-keyword">const</span> <span class="hljs-keyword">int</span> maxn=<span class="hljs-number">1e5</span>+<span class="hljs-number">5</span>;<span class="hljs-keyword">int</span> A[maxl];<span class="hljs-comment">//阶乘； </span><span class="hljs-keyword">int</span> ans_cantor[maxl];<span class="hljs-comment">//康托展开数组 </span><span class="hljs-keyword">bool</span> vis_cantor[maxl];<span class="hljs-comment">//康托标记数组 </span><span class="hljs-built_in">string</span> ss;<span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">init</span><span class="hljs-params">()</span></span>&#123;A[<span class="hljs-number">0</span>]=A[<span class="hljs-number">1</span>]=<span class="hljs-number">1</span>;A[<span class="hljs-number">2</span>]=<span class="hljs-number">2</span>;rep(i,<span class="hljs-number">3</span>,maxl+<span class="hljs-number">1</span>) A[i]=A[i<span class="hljs-number">-1</span>]*i;&#125;<span class="hljs-comment">//contar展开，逆展开，数组标号都是从0开始 </span><span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">cantor</span><span class="hljs-params">(<span class="hljs-keyword">int</span> contar_s[], ll num, <span class="hljs-keyword">int</span> contar_k)</span></span>&#123;<span class="hljs-comment">//康托展开，把一个数字num展开成一个数组contar_s，contar_k是数组长度</span>    <span class="hljs-keyword">int</span> t;    <span class="hljs-built_in">memset</span>(vis_cantor, <span class="hljs-number">0</span>, <span class="hljs-keyword">sizeof</span>(vis_cantor));     <span class="hljs-keyword">for</span>(<span class="hljs-keyword">int</span> i = <span class="hljs-number">0</span>; i &lt; contar_k; i ++)&#123;        t = num / A[contar_k-i<span class="hljs-number">-1</span>];        num%=A[contar_k-i<span class="hljs-number">-1</span>];<span class="hljs-keyword">int</span> cnt_cantor=<span class="hljs-number">0</span>;rep(j,<span class="hljs-number">0</span>,contar_k)&#123;<span class="hljs-comment">//计算每位的逆序数 </span><span class="hljs-built_in">cout</span>&lt;&lt;<span class="hljs-string">"cnt="</span>&lt;&lt;cnt_cantor&lt;&lt;<span class="hljs-string">"t="</span>&lt;&lt;t&lt;&lt;<span class="hljs-string">"vis="</span>&lt;&lt;vis_cantor[j]&lt;&lt;<span class="hljs-built_in">endl</span>;<span class="hljs-keyword">if</span>(vis_cantor[j]) <span class="hljs-keyword">continue</span>;<span class="hljs-keyword">if</span>(cnt_cantor==t)&#123;contar_s[i]=j+<span class="hljs-number">1</span>,vis_cantor[j]=<span class="hljs-number">1</span>;<span class="hljs-keyword">break</span>;&#125; ++cnt_cantor;&#125;    &#125;    rep(i,<span class="hljs-number">0</span>,contar_k) <span class="hljs-built_in">cout</span>&lt;&lt;contar_s[i]&lt;&lt;<span class="hljs-built_in">endl</span>; <span class="hljs-comment">//输出康拖展开的结果 </span>&#125;<span class="hljs-function">ll <span class="hljs-title">inv_cantor</span><span class="hljs-params">(<span class="hljs-keyword">int</span> contar_s[], <span class="hljs-keyword">int</span> contar_k)</span></span>&#123;<span class="hljs-comment">//康托逆展开，把一个数组contar_s换算成一个数字num </span>    <span class="hljs-keyword">int</span> cnt;ll num=<span class="hljs-number">0</span>;    num = <span class="hljs-number">0</span>;    <span class="hljs-keyword">for</span>(<span class="hljs-keyword">int</span> i = <span class="hljs-number">0</span>; i &lt; contar_k; i ++)&#123;        cnt = <span class="hljs-number">0</span>;        <span class="hljs-keyword">for</span>(<span class="hljs-keyword">int</span> j = i + <span class="hljs-number">1</span>; j &lt; contar_k; j ++)&#123;            <span class="hljs-keyword">if</span>(contar_s[i] &gt; contar_s[j]) cnt ++;<span class="hljs-comment">//判断几个数小于它,即求逆序数。 </span>        &#125;        num += A[contar_k-i<span class="hljs-number">-1</span>] * cnt;    &#125;    <span class="hljs-keyword">return</span> num;&#125; <span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span>&#123;ios::sync_with_stdio(<span class="hljs-literal">false</span>);<span class="hljs-keyword">int</span> t;<span class="hljs-built_in">cin</span>&gt;&gt;t;init(); <span class="hljs-keyword">while</span>(t--)&#123;<span class="hljs-built_in">cin</span>&gt;&gt;ss;rep(i,<span class="hljs-number">0</span>,ss.length())&#123;ans_cantor[i]=ss[i]-<span class="hljs-string">'a'</span>+<span class="hljs-number">1</span>; <span class="hljs-comment">//这里加不加1都行</span>&#125;ll num=inv_cantor(ans_cantor,ss.length());<span class="hljs-built_in">cout</span>&lt;&lt;num+<span class="hljs-number">1</span>&lt;&lt;<span class="hljs-built_in">endl</span>;&#125; &#125;</code></pre><h1 id="收获与反思"><a href="#收获与反思" class="headerlink" title="收获与反思"></a>收获与反思</h1><ul><li>感受模板的力量= =</li></ul>]]></content>
    
    
    <categories>
      
      <category>Computer Science</category>
      
      <category>ACM</category>
      
      <category>CSU</category>
      
    </categories>
    
    
    <tags>
      
      <tag>ACM</tag>
      
      <tag>CSU</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>【UVA-815】解题报告（贪心，二分）</title>
    <link href="/post/9eb065c8.html"/>
    <url>/post/9eb065c8.html</url>
    
    <content type="html"><![CDATA[<h1 id="原始题目"><a href="#原始题目" class="headerlink" title="原始题目"></a>原始题目</h1><a id="more"></a><h1 id="题目大意"><a href="#题目大意" class="headerlink" title="题目大意"></a>题目大意</h1><p>给出$n \times m$个$10 \times 10$底面积柱子的海拔，以及洪水的总体积，计算洪水覆盖后的海拔高度以及覆盖柱子的百分比。</p><h1 id="解题思路"><a href="#解题思路" class="headerlink" title="解题思路"></a>解题思路</h1><ul><li>首先$n*m$个柱子可以排序后看作一排。</li><li><p>思路一（自己的）：二分猜答案</p><p>  先判断洪水是否会淹没所有柱子，如果不是的话那么二分下界为最低海拔，上界为最高海拔。二分答案判断<br>  当前海拔下淹没体积是否达到总洪水体积（计算当前淹没体积的时候也需要二分查找，比较繁琐），这个思路<br>  并没有很好的利用海拔随覆盖柱子数增多而增大的性质。</p></li><li><p>思路二（网络大神）：简化后贪心</p><p>  先预处理成$1 \times 1$（或者说直接考虑高度），对柱子高度排序后，我们考虑洪水一定是从低到高填充，那么贪心的<br>  让洪水只填充到当前的柱子，直至平均高度不高于下个柱子，这时候就是最终答案。（tql）</p></li></ul><h1 id="解题代码"><a href="#解题代码" class="headerlink" title="解题代码"></a>解题代码</h1><ul><li><p>二分：</p>  <pre><code class="hljs C++"><span class="hljs-meta">#<span class="hljs-meta-keyword">include</span> <span class="hljs-meta-string">&lt;cstdio&gt;</span></span><span class="hljs-meta">#<span class="hljs-meta-keyword">include</span> <span class="hljs-meta-string">&lt;cstring&gt;</span></span><span class="hljs-meta">#<span class="hljs-meta-keyword">include</span> <span class="hljs-meta-string">&lt;cmath&gt;</span></span><span class="hljs-meta">#<span class="hljs-meta-keyword">include</span> <span class="hljs-meta-string">&lt;algorithm&gt;</span></span><span class="hljs-meta">#<span class="hljs-meta-keyword">include</span> <span class="hljs-meta-string">&lt;set&gt;</span></span><span class="hljs-meta">#<span class="hljs-meta-keyword">include</span> <span class="hljs-meta-string">&lt;queue&gt;</span></span><span class="hljs-meta">#<span class="hljs-meta-keyword">include</span> <span class="hljs-meta-string">&lt;map&gt;</span></span><span class="hljs-meta">#<span class="hljs-meta-keyword">include</span> <span class="hljs-meta-string">&lt;vector&gt;</span></span><span class="hljs-meta">#<span class="hljs-meta-keyword">include</span> <span class="hljs-meta-string">&lt;stack&gt;</span></span><span class="hljs-meta">#<span class="hljs-meta-keyword">include</span> <span class="hljs-meta-string">&lt;iostream&gt;</span></span><span class="hljs-meta">#<span class="hljs-meta-keyword">include</span> <span class="hljs-meta-string">&lt;iomanip&gt;</span></span><span class="hljs-meta">#<span class="hljs-meta-keyword">include</span> <span class="hljs-meta-string">&lt;bits/stdc++.h&gt;</span></span><span class="hljs-meta">#<span class="hljs-meta-keyword">define</span> rep(i,a,n) for(int i=a;i&lt;n;++i)</span><span class="hljs-meta">#<span class="hljs-meta-keyword">define</span> per(i,a,n) for(int i=n-a;i&gt;=a;--i)</span><span class="hljs-meta">#<span class="hljs-meta-keyword">define</span> se second</span><span class="hljs-meta">#<span class="hljs-meta-keyword">define</span> fi first</span><span class="hljs-meta">#<span class="hljs-meta-keyword">define</span> pb push_back</span><span class="hljs-meta">#<span class="hljs-meta-keyword">define</span> mp make_pair</span><span class="hljs-meta">#<span class="hljs-meta-keyword">define</span> np next_permutation</span><span class="hljs-meta">#<span class="hljs-meta-keyword">define</span> ms(x,a) memset((x),a,sizeof((x)))</span><span class="hljs-meta">#<span class="hljs-meta-keyword">define</span> all(x) x.begin(),x.end()</span><span class="hljs-meta">#<span class="hljs-meta-keyword">define</span> eps 1e-9</span><span class="hljs-meta">#<span class="hljs-meta-keyword">define</span> INF 0x3f3f3f3f</span><span class="hljs-keyword">using</span> <span class="hljs-keyword">namespace</span> <span class="hljs-built_in">std</span>;<span class="hljs-keyword">const</span> <span class="hljs-keyword">int</span> maxn=<span class="hljs-number">1e5</span>+<span class="hljs-number">5</span>;<span class="hljs-keyword">const</span> <span class="hljs-keyword">int</span> maxl=<span class="hljs-number">26</span>;<span class="hljs-keyword">typedef</span> <span class="hljs-keyword">long</span> <span class="hljs-keyword">long</span> ll;<span class="hljs-keyword">typedef</span> <span class="hljs-keyword">unsigned</span> <span class="hljs-keyword">long</span> <span class="hljs-keyword">long</span> ull;<span class="hljs-keyword">typedef</span> <span class="hljs-built_in">vector</span>&lt;<span class="hljs-keyword">int</span>&gt; vi;<span class="hljs-keyword">typedef</span> pair&lt;<span class="hljs-keyword">int</span>,<span class="hljs-keyword">int</span>&gt; pii;<span class="hljs-keyword">double</span> a[maxn];<span class="hljs-keyword">double</span> sum[maxn]; <span class="hljs-keyword">double</span> allflood,maxa;<span class="hljs-keyword">int</span> n,m;<span class="hljs-function"><span class="hljs-keyword">double</span> <span class="hljs-title">check</span><span class="hljs-params">(<span class="hljs-keyword">double</span> nowl, <span class="hljs-keyword">double</span> allcubic)</span></span>&#123;<span class="hljs-keyword">int</span> index=lower_bound(a,a+m*n,nowl)-a;<span class="hljs-comment">//cout&lt;&lt;"index="&lt;&lt;index&lt;&lt;"  ";</span><span class="hljs-keyword">if</span>(index==<span class="hljs-number">0</span>) <span class="hljs-keyword">return</span> allcubic;<span class="hljs-keyword">double</span> temp=index*nowl-sum[index<span class="hljs-number">-1</span>];<span class="hljs-comment">//cout&lt;&lt;"temp="&lt;&lt;temp&lt;&lt;endl;</span><span class="hljs-keyword">return</span> allcubic-(<span class="hljs-number">10.0</span>*<span class="hljs-number">10.0</span>*temp);&#125;<span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span>&#123;ios::sync_with_stdio(<span class="hljs-literal">false</span>);<span class="hljs-keyword">int</span> kase=<span class="hljs-number">1</span>;<span class="hljs-keyword">while</span>(<span class="hljs-built_in">cin</span>&gt;&gt;m&gt;&gt;n&amp;&amp;m+n)&#123;maxa=<span class="hljs-number">-100000</span>;rep(i,<span class="hljs-number">0</span>,m)&#123;rep(j,<span class="hljs-number">0</span>,n)&#123;<span class="hljs-built_in">cin</span>&gt;&gt;a[i*n+j];&#125;&#125;sort(a,a+m*n);sum[<span class="hljs-number">0</span>]=a[<span class="hljs-number">0</span>];rep(i,<span class="hljs-number">1</span>,n*m) sum[i]=sum[i<span class="hljs-number">-1</span>]+a[i];<span class="hljs-built_in">cin</span>&gt;&gt;allflood;<span class="hljs-comment">//cout&lt;&lt;"mmin="&lt;&lt;a[0]&lt;&lt;"   mmax="&lt;&lt;a[n*m-1]&lt;&lt;endl;</span><span class="hljs-comment">//一共n*m个区域；</span><span class="hljs-built_in">cout</span>&lt;&lt;<span class="hljs-string">"Region "</span>&lt;&lt;kase++&lt;&lt;<span class="hljs-built_in">endl</span>;<span class="hljs-comment">//先判断填满是不是够</span><span class="hljs-keyword">double</span> temp=<span class="hljs-number">10.0</span>*<span class="hljs-number">10.0</span>*(n*m*a[n*m<span class="hljs-number">-1</span>]-sum[n*m<span class="hljs-number">-1</span>]);<span class="hljs-keyword">if</span>(temp&lt;allflood)&#123;<span class="hljs-keyword">double</span> ans=(allflood-temp)/(<span class="hljs-number">100.0</span>*n*m)+a[n*m<span class="hljs-number">-1</span>];<span class="hljs-built_in">cout</span>&lt;&lt;<span class="hljs-string">"Water level is "</span>&lt;&lt;fixed&lt;&lt;setprecision(<span class="hljs-number">2</span>)&lt;&lt;ans&lt;&lt;<span class="hljs-string">" meters."</span>&lt;&lt;<span class="hljs-built_in">endl</span>;<span class="hljs-built_in">cout</span>&lt;&lt;<span class="hljs-string">"100.00 percent of the region is under water."</span>&lt;&lt;<span class="hljs-built_in">endl</span>;<span class="hljs-built_in">cout</span>&lt;&lt;<span class="hljs-built_in">endl</span>;<span class="hljs-keyword">continue</span>;&#125; <span class="hljs-comment">//不够 </span><span class="hljs-keyword">double</span> l=a[<span class="hljs-number">0</span>],r=a[n*m<span class="hljs-number">-1</span>],mid=(l+r)/<span class="hljs-number">2.0</span>;<span class="hljs-keyword">double</span> ans=check(mid,allflood);<span class="hljs-keyword">while</span>(<span class="hljs-built_in">abs</span>(ans)&gt;eps)&#123;<span class="hljs-keyword">if</span>(ans&gt;<span class="hljs-number">0</span>)  l=mid;<span class="hljs-keyword">else</span> r=mid;mid=(r+l)/<span class="hljs-number">2.0</span>;<span class="hljs-comment">//cout&lt;&lt;"mid="&lt;&lt;mid&lt;&lt;"  ";</span>ans=check(mid,allflood);&#125;<span class="hljs-keyword">int</span> index=lower_bound(a,a+m*n,mid)-a;<span class="hljs-built_in">cout</span>&lt;&lt;<span class="hljs-string">"Water level is "</span>&lt;&lt;fixed&lt;&lt;setprecision(<span class="hljs-number">2</span>)&lt;&lt;mid&lt;&lt;<span class="hljs-string">" meters."</span>&lt;&lt;<span class="hljs-built_in">endl</span>;<span class="hljs-built_in">cout</span>&lt;&lt;fixed&lt;&lt;setprecision(<span class="hljs-number">2</span>)&lt;&lt;(<span class="hljs-keyword">double</span>)index*<span class="hljs-number">100</span>/(n*m)&lt;&lt;<span class="hljs-string">" percent of the region is under water."</span>&lt;&lt;<span class="hljs-built_in">endl</span>;<span class="hljs-built_in">cout</span>&lt;&lt;<span class="hljs-built_in">endl</span>;&#125;&#125;</code></pre></li></ul><ul><li><p>贪心：</p>  <pre><code class="hljs C++"><span class="hljs-meta">#<span class="hljs-meta-keyword">include</span> <span class="hljs-meta-string">&lt;cstdio&gt;</span></span><span class="hljs-meta">#<span class="hljs-meta-keyword">include</span> <span class="hljs-meta-string">&lt;cstring&gt;</span></span><span class="hljs-meta">#<span class="hljs-meta-keyword">include</span> <span class="hljs-meta-string">&lt;cmath&gt;</span></span><span class="hljs-meta">#<span class="hljs-meta-keyword">include</span> <span class="hljs-meta-string">&lt;algorithm&gt;</span></span><span class="hljs-meta">#<span class="hljs-meta-keyword">include</span> <span class="hljs-meta-string">&lt;set&gt;</span></span><span class="hljs-meta">#<span class="hljs-meta-keyword">include</span> <span class="hljs-meta-string">&lt;queue&gt;</span></span><span class="hljs-meta">#<span class="hljs-meta-keyword">include</span> <span class="hljs-meta-string">&lt;map&gt;</span></span><span class="hljs-meta">#<span class="hljs-meta-keyword">include</span> <span class="hljs-meta-string">&lt;vector&gt;</span></span><span class="hljs-meta">#<span class="hljs-meta-keyword">include</span> <span class="hljs-meta-string">&lt;stack&gt;</span></span><span class="hljs-meta">#<span class="hljs-meta-keyword">include</span> <span class="hljs-meta-string">&lt;iostream&gt;</span></span><span class="hljs-meta">#<span class="hljs-meta-keyword">include</span> <span class="hljs-meta-string">&lt;iomanip&gt;</span></span><span class="hljs-meta">#<span class="hljs-meta-keyword">include</span> <span class="hljs-meta-string">&lt;bits/stdc++.h&gt;</span></span><span class="hljs-meta">#<span class="hljs-meta-keyword">define</span> rep(i,a,n) for(int i=a;i&lt;n;++i)</span><span class="hljs-meta">#<span class="hljs-meta-keyword">define</span> per(i,a,n) for(int i=n-a;i&gt;=a;--i)</span><span class="hljs-meta">#<span class="hljs-meta-keyword">define</span> se second</span><span class="hljs-meta">#<span class="hljs-meta-keyword">define</span> fi first</span><span class="hljs-meta">#<span class="hljs-meta-keyword">define</span> pb push_back</span><span class="hljs-meta">#<span class="hljs-meta-keyword">define</span> mp make_pair</span><span class="hljs-meta">#<span class="hljs-meta-keyword">define</span> np next_permutation</span><span class="hljs-meta">#<span class="hljs-meta-keyword">define</span> ms(x,a) memset((x),a,sizeof((x)))</span><span class="hljs-meta">#<span class="hljs-meta-keyword">define</span> all(x) x.begin(),x.end()</span><span class="hljs-meta">#<span class="hljs-meta-keyword">define</span> eps 1e-9</span><span class="hljs-meta">#<span class="hljs-meta-keyword">define</span> INF 0x3f3f3f3f</span><span class="hljs-keyword">using</span> <span class="hljs-keyword">namespace</span> <span class="hljs-built_in">std</span>;<span class="hljs-keyword">const</span> <span class="hljs-keyword">int</span> maxn=<span class="hljs-number">1e5</span>+<span class="hljs-number">5</span>;<span class="hljs-keyword">const</span> <span class="hljs-keyword">int</span> maxl=<span class="hljs-number">26</span>;<span class="hljs-keyword">typedef</span> <span class="hljs-keyword">long</span> <span class="hljs-keyword">long</span> ll;<span class="hljs-keyword">typedef</span> <span class="hljs-keyword">unsigned</span> <span class="hljs-keyword">long</span> <span class="hljs-keyword">long</span> ull;<span class="hljs-keyword">typedef</span> <span class="hljs-built_in">vector</span>&lt;<span class="hljs-keyword">int</span>&gt; vi;<span class="hljs-keyword">typedef</span> pair&lt;<span class="hljs-keyword">int</span>,<span class="hljs-keyword">int</span>&gt; pii;<span class="hljs-keyword">int</span> n,m;<span class="hljs-keyword">int</span> a[maxn];<span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span>&#123;ios::sync_with_stdio(<span class="hljs-literal">false</span>);<span class="hljs-keyword">int</span> kase=<span class="hljs-number">0</span>;<span class="hljs-keyword">while</span>(<span class="hljs-built_in">cin</span>&gt;&gt;n&gt;&gt;m&amp;&amp;n+m)&#123;n*=m;rep(i,<span class="hljs-number">0</span>,n) <span class="hljs-built_in">cin</span>&gt;&gt;a[i];sort(a,a+n);<span class="hljs-keyword">double</span> ans;<span class="hljs-built_in">cin</span>&gt;&gt;ans;ans/=<span class="hljs-number">100</span>;a[n]=INF;<span class="hljs-keyword">int</span> index=<span class="hljs-number">0</span>;rep(i,<span class="hljs-number">0</span>,n)&#123;ans+=a[i];<span class="hljs-keyword">if</span>(ans/(i+<span class="hljs-number">1</span>)&lt;=a[i+<span class="hljs-number">1</span>])&#123;ans=ans/(i+<span class="hljs-number">1</span>);index=i+<span class="hljs-number">1</span>;<span class="hljs-keyword">break</span>;&#125;&#125;<span class="hljs-built_in">cout</span>&lt;&lt;<span class="hljs-string">"Region "</span>&lt;&lt;++kase&lt;&lt;<span class="hljs-built_in">endl</span>;<span class="hljs-built_in">cout</span>&lt;&lt;<span class="hljs-string">"Water level is "</span>&lt;&lt;fixed&lt;&lt;setprecision(<span class="hljs-number">2</span>)&lt;&lt;ans&lt;&lt;<span class="hljs-string">" meters."</span>&lt;&lt;<span class="hljs-built_in">endl</span>;<span class="hljs-built_in">cout</span>&lt;&lt;fixed&lt;&lt;setprecision(<span class="hljs-number">2</span>)&lt;&lt;(<span class="hljs-keyword">double</span>)(index*<span class="hljs-number">100</span>)/n&lt;&lt;<span class="hljs-string">" percent of the region is under water."</span>&lt;&lt;<span class="hljs-built_in">endl</span>;<span class="hljs-built_in">cout</span>&lt;&lt;<span class="hljs-built_in">endl</span>;&#125;&#125;</code></pre></li></ul><h1 id="收获与反思"><a href="#收获与反思" class="headerlink" title="收获与反思"></a>收获与反思</h1><ul><li>代码长度和速度高下立判啊。合理尝试贪心、二分，选择合适方法</li></ul>]]></content>
    
    
    <categories>
      
      <category>Computer Science</category>
      
      <category>ACM</category>
      
      <category>UVA</category>
      
    </categories>
    
    
    <tags>
      
      <tag>ACM</tag>
      
      <tag>UVA</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>【UVA-101】解题报告（模拟）</title>
    <link href="/post/d50b784.html"/>
    <url>/post/d50b784.html</url>
    
    <content type="html"><![CDATA[<h1 id="原始题目"><a href="#原始题目" class="headerlink" title="原始题目"></a>原始题目</h1><a id="more"></a><h1 id="题目大意"><a href="#题目大意" class="headerlink" title="题目大意"></a>题目大意</h1><p>有$n$个积木，初始放在$0,1,2 \cdots n-1$位置上，有四种搭积木操作</p><ul><li><p>move a onto b</p><p>where a and b are block numbers, puts block a onto block b after returning any blocks that are<br>stacked on top of blocks a and b to their initial positions.</p><p>把a和b上的积木放回原来位置，再将a放置到b上。</p></li><li><p>move a over b</p><p>where a and b are block numbers, puts block a onto the top of the stack containing block b, after<br>returning any blocks that are stacked on top of block a to their initial positions.</p><p>把a上的积木放回原来位置，再将a放置在b所在的积木堆上。</p></li><li><p>pile a onto b</p><p>where a and b are block numbers, moves the pile of blocks consisting of block a, and any blocks<br>that are stacked above block a, onto block b. All blocks on top of block b are moved to their<br>initial positions prior to the pile taking place. The blocks stacked above block a retain their order<br>when moved.</p><p>把b上的积木放回原来位置，再将a和a之上的积木块一起放在b上（保持相对顺序）。</p></li><li><p>pile a over b</p><p>where a and b are block numbers, puts the pile of blocks consisting of block a, and any blocks<br>that are stacked above block a, onto the top of the stack containing block b. The blocks stacked<br>above block a retain their original order when moved.</p><p>把a和a之上的积木块一起放在b所在的积木堆上（保持相对顺序）。</p></li></ul><p>直至遇到quit停止操作，输出最后每个位置上的积木状态。</p><h1 id="解题思路"><a href="#解题思路" class="headerlink" title="解题思路"></a>解题思路</h1><ul><li>由于不涉及积木块放置在指定位置的操作，还原必定到原有位置且原有位置为空（易证），不用考虑木块放回的特殊情况。</li><li>注意判断是否在同一堆上，违法命令不进行任何实际操作</li><li>模拟四种操作即可</li></ul><h1 id="解题代码"><a href="#解题代码" class="headerlink" title="解题代码"></a>解题代码</h1><ol><li><p>数组模拟四种操作</p> <pre><code class="hljs C++"><span class="hljs-meta">#<span class="hljs-meta-keyword">include</span> <span class="hljs-meta-string">&lt;cstdio&gt;</span></span><span class="hljs-meta">#<span class="hljs-meta-keyword">include</span> <span class="hljs-meta-string">&lt;cstring&gt;</span></span><span class="hljs-meta">#<span class="hljs-meta-keyword">include</span> <span class="hljs-meta-string">&lt;cmath&gt;</span></span><span class="hljs-meta">#<span class="hljs-meta-keyword">include</span> <span class="hljs-meta-string">&lt;algorithm&gt;</span></span><span class="hljs-meta">#<span class="hljs-meta-keyword">include</span> <span class="hljs-meta-string">&lt;set&gt;</span></span><span class="hljs-meta">#<span class="hljs-meta-keyword">include</span> <span class="hljs-meta-string">&lt;queue&gt;</span></span><span class="hljs-meta">#<span class="hljs-meta-keyword">include</span> <span class="hljs-meta-string">&lt;map&gt;</span></span><span class="hljs-meta">#<span class="hljs-meta-keyword">include</span> <span class="hljs-meta-string">&lt;vector&gt;</span></span><span class="hljs-meta">#<span class="hljs-meta-keyword">include</span> <span class="hljs-meta-string">&lt;stack&gt;</span></span><span class="hljs-meta">#<span class="hljs-meta-keyword">include</span> <span class="hljs-meta-string">&lt;iostream&gt;</span></span><span class="hljs-meta">#<span class="hljs-meta-keyword">include</span> <span class="hljs-meta-string">&lt;iomanip&gt;</span></span><span class="hljs-meta">#<span class="hljs-meta-keyword">include</span> <span class="hljs-meta-string">&lt;bits/stdc++.h&gt;</span></span><span class="hljs-meta">#<span class="hljs-meta-keyword">define</span> rep(i,a,n) for(int i=a;i&lt;n;++i)</span><span class="hljs-meta">#<span class="hljs-meta-keyword">define</span> per(i,a,n) for(int i=n-a;i&gt;=a;--i)</span><span class="hljs-meta">#<span class="hljs-meta-keyword">define</span> se second</span><span class="hljs-meta">#<span class="hljs-meta-keyword">define</span> fi first</span><span class="hljs-meta">#<span class="hljs-meta-keyword">define</span> pb push_back</span><span class="hljs-meta">#<span class="hljs-meta-keyword">define</span> mp make_pair</span><span class="hljs-meta">#<span class="hljs-meta-keyword">define</span> np next_permutation</span><span class="hljs-meta">#<span class="hljs-meta-keyword">define</span> ms(x,a) memset((x),a,sizeof((x)))</span><span class="hljs-meta">#<span class="hljs-meta-keyword">define</span> all(x) x.begin(),x.end()</span><span class="hljs-meta">#<span class="hljs-meta-keyword">define</span> eps 1e-9</span><span class="hljs-meta">#<span class="hljs-meta-keyword">define</span> INF 0x3f3f3f3f</span><span class="hljs-keyword">using</span> <span class="hljs-keyword">namespace</span> <span class="hljs-built_in">std</span>;<span class="hljs-keyword">const</span> <span class="hljs-keyword">int</span> maxn=<span class="hljs-number">1e5</span>+<span class="hljs-number">5</span>;<span class="hljs-keyword">const</span> <span class="hljs-keyword">int</span> maxl=<span class="hljs-number">26</span>;<span class="hljs-keyword">typedef</span> <span class="hljs-keyword">long</span> <span class="hljs-keyword">long</span> ll;<span class="hljs-keyword">typedef</span> <span class="hljs-keyword">unsigned</span> <span class="hljs-keyword">long</span> <span class="hljs-keyword">long</span> ull;<span class="hljs-keyword">typedef</span> <span class="hljs-built_in">vector</span>&lt;<span class="hljs-keyword">int</span>&gt; vi;<span class="hljs-keyword">typedef</span> pair&lt;<span class="hljs-keyword">int</span>,<span class="hljs-keyword">int</span>&gt; pii;<span class="hljs-keyword">int</span> n,m,a,b;<span class="hljs-built_in">string</span> s1,s2;<span class="hljs-keyword">int</span> top[maxn],bottom[maxn],place[maxn],mmp[maxn];<span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">initial</span><span class="hljs-params">()</span></span>&#123;rep(i,<span class="hljs-number">0</span>,n) top[i]=bottom[i]=place[i]=i;rep(i,<span class="hljs-number">0</span>,n) mmp[i]=<span class="hljs-number">-1</span>;&#125;<span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">solve</span><span class="hljs-params">(<span class="hljs-keyword">int</span> aa,<span class="hljs-keyword">int</span> bb,<span class="hljs-keyword">int</span> index)</span></span>&#123;<span class="hljs-keyword">switch</span>(index)&#123;<span class="hljs-keyword">case</span> <span class="hljs-number">1</span>:&#123;<span class="hljs-keyword">while</span>(mmp[aa]!=<span class="hljs-number">-1</span>)&#123;<span class="hljs-keyword">int</span> next=mmp[aa];mmp[aa]=mmp[next];mmp[next]=<span class="hljs-number">-1</span>;top[next]=bottom[next]=place[next]=next;&#125;<span class="hljs-keyword">while</span>(mmp[bb]!=<span class="hljs-number">-1</span>)&#123;<span class="hljs-keyword">int</span> next=mmp[bb];mmp[bb]=mmp[next];mmp[next]=<span class="hljs-number">-1</span>;top[next]=bottom[next]=place[next]=next;&#125;mmp[bb]=aa;<span class="hljs-keyword">int</span> start=top[place[aa]];<span class="hljs-keyword">if</span>(start==aa) top[aa]=<span class="hljs-number">-1</span>;<span class="hljs-keyword">else</span>&#123;<span class="hljs-keyword">while</span>(mmp[start]!=aa) start=mmp[start];mmp[start]=<span class="hljs-number">-1</span>;&#125;place[aa]=place[bb];&#125;<span class="hljs-keyword">break</span>;<span class="hljs-keyword">case</span> <span class="hljs-number">2</span>:&#123;<span class="hljs-keyword">while</span>(mmp[aa]!=<span class="hljs-number">-1</span>)&#123;<span class="hljs-keyword">int</span> next=mmp[aa];mmp[aa]=mmp[next];mmp[next]=<span class="hljs-number">-1</span>;top[next]=bottom[next]=place[next]=next;&#125;<span class="hljs-keyword">while</span>(mmp[bb]!=<span class="hljs-number">-1</span>) bb=mmp[bb];mmp[bb]=aa;<span class="hljs-keyword">int</span> start=top[place[aa]];<span class="hljs-keyword">if</span>(start==aa) top[aa]=<span class="hljs-number">-1</span>;<span class="hljs-keyword">else</span>&#123;<span class="hljs-keyword">while</span>(mmp[start]!=aa) start=mmp[start];mmp[start]=<span class="hljs-number">-1</span>;&#125;place[aa]=place[bb];&#125;<span class="hljs-keyword">break</span>;<span class="hljs-keyword">case</span> <span class="hljs-number">3</span>:&#123;<span class="hljs-keyword">while</span>(mmp[bb]!=<span class="hljs-number">-1</span>)&#123;<span class="hljs-keyword">int</span> next=mmp[bb];mmp[bb]=mmp[next];mmp[next]=<span class="hljs-number">-1</span>;top[next]=bottom[next]=place[next]=next;&#125;mmp[bb]=aa;<span class="hljs-keyword">int</span> start=top[place[aa]];<span class="hljs-keyword">if</span>(start==aa) top[aa]=<span class="hljs-number">-1</span>;<span class="hljs-keyword">else</span>&#123;<span class="hljs-keyword">while</span>(mmp[start]!=aa) start=mmp[start];mmp[start]=<span class="hljs-number">-1</span>;&#125;<span class="hljs-keyword">while</span>(mmp[bb]!=<span class="hljs-number">-1</span>)&#123;place[mmp[bb]]=place[bb];bb=mmp[bb];&#125;&#125;<span class="hljs-keyword">break</span>; <span class="hljs-keyword">case</span> <span class="hljs-number">4</span>:&#123;<span class="hljs-keyword">while</span>(mmp[bb]!=<span class="hljs-number">-1</span>) bb=mmp[bb];mmp[bb]=aa;<span class="hljs-keyword">int</span> start=top[place[aa]];<span class="hljs-keyword">if</span>(start==aa) top[aa]=<span class="hljs-number">-1</span>;<span class="hljs-keyword">else</span>&#123;<span class="hljs-keyword">while</span>(mmp[start]!=aa) start=mmp[start];mmp[start]=<span class="hljs-number">-1</span>;&#125;<span class="hljs-keyword">while</span>(mmp[bb]!=<span class="hljs-number">-1</span>)&#123;place[mmp[bb]]=place[bb];bb=mmp[bb];&#125;&#125;<span class="hljs-keyword">break</span>;&#125;&#125;<span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span>&#123;<span class="hljs-keyword">while</span>(<span class="hljs-built_in">cin</span>&gt;&gt;n)&#123;initial();<span class="hljs-keyword">while</span>(<span class="hljs-built_in">cin</span>&gt;&gt;s1&amp;&amp; s1[<span class="hljs-number">0</span>]!=<span class="hljs-string">'q'</span>)&#123;<span class="hljs-built_in">cin</span>&gt;&gt;a&gt;&gt;s2&gt;&gt;b;<span class="hljs-keyword">if</span>(place[a]==place[b]) <span class="hljs-keyword">continue</span>;<span class="hljs-keyword">if</span>(s1[<span class="hljs-number">0</span>]==<span class="hljs-string">'m'</span> &amp;&amp; s2[<span class="hljs-number">1</span>]==<span class="hljs-string">'n'</span>) solve(a,b,<span class="hljs-number">1</span>);<span class="hljs-keyword">if</span>(s1[<span class="hljs-number">0</span>]==<span class="hljs-string">'m'</span> &amp;&amp; s2[<span class="hljs-number">1</span>]==<span class="hljs-string">'v'</span>) solve(a,b,<span class="hljs-number">2</span>);<span class="hljs-keyword">if</span>(s1[<span class="hljs-number">0</span>]==<span class="hljs-string">'p'</span> &amp;&amp; s2[<span class="hljs-number">1</span>]==<span class="hljs-string">'n'</span>) solve(a,b,<span class="hljs-number">3</span>);<span class="hljs-keyword">if</span>(s1[<span class="hljs-number">0</span>]==<span class="hljs-string">'p'</span> &amp;&amp; s2[<span class="hljs-number">1</span>]==<span class="hljs-string">'v'</span>) solve(a,b,<span class="hljs-number">4</span>);&#125;rep(i,<span class="hljs-number">0</span>,n)&#123;<span class="hljs-built_in">cout</span>&lt;&lt;i&lt;&lt;<span class="hljs-string">":"</span>;<span class="hljs-keyword">if</span>(top[i]==<span class="hljs-number">-1</span>) <span class="hljs-built_in">cout</span>&lt;&lt;<span class="hljs-built_in">endl</span>;<span class="hljs-keyword">else</span> &#123;<span class="hljs-keyword">int</span> start=top[i];<span class="hljs-built_in">cout</span>&lt;&lt;<span class="hljs-string">" "</span>&lt;&lt;start;<span class="hljs-keyword">while</span>(mmp[start]!=<span class="hljs-number">-1</span>)&#123;start=mmp[start];<span class="hljs-built_in">cout</span>&lt;&lt;<span class="hljs-string">" "</span>&lt;&lt;start;&#125;<span class="hljs-built_in">cout</span>&lt;&lt;<span class="hljs-built_in">endl</span>;&#125;&#125;<span class="hljs-comment">//cout&lt;&lt;endl;</span>&#125;&#125;</code></pre></li><li><p>vector模拟两种操作</p> <pre><code class="hljs C++"><span class="hljs-meta">#<span class="hljs-meta-keyword">include</span> <span class="hljs-meta-string">&lt;bits/stdc++.h&gt;</span></span><span class="hljs-meta">#<span class="hljs-meta-keyword">define</span> rep(i,a,n) for(int i=a;i&lt;n;++i)</span><span class="hljs-meta">#<span class="hljs-meta-keyword">define</span> per(i,a,n) for(int i=n-1;i&gt;=a;--i)</span><span class="hljs-meta">#<span class="hljs-meta-keyword">define</span> fi first</span><span class="hljs-meta">#<span class="hljs-meta-keyword">define</span> se second</span><span class="hljs-meta">#<span class="hljs-meta-keyword">define</span> mp make_pair</span><span class="hljs-meta">#<span class="hljs-meta-keyword">define</span> pb push_back</span><span class="hljs-meta">#<span class="hljs-meta-keyword">define</span> np next_permutation</span><span class="hljs-meta">#<span class="hljs-meta-keyword">define</span> cl(x,a,n) memset(x,a,sizeof(int)*n)</span><span class="hljs-keyword">using</span> <span class="hljs-keyword">namespace</span> <span class="hljs-built_in">std</span>;<span class="hljs-keyword">typedef</span> <span class="hljs-keyword">long</span> <span class="hljs-keyword">long</span> ll;<span class="hljs-keyword">typedef</span> <span class="hljs-keyword">unsigned</span> <span class="hljs-keyword">long</span> <span class="hljs-keyword">long</span> ull;<span class="hljs-keyword">typedef</span> <span class="hljs-keyword">long</span> <span class="hljs-keyword">double</span> ld;<span class="hljs-keyword">typedef</span> <span class="hljs-built_in">vector</span>&lt;<span class="hljs-keyword">int</span>&gt; vi;<span class="hljs-keyword">typedef</span> pair&lt;<span class="hljs-keyword">int</span>,<span class="hljs-keyword">int</span>&gt; pii;<span class="hljs-keyword">typedef</span> pair&lt;<span class="hljs-built_in">string</span>,<span class="hljs-built_in">string</span>&gt; pss;<span class="hljs-keyword">const</span> <span class="hljs-keyword">int</span> maxn=<span class="hljs-number">30</span>;<span class="hljs-keyword">int</span> n;<span class="hljs-built_in">vector</span>&lt;<span class="hljs-keyword">int</span>&gt; pile[maxn];<span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">find_block</span><span class="hljs-params">(<span class="hljs-keyword">int</span> a,<span class="hljs-keyword">int</span> &amp;p, <span class="hljs-keyword">int</span> &amp; h)</span> </span>&#123;<span class="hljs-comment">// 引用形式返回ouke和高度</span>    <span class="hljs-keyword">for</span>( p=<span class="hljs-number">0</span>;p&lt;n;p++)&#123;        <span class="hljs-keyword">for</span>(h=<span class="hljs-number">0</span>;h&lt;pile[p].size();h++)&#123;            <span class="hljs-keyword">if</span>(pile[p][h]==a ) <span class="hljs-keyword">return</span>;        &#125;    &#125;&#125;<span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">clear_above</span><span class="hljs-params">(<span class="hljs-keyword">int</span> p,<span class="hljs-keyword">int</span> h)</span></span>&#123;    <span class="hljs-keyword">for</span>(<span class="hljs-keyword">int</span> i=h+<span class="hljs-number">1</span>;i&lt;pile[p].size();i++)&#123;        <span class="hljs-keyword">int</span> b=pile[p][i];        pile[b].pb(b);    &#125;    pile[p].resize(h+<span class="hljs-number">1</span>);&#125;<span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">pile_onto</span><span class="hljs-params">(<span class="hljs-keyword">int</span> p,<span class="hljs-keyword">int</span> h,<span class="hljs-keyword">int</span> p2)</span></span>&#123;    <span class="hljs-keyword">for</span>(<span class="hljs-keyword">int</span> i=h; i&lt;pile[p].size();i++)&#123;        pile[p2].pb(pile[p][i]);    &#125;    pile[p].resize(h);&#125;<span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">print</span><span class="hljs-params">()</span></span>&#123;    <span class="hljs-keyword">for</span>(<span class="hljs-keyword">int</span> i=<span class="hljs-number">0</span>;i&lt;n;++i)&#123;        <span class="hljs-built_in">printf</span>(<span class="hljs-string">"%d:"</span>,i);        <span class="hljs-keyword">for</span>(<span class="hljs-keyword">int</span> j=<span class="hljs-number">0</span>;j&lt;pile[i].size();j++) <span class="hljs-built_in">printf</span>(<span class="hljs-string">" %d"</span>,pile[i][j]);        <span class="hljs-built_in">printf</span>(<span class="hljs-string">"\n"</span>);    &#125;&#125;<span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span>&#123;    <span class="hljs-keyword">int</span> a,b;    <span class="hljs-built_in">cin</span>&gt;&gt;n;    <span class="hljs-built_in">string</span> s1,s2;    rep(i,<span class="hljs-number">0</span>,n) pile[i].pb(i);    <span class="hljs-keyword">while</span>(<span class="hljs-built_in">cin</span>&gt;&gt;s1&gt;&gt;a&gt;&gt;s2&gt;&gt;b)&#123;        <span class="hljs-keyword">int</span> pa,pb,ha,hb;        find_block(a,pa,ha);        find_block(b,pb,hb);        <span class="hljs-keyword">if</span>(pa==pb) <span class="hljs-keyword">continue</span>; <span class="hljs-comment">//feifa</span>        <span class="hljs-keyword">if</span>(s2==<span class="hljs-string">"onto"</span>) clear_above(pb,hb);        <span class="hljs-keyword">if</span>(s1==<span class="hljs-string">"move"</span>) clear_above(pa,ha);        pile_onto(pa,ha,pb);    &#125;    print();    <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;&#125;</code></pre></li></ol><h1 id="收获与反思"><a href="#收获与反思" class="headerlink" title="收获与反思"></a>收获与反思</h1><ul><li>大模拟，输出注意PE。</li></ul>]]></content>
    
    
    <categories>
      
      <category>Computer Science</category>
      
      <category>ACM</category>
      
      <category>UVA</category>
      
    </categories>
    
    
    <tags>
      
      <tag>ACM</tag>
      
      <tag>UVA</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>【UVA-10815】解题报告（STL，set）</title>
    <link href="/post/9282aeca.html"/>
    <url>/post/9282aeca.html</url>
    
    <content type="html"><![CDATA[<h1 id="原始题目"><a href="#原始题目" class="headerlink" title="原始题目"></a>原始题目</h1><a id="more"></a><h1 id="题目大意"><a href="#题目大意" class="headerlink" title="题目大意"></a>题目大意</h1><p>给定一段含标点的文章，将其中的单词全部按小写的字典序输出。</p><h1 id="解题思路"><a href="#解题思路" class="headerlink" title="解题思路"></a>解题思路</h1><ul><li>去年做过这个题，当时入门</li><li>现在利用strig类和stringstream类可以轻松完成任务</li></ul><h1 id="解题代码"><a href="#解题代码" class="headerlink" title="解题代码"></a>解题代码</h1><pre><code class="hljs C++"><span class="hljs-comment">//set ssteam </span><span class="hljs-meta">#<span class="hljs-meta-keyword">include</span> <span class="hljs-meta-string">&lt;cstdio&gt;</span></span><span class="hljs-meta">#<span class="hljs-meta-keyword">include</span> <span class="hljs-meta-string">&lt;cstring&gt;</span></span><span class="hljs-meta">#<span class="hljs-meta-keyword">include</span> <span class="hljs-meta-string">&lt;cmath&gt;</span></span><span class="hljs-meta">#<span class="hljs-meta-keyword">include</span> <span class="hljs-meta-string">&lt;algorithm&gt;</span></span><span class="hljs-meta">#<span class="hljs-meta-keyword">include</span> <span class="hljs-meta-string">&lt;set&gt;</span></span><span class="hljs-meta">#<span class="hljs-meta-keyword">include</span> <span class="hljs-meta-string">&lt;queue&gt;</span></span><span class="hljs-meta">#<span class="hljs-meta-keyword">include</span> <span class="hljs-meta-string">&lt;map&gt;</span></span><span class="hljs-meta">#<span class="hljs-meta-keyword">include</span> <span class="hljs-meta-string">&lt;vector&gt;</span></span><span class="hljs-meta">#<span class="hljs-meta-keyword">include</span> <span class="hljs-meta-string">&lt;stack&gt;</span></span><span class="hljs-meta">#<span class="hljs-meta-keyword">include</span> <span class="hljs-meta-string">&lt;iostream&gt;</span></span><span class="hljs-meta">#<span class="hljs-meta-keyword">include</span> <span class="hljs-meta-string">&lt;iomanip&gt;</span></span><span class="hljs-meta">#<span class="hljs-meta-keyword">include</span> <span class="hljs-meta-string">&lt;sstream&gt;</span></span><span class="hljs-meta">#<span class="hljs-meta-keyword">include</span> <span class="hljs-meta-string">&lt;bits/stdc++.h&gt;</span></span><span class="hljs-meta">#<span class="hljs-meta-keyword">define</span> rep(i,a,n) for(int i=a;i&lt;n;++i)</span><span class="hljs-meta">#<span class="hljs-meta-keyword">define</span> per(i,a,n) for(int i=n-a;i&gt;=a;--i)</span><span class="hljs-meta">#<span class="hljs-meta-keyword">define</span> se second</span><span class="hljs-meta">#<span class="hljs-meta-keyword">define</span> fi first</span><span class="hljs-meta">#<span class="hljs-meta-keyword">define</span> pb push_back</span><span class="hljs-meta">#<span class="hljs-meta-keyword">define</span> mp make_pair</span><span class="hljs-meta">#<span class="hljs-meta-keyword">define</span> np next_permutation</span><span class="hljs-meta">#<span class="hljs-meta-keyword">define</span> ms(x,a) memset((x),a,sizeof((x)))</span><span class="hljs-meta">#<span class="hljs-meta-keyword">define</span> all(x) x.begin(),x.end()</span><span class="hljs-meta">#<span class="hljs-meta-keyword">define</span> eps 1e-9</span><span class="hljs-meta">#<span class="hljs-meta-keyword">define</span> INF 0x3f3f3f3f</span><span class="hljs-keyword">using</span> <span class="hljs-keyword">namespace</span> <span class="hljs-built_in">std</span>;<span class="hljs-built_in">string</span> s,ans;<span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span>&#123;ios::sync_with_stdio(<span class="hljs-literal">false</span>);<span class="hljs-comment">//freopen("in.txt","r",stdin);</span><span class="hljs-built_in">set</span> &lt;<span class="hljs-built_in">string</span>&gt; sset;<span class="hljs-keyword">while</span>(<span class="hljs-built_in">cin</span>&gt;&gt;s)&#123;<span class="hljs-comment">//处理一下</span>rep(i,<span class="hljs-number">0</span>,s.length())&#123;<span class="hljs-keyword">if</span>(!<span class="hljs-built_in">isalpha</span>(s[i])) s[i]=<span class="hljs-string">' '</span>;<span class="hljs-keyword">else</span> s[i]=<span class="hljs-built_in">tolower</span>(s[i]);&#125;<span class="hljs-comment">//cout&lt;&lt;s&lt;&lt;endl;</span><span class="hljs-function"><span class="hljs-built_in">stringstream</span> <span class="hljs-title">ss</span><span class="hljs-params">(s)</span></span>;<span class="hljs-keyword">while</span>(ss&gt;&gt;ans)&#123;sset.insert(ans);&#125;&#125;<span class="hljs-keyword">for</span>(<span class="hljs-built_in">set</span>&lt;<span class="hljs-built_in">string</span>&gt;::iterator it=sset.begin();it!=sset.end();it++)&#123;<span class="hljs-built_in">cout</span>&lt;&lt;*it&lt;&lt;<span class="hljs-built_in">endl</span>;&#125;&#125;</code></pre><h1 id="收获与反思"><a href="#收获与反思" class="headerlink" title="收获与反思"></a>收获与反思</h1><ul><li>再多熟练运用一下stringstream</li></ul>]]></content>
    
    
    <categories>
      
      <category>Computer Science</category>
      
      <category>ACM</category>
      
      <category>UVA</category>
      
    </categories>
    
    
    <tags>
      
      <tag>ACM</tag>
      
      <tag>UVA</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>《我辈孤雏》读书笔记</title>
    <link href="/post/66258384.html"/>
    <url>/post/66258384.html</url>
    
    <content type="html"><![CDATA[<iframe frameborder="no" border="0" marginwidth="0" marginheight="0" width="330" height="86" src="//music.163.com/outchain/player?type=2&id=41462155&auto=1&height=66"></iframe><h1 id="内容摘录与笔记"><a href="#内容摘录与笔记" class="headerlink" title="内容摘录与笔记"></a>内容摘录与笔记</h1><h2 id="第一部"><a href="#第一部" class="headerlink" title="第一部"></a>第一部</h2><blockquote><p>P29 “我一时之间竟说不上话，后来总算把话吐出来：‘您真是太仁慈了，先生，您的协助，我感激不尽，而且我也不希望您以为我不懂事。<br>不过有一点请您谅解，我觉得我不该在这个时候返回英国。’上校一时之间并没有反应……”</p></blockquote><h2 id="第二部"><a href="#第二部" class="headerlink" title="第二部"></a>第二部</h2><blockquote><p>P68 “接下来是针针见血的猛烈抨击，她对督察所用的这一招，我早已熟悉，而日后也还要听她陈述其中概要好多次；她先泛泛地批评英国政府，<br>再把火力集中到私人企业，特别是摩根洋行身上，说他们不该从印度，输入这么庞大数量地鸦片到中国，然后冷眼旁观这整个民族陷入悲惨与堕落，<br>说的时候，母亲地声音常常高张欲裂，不过都尖而未破，她双眼始终不曾放松……”</p><p>P139 “这么多年来，她让我敬畏有加，可现在我明白这一切全是装腔作势：她丝毫无法控制这个逐渐将我们吞没的混乱世界，<br>她只是个可悲的小女人，全靠伪装在我眼中建立她的形象，当巨大势力相互冲突斗争之际，她根本贱于蝼蚁。<br>我站在走廊上瞪着她，眼神鄙夷至极。”</p></blockquote><a id="more"></a><h2 id="第三部"><a href="#第三部" class="headerlink" title="第三部"></a>第三部</h2><ul><li>再次出现系住百叶窗叶片地细绳。<blockquote><p>P153 “因为像您这样的人才，警探先生，这样的人才实在难得。像我们这样的人，我们的职责就是打击坏人，<br>我们……该怎么说好呢？我们就像系住百叶窗叶片的细绳。一旦我们系得不牢靠，一切都会分崩离析。您背负得责任可是相当重大啊，警探先生。”</p></blockquote></li></ul><h2 id="第四部"><a href="#第四部" class="headerlink" title="第四部"></a>第四部</h2><blockquote><p>P179 “‘不，不，先生’——格雷森先生紧张地笑了笑——‘我指地是另一个欢迎仪式。我的意思是，欢迎令尊令堂历劫多年归来地那个。’”</p></blockquote><h2 id="第五部"><a href="#第五部" class="headerlink" title="第五部"></a>第五部</h2><blockquote><p>P183 “从我抵达地那一刻起，真正教我心里暗暗吃惊的是，这里每一个人都拒绝承认他们都罪有应得。待在这里约两周地时间里，<br>在我所接触的所有这些英国人当中，无论地位高低，我都还没遇到——一次也没有——有谁真心感到愧疚。换言之，在这里，<br>在这个可能吞噬整个闻名世界地大漩涡的涡眼里，大家在心照不宣中无耻可悲地集体否认现实，否认自身的责任，而这种行为<br>转为自我封闭，变本加厉，以冠冕堂皇地自我保护表现于外，这是我经常碰到地情况。而现在眼前地这一群所谓上海的精英，<br>如此不屑一顾地凝望他们地中国邻居在运河对岸受苦受难。”</p></blockquote><h2 id="第六部"><a href="#第六部" class="headerlink" title="第六部"></a>第六部</h2><blockquote><p>P327 “桌上的阅读灯下有一圈温暖的光线，可是房中其他部分都一片幽暗。正当我站在那里观察周遭的情况，有个身影从书桌边站了起来，小心地绕过书桌，<br>回头指着桌后他空出来的座位。‘怎么不过去坐那儿，小海雀？’菲利普叔叔对我说，‘你还记得吧？你以前最喜欢坐我书桌后面的位子了。’”</p><p>P332 “‘那么我母亲呢？她发生了什么事？’  菲利普叔叔向前探身，双肘撑着桌子，头部微微往后仰。‘你对于她的事，现在知道的有多少？’他问。<br>他先前在声音里所表现的轻松已经完全消失。他现在看起来有如心事重重的老人，饱受自我悔恨的折磨。尽管他把头往后仰，却还是仔细盯着我看，桌灯的黄光<br>照拂下，看得他白色的鼻毛突出鼻孔。我听到楼下某处，正播放着中国军歌。”</p><p>P336 “我探身向他，进入桌灯炫目的光亮之中，我有种奇怪的感觉，身后的黑暗愈变愈大，此时在那里摊成了一大片幽暗无光的空间。菲利普叔叔用掌心<br>拭去前额的汗珠。不过他现在专注地看着我，继续说：‘那天后来我去新城饭店见王顾。我尽我所能化解可能面临的灾难。不过为时已晚。他那天下午对我说的话，<br>一点都没有生气的样子。他发现你母亲的精神——他就是这么说的，她的‘精神’——非常迷人。他已经为之倾倒，因此打算娶她为妾，带她回湖南。他说要‘驯服’她，<br>如同对待一匹野生的母马一样。这个你得理解，小海雀，你得理解那时候在上海、在中国是什么样的局势，像王顾这样的人，若是决定要做这类的事，谁也阻止不了他。<br>这点你必须理解。向警方或任何人要求保护你母亲，根本不会有结果。也许能暂时缓一缓，不过终究是无用。没有任何人能保护她，不让这种人得逞。不过你明白吗，<br>我真正担心的是你，小海雀。我不确定他打算怎么处置你，这才是我求他的事。结果我们达成协议。我想办法让她落单，无人守护，而同时我又把你带离现场。我只求他这件事。<br>我不希望他连你也带走。你母亲，只能说是在劫难逃。至于你，还有商量的余地，我就是做了这样的事。’”</p><p>P338 “‘菲利普叔叔，什么财务安排？’  他低头看着手背，端详了半晌。‘要不是为了你，她对你的爱，小海雀，我相信你母亲会毫不迟疑结束自己的生命，<br>不会让那个恶棍碰她一下。她总会有办法，也一定会做到。可是她还得担心你。因此，到了最后，她看情势比人强，便做了安排。你将会得到财务上的供应，<br>以换取……换取她的顺从。我亲自监督了大半的程序，经由公司来安排。公司里有个对这件事全无概念的人，还以为这是在为鸦片的安全运送做安排呢！哈！哈！<br>真是个傻子，那个人！’菲利普叔叔摇摇头，面露笑容。接着他的表情又阴沉起来，仿佛他要回到我们原先要谈的主题。   ‘我的生活费，’我平静地说，‘我继承的财产……’<br>‘你在英国的姑妈，她从来就没富有过。真正资助你的人，这么多年来，一直是王顾。’”</p></blockquote><p>在黑夜中摸索，希望能寻得父母那一辈所遗失的真相，奈何在现实的冷酷与成熟面前，我们终究不过孤雏而已，想象不到黑暗中那股势力的强大，压垮了我们本以为还算成熟的臂膀。<br>比起那个时代，我们算得上什么？太过渺小而已。</p><h2 id="第七部"><a href="#第七部" class="headerlink" title="第七部"></a>第七部</h2><blockquote><p>P363 “不过，对于我们这种人而言，我们的命运是以孤儿的眼光看待世界，长年追逐着父母消逝的暗影。我们只有尽全力把使命完成，别无解脱之途，<br>在此之前，心中无法得到片刻的宁静。”</p></blockquote>]]></content>
    
    
    <categories>
      
      <category>Life</category>
      
      <category>阅读</category>
      
    </categories>
    
    
    <tags>
      
      <tag>阅读</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>【POJ-3660】解题报告（Floyd传递闭包）</title>
    <link href="/post/6fc3409b.html"/>
    <url>/post/6fc3409b.html</url>
    
    <content type="html"><![CDATA[<h1 id="原始题目"><a href="#原始题目" class="headerlink" title="原始题目"></a>原始题目</h1><h2 id="Cow-Contest"><a href="#Cow-Contest" class="headerlink" title="Cow Contest"></a>Cow Contest</h2><ul><li>Time Limit: 1000MS        </li><li>Memory Limit: 65536K</li><li>Total Submissions: 15815        </li><li>Accepted: 8813</li></ul><h3 id="Description"><a href="#Description" class="headerlink" title="Description"></a>Description</h3><p>N (1 ≤ N ≤ 100) cows, conveniently numbered 1..N, are participating in a programming contest. As we all know, some cows code better than others. Each cow has a certain constant skill rating that is unique among the competitors.</p><p>The contest is conducted in several head-to-head rounds, each between two cows. If cow A has a greater skill level than cow B (1 ≤ A ≤ N; 1 ≤ B ≤ N; A ≠ B), then cow A will always beat cow B.</p><p>Farmer John is trying to rank the cows by skill level. Given a list the results of M (1 ≤ M ≤ 4,500) two-cow rounds, determine the number of cows whose ranks can be precisely determined from the results. It is guaranteed that the results of the rounds will not be contradictory.<br><a id="more"></a></p><h3 id="Input"><a href="#Input" class="headerlink" title="Input"></a>Input</h3><ul><li>Line 1: Two space-separated integers: N and M</li><li>Lines 2..M+1: Each line contains two space-separated integers that describe the competitors and results (the first integer, A, is the winner) of a single round of competition: A and B</li></ul><h3 id="Output"><a href="#Output" class="headerlink" title="Output"></a>Output</h3><ul><li>Line 1: A single integer representing the number of cows whose ranks can be determined　</li></ul><h3 id="Sample-Input"><a href="#Sample-Input" class="headerlink" title="Sample Input"></a>Sample Input</h3><pre><code>5 54 34 23 21 22 5</code></pre><h3 id="Sample-Output"><a href="#Sample-Output" class="headerlink" title="Sample Output"></a>Sample Output</h3><pre><code>2</code></pre><h3 id="Source"><a href="#Source" class="headerlink" title="Source"></a>Source</h3><p>USACO 2008 January Silver</p><h1 id="题目大意"><a href="#题目大意" class="headerlink" title="题目大意"></a>题目大意</h1><p>一共有N头牛，现在知道M条信息，每条信息描述两头牛谁更强一些，问可以确定最多多少头牛的排名。</p><h1 id="解题思路"><a href="#解题思路" class="headerlink" title="解题思路"></a>解题思路</h1><ul><li>还在学习中，使用Floyd算法求闭包，（A胜B，B胜C，则传递A胜C）</li><li>然后对于每头牛扫一遍是否与其他n-1头牛都有确定的胜负关系，如果有的话答案++。</li><li>还需要深入学习Floyd算法</li></ul><h1 id="解题代码"><a href="#解题代码" class="headerlink" title="解题代码"></a>解题代码</h1><pre><code class="hljs C++"><span class="hljs-meta">#<span class="hljs-meta-keyword">include</span> <span class="hljs-meta-string">&lt;cstdio&gt;</span></span><span class="hljs-meta">#<span class="hljs-meta-keyword">include</span> <span class="hljs-meta-string">&lt;cstring&gt;</span></span><span class="hljs-meta">#<span class="hljs-meta-keyword">include</span> <span class="hljs-meta-string">&lt;cmath&gt;</span></span><span class="hljs-meta">#<span class="hljs-meta-keyword">include</span> <span class="hljs-meta-string">&lt;iostream&gt;</span></span><span class="hljs-meta">#<span class="hljs-meta-keyword">include</span> <span class="hljs-meta-string">&lt;iomanip&gt;</span></span><span class="hljs-meta">#<span class="hljs-meta-keyword">include</span> <span class="hljs-meta-string">&lt;algorithm&gt;</span></span><span class="hljs-meta">#<span class="hljs-meta-keyword">include</span> <span class="hljs-meta-string">&lt;set&gt;</span></span><span class="hljs-meta">#<span class="hljs-meta-keyword">include</span> <span class="hljs-meta-string">&lt;map&gt;</span></span><span class="hljs-meta">#<span class="hljs-meta-keyword">include</span> <span class="hljs-meta-string">&lt;vector&gt;</span></span><span class="hljs-meta">#<span class="hljs-meta-keyword">include</span> <span class="hljs-meta-string">&lt;stack&gt;</span></span><span class="hljs-meta">#<span class="hljs-meta-keyword">include</span> <span class="hljs-meta-string">&lt;queue&gt;</span></span><span class="hljs-meta">#<span class="hljs-meta-keyword">define</span> mp make_pair</span><span class="hljs-meta">#<span class="hljs-meta-keyword">define</span> pb push_back</span><span class="hljs-meta">#<span class="hljs-meta-keyword">define</span> np next_permutation</span><span class="hljs-meta">#<span class="hljs-meta-keyword">define</span> rep(i,a,n) for(int i=a;i&lt;n;++i)</span><span class="hljs-meta">#<span class="hljs-meta-keyword">define</span> per(i,a,n) for(int i=n-1;i&gt;=a;--i)</span><span class="hljs-meta">#<span class="hljs-meta-keyword">define</span> first fi</span><span class="hljs-meta">#<span class="hljs-meta-keyword">define</span> second se</span><span class="hljs-meta">#<span class="hljs-meta-keyword">define</span> eps 1e-9</span><span class="hljs-meta">#<span class="hljs-meta-keyword">define</span> INF 0x3f3f3f3f</span><span class="hljs-meta">#<span class="hljs-meta-keyword">define</span> ms(x,a) memset((x),a,sizeof((x)))</span><span class="hljs-meta">#<span class="hljs-meta-keyword">define</span> all(x) x.begin(),x.end()</span><span class="hljs-meta">#<span class="hljs-meta-keyword">define</span> gapline cout&lt;&lt;<span class="hljs-meta-string">"##================##"</span>&lt;&lt;endl</span><span class="hljs-keyword">using</span> <span class="hljs-keyword">namespace</span> <span class="hljs-built_in">std</span>;<span class="hljs-keyword">const</span> <span class="hljs-keyword">int</span> maxn=<span class="hljs-number">1e3</span>+<span class="hljs-number">5</span>;<span class="hljs-keyword">const</span> <span class="hljs-keyword">int</span> mal=<span class="hljs-number">26</span>;<span class="hljs-keyword">typedef</span> <span class="hljs-keyword">long</span> <span class="hljs-keyword">long</span> ll;<span class="hljs-keyword">typedef</span> <span class="hljs-keyword">unsigned</span> <span class="hljs-keyword">long</span> <span class="hljs-keyword">long</span> ull;<span class="hljs-keyword">typedef</span> <span class="hljs-built_in">vector</span>&lt;<span class="hljs-keyword">int</span>&gt; vi;<span class="hljs-keyword">typedef</span> pair&lt;<span class="hljs-keyword">int</span>,<span class="hljs-keyword">int</span>&gt; pii;<span class="hljs-keyword">bool</span> ans[maxn][maxn];<span class="hljs-keyword">int</span> n,m;<span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">Floyd</span><span class="hljs-params">()</span></span>&#123;rep(k,<span class="hljs-number">1</span>,n+<span class="hljs-number">1</span>)rep(i,<span class="hljs-number">1</span>,n+<span class="hljs-number">1</span>)rep(j,<span class="hljs-number">1</span>,n+<span class="hljs-number">1</span>)ans[i][j]=ans[i][j]|(ans[i][k]&amp;ans[k][j]); &#125;<span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span>&#123;ios::sync_with_stdio(<span class="hljs-literal">false</span>);<span class="hljs-keyword">while</span>(<span class="hljs-built_in">cin</span>&gt;&gt;n)&#123;<span class="hljs-built_in">cin</span>&gt;&gt;m;ms(ans,<span class="hljs-number">0</span>);rep(i,<span class="hljs-number">0</span>,m)&#123;<span class="hljs-keyword">int</span> a,b;<span class="hljs-built_in">cin</span>&gt;&gt;a&gt;&gt;b;ans[a][b]=<span class="hljs-number">1</span>;&#125;Floyd();<span class="hljs-keyword">int</span> aans=<span class="hljs-number">0</span>;rep(i,<span class="hljs-number">1</span>,n+<span class="hljs-number">1</span>)&#123;<span class="hljs-keyword">int</span> ccnt=<span class="hljs-number">0</span>;rep(j,<span class="hljs-number">1</span>,n+<span class="hljs-number">1</span>)&#123;<span class="hljs-keyword">if</span>(ans[i][j]||ans[j][i]) ccnt++;&#125;<span class="hljs-keyword">if</span>(ccnt==n<span class="hljs-number">-1</span>) aans++; &#125;<span class="hljs-built_in">cout</span>&lt;&lt;aans&lt;&lt;<span class="hljs-built_in">endl</span>;&#125; &#125;</code></pre><h1 id="收获与反思"><a href="#收获与反思" class="headerlink" title="收获与反思"></a>收获与反思</h1><ul><li>挖坑，加强理解Floyd最短路算法。</li></ul>]]></content>
    
    
    <categories>
      
      <category>Computer Science</category>
      
      <category>ACM</category>
      
      <category>POJ</category>
      
    </categories>
    
    
    <tags>
      
      <tag>ACM</tag>
      
      <tag>POJ</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>【HDU-1548】解题报告（BFS）</title>
    <link href="/post/ac92be99.html"/>
    <url>/post/ac92be99.html</url>
    
    <content type="html"><![CDATA[<h1 id="原始题目"><a href="#原始题目" class="headerlink" title="原始题目"></a>原始题目</h1><h2 id="A-strange-lift"><a href="#A-strange-lift" class="headerlink" title="A strange lift"></a>A strange lift</h2><ul><li>Time Limit: 2000/1000 MS (Java/Others)    </li><li>Memory Limit: 65536/32768 K (Java/Others)</li><li>Total Submission(s): 32759    </li><li>Accepted Submission(s): 11752</li></ul><h3 id="Problem-Description"><a href="#Problem-Description" class="headerlink" title="Problem Description"></a>Problem Description</h3><p>There is a strange lift.The lift can stop can at every floor as you want, and there is a number $K_i (0 \le  K_i \le  N) $ on every floor.The lift have just two buttons: up and down.When you at floor i,if you press the button “UP” , you will go up $K_i$ floor,i.e,you will go to the i+Ki th floor,as the same, if you press the button “DOWN” , you will go down $K_i$ floor,i.e,you will go to the i-Ki th floor.<br>Of course, the lift can’t go up high than N,and can’t go down lower than 1. For example, there is a buliding with 5 floors, and $k_1 = 3, k_2 = 3 , k_3 = 1 , k_4 = 2 , k_5 = 5 . $ Begining from the 1 st floor,you can press the button “UP”, and you’ll go up to the 4 th floor,and if you press the button “DOWN”, the lift can’t do it, because it can’t go down to the -2 th floor,as you know ,the -2 th floor isn’t exist.</p><p>Here comes the problem: when you are on floor A,and you want to go to floor B,how many times at least he has to press the button “UP” or “DOWN”?<br><a id="more"></a></p><h3 id="Input"><a href="#Input" class="headerlink" title="Input"></a>Input</h3><p>The input consists of several test cases.,Each test case contains two lines.</p><p>The first line contains three integers $N,A,B( 1 \le  N,A,B \le  200)$ which describe above,The second line consist $N$ integers $k_1,k_2  \cdots k_n$ .</p><p>A single 0 indicate the end of the input.</p><h3 id="Output"><a href="#Output" class="headerlink" title="Output"></a>Output</h3><p>For each case of the input output a interger, the least times you have to press the button when you on floor A,and you want to go to floor B.If you can’t reach floor B,printf “-1”.</p><h3 id="Sample-Input"><a href="#Sample-Input" class="headerlink" title="Sample Input"></a>Sample Input</h3><pre><code>5 1 53 3 1 2 50</code></pre><h3 id="Sample-Output"><a href="#Sample-Output" class="headerlink" title="Sample Output"></a>Sample Output</h3><pre><code>3</code></pre><h3 id="Recommend"><a href="#Recommend" class="headerlink" title="Recommend"></a>Recommend</h3><pre><code>8600</code></pre><h1 id="题目大意"><a href="#题目大意" class="headerlink" title="题目大意"></a>题目大意</h1><p>有一个电梯，对于每一层$i$，只能上升或者下降$a_i$（不能低于$1$层或高于$n$层），现在给定初态层数和末态层数，<br>问最少需要操作几次才可以达到末态层数。到达不了输出-1。</p><h1 id="解题思路"><a href="#解题思路" class="headerlink" title="解题思路"></a>解题思路</h1><ul><li>两方向BFS，注意打标记和输出-1的情况即可。</li></ul><h1 id="解题代码"><a href="#解题代码" class="headerlink" title="解题代码"></a>解题代码</h1><pre><code class="hljs C++"><span class="hljs-meta">#<span class="hljs-meta-keyword">include</span> <span class="hljs-meta-string">&lt;cstdio&gt;</span></span><span class="hljs-meta">#<span class="hljs-meta-keyword">include</span> <span class="hljs-meta-string">&lt;cstring&gt;</span></span><span class="hljs-meta">#<span class="hljs-meta-keyword">include</span> <span class="hljs-meta-string">&lt;iostream&gt;</span></span><span class="hljs-meta">#<span class="hljs-meta-keyword">include</span> <span class="hljs-meta-string">&lt;iomanip&gt;</span></span><span class="hljs-meta">#<span class="hljs-meta-keyword">include</span> <span class="hljs-meta-string">&lt;map&gt;</span></span><span class="hljs-meta">#<span class="hljs-meta-keyword">include</span> <span class="hljs-meta-string">&lt;set&gt;</span></span><span class="hljs-meta">#<span class="hljs-meta-keyword">include</span> <span class="hljs-meta-string">&lt;algorithm&gt;</span></span><span class="hljs-meta">#<span class="hljs-meta-keyword">include</span> <span class="hljs-meta-string">&lt;queue&gt;</span></span><span class="hljs-meta">#<span class="hljs-meta-keyword">include</span> <span class="hljs-meta-string">&lt;vector&gt;</span></span><span class="hljs-meta">#<span class="hljs-meta-keyword">include</span> <span class="hljs-meta-string">&lt;stack&gt;</span></span><span class="hljs-comment">//#include &lt;bits/stdc++.h&gt;</span><span class="hljs-comment">//#define mp make_pair</span><span class="hljs-meta">#<span class="hljs-meta-keyword">define</span> np next_permutation</span><span class="hljs-meta">#<span class="hljs-meta-keyword">define</span> pb push_back</span><span class="hljs-meta">#<span class="hljs-meta-keyword">define</span> fi first</span><span class="hljs-meta">#<span class="hljs-meta-keyword">define</span> se second</span><span class="hljs-meta">#<span class="hljs-meta-keyword">define</span> eps 1e-8</span><span class="hljs-meta">#<span class="hljs-meta-keyword">define</span> INF 0x3f3f3f3f</span><span class="hljs-meta">#<span class="hljs-meta-keyword">define</span> rep(i,a,n) for(int i=a;i&lt;n;++i)</span><span class="hljs-meta">#<span class="hljs-meta-keyword">define</span> per(i,a,n) for(int i=n-1;i&gt;=a;--i)</span><span class="hljs-keyword">using</span> <span class="hljs-keyword">namespace</span> <span class="hljs-built_in">std</span>;<span class="hljs-keyword">typedef</span> <span class="hljs-keyword">long</span> <span class="hljs-keyword">long</span> ll;<span class="hljs-keyword">typedef</span> <span class="hljs-keyword">unsigned</span> <span class="hljs-keyword">long</span> <span class="hljs-keyword">long</span> ull;<span class="hljs-keyword">typedef</span> <span class="hljs-built_in">vector</span>&lt;<span class="hljs-keyword">int</span>&gt; vi;<span class="hljs-keyword">typedef</span> pair&lt;<span class="hljs-keyword">int</span>,<span class="hljs-keyword">int</span>&gt; pii;<span class="hljs-keyword">const</span> <span class="hljs-keyword">int</span> maxn=<span class="hljs-number">1e4</span>+<span class="hljs-number">5</span>;<span class="hljs-keyword">int</span> vis[maxn];<span class="hljs-keyword">int</span> mp[maxn],n,a,b;<span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">bfs</span><span class="hljs-params">()</span></span>&#123;<span class="hljs-keyword">int</span> ans=<span class="hljs-number">0</span>;<span class="hljs-keyword">int</span> flag=<span class="hljs-number">0</span>;<span class="hljs-built_in">queue</span>&lt;pii&gt;q;q.push(make_pair(a,<span class="hljs-number">0</span>));<span class="hljs-built_in">memset</span>(vis,<span class="hljs-number">0</span>,<span class="hljs-keyword">sizeof</span>(vis));vis[a]=<span class="hljs-number">1</span>;<span class="hljs-keyword">while</span>(!q.empty())&#123;pii now=q.front();q.pop();<span class="hljs-keyword">if</span>(now.fi==b)&#123;<span class="hljs-built_in">cout</span>&lt;&lt;now.second&lt;&lt;<span class="hljs-built_in">endl</span>;flag=<span class="hljs-number">1</span>;<span class="hljs-keyword">break</span>;&#125;<span class="hljs-keyword">int</span> down=now.fi-mp[now.fi];<span class="hljs-keyword">int</span> up=now.fi+mp[now.fi];<span class="hljs-comment">//cout&lt;&lt;"up="&lt;&lt;up&lt;&lt;"  down="&lt;&lt;down&lt;&lt;endl;</span><span class="hljs-keyword">if</span>(down&gt;=<span class="hljs-number">1</span> &amp;&amp; !vis[down])&#123;vis[down]=<span class="hljs-number">1</span>;q.push(make_pair(down,now.second+<span class="hljs-number">1</span>));&#125;<span class="hljs-keyword">if</span>(up&lt;=n &amp;&amp; !vis[up])&#123;vis[up]=<span class="hljs-number">1</span>;q.push(make_pair(up,now.second+<span class="hljs-number">1</span>));&#125;&#125;<span class="hljs-keyword">if</span>(!flag) <span class="hljs-built_in">cout</span>&lt;&lt;<span class="hljs-number">-1</span>&lt;&lt;<span class="hljs-built_in">endl</span>;&#125;<span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span>&#123;ios::sync_with_stdio(<span class="hljs-literal">false</span>);<span class="hljs-keyword">while</span>(<span class="hljs-built_in">cin</span>&gt;&gt;n&amp;&amp;n)&#123;<span class="hljs-built_in">cin</span>&gt;&gt;a&gt;&gt;b;rep(i,<span class="hljs-number">1</span>,n+<span class="hljs-number">1</span>)<span class="hljs-built_in">cin</span>&gt;&gt;mp[i];bfs();&#125; &#125;</code></pre><h1 id="收获与反思"><a href="#收获与反思" class="headerlink" title="收获与反思"></a>收获与反思</h1><ul><li>简单bfs，注意打对标记即可。</li></ul>]]></content>
    
    
    <categories>
      
      <category>Computer Science</category>
      
      <category>ACM</category>
      
      <category>HDU</category>
      
    </categories>
    
    
    <tags>
      
      <tag>ACM</tag>
      
      <tag>HDU</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>【CodeForces-579A】解题报告（二进制）</title>
    <link href="/post/c37095b9.html"/>
    <url>/post/c37095b9.html</url>
    
    <content type="html"><![CDATA[<h1 id="原始题目"><a href="#原始题目" class="headerlink" title="原始题目"></a>原始题目</h1><h2 id="A-Raising-Bacteria"><a href="#A-Raising-Bacteria" class="headerlink" title="A. Raising Bacteria"></a>A. Raising Bacteria</h2><ul><li>time limit per test1 second</li><li>memory limit per test256 megabytes</li><li>inputstandard input</li><li>outputstandard output</li></ul><p>You are a lover of bacteria. You want to raise some bacteria in a box.</p><p>Initially, the box is empty. Each morning, you can put any number of bacteria into the box. And each night, every bacterium in the box will split into two bacteria. You hope to see exactly x bacteria in the box at some moment.</p><p>What is the minimum number of bacteria you need to put into the box across those days?<br><a id="more"></a></p><h3 id="Input"><a href="#Input" class="headerlink" title="Input"></a>Input</h3><p>The only line containing one integer x (1 ≤ x ≤ $10^9$).</p><h3 id="Output"><a href="#Output" class="headerlink" title="Output"></a>Output</h3><p>The only line containing one integer: the answer.</p><h3 id="Examples"><a href="#Examples" class="headerlink" title="Examples"></a>Examples</h3><h3 id="input"><a href="#input" class="headerlink" title="input"></a>input</h3><pre><code>5</code></pre><h3 id="output"><a href="#output" class="headerlink" title="output"></a>output</h3><pre><code>2</code></pre><h3 id="input-1"><a href="#input-1" class="headerlink" title="input"></a>input</h3><pre><code>8</code></pre><h3 id="output-1"><a href="#output-1" class="headerlink" title="output"></a>output</h3><pre><code>1</code></pre><h3 id="Note"><a href="#Note" class="headerlink" title="Note"></a>Note</h3><p>For the first sample, we can add one bacterium in the box in the first day morning and at the third morning there will be 4 bacteria in the box. Now we put one more resulting 5 in the box. We added 2 bacteria in the process so the answer is 2.</p><p>For the second sample, we can put one in the first morning and in the 4-th morning there will be 8 in the box. So the answer is 1.</p><h1 id="题目大意"><a href="#题目大意" class="headerlink" title="题目大意"></a>题目大意</h1><p>初始盒子是空的，每天早晨你可以放任意个细菌到盒子盒子中去，每个细菌在盒子中每天分裂成两个。现在给出x，问最少需要放多少个细菌可以使<br>一定天数后盒子中细菌数量恰好为x。</p><h1 id="解题思路"><a href="#解题思路" class="headerlink" title="解题思路"></a>解题思路</h1><ul><li>在不限制天数的情况下，恰巧达到x就让每个放入的细菌尽可能繁殖</li><li>将x用二进制表示，有多少个1即为答案。</li></ul><h1 id="解题代码"><a href="#解题代码" class="headerlink" title="解题代码"></a>解题代码</h1><pre><code class="hljs C++"><span class="hljs-meta">#<span class="hljs-meta-keyword">include</span> <span class="hljs-meta-string">&lt;cstdio&gt;</span></span><span class="hljs-meta">#<span class="hljs-meta-keyword">include</span> <span class="hljs-meta-string">&lt;cstring&gt;</span></span><span class="hljs-meta">#<span class="hljs-meta-keyword">include</span> <span class="hljs-meta-string">&lt;iostream&gt;</span></span><span class="hljs-meta">#<span class="hljs-meta-keyword">include</span> <span class="hljs-meta-string">&lt;iomanip&gt;</span></span><span class="hljs-meta">#<span class="hljs-meta-keyword">include</span> <span class="hljs-meta-string">&lt;map&gt;</span></span><span class="hljs-meta">#<span class="hljs-meta-keyword">include</span> <span class="hljs-meta-string">&lt;set&gt;</span></span><span class="hljs-meta">#<span class="hljs-meta-keyword">include</span> <span class="hljs-meta-string">&lt;algorithm&gt;</span></span><span class="hljs-meta">#<span class="hljs-meta-keyword">include</span> <span class="hljs-meta-string">&lt;queue&gt;</span></span><span class="hljs-meta">#<span class="hljs-meta-keyword">include</span> <span class="hljs-meta-string">&lt;vector&gt;</span></span><span class="hljs-meta">#<span class="hljs-meta-keyword">include</span> <span class="hljs-meta-string">&lt;stack&gt;</span></span><span class="hljs-meta">#<span class="hljs-meta-keyword">include</span> <span class="hljs-meta-string">&lt;bits/stdc++.h&gt;</span></span><span class="hljs-meta">#<span class="hljs-meta-keyword">define</span> mp make_pair</span><span class="hljs-meta">#<span class="hljs-meta-keyword">define</span> np next_permutation</span><span class="hljs-meta">#<span class="hljs-meta-keyword">define</span> pb push_back</span><span class="hljs-meta">#<span class="hljs-meta-keyword">define</span> fi first</span><span class="hljs-meta">#<span class="hljs-meta-keyword">define</span> se second</span><span class="hljs-meta">#<span class="hljs-meta-keyword">define</span> eps 1e-8</span><span class="hljs-meta">#<span class="hljs-meta-keyword">define</span> INF 0x3f3f3f3f</span><span class="hljs-keyword">using</span> <span class="hljs-keyword">namespace</span> <span class="hljs-built_in">std</span>;<span class="hljs-keyword">typedef</span> <span class="hljs-keyword">long</span> <span class="hljs-keyword">long</span> ll;<span class="hljs-keyword">typedef</span> <span class="hljs-keyword">unsigned</span> <span class="hljs-keyword">long</span> <span class="hljs-keyword">long</span> ull;<span class="hljs-keyword">typedef</span> <span class="hljs-built_in">vector</span>&lt;<span class="hljs-keyword">int</span>&gt; vi;<span class="hljs-keyword">typedef</span> pair&lt;<span class="hljs-keyword">int</span>,<span class="hljs-keyword">int</span>&gt; pii;<span class="hljs-keyword">const</span> <span class="hljs-keyword">int</span> maxn=<span class="hljs-number">1e5</span>+<span class="hljs-number">5</span>;<span class="hljs-keyword">const</span> <span class="hljs-keyword">int</span> maxl=<span class="hljs-number">26</span>;ll n;<span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span>&#123;ios::sync_with_stdio(<span class="hljs-literal">false</span>);<span class="hljs-keyword">while</span>(<span class="hljs-built_in">cin</span>&gt;&gt;n)&#123;ll ans=<span class="hljs-number">0</span>;<span class="hljs-keyword">while</span>(n)&#123;<span class="hljs-keyword">if</span>(n&amp;<span class="hljs-number">1</span>) ans++;n&gt;&gt;=<span class="hljs-number">1</span>;&#125;<span class="hljs-built_in">cout</span>&lt;&lt;ans&lt;&lt;<span class="hljs-built_in">endl</span>;&#125;&#125;</code></pre><h1 id="收获与反思"><a href="#收获与反思" class="headerlink" title="收获与反思"></a>收获与反思</h1><ul><li>思维</li></ul>]]></content>
    
    
    <categories>
      
      <category>Computer Science</category>
      
      <category>ACM</category>
      
      <category>CodeForces</category>
      
    </categories>
    
    
    <tags>
      
      <tag>ACM</tag>
      
      <tag>CodeForces</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>【HDU-1430】解题报告（数论，康拓展开逆展开，简单哈希，BFS）</title>
    <link href="/post/6f3b3edd.html"/>
    <url>/post/6f3b3edd.html</url>
    
    <content type="html"><![CDATA[<h1 id="原始题目"><a href="#原始题目" class="headerlink" title="原始题目"></a>原始题目</h1><h2 id="魔板"><a href="#魔板" class="headerlink" title="魔板"></a>魔板</h2><ul><li>Time Limit: 10000/5000 MS (Java/Others)    </li><li>Memory Limit: 65536/32768 K (Java/Others)</li><li>Total Submission(s): 4318    </li><li>Accepted Submission(s): 1033</li></ul><h3 id="Problem-Description"><a href="#Problem-Description" class="headerlink" title="Problem Description"></a>Problem Description</h3><p>在魔方风靡全球之后不久，Rubik先生发明了它的简化版——魔板。魔板由8个同样大小的方块组成，每个方块颜色均不相同，可用数字1-8分别表示。任一时刻魔板的状态可用方块的颜色序列表示：从魔板的左上角开始，按顺时针方向依次写下各方块的颜色代号，所得到的数字序列即可表示此时魔板的状态。例如，序列(1,2,3,4,5,6,7,8)表示魔板状态为：</p><p>1 2 3 4<br>8 7 6 5</p><p>对于魔板，可施加三种不同的操作，具体操作方法如下：</p><ul><li>A: 上下两行互换,如上图可变换为状态87654321</li><li>B: 每行同时循环右移一格,如上图可变换为41236785</li><li>C: 中间4个方块顺时针旋转一格,如上图可变换为17245368</li></ul><p>给你魔板的初始状态与目标状态，请给出由初态到目态变换数最少的变换步骤，若有多种变换方案则取字典序最小的那种。</p><a id="more"></a><h3 id="Input"><a href="#Input" class="headerlink" title="Input"></a>Input</h3><p>每组测试数据包括两行，分别代表魔板的初态与目态。</p><h3 id="Output"><a href="#Output" class="headerlink" title="Output"></a>Output</h3><p>对每组测试数据输出满足题意的变换步骤。</p><h3 id="Sample-Input"><a href="#Sample-Input" class="headerlink" title="Sample Input"></a>Sample Input</h3><pre><code>12345678172453681234567882754631</code></pre><h3 id="Sample-Output"><a href="#Sample-Output" class="headerlink" title="Sample Output"></a>Sample Output</h3><pre><code>CAC</code></pre><h3 id="Author"><a href="#Author" class="headerlink" title="Author"></a>Author</h3><p>LL</p><h3 id="Source"><a href="#Source" class="headerlink" title="Source"></a>Source</h3><p>ACM暑期集训队练习赛（三）</p><h3 id="Recommend"><a href="#Recommend" class="headerlink" title="Recommend"></a>Recommend</h3><p>linle</p><h1 id="题目大意"><a href="#题目大意" class="headerlink" title="题目大意"></a>题目大意</h1><p>如题</p><h1 id="解题思路"><a href="#解题思路" class="headerlink" title="解题思路"></a>解题思路</h1><ul><li>先考虑暴力，对于每个初态，按A，B，C的顺序BFS，到末态，输出。</li><li>不过，似乎有些问题。</li><li>问题1：如何表示状态？</li><li>问题2：多组数据每次都BFS的话，会T，咋办？</li></ul><p>对于问题1，我们不难发现，不同状态其实对应了1-8的一个排列，很明显根据常识我们知道排列是有顺序的（逆序数逐渐增大）<br>那么我们可否根据排列的数组得到他对应全排列里的序号？其实这和康托展开就搭上关系了。</p><ul><li>康拓展开：康托展开是一个全排列到一个自然数的双射，常用于构建哈希表时的空间压缩。 康托展开的实质是计算当前排列在所有由小到大全排列中的顺序，因此是可逆的。</li></ul><p>稍微详细点的介绍放在收获与反思里。</p><p>这样我们就解决了表示状态的问题。</p><p>那么对于问题2呢。我们会发现，魔板从初态到末态，重要的是每个板子相对位置的变化，而不是板子的数。换言之，我们可以做一个初态到’12345678’的映射，重新给板子标号，<br>再将末态各板子按映射关系对应新的标号，即末态按照映射对应一个新标号的末态。</p><pre><code>初态        末态75621483 -&gt; 13846572↓ 映射12345678 -&gt; 58763214</code></pre><p>代码为</p><pre><code>rep(i,0,len1){    hhash[raw1[i]-&#39;0&#39;]=i+1;}rep(i,0,len1){    b[i]=hhash[raw2[i]-&#39;0&#39;];    }</code></pre><p>保留板子相对移动的位置不变化即可，这样我们只要预处理一下’12345678’到各个排列的末态，然后对每组输入，做映射到’12345678’，输出新末态的结果即可。   </p><h1 id="解题代码"><a href="#解题代码" class="headerlink" title="解题代码"></a>解题代码</h1><pre><code class="hljs C++"><span class="hljs-meta">#<span class="hljs-meta-keyword">include</span> <span class="hljs-meta-string">&lt;cstdio&gt;</span></span><span class="hljs-meta">#<span class="hljs-meta-keyword">include</span> <span class="hljs-meta-string">&lt;cstring&gt;</span></span><span class="hljs-meta">#<span class="hljs-meta-keyword">include</span> <span class="hljs-meta-string">&lt;cmath&gt;</span></span><span class="hljs-meta">#<span class="hljs-meta-keyword">include</span> <span class="hljs-meta-string">&lt;string&gt;</span></span><span class="hljs-meta">#<span class="hljs-meta-keyword">include</span> <span class="hljs-meta-string">&lt;iostream&gt;</span></span><span class="hljs-meta">#<span class="hljs-meta-keyword">include</span> <span class="hljs-meta-string">&lt;iomanip&gt;</span></span><span class="hljs-meta">#<span class="hljs-meta-keyword">include</span> <span class="hljs-meta-string">&lt;sstream&gt;</span></span><span class="hljs-meta">#<span class="hljs-meta-keyword">include</span> <span class="hljs-meta-string">&lt;set&gt;</span></span><span class="hljs-meta">#<span class="hljs-meta-keyword">include</span> <span class="hljs-meta-string">&lt;map&gt;</span></span><span class="hljs-meta">#<span class="hljs-meta-keyword">include</span> <span class="hljs-meta-string">&lt;queue&gt;</span></span><span class="hljs-meta">#<span class="hljs-meta-keyword">include</span> <span class="hljs-meta-string">&lt;vector&gt;</span></span><span class="hljs-meta">#<span class="hljs-meta-keyword">include</span> <span class="hljs-meta-string">&lt;bits/stdc++.h&gt;</span></span><span class="hljs-meta">#<span class="hljs-meta-keyword">define</span> INF 0x3f3f3f3f</span><span class="hljs-meta">#<span class="hljs-meta-keyword">define</span> eps 1e-8</span><span class="hljs-meta">#<span class="hljs-meta-keyword">define</span> mp make_pair</span><span class="hljs-meta">#<span class="hljs-meta-keyword">define</span> np next_permutation</span><span class="hljs-meta">#<span class="hljs-meta-keyword">define</span> pb push_back</span><span class="hljs-meta">#<span class="hljs-meta-keyword">define</span> all(x) x.begin(),x.end()</span><span class="hljs-meta">#<span class="hljs-meta-keyword">define</span> rep(i,a,n) for(int i=a;i&lt;n;++i)</span><span class="hljs-meta">#<span class="hljs-meta-keyword">define</span> per(i,a,n) for(int i=n-1;i&gt;=a;--i)</span><span class="hljs-meta">#<span class="hljs-meta-keyword">define</span> ms(x,a) memset((x),a,sizeof((x))) </span><span class="hljs-meta">#<span class="hljs-meta-keyword">define</span> mod 998244353 </span><span class="hljs-meta">#<span class="hljs-meta-keyword">define</span> gapline  cout&lt;&lt;<span class="hljs-meta-string">"##---------------##"</span>&lt;&lt;endl</span><span class="hljs-keyword">using</span> <span class="hljs-keyword">namespace</span> <span class="hljs-built_in">std</span>;<span class="hljs-keyword">typedef</span> <span class="hljs-keyword">long</span> <span class="hljs-keyword">long</span> ll;<span class="hljs-keyword">typedef</span> <span class="hljs-keyword">unsigned</span> <span class="hljs-keyword">long</span> <span class="hljs-keyword">long</span> ull;<span class="hljs-keyword">typedef</span> <span class="hljs-built_in">vector</span>&lt;<span class="hljs-keyword">int</span>&gt; vi;<span class="hljs-keyword">typedef</span> pair&lt;<span class="hljs-keyword">int</span>,<span class="hljs-keyword">int</span>&gt; pii;<span class="hljs-keyword">const</span> <span class="hljs-keyword">int</span> maxl=<span class="hljs-number">8</span>;<span class="hljs-keyword">const</span> <span class="hljs-keyword">int</span> maxn=<span class="hljs-number">1e5</span>+<span class="hljs-number">5</span>;<span class="hljs-keyword">int</span> A[maxl];<span class="hljs-comment">//阶乘； </span><span class="hljs-keyword">int</span> ans_cantor[maxl];<span class="hljs-comment">//康托展开数组 </span><span class="hljs-keyword">int</span> next_cantor[maxl];<span class="hljs-keyword">bool</span> vis_cantor[maxl];<span class="hljs-comment">//康托标记数组 </span><span class="hljs-keyword">bool</span> vis[maxn];<span class="hljs-keyword">int</span> hhash[<span class="hljs-number">20</span>],b[<span class="hljs-number">20</span>];<span class="hljs-built_in">string</span> ans[maxn];<span class="hljs-built_in">string</span> raw1,raw2;<span class="hljs-built_in">queue</span> &lt;ll&gt; q;<span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">prechange</span><span class="hljs-params">()</span></span>&#123;<span class="hljs-keyword">int</span> len1=raw1.length();rep(i,<span class="hljs-number">0</span>,len1)&#123;hhash[raw1[i]-<span class="hljs-string">'0'</span>]=i+<span class="hljs-number">1</span>;&#125;rep(i,<span class="hljs-number">0</span>,len1)&#123;b[i]=hhash[raw2[i]-<span class="hljs-string">'0'</span>];&#125;&#125;<span class="hljs-comment">//contar展开，逆展开，数组标号都是从0开始 </span><span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">cantor</span><span class="hljs-params">(<span class="hljs-keyword">int</span> contar_s[], ll num, <span class="hljs-keyword">int</span> contar_k)</span></span>&#123;<span class="hljs-comment">//康托展开，把一个数字num展开成一个数组contar_s，contar_k是数组长度</span>    <span class="hljs-keyword">int</span> t;    <span class="hljs-built_in">memset</span>(vis_cantor, <span class="hljs-number">0</span>, <span class="hljs-keyword">sizeof</span>(vis_cantor));     <span class="hljs-keyword">for</span>(<span class="hljs-keyword">int</span> i = <span class="hljs-number">0</span>; i &lt; contar_k; i ++)&#123;        t = num / A[contar_k-i<span class="hljs-number">-1</span>];        num%=A[contar_k-i<span class="hljs-number">-1</span>];<span class="hljs-keyword">int</span> cnt_cantor=<span class="hljs-number">0</span>;rep(j,<span class="hljs-number">0</span>,contar_k)&#123;<span class="hljs-comment">//计算每位的逆序数 </span><span class="hljs-keyword">if</span>(vis_cantor[j]) <span class="hljs-keyword">continue</span>;<span class="hljs-keyword">if</span>(cnt_cantor==t)&#123;contar_s[i]=j+<span class="hljs-number">1</span>,vis_cantor[j]=<span class="hljs-number">1</span>;<span class="hljs-keyword">break</span>;&#125; ++cnt_cantor;&#125;    &#125;<span class="hljs-comment">//    rep(i,0,contar_k) cout&lt;&lt;contar_s[i]&lt;&lt;' '; //输出康拖展开的结果 </span><span class="hljs-comment">//    cout&lt;&lt;endl;</span><span class="hljs-comment">//    gapline;</span>&#125;<span class="hljs-function">ll <span class="hljs-title">inv_cantor</span><span class="hljs-params">(<span class="hljs-keyword">int</span> contar_s[], <span class="hljs-keyword">int</span> contar_k)</span></span>&#123;<span class="hljs-comment">//康托逆展开，把一个数组contar_s换算成一个数字num </span>    <span class="hljs-keyword">int</span> cnt;ll num=<span class="hljs-number">0</span>;    num = <span class="hljs-number">0</span>;    <span class="hljs-keyword">for</span>(<span class="hljs-keyword">int</span> i = <span class="hljs-number">0</span>; i &lt; contar_k; i ++)&#123;        cnt = <span class="hljs-number">0</span>;        <span class="hljs-keyword">for</span>(<span class="hljs-keyword">int</span> j = i + <span class="hljs-number">1</span>; j &lt; contar_k; j ++)&#123;            <span class="hljs-keyword">if</span>(contar_s[i] &gt; contar_s[j]) cnt ++;<span class="hljs-comment">//判断几个数小于它,即求逆序数。 </span>        &#125;        num += A[contar_k-i<span class="hljs-number">-1</span>] * cnt;    &#125;    <span class="hljs-keyword">return</span> num;&#125;<span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">change</span><span class="hljs-params">(<span class="hljs-keyword">int</span> i)</span></span>&#123;<span class="hljs-keyword">switch</span>(i)&#123;<span class="hljs-keyword">case</span> <span class="hljs-number">0</span>: <span class="hljs-comment">//操作A </span>rep(j,<span class="hljs-number">0</span>,<span class="hljs-number">4</span>) swap(next_cantor[j],next_cantor[maxl<span class="hljs-number">-1</span>-j]);<span class="hljs-keyword">break</span>;<span class="hljs-keyword">case</span> <span class="hljs-number">1</span>: <span class="hljs-comment">//操作B</span>per(j,<span class="hljs-number">1</span>,<span class="hljs-number">4</span>) swap(next_cantor[(j+<span class="hljs-number">1</span>)%<span class="hljs-number">4</span>],next_cantor[j]);swap(next_cantor[<span class="hljs-number">4</span>],next_cantor[<span class="hljs-number">7</span>]);swap(next_cantor[<span class="hljs-number">5</span>],next_cantor[<span class="hljs-number">4</span>]);swap(next_cantor[<span class="hljs-number">6</span>],next_cantor[<span class="hljs-number">5</span>]); <span class="hljs-keyword">break</span>;<span class="hljs-keyword">case</span> <span class="hljs-number">2</span>: <span class="hljs-comment">//操作C</span>swap(next_cantor[<span class="hljs-number">1</span>],next_cantor[<span class="hljs-number">2</span>]);swap(next_cantor[<span class="hljs-number">1</span>],next_cantor[<span class="hljs-number">6</span>]);swap(next_cantor[<span class="hljs-number">6</span>],next_cantor[<span class="hljs-number">5</span>]);<span class="hljs-keyword">break</span>; &#125;&#125;<span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">bfs</span><span class="hljs-params">()</span></span>&#123;A[<span class="hljs-number">0</span>]=A[<span class="hljs-number">1</span>]=<span class="hljs-number">1</span>;A[<span class="hljs-number">2</span>]=<span class="hljs-number">2</span>;rep(i,<span class="hljs-number">3</span>,maxl+<span class="hljs-number">1</span>) A[i]=A[i<span class="hljs-number">-1</span>]*i;<span class="hljs-keyword">while</span>(!q.empty()) q.pop();q.push(<span class="hljs-number">0</span>);vis[<span class="hljs-number">0</span>]=<span class="hljs-number">1</span>;<span class="hljs-keyword">while</span>(!q.empty())&#123;ll temp1=q.front();q.pop();cantor(ans_cantor,temp1,maxl);rep(i,<span class="hljs-number">0</span>,<span class="hljs-number">3</span>)&#123;rep(j,<span class="hljs-number">0</span>,maxl) next_cantor[j]=ans_cantor[j];change(i);ll temp2=inv_cantor(next_cantor,maxl);<span class="hljs-keyword">if</span>(!vis[temp2])&#123;q.push(temp2);vis[temp2]=<span class="hljs-number">1</span>;ans[temp2]=ans[temp1]+(<span class="hljs-keyword">char</span>)(<span class="hljs-string">'A'</span>+i);&#125;&#125;&#125;&#125; <span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span>&#123;ios::sync_with_stdio(<span class="hljs-literal">false</span>);bfs();<span class="hljs-keyword">while</span>(<span class="hljs-built_in">cin</span>&gt;&gt;raw1&gt;&gt;raw2)&#123;prechange();<span class="hljs-comment">//b[]为最终目标态 </span>ll cnt=inv_cantor(b,maxl);<span class="hljs-built_in">cout</span>&lt;&lt;ans[cnt]&lt;&lt;<span class="hljs-built_in">endl</span>;&#125; &#125;</code></pre><h1 id="收获与反思"><a href="#收获与反思" class="headerlink" title="收获与反思"></a>收获与反思</h1><ul><li>本题综合应用了数论里的康托展开（用于找到状态数和排列之间的联系），hash到相同情况讨论，以及BFS，值得深入考虑</li><li><p>关于康托展开<br>  <a href="https://www.cnblogs.com/linyujun/p/5205760.html" target="_blank" rel="noopener">https://www.cnblogs.com/linyujun/p/5205760.html</a><br>  大部分是通过这篇博客以及其他资料学习的，感谢原作者！</p><p>  公式为 <script type="math/tex">X = a_n \times (n-1)! + a_{n-1} \times (n-2)! + \cdots + a_2 \times 1! + a_1 \times 0!</script></p><p>  其中$a_n$表示第i个元素在未出现的元素中排列第几（从0开始）<br>  ，也可以理解成$a_n$表示该位的逆序数。</p><p>  康托展开得到的X，就是该排列在全排列中的顺序（从0开始）。</p><p>  逆展开就是循环除以(n-1)!，商为第n位在未出现元素排列第几（从0开始）。模为下一位的被除数。</p><p>  在详细的等开个数论专题（挖坑）。</p></li></ul>]]></content>
    
    
    <categories>
      
      <category>Computer Science</category>
      
      <category>ACM</category>
      
      <category>HDU</category>
      
    </categories>
    
    
    <tags>
      
      <tag>ACM</tag>
      
      <tag>HDU</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>【AtCoder-4247】解题报告（水题）</title>
    <link href="/post/f0b23c5b.html"/>
    <url>/post/f0b23c5b.html</url>
    
    <content type="html"><![CDATA[<h1 id="原始题目"><a href="#原始题目" class="headerlink" title="原始题目"></a>原始题目</h1><h2 id="B-105"><a href="#B-105" class="headerlink" title="B - 105"></a>B - 105</h2><ul><li><p>Time limit : 2sec / Memory limit : 1000MB</p></li><li><p>Score: 200 points</p></li></ul><h3 id="Problem-Statement"><a href="#Problem-Statement" class="headerlink" title="Problem Statement"></a>Problem Statement</h3><p>The number 105 is quite special - it is odd but still it has eight divisors. Now, your task is this: how many odd numbers with exactly eight positive divisors are there between 1 and N (inclusive)?<br><a id="more"></a></p><h3 id="Constraints"><a href="#Constraints" class="headerlink" title="Constraints"></a>Constraints</h3><ul><li>N is an integer between 1 and 200 (inclusive).</li></ul><h3 id="Input"><a href="#Input" class="headerlink" title="Input"></a>Input</h3><p>Input is given from Standard Input in the following format:</p><pre><code>N</code></pre><h3 id="Output"><a href="#Output" class="headerlink" title="Output"></a>Output</h3><p>Print the count.</p><h3 id="Sample-Input-1"><a href="#Sample-Input-1" class="headerlink" title="Sample Input 1"></a>Sample Input 1</h3><p>105</p><h3 id="Sample-Output-1"><a href="#Sample-Output-1" class="headerlink" title="Sample Output 1"></a>Sample Output 1</h3><p>1</p><ul><li>Among the numbers between 1 and 105, the only number that is odd and has exactly eight divisors is 105.</li></ul><h3 id="Sample-Input-2"><a href="#Sample-Input-2" class="headerlink" title="Sample Input 2"></a>Sample Input 2</h3><pre><code>7</code></pre><h3 id="Sample-Output-2"><a href="#Sample-Output-2" class="headerlink" title="Sample Output 2"></a>Sample Output 2</h3><p>0</p><ul><li>1 has one divisor. 3, 5 and 7 are all prime and have two divisors. Thus, there is no number that satisfies the condition.</li></ul><h1 id="题目大意"><a href="#题目大意" class="headerlink" title="题目大意"></a>题目大意</h1><p>给定n，求1到n恰好又8个因数的数字有多少个</p><h1 id="集体思路"><a href="#集体思路" class="headerlink" title="集体思路"></a>集体思路</h1><ul><li>水题，预处理一下因子个数，再求一下前缀和就行。</li></ul><h1 id="解题代码"><a href="#解题代码" class="headerlink" title="解题代码"></a>解题代码</h1><pre><code class="hljs C++"><span class="hljs-meta">#<span class="hljs-meta-keyword">include</span> <span class="hljs-meta-string">&lt;cstdio&gt;</span></span><span class="hljs-meta">#<span class="hljs-meta-keyword">include</span> <span class="hljs-meta-string">&lt;cstring&gt;</span></span><span class="hljs-meta">#<span class="hljs-meta-keyword">include</span> <span class="hljs-meta-string">&lt;cmath&gt;</span></span><span class="hljs-meta">#<span class="hljs-meta-keyword">include</span> <span class="hljs-meta-string">&lt;string&gt;</span></span><span class="hljs-meta">#<span class="hljs-meta-keyword">include</span> <span class="hljs-meta-string">&lt;iostream&gt;</span></span><span class="hljs-meta">#<span class="hljs-meta-keyword">include</span> <span class="hljs-meta-string">&lt;iomanip&gt;</span></span><span class="hljs-meta">#<span class="hljs-meta-keyword">include</span> <span class="hljs-meta-string">&lt;sstream&gt;</span></span><span class="hljs-meta">#<span class="hljs-meta-keyword">include</span> <span class="hljs-meta-string">&lt;set&gt;</span></span><span class="hljs-meta">#<span class="hljs-meta-keyword">include</span> <span class="hljs-meta-string">&lt;map&gt;</span></span><span class="hljs-meta">#<span class="hljs-meta-keyword">include</span> <span class="hljs-meta-string">&lt;queue&gt;</span></span><span class="hljs-meta">#<span class="hljs-meta-keyword">include</span> <span class="hljs-meta-string">&lt;vector&gt;</span></span><span class="hljs-meta">#<span class="hljs-meta-keyword">include</span> <span class="hljs-meta-string">&lt;bits/stdc++.h&gt;</span></span><span class="hljs-meta">#<span class="hljs-meta-keyword">define</span> INF 0x3f3f3f3f</span><span class="hljs-meta">#<span class="hljs-meta-keyword">define</span> eps 1e-8</span><span class="hljs-meta">#<span class="hljs-meta-keyword">define</span> mp make_pair</span><span class="hljs-meta">#<span class="hljs-meta-keyword">define</span> np next_permutation</span><span class="hljs-meta">#<span class="hljs-meta-keyword">define</span> pb push_back</span><span class="hljs-meta">#<span class="hljs-meta-keyword">define</span> all(x) (x.begin(),x.end())</span><span class="hljs-meta">#<span class="hljs-meta-keyword">define</span> rep(i,a,n) for(int i=a;i&lt;n;++i)</span><span class="hljs-meta">#<span class="hljs-meta-keyword">define</span> per(i,a,n) for(int i=n-1;i&gt;=a;--i)</span> <span class="hljs-meta">#<span class="hljs-meta-keyword">define</span> fi first</span><span class="hljs-meta">#<span class="hljs-meta-keyword">define</span> se second </span><span class="hljs-keyword">using</span> <span class="hljs-keyword">namespace</span> <span class="hljs-built_in">std</span>;<span class="hljs-keyword">const</span> <span class="hljs-keyword">int</span> maxn=<span class="hljs-number">1e4</span>+<span class="hljs-number">5</span>;<span class="hljs-keyword">const</span> <span class="hljs-keyword">int</span> maxl=<span class="hljs-number">26</span>;<span class="hljs-keyword">typedef</span> <span class="hljs-keyword">long</span> <span class="hljs-keyword">long</span> ll;<span class="hljs-keyword">typedef</span> <span class="hljs-keyword">unsigned</span> <span class="hljs-keyword">long</span> <span class="hljs-keyword">long</span> ull;<span class="hljs-keyword">typedef</span> <span class="hljs-built_in">vector</span>&lt;<span class="hljs-keyword">int</span>&gt; vi;<span class="hljs-keyword">typedef</span> pair&lt;<span class="hljs-keyword">int</span>,<span class="hljs-keyword">int</span>&gt; pii;  <span class="hljs-keyword">int</span> cnt[maxn],ans[maxn];<span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">solve</span><span class="hljs-params">()</span></span>&#123;rep(i,<span class="hljs-number">1</span>,<span class="hljs-number">300</span>) cnt[i]++;rep(i,<span class="hljs-number">2</span>,<span class="hljs-number">300</span>)&#123;<span class="hljs-keyword">for</span>(<span class="hljs-keyword">int</span> j=<span class="hljs-number">1</span>;j*i&lt;=<span class="hljs-number">300</span>;j++)&#123;cnt[i*j]++;&#125;&#125;<span class="hljs-keyword">int</span> ccnt=<span class="hljs-number">0</span>;ans[<span class="hljs-number">0</span>]=<span class="hljs-number">0</span>;rep(i,<span class="hljs-number">1</span>,<span class="hljs-number">300</span>) &#123;<span class="hljs-keyword">if</span>(cnt[i]==<span class="hljs-number">8</span> <span class="hljs-keyword">and</span> (i&amp;<span class="hljs-number">1</span>))&#123;ans[i]=++ccnt;&#125;<span class="hljs-keyword">else</span> ans[i]=ccnt;&#125;rep(i,<span class="hljs-number">1</span>,<span class="hljs-number">300</span>) &#123;<span class="hljs-comment">//cout&lt;&lt;"ans["&lt;&lt;i&lt;&lt;"]="&lt;&lt;ans[i]&lt;&lt;endl;</span>&#125;&#125; <span class="hljs-keyword">int</span> a,b;<span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span>&#123;ios::sync_with_stdio(<span class="hljs-literal">false</span>); solve();<span class="hljs-keyword">int</span> n;<span class="hljs-keyword">while</span>(<span class="hljs-built_in">cin</span>&gt;&gt;n)<span class="hljs-built_in">cout</span>&lt;&lt;ans[n]&lt;&lt;<span class="hljs-built_in">endl</span>;&#125;</code></pre><h1 id="收获与反思"><a href="#收获与反思" class="headerlink" title="收获与反思"></a>收获与反思</h1><p>无</p>]]></content>
    
    
    <categories>
      
      <category>Computer Science</category>
      
      <category>ACM</category>
      
      <category>AtCoder</category>
      
    </categories>
    
    
    <tags>
      
      <tag>ACM</tag>
      
      <tag>AtCoder</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>【AtCoder-4242】解题报告（思维，水题）</title>
    <link href="/post/e769f01f.html"/>
    <url>/post/e769f01f.html</url>
    
    <content type="html"><![CDATA[<h1 id="原始题目"><a href="#原始题目" class="headerlink" title="原始题目"></a>原始题目</h1><h2 id="C-To-Infinity"><a href="#C-To-Infinity" class="headerlink" title="C - To Infinity"></a>C - To Infinity</h2><ul><li><p>Time limit : 2sec / Memory limit : 1000MB</p></li><li><p>﻿Score: 300 points</p></li></ul><h3 id="Problem-Statement"><a href="#Problem-Statement" class="headerlink" title="Problem Statement"></a>Problem Statement</h3><p>Mr. Infinity has a string S consisting of digits from 1 to 9. Each time the date changes, this string changes as follows:</p><p>Each occurrence of 2 in S is replaced with 22. Similarly, each 3 becomes 333, 4 becomes 4444, 5 becomes 55555, 6 becomes 666666, 7 becomes 7777777, 8 becomes 88888888 and 9 becomes 999999999. 1 remains as 1.</p><p>For example, if S is 1324, it becomes 1333224444 the next day, and it becomes 133333333322224444444444444444 the day after next. You are interested in what the string looks like after $5 \times 10^{15}$ days. What is the K-th character from the left in the string after $5 \times 10^{15}$ days?<br><a id="more"></a></p><h3 id="Constraints"><a href="#Constraints" class="headerlink" title="Constraints"></a>Constraints</h3><ul><li>S is a string of length between 1 and 100 (inclusive).</li><li>K is an integer between 1 and $10^{18}$ (inclusive).</li><li>The length of the string after $5 \times 10^{15}$ days is at least K.</li></ul><h3 id="Input"><a href="#Input" class="headerlink" title="Input"></a>Input</h3><p>Input is given from Standard Input in the following format:</p><pre><code>SK</code></pre><h3 id="Output"><a href="#Output" class="headerlink" title="Output"></a>Output</h3><p>Print the K-th character from the left in Mr. Infinity’s string after 5×1015 days.</p><h3 id="Sample-Input-1"><a href="#Sample-Input-1" class="headerlink" title="Sample Input 1"></a>Sample Input 1</h3><pre><code>12144</code></pre><h3 id="Sample-Output-1"><a href="#Sample-Output-1" class="headerlink" title="Sample Output 1"></a>Sample Output 1</h3><pre><code>2</code></pre><p>The string S changes as follows:</p><ul><li>Now: 1214</li><li>After one day: 12214444</li><li>After two days: 1222214444444444444444</li><li>After three days: 12222222214444444444444444444444444444444444444444444444444444444444444444</li></ul><p>The first five characters in the string after 5×1015 days is 12222. As K=4, we should print the fourth character, 2.</p><h3 id="Sample-Input-2"><a href="#Sample-Input-2" class="headerlink" title="Sample Input 2"></a>Sample Input 2</h3><pre><code>3157</code></pre><h3 id="Sample-Output-2"><a href="#Sample-Output-2" class="headerlink" title="Sample Output 2"></a>Sample Output 2</h3><pre><code>3</code></pre><p>The initial string is 3. The string after 5×1015 days consists only of 3.</p><h3 id="Sample-Input-3"><a href="#Sample-Input-3" class="headerlink" title="Sample Input 3"></a>Sample Input 3</h3><pre><code>2997924589460730472580800</code></pre><h3 id="Sample-Output-3"><a href="#Sample-Output-3" class="headerlink" title="Sample Output 3"></a>Sample Output 3</h3><pre><code>2</code></pre><h1 id="题目大意"><a href="#题目大意" class="headerlink" title="题目大意"></a>题目大意</h1><p>给定初始的一串数字，之后每一天每个数字会复制该数字次，比如’12223’，下一天变为’1222222333’，如此类推，<br>问经过$5 \times 10^{15}$天后第k位数字是多少。</p><h1 id="解题思路"><a href="#解题思路" class="headerlink" title="解题思路"></a>解题思路</h1><p>由于天数是固定的，而且很大，即便一位2经过5×1015，位数会变为$2^{5 \times 10^{15}}$ ，远超过 $10^{18}$<br>所以只要判断第几位非1即可。</p><h1 id="解题代码"><a href="#解题代码" class="headerlink" title="解题代码"></a>解题代码</h1><pre><code class="hljs C++"><span class="hljs-meta">#<span class="hljs-meta-keyword">include</span> <span class="hljs-meta-string">&lt;cstdio&gt;</span></span><span class="hljs-meta">#<span class="hljs-meta-keyword">include</span> <span class="hljs-meta-string">&lt;cstring&gt;</span></span><span class="hljs-meta">#<span class="hljs-meta-keyword">include</span> <span class="hljs-meta-string">&lt;cmath&gt;</span></span><span class="hljs-meta">#<span class="hljs-meta-keyword">include</span> <span class="hljs-meta-string">&lt;string&gt;</span></span><span class="hljs-meta">#<span class="hljs-meta-keyword">include</span> <span class="hljs-meta-string">&lt;iostream&gt;</span></span><span class="hljs-meta">#<span class="hljs-meta-keyword">include</span> <span class="hljs-meta-string">&lt;iomanip&gt;</span></span><span class="hljs-meta">#<span class="hljs-meta-keyword">include</span> <span class="hljs-meta-string">&lt;sstream&gt;</span></span><span class="hljs-meta">#<span class="hljs-meta-keyword">include</span> <span class="hljs-meta-string">&lt;set&gt;</span></span><span class="hljs-meta">#<span class="hljs-meta-keyword">include</span> <span class="hljs-meta-string">&lt;map&gt;</span></span><span class="hljs-meta">#<span class="hljs-meta-keyword">include</span> <span class="hljs-meta-string">&lt;queue&gt;</span></span><span class="hljs-meta">#<span class="hljs-meta-keyword">include</span> <span class="hljs-meta-string">&lt;vector&gt;</span></span><span class="hljs-meta">#<span class="hljs-meta-keyword">include</span> <span class="hljs-meta-string">&lt;bits/stdc++.h&gt;</span></span><span class="hljs-meta">#<span class="hljs-meta-keyword">define</span> INF 0x3f3f3f3f</span><span class="hljs-meta">#<span class="hljs-meta-keyword">define</span> eps 1e-8</span><span class="hljs-meta">#<span class="hljs-meta-keyword">define</span> mp make_pair</span><span class="hljs-meta">#<span class="hljs-meta-keyword">define</span> np next_permutation</span><span class="hljs-meta">#<span class="hljs-meta-keyword">define</span> pb push_back</span><span class="hljs-meta">#<span class="hljs-meta-keyword">define</span> all(x) (x.begin(),x.end())</span><span class="hljs-meta">#<span class="hljs-meta-keyword">define</span> rep(i,a,n) for(int i=a;i&lt;n;++i)</span><span class="hljs-meta">#<span class="hljs-meta-keyword">define</span> per(i,a,n) for(int i=n-1;i&gt;=a;--i)</span> <span class="hljs-meta">#<span class="hljs-meta-keyword">define</span> fi first</span><span class="hljs-meta">#<span class="hljs-meta-keyword">define</span> se second </span><span class="hljs-keyword">using</span> <span class="hljs-keyword">namespace</span> <span class="hljs-built_in">std</span>;<span class="hljs-keyword">const</span> <span class="hljs-keyword">int</span> maxn=<span class="hljs-number">1e4</span>+<span class="hljs-number">5</span>;<span class="hljs-keyword">const</span> <span class="hljs-keyword">int</span> maxl=<span class="hljs-number">26</span>;<span class="hljs-keyword">typedef</span> <span class="hljs-keyword">long</span> <span class="hljs-keyword">long</span> ll;<span class="hljs-keyword">typedef</span> <span class="hljs-keyword">unsigned</span> <span class="hljs-keyword">long</span> <span class="hljs-keyword">long</span> ull;<span class="hljs-keyword">typedef</span> <span class="hljs-built_in">vector</span>&lt;<span class="hljs-keyword">int</span>&gt; vi;<span class="hljs-keyword">typedef</span> pair&lt;<span class="hljs-keyword">int</span>,<span class="hljs-keyword">int</span>&gt; pii;<span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span>&#123;ios::sync_with_stdio(<span class="hljs-literal">false</span>); <span class="hljs-built_in">string</span> s;ull k;<span class="hljs-keyword">while</span>(<span class="hljs-built_in">cin</span>&gt;&gt;s&gt;&gt;k)&#123;<span class="hljs-keyword">int</span> index=<span class="hljs-number">0</span>;<span class="hljs-keyword">for</span>(<span class="hljs-keyword">int</span> i=<span class="hljs-number">0</span>;i&lt;s.length();i++)&#123;<span class="hljs-keyword">if</span>(s[i]!=<span class="hljs-string">'1'</span>)&#123;index=i;<span class="hljs-keyword">break</span>;&#125;&#125;<span class="hljs-keyword">if</span>(k<span class="hljs-number">-1</span>&lt;index) <span class="hljs-built_in">cout</span>&lt;&lt;<span class="hljs-number">1</span>&lt;&lt;<span class="hljs-built_in">endl</span>;<span class="hljs-keyword">else</span> <span class="hljs-built_in">cout</span>&lt;&lt;s[index]&lt;&lt;<span class="hljs-built_in">endl</span>;&#125;&#125;</code></pre><h1 id="收获与反思"><a href="#收获与反思" class="headerlink" title="收获与反思"></a>收获与反思</h1><ul><li>思考一下即可，不过拓展应该是天数可变的时候，有机会找一下相关题再补吧。</li></ul>]]></content>
    
    
    <categories>
      
      <category>Computer Science</category>
      
      <category>ACM</category>
      
      <category>AtCoder</category>
      
    </categories>
    
    
    <tags>
      
      <tag>ACM</tag>
      
      <tag>AtCoder</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>【AtCoder-4244】解题报告（暴力，DP）</title>
    <link href="/post/1448d9c8.html"/>
    <url>/post/1448d9c8.html</url>
    
    <content type="html"><![CDATA[<h1 id="原始题目"><a href="#原始题目" class="headerlink" title="原始题目"></a>原始题目</h1><h2 id="D-AtCoder-Express-2"><a href="#D-AtCoder-Express-2" class="headerlink" title="D - AtCoder Express 2"></a>D - AtCoder Express 2</h2><ul><li>Time limit : 3sec / Memory limit : 1000MB</li><li>Score: 400 points</li></ul><h3 id="Problem-Statement"><a href="#Problem-Statement" class="headerlink" title="Problem Statement"></a>Problem Statement</h3><p>In Takahashi Kingdom, there is a east-west railroad and N cities along it, numbered 1, 2, 3, …, N from west to east. A company called AtCoder Express possesses M trains, and the train i runs from City Li to City Ri (it is possible that Li=Ri). Takahashi the king is interested in the following Q matters:</p><p>The number of the trains that runs strictly within the section from City pi to City qi, that is, the number of trains j such that pi≤Lj and Rj≤qi.</p><p>Although he is genius, this is too much data to process by himself. Find the answer for each of these Q queries to help him.<br><a id="more"></a></p><h3 id="Constraints"><a href="#Constraints" class="headerlink" title="Constraints"></a>Constraints</h3><ul><li>N is an integer between 1 and 500 (inclusive).</li><li>M is an integer between 1 and 200 000 (inclusive).</li><li>Q is an integer between 1 and 100 000 (inclusive).</li><li>1≤Li≤Ri≤N (1≤i≤M)</li><li>1≤pi≤qi≤N (1≤i≤Q)</li></ul><h3 id="Input"><a href="#Input" class="headerlink" title="Input"></a>Input</h3><p>Input is given from Standard Input in the following format:</p><pre><code>N M QL1 R1L2 R2:LM RMp1 q1p2 q2:pQ qQ</code></pre><h3 id="Output"><a href="#Output" class="headerlink" title="Output"></a>Output</h3><p>Print Q lines. The i-th line should contain the number of the trains that runs strictly within the section from City pi to City qi.</p><h3 id="Sample-Input-1"><a href="#Sample-Input-1" class="headerlink" title="Sample Input 1"></a>Sample Input 1</h3><pre><code>2 3 11 11 22 21 2</code></pre><h3 id="Sample-Output-1"><a href="#Sample-Output-1" class="headerlink" title="Sample Output 1"></a>Sample Output 1</h3><pre><code>3</code></pre><p>As all the trains runs within the section from City 1 to City 2, the answer to the only query is 3.</p><h3 id="Sample-Input-2"><a href="#Sample-Input-2" class="headerlink" title="Sample Input 2"></a>Sample Input 2</h3><pre><code>10 3 21 52 87 101 73 10</code></pre><h3 id="Sample-Output-2"><a href="#Sample-Output-2" class="headerlink" title="Sample Output 2"></a>Sample Output 2</h3><pre><code>11</code></pre><p>The first query is on the section from City 1 to 7. There is only one train that runs strictly within that section: Train 1. The second query is on the section from City 3 to 10. There is only one train that runs strictly within that section: Train 3.</p><h3 id="Sample-Input-3"><a href="#Sample-Input-3" class="headerlink" title="Sample Input 3"></a>Sample Input 3</h3><pre><code>10 10 101 62 94 54 74 75 86 66 77 910 101 81 91 102 82 92 103 83 93 101 10</code></pre><h3 id="Sample-Output-3"><a href="#Sample-Output-3" class="headerlink" title="Sample Output 3"></a>Sample Output 3</h3><pre><code>791068967810</code></pre><h1 id="题目大意"><a href="#题目大意" class="headerlink" title="题目大意"></a>题目大意</h1><p>在一条东西向的铁路上有 $1,2,3 \cdots N$ 个城市，列车公司有$M$列火车，每列火车从$L_i$行驶到 $R_i( L_i \le R_i)$，现在有$Q$个询问<br>每次询问$p_i,q_i$ 两个城市间有多少躺列车的行驶路程恰好再在两城市之间（包括端点）。</p><h1 id="解题思路"><a href="#解题思路" class="headerlink" title="解题思路"></a>解题思路</h1><ul><li><p>暴力：由于只需要计数，那么以每个城市为集合，统计该城市出发的列车的行使距离，对于每次询问，遍历pi到qi城市的集合判断距离是否小于终点到遍历点的距离即可。</p></li><li><p>DP：</p><ul><li>把列车行驶看作线段，很明显大的线段包含小的线段。由此联想可以由内向外扩展，考虑DP</li><li>以终点作为集合，元素为起始点，预处理后对每个集合排序（代码实际应用vector而非set，因为set不支持迭代器随机访问而且可能会有重复线路）</li><li>$dp[i][j]$表示从i城市到j城市包含的火车线路。</li><li>则状态转移方程为$dp[i][j]=dp[i][j-1]+num[i][j]$ ，$num[i][j]$表示到达j城市且起点不在i城市之前的列车线路数。</li><li>求$num[i][j]$，用二分查找lower_bound找到j城市集合中第一个大于等于i的位置，$num[i][j]$即为size减去前缀。</li><li>预处理后直接可以输出答案</li></ul></li></ul><h1 id="解题代码"><a href="#解题代码" class="headerlink" title="解题代码"></a>解题代码</h1><ul><li>暴力</li></ul><pre><code class="hljs C++"><span class="hljs-meta">#<span class="hljs-meta-keyword">include</span> <span class="hljs-meta-string">&lt;cstdio&gt;</span></span><span class="hljs-meta">#<span class="hljs-meta-keyword">include</span> <span class="hljs-meta-string">&lt;cstring&gt;</span></span><span class="hljs-meta">#<span class="hljs-meta-keyword">include</span> <span class="hljs-meta-string">&lt;cmath&gt;</span></span><span class="hljs-meta">#<span class="hljs-meta-keyword">include</span> <span class="hljs-meta-string">&lt;string&gt;</span></span><span class="hljs-meta">#<span class="hljs-meta-keyword">include</span> <span class="hljs-meta-string">&lt;iostream&gt;</span></span><span class="hljs-meta">#<span class="hljs-meta-keyword">include</span> <span class="hljs-meta-string">&lt;iomanip&gt;</span></span><span class="hljs-meta">#<span class="hljs-meta-keyword">include</span> <span class="hljs-meta-string">&lt;sstream&gt;</span></span><span class="hljs-meta">#<span class="hljs-meta-keyword">include</span> <span class="hljs-meta-string">&lt;set&gt;</span></span><span class="hljs-meta">#<span class="hljs-meta-keyword">include</span> <span class="hljs-meta-string">&lt;map&gt;</span></span><span class="hljs-meta">#<span class="hljs-meta-keyword">include</span> <span class="hljs-meta-string">&lt;queue&gt;</span></span><span class="hljs-meta">#<span class="hljs-meta-keyword">include</span> <span class="hljs-meta-string">&lt;vector&gt;</span></span><span class="hljs-meta">#<span class="hljs-meta-keyword">include</span> <span class="hljs-meta-string">&lt;bits/stdc++.h&gt;</span></span><span class="hljs-meta">#<span class="hljs-meta-keyword">define</span> INF 0x3f3f3f3f</span><span class="hljs-meta">#<span class="hljs-meta-keyword">define</span> eps 1e-8</span><span class="hljs-meta">#<span class="hljs-meta-keyword">define</span> mp make_pair</span><span class="hljs-meta">#<span class="hljs-meta-keyword">define</span> np next_permutation</span><span class="hljs-meta">#<span class="hljs-meta-keyword">define</span> pb push_back</span><span class="hljs-meta">#<span class="hljs-meta-keyword">define</span> all(x) (x.begin(),x.end())</span><span class="hljs-meta">#<span class="hljs-meta-keyword">define</span> rep(i,a,n) for(int i=a;i&lt;n;++i)</span><span class="hljs-meta">#<span class="hljs-meta-keyword">define</span> per(i,a,n) for(int i=n-1;i&gt;=a;--i)</span><span class="hljs-keyword">using</span> <span class="hljs-keyword">namespace</span> <span class="hljs-built_in">std</span>; <span class="hljs-keyword">const</span> <span class="hljs-keyword">int</span> maxn=<span class="hljs-number">500</span>+<span class="hljs-number">5</span>;<span class="hljs-built_in">vector</span> &lt;<span class="hljs-keyword">int</span>&gt; v[maxn]; <span class="hljs-keyword">bool</span> vis[maxn]; <span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">init</span><span class="hljs-params">()</span></span>&#123;rep(i,<span class="hljs-number">0</span>,maxn) v[i].clear();<span class="hljs-built_in">memset</span>(vis,<span class="hljs-number">0</span>,<span class="hljs-keyword">sizeof</span>(vis));&#125;  <span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">addedge</span><span class="hljs-params">(<span class="hljs-keyword">int</span> l,<span class="hljs-keyword">int</span> r)</span></span>&#123;<span class="hljs-keyword">int</span> len=r-l;v[l].pb(len);&#125; <span class="hljs-function"><span class="hljs-keyword">int</span>  <span class="hljs-title">checkedge</span><span class="hljs-params">(<span class="hljs-keyword">int</span> l,<span class="hljs-keyword">int</span> len)</span></span>&#123;<span class="hljs-comment">//if(v[l].begin()!=v[l].end()) </span><span class="hljs-comment">// cout&lt;&lt;*v[l].begin()&lt;&lt;endl; </span><span class="hljs-keyword">int</span> ans=upper_bound(v[l].begin(),v[l].end(),len)-v[l].begin();<span class="hljs-comment">//cout&lt;&lt;"ans="&lt;&lt;ans&lt;&lt;endl;</span><span class="hljs-keyword">return</span> ans;&#125;<span class="hljs-keyword">int</span> n,m,q,li,ri,pi,qi; <span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span>&#123;ios::sync_with_stdio(<span class="hljs-literal">false</span>);<span class="hljs-keyword">while</span>(<span class="hljs-built_in">cin</span>&gt;&gt;n&gt;&gt;m&gt;&gt;q)&#123;init(); rep(i,<span class="hljs-number">0</span>,m)&#123;<span class="hljs-built_in">cin</span>&gt;&gt;li&gt;&gt;ri;addedge(li,ri);vis[li]=<span class="hljs-number">1</span>;&#125;rep(i,<span class="hljs-number">0</span>,maxn)&#123;<span class="hljs-keyword">if</span>(vis[i])sort(v[i].begin(),v[i].end()); &#125; rep(i,<span class="hljs-number">0</span>,q)&#123;<span class="hljs-built_in">cin</span>&gt;&gt;pi&gt;&gt;qi;<span class="hljs-keyword">int</span> cnt=<span class="hljs-number">0</span>;<span class="hljs-keyword">for</span>(<span class="hljs-keyword">int</span> i=pi;i&lt;=qi;i++)&#123;<span class="hljs-keyword">int</span> plen=qi-i;<span class="hljs-comment">//cout&lt;&lt;"plen="&lt;&lt;plen&lt;&lt;endl;</span>cnt+=checkedge(i,plen);&#125;<span class="hljs-built_in">cout</span>&lt;&lt;cnt&lt;&lt;<span class="hljs-built_in">endl</span>;&#125;&#125; &#125;</code></pre><ul><li>DP</li></ul><pre><code class="hljs C++"><span class="hljs-meta">#<span class="hljs-meta-keyword">include</span> <span class="hljs-meta-string">&lt;cstdio&gt;</span></span><span class="hljs-meta">#<span class="hljs-meta-keyword">include</span> <span class="hljs-meta-string">&lt;cstring&gt;</span></span><span class="hljs-meta">#<span class="hljs-meta-keyword">include</span> <span class="hljs-meta-string">&lt;cmath&gt;</span></span><span class="hljs-meta">#<span class="hljs-meta-keyword">include</span> <span class="hljs-meta-string">&lt;string&gt;</span></span><span class="hljs-meta">#<span class="hljs-meta-keyword">include</span> <span class="hljs-meta-string">&lt;iostream&gt;</span></span><span class="hljs-meta">#<span class="hljs-meta-keyword">include</span> <span class="hljs-meta-string">&lt;iomanip&gt;</span></span><span class="hljs-meta">#<span class="hljs-meta-keyword">include</span> <span class="hljs-meta-string">&lt;sstream&gt;</span></span><span class="hljs-meta">#<span class="hljs-meta-keyword">include</span> <span class="hljs-meta-string">&lt;set&gt;</span></span><span class="hljs-meta">#<span class="hljs-meta-keyword">include</span> <span class="hljs-meta-string">&lt;map&gt;</span></span><span class="hljs-meta">#<span class="hljs-meta-keyword">include</span> <span class="hljs-meta-string">&lt;queue&gt;</span></span><span class="hljs-meta">#<span class="hljs-meta-keyword">include</span> <span class="hljs-meta-string">&lt;vector&gt;</span></span><span class="hljs-meta">#<span class="hljs-meta-keyword">include</span> <span class="hljs-meta-string">&lt;bits/stdc++.h&gt;</span></span><span class="hljs-meta">#<span class="hljs-meta-keyword">define</span> INF 0x3f3f3f3f</span><span class="hljs-meta">#<span class="hljs-meta-keyword">define</span> eps 1e-8</span><span class="hljs-meta">#<span class="hljs-meta-keyword">define</span> mp make_pair</span><span class="hljs-meta">#<span class="hljs-meta-keyword">define</span> np next_permutation</span><span class="hljs-meta">#<span class="hljs-meta-keyword">define</span> pb push_back</span><span class="hljs-meta">#<span class="hljs-meta-keyword">define</span> all(x) x.begin(),x.end()</span><span class="hljs-meta">#<span class="hljs-meta-keyword">define</span> rep(i,a,n) for(int i=a;i&lt;n;++i)</span><span class="hljs-meta">#<span class="hljs-meta-keyword">define</span> per(i,a,n) for(int i=n-1;i&gt;=a;--i)</span><span class="hljs-keyword">using</span> <span class="hljs-keyword">namespace</span> <span class="hljs-built_in">std</span>; <span class="hljs-keyword">const</span> <span class="hljs-keyword">int</span> maxn=<span class="hljs-number">500</span>+<span class="hljs-number">5</span>;<span class="hljs-keyword">typedef</span> <span class="hljs-keyword">long</span> <span class="hljs-keyword">long</span> ll;<span class="hljs-keyword">typedef</span> <span class="hljs-built_in">vector</span>&lt;<span class="hljs-keyword">int</span>&gt; vi;<span class="hljs-keyword">typedef</span> pair&lt;<span class="hljs-keyword">int</span>,<span class="hljs-keyword">int</span>&gt; pii; vi v[maxn];<span class="hljs-keyword">int</span> dp[maxn][maxn];<span class="hljs-keyword">int</span> n,m,q,li,ri,pi,qi;<span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">solve</span><span class="hljs-params">()</span></span>&#123;rep(i,<span class="hljs-number">1</span>,n+<span class="hljs-number">1</span>) sort(v[i].begin(),v[i].end());<span class="hljs-built_in">memset</span>(dp,<span class="hljs-number">0</span>,<span class="hljs-keyword">sizeof</span>(dp));rep(l,<span class="hljs-number">1</span>,n+<span class="hljs-number">1</span>)&#123;<span class="hljs-keyword">for</span>(<span class="hljs-keyword">int</span> r=l;r&lt;=n;r++)&#123;dp[l][r]=dp[l][r<span class="hljs-number">-1</span>];<span class="hljs-comment">//if(r-1&lt;l) continue;</span>dp[l][r]+=(v[r].size()-(lower_bound(v[r].begin(),v[r].end(),l)-v[r].begin()));&#125;&#125;&#125;<span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span>&#123;ios::sync_with_stdio(<span class="hljs-literal">false</span>);<span class="hljs-keyword">while</span>(<span class="hljs-built_in">cin</span>&gt;&gt;n&gt;&gt;m&gt;&gt;q)&#123;rep(i,<span class="hljs-number">0</span>,m)&#123;<span class="hljs-built_in">cin</span>&gt;&gt;li&gt;&gt;ri;v[ri].pb(li);&#125;solve();rep(i,<span class="hljs-number">0</span>,q)&#123;<span class="hljs-built_in">cin</span>&gt;&gt;pi&gt;&gt;qi;<span class="hljs-built_in">cout</span>&lt;&lt;dp[pi][qi]&lt;&lt;<span class="hljs-built_in">endl</span>;&#125;&#125;&#125;</code></pre><h1 id="收获与反思"><a href="#收获与反思" class="headerlink" title="收获与反思"></a>收获与反思</h1><ul><li>脑子里别老想着暴力，有重复计算又没有修改为什么不考虑记忆化搜索？不考虑DP？思维训练还不够</li><li>很明显的时间差异。</li></ul><p><img src="https://eddyblog.oss-cn-shenzhen.aliyuncs.com/%E3%80%90AtCoder-4244%E3%80%91%E8%A7%A3%E9%A2%98%E6%8A%A5%E5%91%8A%EF%BC%88%E6%9A%B4%E5%8A%9B%EF%BC%8CDP%EF%BC%89/1.jpg" srcset="/img/loading.gif" alt="1.jpg"></p>]]></content>
    
    
    <categories>
      
      <category>Computer Science</category>
      
      <category>ACM</category>
      
      <category>AtCoder</category>
      
    </categories>
    
    
    <tags>
      
      <tag>ACM</tag>
      
      <tag>AtCoder</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>【AtCoder-4245】解题报告（水题）</title>
    <link href="/post/f3d9c661.html"/>
    <url>/post/f3d9c661.html</url>
    
    <content type="html"><![CDATA[<h1 id="原始题目"><a href="#原始题目" class="headerlink" title="原始题目"></a>原始题目</h1><h2 id="A-Garden"><a href="#A-Garden" class="headerlink" title="A - Garden"></a>A - Garden</h2><ul><li>Time limit : 2sec / Memory limit : 1000MB</li><li>Score: 100 points</li></ul><h3 id="Problem-Statement"><a href="#Problem-Statement" class="headerlink" title="Problem Statement"></a>Problem Statement</h3><p>There is a farm whose length and width are A yard and B yard, respectively. A farmer, John, made a vertical road and a horizontal road inside the farm from one border to another, as shown below: (The gray part represents the roads.)<br><img src="https://eddyblog.oss-cn-shenzhen.aliyuncs.com/%E3%80%90AtCoder-4245%E3%80%91%E8%A7%A3%E9%A2%98%E6%8A%A5%E5%91%8A%EF%BC%88%E6%B0%B4%E9%A2%98%EF%BC%89/1.jpg" srcset="/img/loading.gif" alt="1.jpg"><br>What is the area of this yard excluding the roads? Find it.</p><a id="more"></a><h3 id="Note"><a href="#Note" class="headerlink" title="Note"></a>Note</h3><p>It can be proved that the positions of the roads do not affect the area.</p><h3 id="Constraints"><a href="#Constraints" class="headerlink" title="Constraints"></a>Constraints</h3><ul><li>A is an integer between 2 and 100 (inclusive).</li><li>B is an integer between 2 and 100 (inclusive).</li></ul><h3 id="Input"><a href="#Input" class="headerlink" title="Input"></a>Input</h3><p>Input is given from Standard Input in the following format:</p><pre><code>A B</code></pre><h3 id="Output"><a href="#Output" class="headerlink" title="Output"></a>Output</h3><p>Print the area of this yard excluding the roads (in square yards).</p><h3 id="Sample-Input-1"><a href="#Sample-Input-1" class="headerlink" title="Sample Input 1"></a>Sample Input 1</h3><pre><code>2 2</code></pre><h3 id="Sample-Output-1"><a href="#Sample-Output-1" class="headerlink" title="Sample Output 1"></a>Sample Output 1</h3><pre><code>1</code></pre><p>In this case, the area is 1 square yard.</p><h3 id="Sample-Input-2"><a href="#Sample-Input-2" class="headerlink" title="Sample Input 2"></a>Sample Input 2</h3><pre><code>5 7</code></pre><h3 id="Sample-Output-2"><a href="#Sample-Output-2" class="headerlink" title="Sample Output 2"></a>Sample Output 2</h3><pre><code>24</code></pre><p>In this case, the area is 24 square yards.</p><h1 id="题目大意"><a href="#题目大意" class="headerlink" title="题目大意"></a>题目大意</h1><p>一个矩形哇横纵两条宽度为1的道路，问剩下的面积</p><h1 id="解题思路"><a href="#解题思路" class="headerlink" title="解题思路"></a>解题思路</h1><p>小学计算题，秒之</p><h1 id="解题代码"><a href="#解题代码" class="headerlink" title="解题代码"></a>解题代码</h1><pre><code class="hljs C++"><span class="hljs-meta">#<span class="hljs-meta-keyword">include</span> <span class="hljs-meta-string">&lt;cstdio&gt;</span></span><span class="hljs-meta">#<span class="hljs-meta-keyword">include</span> <span class="hljs-meta-string">&lt;cstring&gt;</span></span><span class="hljs-meta">#<span class="hljs-meta-keyword">include</span> <span class="hljs-meta-string">&lt;cmath&gt;</span></span><span class="hljs-meta">#<span class="hljs-meta-keyword">include</span> <span class="hljs-meta-string">&lt;string&gt;</span></span><span class="hljs-meta">#<span class="hljs-meta-keyword">include</span> <span class="hljs-meta-string">&lt;iostream&gt;</span></span><span class="hljs-meta">#<span class="hljs-meta-keyword">include</span> <span class="hljs-meta-string">&lt;iomanip&gt;</span></span><span class="hljs-meta">#<span class="hljs-meta-keyword">include</span> <span class="hljs-meta-string">&lt;sstream&gt;</span></span><span class="hljs-meta">#<span class="hljs-meta-keyword">include</span> <span class="hljs-meta-string">&lt;set&gt;</span></span><span class="hljs-meta">#<span class="hljs-meta-keyword">include</span> <span class="hljs-meta-string">&lt;map&gt;</span></span><span class="hljs-meta">#<span class="hljs-meta-keyword">include</span> <span class="hljs-meta-string">&lt;queue&gt;</span></span><span class="hljs-meta">#<span class="hljs-meta-keyword">include</span> <span class="hljs-meta-string">&lt;vector&gt;</span></span><span class="hljs-meta">#<span class="hljs-meta-keyword">include</span> <span class="hljs-meta-string">&lt;bits/stdc++.h&gt;</span></span><span class="hljs-meta">#<span class="hljs-meta-keyword">define</span> INF 0x3f3f3f3f</span><span class="hljs-meta">#<span class="hljs-meta-keyword">define</span> eps 1e-8</span><span class="hljs-meta">#<span class="hljs-meta-keyword">define</span> mp make_pair</span><span class="hljs-meta">#<span class="hljs-meta-keyword">define</span> np next_permutation</span><span class="hljs-meta">#<span class="hljs-meta-keyword">define</span> pb push_back</span><span class="hljs-meta">#<span class="hljs-meta-keyword">define</span> all(x) (x.begin(),x.end())</span><span class="hljs-meta">#<span class="hljs-meta-keyword">define</span> rep(i,a,n) for(int i=a;i&lt;n;++i)</span><span class="hljs-meta">#<span class="hljs-meta-keyword">define</span> per(i,a,n) for(int i=n-1;i&gt;=a;--i)</span><span class="hljs-meta">#<span class="hljs-meta-keyword">define</span> ms(x,a) memset((x),a,sizeof(x))</span><span class="hljs-meta">#<span class="hljs-meta-keyword">define</span> fi first</span><span class="hljs-meta">#<span class="hljs-meta-keyword">define</span> se second</span><span class="hljs-keyword">using</span> <span class="hljs-keyword">namespace</span> <span class="hljs-built_in">std</span>;<span class="hljs-keyword">const</span> <span class="hljs-keyword">int</span> maxn=<span class="hljs-number">1e5</span>+<span class="hljs-number">5</span>;<span class="hljs-keyword">const</span> <span class="hljs-keyword">int</span> maxl=<span class="hljs-number">26</span>;<span class="hljs-keyword">typedef</span> <span class="hljs-keyword">long</span> <span class="hljs-keyword">long</span> ll;<span class="hljs-keyword">typedef</span> <span class="hljs-keyword">unsigned</span> <span class="hljs-keyword">long</span> <span class="hljs-keyword">long</span> ull;<span class="hljs-keyword">typedef</span> <span class="hljs-built_in">vector</span>&lt;<span class="hljs-keyword">int</span>&gt; vi;<span class="hljs-keyword">typedef</span> pair&lt;<span class="hljs-keyword">int</span>,<span class="hljs-keyword">int</span>&gt; pii;<span class="hljs-keyword">int</span> a,b;<span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span>&#123;  <span class="hljs-keyword">while</span>(<span class="hljs-built_in">cin</span>&gt;&gt;a&gt;&gt;b)  <span class="hljs-built_in">cout</span>&lt;&lt;a*b-a-b+<span class="hljs-number">1</span>&lt;&lt;<span class="hljs-built_in">endl</span>;&#125;</code></pre><h1 id="收获与反思"><a href="#收获与反思" class="headerlink" title="收获与反思"></a>收获与反思</h1><p>无</p>]]></content>
    
    
    <categories>
      
      <category>Computer Science</category>
      
      <category>ACM</category>
      
      <category>AtCoder</category>
      
    </categories>
    
    
    <tags>
      
      <tag>ACM</tag>
      
      <tag>AtCoder</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>密码技术学习——《图解密码技术》笔记（一）</title>
    <link href="/post/4b15f9e3.html"/>
    <url>/post/4b15f9e3.html</url>
    
    <content type="html"><![CDATA[<h1 id="第3章-对称密码（共享密钥密码）——用相同的密钥进行加密和解密"><a href="#第3章-对称密码（共享密钥密码）——用相同的密钥进行加密和解密" class="headerlink" title="第3章 对称密码（共享密钥密码）——用相同的密钥进行加密和解密"></a>第3章 对称密码（共享密钥密码）——用相同的密钥进行加密和解密</h1><h2 id="一次性密码本——绝对不会被破译的密码"><a href="#一次性密码本——绝对不会被破译的密码" class="headerlink" title="一次性密码本——绝对不会被破译的密码"></a>一次性密码本——绝对不会被破译的密码</h2><p>原理： 将明文与一串随机的比特序列进行XOR运算。</p><p>完全随机，密钥空间是所有可能的01组合，所以就算破译成功了，我们也<strong>无法判断它是正确的明文</strong>。比如正确明文是code，但破译会出现从aaaa到zzzz，其中不乏有意义的book，cook等“疑似明文”，由于是完全随机带来的密钥空间有全部可能，我们无法判断真正的明文是什么。</p><p>理论上无法破译</p><p>不过这样密钥的传送也成了问题，假设我们能够安全的传送密钥，那本身这个方法可以用来安全传递我们的消息了，所以现实中除了特工配送密钥完成元首热线通话以外，一次性密码本没有很高的应用价值。</p><h2 id="DES"><a href="#DES" class="headerlink" title="DES"></a>DES</h2><p>Feistel网络的一轮，右侧直接向下变为输出，右侧与轮密钥XOR生成左侧。</p><p>多轮操作，每轮反转左右。</p><p>解密就是重复过程（两次XOR抵消从而得到这一轮前的输入）。</p><h2 id="三重DES"><a href="#三重DES" class="headerlink" title="三重DES"></a>三重DES</h2><p>如名，不过是DES加密-&gt;DES解密-&gt;DES加密（由IBM公司提出，用来兼容普通DES，比如三层都是同样的DES密钥，就是普通DES了）</p><p>解密过程为DES解密-&gt;DES加密-&gt;DES解密</p><p>目前在银行等机构还在使用，但处理速度不高，除了特别重视向下兼容性的情况以外，很少被用于新的用途。</p><h2 id="AES"><a href="#AES" class="headerlink" title="AES"></a>AES</h2><p>取代DES在2000成为新的标准，选定的算法名为Rijndael</p><h3 id="Rijndael"><a href="#Rijndael" class="headerlink" title="Rijndael"></a>Rijndael</h3><p>Rijndael算法也是由多个轮构成的，其中每一轮分为SubBytes（逐字节替换）、ShiftRows（平移行）、MixColumns（混合列）、AddRoundKey（与轮密钥进行XOR）<br>共四个不中。DES使用Feistel网络作为基本结构，而Rijndael使用SPN结构。</p><ul><li>加密：SubBytes -&gt; ShiftRows -&gt; MixColumns -&gt; AddRoundKey</li><li><p>解密：AddRoundKey -&gt; InvMixColumns -&gt; InvShiftRows -&gt; InvSubBytes</p></li><li><p>破译：由于其过程可以由数学公式来表达，那么理论上可以通过数学运算来求解，意味着Rigndael能够通过数学方法进行破译。不过现在为止还没有出现针对Rigndael的有效攻击。</p></li></ul><a id="more"></a><h1 id="第4章-分组密码的模式——分组密码是如何迭代的"><a href="#第4章-分组密码的模式——分组密码是如何迭代的" class="headerlink" title="第4章 分组密码的模式——分组密码是如何迭代的"></a>第4章 分组密码的模式——分组密码是如何迭代的</h1><ul><li>模式总结表格<table><tr><th>模式</th><th>名称</th><th>优点</th><th>缺点</th><th>备注</th></tr><tr><td>ECB模式</td><td>Electronic CodeBook 电子密码本模式</td><td><ul><li>简单</li><li>快速</li><li>支持并行计算（加密、解密）</li></ul></td><td><ul><li>明文中的重复排列会反映在密文中</li><li>通过删除、替换密文分组可以对明文进行操作</li><li>对包含某些比特错误的密文进行解密时，对应的分组会出错</li><li>不能抵御重放攻击</li></ul></td><td> 不应使用</td></tr><tr><td>CBC模式</td><td>Cipher Block Chaining 密文分组链接模式</td><td><ul><li>明文的重复排列不会反映在密文中</li><li>支持并行计算（仅解密）</li><li>能够解密任意密文分组</li></ul></td><td><ul><li>对包含某些错误比特的密文进行解密时，第一个分组的全部比特以及后一个分组的相应比特会出错</li><li>加密不支持并行计算</li></ul></td><td>CRYPTREC推荐<br>《实用密码学》推荐</td></tr><tr><td>CFB模式</td><td>Cipher-FeedBack 密文反馈模式</td><td><ul><li>不需要填充（padding）</li><li>支持并行计算（仅解密）</li><li>能够解密任意密文分组</li></ul></td><td><ul><li>对包含某些错误比特的密文进行解密时，第一个分组的相应比特以及后一个分组的全部比特会出错</li><li>加密不支持并行计算</li><li>不能抵御重放攻击</li></ul></td><td>CRYPTREC推荐</td></tr><tr><td>OFB模式</td><td>Output-FeedBack 输出反馈模式</td><td><ul><li>不需要填充（padding）</li><li>可事先进行加密、解密的准备</li><li>加密、解密使用相同结构</li><li>对包含某些错误比特的密文进行解密时，只有明文中相应的比特会出错</li></ul></td><td><ul><li>不支持并行计算</li><li>主动攻击者反转密文分组中的某些比特时，明文分组中相对应的比特也会被反转</li></ul></td><td>CRYPTREC推荐</td></tr><tr><td>CTR模式</td><td>CounTeR 计数器模式</td><td><ul><li>不需要填充（padding）</li><li>可实现进行加密、解密的准备</li><li>加密、解密使用相同的结构</li><li>对包含某些错误比特的密文进行解密时，只有明文中相对应的比特会出错</li><li>支持并行计算（加密、解密）</li></ul></td><td>主动攻击者反转密文分组中的某些比特时，明文分组中相对应的比特也会被反转</td><td>CRYPTREC推荐<br>《实用密码学》推荐</td></tr></table></li></ul><h1 id="第5章-公钥密码——用公钥加密，用私钥解密"><a href="#第5章-公钥密码——用公钥加密，用私钥解密" class="headerlink" title="第5章 公钥密码——用公钥加密，用私钥解密"></a>第5章 公钥密码——用公钥加密，用私钥解密</h1><h2 id="密钥配送问题"><a href="#密钥配送问题" class="headerlink" title="密钥配送问题"></a>密钥配送问题</h2><ul><li>通过事先共享密钥来解决（部分场景不现实）</li><li>通过密钥分配中心来解决（中心负担大，被破坏代价大风险高）</li><li>通过Diffie-Hellman密钥交换来解决（第11章）</li><li>通过公钥密码来解决（本章后续）</li></ul><h2 id="公钥密码"><a href="#公钥密码" class="headerlink" title="公钥密码"></a>公钥密码</h2><p>一些特征</p><ul><li>发送者只需要加密密钥</li><li>接收者只需要解密密钥</li><li>解密密钥不可以被窃听者获取</li><li>加密密钥被窃听者获取也没问题</li></ul><p>无法解决的问题</p><ul><li>解决了密钥配送问题，但是无门需要判断所得到的公钥是否正确合法，这个问题被称为公钥认证问题（后面章节）。</li><li>速度是对称密的几百分之一，解决方法后面会讲到。</li></ul><h3 id="时钟运算"><a href="#时钟运算" class="headerlink" title="时钟运算"></a>时钟运算</h3><p>补充一些数论知识</p><p>除法：在模12的条件下两个数相乘为1，“类倒数”。可以发现规律，和12的最大公约数为1的数（5，7，11），即于12互质的数，存在倒数。</p><p>乘方：可以先模再乘，应用同余的性质。</p><p>对数：时钟运算中对数成为离散对数。能快速求出离散对数的算法到现在还没有被发现，Diffie-Hellman密钥交换协议以及ElGamal公钥算法中<br>就运用了离散对数。</p><h2 id="RSA"><a href="#RSA" class="headerlink" title="RSA"></a>RSA</h2>]]></content>
    
    
    <categories>
      
      <category>Computer Science</category>
      
      <category>密码学</category>
      
    </categories>
    
    
    <tags>
      
      <tag>密码学</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>《银河帝国8：我，机器人》读书笔记</title>
    <link href="/post/7ef8a98f.html"/>
    <url>/post/7ef8a98f.html</url>
    
    <content type="html"><![CDATA[<h1 id="内容摘录"><a href="#内容摘录" class="headerlink" title="内容摘录"></a>内容摘录</h1><h2 id="机器人学三大法则"><a href="#机器人学三大法则" class="headerlink" title="机器人学三大法则"></a>机器人学三大法则</h2><ol><li>机器人不得伤害人类，或因不作为而使人类受到伤害。</li><li>除非违背第一法则，机器人必须服从人类的命令。</li><li>在不违背第一及第二法则的情况下，机器人必须保护自己。</li></ol><a id="more"></a><h2 id="第五篇-骗子！"><a href="#第五篇-骗子！" class="headerlink" title="第五篇 骗子！"></a>第五篇 骗子！</h2><blockquote><p>P115 “‘你们的教科书里什么也没有；你们的科学知识一堆搜集来的数据，靠临时的理论粘在一起——<br>而且全都简单到不可思议，简直真不值得我浪费时间。让我感兴趣的是你们的小说。你们会研究人类的动机以及<br>情感的互动关系……’”</p><p>P132 “厄比身子抵住了墙壁，双腿跪了下来。‘停止！’他尖叫道，‘关上你的心灵！它充满了痛苦、挫折和恨意！我不是故意的，我不骗你！<br>我试图帮助你们，我把你们想听的话告诉你们。我不得不这样做！’”</p></blockquote><h2 id="第六篇-消失无踪"><a href="#第六篇-消失无踪" class="headerlink" title="第六篇 消失无踪"></a>第六篇 消失无踪</h2><blockquote><p>P143 “‘凯文博士，我们要么就是必须舍弃机器人，要么就是对第一法则做些修改——结果我们选择了后者。’……<br>‘并没有取消它，只是作些修改。’寇纳尔解释道，‘这样制成的正子脑，仅含有第一法则的积极部分，也就是：机器人不得伤害人类，到此为止。<br>不再有强迫性的要求，要他们防止外在因素伤害人类，比方说伽马射线。我这样说正确吧，玻格特博士?’”</p><p>P152 “机器人心理学家说：‘假如修订型机器人从某人上方抛下一个重物，只要他在这样做的时候，明白自己具有足够的力量和反应速度，<br>能在重物砸到那人之前将它抓走，他就不会违反第一法则。然而一旦重物离手，他就不再是主动的媒介，起作用的只剩下盲目的重力。然后那机器人久能改变心意，<br>只要他不作为，就能让重物砸下去。修订后的第一法则允许这个行动。’”</p></blockquote><h2 id="第七篇-逃避！"><a href="#第七篇-逃避！" class="headerlink" title="第七篇 逃避！"></a>第七篇 逃避！</h2><blockquote><p>P200 “接下来就很明显，那项资料进入它的计算机制后，产生了控制恒星际跃迁最短时段的方程式——这意味着人的死亡。统一公司的机器会完全崩溃，<br>正是由于这个原因。但我已将死亡的严重性贬低——并非整个取消，因为第一法则永远无法违反——刚好足以让金头脑能对这个方程式多看一眼；足以给它时间去了解，<br>这段时期过后，那些人会起死回生——正如太空船中的物质和能量会重新出现。换句话说，这个所谓的‘死亡’绝对只是暂时现象。你们懂了吗？”</p></blockquote>]]></content>
    
    
    <categories>
      
      <category>Life</category>
      
      <category>阅读</category>
      
    </categories>
    
    
    <tags>
      
      <tag>阅读</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>【CSU-2056】解题报告（思维，KMP，去0）</title>
    <link href="/post/448da703.html"/>
    <url>/post/448da703.html</url>
    
    <content type="html"><![CDATA[<h1 id="原始题目"><a href="#原始题目" class="headerlink" title="原始题目"></a>原始题目</h1><h2 id="2056-a-simple-game"><a href="#2056-a-simple-game" class="headerlink" title="2056: a simple game"></a>2056: a simple game</h2><ul><li>Time Limit: 1 Sec     </li><li>Memory Limit: 128 Mb     </li><li>Submitted: 412     </li><li>Solved: 73    </li></ul><h3 id="Description"><a href="#Description" class="headerlink" title="Description"></a>Description</h3><p>这一天，小A和小B在玩一个游戏，他俩每人都有一个整数，然后两人轮流对他们的整数进行操作，每次在下列两个操作任选一个：</p><p>（1）对整数进行翻转，如1234翻转成4321 ，1200翻转成21 </p><p>（2）将整数除以10，如1234/10=123，1/10=0 </p><p>当操作过程中出现a==b时，则小A就赢了，而操作一直进行下去或不能使a==b则算小B赢。 </p><p>现在小A求助于你，想让你帮他在知道两人的整数时小A能不能赢，假设每次都是小A先手，并且两人都是采取最优策略 </p><a id="more"></a><h3 id="Input"><a href="#Input" class="headerlink" title="Input"></a>Input</h3><p>首先输入$ T (T \le 100)$，表示有T组数据，然后接下来有$T$行，每行有两个整数$a,b ( 0 \le a,b &lt; 10100000)$。</p><h3 id="Output"><a href="#Output" class="headerlink" title="Output"></a>Output</h3><p>有$T$行，当小A赢了则输出”Yes”,否则输出”No”</p><h3 id="Sample-Input"><a href="#Sample-Input" class="headerlink" title="Sample Input"></a>Sample Input</h3><pre><code>41234 123123 3211234 12345123 123</code></pre><h3 id="Sample-Output"><a href="#Sample-Output" class="headerlink" title="Sample Output"></a>Sample Output</h3><pre><code>YesYesNoYes</code></pre><h3 id="Hint"><a href="#Hint" class="headerlink" title="Hint"></a>Hint</h3><h3 id="Source"><a href="#Source" class="headerlink" title="Source"></a>Source</h3><h3 id="Author"><a href="#Author" class="headerlink" title="Author"></a>Author</h3><p>wsf</p><h1 id="题目大意"><a href="#题目大意" class="headerlink" title="题目大意"></a>题目大意</h1><p>如题</p><h1 id="解题思路"><a href="#解题思路" class="headerlink" title="解题思路"></a>解题思路</h1><ul><li>如果将A，B的整数看作字符串，那两种操作就是反转，去尾。</li><li>两人都采取最优策略，考虑小A什么时候输，即B可以无限翻转而A永远不能将自己的串通过两种操作达到B字符串的状态。</li><li>那么当B的串或B反转后的串是A的子串时，A就是必赢的</li><li>考虑一些特殊情况。</li><li>由于末尾0的存在会在反转中自动去掉，所以要提前预处理一下，把末尾0去掉</li><li>正方各一次KMP即可。</li></ul><h1 id="解题代码"><a href="#解题代码" class="headerlink" title="解题代码"></a>解题代码</h1><pre><code class="hljs C++"><span class="hljs-comment">//#include &lt;bits/stdc++.h&gt;</span><span class="hljs-meta">#<span class="hljs-meta-keyword">include</span> <span class="hljs-meta-string">&lt;cstdio&gt; </span></span><span class="hljs-meta">#<span class="hljs-meta-keyword">include</span> <span class="hljs-meta-string">&lt;cstring&gt;</span></span><span class="hljs-meta">#<span class="hljs-meta-keyword">include</span> <span class="hljs-meta-string">&lt;cstdlib&gt;</span></span><span class="hljs-meta">#<span class="hljs-meta-keyword">include</span> <span class="hljs-meta-string">&lt;iostream&gt;</span></span><span class="hljs-meta">#<span class="hljs-meta-keyword">include</span> <span class="hljs-meta-string">&lt;iomanip&gt;</span></span><span class="hljs-meta">#<span class="hljs-meta-keyword">include</span> <span class="hljs-meta-string">&lt;string&gt;</span></span><span class="hljs-meta">#<span class="hljs-meta-keyword">include</span> <span class="hljs-meta-string">&lt;map&gt;</span></span><span class="hljs-meta">#<span class="hljs-meta-keyword">include</span> <span class="hljs-meta-string">&lt;set&gt;</span></span><span class="hljs-meta">#<span class="hljs-meta-keyword">include</span> <span class="hljs-meta-string">&lt;algorithm&gt;</span></span><span class="hljs-meta">#<span class="hljs-meta-keyword">include</span> <span class="hljs-meta-string">&lt;queue&gt;</span></span><span class="hljs-meta">#<span class="hljs-meta-keyword">include</span> <span class="hljs-meta-string">&lt;vector&gt;</span></span><span class="hljs-meta">#<span class="hljs-meta-keyword">define</span> pb push_back</span><span class="hljs-meta">#<span class="hljs-meta-keyword">define</span> mp make_pair</span><span class="hljs-keyword">using</span> <span class="hljs-keyword">namespace</span> <span class="hljs-built_in">std</span>;<span class="hljs-keyword">typedef</span> <span class="hljs-keyword">long</span> <span class="hljs-keyword">long</span> LL;<span class="hljs-keyword">typedef</span> pair&lt;<span class="hljs-keyword">int</span>,<span class="hljs-keyword">int</span>&gt; PII;<span class="hljs-meta">#<span class="hljs-meta-keyword">define</span> PI acos((double)-1)</span><span class="hljs-meta">#<span class="hljs-meta-keyword">define</span> E exp(double(1))</span><span class="hljs-meta">#<span class="hljs-meta-keyword">define</span> K 1000000+9</span><span class="hljs-meta">#<span class="hljs-meta-keyword">define</span> rep(i,a,n) for(int i=a;i&lt;n;i++)</span><span class="hljs-meta">#<span class="hljs-meta-keyword">define</span> per(i,a,n) for(int i=n-1;i&gt;=a;i--)</span><span class="hljs-meta">#<span class="hljs-meta-keyword">define</span> ms(x,a) memset((x),(a),sizeof(a))</span><span class="hljs-keyword">const</span> <span class="hljs-keyword">int</span> maxn=<span class="hljs-number">1e6</span>+<span class="hljs-number">5</span>;<span class="hljs-keyword">int</span> nt[maxn],nt2[maxn] ;<span class="hljs-keyword">char</span> a[maxn],b[maxn],b2[maxn];<span class="hljs-keyword">int</span> n,m;<span class="hljs-comment">//参数为模板串和next数组</span><span class="hljs-comment">//字符串均从下标0开始</span><span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">kmpGetNext</span><span class="hljs-params">(<span class="hljs-keyword">char</span> *s,<span class="hljs-keyword">int</span> *Next)</span></span>&#123;    Next[<span class="hljs-number">0</span>]=<span class="hljs-number">0</span>;    <span class="hljs-keyword">int</span> len=<span class="hljs-built_in">strlen</span>(s);    <span class="hljs-keyword">for</span>(<span class="hljs-keyword">int</span> i=<span class="hljs-number">1</span>,j=<span class="hljs-number">0</span>;i&lt;len;i++)    &#123;        <span class="hljs-keyword">while</span>(j&amp;&amp;s[i]!=s[j]) j=Next[j];        <span class="hljs-keyword">if</span>(s[i]==s[j]) j++;        Next[i+<span class="hljs-number">1</span>]=j;    &#125;<span class="hljs-comment">//    Next[len]=0;</span>&#125;<span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">kmp</span><span class="hljs-params">(<span class="hljs-keyword">char</span> *ss,<span class="hljs-keyword">char</span> *s,<span class="hljs-keyword">int</span> *Next)</span></span>&#123;    kmpGetNext(s,Next);<span class="hljs-comment">//  调试输出Next数组</span><span class="hljs-comment">//int len=strlen(s);</span><span class="hljs-comment">//for(int i=0;i&lt;=len;i++)</span><span class="hljs-comment">//cout&lt;&lt;Next[i]&lt;&lt;" ";</span><span class="hljs-comment">//cout&lt;&lt;endl; </span>    <span class="hljs-keyword">int</span> ans=<span class="hljs-number">0</span>;    <span class="hljs-keyword">int</span> len1=<span class="hljs-built_in">strlen</span>(ss);    <span class="hljs-keyword">int</span> len2=<span class="hljs-built_in">strlen</span>(s);    <span class="hljs-keyword">for</span>(<span class="hljs-keyword">int</span> i=<span class="hljs-number">0</span>,j=<span class="hljs-number">0</span>;i&lt;len1;i++)    &#123;        <span class="hljs-keyword">while</span>(j&amp;&amp;ss[i]!=s[j])j=Next[j];        <span class="hljs-keyword">if</span>(ss[i]==s[j]) j++;        <span class="hljs-keyword">if</span>(j==len2)&#123;        <span class="hljs-keyword">return</span> <span class="hljs-number">1</span>;&#125;               &#125;    <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<span class="hljs-comment">//return ans;</span>&#125;<span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">main</span><span class="hljs-params">(<span class="hljs-keyword">void</span>)</span></span>&#123;<span class="hljs-comment">//ios::sync_with_stdio(false);</span>    <span class="hljs-keyword">int</span> t;    <span class="hljs-built_in">scanf</span>(<span class="hljs-string">"%d"</span>,&amp;t);     <span class="hljs-keyword">while</span>(t--)    &#123;    <span class="hljs-built_in">memset</span>(nt,<span class="hljs-number">0</span>,<span class="hljs-keyword">sizeof</span>(nt));    <span class="hljs-built_in">memset</span>(nt2,<span class="hljs-number">0</span>,<span class="hljs-keyword">sizeof</span>(nt2));<span class="hljs-built_in">scanf</span>(<span class="hljs-string">"%s"</span>,a);    <span class="hljs-built_in">scanf</span>(<span class="hljs-string">"%s"</span>,b);    <span class="hljs-keyword">int</span> len1=<span class="hljs-built_in">strlen</span>(a);    <span class="hljs-keyword">int</span> len2=<span class="hljs-built_in">strlen</span>(b);    <span class="hljs-keyword">while</span> (a[len1<span class="hljs-number">-1</span>] == <span class="hljs-string">'0'</span>&amp;&amp;len1 &gt; <span class="hljs-number">1</span>)a[--len1] = <span class="hljs-string">'\0'</span>;<span class="hljs-keyword">while</span> (b[len2<span class="hljs-number">-1</span>] == <span class="hljs-string">'0'</span>&amp;&amp;len2 &gt; <span class="hljs-number">1</span>)b[--len2] = <span class="hljs-string">'\0'</span>;rep(i,<span class="hljs-number">0</span>,len2) b2[i]=b[len2<span class="hljs-number">-1</span>-i];b2[len2]=<span class="hljs-string">'\0'</span>;<span class="hljs-comment">//printf("b1=  %s\nb2=  %s\n",b,b2);</span><span class="hljs-keyword">if</span>(kmp(a,b,nt)||kmp(a,b2,nt2)) <span class="hljs-built_in">printf</span>(<span class="hljs-string">"Yes\n"</span>);<span class="hljs-keyword">else</span> <span class="hljs-built_in">printf</span>(<span class="hljs-string">"No\n"</span>);    &#125;    <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;&#125;</code></pre><h1 id="收获与反思"><a href="#收获与反思" class="headerlink" title="收获与反思"></a>收获与反思</h1><ul><li>思维+KMP</li></ul>]]></content>
    
    
    <categories>
      
      <category>Computer Science</category>
      
      <category>ACM</category>
      
      <category>CSU</category>
      
    </categories>
    
    
    <tags>
      
      <tag>ACM</tag>
      
      <tag>CSU</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>【HDU-3746】解题报告（KMP，循环节）</title>
    <link href="/post/bb7f8e97.html"/>
    <url>/post/bb7f8e97.html</url>
    
    <content type="html"><![CDATA[<h1 id="原始题目"><a href="#原始题目" class="headerlink" title="原始题目"></a>原始题目</h1><h2 id="Cyclic-Nacklace"><a href="#Cyclic-Nacklace" class="headerlink" title="Cyclic Nacklace"></a>Cyclic Nacklace</h2><ul><li>Time Limit: 2000/1000 MS (Java/Others)</li><li>Memory Limit: 32768/32768 K (Java/Others)</li><li>Total Submission(s): 14437</li><li>Accepted Submission(s): 6022</li></ul><h3 id="Problem-Description"><a href="#Problem-Description" class="headerlink" title="Problem Description"></a>Problem Description</h3><p>CC always becomes very depressed at the end of this month, he has checked his credit card yesterday, without any surprise, there are only 99.9 yuan left. he is too distressed and thinking about how to tide over the last days. Being inspired by the entrepreneurial spirit of “HDU CakeMan”, he wants to sell some little things to make money. Of course, this is not an easy task.</p><p>As Christmas is around the corner, Boys are busy in choosing christmas presents to send to their girlfriends. It is believed that chain bracelet is a good choice. However, Things are not always so simple, as is known to everyone, girl’s fond of the colorful decoration to make bracelet appears vivid and lively, meanwhile they want to display their mature side as college students. after CC understands the girls demands, he intends to sell the chain bracelet called CharmBracelet. The CharmBracelet is made up with colorful pearls to show girls’ lively, and the most important thing is that it must be connected by a cyclic chain which means the color of pearls are cyclic connected from the left to right. And the cyclic count must be more than one. If you connect the leftmost pearl and the rightmost pearl of such chain, you can make a CharmBracelet. Just like the pictrue below, this CharmBracelet’s cycle is 9 and its cyclic count is 2:</p><p><img src="https://eddyblog.oss-cn-shenzhen.aliyuncs.com/%E3%80%90HDU-3746%E3%80%91%E8%A7%A3%E9%A2%98%E6%8A%A5%E5%91%8A%EF%BC%88KMP%EF%BC%8C%E5%BE%AA%E7%8E%AF%E8%8A%82%EF%BC%89/1.jpg" srcset="/img/loading.gif" alt="1.jpg"></p><p>Now CC has brought in some ordinary bracelet chains, he wants to buy minimum number of pearls to make CharmBracelets so that he can save more money. but when remaking the bracelet, he can only add color pearls to the left end and right end of the chain, that is to say, adding to the middle is forbidden.</p><p>CC is satisfied with his ideas and ask you for help.</p><a id="more"></a><h3 id="Input"><a href="#Input" class="headerlink" title="Input"></a>Input</h3><p>The first line of the input is a single integer $T ( 0 &lt; T \le 100 )$ which means the number of test cases.</p><p>Each test case contains only one line describe the original ordinary chain to be remade. Each character in the string stands for one pearl and there are 26 kinds of pearls being described by ‘a’ ~’z’ characters. The length of the string $Len$: $( 3 \le Len \le 100000 )$.</p><h3 id="Output"><a href="#Output" class="headerlink" title="Output"></a>Output</h3><p>For each case, you are required to output the minimum count of pearls added to make a CharmBracelet.</p><h3 id="Sample-Input"><a href="#Sample-Input" class="headerlink" title="Sample Input"></a>Sample Input</h3><pre><code>3aaaabcaabcde</code></pre><h3 id="Sample-Output"><a href="#Sample-Output" class="headerlink" title="Sample Output"></a>Sample Output</h3><pre><code>025</code></pre><h3 id="Author"><a href="#Author" class="headerlink" title="Author"></a>Author</h3><p>possessor WC</p><h3 id="Source"><a href="#Source" class="headerlink" title="Source"></a>Source</h3><p>HDU 3rd “Vegetable-Birds Cup” Programming Open Contest</p><h3 id="Recommend"><a href="#Recommend" class="headerlink" title="Recommend"></a>Recommend</h3><p>lcy</p><h1 id="题目大意"><a href="#题目大意" class="headerlink" title="题目大意"></a>题目大意</h1><p>有一个手环，由不同珠子构成，若要让他成为一个“魅力手环”需要使手环由大于等于两个，完全相同的首尾相接的子串构成。<br>问需要补充多少珠子使手环变为魅力手环。</p><h1 id="解题思路"><a href="#解题思路" class="headerlink" title="解题思路"></a>解题思路</h1><ul><li>求循环节以及判断是否完全循环，求差值</li></ul><h1 id="解题代码"><a href="#解题代码" class="headerlink" title="解题代码"></a>解题代码</h1><pre><code class="hljs C++"><span class="hljs-comment">//#include &lt;bits/stdc++.h&gt;</span><span class="hljs-meta">#<span class="hljs-meta-keyword">include</span> <span class="hljs-meta-string">&lt;cstdio&gt; </span></span><span class="hljs-meta">#<span class="hljs-meta-keyword">include</span> <span class="hljs-meta-string">&lt;cstring&gt;</span></span><span class="hljs-meta">#<span class="hljs-meta-keyword">include</span> <span class="hljs-meta-string">&lt;cstdlib&gt;</span></span><span class="hljs-meta">#<span class="hljs-meta-keyword">include</span> <span class="hljs-meta-string">&lt;iostream&gt;</span></span><span class="hljs-meta">#<span class="hljs-meta-keyword">include</span> <span class="hljs-meta-string">&lt;iomanip&gt;</span></span><span class="hljs-meta">#<span class="hljs-meta-keyword">include</span> <span class="hljs-meta-string">&lt;string&gt;</span></span><span class="hljs-meta">#<span class="hljs-meta-keyword">include</span> <span class="hljs-meta-string">&lt;map&gt;</span></span><span class="hljs-meta">#<span class="hljs-meta-keyword">include</span> <span class="hljs-meta-string">&lt;set&gt;</span></span><span class="hljs-meta">#<span class="hljs-meta-keyword">include</span> <span class="hljs-meta-string">&lt;algorithm&gt;</span></span><span class="hljs-meta">#<span class="hljs-meta-keyword">include</span> <span class="hljs-meta-string">&lt;queue&gt;</span></span><span class="hljs-meta">#<span class="hljs-meta-keyword">include</span> <span class="hljs-meta-string">&lt;vector&gt;</span></span><span class="hljs-meta">#<span class="hljs-meta-keyword">define</span> pb push_back</span><span class="hljs-meta">#<span class="hljs-meta-keyword">define</span> mp make_pair</span><span class="hljs-keyword">using</span> <span class="hljs-keyword">namespace</span> <span class="hljs-built_in">std</span>;<span class="hljs-keyword">typedef</span> <span class="hljs-keyword">long</span> <span class="hljs-keyword">long</span> LL;<span class="hljs-keyword">typedef</span> pair&lt;<span class="hljs-keyword">int</span>,<span class="hljs-keyword">int</span>&gt; PII;<span class="hljs-meta">#<span class="hljs-meta-keyword">define</span> PI acos((double)-1)</span><span class="hljs-meta">#<span class="hljs-meta-keyword">define</span> E exp(double(1))</span><span class="hljs-meta">#<span class="hljs-meta-keyword">define</span> K 1000000+9</span><span class="hljs-meta">#<span class="hljs-meta-keyword">define</span> rep(i,a,n) for(int i=a;i&lt;n;i++)</span><span class="hljs-meta">#<span class="hljs-meta-keyword">define</span> per(i,a,n) for(int i=n-1;i&gt;=a;i--)</span><span class="hljs-meta">#<span class="hljs-meta-keyword">define</span> ms(x,a) memset((x),(a),sizeof(a))</span><span class="hljs-keyword">const</span> <span class="hljs-keyword">int</span> maxn=<span class="hljs-number">1e6</span>+<span class="hljs-number">5</span>; <span class="hljs-keyword">int</span> nt[maxn];<span class="hljs-keyword">char</span> a[maxn],b[maxn];<span class="hljs-keyword">int</span> n;<span class="hljs-comment">//参数为模板串和next数组</span><span class="hljs-comment">//字符串均从下标0开始</span><span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">kmpGetNext</span><span class="hljs-params">(<span class="hljs-keyword">char</span> *s,<span class="hljs-keyword">int</span> *Next)</span></span>&#123;    Next[<span class="hljs-number">0</span>]=<span class="hljs-number">0</span>;    <span class="hljs-keyword">int</span> len=<span class="hljs-built_in">strlen</span>(s);    <span class="hljs-keyword">for</span>(<span class="hljs-keyword">int</span> i=<span class="hljs-number">1</span>,j=<span class="hljs-number">0</span>;i&lt;len;i++)    &#123;        <span class="hljs-keyword">while</span>(j&amp;&amp;s[i]!=s[j]) j=Next[j];        <span class="hljs-keyword">if</span>(s[i]==s[j]) j++;        Next[i+<span class="hljs-number">1</span>]=j;    &#125;<span class="hljs-comment">//    Next[len]=0;</span>&#125;<span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">kmp</span><span class="hljs-params">(<span class="hljs-keyword">char</span> *ss,<span class="hljs-keyword">char</span> *s,<span class="hljs-keyword">int</span> *Next)</span></span>&#123;    kmpGetNext(s,Next);<span class="hljs-comment">//  调试输出Next数组</span><span class="hljs-comment">//int len=strlen(s);</span><span class="hljs-comment">//for(int i=0;i&lt;=n;i++)</span><span class="hljs-comment">//cout&lt;&lt;Next[i]&lt;&lt;" ";</span><span class="hljs-comment">//cout&lt;&lt;endl; </span><span class="hljs-comment">//    int ans=0;</span><span class="hljs-comment">//    int len1=strlen(ss);</span><span class="hljs-comment">//    int len2=strlen(s);</span>    <span class="hljs-keyword">for</span>(<span class="hljs-keyword">int</span> i=<span class="hljs-number">0</span>,j=<span class="hljs-number">0</span>;i&lt;<span class="hljs-number">2</span>*n;i++)  <span class="hljs-comment">//倍长 </span>    &#123;        <span class="hljs-keyword">while</span>(j&amp;&amp;ss[i%n]!=s[j])j=Next[j];        <span class="hljs-keyword">if</span>(ss[i%n]==s[j]) j++;        <span class="hljs-keyword">if</span>(j==n)&#123;<span class="hljs-keyword">return</span> <span class="hljs-number">1</span>;&#125;               &#125;<span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;&#125;<span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">main</span><span class="hljs-params">(<span class="hljs-keyword">void</span>)</span></span>&#123;<span class="hljs-keyword">int</span> t; <span class="hljs-built_in">scanf</span>(<span class="hljs-string">"%d"</span>,&amp;t);     <span class="hljs-keyword">while</span>(t--)&#123;    <span class="hljs-built_in">scanf</span>(<span class="hljs-string">"%s"</span>,a);    <span class="hljs-built_in">memset</span>(nt,<span class="hljs-number">0</span>,<span class="hljs-keyword">sizeof</span>(nt));    n=<span class="hljs-built_in">strlen</span>(a);    kmpGetNext(a,nt);<span class="hljs-keyword">int</span> ans;<span class="hljs-keyword">int</span> k = n-nt[n];<span class="hljs-comment">//循环节大小</span>        <span class="hljs-keyword">if</span>(k == n) <span class="hljs-comment">//不循环，补充相同一串</span>            ans = n;        <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span>(n % k == <span class="hljs-number">0</span>) <span class="hljs-comment">//完全循环，不需要补充</span>            ans = <span class="hljs-number">0</span>;        <span class="hljs-keyword">else</span> <span class="hljs-comment">//补充剩下的</span>            ans = k - (n % k);        <span class="hljs-built_in">printf</span>(<span class="hljs-string">"%d\n"</span>,ans);<span class="hljs-comment">//cout&lt;&lt;endl;</span>&#125;  &#125;</code></pre><h1 id="收获与反思"><a href="#收获与反思" class="headerlink" title="收获与反思"></a>收获与反思</h1><ul><li>对于KMP循环节的问题<ul><li>$n-nt[n]$求得最长循环节的大小（可能是自身）</li><li>$n%(n-nt[n])$求剩下的尾巴大小（可用来判断是不是完全循环）</li></ul></li></ul>]]></content>
    
    
    <categories>
      
      <category>Computer Science</category>
      
      <category>ACM</category>
      
      <category>HDU</category>
      
    </categories>
    
    
    <tags>
      
      <tag>ACM</tag>
      
      <tag>HDU</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>【HDU-1686】解题报告（KMP）</title>
    <link href="/post/6501181e.html"/>
    <url>/post/6501181e.html</url>
    
    <content type="html"><![CDATA[<h1 id="原始题目"><a href="#原始题目" class="headerlink" title="原始题目"></a>原始题目</h1><h2 id="Oulipo"><a href="#Oulipo" class="headerlink" title="Oulipo"></a>Oulipo</h2><ul><li>Time Limit: 3000/1000 MS (Java/Others)    </li><li>Memory Limit: 32768/32768 K (Java/Others)</li><li>Total Submission(s): 21478    </li><li>Accepted Submission(s): 8336</li></ul><h3 id="Problem-Description"><a href="#Problem-Description" class="headerlink" title="Problem Description"></a>Problem Description</h3><p>The French author Georges Perec (1936–1982) once wrote a book, La disparition, without the letter ‘e’. He was a member of the Oulipo group. A quote from the book:</p><p>Tout avait Pair normal, mais tout s’affirmait faux. Tout avait Fair normal, d’abord, puis surgissait l’inhumain, l’affolant. Il aurait voulu savoir où s’articulait l’association qui l’unissait au roman : stir son tapis, assaillant à tout instant son imagination, l’intuition d’un tabou, la vision d’un mal obscur, d’un quoi vacant, d’un non-dit : la vision, l’avision d’un oubli commandant tout, où s’abolissait la raison : tout avait l’air normal mais…</p><p>Perec would probably have scored high (or rather, low) in the following contest. People are asked to write a perhaps even meaningful text on some subject with as few occurrences of a given “word” as possible. Our task is to provide the jury with a program that counts these occurrences, in order to obtain a ranking of the competitors. These competitors often write very long texts with nonsense meaning; a sequence of 500,000 consecutive ‘T’s is not unusual. And they never use spaces.</p><p>So we want to quickly find out how often a word, i.e., a given string, occurs in a text. More formally: given the alphabet {‘A’, ‘B’, ‘C’, …, ‘Z’} and two finite strings over that alphabet, a word W and a text T, count the number of occurrences of W in T. All the consecutive characters of W must exactly match consecutive characters of T. Occurrences may overlap.</p><a id="more"></a><h3 id="Input"><a href="#Input" class="headerlink" title="Input"></a>Input</h3><p>The first line of the input file contains a single number: the number of test cases to follow. Each test case has the following format:</p><p>One line with the word W, a string over {‘A’, ‘B’, ‘C’, …, ‘Z’}, with 1 ≤ |W| ≤ 10,000 (here |W| denotes the length of the string W).</p><p>One line with the text T, a string over {‘A’, ‘B’, ‘C’, …, ‘Z’}, with |W| ≤ |T| ≤ 1,000,000.</p><h3 id="Output"><a href="#Output" class="headerlink" title="Output"></a>Output</h3><p>For every test case in the input file, the output should contain a single number, on a single line: the number of occurrences of the word W in the text T.</p><h3 id="Sample-Input"><a href="#Sample-Input" class="headerlink" title="Sample Input"></a>Sample Input</h3><pre><code>3BAPCBAPCAZAAZAZAZAVERDIAVERDXIVYERDIAN</code></pre><h3 id="Sample-Output"><a href="#Sample-Output" class="headerlink" title="Sample Output"></a>Sample Output</h3><pre><code>130</code></pre><h3 id="Source"><a href="#Source" class="headerlink" title="Source"></a>Source</h3><p>华东区大学生程序设计邀请赛_热身赛</p><h3 id="Recommend"><a href="#Recommend" class="headerlink" title="Recommend"></a>Recommend</h3><p>lcy</p><h1 id="题目大意"><a href="#题目大意" class="headerlink" title="题目大意"></a>题目大意</h1><ul><li>计算T中W的出现次数，W的所有连续字符必须与T的连续字符完全匹配，可能重叠。</li></ul><h1 id="解题思路"><a href="#解题思路" class="headerlink" title="解题思路"></a>解题思路</h1><ul><li>裸KMP</li></ul><h1 id="解题代码"><a href="#解题代码" class="headerlink" title="解题代码"></a>解题代码</h1><pre><code class="hljs C++"><span class="hljs-comment">//#include &lt;bits/stdc++.h&gt;</span><span class="hljs-meta">#<span class="hljs-meta-keyword">include</span> <span class="hljs-meta-string">&lt;cstdio&gt; </span></span><span class="hljs-meta">#<span class="hljs-meta-keyword">include</span> <span class="hljs-meta-string">&lt;cstring&gt;</span></span><span class="hljs-meta">#<span class="hljs-meta-keyword">include</span> <span class="hljs-meta-string">&lt;cstdlib&gt;</span></span><span class="hljs-meta">#<span class="hljs-meta-keyword">include</span> <span class="hljs-meta-string">&lt;iostream&gt;</span></span><span class="hljs-meta">#<span class="hljs-meta-keyword">include</span> <span class="hljs-meta-string">&lt;iomanip&gt;</span></span><span class="hljs-meta">#<span class="hljs-meta-keyword">include</span> <span class="hljs-meta-string">&lt;string&gt;</span></span><span class="hljs-meta">#<span class="hljs-meta-keyword">include</span> <span class="hljs-meta-string">&lt;map&gt;</span></span><span class="hljs-meta">#<span class="hljs-meta-keyword">include</span> <span class="hljs-meta-string">&lt;set&gt;</span></span><span class="hljs-meta">#<span class="hljs-meta-keyword">include</span> <span class="hljs-meta-string">&lt;algorithm&gt;</span></span><span class="hljs-meta">#<span class="hljs-meta-keyword">include</span> <span class="hljs-meta-string">&lt;queue&gt;</span></span><span class="hljs-meta">#<span class="hljs-meta-keyword">include</span> <span class="hljs-meta-string">&lt;vector&gt;</span></span><span class="hljs-meta">#<span class="hljs-meta-keyword">define</span> pb push_back</span><span class="hljs-meta">#<span class="hljs-meta-keyword">define</span> mp make_pair</span><span class="hljs-keyword">using</span> <span class="hljs-keyword">namespace</span> <span class="hljs-built_in">std</span>;<span class="hljs-keyword">typedef</span> <span class="hljs-keyword">long</span> <span class="hljs-keyword">long</span> LL;<span class="hljs-keyword">typedef</span> pair&lt;<span class="hljs-keyword">int</span>,<span class="hljs-keyword">int</span>&gt; PII;<span class="hljs-meta">#<span class="hljs-meta-keyword">define</span> PI acos((double)-1)</span><span class="hljs-meta">#<span class="hljs-meta-keyword">define</span> E exp(double(1))</span><span class="hljs-meta">#<span class="hljs-meta-keyword">define</span> K 1000000+9</span><span class="hljs-meta">#<span class="hljs-meta-keyword">define</span> rep(i,a,n) for(int i=a;i&lt;n;i++)</span><span class="hljs-meta">#<span class="hljs-meta-keyword">define</span> per(i,a,n) for(int i=n-1;i&gt;=a;i--)</span><span class="hljs-meta">#<span class="hljs-meta-keyword">define</span> ms(x,a) memset((x),(a),sizeof(a))</span><span class="hljs-keyword">int</span> nt[<span class="hljs-number">10006</span>];<span class="hljs-keyword">char</span> a[K],b[<span class="hljs-number">10005</span>];<span class="hljs-keyword">int</span> n,m;<span class="hljs-comment">//参数为模板串和next数组</span><span class="hljs-comment">//字符串均从下标0开始</span><span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">kmpGetNext</span><span class="hljs-params">(<span class="hljs-keyword">char</span> *s,<span class="hljs-keyword">int</span> *Next)</span></span>&#123;    Next[<span class="hljs-number">0</span>]=<span class="hljs-number">0</span>;    <span class="hljs-keyword">int</span> len=<span class="hljs-built_in">strlen</span>(s);    <span class="hljs-keyword">for</span>(<span class="hljs-keyword">int</span> i=<span class="hljs-number">1</span>,j=<span class="hljs-number">0</span>;i&lt;len;i++)    &#123;        <span class="hljs-keyword">while</span>(j&amp;&amp;s[i]!=s[j]) j=Next[j];        <span class="hljs-keyword">if</span>(s[i]==s[j]) j++;        Next[i+<span class="hljs-number">1</span>]=j;    &#125;<span class="hljs-comment">//    Next[len]=0;</span>&#125;<span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">kmp</span><span class="hljs-params">(<span class="hljs-keyword">char</span> *ss,<span class="hljs-keyword">char</span> *s,<span class="hljs-keyword">int</span> *Next)</span></span>&#123;    kmpGetNext(s,Next);<span class="hljs-comment">//  调试输出Next数组</span><span class="hljs-comment">//int len=strlen(s);</span><span class="hljs-comment">//for(int i=0;i&lt;=len;i++)</span><span class="hljs-comment">//cout&lt;&lt;Next[i]&lt;&lt;" ";</span><span class="hljs-comment">//cout&lt;&lt;endl; </span>    <span class="hljs-keyword">int</span> ans=<span class="hljs-number">0</span>;    <span class="hljs-keyword">int</span> len1=<span class="hljs-built_in">strlen</span>(ss);    <span class="hljs-keyword">int</span> len2=<span class="hljs-built_in">strlen</span>(s);    <span class="hljs-keyword">for</span>(<span class="hljs-keyword">int</span> i=<span class="hljs-number">0</span>,j=<span class="hljs-number">0</span>;i&lt;len1;i++)    &#123;        <span class="hljs-keyword">while</span>(j&amp;&amp;ss[i]!=s[j])j=Next[j];        <span class="hljs-keyword">if</span>(ss[i]==s[j]) j++;        <span class="hljs-keyword">if</span>(j==len2)&#123;        ans++;<span class="hljs-comment">//return i-len2+2;</span>&#125;               &#125;<span class="hljs-comment">//    return -1;</span><span class="hljs-keyword">return</span> ans;&#125;<span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">main</span><span class="hljs-params">(<span class="hljs-keyword">void</span>)</span></span>&#123;    <span class="hljs-keyword">int</span> t;    <span class="hljs-built_in">scanf</span>(<span class="hljs-string">"%d"</span>,&amp;t);     <span class="hljs-keyword">while</span>(t--)    &#123;    <span class="hljs-built_in">memset</span>(a,<span class="hljs-number">0</span>,<span class="hljs-keyword">sizeof</span>(a));    <span class="hljs-built_in">memset</span>(b,<span class="hljs-number">0</span>,<span class="hljs-keyword">sizeof</span>(b));    <span class="hljs-built_in">scanf</span>(<span class="hljs-string">"%s"</span>,b);    <span class="hljs-built_in">scanf</span>(<span class="hljs-string">"%s"</span>,a);    <span class="hljs-built_in">cout</span>&lt;&lt; kmp(a,b,nt)&lt;&lt;<span class="hljs-built_in">endl</span>;    &#125;    <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;&#125;</code></pre><h1 id="收获与反思"><a href="#收获与反思" class="headerlink" title="收获与反思"></a>收获与反思</h1><ul><li>KMP水题</li></ul>]]></content>
    
    
    <categories>
      
      <category>Computer Science</category>
      
      <category>ACM</category>
      
      <category>HDU</category>
      
    </categories>
    
    
    <tags>
      
      <tag>ACM</tag>
      
      <tag>HDU</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>【HDU-2087】解题报告（KMP，去重）</title>
    <link href="/post/c5672df5.html"/>
    <url>/post/c5672df5.html</url>
    
    <content type="html"><![CDATA[<h1 id="原始题目"><a href="#原始题目" class="headerlink" title="原始题目"></a>原始题目</h1><h2 id="剪花布条"><a href="#剪花布条" class="headerlink" title="剪花布条"></a>剪花布条</h2><ul><li>Time Limit: 1000/1000 MS (Java/Others)    </li><li>Memory Limit: 32768/32768 K (Java/Others)</li><li>Total Submission(s): 28902    </li><li>Accepted Submission(s): 17700</li></ul><h3 id="Problem-Description"><a href="#Problem-Description" class="headerlink" title="Problem Description"></a>Problem Description</h3><p>一块花布条，里面有些图案，另有一块直接可用的小饰条，里面也有一些图案。对于给定的花布条和小饰条，计算一下能从花布条中尽可能剪出几块小饰条来呢？<br><a id="more"></a></p><h3 id="Input"><a href="#Input" class="headerlink" title="Input"></a>Input</h3><p>输入中含有一些数据，分别是成对出现的花布条和小饰条，其布条都是用可见ASCII字符表示的，可见的ASCII字符有多少个，布条的花纹也有多少种花样。花纹条和小饰条不会超过1000个字符长。如果遇见#字符，则不再进行工作。</p><h3 id="Output"><a href="#Output" class="headerlink" title="Output"></a>Output</h3><p>输出能从花纹布中剪出的最多小饰条个数，如果一块都没有，那就老老实实输出0，每个结果之间应换行。</p><h3 id="Sample-Input"><a href="#Sample-Input" class="headerlink" title="Sample Input"></a>Sample Input</h3><pre><code>abcde a3aaaaaa  aa#</code></pre><h3 id="Sample-Output"><a href="#Sample-Output" class="headerlink" title="Sample Output"></a>Sample Output</h3><pre><code>03</code></pre><h3 id="Author"><a href="#Author" class="headerlink" title="Author"></a>Author</h3><p>qianneng</p><h3 id="Source"><a href="#Source" class="headerlink" title="Source"></a>Source</h3><p>冬练三九之二</p><h3 id="Recommend"><a href="#Recommend" class="headerlink" title="Recommend"></a>Recommend</h3><p>lcy</p><h1 id="题目大意"><a href="#题目大意" class="headerlink" title="题目大意"></a>题目大意</h1><p>如题</p><h1 id="解题思路"><a href="#解题思路" class="headerlink" title="解题思路"></a>解题思路</h1><ul><li>模板加一句$Next[len]=0$，去重即可。</li></ul><h1 id="解题代码"><a href="#解题代码" class="headerlink" title="解题代码"></a>解题代码</h1><pre><code class="hljs C++"><span class="hljs-comment">//#include &lt;bits/stdc++.h&gt;</span><span class="hljs-meta">#<span class="hljs-meta-keyword">include</span> <span class="hljs-meta-string">&lt;cstdio&gt; </span></span><span class="hljs-meta">#<span class="hljs-meta-keyword">include</span> <span class="hljs-meta-string">&lt;cstring&gt;</span></span><span class="hljs-meta">#<span class="hljs-meta-keyword">include</span> <span class="hljs-meta-string">&lt;cstdlib&gt;</span></span><span class="hljs-meta">#<span class="hljs-meta-keyword">include</span> <span class="hljs-meta-string">&lt;iostream&gt;</span></span><span class="hljs-meta">#<span class="hljs-meta-keyword">include</span> <span class="hljs-meta-string">&lt;iomanip&gt;</span></span><span class="hljs-meta">#<span class="hljs-meta-keyword">include</span> <span class="hljs-meta-string">&lt;string&gt;</span></span><span class="hljs-meta">#<span class="hljs-meta-keyword">include</span> <span class="hljs-meta-string">&lt;map&gt;</span></span><span class="hljs-meta">#<span class="hljs-meta-keyword">include</span> <span class="hljs-meta-string">&lt;set&gt;</span></span><span class="hljs-meta">#<span class="hljs-meta-keyword">include</span> <span class="hljs-meta-string">&lt;algorithm&gt;</span></span><span class="hljs-meta">#<span class="hljs-meta-keyword">include</span> <span class="hljs-meta-string">&lt;queue&gt;</span></span><span class="hljs-meta">#<span class="hljs-meta-keyword">include</span> <span class="hljs-meta-string">&lt;vector&gt;</span></span><span class="hljs-meta">#<span class="hljs-meta-keyword">define</span> pb push_back</span><span class="hljs-meta">#<span class="hljs-meta-keyword">define</span> mp make_pair</span><span class="hljs-keyword">using</span> <span class="hljs-keyword">namespace</span> <span class="hljs-built_in">std</span>;<span class="hljs-keyword">typedef</span> <span class="hljs-keyword">long</span> <span class="hljs-keyword">long</span> LL;<span class="hljs-keyword">typedef</span> pair&lt;<span class="hljs-keyword">int</span>,<span class="hljs-keyword">int</span>&gt; PII;<span class="hljs-meta">#<span class="hljs-meta-keyword">define</span> PI acos((double)-1)</span><span class="hljs-meta">#<span class="hljs-meta-keyword">define</span> E exp(double(1))</span><span class="hljs-meta">#<span class="hljs-meta-keyword">define</span> K 1000000+9</span><span class="hljs-meta">#<span class="hljs-meta-keyword">define</span> rep(i,a,n) for(int i=a;i&lt;n;i++)</span><span class="hljs-meta">#<span class="hljs-meta-keyword">define</span> per(i,a,n) for(int i=n-1;i&gt;=a;i--)</span><span class="hljs-meta">#<span class="hljs-meta-keyword">define</span> ms(x,a) memset((x),(a),sizeof(a))</span><span class="hljs-keyword">int</span> nt[<span class="hljs-number">10006</span>];<span class="hljs-keyword">char</span> a[K],b[<span class="hljs-number">10005</span>];<span class="hljs-keyword">int</span> n,m;<span class="hljs-comment">//参数为模板串和next数组</span><span class="hljs-comment">//字符串均从下标0开始</span><span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">kmpGetNext</span><span class="hljs-params">(<span class="hljs-keyword">char</span> *s,<span class="hljs-keyword">int</span> *Next)</span></span>&#123;    Next[<span class="hljs-number">0</span>]=<span class="hljs-number">0</span>;    <span class="hljs-keyword">int</span> len=<span class="hljs-built_in">strlen</span>(s);    <span class="hljs-keyword">for</span>(<span class="hljs-keyword">int</span> i=<span class="hljs-number">1</span>,j=<span class="hljs-number">0</span>;i&lt;len;i++)    &#123;        <span class="hljs-keyword">while</span>(j&amp;&amp;s[i]!=s[j]) j=Next[j];        <span class="hljs-keyword">if</span>(s[i]==s[j]) j++;        Next[i+<span class="hljs-number">1</span>]=j;    &#125;<span class="hljs-comment">//    Next[len]=0;</span>&#125;<span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">kmp</span><span class="hljs-params">(<span class="hljs-keyword">char</span> *ss,<span class="hljs-keyword">char</span> *s,<span class="hljs-keyword">int</span> *Next)</span></span>&#123;    kmpGetNext(s,Next);<span class="hljs-comment">//  调试输出Next数组</span><span class="hljs-comment">//int len=strlen(s);</span><span class="hljs-comment">//for(int i=0;i&lt;=len;i++)</span><span class="hljs-comment">//cout&lt;&lt;Next[i]&lt;&lt;" ";</span><span class="hljs-comment">//cout&lt;&lt;endl; </span>    <span class="hljs-keyword">int</span> ans=<span class="hljs-number">0</span>;    <span class="hljs-keyword">int</span> len1=<span class="hljs-built_in">strlen</span>(ss);    <span class="hljs-keyword">int</span> len2=<span class="hljs-built_in">strlen</span>(s);    <span class="hljs-keyword">for</span>(<span class="hljs-keyword">int</span> i=<span class="hljs-number">0</span>,j=<span class="hljs-number">0</span>;i&lt;len1;i++)    &#123;        <span class="hljs-keyword">while</span>(j&amp;&amp;ss[i]!=s[j])j=Next[j];        <span class="hljs-keyword">if</span>(ss[i]==s[j]) j++;        <span class="hljs-keyword">if</span>(j==len2)&#123;        ans++;<span class="hljs-comment">//return i-len2+2;</span>&#125;               &#125;<span class="hljs-comment">//    return -1;</span><span class="hljs-keyword">return</span> ans;&#125;<span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">main</span><span class="hljs-params">(<span class="hljs-keyword">void</span>)</span></span>&#123;<span class="hljs-comment">//ios::sync_with_stdio(false);</span>    <span class="hljs-keyword">int</span> t;    <span class="hljs-built_in">scanf</span>(<span class="hljs-string">"%d"</span>,&amp;t);     <span class="hljs-keyword">while</span>(t--)    &#123;    <span class="hljs-built_in">memset</span>(a,<span class="hljs-number">0</span>,<span class="hljs-keyword">sizeof</span>(a));    <span class="hljs-built_in">memset</span>(b,<span class="hljs-number">0</span>,<span class="hljs-keyword">sizeof</span>(b));    <span class="hljs-built_in">scanf</span>(<span class="hljs-string">"%s"</span>,a);    <span class="hljs-built_in">scanf</span>(<span class="hljs-string">"%s"</span>,b);    <span class="hljs-built_in">cout</span>&lt;&lt; kmp(a,b,nt)&lt;&lt;<span class="hljs-built_in">endl</span>;    &#125;    <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;&#125;</code></pre><h1 id="收获与反思"><a href="#收获与反思" class="headerlink" title="收获与反思"></a>收获与反思</h1><ul><li>KMP水题</li></ul>]]></content>
    
    
    <categories>
      
      <category>Computer Science</category>
      
      <category>ACM</category>
      
      <category>HDU</category>
      
    </categories>
    
    
    <tags>
      
      <tag>ACM</tag>
      
      <tag>HDU</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>【CSU-1598】解题报告（KMP）</title>
    <link href="/post/9a9a4797.html"/>
    <url>/post/9a9a4797.html</url>
    
    <content type="html"><![CDATA[<h1 id="原始题目"><a href="#原始题目" class="headerlink" title="原始题目"></a>原始题目</h1><h2 id="1598-最长公共前缀"><a href="#1598-最长公共前缀" class="headerlink" title="1598: 最长公共前缀"></a>1598: 最长公共前缀</h2><ul><li>Time Limit: 1 Sec     </li><li>Memory Limit: 128 Mb     </li><li>Submitted: 222     </li><li>Solved: 186    </li></ul><h3 id="Description"><a href="#Description" class="headerlink" title="Description"></a>Description</h3><p>给定两个字符串$s$和$t$，现有一个扫描器，从$s$的最左边开始向右扫描，每次扫描到一个$t$就把这一段删除，输出能发现$t$的个数。<br><a id="more"></a></p><h3 id="Input"><a href="#Input" class="headerlink" title="Input"></a>Input</h3><p>第一行包含一个整数$ T ( T \le  50)$ ，表示数据组数。<br>每组数据第一行包含一个字符串$s$，第二行一个字符串$t$，字符串长度不超过$1000000$。</p><h3 id="Output"><a href="#Output" class="headerlink" title="Output"></a>Output</h3><p>对于每组数据，输出答案。</p><h3 id="Sample-Input"><a href="#Sample-Input" class="headerlink" title="Sample Input"></a>Sample Input</h3><pre><code>2abababababababbaSample Output32</code></pre><h3 id="Hint"><a href="#Hint" class="headerlink" title="Hint"></a>Hint</h3><h3 id="Source"><a href="#Source" class="headerlink" title="Source"></a>Source</h3><p>国防科学技术大学第十八届银河之光文化节ACM程序设计竞赛初赛</p><h1 id="题目大意"><a href="#题目大意" class="headerlink" title="题目大意"></a>题目大意</h1><p>如题</p><h1 id="解题思路"><a href="#解题思路" class="headerlink" title="解题思路"></a>解题思路</h1><ul><li>加一个$Next[m]=0$即匹配完成后删除这一段（去重）</li><li>不过这个题目水，不加也过了</li></ul><h1 id="解题代码"><a href="#解题代码" class="headerlink" title="解题代码"></a>解题代码</h1><pre><code class="hljs C++"><span class="hljs-comment">//#include &lt;bits/stdc++.h&gt;</span><span class="hljs-meta">#<span class="hljs-meta-keyword">include</span> <span class="hljs-meta-string">&lt;cstdio&gt; </span></span><span class="hljs-meta">#<span class="hljs-meta-keyword">include</span> <span class="hljs-meta-string">&lt;cstring&gt;</span></span><span class="hljs-meta">#<span class="hljs-meta-keyword">include</span> <span class="hljs-meta-string">&lt;cstdlib&gt;</span></span><span class="hljs-meta">#<span class="hljs-meta-keyword">include</span> <span class="hljs-meta-string">&lt;iostream&gt;</span></span><span class="hljs-meta">#<span class="hljs-meta-keyword">include</span> <span class="hljs-meta-string">&lt;iomanip&gt;</span></span><span class="hljs-meta">#<span class="hljs-meta-keyword">include</span> <span class="hljs-meta-string">&lt;string&gt;</span></span><span class="hljs-meta">#<span class="hljs-meta-keyword">include</span> <span class="hljs-meta-string">&lt;map&gt;</span></span><span class="hljs-meta">#<span class="hljs-meta-keyword">include</span> <span class="hljs-meta-string">&lt;set&gt;</span></span><span class="hljs-meta">#<span class="hljs-meta-keyword">include</span> <span class="hljs-meta-string">&lt;algorithm&gt;</span></span><span class="hljs-meta">#<span class="hljs-meta-keyword">include</span> <span class="hljs-meta-string">&lt;queue&gt;</span></span><span class="hljs-meta">#<span class="hljs-meta-keyword">include</span> <span class="hljs-meta-string">&lt;vector&gt;</span></span><span class="hljs-meta">#<span class="hljs-meta-keyword">define</span> pb push_back</span><span class="hljs-meta">#<span class="hljs-meta-keyword">define</span> mp make_pair</span><span class="hljs-keyword">using</span> <span class="hljs-keyword">namespace</span> <span class="hljs-built_in">std</span>;<span class="hljs-keyword">typedef</span> <span class="hljs-keyword">long</span> <span class="hljs-keyword">long</span> LL;<span class="hljs-keyword">typedef</span> pair&lt;<span class="hljs-keyword">int</span>,<span class="hljs-keyword">int</span>&gt; PII;<span class="hljs-meta">#<span class="hljs-meta-keyword">define</span> PI acos((double)-1)</span><span class="hljs-meta">#<span class="hljs-meta-keyword">define</span> E exp(double(1))</span><span class="hljs-meta">#<span class="hljs-meta-keyword">define</span> K 1000000+9</span><span class="hljs-meta">#<span class="hljs-meta-keyword">define</span> rep(i,a,n) for(int i=a;i&lt;n;i++)</span><span class="hljs-meta">#<span class="hljs-meta-keyword">define</span> per(i,a,n) for(int i=n-1;i&gt;=a;i--)</span><span class="hljs-meta">#<span class="hljs-meta-keyword">define</span> ms(x,a) memset((x),(a),sizeof(a))</span><span class="hljs-keyword">int</span> nt[<span class="hljs-number">10006</span>];<span class="hljs-keyword">char</span> a[K],b[<span class="hljs-number">10005</span>];<span class="hljs-keyword">int</span> n,m;<span class="hljs-comment">//参数为模板串和next数组</span><span class="hljs-comment">//字符串均从下标0开始</span><span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">kmpGetNext</span><span class="hljs-params">(<span class="hljs-keyword">char</span> *s,<span class="hljs-keyword">int</span> *Next)</span></span>&#123;    Next[<span class="hljs-number">0</span>]=<span class="hljs-number">0</span>;    <span class="hljs-keyword">int</span> len=<span class="hljs-built_in">strlen</span>(s);    <span class="hljs-keyword">for</span>(<span class="hljs-keyword">int</span> i=<span class="hljs-number">1</span>,j=<span class="hljs-number">0</span>;i&lt;len;i++)    &#123;        <span class="hljs-keyword">while</span>(j&amp;&amp;s[i]!=s[j]) j=Next[j];        <span class="hljs-keyword">if</span>(s[i]==s[j]) j++;        Next[i+<span class="hljs-number">1</span>]=j;    &#125;    Next[len]=<span class="hljs-number">0</span>;&#125;<span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">kmp</span><span class="hljs-params">(<span class="hljs-keyword">char</span> *ss,<span class="hljs-keyword">char</span> *s,<span class="hljs-keyword">int</span> *Next)</span></span>&#123;    kmpGetNext(s,Next);<span class="hljs-comment">//  调试输出Next数组</span><span class="hljs-comment">//int len=strlen(s);</span><span class="hljs-comment">//for(int i=0;i&lt;=len;i++)</span><span class="hljs-comment">//cout&lt;&lt;Next[i]&lt;&lt;" ";</span><span class="hljs-comment">//cout&lt;&lt;endl; </span>    <span class="hljs-keyword">int</span> ans=<span class="hljs-number">0</span>;    <span class="hljs-keyword">int</span> len1=<span class="hljs-built_in">strlen</span>(ss);    <span class="hljs-keyword">int</span> len2=<span class="hljs-built_in">strlen</span>(s);    <span class="hljs-keyword">for</span>(<span class="hljs-keyword">int</span> i=<span class="hljs-number">0</span>,j=<span class="hljs-number">0</span>;i&lt;len1;i++)    &#123;        <span class="hljs-keyword">while</span>(j&amp;&amp;ss[i]!=s[j])j=Next[j];        <span class="hljs-keyword">if</span>(ss[i]==s[j]) j++;        <span class="hljs-keyword">if</span>(j==len2)&#123;        ans++;<span class="hljs-comment">//return i-len2+2;</span>&#125;               &#125;<span class="hljs-comment">//    return -1;</span><span class="hljs-keyword">return</span> ans;&#125;<span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">main</span><span class="hljs-params">(<span class="hljs-keyword">void</span>)</span></span>&#123;<span class="hljs-comment">//ios::sync_with_stdio(false);</span>    <span class="hljs-keyword">int</span> t;    <span class="hljs-built_in">scanf</span>(<span class="hljs-string">"%d"</span>,&amp;t);     <span class="hljs-keyword">while</span>(t--)    &#123;    <span class="hljs-built_in">memset</span>(a,<span class="hljs-number">0</span>,<span class="hljs-keyword">sizeof</span>(a));    <span class="hljs-built_in">memset</span>(b,<span class="hljs-number">0</span>,<span class="hljs-keyword">sizeof</span>(b));    <span class="hljs-built_in">scanf</span>(<span class="hljs-string">"%s"</span>,a);    <span class="hljs-built_in">scanf</span>(<span class="hljs-string">"%s"</span>,b);    <span class="hljs-built_in">cout</span>&lt;&lt; kmp(a,b,nt)&lt;&lt;<span class="hljs-built_in">endl</span>;    &#125;    <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;&#125;</code></pre><h1 id="收获与反思"><a href="#收获与反思" class="headerlink" title="收获与反思"></a>收获与反思</h1><ul><li>KMP水题</li></ul>]]></content>
    
    
    <categories>
      
      <category>Computer Science</category>
      
      <category>ACM</category>
      
      <category>CSU</category>
      
    </categories>
    
    
    <tags>
      
      <tag>ACM</tag>
      
      <tag>CSU</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>【CSU-1581】解题报告（思维，KMP）</title>
    <link href="/post/742966af.html"/>
    <url>/post/742966af.html</url>
    
    <content type="html"><![CDATA[<h1 id="原始题目"><a href="#原始题目" class="headerlink" title="原始题目"></a>原始题目</h1><h2 id="Problem-H-Clock-Pictures"><a href="#Problem-H-Clock-Pictures" class="headerlink" title="Problem H: Clock Pictures"></a>Problem H: Clock Pictures</h2><h3 id="1581-Clock-Pictures"><a href="#1581-Clock-Pictures" class="headerlink" title="1581: Clock Pictures"></a>1581: Clock Pictures</h3><ul><li>Time Limit: 3 Sec</li><li>Memory Limit: 128 Mb</li><li>Submitted: 322</li><li>Solved: 82</li></ul><h3 id="Description"><a href="#Description" class="headerlink" title="Description"></a>Description</h3><p>You have two pictures of an unusual kind of clock. The clock has n hands, each having the same length and no kind of marking whatsoever. Also, the numbers on the clock are so faded that you can’t even tell anymore what direction is up in the picture. So the only thing that you see on the pictures, are n shades of the n hands, and nothing else.</p><p>You’d like to know if both images might have been taken at exactly the same time of the day, possibly with the camera rotated at different angles.</p><p>Given the description of the two images, determine whether it is possible that these two pictures could be showing the same clock displaying the same time.<br><a id="more"></a></p><h3 id="Input"><a href="#Input" class="headerlink" title="Input"></a>Input</h3><p>The ﬁrst line contains a single integer $n$ $(2 ≤ n ≤ 200 000)$, the number of hands on the clock.</p><p>Each of the next two lines contains n integers $a_i$ $(0 ≤ a_i &lt; 360 000)$,<br>representing the angles of the hands of the clock on one of the images,<br>in thousandths of a degree.</p><p>The ﬁrst line represents the position of the hands on the ﬁrst image, whereas the second line corresponds to the second image. The number $a_i$ denotes the angle between the recorded position of some hand and the upward direction in the image, measured clockwise. Angles of the same clock are distinct and are not given in any speciﬁc order.</p><h3 id="Output"><a href="#Output" class="headerlink" title="Output"></a>Output</h3><p>Output one line containing one word: possible if the clocks could be showing the same time,impossible otherwise.</p><p><img src="https://eddyblog.oss-cn-shenzhen.aliyuncs.com/%E3%80%90CSU-1581%E3%80%91%E8%A7%A3%E9%A2%98%E6%8A%A5%E5%91%8A%EF%BC%88%E6%80%9D%E7%BB%B4%EF%BC%8CKMP%EF%BC%89/1.jpg" srcset="/img/loading.gif" alt="1.jpg"></p><h3 id="Sample-Input"><a href="#Sample-Input" class="headerlink" title="Sample Input"></a>Sample Input</h3><pre><code>61 2 3 4 5 67 6 5 4 3 1</code></pre><h3 id="Sample-Output"><a href="#Sample-Output" class="headerlink" title="Sample Output"></a>Sample Output</h3><pre><code>impossible</code></pre><h3 id="HINT"><a href="#HINT" class="headerlink" title="HINT"></a>HINT</h3><h1 id="题目大意"><a href="#题目大意" class="headerlink" title="题目大意"></a>题目大意</h1><ul><li>一个有$n$个指针的表盘，看不清数字，以随机顺序给出n个指针相对记录位置（不固定）的顺时针旋转角度，问两个表盘经过旋转是否能够重合（是否表示一个表盘）。</li></ul><h1 id="解题思路"><a href="#解题思路" class="headerlink" title="解题思路"></a>解题思路</h1><ul><li>对于相同表盘，记录位置不固定，但是两个指针间的角度差固定，判断位移后可不可以相同。</li><li>注意第一个指针和末尾指针的角度差需要补3600000</li><li>将一组倍长做KMP可以解决这个问题，若位移后可以相同，那么倍长后2倍距离必包含另一串。</li></ul><h1 id="解题代码"><a href="#解题代码" class="headerlink" title="解题代码"></a>解题代码</h1><pre><code class="hljs C++"><span class="hljs-comment">//#include &lt;bits/stdc++.h&gt;</span><span class="hljs-meta">#<span class="hljs-meta-keyword">include</span> <span class="hljs-meta-string">&lt;cstdio&gt;</span></span><span class="hljs-meta">#<span class="hljs-meta-keyword">include</span> <span class="hljs-meta-string">&lt;cstring&gt;</span></span><span class="hljs-meta">#<span class="hljs-meta-keyword">include</span> <span class="hljs-meta-string">&lt;cstdlib&gt;</span></span><span class="hljs-meta">#<span class="hljs-meta-keyword">include</span> <span class="hljs-meta-string">&lt;iostream&gt;</span></span><span class="hljs-meta">#<span class="hljs-meta-keyword">include</span> <span class="hljs-meta-string">&lt;iomanip&gt;</span></span><span class="hljs-meta">#<span class="hljs-meta-keyword">include</span> <span class="hljs-meta-string">&lt;string&gt;</span></span><span class="hljs-meta">#<span class="hljs-meta-keyword">include</span> <span class="hljs-meta-string">&lt;map&gt;</span></span><span class="hljs-meta">#<span class="hljs-meta-keyword">include</span> <span class="hljs-meta-string">&lt;set&gt;</span></span><span class="hljs-meta">#<span class="hljs-meta-keyword">include</span> <span class="hljs-meta-string">&lt;algorithm&gt;</span></span><span class="hljs-meta">#<span class="hljs-meta-keyword">include</span> <span class="hljs-meta-string">&lt;queue&gt;</span></span><span class="hljs-meta">#<span class="hljs-meta-keyword">include</span> <span class="hljs-meta-string">&lt;vector&gt;</span></span><span class="hljs-meta">#<span class="hljs-meta-keyword">define</span> pb push_back</span><span class="hljs-meta">#<span class="hljs-meta-keyword">define</span> mp make_pair</span><span class="hljs-keyword">using</span> <span class="hljs-keyword">namespace</span> <span class="hljs-built_in">std</span>;<span class="hljs-keyword">typedef</span> <span class="hljs-keyword">long</span> <span class="hljs-keyword">long</span> LL;<span class="hljs-keyword">typedef</span> pair&lt;<span class="hljs-keyword">int</span>,<span class="hljs-keyword">int</span>&gt; PII;<span class="hljs-meta">#<span class="hljs-meta-keyword">define</span> PI acos((double)-1)</span><span class="hljs-meta">#<span class="hljs-meta-keyword">define</span> E exp(double(1))</span><span class="hljs-meta">#<span class="hljs-meta-keyword">define</span> K 1000000+9</span><span class="hljs-meta">#<span class="hljs-meta-keyword">define</span> rep(i,a,n) for(int i=a;i&lt;n;i++)</span><span class="hljs-meta">#<span class="hljs-meta-keyword">define</span> per(i,a,n) for(int i=n-1;i&gt;=a;i--)</span><span class="hljs-meta">#<span class="hljs-meta-keyword">define</span> ms(x,a) memset((x),(a),sizeof(a))</span><span class="hljs-keyword">const</span> <span class="hljs-keyword">int</span> maxn=<span class="hljs-number">2e5</span>+<span class="hljs-number">5</span>; <span class="hljs-keyword">int</span> nt[maxn];<span class="hljs-keyword">int</span> aa[maxn],bb[maxn];<span class="hljs-keyword">int</span> a[maxn],b[maxn];<span class="hljs-keyword">int</span> n;<span class="hljs-comment">//参数为模板串和next数组</span><span class="hljs-comment">//字符串均从下标0开始</span><span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">kmpGetNext</span><span class="hljs-params">(<span class="hljs-keyword">int</span> *s,<span class="hljs-keyword">int</span> *Next)</span></span>&#123;    Next[<span class="hljs-number">0</span>]=<span class="hljs-number">0</span>;<span class="hljs-comment">//    int len=strlen(s);</span>    <span class="hljs-keyword">for</span>(<span class="hljs-keyword">int</span> i=<span class="hljs-number">1</span>,j=<span class="hljs-number">0</span>;i&lt;n;i++)    &#123;        <span class="hljs-keyword">while</span>(j&amp;&amp;s[i]!=s[j]) j=Next[j];        <span class="hljs-keyword">if</span>(s[i]==s[j]) j++;        Next[i+<span class="hljs-number">1</span>]=j;    &#125;<span class="hljs-comment">//    Next[len]=0;</span>&#125;<span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">kmp</span><span class="hljs-params">(<span class="hljs-keyword">int</span> *ss,<span class="hljs-keyword">int</span> *s,<span class="hljs-keyword">int</span> *Next)</span></span>&#123;    kmpGetNext(s,Next);<span class="hljs-comment">//  调试输出Next数组</span><span class="hljs-comment">//int len=strlen(s);</span><span class="hljs-comment">//for(int i=0;i&lt;=n;i++)</span><span class="hljs-comment">//cout&lt;&lt;Next[i]&lt;&lt;" ";</span><span class="hljs-comment">//cout&lt;&lt;endl; </span><span class="hljs-comment">//    int ans=0;</span><span class="hljs-comment">//    int len1=strlen(ss);</span><span class="hljs-comment">//    int len2=strlen(s);</span>    <span class="hljs-keyword">for</span>(<span class="hljs-keyword">int</span> i=<span class="hljs-number">0</span>,j=<span class="hljs-number">0</span>;i&lt;<span class="hljs-number">2</span>*n;i++)  <span class="hljs-comment">//倍长 </span>    &#123;        <span class="hljs-keyword">while</span>(j&amp;&amp;ss[i%n]!=s[j])j=Next[j];        <span class="hljs-keyword">if</span>(ss[i%n]==s[j]) j++;        <span class="hljs-keyword">if</span>(j==n)&#123;<span class="hljs-keyword">return</span> <span class="hljs-number">1</span>;&#125;               &#125;<span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;&#125;<span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">main</span><span class="hljs-params">(<span class="hljs-keyword">void</span>)</span></span>&#123;ios::sync_with_stdio(<span class="hljs-literal">false</span>);    <span class="hljs-keyword">while</span>(<span class="hljs-built_in">cin</span>&gt;&gt;n)    &#123;    <span class="hljs-built_in">memset</span>(a,<span class="hljs-number">0</span>,<span class="hljs-keyword">sizeof</span>(a));    <span class="hljs-built_in">memset</span>(b,<span class="hljs-number">0</span>,<span class="hljs-keyword">sizeof</span>(b));    rep(i,<span class="hljs-number">0</span>,n) <span class="hljs-built_in">cin</span>&gt;&gt;aa[i];    rep(i,<span class="hljs-number">0</span>,n) <span class="hljs-built_in">cin</span>&gt;&gt;bb[i];    sort(aa,aa+n);    sort(bb,bb+n);    rep(i,<span class="hljs-number">0</span>,n<span class="hljs-number">-1</span>)&#123;    a[i]=aa[i+<span class="hljs-number">1</span>]-aa[i];    b[i]=bb[i+<span class="hljs-number">1</span>]-bb[i];&#125;a[n<span class="hljs-number">-1</span>]=<span class="hljs-number">360000</span>+aa[<span class="hljs-number">0</span>]-aa[n<span class="hljs-number">-1</span>];<span class="hljs-comment">//rep(i,0,n) cout&lt;&lt;a[i]&lt;&lt;" ";</span><span class="hljs-comment">//cout&lt;&lt;endl;</span>b[n<span class="hljs-number">-1</span>]=<span class="hljs-number">360000</span>+bb[<span class="hljs-number">0</span>]-bb[n<span class="hljs-number">-1</span>];<span class="hljs-comment">//rep(i,0,n) cout&lt;&lt;b[i]&lt;&lt;" ";</span><span class="hljs-comment">//cout&lt;&lt;endl;</span>    <span class="hljs-keyword">if</span>(kmp(a,b,nt))    <span class="hljs-built_in">cout</span>&lt;&lt;<span class="hljs-string">"possible"</span>&lt;&lt;<span class="hljs-built_in">endl</span>;    <span class="hljs-keyword">else</span> <span class="hljs-built_in">cout</span>&lt;&lt;<span class="hljs-string">"impossible"</span>&lt;&lt;<span class="hljs-built_in">endl</span>;    &#125;    <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;&#125;</code></pre><h1 id="收获与反思"><a href="#收获与反思" class="headerlink" title="收获与反思"></a>收获与反思</h1><ul><li>仔细读题，分析题目</li><li>倍长KMP可以判断自身位移的情况。</li></ul>]]></content>
    
    
    <categories>
      
      <category>Computer Science</category>
      
      <category>ACM</category>
      
      <category>CSU</category>
      
    </categories>
    
    
    <tags>
      
      <tag>ACM</tag>
      
      <tag>CSU</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>【HDU-6373】解题报告（物理力学，模拟，2018杭电多校第六场）</title>
    <link href="/post/d73de254.html"/>
    <url>/post/d73de254.html</url>
    
    <content type="html"><![CDATA[<h1 id="原始题目"><a href="#原始题目" class="headerlink" title="原始题目"></a>原始题目</h1><h2 id="Pinball"><a href="#Pinball" class="headerlink" title="Pinball"></a>Pinball</h2><ul><li>Time Limit: 2000/1000 MS (Java/Others)    </li><li>Memory Limit: 262144/262144 K (Java/Others)</li><li>Total Submission(s): 604    </li><li>Accepted Submission(s): 264</li></ul><h3 id="Problem-Description"><a href="#Problem-Description" class="headerlink" title="Problem Description"></a>Problem Description</h3><p>There is a slope on the 2D plane. The lowest point of the slope is at the origin. There is a small ball falling down above the slope. Your task is to find how many times the ball has been bounced on the slope.</p><p>It’s guarantee that the ball will not reach the slope or ground or Y-axis with a distance of less than 1 from the origin. And the ball is elastic collision without energy loss. Gravity acceleration $g=9.8m/s^2$.</p><a id="more"></a><h3 id="Input"><a href="#Input" class="headerlink" title="Input"></a>Input</h3><p>There are multiple test cases. The first line of input contains an integer T (1 ≤ T ≤ 100), indicating the number of test cases.</p><p>The first line of each test case contains four integers a, b, x, y (1 ≤ a, b, -x, y ≤ 100), indicate that the slope will pass through the point(-a, b), the initial position of the ball is (x, y).</p><h3 id="Output"><a href="#Output" class="headerlink" title="Output"></a>Output</h3><p>Output the answer.</p><p>It’s guarantee that the answer will not exceed 50.</p><h3 id="Sample-Input"><a href="#Sample-Input" class="headerlink" title="Sample Input"></a>Sample Input</h3><pre><code>15 1 -5 3</code></pre><h3 id="Sample-Output"><a href="#Sample-Output" class="headerlink" title="Sample Output"></a>Sample Output</h3><pre><code>2</code></pre><h3 id="Source"><a href="#Source" class="headerlink" title="Source"></a>Source</h3><p>2018 Multi-University Training Contest 6</p><h3 id="Recommend"><a href="#Recommend" class="headerlink" title="Recommend"></a>Recommend</h3><p>chendu</p><h1 id="题目大意"><a href="#题目大意" class="headerlink" title="题目大意"></a>题目大意</h1><ul><li>给定一个从原点向一个方向延长的斜板，以及初始小球的坐标，重力加速度。求能在斜板上弹跳几次（不考虑能量损失）</li></ul><h1 id="解题思路"><a href="#解题思路" class="headerlink" title="解题思路"></a>解题思路</h1><ul><li>物理题，把运动分解成沿板方向和垂直于板的方向的分运动，求出沿板子运动的时间$t1$，垂直于板子运动的（每一次上升/下降）的时间$t2$。</li><li>考虑一下，当$(2<em>n+1)</em>t2 \lebs t1 &lt; (2<em>(n+1)+1)</em>t2 $ 时，n即为答案</li></ul><h1 id="解题代码"><a href="#解题代码" class="headerlink" title="解题代码"></a>解题代码</h1><pre><code class="hljs C++"><span class="hljs-meta">#<span class="hljs-meta-keyword">include</span> <span class="hljs-meta-string">&lt;bits/stdc++.h&gt;</span></span><span class="hljs-meta">#<span class="hljs-meta-keyword">include</span> <span class="hljs-meta-string">&lt;cstdio&gt;</span></span><span class="hljs-meta">#<span class="hljs-meta-keyword">include</span> <span class="hljs-meta-string">&lt;cmath&gt;</span></span><span class="hljs-meta">#<span class="hljs-meta-keyword">include</span> <span class="hljs-meta-string">&lt;cstdlib&gt;</span></span><span class="hljs-meta">#<span class="hljs-meta-keyword">include</span> <span class="hljs-meta-string">&lt;cstring&gt;</span></span><span class="hljs-meta">#<span class="hljs-meta-keyword">include</span> <span class="hljs-meta-string">&lt;iostream&gt;</span></span><span class="hljs-meta">#<span class="hljs-meta-keyword">include</span> <span class="hljs-meta-string">&lt;set&gt;</span></span><span class="hljs-meta">#<span class="hljs-meta-keyword">include</span> <span class="hljs-meta-string">&lt;iomanip&gt;</span></span><span class="hljs-meta">#<span class="hljs-meta-keyword">include</span> <span class="hljs-meta-string">&lt;algorithm&gt;</span></span><span class="hljs-meta">#<span class="hljs-meta-keyword">include</span> <span class="hljs-meta-string">&lt;queue&gt;</span></span><span class="hljs-meta">#<span class="hljs-meta-keyword">include</span> <span class="hljs-meta-string">&lt;map&gt;</span></span><span class="hljs-meta">#<span class="hljs-meta-keyword">include</span> <span class="hljs-meta-string">&lt;string&gt;</span></span><span class="hljs-meta">#<span class="hljs-meta-keyword">define</span> INF 0x3f3f3f3f</span><span class="hljs-meta">#<span class="hljs-meta-keyword">define</span> rep(i,a,n) for(int i=a;i&lt;n;i++)</span><span class="hljs-meta">#<span class="hljs-meta-keyword">define</span> per(i,a,n) for(int i=n-1;i&gt;=a;i--)</span><span class="hljs-meta">#<span class="hljs-meta-keyword">define</span> ms(x,a) memset((x),(a),sizeof(a))</span><span class="hljs-keyword">using</span> <span class="hljs-keyword">namespace</span> <span class="hljs-built_in">std</span>;<span class="hljs-keyword">const</span> <span class="hljs-keyword">int</span> maxn=<span class="hljs-number">1e5</span>+<span class="hljs-number">5</span>;<span class="hljs-keyword">int</span> n,m,t;<span class="hljs-keyword">double</span> a,b,x,y;<span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">solve</span><span class="hljs-params">()</span></span>&#123;<span class="hljs-keyword">double</span> alfa=<span class="hljs-built_in">atan</span>(b/a);<span class="hljs-keyword">double</span> y1=(y-x*<span class="hljs-built_in">tan</span>(alfa))*<span class="hljs-built_in">cos</span>(alfa);<span class="hljs-keyword">double</span> x1=y*<span class="hljs-built_in">sin</span>(alfa)+x*<span class="hljs-built_in">cos</span>(alfa);<span class="hljs-comment">//cout&lt;&lt;y1&lt;&lt;"  "&lt;&lt;x1&lt;&lt;endl; </span><span class="hljs-keyword">int</span> n=<span class="hljs-built_in">floor</span>(<span class="hljs-built_in">sqrt</span>(x1/y1*a/b));<span class="hljs-built_in">cout</span>&lt;&lt;(n+<span class="hljs-number">1</span>)/<span class="hljs-number">2</span>&lt;&lt;<span class="hljs-built_in">endl</span>;&#125;<span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span>&#123;ios::sync_with_stdio(<span class="hljs-literal">false</span>);<span class="hljs-built_in">cin</span>&gt;&gt;t;<span class="hljs-keyword">while</span>(t--)&#123;<span class="hljs-built_in">cin</span>&gt;&gt;a&gt;&gt;b&gt;&gt;x&gt;&gt;y;x=-x;solve();&#125;&#125;</code></pre><h1 id="收获与反思"><a href="#收获与反思" class="headerlink" title="收获与反思"></a>收获与反思</h1><ul><li>分运动看时间比判断，队友想出来的= =。</li></ul>]]></content>
    
    
    <categories>
      
      <category>Computer Science</category>
      
      <category>ACM</category>
      
      <category>HDU</category>
      
    </categories>
    
    
    <tags>
      
      <tag>ACM</tag>
      
      <tag>HDU</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>【HDU-6362】解题报告（数学，积分，2018杭电多校第六场）</title>
    <link href="/post/b3ee770c.html"/>
    <url>/post/b3ee770c.html</url>
    
    <content type="html"><![CDATA[<h1 id="原始题目"><a href="#原始题目" class="headerlink" title="原始题目"></a>原始题目</h1><h2 id="oval-and-rectangle"><a href="#oval-and-rectangle" class="headerlink" title="oval-and-rectangle"></a>oval-and-rectangle</h2><ul><li>Time Limit: 2000/1000 MS (Java/Others)    </li><li>Memory Limit: 32768/32768 K (Java/Others)</li><li>Total Submission(s): 647    </li><li>Accepted Submission(s): 310</li></ul><h3 id="Problem-Description"><a href="#Problem-Description" class="headerlink" title="Problem Description"></a>Problem Description</h3><p>Patrick Star find an oval.</p><p>The half of longer axes is on the x-axis with length $a$.</p><p>The half of shorter axes is on the y-axis with length $b$.</p><p>Patrick Star plan to choose a real number c randomly from $[0,b]$, after that, Patrick Star will get a rectangle :</p><ol><li><p>The four vertexes of it are on the outline of the oval.</p></li><li><p>The two sides of it parallel to coordinate axis.</p></li><li><p>One of its side is $y=c$.</p></li></ol><p>Patrick Star want to know the expectations of the rectangle’s perimeter.</p><a id="more"></a><h3 id="Input"><a href="#Input" class="headerlink" title="Input"></a>Input</h3><p>The first line contain a integer $T$ (no morn than 10), the following is $T$ test case, for each test case :</p><p>Each line contains contains two integer $a, b (0&lt;b&lt;a&lt;105)$. Separated by an white space.</p><h3 id="Output"><a href="#Output" class="headerlink" title="Output"></a>Output</h3><p>For each test case output one line denotes the expectations of the rectangle’s perimeter .</p><p>You should keep exactly 6 decimal digits and ignore the remain decimal digits. </p><p>It is guaranted that the 7-th decimal digit of answer wont be 0 or 9.</p><h3 id="Sample-Input"><a href="#Sample-Input" class="headerlink" title="Sample Input"></a>Sample Input</h3><pre><code>12 1</code></pre><h3 id="Sample-Output"><a href="#Sample-Output" class="headerlink" title="Sample Output"></a>Sample Output</h3><pre><code>8.283185</code></pre><h3 id="Source"><a href="#Source" class="headerlink" title="Source"></a>Source</h3><p>2018 Multi-University Training Contest 6</p><h3 id="Recommend"><a href="#Recommend" class="headerlink" title="Recommend"></a>Recommend</h3><p>chendu</p><h1 id="题目大意"><a href="#题目大意" class="headerlink" title="题目大意"></a>题目大意</h1><ul><li>椭圆半长轴为$a$，半短轴为$b$，从区间$[0,b]$随机抽实数$c$，求过$(0,c)$点的与椭圆内切，四边与坐标轴平行<br>的长方形周长</li></ul><h1 id="解题思路"><a href="#解题思路" class="headerlink" title="解题思路"></a>解题思路</h1><ul><li>是个积分题，不过直接用积分函数计算到制定精度会T（没错我就这么T了一发）</li><li>手动算一下<ul><li></li><li>最后除以b得到答案</li></ul></li><li>注意要求不四舍五入，精度应该输出$ans-0.0000005$</li></ul><h1 id="解题代码"><a href="#解题代码" class="headerlink" title="解题代码"></a>解题代码</h1><pre><code class="hljs C++"><span class="hljs-meta">#<span class="hljs-meta-keyword">include</span> <span class="hljs-meta-string">&lt;bits/stdc++.h&gt;</span></span><span class="hljs-meta">#<span class="hljs-meta-keyword">include</span> <span class="hljs-meta-string">&lt;cstdio&gt;</span></span><span class="hljs-meta">#<span class="hljs-meta-keyword">include</span> <span class="hljs-meta-string">&lt;cmath&gt;</span></span><span class="hljs-meta">#<span class="hljs-meta-keyword">include</span> <span class="hljs-meta-string">&lt;cstdlib&gt;</span></span><span class="hljs-meta">#<span class="hljs-meta-keyword">include</span> <span class="hljs-meta-string">&lt;cstring&gt;</span></span><span class="hljs-meta">#<span class="hljs-meta-keyword">include</span> <span class="hljs-meta-string">&lt;iostream&gt;</span></span><span class="hljs-meta">#<span class="hljs-meta-keyword">include</span> <span class="hljs-meta-string">&lt;set&gt;</span></span><span class="hljs-meta">#<span class="hljs-meta-keyword">include</span> <span class="hljs-meta-string">&lt;iomanip&gt;</span></span><span class="hljs-meta">#<span class="hljs-meta-keyword">include</span> <span class="hljs-meta-string">&lt;algorithm&gt;</span></span><span class="hljs-meta">#<span class="hljs-meta-keyword">include</span> <span class="hljs-meta-string">&lt;queue&gt;</span></span><span class="hljs-meta">#<span class="hljs-meta-keyword">include</span> <span class="hljs-meta-string">&lt;map&gt;</span></span><span class="hljs-meta">#<span class="hljs-meta-keyword">include</span> <span class="hljs-meta-string">&lt;string&gt;</span></span><span class="hljs-meta">#<span class="hljs-meta-keyword">define</span> INF 0x3f3f3f3f</span><span class="hljs-meta">#<span class="hljs-meta-keyword">define</span> rep(i,a,n) for(int i=a;i&lt;n;i++)</span><span class="hljs-meta">#<span class="hljs-meta-keyword">define</span> per(i,a,n) for(int i=n-1;i&gt;=a;i--)</span><span class="hljs-meta">#<span class="hljs-meta-keyword">define</span> ms(x,a) memset((x),(a),sizeof(a))</span><span class="hljs-keyword">using</span> <span class="hljs-keyword">namespace</span> <span class="hljs-built_in">std</span>;<span class="hljs-keyword">const</span> <span class="hljs-keyword">int</span> maxn=<span class="hljs-number">1e5</span>+<span class="hljs-number">5</span>;<span class="hljs-meta">#<span class="hljs-meta-keyword">define</span> PI acos(-1.0)</span><span class="hljs-keyword">int</span> n,m,t;<span class="hljs-keyword">int</span> a,b;<span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span>&#123;ios::sync_with_stdio(<span class="hljs-literal">false</span>);<span class="hljs-built_in">cin</span>&gt;&gt;t;<span class="hljs-keyword">while</span>(t--)&#123;<span class="hljs-built_in">cin</span>&gt;&gt;a&gt;&gt;b;<span class="hljs-keyword">double</span> ans=a*PI+<span class="hljs-number">2</span>*b;<span class="hljs-built_in">cout</span>&lt;&lt;fixed&lt;&lt;setprecision(<span class="hljs-number">6</span>)&lt;&lt;ans<span class="hljs-number">-0.0000005</span>&lt;&lt;<span class="hljs-built_in">endl</span>; &#125;&#125;</code></pre><h1 id="收获与反思"><a href="#收获与反思" class="headerlink" title="收获与反思"></a>收获与反思</h1><ul><li>高数教做人系列</li></ul>]]></content>
    
    
    <categories>
      
      <category>Computer Science</category>
      
      <category>ACM</category>
      
      <category>HDU</category>
      
    </categories>
    
    
    <tags>
      
      <tag>ACM</tag>
      
      <tag>HDU</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>【UVALive-3942】解题报告（字典树，dp）</title>
    <link href="/post/f279299a.html"/>
    <url>/post/f279299a.html</url>
    
    <content type="html"><![CDATA[<h1 id="原始题目"><a href="#原始题目" class="headerlink" title="原始题目"></a>原始题目</h1><a id="more"></a><h1 id="题目大意"><a href="#题目大意" class="headerlink" title="题目大意"></a>题目大意</h1><ul><li>给定一个文本串和n个字符串，用这n个字符串组合成文本串有多少种可能。</li></ul><h1 id="解题思路"><a href="#解题思路" class="headerlink" title="解题思路"></a>解题思路</h1><ul><li>先将n个字符串储存到字典树里。</li><li>考虑DP<ul><li>$dp[i]$表示前i位字符进行第一次分割的可能数目</li><li>i从len-1-&gt;0逆序遍历，j从i到len-1遍历。</li><li>只要遍历j时遇到染色结点，表明可以在此再分割一次，由此推出状态转移方程。$dp[i] = (dp[i] + dp[j + 1]) % mod$ </li></ul></li></ul><h1 id="解题代码"><a href="#解题代码" class="headerlink" title="解题代码"></a>解题代码</h1><pre><code class="hljs C++"><span class="hljs-meta">#<span class="hljs-meta-keyword">include</span> <span class="hljs-meta-string">&lt;cstdio&gt;</span></span><span class="hljs-meta">#<span class="hljs-meta-keyword">include</span> <span class="hljs-meta-string">&lt;cstring&gt;</span></span><span class="hljs-meta">#<span class="hljs-meta-keyword">include</span> <span class="hljs-meta-string">&lt;iostream&gt;</span></span><span class="hljs-meta">#<span class="hljs-meta-keyword">include</span> <span class="hljs-meta-string">&lt;cstdlib&gt;</span></span><span class="hljs-meta">#<span class="hljs-meta-keyword">include</span> <span class="hljs-meta-string">&lt;set&gt;</span></span><span class="hljs-meta">#<span class="hljs-meta-keyword">include</span> <span class="hljs-meta-string">&lt;string&gt;</span></span><span class="hljs-meta">#<span class="hljs-meta-keyword">include</span> <span class="hljs-meta-string">&lt;cstring&gt;</span></span><span class="hljs-meta">#<span class="hljs-meta-keyword">include</span> <span class="hljs-meta-string">&lt;stack&gt;</span></span><span class="hljs-meta">#<span class="hljs-meta-keyword">define</span> rep(i,a,n) for(int i=a;i&lt;n;i++)</span><span class="hljs-meta">#<span class="hljs-meta-keyword">define</span> per(i,a,n) for(int i=n-1;i&gt;=a;i--)</span><span class="hljs-meta">#<span class="hljs-meta-keyword">define</span> ms(x,a) memset((x),(a),sizeof(x))</span><span class="hljs-keyword">using</span> <span class="hljs-keyword">namespace</span> <span class="hljs-built_in">std</span>;<span class="hljs-keyword">const</span> <span class="hljs-keyword">int</span> maxn=<span class="hljs-number">3e5</span>+<span class="hljs-number">5</span>;<span class="hljs-keyword">const</span> <span class="hljs-keyword">int</span> maxl=<span class="hljs-number">26</span>;<span class="hljs-keyword">const</span> <span class="hljs-keyword">int</span> mod=<span class="hljs-number">20071027</span>;<span class="hljs-keyword">typedef</span> <span class="hljs-keyword">long</span> <span class="hljs-keyword">long</span> ll;<span class="hljs-keyword">typedef</span> <span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">Trie</span>&#123;</span><span class="hljs-keyword">int</span> v;Trie* next[maxl];&#125;Trie; Trie *root;<span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">iniTrie</span><span class="hljs-params">()</span></span>&#123;root=(Trie*)<span class="hljs-built_in">malloc</span>(<span class="hljs-keyword">sizeof</span>(Trie));<span class="hljs-keyword">for</span>(<span class="hljs-keyword">int</span> i=<span class="hljs-number">0</span>;i&lt;maxl;i++)root-&gt;next[i]=<span class="hljs-literal">NULL</span>;root-&gt;v=<span class="hljs-number">-1</span>;&#125;<span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">creTrie</span><span class="hljs-params">(<span class="hljs-keyword">char</span>* a)</span></span>&#123;<span class="hljs-keyword">int</span> l=<span class="hljs-built_in">strlen</span>(a);Trie *p=root,*q;<span class="hljs-keyword">for</span>(<span class="hljs-keyword">int</span> i=<span class="hljs-number">0</span>;i&lt;l;i++)&#123;<span class="hljs-keyword">int</span> id=a[i]-<span class="hljs-string">'a'</span>;<span class="hljs-comment">//并非前缀不能有相同，而是不能在相同的分支上。 </span><span class="hljs-keyword">if</span>(p-&gt;next[id]!=<span class="hljs-literal">NULL</span>) &#123;p=p-&gt;next[id];<span class="hljs-keyword">if</span>(i==l<span class="hljs-number">-1</span>)&#123;p-&gt;v=<span class="hljs-number">1</span>;<span class="hljs-keyword">return</span>;&#125;&#125;<span class="hljs-keyword">else</span>&#123;q=(Trie*)<span class="hljs-built_in">malloc</span>(<span class="hljs-keyword">sizeof</span>(Trie));q-&gt;v=<span class="hljs-number">0</span>;<span class="hljs-keyword">for</span>(<span class="hljs-keyword">int</span> j=<span class="hljs-number">0</span>;j&lt;maxl;j++) q-&gt;next[j]=<span class="hljs-literal">NULL</span>;p-&gt;next[id]=q;p=p-&gt;next[id];<span class="hljs-keyword">if</span>(i==l<span class="hljs-number">-1</span>)&#123;p-&gt;v=<span class="hljs-number">1</span>;<span class="hljs-keyword">return</span>;&#125;&#125;&#125;&#125;<span class="hljs-function"><span class="hljs-keyword">bool</span> <span class="hljs-title">findTrie</span><span class="hljs-params">(<span class="hljs-built_in">string</span> b)</span></span>&#123;Trie *p=root;<span class="hljs-keyword">int</span> l=b.length();<span class="hljs-keyword">for</span>(<span class="hljs-keyword">int</span> i=<span class="hljs-number">0</span>;i&lt;l;i++)&#123;<span class="hljs-keyword">int</span> index=b[i]-<span class="hljs-string">'a'</span>;<span class="hljs-keyword">if</span>(p-&gt;next[index]!=<span class="hljs-literal">NULL</span>)p=p-&gt;next[index];<span class="hljs-keyword">else</span> <span class="hljs-keyword">return</span> <span class="hljs-literal">false</span>;&#125;<span class="hljs-keyword">return</span> p-&gt;v;&#125;<span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">delTrie</span><span class="hljs-params">(Trie *p)</span>  </span>&#123;      <span class="hljs-keyword">int</span> i;      <span class="hljs-keyword">for</span>(i=<span class="hljs-number">0</span>;i&lt;maxl;i++)      &#123;          <span class="hljs-keyword">if</span>(p-&gt;next[i] != <span class="hljs-literal">NULL</span>)              delTrie(p-&gt;next[i]);      &#125;      <span class="hljs-built_in">free</span>(p);<span class="hljs-comment">//    printf("1");</span>p==<span class="hljs-literal">NULL</span>;  <span class="hljs-keyword">return</span> ;&#125;  <span class="hljs-keyword">int</span> n,kase;<span class="hljs-keyword">int</span> dp[maxn];<span class="hljs-keyword">char</span> raw[maxn],s[<span class="hljs-number">1000</span>];<span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">Dp</span><span class="hljs-params">(<span class="hljs-keyword">char</span> *s, <span class="hljs-keyword">int</span> len)</span> </span>&#123;        dp[len] = <span class="hljs-number">1</span>;        <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> i = len - <span class="hljs-number">1</span>; i &gt;= <span class="hljs-number">0</span>; --i) &#123;            Trie *pp = root;<span class="hljs-comment">//根节点</span>            <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> j = i; j &lt; len; ++j) &#123;                <span class="hljs-keyword">int</span> temp = s[j]-<span class="hljs-string">'a'</span>;                <span class="hljs-comment">//cout &lt;&lt; s[j] &lt;&lt; endl;</span>                <span class="hljs-keyword">if</span> (pp-&gt;next[temp] == <span class="hljs-literal">NULL</span>) &#123;<span class="hljs-comment">//同dfs退出原理</span>                    <span class="hljs-keyword">break</span>;                &#125;                pp = pp-&gt;next[temp];                <span class="hljs-keyword">if</span> (pp-&gt;v == <span class="hljs-literal">true</span>) &#123;                    dp[i] = (dp[i] + dp[j + <span class="hljs-number">1</span>]) % mod;<span class="hljs-comment">//更新方案数</span>                    <span class="hljs-comment">//cout &lt;&lt; j + 1 &lt;&lt; " " &lt;&lt; len &lt;&lt; endl;</span>                &#125;            &#125;            dp[i] %= mod;        &#125;        <span class="hljs-keyword">return</span> dp[<span class="hljs-number">0</span>];    &#125;<span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">solve</span><span class="hljs-params">()</span></span>&#123;<span class="hljs-keyword">int</span> ans=<span class="hljs-number">0</span>;<span class="hljs-keyword">int</span> len=<span class="hljs-built_in">strlen</span>(raw);ms(dp,<span class="hljs-number">0</span>);ans=Dp(raw,len);<span class="hljs-built_in">cout</span> &lt;&lt; <span class="hljs-string">"Case "</span> &lt;&lt; ++kase &lt;&lt; <span class="hljs-string">": "</span>;<span class="hljs-built_in">cout</span>&lt;&lt;ans&lt;&lt;<span class="hljs-built_in">endl</span>;&#125;<span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span>&#123;<span class="hljs-comment">//freopen("in.txt", "r", stdin);</span>ios::sync_with_stdio(<span class="hljs-literal">false</span>);<span class="hljs-keyword">while</span>(<span class="hljs-built_in">cin</span>&gt;&gt;raw)&#123;iniTrie();<span class="hljs-built_in">cin</span>&gt;&gt;n;rep(i,<span class="hljs-number">0</span>,n)&#123;<span class="hljs-built_in">cin</span>&gt;&gt;s;creTrie(s);&#125;solve();delTrie(root);&#125;&#125;</code></pre><h1 id="收获与反思"><a href="#收获与反思" class="headerlink" title="收获与反思"></a>收获与反思</h1><ul><li>字典树与dp结合</li><li>记忆化，dp的思想很重要！</li></ul>]]></content>
    
    
    <categories>
      
      <category>Computer Science</category>
      
      <category>ACM</category>
      
      <category>UVA</category>
      
    </categories>
    
    
    <tags>
      
      <tag>ACM</tag>
      
      <tag>UVA</tag>
      
      <tag>补图</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>【CSU-1216】解题报告（01字典树，异或最大值）</title>
    <link href="/post/16fa37a4.html"/>
    <url>/post/16fa37a4.html</url>
    
    <content type="html"><![CDATA[<h1 id="原始题目"><a href="#原始题目" class="headerlink" title="原始题目"></a>原始题目</h1><h2 id="1216-异或最大值"><a href="#1216-异或最大值" class="headerlink" title="1216: 异或最大值"></a>1216: 异或最大值</h2><ul><li>Time Limit: 2 Sec     </li><li>Memory Limit: 128 Mb     </li><li>Submitted: 1282     </li><li>Solved: 460    </li></ul><h3 id="Description"><a href="#Description" class="headerlink" title="Description"></a>Description</h3><p>给定一些数，求这些数中两个数的异或值最大的那个值<br><a id="more"></a></p><h3 id="Input"><a href="#Input" class="headerlink" title="Input"></a>Input</h3><p>多组数据。第一行为数字个数$n (1 \le n \le 10 ^ 5)$。接下来$n$行每行一个32位有符号非负整数。</p><h3 id="Output"><a href="#Output" class="headerlink" title="Output"></a>Output</h3><p>任意两数最大异或值</p><h3 id="Sample-Input"><a href="#Sample-Input" class="headerlink" title="Sample Input"></a>Sample Input</h3><pre><code>3379</code></pre><h3 id="Sample-Output"><a href="#Sample-Output" class="headerlink" title="Sample Output"></a>Sample Output</h3><pre><code>14</code></pre><h3 id="Hint"><a href="#Hint" class="headerlink" title="Hint"></a>Hint</h3><h3 id="Source"><a href="#Source" class="headerlink" title="Source"></a>Source</h3><p>CSGrandeur的数据结构习题</p><h1 id="题目大意"><a href="#题目大意" class="headerlink" title="题目大意"></a>题目大意</h1><p>如题</p><h1 id="解题思路"><a href="#解题思路" class="headerlink" title="解题思路"></a>解题思路</h1><ul><li>和HDU-4825都是求异或最大值，裸的01字典树</li><li>正解：<ul><li>每个数用二进制数表示，用32位的0、1数组（高位在前）储存到01字典树中。</li><li>对于每次询问q，将q也表示成01串，从高位到低位每次贪心的顺着字典树向下找相反的结点（0找1，1找0），<br>因为这样可以保证让两个数的异或值尽可能地大（所以一定要从高位向下找）。</li></ul></li></ul><h1 id="解题代码"><a href="#解题代码" class="headerlink" title="解题代码"></a>解题代码</h1><pre><code class="hljs C++"><span class="hljs-meta">#<span class="hljs-meta-keyword">include</span> <span class="hljs-meta-string">&lt;cstdio&gt;</span></span><span class="hljs-meta">#<span class="hljs-meta-keyword">include</span> <span class="hljs-meta-string">&lt;cstring&gt;</span></span><span class="hljs-meta">#<span class="hljs-meta-keyword">include</span> <span class="hljs-meta-string">&lt;iostream&gt;</span></span><span class="hljs-meta">#<span class="hljs-meta-keyword">include</span> <span class="hljs-meta-string">&lt;cstdlib&gt;</span></span><span class="hljs-meta">#<span class="hljs-meta-keyword">include</span> <span class="hljs-meta-string">&lt;set&gt;</span></span><span class="hljs-meta">#<span class="hljs-meta-keyword">include</span> <span class="hljs-meta-string">&lt;string&gt;</span></span><span class="hljs-meta">#<span class="hljs-meta-keyword">include</span> <span class="hljs-meta-string">&lt;cstring&gt;</span></span><span class="hljs-meta">#<span class="hljs-meta-keyword">include</span> <span class="hljs-meta-string">&lt;stack&gt;</span></span><span class="hljs-meta">#<span class="hljs-meta-keyword">define</span> rep(i,a,n) for(int i=a;i&lt;n;i++)</span><span class="hljs-meta">#<span class="hljs-meta-keyword">define</span> per(i,a,n) for(int i=n-1;i&gt;=a;i--)</span><span class="hljs-meta">#<span class="hljs-meta-keyword">define</span> ms(x,a) memset((x),(a),sizeof(a))</span><span class="hljs-meta">#<span class="hljs-meta-keyword">define</span> L 32</span><span class="hljs-keyword">using</span> <span class="hljs-keyword">namespace</span> <span class="hljs-built_in">std</span>;<span class="hljs-keyword">const</span> <span class="hljs-keyword">int</span> maxn=<span class="hljs-number">1e5</span>+<span class="hljs-number">5</span>;<span class="hljs-keyword">const</span> <span class="hljs-keyword">int</span> maxl=<span class="hljs-number">2</span>;<span class="hljs-keyword">typedef</span> <span class="hljs-keyword">long</span> <span class="hljs-keyword">long</span> ll;<span class="hljs-keyword">typedef</span> <span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">Trie</span>&#123;</span><span class="hljs-keyword">int</span> v;Trie* next[maxl];&#125;Trie; Trie *root;<span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">iniTrie</span><span class="hljs-params">()</span></span>&#123;root=(Trie*)<span class="hljs-built_in">malloc</span>(<span class="hljs-keyword">sizeof</span>(Trie));<span class="hljs-keyword">for</span>(<span class="hljs-keyword">int</span> i=<span class="hljs-number">0</span>;i&lt;maxl;i++)root-&gt;next[i]=<span class="hljs-literal">NULL</span>;root-&gt;v=<span class="hljs-number">-1</span>;&#125;<span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">creTrie</span><span class="hljs-params">(<span class="hljs-keyword">int</span> a)</span></span>&#123;<span class="hljs-keyword">int</span> temp[<span class="hljs-number">35</span>];<span class="hljs-keyword">int</span> id=L<span class="hljs-number">-1</span>;<span class="hljs-keyword">while</span>(a)&#123;temp[id--]=(a&amp;<span class="hljs-number">1</span>);a/=<span class="hljs-number">2</span>;&#125;rep(i,<span class="hljs-number">0</span>,id+<span class="hljs-number">1</span>) temp[i]=<span class="hljs-number">0</span>;<span class="hljs-comment">//rep(i,0,L) cout&lt;&lt;temp[i];</span><span class="hljs-comment">//cout&lt;&lt;endl&lt;&lt;endl;</span><span class="hljs-keyword">int</span> l=L;Trie *p=root,*q;<span class="hljs-keyword">for</span>(<span class="hljs-keyword">int</span> i=<span class="hljs-number">0</span>;i&lt;l;i++)&#123;<span class="hljs-keyword">int</span> id=temp[i];<span class="hljs-comment">//并非前缀不能有相同，而是不能在相同的分支上。 </span><span class="hljs-keyword">if</span>(p-&gt;next[id]!=<span class="hljs-literal">NULL</span>) &#123;p=p-&gt;next[id];<span class="hljs-comment">//p-&gt;v++;</span>&#125;<span class="hljs-keyword">else</span>&#123;q=(Trie*)<span class="hljs-built_in">malloc</span>(<span class="hljs-keyword">sizeof</span>(Trie));q-&gt;v=<span class="hljs-number">1</span>;<span class="hljs-keyword">for</span>(<span class="hljs-keyword">int</span> j=<span class="hljs-number">0</span>;j&lt;maxl;j++) q-&gt;next[j]=<span class="hljs-literal">NULL</span>;p-&gt;next[id]=q;p=p-&gt;next[id];&#125;&#125;&#125;<span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">findTrie</span><span class="hljs-params">(<span class="hljs-keyword">int</span> a)</span></span>&#123;<span class="hljs-keyword">int</span> aa=a;<span class="hljs-keyword">int</span> temp[<span class="hljs-number">35</span>];<span class="hljs-keyword">int</span> id=L<span class="hljs-number">-1</span>;<span class="hljs-keyword">while</span>(a)&#123;temp[id--]=(a&amp;<span class="hljs-number">1</span>);a/=<span class="hljs-number">2</span>;&#125;<span class="hljs-comment">//cout&lt;&lt;"#"&lt;&lt;a&lt;&lt;endl;</span>rep(i,<span class="hljs-number">0</span>,id+<span class="hljs-number">1</span>) temp[i]=<span class="hljs-number">0</span>;<span class="hljs-keyword">int</span> aans=<span class="hljs-number">0</span>;Trie *p=root;<span class="hljs-keyword">int</span> l=L;<span class="hljs-keyword">for</span>(<span class="hljs-keyword">int</span> i=<span class="hljs-number">0</span>;i&lt;l;i++)&#123;<span class="hljs-keyword">int</span> index=!temp[i];<span class="hljs-comment">//cout&lt;&lt;"index="&lt;&lt;index&lt;&lt;endl;</span><span class="hljs-keyword">if</span>(p-&gt;next[index]!=<span class="hljs-literal">NULL</span>)&#123;aans=(aans&lt;&lt;<span class="hljs-number">1</span>)+index;p=p-&gt;next[index];&#125;<span class="hljs-keyword">else</span>&#123;aans=(aans&lt;&lt;<span class="hljs-number">1</span>)+temp[i];p=p-&gt;next[temp[i]];&#125;&#125;<span class="hljs-keyword">return</span> aans^aa;&#125;<span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">delTrie</span><span class="hljs-params">(Trie *p)</span>  </span>&#123;      <span class="hljs-keyword">int</span> i;      <span class="hljs-keyword">for</span>(i=<span class="hljs-number">0</span>;i&lt;maxl;i++)      &#123;          <span class="hljs-keyword">if</span>(p-&gt;next[i] != <span class="hljs-literal">NULL</span>)              delTrie(p-&gt;next[i]);      &#125;      <span class="hljs-built_in">free</span>(p);<span class="hljs-comment">//    printf("1");</span>p==<span class="hljs-literal">NULL</span>;  <span class="hljs-keyword">return</span> ;&#125;  <span class="hljs-keyword">int</span> a[maxn],n;<span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span>&#123;ios::sync_with_stdio(<span class="hljs-literal">false</span>);<span class="hljs-keyword">while</span>(<span class="hljs-built_in">cin</span>&gt;&gt;n)&#123;iniTrie();rep(i,<span class="hljs-number">0</span>,n)&#123;<span class="hljs-built_in">cin</span>&gt;&gt;a[i];creTrie(a[i]);&#125;<span class="hljs-keyword">int</span> fans=<span class="hljs-number">0</span>;rep(i,<span class="hljs-number">0</span>,n)&#123;fans=max(fans,findTrie(a[i]));&#125;<span class="hljs-built_in">cout</span>&lt;&lt;fans&lt;&lt;<span class="hljs-built_in">endl</span>;delTrie(root); &#125;&#125;</code></pre><h1 id="收获与反思"><a href="#收获与反思" class="headerlink" title="收获与反思"></a>收获与反思</h1><ul><li>异或最大值可以考虑01字典树。</li></ul>]]></content>
    
    
    <categories>
      
      <category>Computer Science</category>
      
      <category>ACM</category>
      
      <category>CSU</category>
      
    </categories>
    
    
    <tags>
      
      <tag>ACM</tag>
      
      <tag>CSU</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>【HDU-4825】解题报告（01字典树，异或最大值）</title>
    <link href="/post/6d52b9f2.html"/>
    <url>/post/6d52b9f2.html</url>
    
    <content type="html"><![CDATA[<h1 id="原始题目"><a href="#原始题目" class="headerlink" title="原始题目"></a>原始题目</h1><h2 id="Xor-Sum"><a href="#Xor-Sum" class="headerlink" title="Xor Sum"></a>Xor Sum</h2><ul><li>Time Limit: 2000/1000 MS (Java/Others)    </li><li>Memory Limit: 132768/132768 K (Java/Others)</li><li>Total Submission(s): 4756    </li><li>Accepted Submission(s): 2076</li></ul><h3 id="Problem-Description"><a href="#Problem-Description" class="headerlink" title="Problem Description"></a>Problem Description</h3><p>Zeus 和 Prometheus 做了一个游戏，Prometheus 给 Zeus 一个集合，集合中包含了$N$个正整数，随后 Prometheus 将向 Zeus 发起$M$次询问，每次询问中包含一个正整数 $S$ ，之后 Zeus 需要在集合当中找出一个正整数 $K$ ，使得 $K$ 与 $S$ 的异或结果最大。Prometheus 为了让 Zeus 看到人类的伟大，随即同意 Zeus 可以向人类求助。你能证明人类的智慧么？<br> <a id="more"></a></p><h3 id="Input"><a href="#Input" class="headerlink" title="Input"></a>Input</h3><p>输入包含若干组测试数据，每组测试数据包含若干行。</p><p>输入的第一行是一个整数$ T(T &lt; 10)$，表示共有$T$组数据。</p><p>每组数据的第一行输入两个正整数$N,M( 1 &lt;\le N,M \le 100000)$，接下来一行，包含$N$个正整数，代表 Zeus 的获得的集合，之后$M$行，每行一个正整数$S$，代表 Prometheus 询问的正整数。所有正整数均不超过$2^{32}$。</p><h3 id="Output"><a href="#Output" class="headerlink" title="Output"></a>Output</h3><p>对于每组数据，首先需要输出单独一行”Case #?:”，其中问号处应填入当前的数据组数，组数从1开始计算。</p><p>对于每个询问，输出一个正整数K，使得K与S异或值最大。</p><h3 id="Sample-Input"><a href="#Sample-Input" class="headerlink" title="Sample Input"></a>Sample Input</h3><pre><code>23 23 4 5154 14 6 5 63</code></pre><h3 id="Sample-Output"><a href="#Sample-Output" class="headerlink" title="Sample Output"></a>Sample Output</h3><pre><code>Case #1:43Case #2:4</code></pre><h3 id="Source"><a href="#Source" class="headerlink" title="Source"></a>Source</h3><p>2014年百度之星程序设计大赛 - 资格赛</p><h3 id="Recommend"><a href="#Recommend" class="headerlink" title="Recommend"></a>Recommend</h3><p>liuyiding</p><h1 id="题目大意"><a href="#题目大意" class="headerlink" title="题目大意"></a>题目大意</h1><p>如题</p><h1 id="解题思路"><a href="#解题思路" class="headerlink" title="解题思路"></a>解题思路</h1><ul><li>直接找的话复杂度O（m*n），会T（本题显然不可能这么简单啊）</li><li>正解：<ul><li>每个数用二进制数表示，用32位的0、1数组（高位在前）储存到01字典树中。</li><li>对于每次询问q，将q也表示成01串，从高位到低位每次贪心的顺着字典树向下找相反的结点（0找1，1找0），<br>因为这样可以保证让两个数的异或值尽可能地大（所以一定要从高位向下找）。</li></ul></li></ul><h1 id="解题代码"><a href="#解题代码" class="headerlink" title="解题代码"></a>解题代码</h1><pre><code class="hljs C++"><span class="hljs-meta">#<span class="hljs-meta-keyword">include</span> <span class="hljs-meta-string">&lt;cstdio&gt;</span></span><span class="hljs-meta">#<span class="hljs-meta-keyword">include</span> <span class="hljs-meta-string">&lt;cstring&gt;</span></span><span class="hljs-meta">#<span class="hljs-meta-keyword">include</span> <span class="hljs-meta-string">&lt;iostream&gt;</span></span><span class="hljs-meta">#<span class="hljs-meta-keyword">include</span> <span class="hljs-meta-string">&lt;cstdlib&gt;</span></span><span class="hljs-meta">#<span class="hljs-meta-keyword">include</span> <span class="hljs-meta-string">&lt;set&gt;</span></span><span class="hljs-meta">#<span class="hljs-meta-keyword">include</span> <span class="hljs-meta-string">&lt;string&gt;</span></span><span class="hljs-meta">#<span class="hljs-meta-keyword">include</span> <span class="hljs-meta-string">&lt;cstring&gt;</span></span><span class="hljs-meta">#<span class="hljs-meta-keyword">include</span> <span class="hljs-meta-string">&lt;stack&gt;</span></span><span class="hljs-meta">#<span class="hljs-meta-keyword">define</span> rep(i,a,n) for(int i=a;i&lt;n;i++)</span><span class="hljs-meta">#<span class="hljs-meta-keyword">define</span> per(i,a,n) for(int i=n-1;i&gt;=a;i--)</span><span class="hljs-meta">#<span class="hljs-meta-keyword">define</span> ms(x,a) memset((x),(a),sizeof(a))</span><span class="hljs-meta">#<span class="hljs-meta-keyword">define</span> debugin freopen(<span class="hljs-meta-string">"in.txt"</span>,<span class="hljs-meta-string">"r"</span>,stdin)</span><span class="hljs-meta">#<span class="hljs-meta-keyword">define</span> debugout freopen(<span class="hljs-meta-string">"out.txt"</span>,<span class="hljs-meta-string">"w"</span>,stdout)</span><span class="hljs-meta">#<span class="hljs-meta-keyword">define</span> L 32</span><span class="hljs-keyword">using</span> <span class="hljs-keyword">namespace</span> <span class="hljs-built_in">std</span>;<span class="hljs-keyword">const</span> <span class="hljs-keyword">int</span> maxn=<span class="hljs-number">1e5</span>+<span class="hljs-number">5</span>;<span class="hljs-keyword">const</span> <span class="hljs-keyword">int</span> maxl=<span class="hljs-number">2</span>;<span class="hljs-keyword">typedef</span> <span class="hljs-keyword">long</span> <span class="hljs-keyword">long</span> ll;<span class="hljs-keyword">typedef</span> <span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">Trie</span>&#123;</span><span class="hljs-keyword">int</span> v;Trie* next[maxl];&#125;Trie; Trie *root;<span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">iniTrie</span><span class="hljs-params">()</span></span>&#123;root=(Trie*)<span class="hljs-built_in">malloc</span>(<span class="hljs-keyword">sizeof</span>(Trie));<span class="hljs-keyword">for</span>(<span class="hljs-keyword">int</span> i=<span class="hljs-number">0</span>;i&lt;maxl;i++)root-&gt;next[i]=<span class="hljs-literal">NULL</span>;root-&gt;v=<span class="hljs-number">-1</span>;&#125;<span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">creTrie</span><span class="hljs-params">(<span class="hljs-keyword">int</span> a)</span></span>&#123;<span class="hljs-keyword">int</span> temp[<span class="hljs-number">35</span>];<span class="hljs-keyword">int</span> id=L<span class="hljs-number">-1</span>;<span class="hljs-keyword">while</span>(a)&#123;temp[id--]=(a&amp;<span class="hljs-number">1</span>);a/=<span class="hljs-number">2</span>;&#125;rep(i,<span class="hljs-number">0</span>,id+<span class="hljs-number">1</span>) temp[i]=<span class="hljs-number">0</span>;<span class="hljs-comment">//rep(i,0,L) cout&lt;&lt;temp[i];</span><span class="hljs-comment">//cout&lt;&lt;endl&lt;&lt;endl;</span><span class="hljs-keyword">int</span> l=L;Trie *p=root,*q;<span class="hljs-keyword">for</span>(<span class="hljs-keyword">int</span> i=<span class="hljs-number">0</span>;i&lt;l;i++)&#123;<span class="hljs-keyword">int</span> id=temp[i];<span class="hljs-comment">//并非前缀不能有相同，而是不能在相同的分支上。 </span><span class="hljs-keyword">if</span>(p-&gt;next[id]!=<span class="hljs-literal">NULL</span>) &#123;p=p-&gt;next[id];<span class="hljs-comment">//p-&gt;v++;</span>&#125;<span class="hljs-keyword">else</span>&#123;q=(Trie*)<span class="hljs-built_in">malloc</span>(<span class="hljs-keyword">sizeof</span>(Trie));q-&gt;v=<span class="hljs-number">1</span>;<span class="hljs-keyword">for</span>(<span class="hljs-keyword">int</span> j=<span class="hljs-number">0</span>;j&lt;maxl;j++) q-&gt;next[j]=<span class="hljs-literal">NULL</span>;p-&gt;next[id]=q;p=p-&gt;next[id];&#125;&#125;&#125;<span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">findTrie</span><span class="hljs-params">(<span class="hljs-keyword">int</span> a)</span></span>&#123;<span class="hljs-comment">//int aa=a;</span><span class="hljs-keyword">int</span> temp[<span class="hljs-number">35</span>];<span class="hljs-keyword">int</span> id=L<span class="hljs-number">-1</span>;<span class="hljs-keyword">while</span>(a)&#123;temp[id--]=(a&amp;<span class="hljs-number">1</span>);a/=<span class="hljs-number">2</span>;&#125;<span class="hljs-comment">//cout&lt;&lt;"#"&lt;&lt;a&lt;&lt;endl;</span>rep(i,<span class="hljs-number">0</span>,id+<span class="hljs-number">1</span>) temp[i]=<span class="hljs-number">0</span>;<span class="hljs-keyword">int</span> aans=<span class="hljs-number">0</span>;Trie *p=root;<span class="hljs-keyword">int</span> l=L;<span class="hljs-keyword">for</span>(<span class="hljs-keyword">int</span> i=<span class="hljs-number">0</span>;i&lt;l;i++)&#123;<span class="hljs-keyword">int</span> index=!temp[i];<span class="hljs-comment">//cout&lt;&lt;"index="&lt;&lt;index&lt;&lt;endl;</span><span class="hljs-keyword">if</span>(p-&gt;next[index]!=<span class="hljs-literal">NULL</span>)&#123;aans=(aans&lt;&lt;<span class="hljs-number">1</span>)+index;p=p-&gt;next[index];&#125;<span class="hljs-keyword">else</span>&#123;aans=(aans&lt;&lt;<span class="hljs-number">1</span>)+temp[i];p=p-&gt;next[temp[i]];&#125;&#125;<span class="hljs-keyword">return</span> aans; &#125;<span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">delTrie</span><span class="hljs-params">(Trie *p)</span>  </span>&#123;      <span class="hljs-keyword">int</span> i;      <span class="hljs-keyword">for</span>(i=<span class="hljs-number">0</span>;i&lt;maxl;i++)      &#123;          <span class="hljs-keyword">if</span>(p-&gt;next[i] != <span class="hljs-literal">NULL</span>)              delTrie(p-&gt;next[i]);      &#125;      <span class="hljs-built_in">free</span>(p);<span class="hljs-comment">//    printf("1");</span>p==<span class="hljs-literal">NULL</span>;  <span class="hljs-keyword">return</span> ;&#125;  <span class="hljs-keyword">int</span> a[maxn],n,t,m;<span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span>&#123;ios::sync_with_stdio(<span class="hljs-literal">false</span>);<span class="hljs-comment">//debugin;</span><span class="hljs-comment">//debugout;</span><span class="hljs-built_in">cin</span>&gt;&gt;t;rep(l,<span class="hljs-number">1</span>,t+<span class="hljs-number">1</span>)&#123;<span class="hljs-built_in">cout</span>&lt;&lt;<span class="hljs-string">"Case #"</span>&lt;&lt;l&lt;&lt;<span class="hljs-string">":"</span>&lt;&lt;<span class="hljs-built_in">endl</span>;<span class="hljs-built_in">cin</span>&gt;&gt;n&gt;&gt;m; <span class="hljs-comment">//n树m询问</span>iniTrie(); rep(i,<span class="hljs-number">0</span>,n)&#123;<span class="hljs-built_in">cin</span>&gt;&gt;a[i];creTrie(a[i]);&#125;rep(i,<span class="hljs-number">0</span>,m)&#123;<span class="hljs-built_in">cin</span>&gt;&gt;a[i];<span class="hljs-built_in">cout</span>&lt;&lt;findTrie(a[i])&lt;&lt;<span class="hljs-built_in">endl</span>;&#125;delTrie(root);&#125;&#125;</code></pre><h1 id="收获与反思"><a href="#收获与反思" class="headerlink" title="收获与反思"></a>收获与反思</h1><ul><li>异或最大值可以考虑01字典树。</li></ul>]]></content>
    
    
    <categories>
      
      <category>Computer Science</category>
      
      <category>ACM</category>
      
      <category>HDU</category>
      
    </categories>
    
    
    <tags>
      
      <tag>ACM</tag>
      
      <tag>HDU</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>【HDU-1251】解题报告（字典树）</title>
    <link href="/post/585293b8.html"/>
    <url>/post/585293b8.html</url>
    
    <content type="html"><![CDATA[<h1 id="原始题目"><a href="#原始题目" class="headerlink" title="原始题目"></a>原始题目</h1><h2 id="统计难题"><a href="#统计难题" class="headerlink" title="统计难题"></a>统计难题</h2><ul><li>Time Limit: 4000/2000 MS (Java/Others)    </li><li>Memory Limit: 131070/65535 K (Java/Others)</li><li>Total Submission(s): 55180    </li><li>Accepted Submission(s): 19275</li></ul><h3 id="Problem-Description"><a href="#Problem-Description" class="headerlink" title="Problem Description"></a>Problem Description</h3><p>Ignatius最近遇到一个难题,老师交给他很多单词(只有小写字母组成,不会有重复的单词出现),现在老师要他统计出以某个字符串为前缀的单词数量(单词本身也是自己的前缀).<br> <a id="more"></a></p><h3 id="Input"><a href="#Input" class="headerlink" title="Input"></a>Input</h3><p>输入数据的第一部分是一张单词表,每行一个单词,单词的长度不超过10,它们代表的是老师交给Ignatius统计的单词,一个空行代表单词表的结束.第二部分是一连串的提问,每行一个提问,每个提问都是一个字符串.</p><p>注意:本题只有一组测试数据,处理到文件结束.</p><h3 id="Output"><a href="#Output" class="headerlink" title="Output"></a>Output</h3><p>对于每个提问,给出以该字符串为前缀的单词的数量.</p><h3 id="Sample-Input"><a href="#Sample-Input" class="headerlink" title="Sample Input"></a>Sample Input</h3><pre><code>bananabandbeeabsoluteacmbabbandabc</code></pre><h3 id="Sample-Output"><a href="#Sample-Output" class="headerlink" title="Sample Output"></a>Sample Output</h3><pre><code>2310</code></pre><h3 id="Author"><a href="#Author" class="headerlink" title="Author"></a>Author</h3><p>Ignatius.L</p><h3 id="Recommend"><a href="#Recommend" class="headerlink" title="Recommend"></a>Recommend</h3><p>Ignatius.L</p><h1 id="题目大意"><a href="#题目大意" class="headerlink" title="题目大意"></a>题目大意</h1><p>如题</p><h1 id="解题思路"><a href="#解题思路" class="headerlink" title="解题思路"></a>解题思路</h1><ul><li>字典树裸题，建立字典树时每个单词每个结点权值++</li><li>访问的时候不在树上输出0，在的话输出结尾结点的权值。</li></ul><h1 id="解题代码"><a href="#解题代码" class="headerlink" title="解题代码"></a>解题代码</h1><pre><code class="hljs C++"><span class="hljs-meta">#<span class="hljs-meta-keyword">include</span> <span class="hljs-meta-string">&lt;cstdio&gt;</span></span><span class="hljs-meta">#<span class="hljs-meta-keyword">include</span> <span class="hljs-meta-string">&lt;cstring&gt;</span></span><span class="hljs-meta">#<span class="hljs-meta-keyword">include</span> <span class="hljs-meta-string">&lt;iostream&gt;</span></span><span class="hljs-meta">#<span class="hljs-meta-keyword">include</span> <span class="hljs-meta-string">&lt;cstdlib&gt;</span></span><span class="hljs-meta">#<span class="hljs-meta-keyword">include</span> <span class="hljs-meta-string">&lt;set&gt;</span></span><span class="hljs-meta">#<span class="hljs-meta-keyword">include</span> <span class="hljs-meta-string">&lt;string&gt;</span></span><span class="hljs-meta">#<span class="hljs-meta-keyword">include</span> <span class="hljs-meta-string">&lt;cstring&gt;</span></span><span class="hljs-meta">#<span class="hljs-meta-keyword">include</span> <span class="hljs-meta-string">&lt;stack&gt;</span></span><span class="hljs-keyword">using</span> <span class="hljs-keyword">namespace</span> <span class="hljs-built_in">std</span>;<span class="hljs-keyword">const</span> <span class="hljs-keyword">int</span> maxn=<span class="hljs-number">1e5</span>+<span class="hljs-number">5</span>;<span class="hljs-keyword">const</span> <span class="hljs-keyword">int</span> maxl=<span class="hljs-number">26</span>;<span class="hljs-keyword">typedef</span> <span class="hljs-keyword">long</span> <span class="hljs-keyword">long</span> ll;<span class="hljs-keyword">typedef</span> <span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">Trie</span>&#123;</span><span class="hljs-keyword">int</span> v;Trie* next[maxl];&#125;Trie; Trie *root;<span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">iniTrie</span><span class="hljs-params">()</span></span>&#123;root=(Trie*)<span class="hljs-built_in">malloc</span>(<span class="hljs-keyword">sizeof</span>(Trie));<span class="hljs-keyword">for</span>(<span class="hljs-keyword">int</span> i=<span class="hljs-number">0</span>;i&lt;maxl;i++)root-&gt;next[i]=<span class="hljs-literal">NULL</span>;root-&gt;v=<span class="hljs-number">-1</span>;&#125;<span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">creTrie</span><span class="hljs-params">(<span class="hljs-keyword">char</span>* a)</span></span>&#123;<span class="hljs-keyword">int</span> l=<span class="hljs-built_in">strlen</span>(a);Trie *p=root,*q;<span class="hljs-keyword">for</span>(<span class="hljs-keyword">int</span> i=<span class="hljs-number">0</span>;i&lt;l;i++)&#123;<span class="hljs-keyword">int</span> id=a[i]-<span class="hljs-string">'a'</span>;<span class="hljs-comment">//并非前缀不能有相同，而是不能在相同的分支上。 </span><span class="hljs-keyword">if</span>(p-&gt;next[id]!=<span class="hljs-literal">NULL</span>) &#123;p=p-&gt;next[id];p-&gt;v++;&#125;<span class="hljs-keyword">else</span>&#123;q=(Trie*)<span class="hljs-built_in">malloc</span>(<span class="hljs-keyword">sizeof</span>(Trie));q-&gt;v=<span class="hljs-number">1</span>;<span class="hljs-keyword">for</span>(<span class="hljs-keyword">int</span> j=<span class="hljs-number">0</span>;j&lt;maxl;j++) q-&gt;next[j]=<span class="hljs-literal">NULL</span>;p-&gt;next[id]=q;p=p-&gt;next[id];&#125;&#125;&#125;<span class="hljs-comment">//void printTrie()</span><span class="hljs-comment">//&#123;</span><span class="hljs-comment">//Trie* p=root;</span><span class="hljs-comment">//stack&lt;Trie*&gt;s;</span><span class="hljs-comment">//s.push(p);</span><span class="hljs-comment">//while(!s.empty())</span><span class="hljs-comment">//&#123;</span><span class="hljs-comment">//Trie *now=s.top();</span><span class="hljs-comment">//s.pop();</span><span class="hljs-comment">//if(now-&gt;v==1) printf("%d\n",now-&gt;v);</span><span class="hljs-comment">//for(int i=0;i&lt;maxl;i++)</span><span class="hljs-comment">//if(now-&gt;next[i]!=NULL)</span><span class="hljs-comment">//s.push(now-&gt;next[i]); </span><span class="hljs-comment">//&#125;</span><span class="hljs-comment">//&#125;</span><span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">printTrie</span><span class="hljs-params">(<span class="hljs-keyword">char</span>* b)</span></span>&#123;Trie *p=root;<span class="hljs-keyword">int</span> l=<span class="hljs-built_in">strlen</span>(b);<span class="hljs-keyword">for</span>(<span class="hljs-keyword">int</span> i=<span class="hljs-number">0</span>;i&lt;l;i++)&#123;<span class="hljs-keyword">int</span> index=b[i]-<span class="hljs-string">'a'</span>;<span class="hljs-keyword">if</span>(p-&gt;next[index]!=<span class="hljs-literal">NULL</span>)p=p-&gt;next[index];<span class="hljs-keyword">else</span>&#123;<span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;&#125;&#125;<span class="hljs-keyword">return</span> p-&gt;v;&#125;<span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">delTrie</span><span class="hljs-params">(Trie *p)</span>  </span>&#123;      <span class="hljs-keyword">int</span> i;      <span class="hljs-keyword">for</span>(i=<span class="hljs-number">0</span>;i&lt;maxl;i++)      &#123;          <span class="hljs-keyword">if</span>(p-&gt;next[i] != <span class="hljs-literal">NULL</span>)              delTrie(p-&gt;next[i]);      &#125;      <span class="hljs-built_in">free</span>(p);<span class="hljs-comment">//    printf("1");</span>p==<span class="hljs-literal">NULL</span>;  <span class="hljs-keyword">return</span> ;&#125;  <span class="hljs-keyword">int</span> t,ccount;<span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span>&#123;<span class="hljs-keyword">char</span> a[<span class="hljs-number">20</span>],c;iniTrie();<span class="hljs-keyword">while</span>(gets(a)&amp;&amp;a[<span class="hljs-number">0</span>]!=<span class="hljs-string">'\0'</span>)creTrie(a);<span class="hljs-keyword">while</span>(~<span class="hljs-built_in">scanf</span>(<span class="hljs-string">"%s"</span>,a))<span class="hljs-built_in">printf</span>(<span class="hljs-string">"%d\n"</span>,printTrie(a));delTrie(root);&#125;</code></pre><h1 id="收获与反思"><a href="#收获与反思" class="headerlink" title="收获与反思"></a>收获与反思</h1><ul><li>字典树裸题，注意建立的时候怎么打标记（染色）。</li></ul>]]></content>
    
    
    <categories>
      
      <category>Computer Science</category>
      
      <category>ACM</category>
      
      <category>HDU</category>
      
    </categories>
    
    
    <tags>
      
      <tag>ACM</tag>
      
      <tag>HDU</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>【POJ-1200】解题报告（字符串hash，进制）</title>
    <link href="/post/bc8586da.html"/>
    <url>/post/bc8586da.html</url>
    
    <content type="html"><![CDATA[<h1 id="原始题目"><a href="#原始题目" class="headerlink" title="原始题目"></a>原始题目</h1><h2 id="Crazy-Search"><a href="#Crazy-Search" class="headerlink" title="Crazy Search"></a>Crazy Search</h2><ul><li>Time Limit: 1000MS        </li><li>Memory Limit: 65536K</li><li>Total Submissions: 32268        </li><li>Accepted: 8900</li></ul><h3 id="Description"><a href="#Description" class="headerlink" title="Description"></a>Description</h3><p>Many people like to solve hard puzzles some of which may lead them to madness. One such puzzle could be finding a hidden prime number in a given text. Such number could be the number of different substrings of a given size that exist in the text. As you soon will discover, you really need the help of a computer and a good algorithm to solve such a puzzle. </p><p>Your task is to write a program that given the size, N, of the substring, the number of different characters that may occur in the text, NC, and the text itself, determines the number of different substrings of size N that appear in the text. </p><p>As an example, consider N=3, NC=4 and the text “daababac”. The different substrings of size 3 that can be found in this text are: “daa”; “aab”; “aba”; “bab”; “bac”. Therefore, the answer should be 5.<br><a id="more"></a></p><h3 id="Input"><a href="#Input" class="headerlink" title="Input"></a>Input</h3><p>The first line of input consists of two numbers, N and NC, separated by exactly one space. This is followed by the text where the search takes place. You may assume that the maximum number of substrings formed by the possible set of characters does not exceed 16 Millions.</p><h3 id="Output"><a href="#Output" class="headerlink" title="Output"></a>Output</h3><p>The program should output just an integer corresponding to the number of different substrings of size N found in the given text.</p><h3 id="Sample-Input"><a href="#Sample-Input" class="headerlink" title="Sample Input"></a>Sample Input</h3><pre><code>3 4daababac</code></pre><h3 id="Sample-Output"><a href="#Sample-Output" class="headerlink" title="Sample Output"></a>Sample Output</h3><pre><code>5</code></pre><h3 id="Hint"><a href="#Hint" class="headerlink" title="Hint"></a>Hint</h3><p>Huge input,scanf is recommended.</p><h3 id="Source"><a href="#Source" class="headerlink" title="Source"></a>Source</h3><p>Southwestern Europe 2002</p><h1 id="题目大意"><a href="#题目大意" class="headerlink" title="题目大意"></a>题目大意</h1><ul><li>最多由nc种字符构成的原字符串，求长度为n的子串共有多少种。<h1 id="解题思路"><a href="#解题思路" class="headerlink" title="解题思路"></a>解题思路</h1></li><li>字符串hash</li><li>由于最多不超过nc种字符，把每种字符映射到1到nc，字串即可看作类似nc进制的数（不含0）</li><li>用set或者vis数组维护一下记录不同数的个数即可。<h1 id="解题代码"><a href="#解题代码" class="headerlink" title="解题代码"></a>解题代码</h1><pre><code class="hljs C++"><span class="hljs-comment">//#include &lt;bits/stdc++.h&gt;</span><span class="hljs-meta">#<span class="hljs-meta-keyword">include</span> <span class="hljs-meta-string">&lt;cstdio&gt;</span></span><span class="hljs-meta">#<span class="hljs-meta-keyword">include</span> <span class="hljs-meta-string">&lt;cmath&gt;</span></span><span class="hljs-meta">#<span class="hljs-meta-keyword">include</span> <span class="hljs-meta-string">&lt;cstdlib&gt;</span></span><span class="hljs-meta">#<span class="hljs-meta-keyword">include</span> <span class="hljs-meta-string">&lt;cstring&gt;</span></span><span class="hljs-meta">#<span class="hljs-meta-keyword">include</span> <span class="hljs-meta-string">&lt;iostream&gt;</span></span><span class="hljs-meta">#<span class="hljs-meta-keyword">include</span> <span class="hljs-meta-string">&lt;set&gt;</span></span><span class="hljs-meta">#<span class="hljs-meta-keyword">include</span> <span class="hljs-meta-string">&lt;iomanip&gt;</span></span><span class="hljs-meta">#<span class="hljs-meta-keyword">include</span> <span class="hljs-meta-string">&lt;algorithm&gt;</span></span><span class="hljs-meta">#<span class="hljs-meta-keyword">include</span> <span class="hljs-meta-string">&lt;queue&gt;</span></span><span class="hljs-meta">#<span class="hljs-meta-keyword">include</span> <span class="hljs-meta-string">&lt;map&gt;</span></span><span class="hljs-meta">#<span class="hljs-meta-keyword">include</span> <span class="hljs-meta-string">&lt;string&gt;</span></span><span class="hljs-meta">#<span class="hljs-meta-keyword">define</span> INF 0x3f3f3f3f</span><span class="hljs-meta">#<span class="hljs-meta-keyword">define</span> rep(i,a,n) for(int i=a;i&lt;n;i++)</span><span class="hljs-meta">#<span class="hljs-meta-keyword">define</span> per(i,a,n) for(int i=n-1;i&gt;=a;i--)</span><span class="hljs-meta">#<span class="hljs-meta-keyword">define</span> ms(x,a) memset((x),(a),sizeof(a))</span><span class="hljs-keyword">using</span> <span class="hljs-keyword">namespace</span> <span class="hljs-built_in">std</span>;<span class="hljs-keyword">const</span> <span class="hljs-keyword">int</span> maxn=<span class="hljs-number">1e5</span>+<span class="hljs-number">5</span>;<span class="hljs-meta">#<span class="hljs-meta-keyword">define</span> PI acos(-1.0)</span><span class="hljs-keyword">typedef</span> <span class="hljs-keyword">long</span> <span class="hljs-keyword">long</span> ll;<span class="hljs-keyword">typedef</span> <span class="hljs-keyword">unsigned</span> <span class="hljs-keyword">long</span> <span class="hljs-keyword">long</span> ull;<span class="hljs-keyword">int</span> letter[<span class="hljs-number">300</span>];<span class="hljs-keyword">char</span> s[<span class="hljs-number">1000005</span>];<span class="hljs-keyword">bool</span> myhash[<span class="hljs-number">20000005</span>];<span class="hljs-keyword">int</span> n,nc;<span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span>&#123;ios::sync_with_stdio(<span class="hljs-literal">false</span>);<span class="hljs-keyword">while</span>(<span class="hljs-built_in">cin</span>&gt;&gt;n&gt;&gt;nc&gt;&gt;s)&#123;<span class="hljs-built_in">memset</span>(letter,<span class="hljs-number">0</span>,<span class="hljs-keyword">sizeof</span>(letter));<span class="hljs-built_in">memset</span>(myhash,<span class="hljs-number">0</span>,<span class="hljs-keyword">sizeof</span>(myhash));<span class="hljs-keyword">int</span> len=<span class="hljs-built_in">strlen</span>(s);<span class="hljs-keyword">int</span> cnt=<span class="hljs-number">0</span>;rep(i,<span class="hljs-number">0</span>,len)&#123;<span class="hljs-keyword">if</span>(!letter[s[i]]) &#123;letter[s[i]]=++cnt;<span class="hljs-keyword">if</span>(cnt==nc) <span class="hljs-keyword">break</span>;&#125;&#125;<span class="hljs-keyword">int</span> ans=<span class="hljs-number">0</span>;rep(i,<span class="hljs-number">0</span>,len-n+<span class="hljs-number">1</span>)&#123;<span class="hljs-keyword">int</span> sum=<span class="hljs-number">0</span>;<span class="hljs-keyword">for</span>(<span class="hljs-keyword">int</span> j=i;j&lt;i+n;j++)&#123;sum=sum*nc+letter[s[j]];&#125;<span class="hljs-keyword">if</span>(!myhash[sum])&#123;<span class="hljs-comment">//cout&lt;&lt;"i="&lt;&lt;i&lt;&lt;endl;</span>ans++;myhash[sum]=<span class="hljs-number">1</span>;&#125;<span class="hljs-keyword">else</span> <span class="hljs-keyword">continue</span>;&#125;<span class="hljs-built_in">cout</span>&lt;&lt;ans&lt;&lt;<span class="hljs-built_in">endl</span>; &#125;&#125;</code></pre></li></ul><h1 id="收获与反思"><a href="#收获与反思" class="headerlink" title="收获与反思"></a>收获与反思</h1><ul><li>简单字符串hash，没有涉及取模操作</li></ul>]]></content>
    
    
    <categories>
      
      <category>Computer Science</category>
      
      <category>ACM</category>
      
      <category>POJ</category>
      
    </categories>
    
    
    <tags>
      
      <tag>ACM</tag>
      
      <tag>POJ</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>【HDU-1711】解题报告（KMP模板题，字符串hash）</title>
    <link href="/post/531de0f8.html"/>
    <url>/post/531de0f8.html</url>
    
    <content type="html"><![CDATA[<h1 id="原始题目"><a href="#原始题目" class="headerlink" title="原始题目"></a>原始题目</h1><h2 id="Number-Sequence"><a href="#Number-Sequence" class="headerlink" title="Number Sequence"></a>Number Sequence</h2><ul><li>Time Limit: 10000/5000 MS (Java/Others)    </li><li>Memory Limit: 32768/32768 K (Java/Others)</li><li>Total Submission(s): 39142    </li><li>Accepted Submission(s): 16165</li></ul><h3 id="Problem-Description"><a href="#Problem-Description" class="headerlink" title="Problem Description"></a>Problem Description</h3><p>Given two sequences of numbers : a[1], a[2], …… , a[N], and b[1], b[2], …… , b[M] (1 ≤ M ≤ 10000, 1 ≤ N ≤ 1000000). Your task is to find a number K which make a[K] = b[1], a[K + 1] = b[2], …… , a[K + M - 1] = b[M]. If there are more than one K exist, output the smallest one.<br><a id="more"></a></p><h3 id="Input"><a href="#Input" class="headerlink" title="Input"></a>Input</h3><p>The first line of input is a number T which indicate the number of cases. Each case contains three lines. The first line is two numbers N and M (1 ≤ M ≤ 10000, 1 ≤ N ≤ 1000000). The second line contains N integers which indicate a[1], a[2], …… , a[N]. The third line contains M integers which indicate b[1], b[2], …… , b[M]. All integers are in the range of [-1000000, 1000000].</p><h3 id="Output"><a href="#Output" class="headerlink" title="Output"></a>Output</h3><p>For each test case, you should output one line which only contain K described above. If no such K exists, output -1 instead.</p><h3 id="Sample-Input"><a href="#Sample-Input" class="headerlink" title="Sample Input"></a>Sample Input</h3><pre><code>213 51 2 1 2 3 1 2 3 1 3 2 1 21 2 3 1 313 51 2 1 2 3 1 2 3 1 3 2 1 21 2 3 2 1</code></pre><h3 id="Sample-Output"><a href="#Sample-Output" class="headerlink" title="Sample Output"></a>Sample Output</h3><pre><code>6-1</code></pre><h3 id="Source"><a href="#Source" class="headerlink" title="Source"></a>Source</h3><p>HDU 2007-Spring Programming Contest</p><h3 id="Recommend"><a href="#Recommend" class="headerlink" title="Recommend"></a>Recommend</h3><p>lcy</p><h1 id="题目大意"><a href="#题目大意" class="headerlink" title="题目大意"></a>题目大意</h1><ul><li>给定一个数字串和一个模式串，输出最早匹配的位置，没有输出-1。</li></ul><h1 id="解题思路"><a href="#解题思路" class="headerlink" title="解题思路"></a>解题思路</h1><ul><li>KMP把字符匹配改成int即可。</li></ul><h1 id="解题代码"><a href="#解题代码" class="headerlink" title="解题代码"></a>解题代码</h1><pre><code class="hljs C++"><span class="hljs-comment">//#include &lt;bits/stdc++.h&gt;</span><span class="hljs-meta">#<span class="hljs-meta-keyword">include</span> <span class="hljs-meta-string">&lt;cstdio&gt; </span></span><span class="hljs-meta">#<span class="hljs-meta-keyword">include</span> <span class="hljs-meta-string">&lt;cstring&gt;</span></span><span class="hljs-meta">#<span class="hljs-meta-keyword">include</span> <span class="hljs-meta-string">&lt;cstdlib&gt;</span></span><span class="hljs-meta">#<span class="hljs-meta-keyword">include</span> <span class="hljs-meta-string">&lt;iostream&gt;</span></span><span class="hljs-meta">#<span class="hljs-meta-keyword">include</span> <span class="hljs-meta-string">&lt;iomanip&gt;</span></span><span class="hljs-meta">#<span class="hljs-meta-keyword">include</span> <span class="hljs-meta-string">&lt;string&gt;</span></span><span class="hljs-meta">#<span class="hljs-meta-keyword">include</span> <span class="hljs-meta-string">&lt;map&gt;</span></span><span class="hljs-meta">#<span class="hljs-meta-keyword">include</span> <span class="hljs-meta-string">&lt;set&gt;</span></span><span class="hljs-meta">#<span class="hljs-meta-keyword">include</span> <span class="hljs-meta-string">&lt;algorithm&gt;</span></span><span class="hljs-meta">#<span class="hljs-meta-keyword">include</span> <span class="hljs-meta-string">&lt;queue&gt;</span></span><span class="hljs-meta">#<span class="hljs-meta-keyword">include</span> <span class="hljs-meta-string">&lt;vector&gt;</span></span><span class="hljs-meta">#<span class="hljs-meta-keyword">define</span> pb push_back</span><span class="hljs-meta">#<span class="hljs-meta-keyword">define</span> mp make_pair</span><span class="hljs-keyword">using</span> <span class="hljs-keyword">namespace</span> <span class="hljs-built_in">std</span>;<span class="hljs-keyword">typedef</span> <span class="hljs-keyword">long</span> <span class="hljs-keyword">long</span> LL;<span class="hljs-keyword">typedef</span> pair&lt;<span class="hljs-keyword">int</span>,<span class="hljs-keyword">int</span>&gt; PII;<span class="hljs-meta">#<span class="hljs-meta-keyword">define</span> PI acos((double)-1)</span><span class="hljs-meta">#<span class="hljs-meta-keyword">define</span> E exp(double(1))</span><span class="hljs-meta">#<span class="hljs-meta-keyword">define</span> K 1000000+9</span><span class="hljs-meta">#<span class="hljs-meta-keyword">define</span> rep(i,a,n) for(int i=a;i&lt;n;i++)</span><span class="hljs-meta">#<span class="hljs-meta-keyword">define</span> per(i,a,n) for(int i=n-1;i&gt;=a;i--)</span><span class="hljs-meta">#<span class="hljs-meta-keyword">define</span> ms(x,a) memset((x),(a),sizeof(a))</span><span class="hljs-keyword">int</span> nt[<span class="hljs-number">10006</span>];<span class="hljs-keyword">int</span> a[K],b[<span class="hljs-number">10005</span>],n,m;<span class="hljs-comment">//参数为模板串和next数组</span><span class="hljs-comment">//字符串均从下标0开始</span><span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">kmp_next</span><span class="hljs-params">(<span class="hljs-keyword">int</span> *T,<span class="hljs-keyword">int</span> *nt)</span></span>&#123;    nt[<span class="hljs-number">0</span>]=<span class="hljs-number">0</span>;    <span class="hljs-keyword">for</span>(<span class="hljs-keyword">int</span> i=<span class="hljs-number">1</span>,j=<span class="hljs-number">0</span>;i&lt;m;i++)    &#123;        <span class="hljs-keyword">while</span>(j&amp;&amp;T[i]!=T[j])j=nt[j<span class="hljs-number">-1</span>];        <span class="hljs-keyword">if</span>(T[i]==T[j])j++;        nt[i]=j;    &#125;&#125;<span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">kmp</span><span class="hljs-params">(<span class="hljs-keyword">int</span> *S,<span class="hljs-keyword">int</span> *T,<span class="hljs-keyword">int</span> *nt)</span></span>&#123;    kmp_next(T,nt);    <span class="hljs-keyword">int</span> ans=<span class="hljs-number">0</span>;    <span class="hljs-comment">//n //m</span>    <span class="hljs-keyword">for</span>(<span class="hljs-keyword">int</span> i=<span class="hljs-number">0</span>,j=<span class="hljs-number">0</span>;i&lt;n;i++)    &#123;        <span class="hljs-keyword">while</span>(j&amp;&amp;S[i]!=T[j])j=nt[j<span class="hljs-number">-1</span>];        <span class="hljs-keyword">if</span>(S[i]==T[j])j++;        <span class="hljs-keyword">if</span>(j==m)&#123;<span class="hljs-comment">//        ans++;</span><span class="hljs-keyword">return</span> i-m+<span class="hljs-number">2</span>;&#125;               &#125;    <span class="hljs-keyword">return</span> <span class="hljs-number">-1</span>;&#125;<span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">main</span><span class="hljs-params">(<span class="hljs-keyword">void</span>)</span></span>&#123;ios::sync_with_stdio(<span class="hljs-literal">false</span>);    <span class="hljs-keyword">int</span> t;<span class="hljs-built_in">cin</span>&gt;&gt;t;    <span class="hljs-keyword">while</span>(t--)    &#123;    <span class="hljs-built_in">cin</span>&gt;&gt;n&gt;&gt;m;    rep(i,<span class="hljs-number">0</span>,n) <span class="hljs-built_in">cin</span>&gt;&gt;a[i];    rep(i,<span class="hljs-number">0</span>,m) <span class="hljs-built_in">cin</span>&gt;&gt;b[i];    <span class="hljs-built_in">cout</span>&lt;&lt; kmp(a,b,nt)&lt;&lt;<span class="hljs-built_in">endl</span>;    &#125;    <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;&#125;<span class="hljs-comment">//1 2 1 2 3 1 2 3 1 3  2 1 2 3 1 2 3</span></code></pre><h1 id="收获与反思"><a href="#收获与反思" class="headerlink" title="收获与反思"></a>收获与反思</h1><ul><li>单模匹配考虑KMP，熟悉模板和算法。</li></ul>]]></content>
    
    
    <categories>
      
      <category>Computer Science</category>
      
      <category>ACM</category>
      
      <category>HDU</category>
      
    </categories>
    
    
    <tags>
      
      <tag>ACM</tag>
      
      <tag>HDU</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>【HDU-1224】解题报告（最长路，路径）</title>
    <link href="/post/cd18de84.html"/>
    <url>/post/cd18de84.html</url>
    
    <content type="html"><![CDATA[<h1 id="原始题目"><a href="#原始题目" class="headerlink" title="原始题目"></a>原始题目</h1><h2 id="Free-DIY-Tour"><a href="#Free-DIY-Tour" class="headerlink" title="Free DIY Tour"></a>Free DIY Tour</h2><ul><li>Time Limit: 2000/1000 MS (Java/Others)    </li><li>Memory Limit: 65536/32768 K (Java/Others)</li><li>Total Submission(s): 8700    </li><li>Accepted Submission(s): 2805</li></ul><h3 id="Problem-Description"><a href="#Problem-Description" class="headerlink" title="Problem Description"></a>Problem Description</h3><p>Weiwei is a software engineer of ShiningSoft. He has just excellently fulfilled a software project with his fellow workers. His boss is so satisfied with their job that he decide to provide them a free tour around the world. It’s a good chance to relax themselves. To most of them, it’s the first time to go abroad so they decide to make a collective tour.</p><p>The tour company shows them a new kind of tour circuit - DIY circuit. Each circuit contains some cities which can be selected by tourists themselves. According to the company’s statistic, each city has its own interesting point. For instance, Paris has its interesting point of 90, New York has its interesting point of 70, ect. Not any two cities in the world have straight flight so the tour company provide a map to tell its tourists whether they can got a straight flight between any two cities on the map. In order to fly back, the company has made it impossible to make a circle-flight on the half way, using the cities on the map. That is, they marked each city on the map with one number, a city with higher number has no straight flight to a city with lower number. </p><p>Note: Weiwei always starts from Hangzhou(in this problem, we assume Hangzhou is always the first city and also the last city, so we mark Hangzhou both 1 and N+1), and its interesting point is always 0.</p><p>Now as the leader of the team, Weiwei wants to make a tour as interesting as possible. If you were Weiwei, how did you DIY it?</p><a id="more"></a> <h3 id="Input"><a href="#Input" class="headerlink" title="Input"></a>Input</h3><p>The input will contain several cases. The first line is an integer T which suggests the number of cases. Then T cases follows.</p><p>Each case will begin with an integer N(2 ≤ N ≤ 100) which is the number of cities on the map.</p><p>Then N integers follows, representing the interesting point list of the cities.</p><p>And then it is an integer M followed by M pairs of integers [Ai, Bi] (1 ≤ i ≤ M). Each pair of [Ai, Bi] indicates that a straight flight is available from City Ai to City Bi.</p><h3 id="Output"><a href="#Output" class="headerlink" title="Output"></a>Output</h3><p>For each case, your task is to output the maximal summation of interesting points Weiwei and his fellow workers can get through optimal DIYing and the optimal circuit. The format is as the sample. You may assume that there is only one optimal circuit. </p><p>Output a blank line between two cases.</p><h3 id="Sample-Input"><a href="#Sample-Input" class="headerlink" title="Sample Input"></a>Sample Input</h3><pre><code>230 70 9041 21 32 43 430 90 7041 21 32 43 4</code></pre><h3 id="Sample-Output"><a href="#Sample-Output" class="headerlink" title="Sample Output"></a>Sample Output</h3><pre><code>CASE 1#points : 90circuit : 1-&gt;3-&gt;1CASE 2#points : 90circuit : 1-&gt;2-&gt;1</code></pre><h3 id="Author"><a href="#Author" class="headerlink" title="Author"></a>Author</h3><p>JGShining（极光炫影）</p><h3 id="Source"><a href="#Source" class="headerlink" title="Source"></a>Source</h3><p>杭州电子科技大学第三届程序设计大赛</p><h3 id="Recommend"><a href="#Recommend" class="headerlink" title="Recommend"></a>Recommend</h3><p>Ignatius.L</p><h1 id="题目大意"><a href="#题目大意" class="headerlink" title="题目大意"></a>题目大意</h1><ul><li>自定义旅途路线，1和n+1结点权值为0，剩下结点权值给定，有向图，求最长路。</li></ul><h1 id="解题思路"><a href="#解题思路" class="headerlink" title="解题思路"></a>解题思路</h1><ul><li>改了一下Dijkstra最短路算法竟然A了。</li></ul><h1 id="解题代码"><a href="#解题代码" class="headerlink" title="解题代码"></a>解题代码</h1><pre><code class="hljs C++"><span class="hljs-meta">#<span class="hljs-meta-keyword">include</span> <span class="hljs-meta-string">&lt;cstdio&gt;</span></span><span class="hljs-meta">#<span class="hljs-meta-keyword">include</span> <span class="hljs-meta-string">&lt;cstring&gt;</span></span><span class="hljs-meta">#<span class="hljs-meta-keyword">include</span> <span class="hljs-meta-string">&lt;string&gt;</span></span><span class="hljs-meta">#<span class="hljs-meta-keyword">include</span> <span class="hljs-meta-string">&lt;algorithm&gt;</span></span><span class="hljs-meta">#<span class="hljs-meta-keyword">include</span> <span class="hljs-meta-string">&lt;iostream&gt;</span></span><span class="hljs-meta">#<span class="hljs-meta-keyword">include</span> <span class="hljs-meta-string">&lt;stack&gt;</span></span><span class="hljs-meta">#<span class="hljs-meta-keyword">include</span> <span class="hljs-meta-string">&lt;set&gt;</span></span><span class="hljs-meta">#<span class="hljs-meta-keyword">include</span> <span class="hljs-meta-string">&lt;vector&gt;</span></span><span class="hljs-meta">#<span class="hljs-meta-keyword">include</span> <span class="hljs-meta-string">&lt;queue&gt;</span></span><span class="hljs-meta">#<span class="hljs-meta-keyword">include</span> <span class="hljs-meta-string">&lt;cmath&gt;</span></span><span class="hljs-meta">#<span class="hljs-meta-keyword">include</span> <span class="hljs-meta-string">&lt;cstdlib&gt;</span></span><span class="hljs-meta">#<span class="hljs-meta-keyword">include</span> <span class="hljs-meta-string">&lt;bits/stdc++.h&gt; </span></span><span class="hljs-keyword">using</span> <span class="hljs-keyword">namespace</span> <span class="hljs-built_in">std</span>;<span class="hljs-meta">#<span class="hljs-meta-keyword">define</span> eps 1e-8</span><span class="hljs-meta">#<span class="hljs-meta-keyword">define</span> INF 0x3f3f3f3f</span><span class="hljs-meta">#<span class="hljs-meta-keyword">define</span> rep(i,a,n) for(int i=a;i&lt;n;i++)</span><span class="hljs-meta">#<span class="hljs-meta-keyword">define</span> per(i,a,n) for(int i=n-1;i&gt;=a;i--)</span><span class="hljs-meta">#<span class="hljs-meta-keyword">define</span> all(x) x.begin(),x.end()</span><span class="hljs-meta">#<span class="hljs-meta-keyword">define</span> pb push_back</span><span class="hljs-meta">#<span class="hljs-meta-keyword">define</span> np next_permutation</span><span class="hljs-meta">#<span class="hljs-meta-keyword">define</span> ms(x,a) memset((x),(a),sizeof(x))</span><span class="hljs-comment">//优先队列迪杰斯特拉 </span><span class="hljs-keyword">const</span> <span class="hljs-keyword">int</span> maxn=<span class="hljs-number">1e5</span>+<span class="hljs-number">5</span>;<span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">Edge</span>&#123;</span><span class="hljs-keyword">int</span> u,v,w;Edge(<span class="hljs-keyword">int</span> _u,<span class="hljs-keyword">int</span> _v,<span class="hljs-keyword">int</span> _w):u(_u),v(_v),w(_w)&#123;&#125;;&#125;;<span class="hljs-built_in">vector</span> &lt;Edge&gt; edges[maxn];<span class="hljs-keyword">int</span> dis[maxn],path[maxn],num[maxn],ans[maxn];<span class="hljs-keyword">bool</span> vis[maxn];<span class="hljs-keyword">int</span> n,m,uu,vv,ww,t;<span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">init</span><span class="hljs-params">()</span></span>&#123; <span class="hljs-comment">//n个结点的边集都清空 </span>rep(i,<span class="hljs-number">0</span>,maxn)&#123;edges[i].clear();&#125;ms(vis,<span class="hljs-number">0</span>);ms(dis,-INF);ms(path,<span class="hljs-number">0</span>);ms(num,<span class="hljs-number">0</span>);&#125;<span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">addEdge</span><span class="hljs-params">(<span class="hljs-keyword">int</span> u,<span class="hljs-keyword">int</span> v,<span class="hljs-keyword">int</span> w)</span></span>&#123;edges[u].pb(Edge(u,v,w));&#125;<span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">Node</span>&#123;</span><span class="hljs-keyword">int</span> Id,W;Node(<span class="hljs-keyword">int</span> _Id,<span class="hljs-keyword">int</span> _W):Id(_Id),W(_W)&#123;&#125;;<span class="hljs-keyword">bool</span> <span class="hljs-keyword">operator</span> &lt; (<span class="hljs-keyword">const</span> Node &amp;b) <span class="hljs-keyword">const</span> &#123;W&lt;b.W;&#125;&#125;;<span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">Dijkstra</span><span class="hljs-params">(<span class="hljs-keyword">int</span> s)</span></span>&#123;priority_queue &lt;Node&gt; q;q.push(Node(s,<span class="hljs-number">0</span>)) ,dis[s]=<span class="hljs-number">0</span>;<span class="hljs-keyword">while</span>(!q.empty())&#123;Node now=q.top();q.pop();<span class="hljs-keyword">int</span> index=now.Id;<span class="hljs-keyword">if</span>(dis[index]!=now.W) <span class="hljs-keyword">continue</span>;rep(i,<span class="hljs-number">0</span>,edges[index].size())&#123;<span class="hljs-comment">//cout&lt;&lt;"dis="&lt;&lt;dis[edges[index][i].v]&lt;&lt;"  new cost="&lt;&lt;dis[index]+edges[index][i].w;</span><span class="hljs-keyword">if</span>(dis[edges[index][i].v]&lt;dis[index]+edges[index][i].w)&#123;dis[edges[index][i].v]=dis[index]+edges[index][i].w;q.push(Node(edges[index][i].v,dis[edges[index][i].v]));path[edges[index][i].v]=index;<span class="hljs-comment">//cout&lt;&lt;" #"&lt;&lt; edges[index][i].v&lt;&lt;"   #"&lt;&lt;index&lt;&lt;endl;</span>&#125;&#125;&#125;&#125;<span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span>&#123;<span class="hljs-comment">//freopen("in.txt","r",stdin);</span>ios::sync_with_stdio(<span class="hljs-literal">false</span>);<span class="hljs-built_in">cin</span>&gt;&gt;t;rep(T,<span class="hljs-number">1</span>,t+<span class="hljs-number">1</span>)&#123;<span class="hljs-keyword">if</span>(T!=<span class="hljs-number">1</span>) <span class="hljs-built_in">cout</span>&lt;&lt;<span class="hljs-built_in">endl</span>;<span class="hljs-built_in">cin</span>&gt;&gt;n;init();rep(i,<span class="hljs-number">1</span>,n+<span class="hljs-number">1</span>)&#123;<span class="hljs-built_in">cin</span>&gt;&gt;num[i];  <span class="hljs-comment">//输入点权值 </span>&#125;<span class="hljs-built_in">cin</span>&gt;&gt;m;rep(i,<span class="hljs-number">1</span>,m+<span class="hljs-number">1</span>)&#123;<span class="hljs-built_in">cin</span>&gt;&gt;uu&gt;&gt;vv;addEdge(uu,vv,num[uu]);&#125;Dijkstra(<span class="hljs-number">1</span>);<span class="hljs-comment">//预处理路径</span><span class="hljs-keyword">int</span> cnt=<span class="hljs-number">0</span>,ini=n+<span class="hljs-number">1</span>;<span class="hljs-keyword">while</span>(<span class="hljs-number">1</span>)&#123;ans[cnt++]=ini;ini=path[ini];<span class="hljs-keyword">if</span>(ini==<span class="hljs-number">1</span>) <span class="hljs-keyword">break</span>;&#125; ans[cnt]=<span class="hljs-number">1</span>;<span class="hljs-comment">//输出</span><span class="hljs-built_in">cout</span>&lt;&lt;<span class="hljs-string">"CASE "</span>&lt;&lt;T&lt;&lt;<span class="hljs-string">"#"</span>&lt;&lt;<span class="hljs-built_in">endl</span>&lt;&lt;<span class="hljs-string">"points : "</span>&lt;&lt;dis[n+<span class="hljs-number">1</span>]&lt;&lt;<span class="hljs-built_in">endl</span>;<span class="hljs-built_in">cout</span>&lt;&lt;<span class="hljs-string">"circuit : "</span>;<span class="hljs-keyword">for</span>(<span class="hljs-keyword">int</span> i=cnt;i&gt;<span class="hljs-number">0</span>;i--) <span class="hljs-built_in">cout</span>&lt;&lt;ans[i]&lt;&lt;<span class="hljs-string">"-&gt;"</span>;<span class="hljs-built_in">cout</span>&lt;&lt;<span class="hljs-number">1</span>&lt;&lt;<span class="hljs-built_in">endl</span>;&#125; &#125;</code></pre><h1 id="收获与反思"><a href="#收获与反思" class="headerlink" title="收获与反思"></a>收获与反思</h1><ul><li>需要研究一下Dij可否算最长路</li></ul>]]></content>
    
    
    <categories>
      
      <category>Computer Science</category>
      
      <category>ACM</category>
      
      <category>HDU</category>
      
    </categories>
    
    
    <tags>
      
      <tag>ACM</tag>
      
      <tag>HDU</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>【HDU-2544】解题报告（最短路，dij）</title>
    <link href="/post/34a049ac.html"/>
    <url>/post/34a049ac.html</url>
    
    <content type="html"><![CDATA[<h1 id="原始题目"><a href="#原始题目" class="headerlink" title="原始题目"></a>原始题目</h1><h2 id="最短路"><a href="#最短路" class="headerlink" title="最短路"></a>最短路</h2><ul><li>Time Limit: 5000/1000 MS (Java/Others)    </li><li>Memory Limit: 32768/32768 K (Java/Others)</li><li>Total Submission(s): 88011    </li><li>Accepted Submission(s): 38096</li></ul><h3 id="Problem-Description"><a href="#Problem-Description" class="headerlink" title="Problem Description"></a>Problem Description</h3><p>在每年的校赛里，所有进入决赛的同学都会获得一件很漂亮的t-shirt。但是每当我们的工作人员把上百件的衣服从商店运回到赛场的时候，却是非常累的！所以现在他们想要寻找最短的从商店到赛场的路线，你可以帮助他们吗？<br><a id="more"></a></p><h3 id="Input"><a href="#Input" class="headerlink" title="Input"></a>Input</h3><p>输入包括多组数据。每组数据第一行是两个整数N、M（N≤100，M≤10000），N表示成都的大街上有几个路口，标号为1的路口是商店所在地，标号为N的路口是赛场所在地，M则表示在成都有几条路。N=M=0表示输入结束。接下来M行，每行包括3个整数A，B，C（1≤A,B≤N,1≤C≤1000）,表示在路口A与路口B之间有一条路，我们的工作人员需要C分钟的时间走过这条路。<br>输入保证至少存在1条商店到赛场的路线。</p><h3 id="Output"><a href="#Output" class="headerlink" title="Output"></a>Output</h3><p>对于每组输入，输出一行，表示工作人员从商店走到赛场的最短时间</p><h3 id="Sample-Input"><a href="#Sample-Input" class="headerlink" title="Sample Input"></a>Sample Input</h3><pre><code>2 11 2 33 31 2 52 3 53 1 20 0</code></pre><h3 id="Sample-Output"><a href="#Sample-Output" class="headerlink" title="Sample Output"></a>Sample Output</h3><pre><code>32</code></pre><h3 id="Source"><a href="#Source" class="headerlink" title="Source"></a>Source</h3><p>UESTC 6th Programming Contest Online</p><h3 id="Recommend"><a href="#Recommend" class="headerlink" title="Recommend"></a>Recommend</h3><p>lcy</p><h1 id="题目大意"><a href="#题目大意" class="headerlink" title="题目大意"></a>题目大意</h1><p>如题</p><h1 id="解题思路"><a href="#解题思路" class="headerlink" title="解题思路"></a>解题思路</h1><ul><li>单源正权，Dijkstra最短路模板题</li></ul><h1 id="解题代码"><a href="#解题代码" class="headerlink" title="解题代码"></a>解题代码</h1><pre><code class="hljs C++"><span class="hljs-meta">#<span class="hljs-meta-keyword">include</span> <span class="hljs-meta-string">&lt;cstdio&gt;</span></span><span class="hljs-meta">#<span class="hljs-meta-keyword">include</span> <span class="hljs-meta-string">&lt;cstring&gt;</span></span><span class="hljs-meta">#<span class="hljs-meta-keyword">include</span> <span class="hljs-meta-string">&lt;string&gt;</span></span><span class="hljs-meta">#<span class="hljs-meta-keyword">include</span> <span class="hljs-meta-string">&lt;algorithm&gt;</span></span><span class="hljs-meta">#<span class="hljs-meta-keyword">include</span> <span class="hljs-meta-string">&lt;iostream&gt;</span></span><span class="hljs-meta">#<span class="hljs-meta-keyword">include</span> <span class="hljs-meta-string">&lt;stack&gt;</span></span><span class="hljs-meta">#<span class="hljs-meta-keyword">include</span> <span class="hljs-meta-string">&lt;set&gt;</span></span><span class="hljs-meta">#<span class="hljs-meta-keyword">include</span> <span class="hljs-meta-string">&lt;vector&gt;</span></span><span class="hljs-meta">#<span class="hljs-meta-keyword">include</span> <span class="hljs-meta-string">&lt;queue&gt;</span></span><span class="hljs-meta">#<span class="hljs-meta-keyword">include</span> <span class="hljs-meta-string">&lt;cmath&gt;</span></span><span class="hljs-meta">#<span class="hljs-meta-keyword">include</span> <span class="hljs-meta-string">&lt;cstdlib&gt;</span></span><span class="hljs-meta">#<span class="hljs-meta-keyword">include</span> <span class="hljs-meta-string">&lt;bits/stdc++.h&gt; </span></span><span class="hljs-keyword">using</span> <span class="hljs-keyword">namespace</span> <span class="hljs-built_in">std</span>;<span class="hljs-meta">#<span class="hljs-meta-keyword">define</span> eps 1e-8</span><span class="hljs-meta">#<span class="hljs-meta-keyword">define</span> INF 0x3f3f3f3f</span><span class="hljs-meta">#<span class="hljs-meta-keyword">define</span> rep(i,a,n) for(int i=a;i&lt;n;i++)</span><span class="hljs-meta">#<span class="hljs-meta-keyword">define</span> per(i,a,n) for(int i=n-1;i&gt;=a;i--)</span><span class="hljs-meta">#<span class="hljs-meta-keyword">define</span> all(x) x.begin(),x.end()</span><span class="hljs-meta">#<span class="hljs-meta-keyword">define</span> pb push_back</span><span class="hljs-meta">#<span class="hljs-meta-keyword">define</span> np next_permutation</span><span class="hljs-meta">#<span class="hljs-meta-keyword">define</span> ms(x,a) memset((x),(a),sizeof(x))</span><span class="hljs-comment">//优先队列迪杰斯特拉 </span><span class="hljs-keyword">const</span> <span class="hljs-keyword">int</span> maxn=<span class="hljs-number">1e5</span>+<span class="hljs-number">5</span>;<span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">Edge</span>&#123;</span><span class="hljs-keyword">int</span> u,v,w;Edge(<span class="hljs-keyword">int</span> _u,<span class="hljs-keyword">int</span> _v,<span class="hljs-keyword">int</span> _w):u(_u),v(_v),w(_w)&#123;&#125;;&#125;;<span class="hljs-built_in">vector</span> &lt;Edge&gt; edges[maxn];<span class="hljs-keyword">int</span> dis[maxn];<span class="hljs-keyword">bool</span> vis[maxn];<span class="hljs-keyword">int</span> n,m,uu,vv,ww;<span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">init</span><span class="hljs-params">(<span class="hljs-keyword">int</span> n)</span></span>&#123; <span class="hljs-comment">//n个结点的边集都清空 </span>rep(i,<span class="hljs-number">0</span>,maxn)&#123;edges[i].clear();&#125;&#125;<span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">addEdge</span><span class="hljs-params">(<span class="hljs-keyword">int</span> u,<span class="hljs-keyword">int</span> v,<span class="hljs-keyword">int</span> w)</span></span>&#123;edges[u].pb(Edge(u,v,w));&#125;<span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">Node</span>&#123;</span><span class="hljs-keyword">int</span> Id,W;Node(<span class="hljs-keyword">int</span> _Id,<span class="hljs-keyword">int</span> _W):Id(_Id),W(_W)&#123;&#125;;<span class="hljs-keyword">bool</span> <span class="hljs-keyword">operator</span> &lt; (<span class="hljs-keyword">const</span> Node &amp;b) <span class="hljs-keyword">const</span> &#123;W&gt;b.W;&#125;&#125;;<span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">Dijkstra</span><span class="hljs-params">(<span class="hljs-keyword">int</span> s)</span></span>&#123;ms(vis,<span class="hljs-number">0</span>);ms(dis,INF);priority_queue &lt;Node&gt; q;q.push(Node(s,<span class="hljs-number">0</span>)) ,dis[s]=<span class="hljs-number">0</span>;<span class="hljs-keyword">while</span>(!q.empty())&#123;Node now=q.top();q.pop();<span class="hljs-keyword">int</span> index=now.Id;<span class="hljs-keyword">if</span>(dis[index]!=now.W) <span class="hljs-keyword">continue</span>;rep(i,<span class="hljs-number">0</span>,edges[index].size())&#123;<span class="hljs-keyword">if</span>(dis[edges[index][i].v]&gt;dis[index]+edges[index][i].w)&#123;dis[edges[index][i].v]=dis[index]+edges[index][i].w;q.push(Node(edges[index][i].v,dis[edges[index][i].v]));&#125;&#125;&#125;&#125;<span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span>&#123;ios::sync_with_stdio(<span class="hljs-literal">false</span>);<span class="hljs-keyword">while</span>(<span class="hljs-built_in">cin</span>&gt;&gt;n&gt;&gt;m&amp;&amp;n+m)&#123;init(n);rep(i,<span class="hljs-number">1</span>,m+<span class="hljs-number">1</span>)&#123;<span class="hljs-built_in">cin</span>&gt;&gt;uu&gt;&gt;vv&gt;&gt;ww;addEdge(uu,vv,ww);addEdge(vv,uu,ww);&#125; Dijkstra(<span class="hljs-number">1</span>);<span class="hljs-built_in">cout</span>&lt;&lt;dis[n]&lt;&lt;<span class="hljs-built_in">endl</span>; &#125; &#125;</code></pre><h1 id="收获与反思"><a href="#收获与反思" class="headerlink" title="收获与反思"></a>收获与反思</h1><ul><li>理解熟悉模板</li></ul>]]></content>
    
    
    <categories>
      
      <category>Computer Science</category>
      
      <category>ACM</category>
      
      <category>HDU</category>
      
    </categories>
    
    
    <tags>
      
      <tag>ACM</tag>
      
      <tag>HDU</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>《刺杀骑士团长》读书笔记</title>
    <link href="/post/d81c5363.html"/>
    <url>/post/d81c5363.html</url>
    
    <content type="html"><![CDATA[<p><iframe frameborder="no" border="0" marginwidth="0" marginheight="0" width="330" height="86" src="//music.163.com/outchain/player?type=2&id=452814326&auto=1&height=66"></iframe></p><h1 id="内容摘录"><a href="#内容摘录" class="headerlink" title="内容摘录"></a>内容摘录</h1><h2 id="第1部-显形理念篇"><a href="#第1部-显形理念篇" class="headerlink" title="第1部 显形理念篇"></a>第1部 显形理念篇</h2><blockquote><p>P95 “免色这个人物身上，总好像有悄然潜伏的什么。那个秘密已经放进带锁的小盒，深深埋入地下。很早以前埋的，如今上面长满绵柔茂密的绿草。<br>而知晓埋那个小盒的场所的，这个世界上唯独免色一人。我不能不在其微笑的深处感觉出拥有那一类型的秘密带来的孤独。”</p><p>P193 “就是有这一种类的梦。支离破碎犬牙交错的梦。每一块碎片诚然有其量感，但因相互纠缠而抵消了一尽。”</p><p>P204 “我的感情在永无休止的沉默中犹如以刀具做成的沉重的摆子一样从一个极端画着大大的弧线摆向另一个极端。”</p><p>P226 “就是说，在我们的人生中，现实与非现实的界线往往很难捕捉。那条界线看上去总是经常来来去去，就像每天兴之所至地随便移动的国境线——必须好好留意其<br>动向才行。否则，就不知道自己现在是在哪一边了。我刚才说再在洞中停留下去可能危险，就是这个意思。”</p></blockquote><a id="more"></a><blockquote><p>P293 “晚饭时间！人们大概同家人一起面对餐桌，即将把热乎乎的饭菜放入口中。我可以从那些灯光中感受到那种微笑的温煦。”</p><p>P300 “‘一个人被关在又黑又窄的地方，最可怕的不是死，而是   开始考虑自己可能要永远在这里活下去，那比什么都可怕。<br>那么一想，就吓得透不过气，就好像周围墙壁挤压过来直接把自己压瘪挤死——便是有那样汹涌的错觉。而在那里活下去，人就必须想方设法跨越那种恐惧，即克服自己。<br>为此就需要无限接近死亡。’‘可那伴随着危险。’‘和接近太阳的伊卡洛斯一样。至于接近的极限在哪里，分辨那条生死攸关的线并非易事。那将成为玩命作业。’‘而若回避那种接近，就不能跨越恐惧克服自己。00p’”</p><p>P333 “历史之中，就那样搁置在黑暗中为好的事件多的要命。正确知识未必使人丰富。客观未必凌驾于主观之上。事实未必吹灭妄想。”</p></blockquote>]]></content>
    
    
    <categories>
      
      <category>Life</category>
      
      <category>阅读</category>
      
    </categories>
    
    
    <tags>
      
      <tag>阅读</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>【CSU-1980】解题报告（区间dp，树的中序遍历）</title>
    <link href="/post/dc981233.html"/>
    <url>/post/dc981233.html</url>
    
    <content type="html"><![CDATA[<h1 id="原始题目"><a href="#原始题目" class="headerlink" title="原始题目"></a>原始题目</h1><h2 id="1980-不堪重负的树"><a href="#1980-不堪重负的树" class="headerlink" title="1980: 不堪重负的树"></a>1980: 不堪重负的树</h2><ul><li>Time Limit: 1 Sec     </li><li>Memory Limit: 128 Mb     </li><li>Submitted: 188     </li><li>Solved: 83    </li></ul><h3 id="Description"><a href="#Description" class="headerlink" title="Description"></a>Description</h3><p>小X非常喜欢树，然后他生成了一个大森林给自己玩。</p><p>玩着玩着，小X陷入了沉思。</p><ul><li>一棵树由N个节点组成，编号为i的节点有一个价值Wi。</li><li>假设从树根出发前往第i个节点（可能是树根自己），一共需要经过Di个节点（包括起点和终点），那么这个节点对这棵树产生的负担就是Di与Wi的乘积。</li><li>对于一棵树而言，这棵树的负担值为所有节点对它产生的负担之和。</li></ul><p>小X学习了dfs，如果他知道树的结构，他当然可以很容易地算出树的负担值。可是现在沉思中的小X并不知道树的结构形态，他只知道一棵二叉树的中序遍历以及每个节点的价值，那么这棵二叉树可能的最小负担值是多少呢？<br><a id="more"></a></p><h3 id="Input"><a href="#Input" class="headerlink" title="Input"></a>Input</h3><p>第一行为一个正整数T(T≤20)表示数据组数。</p><p>每组数据包括三行。</p><p>第一行为一个正整数N(N≤200)。</p><p>第二行为N个正整数Wi(Wi≤108)，表示编号为i的节点的价值。</p><p>第三行为N个正整数Pi(Pi≤N)，为一个1~N的排列，表示二叉树的中序遍历结果。</p><h3 id="Output"><a href="#Output" class="headerlink" title="Output"></a>Output</h3><p>对于每组数据，输出一行一个正整数，表示这棵树可能的最小负担值。</p><h3 id="Sample-Input"><a href="#Sample-Input" class="headerlink" title="Sample Input"></a>Sample Input</h3><pre><code>241 2 3 41 2 3 471 1 1 1 1 1 14 2 3 5 7 1 6</code></pre><h3 id="Sample-Output"><a href="#Sample-Output" class="headerlink" title="Sample Output"></a>Sample Output</h3><pre><code>1817</code></pre><h3 id="Hint"><a href="#Hint" class="headerlink" title="Hint"></a>Hint</h3><p>对于第一个样例，树根为3，3的左儿子是2，3的右儿子是4，2的左儿子是1，这样构成的树可以达到最小负担。</p><p>对于第二个样例，对应的满二叉树可以达到最小负担。</p><h3 id="Source"><a href="#Source" class="headerlink" title="Source"></a>Source</h3><p>2017年8月月赛</p><h3 id="Author"><a href="#Author" class="headerlink" title="Author"></a>Author</h3><p>devember</p><h1 id="题目大意"><a href="#题目大意" class="headerlink" title="题目大意"></a>题目大意</h1><p>如题</p><h1 id="解题思路"><a href="#解题思路" class="headerlink" title="解题思路"></a>解题思路</h1><ul><li>先求得中序遍历各节点的权值</li><li>预处理前缀和，以及dp数组（初始$dp[i][i]=f[i]$）</li><li>对于一棵树可以由左子树、右子树的最优解转移过来，区间dp</li><li>状态转移方程<script type="math/tex; mode=display">dp[i][j]=min(dp[i][k-1]+dp[k+1][j])+\sum_{m=i}^{j} f[i]  (i<k<j)</script></li><li>注意边界情况（某子树为空时）</li></ul><h1 id="解题代码"><a href="#解题代码" class="headerlink" title="解题代码"></a>解题代码</h1><pre><code class="hljs C++"><span class="hljs-meta">#<span class="hljs-meta-keyword">include</span> <span class="hljs-meta-string">&lt;cstdio&gt;</span></span><span class="hljs-meta">#<span class="hljs-meta-keyword">include</span> <span class="hljs-meta-string">&lt;cstring&gt;</span></span><span class="hljs-meta">#<span class="hljs-meta-keyword">include</span> <span class="hljs-meta-string">&lt;cstdlib&gt;</span></span><span class="hljs-meta">#<span class="hljs-meta-keyword">include</span> <span class="hljs-meta-string">&lt;iostream&gt;</span></span><span class="hljs-meta">#<span class="hljs-meta-keyword">include</span> <span class="hljs-meta-string">&lt;algorithm&gt;</span></span><span class="hljs-comment">//#include &lt;bits/stdc++.h&gt;</span><span class="hljs-meta">#<span class="hljs-meta-keyword">define</span> ms(i,a) memset((i),(a),sizeof(i))</span><span class="hljs-meta">#<span class="hljs-meta-keyword">define</span> rep(i,a,n) for (int i=a;i&lt;n;i++)</span><span class="hljs-meta">#<span class="hljs-meta-keyword">define</span> per(i,a,n) for (int i=n-1;i&gt;=a;i--)</span><span class="hljs-meta">#<span class="hljs-meta-keyword">define</span> pb push_back</span><span class="hljs-meta">#<span class="hljs-meta-keyword">define</span> mp make_pair</span><span class="hljs-meta">#<span class="hljs-meta-keyword">define</span> np next_permutation</span><span class="hljs-meta">#<span class="hljs-meta-keyword">define</span> all(x) x.begin(),x.end()</span><span class="hljs-meta">#<span class="hljs-meta-keyword">define</span> fi first</span><span class="hljs-meta">#<span class="hljs-meta-keyword">define</span> se second</span><span class="hljs-meta">#<span class="hljs-meta-keyword">define</span> SZ(x) ((ll)(x).size()) </span><span class="hljs-meta">#<span class="hljs-meta-keyword">define</span> INF 0x3f3f3f3f</span><span class="hljs-keyword">using</span> <span class="hljs-keyword">namespace</span> <span class="hljs-built_in">std</span>;<span class="hljs-keyword">typedef</span> <span class="hljs-keyword">long</span> <span class="hljs-keyword">long</span> ll;<span class="hljs-keyword">const</span> ll maxn=<span class="hljs-number">200</span>+<span class="hljs-number">5</span>;ll dp[maxn][maxn],p[maxn],w[maxn],f[maxn],sum[maxn];ll n,t;<span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">initial</span><span class="hljs-params">()</span></span>&#123;rep(i,<span class="hljs-number">1</span>,n+<span class="hljs-number">1</span>)&#123;f[i]=w[p[i]];&#125; rep(i,<span class="hljs-number">1</span>,n+<span class="hljs-number">1</span>)&#123;rep(j,i,n+<span class="hljs-number">1</span>)&#123;<span class="hljs-keyword">if</span>(i==j) dp[i][j]=f[i];<span class="hljs-keyword">else</span> dp[i][j]=INF; &#125;&#125;sum[<span class="hljs-number">0</span>]=<span class="hljs-number">0</span>;    rep(i,<span class="hljs-number">1</span>,n+<span class="hljs-number">1</span>) sum[i]=sum[i<span class="hljs-number">-1</span>]+f[i];<span class="hljs-comment">//前缀和 </span>&#125; <span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span>&#123;ios::sync_with_stdio(<span class="hljs-literal">false</span>);     <span class="hljs-built_in">cin</span>&gt;&gt;t;    <span class="hljs-keyword">while</span>(t--)    &#123;        <span class="hljs-built_in">cin</span>&gt;&gt;n;        rep(i,<span class="hljs-number">1</span>,n+<span class="hljs-number">1</span>)<span class="hljs-built_in">cin</span>&gt;&gt;w[i];        rep(i,<span class="hljs-number">1</span>,n+<span class="hljs-number">1</span>)<span class="hljs-built_in">cin</span>&gt;&gt;p[i];        initial();                 <span class="hljs-keyword">for</span>(ll len=<span class="hljs-number">2</span>;len&lt;=n;len++)&#123;        <span class="hljs-keyword">for</span>(ll i=<span class="hljs-number">1</span>;i+len<span class="hljs-number">-1</span>&lt;=n;i++)&#123;        ll j=i+len<span class="hljs-number">-1</span>;        dp[i][j]=min(dp[i+<span class="hljs-number">1</span>][j],dp[i][j<span class="hljs-number">-1</span>])+sum[j]-sum[i<span class="hljs-number">-1</span>];        <span class="hljs-keyword">for</span>(ll k=i+<span class="hljs-number">1</span>;k&lt;j;k++)&#123;        dp[i][j]=min(dp[i][j],dp[i][k<span class="hljs-number">-1</span>]+dp[k+<span class="hljs-number">1</span>][j]+sum[j]-sum[i<span class="hljs-number">-1</span>]);&#125;        &#125;&#125;        <span class="hljs-built_in">cout</span>&lt;&lt;dp[<span class="hljs-number">1</span>][n]&lt;&lt;<span class="hljs-built_in">endl</span>;    &#125;    <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;&#125;</code></pre><h1 id="收获与反思"><a href="#收获与反思" class="headerlink" title="收获与反思"></a>收获与反思</h1><ul><li>区间DP逐渐形成自己的写法</li><li>注意边界条件的考虑，这里需要考虑空树的情况，<script type="math/tex; mode=display">dp[i][j]=min(dp[i+1][j],dp[i][j-1])+sum[j]-sum[i-1]</script></li></ul>]]></content>
    
    
    <categories>
      
      <category>Computer Science</category>
      
      <category>ACM</category>
      
      <category>CSU</category>
      
    </categories>
    
    
    <tags>
      
      <tag>ACM</tag>
      
      <tag>CSU</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>【POJ-1651】解题报告（区间DP入门）</title>
    <link href="/post/4fa396eb.html"/>
    <url>/post/4fa396eb.html</url>
    
    <content type="html"><![CDATA[<h1 id="原始题目"><a href="#原始题目" class="headerlink" title="原始题目"></a>原始题目</h1><h2 id="Multiplication-Puzzle"><a href="#Multiplication-Puzzle" class="headerlink" title="Multiplication Puzzle"></a>Multiplication Puzzle</h2><ul><li>Time Limit: 1000MS        </li><li>Memory Limit: 65536K</li><li>Total Submissions: 13111        </li><li>Accepted: 8035</li></ul><h3 id="Description"><a href="#Description" class="headerlink" title="Description"></a>Description</h3><p>The multiplication puzzle is played with a row of cards, each containing a single positive integer. During the move player takes one card out of the row and scores the number of points equal to the product of the number on the card taken and the numbers on the cards on the left and on the right of it. It is not allowed to take out the first and the last card in the row. After the final move, only two cards are left in the row. </p><p>The goal is to take cards in such order as to minimize the total number of scored points. </p><p>For example, if cards in the row contain numbers 10, 1, 50, 20, 5, player might take a card with 1, then 20 and 50, scoring </p><script type="math/tex; mode=display">10*1*50 + 50*20*5 + 10*50*5 = 500+5000+2500 = 8000</script><p>If he would take the cards in the opposite order, i.e. 50, then 20, then 1, the score would be </p><script type="math/tex; mode=display">1*50*20 + 1*20*5 + 10*1*5 = 1000+100+50 = 1150</script><a id="more"></a><h3 id="Input"><a href="#Input" class="headerlink" title="Input"></a>Input</h3><p>The first line of the input contains the number of cards $N (3 \le N \le 100)$. The second line contains $N$ integers in the range from $1$ to $100$, separated by spaces.</p><h3 id="Output"><a href="#Output" class="headerlink" title="Output"></a>Output</h3><p>Output must contain a single integer - the minimal score.</p><h3 id="Sample-Input"><a href="#Sample-Input" class="headerlink" title="Sample Input"></a>Sample Input</h3><pre><code>610 1 50 50 20 5</code></pre><h3 id="Sample-Output"><a href="#Sample-Output" class="headerlink" title="Sample Output"></a>Sample Output</h3><pre><code>3650Source</code></pre><p>Northeastern Europe 2001, Far-Eastern Subregion</p><h1 id="题目大意"><a href="#题目大意" class="headerlink" title="题目大意"></a>题目大意</h1><ul><li>抽卡片，分数每次增加所抽卡片以及其相邻两侧的卡片的数值。不允许抽第一个和最后一个，抽到最后仅剩下这两张卡片，求最小的分数。</li></ul><h1 id="解题思路"><a href="#解题思路" class="headerlink" title="解题思路"></a>解题思路</h1><ul><li>每个大区间的分数都由最后抽的一张牌分成两个小区间，区间dp问题</li><li>状态转移方程<script type="math/tex; mode=display">dp[i][j]=min(dp[i][k]+dp[k][j]+a[i]*a[k]*a[j]) (i\leq k \leq j)</script><h1 id="解题代码"><a href="#解题代码" class="headerlink" title="解题代码"></a>解题代码</h1><pre><code class="hljs C++"><span class="hljs-meta">#<span class="hljs-meta-keyword">include</span> <span class="hljs-meta-string">&lt;vector&gt;</span></span><span class="hljs-meta">#<span class="hljs-meta-keyword">include</span> <span class="hljs-meta-string">&lt;queue&gt;</span></span><span class="hljs-meta">#<span class="hljs-meta-keyword">include</span> <span class="hljs-meta-string">&lt;cstdio&gt;</span></span><span class="hljs-meta">#<span class="hljs-meta-keyword">include</span> <span class="hljs-meta-string">&lt;cstring&gt;</span></span><span class="hljs-meta">#<span class="hljs-meta-keyword">include</span> <span class="hljs-meta-string">&lt;cstdlib&gt;</span></span><span class="hljs-meta">#<span class="hljs-meta-keyword">include</span> <span class="hljs-meta-string">&lt;iostream&gt;</span></span><span class="hljs-meta">#<span class="hljs-meta-keyword">include</span> <span class="hljs-meta-string">&lt;algorithm&gt;</span></span><span class="hljs-comment">//#include &lt;bits/stdc++.h&gt;</span><span class="hljs-meta">#<span class="hljs-meta-keyword">define</span> ms(i,a) memset((i),(a),sizeof(i))</span><span class="hljs-meta">#<span class="hljs-meta-keyword">define</span> rep(i,a,n) for (int i=a;i&lt;n;i++)</span><span class="hljs-meta">#<span class="hljs-meta-keyword">define</span> per(i,a,n) for (int i=n-1;i&gt;=a;i--)</span><span class="hljs-meta">#<span class="hljs-meta-keyword">define</span> pb push_back</span><span class="hljs-meta">#<span class="hljs-meta-keyword">define</span> mp make_pair</span><span class="hljs-meta">#<span class="hljs-meta-keyword">define</span> np next_permutation</span><span class="hljs-meta">#<span class="hljs-meta-keyword">define</span> all(x) x.begin(),x.end()</span><span class="hljs-meta">#<span class="hljs-meta-keyword">define</span> fi first</span><span class="hljs-meta">#<span class="hljs-meta-keyword">define</span> se second</span><span class="hljs-meta">#<span class="hljs-meta-keyword">define</span> SZ(x) ((int)(x).size()) </span><span class="hljs-meta">#<span class="hljs-meta-keyword">define</span> INF 0x3f3f3f3f</span><span class="hljs-keyword">using</span> <span class="hljs-keyword">namespace</span> <span class="hljs-built_in">std</span>;<span class="hljs-keyword">int</span> n,t,m; <span class="hljs-keyword">int</span> dp[<span class="hljs-number">105</span>][<span class="hljs-number">105</span>],a[<span class="hljs-number">105</span>],sum[<span class="hljs-number">105</span>]; <span class="hljs-comment">//前缀和 </span><span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">initial</span><span class="hljs-params">()</span></span>&#123;ms(dp,<span class="hljs-number">0</span>);rep(i,<span class="hljs-number">1</span>,n+<span class="hljs-number">1</span>)&#123;        rep(j,i+<span class="hljs-number">2</span>,n+<span class="hljs-number">1</span>)&#123;            <span class="hljs-keyword">if</span>(j==i+<span class="hljs-number">2</span>) dp[i][j]=a[i]*a[i+<span class="hljs-number">1</span>]*a[i+<span class="hljs-number">2</span>];             <span class="hljs-keyword">else</span> dp[i][j]=INF;    &#125;    &#125; &#125;<span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span>&#123;ios::sync_with_stdio(<span class="hljs-literal">false</span>);<span class="hljs-comment">//freopen("in.txt","r",stdin);</span>    <span class="hljs-keyword">while</span>(<span class="hljs-built_in">cin</span>&gt;&gt;n)    &#123;        sum[<span class="hljs-number">0</span>]=<span class="hljs-number">0</span>;         rep(i,<span class="hljs-number">1</span>,n+<span class="hljs-number">1</span>)&#123;        <span class="hljs-built_in">cin</span>&gt;&gt;a[i];<span class="hljs-comment">//        sum[i]=sum[i-1]+m;</span>&#125;initial();        <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> len = <span class="hljs-number">4</span>; len &lt;= n; ++len)&#123;            <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> i = <span class="hljs-number">1</span>; i + len - <span class="hljs-number">1</span> &lt;= n; ++i) &#123;                 <span class="hljs-keyword">int</span> j = i + len - <span class="hljs-number">1</span>;                 <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> k = i; k &lt;= j; ++k)                    dp[i][j] = min(dp[i][j], dp[i][k] + dp[k][j] + a[i] * a[k] * a[j]);<span class="hljs-comment">//                cout&lt;&lt;"i="&lt;&lt;i&lt;&lt;"  j="&lt;&lt;j&lt;&lt;"  dp="&lt;&lt;dp[i][j]&lt;&lt;endl;</span>            &#125;        &#125;        <span class="hljs-built_in">cout</span>&lt;&lt;dp[<span class="hljs-number">1</span>][n]&lt;&lt;<span class="hljs-built_in">endl</span>;    &#125;    <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;&#125;</code></pre></li></ul><h1 id="收获与反思"><a href="#收获与反思" class="headerlink" title="收获与反思"></a>收获与反思</h1><ul><li>注意边界条件</li><li>注意dp数组的初始化</li></ul>]]></content>
    
    
    <categories>
      
      <category>Computer Science</category>
      
      <category>ACM</category>
      
      <category>POJ</category>
      
    </categories>
    
    
    <tags>
      
      <tag>ACM</tag>
      
      <tag>POJ</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>【CSU-1592】解题报告（区间DP入门）</title>
    <link href="/post/c6d76e9a.html"/>
    <url>/post/c6d76e9a.html</url>
    
    <content type="html"><![CDATA[<h1 id="原始题目"><a href="#原始题目" class="headerlink" title="原始题目"></a>原始题目</h1><h2 id="1592-石子归并"><a href="#1592-石子归并" class="headerlink" title="1592: 石子归并"></a>1592: 石子归并</h2><ul><li>Time Limit: 1 Sec     </li><li>Memory Limit: 128 Mb     </li><li>Submitted: 896     </li><li>Solved: 421    </li></ul><h3 id="Description"><a href="#Description" class="headerlink" title="Description"></a>Description</h3><p>现在有$n$堆石子，第$i$堆有$a_i$个石子。现在要把这些石子合并成一堆，每次只能合并相邻两个，每次合并的代价是两堆石子的总石子数。求合并所有石子的最小代价。<br><a id="more"></a></p><h3 id="Input"><a href="#Input" class="headerlink" title="Input"></a>Input</h3><p>第一行包含一个整数$T ( T \le 50) $ ，表示数据组数。</p><p>每组数据第一行包含一个整数$ n ( 2 \le n \le 100 ) $，表示石子的堆数。</p><p>第二行包含$n$个正整数$ a_i  ( a_i  \le 100)$，表示每堆石子的石子数。</p><h3 id="Output"><a href="#Output" class="headerlink" title="Output"></a>Output</h3><p>每组数据仅一行，表示最小合并代价。</p><h3 id="Sample-Input"><a href="#Sample-Input" class="headerlink" title="Sample Input"></a>Sample Input</h3><pre><code>241 2 3 453 5 2 1 4</code></pre><h3 id="Sample-Output"><a href="#Sample-Output" class="headerlink" title="Sample Output"></a>Sample Output</h3><pre><code>1933</code></pre><h3 id="Hint"><a href="#Hint" class="headerlink" title="Hint"></a>Hint</h3><h3 id="Source"><a href="#Source" class="headerlink" title="Source"></a>Source</h3><p>国防科学技术大学第十八届银河之光文化节ACM程序设计竞赛初赛</p><h1 id="题目大意"><a href="#题目大意" class="headerlink" title="题目大意"></a>题目大意</h1><p>如题</p><h1 id="解题思路"><a href="#解题思路" class="headerlink" title="解题思路"></a>解题思路</h1><ul><li><p>区间dp</p></li><li><p>状态转移方程：$dp[i][j]=min(dp[i][j],dp[i][i+k]+dp[i+k+1][j]+sum[j]-sum[i-1])$;</p></li></ul><h1 id="解题代码"><a href="#解题代码" class="headerlink" title="解题代码"></a>解题代码</h1><pre><code class="hljs C++"><span class="hljs-meta">#<span class="hljs-meta-keyword">include</span> <span class="hljs-meta-string">&lt;vector&gt;</span></span><span class="hljs-meta">#<span class="hljs-meta-keyword">include</span> <span class="hljs-meta-string">&lt;queue&gt;</span></span><span class="hljs-meta">#<span class="hljs-meta-keyword">include</span> <span class="hljs-meta-string">&lt;cstdio&gt;</span></span><span class="hljs-meta">#<span class="hljs-meta-keyword">include</span> <span class="hljs-meta-string">&lt;cstring&gt;</span></span><span class="hljs-meta">#<span class="hljs-meta-keyword">include</span> <span class="hljs-meta-string">&lt;cstdlib&gt;</span></span><span class="hljs-meta">#<span class="hljs-meta-keyword">include</span> <span class="hljs-meta-string">&lt;iostream&gt;</span></span><span class="hljs-meta">#<span class="hljs-meta-keyword">include</span> <span class="hljs-meta-string">&lt;algorithm&gt;</span></span><span class="hljs-comment">//#include &lt;bits/stdc++.h&gt;</span><span class="hljs-meta">#<span class="hljs-meta-keyword">define</span> ms(i,a) memset((i),(a),sizeof(i))</span><span class="hljs-meta">#<span class="hljs-meta-keyword">define</span> rep(i,a,n) for (int i=a;i&lt;n;i++)</span><span class="hljs-meta">#<span class="hljs-meta-keyword">define</span> per(i,a,n) for (int i=n-1;i&gt;=a;i--)</span><span class="hljs-meta">#<span class="hljs-meta-keyword">define</span> pb push_back</span><span class="hljs-meta">#<span class="hljs-meta-keyword">define</span> mp make_pair</span><span class="hljs-meta">#<span class="hljs-meta-keyword">define</span> np next_permutation</span><span class="hljs-meta">#<span class="hljs-meta-keyword">define</span> all(x) x.begin(),x.end()</span><span class="hljs-meta">#<span class="hljs-meta-keyword">define</span> fi first</span><span class="hljs-meta">#<span class="hljs-meta-keyword">define</span> se second</span><span class="hljs-meta">#<span class="hljs-meta-keyword">define</span> SZ(x) ((int)(x).size()) </span><span class="hljs-meta">#<span class="hljs-meta-keyword">define</span> INF 0x3f3f3f3f</span><span class="hljs-keyword">using</span> <span class="hljs-keyword">namespace</span> <span class="hljs-built_in">std</span>;<span class="hljs-keyword">int</span> n,t,m; <span class="hljs-keyword">int</span> dp[<span class="hljs-number">105</span>][<span class="hljs-number">105</span>],sum[<span class="hljs-number">105</span>]; <span class="hljs-comment">//前缀和 </span><span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">initial</span><span class="hljs-params">()</span></span>&#123;rep(i,<span class="hljs-number">1</span>,n+<span class="hljs-number">1</span>)&#123;        rep(j,<span class="hljs-number">1</span>,n+<span class="hljs-number">1</span>)&#123;            <span class="hljs-keyword">if</span>(i==j) dp[i][j]=<span class="hljs-number">0</span>;            <span class="hljs-keyword">else</span> dp[i][j]=INF;    &#125;    &#125; &#125;<span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span>&#123;ios::sync_with_stdio(<span class="hljs-literal">false</span>);    <span class="hljs-built_in">cin</span>&gt;&gt;t;    <span class="hljs-keyword">while</span>(t--)    &#123;        <span class="hljs-built_in">cin</span>&gt;&gt;n;        sum[<span class="hljs-number">0</span>]=<span class="hljs-number">0</span>;         rep(i,<span class="hljs-number">1</span>,n+<span class="hljs-number">1</span>)&#123;        <span class="hljs-built_in">cin</span>&gt;&gt;m;        sum[i]=sum[i<span class="hljs-number">-1</span>]+m;&#125;       initial();        <span class="hljs-keyword">for</span>(<span class="hljs-keyword">int</span> len=<span class="hljs-number">1</span>; len&lt;n; len++)         &#123;            <span class="hljs-keyword">for</span>(<span class="hljs-keyword">int</span> i=<span class="hljs-number">1</span>; i+len&lt;=n; i++)             &#123;                <span class="hljs-keyword">int</span> j=i+len;                <span class="hljs-keyword">for</span>(<span class="hljs-keyword">int</span> k=<span class="hljs-number">0</span>; i+k&lt;j; k++)                     dp[i][j]=min(dp[i][j],dp[i][i+k]+dp[i+k+<span class="hljs-number">1</span>][j]+sum[j]-sum[i<span class="hljs-number">-1</span>]);            &#125;        &#125;        <span class="hljs-built_in">cout</span>&lt;&lt;dp[<span class="hljs-number">1</span>][n]&lt;&lt;<span class="hljs-built_in">endl</span>;    &#125;    <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;&#125;</code></pre><h1 id="收获与反思"><a href="#收获与反思" class="headerlink" title="收获与反思"></a>收获与反思</h1><ul><li>对于求区间问题最优解，考虑区间dp</li></ul>]]></content>
    
    
    <categories>
      
      <category>Computer Science</category>
      
      <category>ACM</category>
      
      <category>CSU</category>
      
    </categories>
    
    
    <tags>
      
      <tag>ACM</tag>
      
      <tag>CSU</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>【HDU-1789】解题报告（贪心，多种思路）</title>
    <link href="/post/9f8e212d.html"/>
    <url>/post/9f8e212d.html</url>
    
    <content type="html"><![CDATA[<h1 id="原始题目"><a href="#原始题目" class="headerlink" title="原始题目"></a>原始题目</h1><h2 id="Doing-Homework-again"><a href="#Doing-Homework-again" class="headerlink" title="Doing Homework again"></a>Doing Homework again</h2><ul><li>Time Limit: 1000/1000 MS (Java/Others)    </li><li>Memory Limit: 32768/32768 K (Java/Others)</li><li>Total Submission(s): 17643    </li><li>Accepted Submission(s): 10264</li></ul><h3 id="Problem-Description"><a href="#Problem-Description" class="headerlink" title="Problem Description"></a>Problem Description</h3><p>Ignatius has just come back school from the 30th ACM/ICPC. Now he has a lot of homework to do. Every teacher gives him a deadline of handing in the homework. If Ignatius hands in the homework after the deadline, the teacher will reduce his score of the final test. And now we assume that doing everyone homework always takes one day. So Ignatius wants you to help him to arrange the order of doing homework to minimize the reduced score.<br> <a id="more"></a></p><h3 id="Input"><a href="#Input" class="headerlink" title="Input"></a>Input</h3><p>The input contains several test cases. The first line of the input is a single integer T that is the number of test cases. T test cases follow.<br>Each test case start with a positive integer N(1≤N≤1000) which indicate the number of homework.. Then 2 lines follow. The first line contains N integers that indicate the deadlines of the subjects, and the next line contains N integers that indicate the reduced scores.</p><h3 id="Output"><a href="#Output" class="headerlink" title="Output"></a>Output</h3><p>For each test case, you should output the smallest total reduced score, one line per test case.</p><h3 id="Sample-Input"><a href="#Sample-Input" class="headerlink" title="Sample Input"></a>Sample Input</h3><pre><code>333 3 310 5 131 3 16 2 371 4 6 4 2 4 33 2 1 7 6 5 4</code></pre><h3 id="Sample-Output"><a href="#Sample-Output" class="headerlink" title="Sample Output"></a>Sample Output</h3><pre><code>035</code></pre><h3 id="Author"><a href="#Author" class="headerlink" title="Author"></a>Author</h3><p>lcy</p><h3 id="Source"><a href="#Source" class="headerlink" title="Source"></a>Source</h3><p>2007省赛集训队练习赛（10）_以此感谢DOOMIII</p><h3 id="Recommend"><a href="#Recommend" class="headerlink" title="Recommend"></a>Recommend</h3><p>lcy</p><h1 id="题目大意"><a href="#题目大意" class="headerlink" title="题目大意"></a>题目大意</h1><ul><li>某同学参加完比赛回来补作业，每种作业有ddl天数和扣分值。想让总扣分值尽量少，输出最小值。</li></ul><h1 id="解题思路"><a href="#解题思路" class="headerlink" title="解题思路"></a>解题思路</h1><ul><li>思路1：贪心，按分值从大到小排序，对于每份作业优先从ddl天向前安排，如果所有天都安排满了，那么ans加上该作业的扣分值（合理性：先安排的作业扣分值一定更大）</li><li>思路2：贪心+优先队列，按时间从小到大排序，按天数递增安排作业，可安排则将扣分值入队，如果安排满了，那么</li></ul>]]></content>
    
    
    <categories>
      
      <category>Computer Science</category>
      
      <category>ACM</category>
      
      <category>HDU</category>
      
    </categories>
    
    
    <tags>
      
      <tag>ACM</tag>
      
      <tag>HDU</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>【CSU-1588】解题报告（贪心，水题）</title>
    <link href="/post/8ddc8a30.html"/>
    <url>/post/8ddc8a30.html</url>
    
    <content type="html"><![CDATA[<h1 id="原始题目"><a href="#原始题目" class="headerlink" title="原始题目"></a>原始题目</h1><h2 id="1588-合并果子"><a href="#1588-合并果子" class="headerlink" title="1588: 合并果子"></a>1588: 合并果子</h2><ul><li>Time Limit: 1 Sec     </li><li>Memory Limit: 128 Mb     </li><li>Submitted: 1907     </li><li>Solved: 906    </li></ul><h3 id="Description"><a href="#Description" class="headerlink" title="Description"></a>Description</h3><p>现在有$n$堆果子，第$i$堆有 $a_i$个果子。现在要把这些果子合并成一堆，每次合并的代价是两堆果子的总果子数。求合并所有果子的最小代价。<br><a id="more"></a></p><h3 id="Input"><a href="#Input" class="headerlink" title="Input"></a>Input</h3><p>第一行包含一个整数$T(T \le 50)$，表示数据组数。</p><p>每组数据第一行包含一个整数$ n( 2 \le n \le 1000 )$ ，表示果子的堆数。</p><p>第二行包含$n$个正整数$a_i ( a_i \le 100) $，表示每堆果子的果子数。</p><h3 id="Output"><a href="#Output" class="headerlink" title="Output"></a>Output</h3><p>每组数据仅一行，表示最小合并代价。</p><h3 id="Sample-Input"><a href="#Sample-Input" class="headerlink" title="Sample Input"></a>Sample Input</h3><pre><code>241 2 3 453 5 2 1 4</code></pre><h3 id="Sample-Output"><a href="#Sample-Output" class="headerlink" title="Sample Output"></a>Sample Output</h3><pre><code>1933</code></pre><h3 id="Hint"><a href="#Hint" class="headerlink" title="Hint"></a>Hint</h3><h3 id="Source"><a href="#Source" class="headerlink" title="Source"></a>Source</h3><p>国防科学技术大学第十八届银河之光文化节ACM程序设计竞赛初赛</p><h1 id="题目大意"><a href="#题目大意" class="headerlink" title="题目大意"></a>题目大意</h1><p>如题</p><h1 id="解题思路"><a href="#解题思路" class="headerlink" title="解题思路"></a>解题思路</h1><ul><li>贪心，优先队列，每次取顶上两堆果子。</li></ul><h1 id="解题代码"><a href="#解题代码" class="headerlink" title="解题代码"></a>解题代码</h1><pre><code class="hljs C++"><span class="hljs-comment">//#include &lt;bits/stdc++.h&gt;</span><span class="hljs-meta">#<span class="hljs-meta-keyword">include</span> <span class="hljs-meta-string">&lt;cstdio&gt;</span></span><span class="hljs-meta">#<span class="hljs-meta-keyword">include</span> <span class="hljs-meta-string">&lt;cmath&gt;</span></span><span class="hljs-meta">#<span class="hljs-meta-keyword">include</span> <span class="hljs-meta-string">&lt;cstdlib&gt;</span></span><span class="hljs-meta">#<span class="hljs-meta-keyword">include</span> <span class="hljs-meta-string">&lt;cstring&gt;</span></span><span class="hljs-meta">#<span class="hljs-meta-keyword">include</span> <span class="hljs-meta-string">&lt;iostream&gt;</span></span><span class="hljs-meta">#<span class="hljs-meta-keyword">include</span> <span class="hljs-meta-string">&lt;set&gt;</span></span><span class="hljs-meta">#<span class="hljs-meta-keyword">include</span> <span class="hljs-meta-string">&lt;iomanip&gt;</span></span><span class="hljs-meta">#<span class="hljs-meta-keyword">include</span> <span class="hljs-meta-string">&lt;algorithm&gt;</span></span><span class="hljs-meta">#<span class="hljs-meta-keyword">include</span> <span class="hljs-meta-string">&lt;queue&gt;</span></span><span class="hljs-meta">#<span class="hljs-meta-keyword">include</span> <span class="hljs-meta-string">&lt;map&gt;</span></span><span class="hljs-meta">#<span class="hljs-meta-keyword">include</span> <span class="hljs-meta-string">&lt;string&gt;</span></span><span class="hljs-meta">#<span class="hljs-meta-keyword">define</span> INF 0x3f3f3f3f</span><span class="hljs-meta">#<span class="hljs-meta-keyword">define</span> rep(i,a,n) for(int i=a;i&lt;n;i++)</span><span class="hljs-meta">#<span class="hljs-meta-keyword">define</span> per(i,a,n) for(int i=n-1;i&gt;=a;i--)</span><span class="hljs-keyword">using</span> <span class="hljs-keyword">namespace</span> <span class="hljs-built_in">std</span>;<span class="hljs-keyword">const</span> <span class="hljs-keyword">int</span> maxn=<span class="hljs-number">1e5</span>+<span class="hljs-number">5</span>; <span class="hljs-keyword">typedef</span> <span class="hljs-keyword">long</span> <span class="hljs-keyword">long</span> ll;ll t,n,a[maxn];priority_queue&lt;ll, <span class="hljs-built_in">vector</span>&lt;ll&gt;, greater&lt;ll&gt; &gt; pq;<span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span>&#123;ios::sync_with_stdio(<span class="hljs-literal">false</span>);<span class="hljs-keyword">int</span> t;<span class="hljs-built_in">cin</span>&gt;&gt;t;<span class="hljs-keyword">while</span>(t--)&#123;<span class="hljs-keyword">while</span>(!pq.empty()) pq.pop();<span class="hljs-keyword">int</span> n; ll sum=<span class="hljs-number">0</span>,sum1,a;<span class="hljs-built_in">cin</span>&gt;&gt;n;rep(i,<span class="hljs-number">0</span>,n)&#123;<span class="hljs-built_in">cin</span>&gt;&gt;a;pq.push(a);&#125;<span class="hljs-keyword">while</span>(!pq.empty())&#123;sum1=pq.top();pq.pop();sum1+=pq.top();pq.pop();<span class="hljs-keyword">if</span>(pq.empty())&#123;<span class="hljs-comment">//cout&lt;&lt;"empty"&lt;&lt;sum1&lt;&lt;endl;</span>sum+=sum1;<span class="hljs-keyword">break</span>;&#125;<span class="hljs-keyword">else</span>&#123;sum+=sum1;<span class="hljs-comment">//cout&lt;&lt;"get"&lt;&lt;sum1&lt;&lt;endl;</span>pq.push(sum1);&#125;  &#125;<span class="hljs-built_in">cout</span>&lt;&lt;sum&lt;&lt;<span class="hljs-built_in">endl</span>;&#125;&#125;</code></pre><h1 id="收获与反思"><a href="#收获与反思" class="headerlink" title="收获与反思"></a>收获与反思</h1><p>水题</p>]]></content>
    
    
    <categories>
      
      <category>Computer Science</category>
      
      <category>ACM</category>
      
      <category>CSU</category>
      
    </categories>
    
    
    <tags>
      
      <tag>ACM</tag>
      
      <tag>CSU</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>【HDU-6325】解题报告（计算几何，2018杭电多校第三场）</title>
    <link href="/post/264a9c89.html"/>
    <url>/post/264a9c89.html</url>
    
    <content type="html"><![CDATA[<h1 id="原始题目"><a href="#原始题目" class="headerlink" title="原始题目"></a>原始题目</h1><h2 id="Problem-G-Interstellar-Travel"><a href="#Problem-G-Interstellar-Travel" class="headerlink" title="Problem G. Interstellar Travel"></a>Problem G. Interstellar Travel</h2><ul><li>Time Limit: 4000/2000 MS (Java/Others)    </li><li>Memory Limit: 524288/524288 K (Java/Others)</li><li>Total Submission(s): 638    </li><li>Accepted Submission(s): 137</li></ul><h3 id="Problem-Description"><a href="#Problem-Description" class="headerlink" title="Problem Description"></a>Problem Description</h3><p>After trying hard for many years, Little Q has finally received an astronaut license. To celebrate the fact, he intends to buy himself a spaceship and make an interstellar travel.</p><p>Little Q knows the position of $n$ planets in space, labeled by $1$ to $n$. To his surprise, these planets are all coplanar. So to simplify, Little Q put these $n$ planets on a plane coordinate system, and calculated the coordinate of each planet $(x_i,y_i)$.</p><p>Little Q plans to start his journey at the $1$-th planet, and end at the $n$-th planet. When he is at the $i$-th planet, he can next fly to the $j$-th planet only if $x_i&lt;x_j$, which will cost his spaceship $x_i\times y_j-x_j\times y_i$ units of energy. Note that this cost can be negative, it means the flight will supply his spaceship.</p><p>Please write a program to help Little Q find the best route with minimum total cost.<br><a id="more"></a></p><h3 id="Input"><a href="#Input" class="headerlink" title="Input"></a>Input</h3><p>The first line of the input contains an integer $T(1\leq T\leq10)$, denoting the number of test cases.</p><p>In each test case, there is an integer $n(2\leq n\leq 200000)$ in the first line, denoting the number of planets.</p><p>For the next n lines, each line contains $2$ integers $x_i,y_i(0\leq x_i,y_i\leq 10^9)$, denoting the coordinate of the i-th planet. Note that different planets may have the same coordinate because they are too close to each other. It is guaranteed that $y_1=y_n=0,0=x_1&lt;x_2,x_3,…,x_{n-1}&lt;x_n$.</p><h3 id="Output"><a href="#Output" class="headerlink" title="Output"></a>Output</h3><p>For each test case, print a single line containing several distinct integers $p_1,p_2,…,p_m(1\leq p_i\leq n)$, denoting the route you chosen is $p_1\rightarrow p_2\rightarrow…\rightarrow p_{m-1}\rightarrow p_m$. Obviously $p_1$ should be $1$ and $p_m$ should be $n$. You should choose the route with minimum total cost. If there are multiple best routes, please choose the one with the smallest lexicographically.</p><p>A sequence of integers $a$ is lexicographically smaller than $a$ sequence of $b$ if there exists such index $j$ that $a_i=b_i$ for all $i&lt;j$, but $a_j&lt;b_j$.</p><h3 id="Sample-Input"><a href="#Sample-Input" class="headerlink" title="Sample Input"></a>Sample Input</h3><pre><code>130 03 04 0</code></pre><h3 id="Sample-Output"><a href="#Sample-Output" class="headerlink" title="Sample Output"></a>Sample Output</h3><pre><code>1 2 3</code></pre><h3 id="Source"><a href="#Source" class="headerlink" title="Source"></a>Source</h3><p>2018 Multi-University Training Contest 3</p><h3 id="Recommend"><a href="#Recommend" class="headerlink" title="Recommend"></a>Recommend</h3><p>chendu</p><h1 id="题目大意"><a href="#题目大意" class="headerlink" title="题目大意"></a>题目大意</h1><ul><li>给了$n$个星球的横纵坐标，从第一个星球旅行到第n个星球，消耗的燃料是叉积（可能为负）</li><li>已知$y_1=y_n=0,0=x_1&lt;x_2,x_3,…,x_{n-1}&lt;x_n$，每次旅行下一个星球的$x$坐标要大于上一个星球。</li><li>求消耗燃料的最小值，输出字典序最小的满足条件的访问顺序。</li></ul><h1 id="解题思路"><a href="#解题思路" class="headerlink" title="解题思路"></a>解题思路</h1><ul><li>即求从第一个点到第n个星球的上半凸包（有向面积最小，负最大）</li><li>三点共线和同点的时候要满足字典序最小的要求。 共线时判断中间点字典序是不是小于后点，共点时保留序列最小的。</li></ul><h1 id="解题代码"><a href="#解题代码" class="headerlink" title="解题代码"></a>解题代码</h1><pre><code class="hljs C++">#include &lt;bits/stdc++.h&gt;using namespace std;#define rep(i,a,n) for (int i=a;i&lt;n;i++)#define per(i,a,n) for (int i=n-1;i&gt;=a;i--)#define pb push_back#define mp make_pair#define np next_permutation#define all(x) x.begin(),x.end()#define fi first#define se second#define SZ(x) ((int)(x).size()) const int maxn=2e5+5;const double eps=1e-9;typedef long long ll;ll n,cnt;//有的命名为sgn函数，高精度符号判断 ll dcmp(double x)&#123;//相等函数判断，减少精度问题 if(fabs(x)&lt;eps) return 0;else return x&lt;0?-1:1;&#125;//点的定义 class Point&#123;public:ll x,y;Point (ll x=0,double y=0):x(x),y(y)&#123;&#125; //构造函数，方便代码的编写 &#125;; typedef Point Vector;// 从程序实现上，Vector只是Point的别名//运算符重载 //向量+向量=向量，点+向量=点Vector operator + (const Vector &amp;A,const Vector &amp;B) &#123; return Vector(A.x+B.x,A.y+B.y); &#125;//向量-向量=向量，点-向量-点 Vector operator - (const Vector &amp;A,const Vector &amp;B) &#123; return Vector(A.x-B.x,A.y-B.y); &#125;//向量*数=向量 （数乘） Vector operator * (const Vector &amp;A,double p) &#123; return Vector(A.x*p,A.y*p); &#125;//向量/数=向量 （数除） Vector operator / (const Vector &amp;A,double p) &#123; return Vector(A.x/p,A.y/p); &#125;//向量（点乘）向量=数  （点乘）double operator * (const Vector &amp;A,const Vector &amp;B) &#123; return A.x*B.x+A.y*B.y; &#125;double dot(const Vector &amp;A,const Vector &amp;B)&#123; return A.x*B.x+A.y*B.y; &#125;//向量（叉乘）向量=向量 （叉乘） double operator ^ (const Vector &amp;A,const Vector &amp;B)&#123; return A.x*B.y-A.y*B.x; &#125;ll cross(const Vector &amp;A,const Vector &amp;B)&#123; return A.x*B.y-A.y*B.x; &#125;//计算向量模长 double abs(const Vector &amp;A)&#123; return sqrt(dot(A,A));&#125;//计算平行四边形方向面积double area2(const Point &amp;A,const Point &amp;B,const Point &amp;C)&#123; return cross(B-A,C-A) ;&#125;  //按x值递增排序 bool operator &lt; (const Point &amp;A,const Point &amp;B) &#123; return A.x==B.x?A.y&lt;B.y:A.x&lt;B.x; &#125; //判定两个点是否相同，用到dcmp精度判定 bool operator == (const Point &amp;A,const Point &amp;B) &#123; return dcmp(A.x-B.x)==0&amp;&amp; dcmp(A.y-B.y)==0; &#125; //向量旋转Vector rotate(Vector A,double rad) &#123; return Vector(A.x*cos(rad)-A.y*sin(rad),A.x*sin(rad)+A.y*cos(rad));&#125;//计算单位法线，左转90Vector normal(Vector A)&#123;double l=abs(A);return Vector(-A.y/l,A.x/l);&#125; //线段定义 class Line &#123;public:Point s,e;Line()&#123;&#125;Line(Point _s,Point _e)&#123;s=_s;e=_e;&#125;&#125;line[maxn];//判断两线段是否相交 bool inter(Line l1,Line l2)&#123;//cout&lt;&lt;"L1  "&lt;&lt;l1.e.x&lt;&lt;","&lt;&lt;l1.e.y&lt;&lt;"   "&lt;&lt;l1.s.x&lt;&lt;","&lt;&lt;l1.s.y&lt;&lt;endl;//cout&lt;&lt;"L2  "&lt;&lt;l2.e.x&lt;&lt;","&lt;&lt;l2.e.y&lt;&lt;"   "&lt;&lt;l2.s.x&lt;&lt;","&lt;&lt;l2.s.y&lt;&lt;endl;return (//根据题目要求端点相交是否算作相交来决定大于等于和小于等于 //排斥实验 max(l1.s.x,l1.e.x)&gt;=min(l2.s.x,l2.e.x) &amp;&amp;max(l2.s.x,l2.e.x)&gt;=min(l1.s.x,l1.e.x) &amp;&amp;max(l1.s.y,l1.e.y)&gt;=min(l2.s.y,l2.e.y) &amp;&amp;max(l2.s.y,l2.e.y)&gt;=min(l1.s.y,l1.e.y) &amp;&amp;//跨立实验 dcmp((l2.s-l1.s)^(l1.s-l1.e))*dcmp((l2.e-l1.s)^(l1.s-l1.e))&lt;0 &amp;&amp;dcmp((l1.s-l2.s)^(l2.s-l2.e))*dcmp((l1.e-l2.s)^(l2.s-l2.e))&lt;0) ;&#125;bool inter(Point a1,Point a2,Point b1,Point b2)&#123;Line l1(a1,a2),l2(b1,b2);return inter(l1,l2);&#125;//求两直线交点Point getinter(Line l1,Line l2)&#123;Vector v=l1.s-l1.e;Vector w=l2.s-l2.e;Vector u=l1.e-l2.e;double t=cross(w,u)/cross(v,w);return l1.e+v*t;&#125; Point getinter(Point a1,Point a2,Point b1,Point b2)&#123;Line l1(a1,a2);Line l2(b1,b2);return getinter(l1,l2);&#125;//判定点和线段的关系，//0:不在线段所在直线上//1:在线段内（不含端点） //2:在线段端点//3:在线段两侧的射线上 ll  online(Point a,Line l)&#123;if(dcmp(cross(l.s-a,l.e-a))!=0) return 0;double pans=dcmp(dot(l.s-a,l.e-a));//cout&lt;&lt;(l.s-a).x&lt;&lt;","&lt;&lt;(l.s-a).y&lt;&lt;"   "&lt;&lt;(l.e-a).x&lt;&lt;","&lt;&lt;(l.e-a).y&lt;&lt;endl;if(pans&lt;0) return 1;else if(pans==0) return 2;else if(pans&gt;0) return 3;&#125;ll online(Point a,Point b1,Point b2)&#123;Line l(b1,b2);return online(a,l);&#125;class node&#123;public:ll index;Point p;&#125; point[maxn],ans[maxn],pre[maxn];bool cmp(node a, node b)&#123;if(a.p.x==b.p.x)&#123;if(a.p.y==b.p.y) return a.index&gt;b.index;return a.p.y&lt;b.p.y;&#125;else &#123;return a.p.x&lt;b.p.x;&#125;&#125;ll ConvexHull()&#123;ll flag=0;ll m=0;for(ll i=1;i&lt;=cnt;i++)&#123;if(!flag &amp;&amp; point[i].index!=1) continue;if(point[i].index==1)&#123;flag=1;&#125;while(m&gt;1 &amp;&amp; cross(ans[m-1].p-ans[m-2].p,point[i].p-ans[m-2].p)&gt;=0) &#123;if(m&gt;1 &amp;&amp; cross(ans[m-1].p-ans[m-2].p,point[i].p-ans[m-2].p)==0)&#123;//判断字典序if(point[i].index&lt;ans[m-1].index) m--;else break;&#125;else if(m&gt;1 &amp;&amp; cross(ans[m-1].p-ans[m-2].p,point[i].p-ans[m-2].p)&gt;0)&#123;m--;&#125;&#125;ans[m].p=point[i].p;ans[m].index=point[i].index;//cout&lt;&lt;m&lt;&lt;"  ans.p=("&lt;&lt;ans[m].p.x&lt;&lt;","&lt;&lt;ans[m].p.y&lt;&lt;"   index="&lt;&lt;ans[m].index&lt;&lt;endl;//cout&lt;&lt;"$$$$"&lt;&lt;ans[m].index&lt;&lt;"     "&lt;&lt;n&lt;&lt;"$$$$"&lt;&lt;endl; m++;if(ans[m-1].index==n) break;//cout&lt;&lt;m&lt;&lt;"  ans.p=("&lt;&lt;ans[m].p.x&lt;&lt;","&lt;&lt;ans[m].p.y&lt;&lt;"   index="&lt;&lt;ans[m].index&lt;&lt;endl;&#125;return m;&#125;int main()&#123;ios::sync_with_stdio(false);ll t;cin&gt;&gt;t;while(t--)&#123;cin&gt;&gt;n;cnt=0;rep(i,1,n+1)&#123;cin&gt;&gt;pre[i].p.x&gt;&gt;pre[i].p.y;pre[i].index=i;&#125;sort(pre+1,pre+n+1,cmp);rep(i,1,n+1)&#123;if(i==1) point[++cnt]=pre[i];else if(pre[i].p.x==point[cnt].p.x) point[cnt]=pre[i];else point[++cnt]=pre[i];&#125;ll len=ConvexHull();rep(i,0,len)&#123;if(i==0) cout&lt;&lt;ans[i].index;else cout&lt;&lt;" "&lt;&lt;ans[i].index;&#125;cout&lt;&lt;endl;&#125;&#125; //1//7//1 1//3 5//3 1//1 3//2 4//7 2//9 1//2 //13//1 0 //3 5//3 1//2 4//5 3//4 6//2 4//7 2//6 13//9 1//3 0//10 1//11 0</code></pre><h1 id="收获与反思"><a href="#收获与反思" class="headerlink" title="收获与反思"></a>收获与反思</h1><ul><li>注意long long</li><li>可能出现共点情况，三点共线情况，都要考虑字典序的要求</li></ul>]]></content>
    
    
    <categories>
      
      <category>Computer Science</category>
      
      <category>ACM</category>
      
      <category>HDU</category>
      
    </categories>
    
    
    <tags>
      
      <tag>ACM</tag>
      
      <tag>HDU</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>【POJ-1654】解题报告（计算几何，longlong）</title>
    <link href="/post/98804e11.html"/>
    <url>/post/98804e11.html</url>
    
    <content type="html"><![CDATA[<h1 id="原始题目"><a href="#原始题目" class="headerlink" title="原始题目"></a>原始题目</h1><h2 id="Area"><a href="#Area" class="headerlink" title="Area"></a>Area</h2><ul><li>Time Limit: 1000MS        </li><li>Memory Limit: 10000K</li><li>Total Submissions: 21457        </li><li>Accepted: 5826</li></ul><h3 id="Description"><a href="#Description" class="headerlink" title="Description"></a>Description</h3><p>You are going to compute the area of a special kind of polygon. One vertex of the polygon is the origin of the orthogonal coordinate system. From this vertex, you may go step by step to the following vertexes of the polygon until back to the initial vertex. For each step you may go North, West, South or East with step length of 1 unit, or go Northwest, Northeast, Southwest or Southeast with step length of square root of 2. </p><p>For example, this is a legal polygon to be computed and its area is 2.5: </p><a id="more"></a><h3 id="Input"><a href="#Input" class="headerlink" title="Input"></a>Input</h3><p>The first line of input is an integer t (1 ≤ t ≤ 20), the number of the test polygons. Each of the following lines contains a string composed of digits 1-9 describing how the polygon is formed by walking from the origin. Here 8, 2, 6 and 4 represent North, South, East and West, while 9, 7, 3 and 1 denote Northeast, Northwest, Southeast and Southwest respectively. Number 5 only appears at the end of the sequence indicating the stop of walking. You may assume that the input polygon is valid which means that the endpoint is always the start point and the sides of the polygon are not cross to each other.Each line may contain up to 1000000 digits.</p><h3 id="Output"><a href="#Output" class="headerlink" title="Output"></a>Output</h3><p>For each polygon, print its area on a single line.</p><h3 id="Sample-Input"><a href="#Sample-Input" class="headerlink" title="Sample Input"></a>Sample Input</h3><pre><code>4582567256244865</code></pre><h3 id="Sample-Output"><a href="#Sample-Output" class="headerlink" title="Sample Output"></a>Sample Output</h3><pre><code>000.52</code></pre><h3 id="Source"><a href="#Source" class="headerlink" title="Source"></a>Source</h3><p>POJ Monthly—2004.05.15 Liu Rujia@POJ</p><h1 id="题目大意"><a href="#题目大意" class="headerlink" title="题目大意"></a>题目大意</h1><ul><li>在二维坐标系中点向8个方向移动，经过一系列移动后回到原点，并且边不相交（构成闭合的多边形），求其面积。</li></ul><h1 id="解题思路"><a href="#解题思路" class="headerlink" title="解题思路"></a>解题思路</h1><ul><li>由于坐标都是整数且很大，由于精度考虑，按照long long计算最后再除以2.</li></ul><h1 id="解题代码"><a href="#解题代码" class="headerlink" title="解题代码"></a>解题代码</h1><pre><code class="hljs C++">//计算几何模板，二维几何基础//使用印用注意避免直接在程序中调用构造函数构造无名对象。否则可能会导致程序出错 //#include &lt;bits/stdc++.h&gt;#include &lt;cstdio&gt;#include &lt;cmath&gt;#include &lt;cstdlib&gt;#include &lt;cstring&gt;#include &lt;iostream&gt;#include &lt;set&gt;#include &lt;iomanip&gt;#include &lt;algorithm&gt;#include &lt;queue&gt;#include &lt;map&gt;#include &lt;string&gt;#define INF 0x3f3f3f3f#define rep(i,a,n) for(int i=a;i&lt;n;i++)#define per(i,a,n) for(int i=n-1;i&gt;=a;i--)using namespace std;typedef long long ll;const double eps =1e-10;const int maxn=50;int n;//有的命名为sgn函数，高精度符号判断 int dcmp(double x)&#123;//相等函数判断，减少精度问题 if(fabs(x)&lt;eps) return 0;else return x&lt;0?-1:1;&#125;//点的定义 class Point&#123;public:ll x,y;Point (ll x=0,ll y=0):x(x),y(y)&#123;&#125; //构造函数，方便代码的编写 &#125;; typedef Point Vector;// 从程序实现上，Vector只是Point的别名//运算符重载 //向量+向量=向量，点+向量=点Vector operator + (const Vector &amp;A,const Vector &amp;B) &#123; return Vector(A.x+B.x,A.y+B.y); &#125;//向量-向量=向量，点-向量-点 Vector operator - (const Vector &amp;A,const Vector &amp;B) &#123; return Vector(A.x-B.x,A.y-B.y); &#125;//向量*数=向量 （数乘） Vector operator * (const Vector &amp;A,double p) &#123; return Vector(A.x*p,A.y*p); &#125;//向量/数=向量 （数除） Vector operator / (const Vector &amp;A,double p) &#123; return Vector(A.x/p,A.y/p); &#125;//向量（点乘）向量=数  （点乘）double operator * (const Vector &amp;A,const Vector &amp;B) &#123; return A.x*B.x+A.y*B.y; &#125;double dot(const Vector &amp;A,const Vector &amp;B)&#123; return A.x*B.x+A.y*B.y; &#125;//向量（叉乘）向量=向量 （叉乘） double operator ^ (const Vector &amp;A,const Vector &amp;B)&#123; return A.x*B.y-A.y*B.x; &#125;ll cross(const Vector &amp;A,const Vector &amp;B)&#123; return A.x*B.y-A.y*B.x; &#125;//计算向量模长 double abs(const Vector &amp;A)&#123; return sqrt(dot(A,A));&#125;//计算平行四边形方向面积double area2(const Point &amp;A,const Point &amp;B,const Point &amp;C)&#123; return cross(B-A,C-A) ;&#125;  //按x值递增排序 bool operator &lt; (const Point &amp;A,const Point &amp;B) &#123; return A.x==B.x?A.y&lt;B.y:A.x&lt;B.x; &#125; //判定两个点是否相同，用到dcmp精度判定 bool operator == (const Point &amp;A,const Point &amp;B) &#123; return dcmp(A.x-B.x)==0&amp;&amp; dcmp(A.y-B.y)==0; &#125; //向量旋转Vector rotate(Vector A,double rad) &#123; return Vector(A.x*cos(rad)-A.y*sin(rad),A.x*sin(rad)+A.y*cos(rad));&#125;//计算单位法线，左转90Vector normal(Vector A)&#123;double l=abs(A);return Vector(-A.y/l,A.x/l);&#125; //线段定义 class Line &#123;public:Point s,e;Line()&#123;&#125;Line(Point _s,Point _e)&#123;s=_s;e=_e;&#125;&#125;line[maxn];//判断两线段是否相交 bool inter(Line l1,Line l2)&#123;//cout&lt;&lt;"L1  "&lt;&lt;l1.e.x&lt;&lt;","&lt;&lt;l1.e.y&lt;&lt;"   "&lt;&lt;l1.s.x&lt;&lt;","&lt;&lt;l1.s.y&lt;&lt;endl;//cout&lt;&lt;"L2  "&lt;&lt;l2.e.x&lt;&lt;","&lt;&lt;l2.e.y&lt;&lt;"   "&lt;&lt;l2.s.x&lt;&lt;","&lt;&lt;l2.s.y&lt;&lt;endl;return (//根据题目要求端点相交是否算作相交来决定大于等于和小于等于 //排斥实验 max(l1.s.x,l1.e.x)&gt;=min(l2.s.x,l2.e.x) &amp;&amp;max(l2.s.x,l2.e.x)&gt;=min(l1.s.x,l1.e.x) &amp;&amp;max(l1.s.y,l1.e.y)&gt;=min(l2.s.y,l2.e.y) &amp;&amp;max(l2.s.y,l2.e.y)&gt;=min(l1.s.y,l1.e.y) &amp;&amp;//跨立实验 dcmp((l2.s-l1.s)^(l1.s-l1.e))*dcmp((l2.e-l1.s)^(l1.s-l1.e))&lt;0 &amp;&amp;dcmp((l1.s-l2.s)^(l2.s-l2.e))*dcmp((l1.e-l2.s)^(l2.s-l2.e))&lt;0) ;&#125;bool inter(Point a1,Point a2,Point b1,Point b2)&#123;Line l1(a1,a2),l2(b1,b2);return inter(l1,l2);&#125;//求两直线交点Point getinter(Line l1,Line l2)&#123;Vector v=l1.s-l1.e;Vector w=l2.s-l2.e;Vector u=l1.e-l2.e;double t=cross(w,u)/cross(v,w);return l1.e+v*t;&#125; Point getinter(Point a1,Point a2,Point b1,Point b2)&#123;Line l1(a1,a2);Line l2(b1,b2);return getinter(l1,l2);&#125;//判定点和线段的关系，//0:不在线段所在直线上//1:在线段内（不含端点） //2:在线段端点//3:在线段两侧的射线上 int  online(Point a,Line l)&#123;if(dcmp(cross(l.s-a,l.e-a))!=0) return 0;double pans=dcmp(dot(l.s-a,l.e-a));//cout&lt;&lt;(l.s-a).x&lt;&lt;","&lt;&lt;(l.s-a).y&lt;&lt;"   "&lt;&lt;(l.e-a).x&lt;&lt;","&lt;&lt;(l.e-a).y&lt;&lt;endl;if(pans&lt;0) return 1;else if(pans==0) return 2;else if(pans&gt;0) return 3;&#125;int online(Point a,Point b1,Point b2)&#123;Line l(b1,b2);return online(a,l);&#125;   int main()&#123;int t;cin&gt;&gt;t;while(t--)&#123;Point pnow(0,0),pnext(0,0);ll area=0;string s;cin&gt;&gt;s;int len=s.size();rep(i,0,len)&#123;pnow=pnext;switch(s[i])&#123;case '8': pnext.y++; break;case '2': pnext.y--; break;case '6': pnext.x++; break;case '4': pnext.x--; break;case '9': pnext.x++, pnext.y++; break;case '7': pnext.x--, pnext.y++; break;case '3': pnext.x++, pnext.y--; break;case '1': pnext.x--, pnext.y--; break;default: break;&#125;area+=cross(pnext,pnow);&#125;area=(area&lt;0?(0-area):area);if(area%2==0) cout&lt;&lt;area/2&lt;&lt;endl;else cout&lt;&lt;area/2&lt;&lt;".5"&lt;&lt;endl; &#125;&#125;</code></pre><h1 id="收获与反思"><a href="#收获与反思" class="headerlink" title="收获与反思"></a>收获与反思</h1><ul><li>整数坐标注意开long long。</li><li>多边形有向面积模板题。</li></ul>]]></content>
    
    
    <categories>
      
      <category>Computer Science</category>
      
      <category>ACM</category>
      
      <category>POJ</category>
      
    </categories>
    
    
    <tags>
      
      <tag>ACM</tag>
      
      <tag>POJ</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>【UVA-10652】解题报告（计算几何，凸包模板）</title>
    <link href="/post/57bfde8d.html"/>
    <url>/post/57bfde8d.html</url>
    
    <content type="html"><![CDATA[<h1 id="原始题目"><a href="#原始题目" class="headerlink" title="原始题目"></a>原始题目</h1><h2 id="Board-Wrapping"><a href="#Board-Wrapping" class="headerlink" title="Board Wrapping"></a>Board Wrapping</h2><a id="more"></a><h1 id="题目大意"><a href="#题目大意" class="headerlink" title="题目大意"></a>题目大意</h1><ul><li>给出平面直角坐标系n个长方形模具的中心点，长宽以及顺时针旋转角度，求一个能包含所有模具的最小多边形，并计算模具的面积占多边形面积的百分比。</li></ul><h1 id="解题思路"><a href="#解题思路" class="headerlink" title="解题思路"></a>解题思路</h1><ul><li>把长方形都看成四个点，则为凸包问题，求凸包面积以及长方形面积计算百分比即可。</li></ul><h1 id="解题代码"><a href="#解题代码" class="headerlink" title="解题代码"></a>解题代码</h1><pre><code class="hljs C++">//计算几何模板，二维几何基础//使用印用注意避免直接在程序中调用构造函数构造无名对象。否则可能会导致程序出错 #include &lt;bits/stdc++.h&gt;#include &lt;cstdio&gt;#include &lt;cmath&gt;#include &lt;cstdlib&gt;#include &lt;cstring&gt;#include &lt;iostream&gt;#include &lt;set&gt;#include &lt;iomanip&gt;#include &lt;algorithm&gt;#include &lt;queue&gt;#include &lt;map&gt;#include &lt;string&gt;#define INF 0x3f3f3f3f#define rep(i,a,n) for(int i=a;i&lt;n;i++)#define per(i,a,n) for(int i=n-1;i&gt;=a;i--)using namespace std;typedef long long ll;const double eps =1e-10;const int maxn=2500; //注意修改 int n;//有的命名为sgn函数，高精度符号判断 int dcmp(double x)&#123;//相等函数判断，减少精度问题 if(fabs(x)&lt;eps) return 0;else return x&lt;0?-1:1;&#125;//点的定义 class Point&#123;public:double x,y;Point (double x=0,double y=0):x(x),y(y)&#123;&#125; //构造函数，方便代码的编写 &#125;point[maxn],pafter[maxn]; typedef Point Vector;// 从程序实现上，Vector只是Point的别名//运算符重载 Vector operator + (const Vector &amp;A,const Vector &amp;B) &#123; return Vector(A.x+B.x,A.y+B.y); &#125; //向量+向量=向量，点+向量=点Vector operator - (const Vector &amp;A,const Vector &amp;B) &#123; return Vector(A.x-B.x,A.y-B.y); &#125; //向量-向量=向量，点-向量-点  Vector operator * (const Vector &amp;A,double p) &#123; return Vector(A.x*p,A.y*p); &#125;   //向量*数=向量 （数乘） Vector operator / (const Vector &amp;A,double p) &#123; return Vector(A.x/p,A.y/p); &#125;//向量/数=向量 （数除）double operator * (const Vector &amp;A,const Vector &amp;B) &#123; return A.x*B.x+A.y*B.y; &#125;//向量（点乘）向量=数  （点乘）bool operator &lt; (const Point &amp;A,const Point &amp;B) &#123; return A.x==B.x?A.y&lt;B.y:A.x&lt;B.x; &#125; //按x值递增排序 bool operator == (const Point &amp;A,const Point &amp;B) &#123; return dcmp(A.x-B.x)==0&amp;&amp; dcmp(A.y-B.y)==0; &#125; //判定两个点是否相同，用到dcmp精度判定 //点乘叉乘 double dot(const Vector &amp;A,const Vector &amp;B)&#123; return A.x*B.x+A.y*B.y; &#125;//向量（叉乘）向量=向量 （叉乘） double operator ^ (const Vector &amp;A,const Vector &amp;B)&#123; return A.x*B.y-A.y*B.x; &#125;double cross(const Vector &amp;A,const Vector &amp;B)&#123; return A.x*B.y-A.y*B.x; &#125;//模长面积 double abs(const Vector &amp;A)&#123; return sqrt(dot(A,A));&#125;//计算向量模长 double area2(const Point &amp;A,const Point &amp;B,const Point &amp;C)&#123; return cross(B-A,C-A) ;&#125; //计算平行四边形方向面积double PolygonArea(Point *p,int n) &#123; double area=0; rep(i,1,n-1)&#123;area+=cross(p[i]-p[0],p[i+1]-p[0]);&#125;return area/2.0; &#125;//计算多边形的有向面积//旋转Vector rotate(Vector A,double rad) &#123; return Vector(A.x*cos(rad)-A.y*sin(rad),A.x*sin(rad)+A.y*cos(rad));&#125;  //旋转rad弧度 Vector normal(Vector A)&#123;double l=abs(A);return Vector(-A.y/l,A.x/l);&#125; //计算单位法线，左转90double torad(double deg) &#123; return deg/180*acos(-1); &#125; //角度转弧度 //线段定义 class Line &#123;public:Point s,e;Line()&#123;&#125;Line(Point _s,Point _e)&#123;s=_s;e=_e;&#125;&#125;line[maxn];//判断两线段是否相交 bool inter(Line l1,Line l2)&#123;//cout&lt;&lt;"L1  "&lt;&lt;l1.e.x&lt;&lt;","&lt;&lt;l1.e.y&lt;&lt;"   "&lt;&lt;l1.s.x&lt;&lt;","&lt;&lt;l1.s.y&lt;&lt;endl;//cout&lt;&lt;"L2  "&lt;&lt;l2.e.x&lt;&lt;","&lt;&lt;l2.e.y&lt;&lt;"   "&lt;&lt;l2.s.x&lt;&lt;","&lt;&lt;l2.s.y&lt;&lt;endl;return (//根据题目要求端点相交是否算作相交来决定大于等于和小于等于 //排斥实验 max(l1.s.x,l1.e.x)&gt;=min(l2.s.x,l2.e.x) &amp;&amp;max(l2.s.x,l2.e.x)&gt;=min(l1.s.x,l1.e.x) &amp;&amp;max(l1.s.y,l1.e.y)&gt;=min(l2.s.y,l2.e.y) &amp;&amp;max(l2.s.y,l2.e.y)&gt;=min(l1.s.y,l1.e.y) &amp;&amp;//跨立实验 dcmp((l2.s-l1.s)^(l1.s-l1.e))*dcmp((l2.e-l1.s)^(l1.s-l1.e))&lt;0 &amp;&amp;dcmp((l1.s-l2.s)^(l2.s-l2.e))*dcmp((l1.e-l2.s)^(l2.s-l2.e))&lt;0) ;&#125;bool inter(Point a1,Point a2,Point b1,Point b2)&#123;Line l1(a1,a2),l2(b1,b2);return inter(l1,l2);&#125;bool cmp(Point a,Point b)&#123;if(a.x==b.x) return a.y&lt;b.y;else return a.x&lt;b.x;&#125;//求两直线交点Point getinter(Line l1,Line l2)&#123;Vector v=l1.s-l1.e;Vector w=l2.s-l2.e;Vector u=l1.e-l2.e;double t=cross(w,u)/cross(v,w);return l1.e+v*t;&#125; Point getinter(Point a1,Point a2,Point b1,Point b2)&#123;Line l1(a1,a2);Line l2(b1,b2);return getinter(l1,l2);&#125;//判定点和线段的关系，//0:不在线段所在直线上//1:在线段内（不含端点） //2:在线段端点//3:在线段两侧的射线上 int  online(Point a,Line l)&#123;if(dcmp(cross(l.s-a,l.e-a))!=0) return 0;double pans=dcmp(dot(l.s-a,l.e-a));//cout&lt;&lt;(l.s-a).x&lt;&lt;","&lt;&lt;(l.s-a).y&lt;&lt;"   "&lt;&lt;(l.e-a).x&lt;&lt;","&lt;&lt;(l.e-a).y&lt;&lt;endl;if(pans&lt;0) return 1;else if(pans==0) return 2;else if(pans&gt;0) return 3;&#125;int online(Point a,Point b1,Point b2)&#123;Line l(b1,b2);return online(a,l);&#125;//凸包int ConvexHull(Point *p,int n,Point *ch)&#123;sort(p,p+n,cmp);int m=0;for(int i=0;i&lt;n;i++)&#123;while(m&gt;1 &amp;&amp; cross(ch[m-1]-ch[m-2],p[i]-ch[m-2])&lt;=0) m--;ch[m++]=p[i];&#125;int k=m;for(int i=n-2;i&gt;=0;i--)&#123;while(m&gt;k &amp;&amp; cross(ch[m-1]-ch[m-2],p[i]-ch[m-2])&lt;=0) m--;ch[m++]=p[i];&#125;if(n&gt;1) m--;return m;&#125; int main()&#123;int t;ios::sync_with_stdio(false);cin&gt;&gt;t;while(t--)&#123;int n,pc=0;double area1=0;cin&gt;&gt;n;rep(i,0,n)&#123;double x,y,w,h,j,ang;cin&gt;&gt;x&gt;&gt;y&gt;&gt;w&gt;&gt;h&gt;&gt;j;Point o(x,y); //原始点ang=-torad(j);point[pc++]=o+rotate(Vector(w/2,h/2),ang);point[pc++]=o+rotate(Vector(-w/2,h/2),ang);point[pc++]=o+rotate(Vector(w/2,-h/2),ang);point[pc++]=o+rotate(Vector(-w/2,-h/2),ang);area1+= w*h; &#125;//for(int i=0;i&lt;pc;i++) cout&lt;&lt;point[i].x&lt;&lt;","&lt;&lt;point[i].y&lt;&lt;endl;int len=ConvexHull(point,pc,pafter);double area2 = PolygonArea(pafter,len);//cout&lt;&lt;"len="&lt;&lt;len&lt;&lt;"  area1="&lt;&lt;area1&lt;&lt;"  area2="&lt;&lt;area2&lt;&lt;endl;cout&lt;&lt;fixed&lt;&lt;setprecision(1)&lt;&lt;area1*100/area2&lt;&lt;" %"&lt;&lt;endl;&#125; &#125;</code></pre><h1 id="收获与反思"><a href="#收获与反思" class="headerlink" title="收获与反思"></a>收获与反思</h1><ul><li>凸包模板</li></ul>]]></content>
    
    
    <categories>
      
      <category>Computer Science</category>
      
      <category>ACM</category>
      
      <category>UVA</category>
      
    </categories>
    
    
    <tags>
      
      <tag>ACM</tag>
      
      <tag>UVA</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>【POJ-1269】解题报告（计算几何，直线相交求交点）</title>
    <link href="/post/fb2f630e.html"/>
    <url>/post/fb2f630e.html</url>
    
    <content type="html"><![CDATA[<h1 id="原始题目"><a href="#原始题目" class="headerlink" title="原始题目"></a>原始题目</h1><h2 id="Intersecting-Lines"><a href="#Intersecting-Lines" class="headerlink" title="Intersecting Lines"></a>Intersecting Lines</h2><ul><li>Time Limit: 1000MS        </li><li>Memory Limit: 10000K</li><li>Total Submissions: 18318        </li><li>Accepted: 7816</li></ul><h3 id="Description"><a href="#Description" class="headerlink" title="Description"></a>Description</h3><p>We all know that a pair of distinct points on a plane defines a line and that a pair of lines on a plane will intersect in one of three ways:<br>1) no intersection because they are parallel,<br>2) intersect in a line because they are on top of one another (i.e. they are the same line),<br>3) intersect in a point. In this problem you will use your algebraic knowledge to create a program that determines how and where two lines intersect. </p><p>Your program will repeatedly read in four points that define two lines in the x-y plane and determine how and where the lines intersect. All numbers required by this problem will be reasonable, say between -1000 and 1000. </p><a id="more"></a><h3 id="Input"><a href="#Input" class="headerlink" title="Input"></a>Input</h3><p>The first line contains an integer N between 1 and 10 describing how many pairs of lines are represented. The next N lines will each contain eight integers. These integers represent the coordinates of four points on the plane in the order x1y1x2y2x3y3x4y4. Thus each of these input lines represents two lines on the plane: the line through (x1,y1) and (x2,y2) and the line through (x3,y3) and (x4,y4). The point (x1,y1) is always distinct from (x2,y2). Likewise with (x3,y3) and (x4,y4).</p><h3 id="Output"><a href="#Output" class="headerlink" title="Output"></a>Output</h3><p>There should be N+2 lines of output. The first line of output should read INTERSECTING LINES OUTPUT. There will then be one line of output for each pair of planar lines represented by a line of input, describing how the lines intersect: none, line, or point. If the intersection is a point then your program should output the x and y coordinates of the point, correct to two decimal places. The final line of output should read “END OF OUTPUT”.</p><h3 id="Sample-Input"><a href="#Sample-Input" class="headerlink" title="Sample Input"></a>Sample Input</h3><pre><code>50 0 4 4 0 4 4 05 0 7 6 1 0 2 35 0 7 6 3 -6 4 -32 0 2 27 1 5 18 50 3 4 0 1 2 2 5</code></pre><h3 id="Sample-Output"><a href="#Sample-Output" class="headerlink" title="Sample Output"></a>Sample Output</h3><pre><code>INTERSECTING LINES OUTPUTPOINT 2.00 2.00NONELINEPOINT 2.00 5.00POINT 1.07 2.20END OF OUTPUT</code></pre><h3 id="Source"><a href="#Source" class="headerlink" title="Source"></a>Source</h3><p>Mid-Atlantic 1996</p><h1 id="题目大意"><a href="#题目大意" class="headerlink" title="题目大意"></a>题目大意</h1><p>给出n组两点确定的直线（不是线段），判断两条直线是平行，相交（给出交点）还是同一直线。</p><h1 id="解题思路"><a href="#解题思路" class="headerlink" title="解题思路"></a>解题思路</h1><ul><li>计算几何基础题</li><li>先求两向量$v_1,v_2$的cross（叉积），若为零则从两条直线的点各取一个构成向量$v_3$和原向量其中一个求叉积，若也为零说明共线，不为零说明平行</li><li>非上述则求交点，套模板公式即可</li></ul><h1 id="解题代码"><a href="#解题代码" class="headerlink" title="解题代码"></a>解题代码</h1><pre><code class="hljs C++">//计算几何模板，二维几何基础//使用印用注意避免直接在程序中调用构造函数构造无名对象。否则可能会导致程序出错 //#include &lt;bits/stdc++.h&gt;#include &lt;cstdio&gt;#include &lt;cmath&gt;#include &lt;cstdlib&gt;#include &lt;cstring&gt;#include &lt;iostream&gt;#include &lt;set&gt;#include &lt;iomanip&gt;#include &lt;algorithm&gt;#include &lt;queue&gt;#include &lt;map&gt;#include &lt;string&gt;#define INF 0x3f3f3f3f#define rep(i,a,n) for(int i=a;i&lt;n;i++)#define per(i,a,n) for(int i=n-1;i&gt;=a;i--)using namespace std;typedef long long ll;const double eps =1e-10;const int maxn=50;int n;//有的命名为sgn函数，高精度符号判断 int dcmp(double x)&#123;//相等函数判断，减少精度问题 if(fabs(x)&lt;eps) return 0;else return x&lt;0?-1:1;&#125;//点的定义 class Point&#123;public:double x,y;Point (double x=0,double y=0):x(x),y(y)&#123;&#125; //构造函数，方便代码的编写 &#125;point[maxn]; typedef Point Vector;// 从程序实现上，Vector只是Point的别名//运算符重载 Vector operator + (const Vector &amp;A,const Vector &amp;B) &#123; return Vector(A.x+B.x,A.y+B.y); &#125; //向量+向量=向量，点+向量=点Vector operator - (const Vector &amp;A,const Vector &amp;B) &#123; return Vector(A.x-B.x,A.y-B.y); &#125; //向量-向量=向量，点-向量-点  Vector operator * (const Vector &amp;A,double p) &#123; return Vector(A.x*p,A.y*p); &#125;   //向量*数=向量 （数乘） Vector operator / (const Vector &amp;A,double p) &#123; return Vector(A.x/p,A.y/p); &#125;//向量/数=向量 （数除）double operator * (const Vector &amp;A,const Vector &amp;B) &#123; return A.x*B.x+A.y*B.y; &#125;//向量（点乘）向量=数  （点乘）bool operator &lt; (const Point &amp;A,const Point &amp;B) &#123; return A.x==B.x?A.y&lt;B.y:A.x&lt;B.x; &#125; //按x值递增排序 bool operator == (const Point &amp;A,const Point &amp;B) &#123; return dcmp(A.x-B.x)==0&amp;&amp; dcmp(A.y-B.y)==0; &#125; //判定两个点是否相同，用到dcmp精度判定 //点乘叉乘 double dot(const Vector &amp;A,const Vector &amp;B)&#123; return A.x*B.x+A.y*B.y; &#125;//向量（叉乘）向量=向量 （叉乘） double operator ^ (const Vector &amp;A,const Vector &amp;B)&#123; return A.x*B.y-A.y*B.x; &#125;double cross(const Vector &amp;A,const Vector &amp;B)&#123; return A.x*B.y-A.y*B.x; &#125;//模长面积 double abs(const Vector &amp;A)&#123; return sqrt(dot(A,A));&#125;//计算向量模长 double area2(const Point &amp;A,const Point &amp;B,const Point &amp;C)&#123; return cross(B-A,C-A) ;&#125; //计算平行四边形方向面积double PolygonArea(Point *p,int n) &#123; double area=0; rep(i,1,n-1)&#123;area+=cross(p[i]-p[0],p[i+1]-p[0]);&#125;return area/2.0; &#125;//计算多边形的有向面积//旋转Vector rotate(Vector A,double rad) &#123; return Vector(A.x*cos(rad)-A.y*sin(rad),A.x*sin(rad)+A.y*cos(rad));&#125;  //旋转rad弧度 Vector normal(Vector A)&#123;double l=abs(A);return Vector(-A.y/l,A.x/l);&#125; //计算单位法线，左转90//线段定义 class Line &#123;public:Point s,e;Line()&#123;&#125;Line(Point _s,Point _e)&#123;s=_s;e=_e;&#125;&#125;line[maxn];//判断两线段是否相交 bool inter(Line l1,Line l2)&#123;//cout&lt;&lt;"L1  "&lt;&lt;l1.e.x&lt;&lt;","&lt;&lt;l1.e.y&lt;&lt;"   "&lt;&lt;l1.s.x&lt;&lt;","&lt;&lt;l1.s.y&lt;&lt;endl;//cout&lt;&lt;"L2  "&lt;&lt;l2.e.x&lt;&lt;","&lt;&lt;l2.e.y&lt;&lt;"   "&lt;&lt;l2.s.x&lt;&lt;","&lt;&lt;l2.s.y&lt;&lt;endl;return (//根据题目要求端点相交是否算作相交来决定大于等于和小于等于 //排斥实验 max(l1.s.x,l1.e.x)&gt;=min(l2.s.x,l2.e.x) &amp;&amp;max(l2.s.x,l2.e.x)&gt;=min(l1.s.x,l1.e.x) &amp;&amp;max(l1.s.y,l1.e.y)&gt;=min(l2.s.y,l2.e.y) &amp;&amp;max(l2.s.y,l2.e.y)&gt;=min(l1.s.y,l1.e.y) &amp;&amp;//跨立实验 dcmp((l2.s-l1.s)^(l1.s-l1.e))*dcmp((l2.e-l1.s)^(l1.s-l1.e))&lt;0 &amp;&amp;dcmp((l1.s-l2.s)^(l2.s-l2.e))*dcmp((l1.e-l2.s)^(l2.s-l2.e))&lt;0) ;&#125;bool inter(Point a1,Point a2,Point b1,Point b2)&#123;Line l1(a1,a2),l2(b1,b2);return inter(l1,l2);&#125;bool cmp(Point a,Point b)&#123;if(a.x==b.x) return a.y&lt;b.y;else return a.x&lt;b.x;&#125;//求两直线交点Point getinter(Line l1,Line l2)&#123;Vector v=l1.s-l1.e;Vector w=l2.s-l2.e;Vector u=l1.e-l2.e;double t=cross(w,u)/cross(v,w);return l1.e+v*t;&#125; Point getinter(Point a1,Point a2,Point b1,Point b2)&#123;Line l1(a1,a2);Line l2(b1,b2);return getinter(l1,l2);&#125;//判定点和线段的关系，//0:不在线段所在直线上//1:在线段内（不含端点） //2:在线段端点//3:在线段两侧的射线上 int  online(Point a,Line l)&#123;if(dcmp(cross(l.s-a,l.e-a))!=0) return 0;double pans=dcmp(dot(l.s-a,l.e-a));//cout&lt;&lt;(l.s-a).x&lt;&lt;","&lt;&lt;(l.s-a).y&lt;&lt;"   "&lt;&lt;(l.e-a).x&lt;&lt;","&lt;&lt;(l.e-a).y&lt;&lt;endl;if(pans&lt;0) return 1;else if(pans==0) return 2;else if(pans&gt;0) return 3;&#125;int online(Point a,Point b1,Point b2)&#123;Line l(b1,b2);return online(a,l);&#125;//凸包int ConvexHull(Point *p,int n,Point *ch)&#123;sort(p,p+n,cmp);int m=0;for(int i=0;i&lt;n;i++)&#123;while(m&gt;1 &amp;&amp; cross(ch[m-1]-ch[m-2],p[i]-ch[m-2])&lt;=0) m--;ch[m++]=p[i];&#125;int k=m;for(int i=n-2;i&gt;=0;i--)&#123;while(m&gt;k &amp;&amp; cross(ch[m-1]-ch[m-2],p[i]-ch[m-2])&lt;=0) m--;ch[m++]=p[i];&#125;if(n&gt;1) m--;return m;&#125;  int main()&#123;cin&gt;&gt;n;cout&lt;&lt;"INTERSECTING LINES OUTPUT"&lt;&lt;endl;rep(i,0,n)&#123;Line l1,l2;cin&gt;&gt;l1.e.x&gt;&gt;l1.e.y&gt;&gt;l1.s.x&gt;&gt;l1.s.y&gt;&gt;l2.e.x&gt;&gt;l2.e.y&gt;&gt;l2.s.x&gt;&gt;l2.s.y;Vector v1=l1.s-l1.e;Vector v2=l2.s-l2.e;if(dcmp(cross(v1,v2))==0) &#123;Vector v3=l1.s-l2.e;if(dcmp(cross(v1,v3))==0) cout&lt;&lt;"LINE"&lt;&lt;endl;else cout&lt;&lt;"NONE"&lt;&lt;endl;continue;&#125;Point in=getinter(l1,l2);cout&lt;&lt;"POINT "&lt;&lt;fixed&lt;&lt;setprecision(2)&lt;&lt;in.x&lt;&lt;" "&lt;&lt;in.y&lt;&lt;endl;&#125; cout&lt;&lt;"END OF OUTPUT"&lt;&lt;endl;&#125;</code></pre><h1 id="收获与反思"><a href="#收获与反思" class="headerlink" title="收获与反思"></a>收获与反思</h1><ul><li>第一次接触计算几何，模板积累。</li></ul>]]></content>
    
    
    <categories>
      
      <category>Computer Science</category>
      
      <category>ACM</category>
      
      <category>POJ</category>
      
    </categories>
    
    
    <tags>
      
      <tag>ACM</tag>
      
      <tag>POJ</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>【POJ-1066】解题报告（计算几何，线段交点）</title>
    <link href="/post/9c28a880.html"/>
    <url>/post/9c28a880.html</url>
    
    <content type="html"><![CDATA[<h1 id="原始题目"><a href="#原始题目" class="headerlink" title="原始题目"></a>原始题目</h1><h2 id="Treasure-Hunt"><a href="#Treasure-Hunt" class="headerlink" title="Treasure Hunt"></a>Treasure Hunt</h2><ul><li>Time Limit: 1000MS        </li><li>Memory Limit: 10000K</li><li>Total Submissions: 7927        </li><li>Accepted: 3269</li></ul><h3 id="Description"><a href="#Description" class="headerlink" title="Description"></a>Description</h3><p>Archeologists from the Antiquities and Curios Museum (ACM) have flown to Egypt to examine the great pyramid of Key-Ops. Using state-of-the-art technology they are able to determine that the lower floor of the pyramid is constructed from a series of straightline walls, which intersect to form numerous enclosed chambers. Currently, no doors exist to allow access to any chamber. This state-of-the-art technology has also pinpointed the location of the treasure room. What these dedicated (and greedy) archeologists want to do is blast doors through the walls to get to the treasure room. However, to minimize the damage to the artwork in the intervening chambers (and stay under their government grant for dynamite) they want to blast through the minimum number of doors. For structural integrity purposes, doors should only be blasted at the midpoint of the wall of the room being entered. You are to write a program which determines this minimum number of doors. </p><p>An example is shown below:<br></p><a id="more"></a><h3 id="Input"><a href="#Input" class="headerlink" title="Input"></a>Input</h3><p>The input will consist of one case. The first line will be an integer n (0 ≤ n ≤ 30) specifying number of interior walls, followed by n lines containing integer endpoints of each wall x1 y1 x2 y2 . The 4 enclosing walls of the pyramid have fixed endpoints at (0,0); (0,100); (100,100) and (100,0) and are not included in the list of walls. The interior walls always span from one exterior wall to another exterior wall and are arranged such that no more than two walls intersect at any point. You may assume that no two given walls coincide. After the listing of the interior walls there will be one final line containing the floating point coordinates of the treasure in the treasure room (guaranteed not to lie on a wall).</p><h3 id="Output"><a href="#Output" class="headerlink" title="Output"></a>Output</h3><p>Print a single line listing the minimum number of doors which need to be created, in the format shown below.</p><h3 id="Sample-Input"><a href="#Sample-Input" class="headerlink" title="Sample Input"></a>Sample Input</h3><pre><code>7 20 0 37 100 40 0 76 100 85 0 0 75 100 90 0 90 0 71 100 61 0 14 100 38 100 47 47 100 54.5 55.4 </code></pre><h3 id="Sample-Output"><a href="#Sample-Output" class="headerlink" title="Sample Output"></a>Sample Output</h3><pre><code>Number of doors = 2 </code></pre><h3 id="Source"><a href="#Source" class="headerlink" title="Source"></a>Source</h3><p>East Central North America 1999</p><h1 id="题目大意"><a href="#题目大意" class="headerlink" title="题目大意"></a>题目大意</h1><p>在一个100*100的正方形区域中，有n条两端点均在正方形边界的墙将区域分成许多个部分（房间），已知可以破坏每个区域房间墙壁的中点，区域中某个点是宝藏，问从外界到宝藏处最少需要破坏多少个墙壁。</p><h1 id="解题思路"><a href="#解题思路" class="headerlink" title="解题思路"></a>解题思路</h1><ul><li>由于破坏墙中点后就可以移动到左右端点，故实际上破坏位置在不在中点没有区别。</li><li>不可能绕开墙壁，所以走直线最近，每个墙壁最多只会遭遇一次。</li><li>所以等价从边界上每个墙壁的端点到宝藏位置连一条线段，和其他线段的交点（严格相交）+1就是所求答案。</li><li>利用计算几何中的判断线段是否相交的函数。</li></ul><h1 id="解题代码"><a href="#解题代码" class="headerlink" title="解题代码"></a>解题代码</h1><pre><code class="hljs C++">//计算几何模板，二维几何基础//使用印用注意避免直接在程序中调用构造函数构造无名对象。否则可能会导致程序出错 //#include &lt;bits/stdc++.h&gt;#include &lt;cstdio&gt;#include &lt;cmath&gt;#include &lt;cstdlib&gt;#include &lt;cstring&gt;#include &lt;iostream&gt;#include &lt;set&gt;#include &lt;iomanip&gt;#include &lt;algorithm&gt;#include &lt;queue&gt;#include &lt;map&gt;#include &lt;string&gt;#define INF 0x3f3f3f3f#define rep(i,a,n) for(int i=a;i&lt;n;i++)#define per(i,a,n) for(int i=n-1;i&gt;=a;i--)using namespace std;typedef long long ll;const double eps =1e-10;const int maxn=50;int n;//有的命名为sgn函数，高精度符号判断 int dcmp(double x)&#123;//相等函数判断，减少精度问题 if(fabs(x)&lt;eps) return 0;else return x&lt;0?-1:1;&#125;//点的定义 class Point&#123;public:double x,y;Point (double x=0,double y=0):x(x),y(y)&#123;&#125; //构造函数，方便代码的编写 &#125;point[maxn]; typedef Point Vector;// 从程序实现上，Vector只是Point的别名//运算符重载 Vector operator + (const Vector &amp;A,const Vector &amp;B) &#123; return Vector(A.x+B.x,A.y+B.y); &#125; //向量+向量=向量，点+向量=点Vector operator - (const Vector &amp;A,const Vector &amp;B) &#123; return Vector(A.x-B.x,A.y-B.y); &#125; //向量-向量=向量，点-向量-点  Vector operator * (const Vector &amp;A,double p) &#123; return Vector(A.x*p,A.y*p); &#125;   //向量*数=向量 （数乘） Vector operator / (const Vector &amp;A,double p) &#123; return Vector(A.x/p,A.y/p); &#125;//向量/数=向量 （数除）double operator * (const Vector &amp;A,const Vector &amp;B) &#123; return A.x*B.x+A.y*B.y; &#125;//向量（点乘）向量=数  （点乘）bool operator &lt; (const Point &amp;A,const Point &amp;B) &#123; return A.x==B.x?A.y&lt;B.y:A.x&lt;B.x; &#125; //按x值递增排序 bool operator == (const Point &amp;A,const Point &amp;B) &#123; return dcmp(A.x-B.x)==0&amp;&amp; dcmp(A.y-B.y)==0; &#125; //判定两个点是否相同，用到dcmp精度判定 //点乘叉乘 double dot(const Vector &amp;A,const Vector &amp;B)&#123; return A.x*B.x+A.y*B.y; &#125;//向量（叉乘）向量=向量 （叉乘） double operator ^ (const Vector &amp;A,const Vector &amp;B)&#123; return A.x*B.y-A.y*B.x; &#125;double cross(const Vector &amp;A,const Vector &amp;B)&#123; return A.x*B.y-A.y*B.x; &#125;//模长面积 double abs(const Vector &amp;A)&#123; return sqrt(dot(A,A));&#125;//计算向量模长 double area2(const Point &amp;A,const Point &amp;B,const Point &amp;C)&#123; return cross(B-A,C-A) ;&#125; //计算平行四边形方向面积double PolygonArea(Point *p,int n) &#123; double area=0; rep(i,1,n-1)&#123;area+=cross(p[i]-p[0],p[i+1]-p[0]);&#125;return area/2.0; &#125;//计算多边形的有向面积//旋转Vector rotate(Vector A,double rad) &#123; return Vector(A.x*cos(rad)-A.y*sin(rad),A.x*sin(rad)+A.y*cos(rad));&#125;  //旋转rad弧度 Vector normal(Vector A)&#123;double l=abs(A);return Vector(-A.y/l,A.x/l);&#125; //计算单位法线，左转90//线段定义 class Line &#123;public:Point s,e;Line()&#123;&#125;Line(Point _s,Point _e)&#123;s=_s;e=_e;&#125;&#125;line[maxn];//判断两线段是否相交 bool inter(Line l1,Line l2)&#123;//cout&lt;&lt;"L1  "&lt;&lt;l1.e.x&lt;&lt;","&lt;&lt;l1.e.y&lt;&lt;"   "&lt;&lt;l1.s.x&lt;&lt;","&lt;&lt;l1.s.y&lt;&lt;endl;//cout&lt;&lt;"L2  "&lt;&lt;l2.e.x&lt;&lt;","&lt;&lt;l2.e.y&lt;&lt;"   "&lt;&lt;l2.s.x&lt;&lt;","&lt;&lt;l2.s.y&lt;&lt;endl;return (//根据题目要求端点相交是否算作相交来决定大于等于和小于等于 //排斥实验 max(l1.s.x,l1.e.x)&gt;=min(l2.s.x,l2.e.x) &amp;&amp;max(l2.s.x,l2.e.x)&gt;=min(l1.s.x,l1.e.x) &amp;&amp;max(l1.s.y,l1.e.y)&gt;=min(l2.s.y,l2.e.y) &amp;&amp;max(l2.s.y,l2.e.y)&gt;=min(l1.s.y,l1.e.y) &amp;&amp;//跨立实验 dcmp((l2.s-l1.s)^(l1.s-l1.e))*dcmp((l2.e-l1.s)^(l1.s-l1.e))&lt;0 &amp;&amp;dcmp((l1.s-l2.s)^(l2.s-l2.e))*dcmp((l1.e-l2.s)^(l2.s-l2.e))&lt;0) ;&#125;bool inter(Point a1,Point a2,Point b1,Point b2)&#123;Line l1(a1,a2),l2(b1,b2);return inter(l1,l2);&#125;bool cmp(Point a,Point b)&#123;if(a.x==b.x) return a.y&lt;b.y;else return a.x&lt;b.x;&#125;//求两直线交点Point getinter(Line l1,Line l2)&#123;Vector v=l1.s-l1.e;Vector w=l2.s-l2.e;Vector u=l1.e-l2.e;double t=cross(w,u)/cross(v,w);return l1.e+v*t;&#125; Point getinter(Point a1,Point a2,Point b1,Point b2)&#123;Line l1(a1,a2);Line l2(b1,b2);return getinter(l1,l2);&#125;//判定点和线段的关系，//0:不在线段所在直线上//1:在线段内（不含端点） //2:在线段端点//3:在线段两侧的射线上 int  online(Point a,Line l)&#123;if(dcmp(cross(l.s-a,l.e-a))!=0) return 0;double pans=dcmp(dot(l.s-a,l.e-a));//cout&lt;&lt;(l.s-a).x&lt;&lt;","&lt;&lt;(l.s-a).y&lt;&lt;"   "&lt;&lt;(l.e-a).x&lt;&lt;","&lt;&lt;(l.e-a).y&lt;&lt;endl;if(pans&lt;0) return 1;else if(pans==0) return 2;else if(pans&gt;0) return 3;&#125;int online(Point a,Point b1,Point b2)&#123;Line l(b1,b2);return online(a,l);&#125;//凸包int ConvexHull(Point *p,int n,Point *ch)&#123;sort(p,p+n,cmp);int m=0;for(int i=0;i&lt;n;i++)&#123;while(m&gt;1 &amp;&amp; cross(ch[m-1]-ch[m-2],p[i]-ch[m-2])&lt;=0) m--;ch[m++]=p[i];&#125;int k=m;for(int i=n-2;i&gt;=0;i--)&#123;while(m&gt;k &amp;&amp; cross(ch[m-1]-ch[m-2],p[i]-ch[m-2])&lt;=0) m--;ch[m++]=p[i];&#125;if(n&gt;1) m--;return m;&#125;  int main()&#123;cin&gt;&gt;n;rep(i,0,n)&#123;cin&gt;&gt;line[i].e.x&gt;&gt;line[i].e.y&gt;&gt;line[i].s.x&gt;&gt;line[i].s.y;&#125;cin&gt;&gt;point[0].x&gt;&gt;point[0].y;if(n==0) cout&lt;&lt;"Number of doors = 1"&lt;&lt;endl;else&#123;int ans=INF;rep(i,0,n)&#123;int cnt=0;Point pn=line[i].e;Line ln(point[0],pn);rep(j,0,n)&#123;if(inter(ln,line[j])) cnt++;&#125;//cout&lt;&lt;"p1     "&lt;&lt;cnt&lt;&lt;endl;ans=min(ans,cnt);cnt=0;pn=line[i].s;ln.s=point[0];ln.e=pn;rep(j,0,n)&#123;if(inter(ln,line[j])) cnt++;&#125;ans=min(ans,cnt);//cout&lt;&lt;"p2     "&lt;&lt;cnt&lt;&lt;endl;&#125;cout&lt;&lt;"Number of doors = "&lt;&lt;ans+1&lt;&lt;endl;&#125;  &#125;</code></pre><h1 id="收获与反思"><a href="#收获与反思" class="headerlink" title="收获与反思"></a>收获与反思</h1><ul><li>第一次接触计算几何，模板积累。</li></ul>]]></content>
    
    
    <categories>
      
      <category>Computer Science</category>
      
      <category>ACM</category>
      
      <category>POJ</category>
      
    </categories>
    
    
    <tags>
      
      <tag>ACM</tag>
      
      <tag>POJ</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>【HDU-6322】解题报告（数论，2018杭电多校第三场）</title>
    <link href="/post/e8ae7612.html"/>
    <url>/post/e8ae7612.html</url>
    
    <content type="html"><![CDATA[<h1 id="原始题目"><a href="#原始题目" class="headerlink" title="原始题目"></a>原始题目</h1><h2 id="Problem-D-Euler-Function"><a href="#Problem-D-Euler-Function" class="headerlink" title="Problem D. Euler Function"></a>Problem D. Euler Function</h2><ul><li>Time Limit: 2000/1000 MS (Java/Others)    </li><li>Memory Limit: 524288/524288 K (Java/Others)</li><li>Total Submission(s): 150    </li><li>Accepted Submission(s): 136</li></ul><a id="more"></a><h3 id="Problem-Description"><a href="#Problem-Description" class="headerlink" title="Problem Description"></a>Problem Description</h3><p>In number theory, Euler’s totient function $\varphi(n)$ counts the positive integers up to a given integer $n$ that are relatively prime to $n$. It can be defined more formally as the number of integers $k$ in the range $1\leq k\leq n$ for which the greatest common divisor $\gcd(n, k)$ is equal to $1$.</p><p>For example, $\varphi(9) = 6$ because $1,2,4,5,7$ and $8$ are coprime with $9$. As another example, $\varphi(1) = 1$ since for $n = 1$ the only integer in the range from $1$ to $n$ is 1 itself, and $\gcd(1, 1) = 1$ .</p><p>A composite number is a positive integer that can be formed by multiplying together two smaller positive integers. Equivalently, it is a positive integer that has at least one divisor other than $1$ and itself. So obviously $1$ and all prime numbers are not composite number.</p><p>In this problem, given integer $k$, your task is to find the $k$-th smallest positive integer n, that $\varphi(n)$ is a composite number.</p><h3 id="Input"><a href="#Input" class="headerlink" title="Input"></a>Input</h3><p>The first line of the input contains an integer $T(1\leq T\leq100000)$, denoting the number of test cases.<br>In each test case, there is only one integer $k(1\leq k\leq 10^9)$.</p><h3 id="Output"><a href="#Output" class="headerlink" title="Output"></a>Output</h3><p>For each test case, print a single line containing an integer, denoting the answer.</p><h3 id="Sample-Input"><a href="#Sample-Input" class="headerlink" title="Sample Input"></a>Sample Input</h3><pre><code>212</code></pre><h3 id="Sample-Output"><a href="#Sample-Output" class="headerlink" title="Sample Output"></a>Sample Output</h3><pre><code>57</code></pre><h3 id="Source"><a href="#Source" class="headerlink" title="Source"></a>Source</h3><p>2018 Multi-University Training Contest 3</p><h3 id="Recommend"><a href="#Recommend" class="headerlink" title="Recommend"></a>Recommend</h3><p>chendu</p><h1 id="题目大意"><a href="#题目大意" class="headerlink" title="题目大意"></a>题目大意</h1><p>求第k个正整数n，其欧拉函数$\varphi(n)$为合数。</p><h1 id="解题思路"><a href="#解题思路" class="headerlink" title="解题思路"></a>解题思路</h1><ul><li>数论题</li><li>手写一下，发现数稍微大便全是合数。反向考虑$\varphi(n)$为质数。</li><li>已知$\varphi(n) = p_1^{k_1-1}(p_1-1)p_2^{k_2-1}(p_2-1)\cdots$，其中$\gcd(p_1, p_2 \cdots)=1$。分情况讨论：<ul><li>情况1：$n$为$p^k$形式，即只有一个质因子。</li><li>子情况1.1：该质因子为$2$，那么要使$\varphi(n)$为质数，则$p^{k-1}$为质数，很明显$k=1,2$，所以该情况下$n$只能为$2,4$</li><li>子情况1.2：该质因数不为$2$，那么要使$\varphi(n)$为质数，$p-1$也得为质数，很明显成立的只有$3$（相邻两个数均为质数）</li><li>情况2：$n$由两个质因子构成。</li><li>子情况1.1：其中一个为$2$，由于另一个会贡献一个$2$，要使$\varphi(n)$为质数,则$2$质因数指数只能为$1$，另一质因数只能为$3$，指数只能为$1$。</li><li>子情况2.2：均不为$2$，那么两个质因子各贡献一个$2$，那么$\varphi(n)$一定为4的倍数，不为质数。</li></ul></li><li><p>当$n=1,2,3,4,6$时，$\varphi(n)$为质数。</p><h1 id="解题代码"><a href="#解题代码" class="headerlink" title="解题代码"></a>解题代码</h1><pre><code class="hljs C++"><span class="hljs-meta">#<span class="hljs-meta-keyword">include</span><span class="hljs-meta-string">&lt;bits/stdc++.h&gt;</span></span><span class="hljs-keyword">using</span> <span class="hljs-keyword">namespace</span> <span class="hljs-built_in">std</span>;<span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span>&#123;<span class="hljs-keyword">int</span> T;<span class="hljs-keyword">long</span> <span class="hljs-keyword">long</span> k;<span class="hljs-built_in">cin</span>&gt;&gt;T;<span class="hljs-keyword">while</span>(T--)&#123;<span class="hljs-built_in">cin</span>&gt;&gt;k;<span class="hljs-keyword">if</span>(k==<span class="hljs-number">1</span>) <span class="hljs-built_in">cout</span>&lt;&lt;<span class="hljs-number">5</span>&lt;&lt;<span class="hljs-built_in">endl</span>;<span class="hljs-keyword">else</span> <span class="hljs-built_in">cout</span>&lt;&lt;k+<span class="hljs-number">5</span>&lt;&lt;<span class="hljs-built_in">endl</span>;&#125;<span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;&#125;</code></pre></li></ul><h1 id="收获与反思"><a href="#收获与反思" class="headerlink" title="收获与反思"></a>收获与反思</h1><ul><li>数论先推前几项再分析</li><li>掌握欧拉函数的计算方法和性质。</li></ul>]]></content>
    
    
    <categories>
      
      <category>Computer Science</category>
      
      <category>ACM</category>
      
      <category>HDU</category>
      
    </categories>
    
    
    <tags>
      
      <tag>ACM</tag>
      
      <tag>HDU</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>【CSU-2059】解题报告（递推，几何）</title>
    <link href="/post/34f53a10.html"/>
    <url>/post/34f53a10.html</url>
    
    <content type="html"><![CDATA[<p>HDU-2050变式拓展</p><h1 id="原始题目"><a href="#原始题目" class="headerlink" title="原始题目"></a>原始题目</h1><h2 id="2059-Water-Problem"><a href="#2059-Water-Problem" class="headerlink" title="2059: Water Problem"></a>2059: Water Problem</h2><ul><li>Time Limit: 1 Sec     </li><li>Memory Limit: 128 Mb     </li><li>Submitted: 576     </li><li>Solved: 199    <h3 id="Description"><a href="#Description" class="headerlink" title="Description"></a>Description</h3>​ 一条‘Z’形线可以将平面分为两个区域，那么由N条Z形线所定义的区域的最大个数是多少呢？每条Z形线由两条平行的无限半直线和一条直线段组成</li></ul><a id="more"></a><h3 id="Input"><a href="#Input" class="headerlink" title="Input"></a>Input</h3><p>首先输入一个数字T（T&lt;100），代表有T次询问 每次询问输入一个数字N（N&lt;1e8），代表有N条Z形线</p><h3 id="Output"><a href="#Output" class="headerlink" title="Output"></a>Output</h3><p>对于每次询问，在一行输出N条‘Z’形线所能划分的区域的最大个数为多少</p><h3 id="Sample-Input"><a href="#Sample-Input" class="headerlink" title="Sample Input"></a>Sample Input</h3><pre><code>212</code></pre><h3 id="Sample-Output"><a href="#Sample-Output" class="headerlink" title="Sample Output"></a>Sample Output</h3><pre><code>212</code></pre><h3 id="Hint"><a href="#Hint" class="headerlink" title="Hint"></a>Hint</h3><h3 id="Source"><a href="#Source" class="headerlink" title="Source"></a>Source</h3><h3 id="Author"><a href="#Author" class="headerlink" title="Author"></a>Author</h3><p>csutsz</p><h1 id="题目大意"><a href="#题目大意" class="headerlink" title="题目大意"></a>题目大意</h1><p>如题</p><h1 id="解题思路"><a href="#解题思路" class="headerlink" title="解题思路"></a>解题思路</h1><ul><li>先推导递推式，由于数据量大，再推导通项公式最后直接输出。</li><li>分析：第i条z形线比第i-1条z形线新分成的最多区域数为新增最多交点个数+1<ul><li>第i条线最多与前i-1条z形线交 $4*(i-1)$ 个点。<script type="math/tex; mode=display">dp[i]=dp[i-1]+4\*(i-1)+! , dp[1]=2</script></li><li>所以得到通项公式<script type="math/tex; mode=display">dp[i]=\frac{9\*(i-1)\*(i)}{2}+i+1</script></li></ul></li></ul><h1 id="解题代码"><a href="#解题代码" class="headerlink" title="解题代码"></a>解题代码</h1><pre><code class="hljs C++"><span class="hljs-meta">#<span class="hljs-meta-keyword">include</span> <span class="hljs-meta-string">&lt;cstdio&gt;</span></span><span class="hljs-meta">#<span class="hljs-meta-keyword">include</span> <span class="hljs-meta-string">&lt;cstring&gt;</span></span><span class="hljs-meta">#<span class="hljs-meta-keyword">include</span> <span class="hljs-meta-string">&lt;iostream&gt;</span></span><span class="hljs-meta">#<span class="hljs-meta-keyword">include</span> <span class="hljs-meta-string">&lt;set&gt;</span></span><span class="hljs-meta">#<span class="hljs-meta-keyword">include</span> <span class="hljs-meta-string">&lt;algorithm&gt;</span></span><span class="hljs-meta">#<span class="hljs-meta-keyword">include</span> <span class="hljs-meta-string">&lt;queue&gt;</span></span><span class="hljs-meta">#<span class="hljs-meta-keyword">include</span> <span class="hljs-meta-string">&lt;map&gt;</span></span><span class="hljs-meta">#<span class="hljs-meta-keyword">include</span> <span class="hljs-meta-string">&lt;string&gt;</span></span><span class="hljs-meta">#<span class="hljs-meta-keyword">define</span> eps 1e-8</span><span class="hljs-meta">#<span class="hljs-meta-keyword">define</span> INF 0x3f3f3f3f</span><span class="hljs-meta">#<span class="hljs-meta-keyword">define</span> rep(i,a,n) for(int i=a;i&lt;n;i++)</span><span class="hljs-meta">#<span class="hljs-meta-keyword">define</span> per(i,a,n) for(int i=n-1;i&gt;=a;i--)</span><span class="hljs-keyword">using</span> <span class="hljs-keyword">namespace</span> <span class="hljs-built_in">std</span>;<span class="hljs-keyword">const</span> <span class="hljs-keyword">int</span> maxn=<span class="hljs-number">1e8</span>+<span class="hljs-number">2</span>;<span class="hljs-keyword">typedef</span> <span class="hljs-keyword">long</span> <span class="hljs-keyword">long</span> ll;<span class="hljs-keyword">using</span> <span class="hljs-keyword">namespace</span> <span class="hljs-built_in">std</span>;<span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span>&#123;<span class="hljs-keyword">int</span> t;<span class="hljs-built_in">cin</span>&gt;&gt;t;<span class="hljs-keyword">for</span>(ll i=<span class="hljs-number">0</span>;i&lt;t;i++)&#123;ll a;<span class="hljs-built_in">cin</span>&gt;&gt;a;<span class="hljs-keyword">if</span>(a==<span class="hljs-number">1</span>) <span class="hljs-built_in">cout</span>&lt;&lt;<span class="hljs-number">2</span>&lt;&lt;<span class="hljs-built_in">endl</span>;<span class="hljs-keyword">else</span> <span class="hljs-built_in">cout</span>&lt;&lt;<span class="hljs-number">9</span>*(a<span class="hljs-number">-1</span>)*(a)/<span class="hljs-number">2</span>+a+<span class="hljs-number">1</span>&lt;&lt;<span class="hljs-built_in">endl</span>;&#125;&#125;</code></pre><h1 id="收获与反思"><a href="#收获与反思" class="headerlink" title="收获与反思"></a>收获与反思</h1><ul><li>折线，z形线，类似的都转化到与新增交点数的关系。</li></ul>]]></content>
    
    
    <categories>
      
      <category>Computer Science</category>
      
      <category>ACM</category>
      
      <category>CSU</category>
      
    </categories>
    
    
    <tags>
      
      <tag>ACM</tag>
      
      <tag>CSU</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>【ZOJ-1633】解题报告（字符串递推，二分查找）</title>
    <link href="/post/5e189593.html"/>
    <url>/post/5e189593.html</url>
    
    <content type="html"><![CDATA[<h1 id="原始题目"><a href="#原始题目" class="headerlink" title="原始题目"></a>原始题目</h1><h2 id="Big-String"><a href="#Big-String" class="headerlink" title="Big String"></a>Big String</h2><ul><li>Time Limit: 2 Seconds      </li><li>Memory Limit: 65536 KB</li></ul><p>We will construct an infinitely long string from two short strings: A = “^__^” (four characters), and B = “T.T” (three characters). Repeat the following steps:</p><ul><li>Concatenate A after B to obtain a new string C. For example, if A = “^__^” and B = “T.T”, then C = BA = “T.T^__^”.</li><li>Let A = B, B = C — as the example above A = “T.T”, B = “T.T^__^”.</li></ul><p>Your task is to find out the n-th character of this infinite string.<br><a id="more"></a></p><h3 id="Input"><a href="#Input" class="headerlink" title="Input"></a>Input</h3><p>The input contains multiple test cases, each contains only one integer $N (1 \le N \le 2^{63} - 1)$. Proceed to the end of file.</p><h3 id="Output"><a href="#Output" class="headerlink" title="Output"></a>Output</h3><p>For each test case, print one character on each line, which is the N-th (index begins with 1) character of this infinite string.</p><h3 id="Sample-Input"><a href="#Sample-Input" class="headerlink" title="Sample Input"></a>Sample Input</h3><pre><code>1248</code></pre><h3 id="Sample-Output"><a href="#Sample-Output" class="headerlink" title="Sample Output"></a>Sample Output</h3><pre><code>T.^T</code></pre><h3 id="Author"><a href="#Author" class="headerlink" title="Author:"></a>Author:</h3><p>CHENG, Long</p><h3 id="Source"><a href="#Source" class="headerlink" title="Source:"></a>Source:</h3><p>Zhejiang University Local Contest 2003</p><h1 id="题目大意"><a href="#题目大意" class="headerlink" title="题目大意"></a>题目大意</h1><p>由A=”^__^” ，  B=”T.T” ， C=BA=”T.T^__^” ，再令C=B, B=A，重复这种操作，问如此构成的字符串第n个字符是什么。</p><h1 id="解题思路"><a href="#解题思路" class="headerlink" title="解题思路"></a>解题思路</h1><ul><li>$dp[i]$ 表示第i个字符串由多少个字符构成，已知$dp[0]=4,dp[1]=3,dp[2]=7$，根据递推规则可知$dp[i+1]=dp[i]+dp[i-1]$</li><li>折半查找第一个比n大的dp[i]，则第i串里的第n位与第i-1串里的第n-dp[i-1]（可以保证这一项大于零）位对应字符相同。递归操作直至n&lt;7。从”T.T^__^”寻找就可以了</li></ul><h1 id="解题代码"><a href="#解题代码" class="headerlink" title="解题代码"></a>解题代码</h1><pre><code class="hljs C++"><span class="hljs-meta">#<span class="hljs-meta-keyword">include</span> <span class="hljs-meta-string">&lt;cstdio&gt;</span></span><span class="hljs-meta">#<span class="hljs-meta-keyword">include</span> <span class="hljs-meta-string">&lt;cstring&gt;</span></span><span class="hljs-meta">#<span class="hljs-meta-keyword">include</span> <span class="hljs-meta-string">&lt;iostream&gt;</span></span><span class="hljs-meta">#<span class="hljs-meta-keyword">include</span> <span class="hljs-meta-string">&lt;set&gt;</span></span><span class="hljs-meta">#<span class="hljs-meta-keyword">include</span> <span class="hljs-meta-string">&lt;algorithm&gt;</span></span><span class="hljs-meta">#<span class="hljs-meta-keyword">include</span> <span class="hljs-meta-string">&lt;queue&gt;</span></span><span class="hljs-meta">#<span class="hljs-meta-keyword">include</span> <span class="hljs-meta-string">&lt;map&gt;</span></span><span class="hljs-meta">#<span class="hljs-meta-keyword">include</span> <span class="hljs-meta-string">&lt;string&gt;</span></span><span class="hljs-meta">#<span class="hljs-meta-keyword">define</span> eps 1e-8</span><span class="hljs-meta">#<span class="hljs-meta-keyword">define</span> INF 0x3f3f3f3f</span><span class="hljs-meta">#<span class="hljs-meta-keyword">define</span> rep(i,a,n) for(int i=a;i&lt;n;i++)</span><span class="hljs-meta">#<span class="hljs-meta-keyword">define</span> per(i,a,n) for(int i=n-1;i&gt;=a;i--)</span><span class="hljs-keyword">using</span> <span class="hljs-keyword">namespace</span> <span class="hljs-built_in">std</span>;<span class="hljs-keyword">using</span> <span class="hljs-keyword">namespace</span> <span class="hljs-built_in">std</span>;<span class="hljs-keyword">typedef</span> <span class="hljs-keyword">long</span> <span class="hljs-keyword">long</span> ll;ll a[<span class="hljs-number">95</span>];  <span class="hljs-comment">//保存字符串的长度</span><span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span>&#123;    <span class="hljs-built_in">string</span> C = <span class="hljs-string">"T.T^__^"</span>;    a[<span class="hljs-number">0</span>] = <span class="hljs-number">4</span>;    a[<span class="hljs-number">1</span>] = <span class="hljs-number">3</span>;    <span class="hljs-keyword">int</span> i;    <span class="hljs-keyword">for</span>(i = <span class="hljs-number">2</span>; i &lt; <span class="hljs-number">90</span>; i++)        a[i] = a[i<span class="hljs-number">-1</span>] + a[i<span class="hljs-number">-2</span>];    ll n;    <span class="hljs-keyword">while</span>(<span class="hljs-built_in">cin</span> &gt;&gt; n)    &#123;        <span class="hljs-keyword">while</span>(n &gt; <span class="hljs-number">7</span>)        &#123;            <span class="hljs-keyword">int</span> pos = lower_bound(a, a+<span class="hljs-number">89</span>, n) - a;            n -= a[pos<span class="hljs-number">-1</span>];        &#125;        <span class="hljs-built_in">cout</span> &lt;&lt; C[n<span class="hljs-number">-1</span>] &lt;&lt; <span class="hljs-built_in">endl</span>;    &#125;    <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;&#125;</code></pre><h1 id="收获与反思"><a href="#收获与反思" class="headerlink" title="收获与反思"></a>收获与反思</h1><ul><li>二分查找与递推的结合</li></ul>]]></content>
    
    
    <categories>
      
      <category>Computer Science</category>
      
      <category>ACM</category>
      
      <category>ZOJ</category>
      
    </categories>
    
    
    <tags>
      
      <tag>ACM</tag>
      
      <tag>ZOJ</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>【CSU-1587】解题报告（递推，水题）</title>
    <link href="/post/31f89579.html"/>
    <url>/post/31f89579.html</url>
    
    <content type="html"><![CDATA[<h1 id="原始题目"><a href="#原始题目" class="headerlink" title="原始题目"></a>原始题目</h1><h2 id="1587-爬楼梯"><a href="#1587-爬楼梯" class="headerlink" title="1587: 爬楼梯"></a>1587: 爬楼梯</h2><ul><li>Time Limit: 1 Sec     </li><li>Memory Limit: 128 Mb     </li><li>Submitted: 867     </li><li>Solved: 514    <h3 id="Description"><a href="#Description" class="headerlink" title="Description"></a>Description</h3>小时候我们都玩过爬楼梯的游戏：两人猜拳，赢了可向上爬一级，谁先到最高级则获胜。作为大学生，我们应该玩一个更有水平的游戏。<br>现在一个人要上n级楼梯，每一步可以选择上一级或者上两级，但是不能后退。求上这n级楼梯的方案数。</li></ul><a id="more"></a><h3 id="Input"><a href="#Input" class="headerlink" title="Input"></a>Input</h3><p>第一行只有一个整数$T(1 \le T \le 45)$，表示数据组数。<br>下面的T行每一行有一个整数$ n ( 1 \le n \le 45)$ ，表示有多少级楼梯。</p><h3 id="Output"><a href="#Output" class="headerlink" title="Output"></a>Output</h3><p>对于每一组数据输出一个整数s，表示方案数。</p><h3 id="Sample-Input"><a href="#Sample-Input" class="headerlink" title="Sample Input"></a>Sample Input</h3><pre><code>41234</code></pre><h3 id="Sample-Output"><a href="#Sample-Output" class="headerlink" title="Sample Output"></a>Sample Output</h3><pre><code>1235</code></pre><h3 id="Hint"><a href="#Hint" class="headerlink" title="Hint"></a>Hint</h3><h3 id="Source"><a href="#Source" class="headerlink" title="Source"></a>Source</h3><p>国防科学技术大学第十八届银河之光文化节ACM程序设计竞赛初赛</p><h1 id="题目大意"><a href="#题目大意" class="headerlink" title="题目大意"></a>题目大意</h1><p>如题</p><h1 id="解题思路"><a href="#解题思路" class="headerlink" title="解题思路"></a>解题思路</h1><ul><li>到第i级阶梯可由第i-1级阶梯爬一级或由第i-2级解题爬两层。</li></ul><h1 id="解题代码"><a href="#解题代码" class="headerlink" title="解题代码"></a>解题代码</h1><pre><code class="hljs C++"><span class="hljs-meta">#<span class="hljs-meta-keyword">include</span> <span class="hljs-meta-string">&lt;cstdio&gt;</span></span><span class="hljs-meta">#<span class="hljs-meta-keyword">include</span> <span class="hljs-meta-string">&lt;cstring&gt;</span></span><span class="hljs-meta">#<span class="hljs-meta-keyword">include</span> <span class="hljs-meta-string">&lt;iostream&gt;</span></span><span class="hljs-meta">#<span class="hljs-meta-keyword">include</span> <span class="hljs-meta-string">&lt;set&gt;</span></span><span class="hljs-meta">#<span class="hljs-meta-keyword">include</span> <span class="hljs-meta-string">&lt;algorithm&gt;</span></span><span class="hljs-meta">#<span class="hljs-meta-keyword">include</span> <span class="hljs-meta-string">&lt;queue&gt;</span></span><span class="hljs-meta">#<span class="hljs-meta-keyword">include</span> <span class="hljs-meta-string">&lt;map&gt;</span></span><span class="hljs-meta">#<span class="hljs-meta-keyword">include</span> <span class="hljs-meta-string">&lt;string&gt;</span></span><span class="hljs-meta">#<span class="hljs-meta-keyword">define</span> eps 1e-8</span><span class="hljs-meta">#<span class="hljs-meta-keyword">define</span> INF 0x3f3f3f3f</span><span class="hljs-meta">#<span class="hljs-meta-keyword">define</span> rep(i,a,n) for(int i=a;i&lt;n;i++)</span><span class="hljs-meta">#<span class="hljs-meta-keyword">define</span> per(i,a,n) for(int i=n-1;i&gt;=a;i--)</span><span class="hljs-keyword">using</span> <span class="hljs-keyword">namespace</span> <span class="hljs-built_in">std</span>;<span class="hljs-keyword">const</span> <span class="hljs-keyword">int</span> maxn=<span class="hljs-number">1e5</span>+<span class="hljs-number">5</span>;<span class="hljs-keyword">typedef</span> <span class="hljs-keyword">long</span> <span class="hljs-keyword">long</span> ll;ll dp[maxn];<span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">solve</span><span class="hljs-params">()</span></span>&#123;<span class="hljs-built_in">memset</span>(dp,<span class="hljs-number">0</span>,<span class="hljs-keyword">sizeof</span>(dp));dp[<span class="hljs-number">1</span>]=<span class="hljs-number">1</span>;dp[<span class="hljs-number">2</span>]=<span class="hljs-number">2</span>;rep(i,<span class="hljs-number">3</span>,<span class="hljs-number">50</span>)&#123;dp[i]=dp[i<span class="hljs-number">-1</span>]+dp[i<span class="hljs-number">-2</span>];&#125; &#125;<span class="hljs-keyword">using</span> <span class="hljs-keyword">namespace</span> <span class="hljs-built_in">std</span>;<span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span>&#123;<span class="hljs-keyword">int</span> t;solve();<span class="hljs-keyword">while</span>(<span class="hljs-built_in">cin</span>&gt;&gt;t)&#123;rep(i,<span class="hljs-number">0</span>,t)&#123;ll a;<span class="hljs-built_in">cin</span>&gt;&gt;a;<span class="hljs-built_in">cout</span>&lt;&lt;dp[a]&lt;&lt;<span class="hljs-built_in">endl</span>;&#125;&#125;&#125;</code></pre><h1 id="收获与反思"><a href="#收获与反思" class="headerlink" title="收获与反思"></a>收获与反思</h1><p>暂无，水题</p>]]></content>
    
    
    <categories>
      
      <category>Computer Science</category>
      
      <category>ACM</category>
      
      <category>CSU</category>
      
    </categories>
    
    
    <tags>
      
      <tag>ACM</tag>
      
      <tag>CSU</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>【UVA-12034】解题报告（递推，DP）</title>
    <link href="/post/5f341cbe.html"/>
    <url>/post/5f341cbe.html</url>
    
    <content type="html"><![CDATA[<h1 id="原始题目"><a href="#原始题目" class="headerlink" title="原始题目"></a>原始题目</h1><h2 id="12034-Race"><a href="#12034-Race" class="headerlink" title="12034 - Race"></a>12034 - Race</h2><ul><li>Time limit: 1.000 seconds</li></ul><p>Disky and Sooma, two of the biggest mega minds of Bangladesh went to a far country. They ate, coded<br>and wandered around, even in their holidays. They passed several months in this way. But everything<br>has an end. A holy person, Munsiji came into their life. Munsiji took them to derby (horse racing).<br>Munsiji enjoyed the race, but as usual Disky and Sooma did their as usual task instead of passing some<br>romantic moments. They were thinking- in how many ways a race can finish! Who knows, maybe this<br>is their romance!</p><a id="more"></a><p>In a race there are n horses. You have to output the number of ways the race can finish. Note that,<br>more than one horse may get the same position. For example, 2 horses can finish in 3 ways.</p><ol><li>Both first</li><li>horse1 first and horse2 second</li><li>horse2 first and horse1 second</li></ol><h3 id="Input"><a href="#Input" class="headerlink" title="Input"></a>Input</h3><p>Input starts with an integer T (≤ 1000), denoting the number of test cases. Each case starts with a<br>line containing an integer n (1 ≤ n ≤ 1000).</p><h3 id="Output"><a href="#Output" class="headerlink" title="Output"></a>Output</h3><p>For each case, print the case number and the number of ways the race can finish. The result can be<br>very large, print the result modulo 10056.</p><h3 id="Sample-Input"><a href="#Sample-Input" class="headerlink" title="Sample Input"></a>Sample Input</h3><pre><code>3123</code></pre><h3 id="Sample-Output"><a href="#Sample-Output" class="headerlink" title="Sample Output"></a>Sample Output</h3><pre><code>Case 1: 1Case 2: 3Case 3: 13</code></pre><h1 id="题目大意"><a href="#题目大意" class="headerlink" title="题目大意"></a>题目大意</h1><p>一场赛马比赛中由n匹马，任意两匹马可以同时到达或者一先一后到达，问一共有多少种到达的可能。</p><h1 id="解题思路"><a href="#解题思路" class="headerlink" title="解题思路"></a>解题思路</h1><ul><li>考虑dp。</li><li>$dp[i][j]$表示i匹马用j次到达的可能情况数。<ul><li>考虑第i匹马的情况，可能和前i-1匹马一同到达，或者单独到达（即第i匹马到达时有并列，无并列）。$dp[i][j]=j*(dp[i-1][j]+dp[i-1][j-1])$，乘j是因为第i匹马名次有j种可能。</li></ul></li></ul><h1 id="解题代码"><a href="#解题代码" class="headerlink" title="解题代码"></a>解题代码</h1><pre><code class="hljs C++"><span class="hljs-meta">#<span class="hljs-meta-keyword">include</span> <span class="hljs-meta-string">&lt;cstdio&gt;</span></span><span class="hljs-meta">#<span class="hljs-meta-keyword">include</span> <span class="hljs-meta-string">&lt;cstring&gt;</span></span><span class="hljs-meta">#<span class="hljs-meta-keyword">include</span> <span class="hljs-meta-string">&lt;iostream&gt;</span></span><span class="hljs-meta">#<span class="hljs-meta-keyword">include</span> <span class="hljs-meta-string">&lt;set&gt;</span></span><span class="hljs-meta">#<span class="hljs-meta-keyword">include</span> <span class="hljs-meta-string">&lt;algorithm&gt;</span></span><span class="hljs-meta">#<span class="hljs-meta-keyword">include</span> <span class="hljs-meta-string">&lt;queue&gt;</span></span><span class="hljs-meta">#<span class="hljs-meta-keyword">include</span> <span class="hljs-meta-string">&lt;map&gt;</span></span><span class="hljs-meta">#<span class="hljs-meta-keyword">include</span> <span class="hljs-meta-string">&lt;string&gt;</span></span><span class="hljs-meta">#<span class="hljs-meta-keyword">define</span> eps 1e-8</span><span class="hljs-meta">#<span class="hljs-meta-keyword">define</span> INF 0x3f3f3f3f</span><span class="hljs-meta">#<span class="hljs-meta-keyword">define</span> rep(i,a,n) for(int i=a;i&lt;n;i++)</span><span class="hljs-meta">#<span class="hljs-meta-keyword">define</span> per(i,a,n) for(int i=n-1;i&gt;=a;i--)</span><span class="hljs-keyword">using</span> <span class="hljs-keyword">namespace</span> <span class="hljs-built_in">std</span>;<span class="hljs-keyword">const</span> <span class="hljs-keyword">int</span> maxn=<span class="hljs-number">1e8</span>+<span class="hljs-number">2</span>;<span class="hljs-keyword">const</span> <span class="hljs-keyword">int</span> mod=<span class="hljs-number">10056</span>;<span class="hljs-keyword">typedef</span> <span class="hljs-keyword">long</span> <span class="hljs-keyword">long</span> ll;ll dp[<span class="hljs-number">1005</span>][<span class="hljs-number">1005</span>];ll ans[<span class="hljs-number">1005</span>];<span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span>&#123;<span class="hljs-keyword">int</span> t;<span class="hljs-built_in">memset</span>(dp,<span class="hljs-number">0</span>,<span class="hljs-keyword">sizeof</span>(dp));<span class="hljs-built_in">memset</span>(ans,<span class="hljs-number">0</span>,<span class="hljs-keyword">sizeof</span>(ans));dp[<span class="hljs-number">1</span>][<span class="hljs-number">1</span>]=<span class="hljs-number">1</span>;ans[<span class="hljs-number">1</span>]=<span class="hljs-number">1</span>;<span class="hljs-keyword">for</span>(<span class="hljs-keyword">int</span> i=<span class="hljs-number">2</span>;i&lt;=<span class="hljs-number">1000</span>;i++)&#123;<span class="hljs-keyword">int</span> sum=<span class="hljs-number">0</span>;<span class="hljs-keyword">for</span>(<span class="hljs-keyword">int</span> j=<span class="hljs-number">1</span>;j&lt;=i;j++)&#123;<span class="hljs-keyword">if</span>(j==<span class="hljs-number">1</span>) dp[i][j]=<span class="hljs-number">1</span>;<span class="hljs-keyword">else</span> dp[i][j]=j*(dp[i<span class="hljs-number">-1</span>][j]+dp[i<span class="hljs-number">-1</span>][j<span class="hljs-number">-1</span>])%mod;sum=(sum+dp[i][j])%mod;<span class="hljs-comment">//cout&lt;&lt;"ans["&lt;&lt;i&lt;&lt;"]="&lt;&lt;ans[i]&lt;&lt;endl;</span>&#125; ans[i]=sum;<span class="hljs-comment">//cout&lt;&lt;i&lt;&lt;" "&lt;&lt;ans[i]&lt;&lt; "  "&lt;&lt;ans[i-1]&lt;&lt;endl; </span>&#125;<span class="hljs-comment">//for(int i=2;i&lt;=1005;i++)&#123;</span><span class="hljs-comment">//cout&lt;&lt;"i="&lt;&lt;i&lt;&lt;" "&lt;&lt;ans[i]&lt;&lt;endl; </span><span class="hljs-comment">//&#125;</span><span class="hljs-built_in">cin</span>&gt;&gt;t;<span class="hljs-keyword">int</span> n,cas=<span class="hljs-number">1</span>;<span class="hljs-keyword">while</span>(t--)    &#123;        <span class="hljs-built_in">cin</span>&gt;&gt;n;        <span class="hljs-built_in">cout</span>&lt;&lt;<span class="hljs-string">"Case "</span>&lt;&lt;cas++&lt;&lt;<span class="hljs-string">": "</span> &lt;&lt;ans[n]&lt;&lt;<span class="hljs-built_in">endl</span>;    &#125;&#125;</code></pre><h1 id="收获与反思"><a href="#收获与反思" class="headerlink" title="收获与反思"></a>收获与反思</h1><p>注意取模的运算规则，考虑dp与最终答案的关系。</p>]]></content>
    
    
    <categories>
      
      <category>Computer Science</category>
      
      <category>ACM</category>
      
      <category>UVA</category>
      
    </categories>
    
    
    <tags>
      
      <tag>ACM</tag>
      
      <tag>UVA</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>【URAL-1081】解题报告（递推，斐波那契）</title>
    <link href="/post/40dfaace.html"/>
    <url>/post/40dfaace.html</url>
    
    <content type="html"><![CDATA[<h1 id="题目大意"><a href="#题目大意" class="headerlink" title="题目大意"></a>题目大意</h1><h2 id="1081-Binary-Lexicographic-Sequence"><a href="#1081-Binary-Lexicographic-Sequence" class="headerlink" title="1081. Binary Lexicographic Sequence"></a>1081. Binary Lexicographic Sequence</h2><ul><li>Time limit: 0.5 second</li><li>Memory limit: 64 MB</li></ul><p>Consider all the sequences with length (0 &lt; N &lt; 44), containing only the elements 0 and 1, and no two ones are adjacent (110 is not a valid sequence of length 3, 0101 is a valid sequence of length 4). Write a program which finds the sequence, which is on K-th place (0 &lt; K &lt; 109) in the lexicographically sorted in ascending order collection of the described sequences.<br><a id="more"></a></p><h3 id="Input"><a href="#Input" class="headerlink" title="Input"></a>Input</h3><p>The first line of input contains two positive integers N and K.</p><h3 id="Output"><a href="#Output" class="headerlink" title="Output"></a>Output</h3><p>Write the found sequence or −1 if the number K is larger then the number of valid sequences.</p><h3 id="Sample"><a href="#Sample" class="headerlink" title="Sample"></a>Sample</h3><h4 id="input"><a href="#input" class="headerlink" title="input"></a>input</h4><pre><code>3 1  </code></pre><h4 id="output"><a href="#output" class="headerlink" title="output"></a>output</h4><pre><code>000</code></pre><h3 id="Problem-Author"><a href="#Problem-Author" class="headerlink" title="Problem Author:"></a>Problem Author:</h3><p>Emil Kelevedzhiev</p><h3 id="Problem-Source"><a href="#Problem-Source" class="headerlink" title="Problem Source:"></a>Problem Source:</h3><p>Winter Mathematical Festival Varna ‘2001 Informatics Tournament</p><h1 id="题目大意-1"><a href="#题目大意-1" class="headerlink" title="题目大意"></a>题目大意</h1><p>求词典序下第K个长度为N且无相邻位置都为1的0、1序列。无解时输出-1。</p><h1 id="解题思路"><a href="#解题思路" class="headerlink" title="解题思路"></a>解题思路</h1><ul><li>先考虑长度为n的符合要求序列有多少个。<ul><li>1（2个）:0 1</li><li>2（3个）:00 01 10</li><li>3（5个）:000 001 010 100 101</li><li>4（8个）:0000 0001 0010 0100 0101 1000 1001 1010</li><li>5（13个）:00000 00001 00010 00100 00101 01000 01001 01010 10000 10001 10010 10100 10101</li></ul></li><li>发现规律，个数为斐波那契数列。构成原因：dp[k+1]的前dp[k]项为前面补0，后dp[k-1]项为前面补10</li></ul><h1 id="解题代码"><a href="#解题代码" class="headerlink" title="解题代码"></a>解题代码</h1><pre><code class="hljs C++"><span class="hljs-meta">#<span class="hljs-meta-keyword">include</span> <span class="hljs-meta-string">&lt;cstdio&gt;</span></span><span class="hljs-meta">#<span class="hljs-meta-keyword">include</span> <span class="hljs-meta-string">&lt;cstring&gt;</span></span><span class="hljs-meta">#<span class="hljs-meta-keyword">include</span> <span class="hljs-meta-string">&lt;iostream&gt;</span></span><span class="hljs-meta">#<span class="hljs-meta-keyword">include</span> <span class="hljs-meta-string">&lt;set&gt;</span></span><span class="hljs-meta">#<span class="hljs-meta-keyword">include</span> <span class="hljs-meta-string">&lt;algorithm&gt;</span></span><span class="hljs-meta">#<span class="hljs-meta-keyword">include</span> <span class="hljs-meta-string">&lt;queue&gt;</span></span><span class="hljs-meta">#<span class="hljs-meta-keyword">include</span> <span class="hljs-meta-string">&lt;map&gt;</span></span><span class="hljs-meta">#<span class="hljs-meta-keyword">include</span> <span class="hljs-meta-string">&lt;string&gt;</span></span><span class="hljs-meta">#<span class="hljs-meta-keyword">define</span> eps 1e-8</span><span class="hljs-meta">#<span class="hljs-meta-keyword">define</span> INF 0x3f3f3f3f</span><span class="hljs-meta">#<span class="hljs-meta-keyword">define</span> rep(i,a,n) for(int i=a;i&lt;n;i++)</span><span class="hljs-meta">#<span class="hljs-meta-keyword">define</span> per(i,a,n) for(int i=n-1;i&gt;=a;i--)</span><span class="hljs-keyword">using</span> <span class="hljs-keyword">namespace</span> <span class="hljs-built_in">std</span>;<span class="hljs-keyword">typedef</span> <span class="hljs-keyword">long</span> <span class="hljs-keyword">long</span> ll;<span class="hljs-keyword">const</span> <span class="hljs-keyword">int</span> maxn=<span class="hljs-number">1e5</span>+<span class="hljs-number">5</span>;ll n,k;ll dp[maxn];<span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">solve</span><span class="hljs-params">()</span></span>&#123;dp[<span class="hljs-number">0</span>]=<span class="hljs-number">1</span>;dp[<span class="hljs-number">1</span>]=<span class="hljs-number">2</span>;dp[<span class="hljs-number">2</span>]=<span class="hljs-number">3</span>;rep(i,<span class="hljs-number">3</span>,<span class="hljs-number">50</span>)&#123;dp[i]=dp[i<span class="hljs-number">-1</span>]+dp[i<span class="hljs-number">-2</span>];&#125;&#125;<span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span>&#123;solve();<span class="hljs-keyword">while</span>(~<span class="hljs-built_in">scanf</span>(<span class="hljs-string">"%lld%lld"</span>,&amp;n,&amp;k))&#123;<span class="hljs-keyword">if</span>(k&gt;dp[n])&#123;<span class="hljs-built_in">printf</span>(<span class="hljs-string">"-1\n"</span>);&#125;<span class="hljs-keyword">else</span> &#123;<span class="hljs-keyword">while</span>(n)&#123;n--;<span class="hljs-keyword">if</span>(k&lt;=dp[n])<span class="hljs-built_in">printf</span>(<span class="hljs-string">"0"</span>);<span class="hljs-keyword">else</span>&#123;<span class="hljs-built_in">printf</span>(<span class="hljs-string">"1"</span>);k-=dp[n];&#125;&#125;<span class="hljs-built_in">printf</span>(<span class="hljs-string">"\n"</span>);&#125;&#125;&#125;</code></pre><h1 id="收获与反思"><a href="#收获与反思" class="headerlink" title="收获与反思"></a>收获与反思</h1><ul><li>注意观察斐波那契数列</li></ul>]]></content>
    
    
    <categories>
      
      <category>Computer Science</category>
      
      <category>ACM</category>
      
      <category>URAL</category>
      
    </categories>
    
    
    <tags>
      
      <tag>ACM</tag>
      
      <tag>URAL</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>【HDU-2018】解题报告（递推，水题）</title>
    <link href="/post/36bef409.html"/>
    <url>/post/36bef409.html</url>
    
    <content type="html"><![CDATA[<h1 id="原始题目"><a href="#原始题目" class="headerlink" title="原始题目"></a>原始题目</h1><h2 id="母牛的故事"><a href="#母牛的故事" class="headerlink" title="母牛的故事"></a>母牛的故事</h2><ul><li>Time Limit: 2000/1000 MS (Java/Others)    </li><li>Memory Limit: 65536/32768 K (Java/Others)</li><li>Total Submission(s): 105012    </li><li>Accepted Submission(s): 51527</li></ul><h3 id="Problem-Description"><a href="#Problem-Description" class="headerlink" title="Problem Description"></a>Problem Description</h3><p>有一头母牛，它每年年初生一头小母牛。每头小母牛从第四个年头开始，每年年初也生一头小母牛。请编程实现在第n年的时候，共有多少头母牛？<br> <a id="more"></a></p><h3 id="Input"><a href="#Input" class="headerlink" title="Input"></a>Input</h3><p>输入数据由多个测试实例组成，每个测试实例占一行，包括一个整数n(0&lt;n&lt;55)，n的含义如题目中描述。<br>n=0表示输入数据的结束，不做处理。</p><h3 id="Output"><a href="#Output" class="headerlink" title="Output"></a>Output</h3><p>对于每个测试实例，输出在第n年的时候母牛的数量。<br>每个输出占一行。</p><h3 id="Sample-Input"><a href="#Sample-Input" class="headerlink" title="Sample Input"></a>Sample Input</h3><pre><code>2450</code></pre><h3 id="Sample-Output"><a href="#Sample-Output" class="headerlink" title="Sample Output"></a>Sample Output</h3><pre><code>246</code></pre><h3 id="Author"><a href="#Author" class="headerlink" title="Author"></a>Author</h3><p>lcy</p><h3 id="Source"><a href="#Source" class="headerlink" title="Source"></a>Source</h3><p>C语言程序设计练习（三）</p><h3 id="Recommend"><a href="#Recommend" class="headerlink" title="Recommend"></a>Recommend</h3><p>lcy</p><h1 id="题目大意"><a href="#题目大意" class="headerlink" title="题目大意"></a>题目大意</h1><p>如题</p><h1 id="解题思路"><a href="#解题思路" class="headerlink" title="解题思路"></a>解题思路</h1><ul><li>$b[i]$表示第i年的母牛数，$s[i]$表示第i年的小牛数。有$b[i]=b[i-1]+b[i-3]$;$s[i]=s[i-1]-b[i-3]+b[i]$;</li><li>即第i年的母牛等于i-1年的母牛数加上三年前母牛产的小牛数（今年长成母牛），第i年的小牛数等于第i-1年的小牛数减去三年前新产的小牛数（今年长成母牛）加上今年新产的小牛。</li><li>输出大小牛的和<h1 id="解题代码"><a href="#解题代码" class="headerlink" title="解题代码"></a>解题代码</h1><pre><code class="hljs C++"><span class="hljs-meta">#<span class="hljs-meta-keyword">include</span> <span class="hljs-meta-string">&lt;cstdio&gt;</span></span><span class="hljs-meta">#<span class="hljs-meta-keyword">include</span> <span class="hljs-meta-string">&lt;cstring&gt;</span></span><span class="hljs-meta">#<span class="hljs-meta-keyword">include</span> <span class="hljs-meta-string">&lt;iostream&gt;</span></span><span class="hljs-meta">#<span class="hljs-meta-keyword">include</span> <span class="hljs-meta-string">&lt;set&gt;</span></span><span class="hljs-meta">#<span class="hljs-meta-keyword">include</span> <span class="hljs-meta-string">&lt;algorithm&gt;</span></span><span class="hljs-meta">#<span class="hljs-meta-keyword">include</span> <span class="hljs-meta-string">&lt;queue&gt;</span></span><span class="hljs-meta">#<span class="hljs-meta-keyword">include</span> <span class="hljs-meta-string">&lt;map&gt;</span></span><span class="hljs-meta">#<span class="hljs-meta-keyword">include</span> <span class="hljs-meta-string">&lt;string&gt;</span></span><span class="hljs-meta">#<span class="hljs-meta-keyword">define</span> eps 1e-8</span><span class="hljs-meta">#<span class="hljs-meta-keyword">define</span> INF 0x3f3f3f3f</span><span class="hljs-meta">#<span class="hljs-meta-keyword">define</span> rep(i,a,n) for(int i=a;i&lt;n;i++)</span><span class="hljs-meta">#<span class="hljs-meta-keyword">define</span> per(i,a,n) for(int i=n-1;i&gt;=a;i--)</span><span class="hljs-keyword">using</span> <span class="hljs-keyword">namespace</span> <span class="hljs-built_in">std</span>;<span class="hljs-keyword">const</span> <span class="hljs-keyword">int</span> maxn=<span class="hljs-number">1e8</span>+<span class="hljs-number">2</span>;<span class="hljs-keyword">typedef</span> <span class="hljs-keyword">long</span> <span class="hljs-keyword">long</span> ll;<span class="hljs-keyword">int</span> b[<span class="hljs-number">100</span>],s[<span class="hljs-number">100</span>];<span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">solve</span><span class="hljs-params">()</span></span>&#123;b[<span class="hljs-number">1</span>]=b[<span class="hljs-number">2</span>]=b[<span class="hljs-number">3</span>]=b[<span class="hljs-number">4</span>]=<span class="hljs-number">1</span>;s[<span class="hljs-number">1</span>]=<span class="hljs-number">0</span>;s[<span class="hljs-number">2</span>]=<span class="hljs-number">1</span>;s[<span class="hljs-number">3</span>]=<span class="hljs-number">2</span>;s[<span class="hljs-number">4</span>]=<span class="hljs-number">3</span>;<span class="hljs-keyword">for</span>(<span class="hljs-keyword">int</span> i=<span class="hljs-number">5</span>;i&lt;<span class="hljs-number">55</span>;i++)&#123;b[i]=b[i<span class="hljs-number">-1</span>]+b[i<span class="hljs-number">-3</span>];s[i]=s[i<span class="hljs-number">-1</span>]-b[i<span class="hljs-number">-3</span>]+b[i];&#125;&#125;<span class="hljs-keyword">int</span> n;<span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span>&#123;solve();<span class="hljs-keyword">while</span>(<span class="hljs-built_in">cin</span>&gt;&gt;n&amp;&amp;n)&#123;<span class="hljs-built_in">cout</span>&lt;&lt;b[n]+s[n]&lt;&lt;<span class="hljs-built_in">endl</span>;&#125;&#125;</code></pre></li></ul><h1 id="收获与反思"><a href="#收获与反思" class="headerlink" title="收获与反思"></a>收获与反思</h1><p>暂无</p>]]></content>
    
    
    <categories>
      
      <category>Computer Science</category>
      
      <category>ACM</category>
      
      <category>HDU</category>
      
    </categories>
    
    
    <tags>
      
      <tag>ACM</tag>
      
      <tag>HDU</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>【POJ-1664】解题报告（递推，dp）</title>
    <link href="/post/bde4b1f8.html"/>
    <url>/post/bde4b1f8.html</url>
    
    <content type="html"><![CDATA[<h1 id="原始题目"><a href="#原始题目" class="headerlink" title="原始题目"></a>原始题目</h1><h2 id="放苹果"><a href="#放苹果" class="headerlink" title="放苹果"></a>放苹果</h2><ul><li>Time Limit: 1000MS</li><li>Memory Limit: 10000K</li><li>Total Submissions: 37069</li><li>Accepted: 22825</li></ul><h3 id="Description"><a href="#Description" class="headerlink" title="Description"></a>Description</h3><p>把 M 个同样的苹果放在 N 个同样的盘子里，允许有的盘子空着不放，问共有多少种不同的分法？（用 K 表示）5，1，1 和 1，5，1 是同一种分法。</p><a id="more"></a><h3 id="Input"><a href="#Input" class="headerlink" title="Input"></a>Input</h3><p>第一行是测试数据的数目$ t(0 \le t \le 20)$。以下每行均包含二个整数 M 和 N，以空格分开。 $ 1 \le M , N \le 10 $。</p><h3 id="Output"><a href="#Output" class="headerlink" title="Output"></a>Output</h3><p>对输入的每组数据 M 和 N，用一行输出相应的 K。</p><h3 id="Sample-Input"><a href="#Sample-Input" class="headerlink" title="Sample Input"></a>Sample Input</h3><pre><code>17 3</code></pre><h3 id="Sample-Output"><a href="#Sample-Output" class="headerlink" title="Sample Output"></a>Sample Output</h3><pre><code>8</code></pre><h3 id="Source"><a href="#Source" class="headerlink" title="Source"></a>Source</h3><p>lwx@POJ</p><h1 id="题目大意"><a href="#题目大意" class="headerlink" title="题目大意"></a>题目大意</h1><p>如题</p><h1 id="解题思路"><a href="#解题思路" class="headerlink" title="解题思路"></a>解题思路</h1><ul><li>$dp[i][j]$ 表示 i 个苹果 j 个盘子的分法。</li><li>状态转移： - 当$i&lt;j$时，$dp[i][j]=dp[i][i]$ （不区分盘子，所以盘子多余的情况数和盘子恰好和苹果数相等的情况数相等） - 当$i\geqslantj$，$dp[i][j]=dp[i-j][j]+dp[i][j-1]$ （每个盘子都有苹果和有一个盘子没有苹果两种状况转移）<br>注意初始的情况就好。</li></ul><h1 id="解题代码"><a href="#解题代码" class="headerlink" title="解题代码"></a>解题代码</h1><pre><code class="hljs C++"><span class="hljs-meta">#<span class="hljs-meta-keyword">include</span> <span class="hljs-meta-string">&lt;cstdio&gt;</span></span><span class="hljs-meta">#<span class="hljs-meta-keyword">include</span> <span class="hljs-meta-string">&lt;cstring&gt;</span></span><span class="hljs-meta">#<span class="hljs-meta-keyword">include</span> <span class="hljs-meta-string">&lt;iostream&gt;</span></span><span class="hljs-meta">#<span class="hljs-meta-keyword">include</span> <span class="hljs-meta-string">&lt;set&gt;</span></span><span class="hljs-meta">#<span class="hljs-meta-keyword">include</span> <span class="hljs-meta-string">&lt;algorithm&gt;</span></span><span class="hljs-meta">#<span class="hljs-meta-keyword">include</span> <span class="hljs-meta-string">&lt;queue&gt;</span></span><span class="hljs-meta">#<span class="hljs-meta-keyword">include</span> <span class="hljs-meta-string">&lt;map&gt;</span></span><span class="hljs-meta">#<span class="hljs-meta-keyword">include</span> <span class="hljs-meta-string">&lt;string&gt;</span></span><span class="hljs-meta">#<span class="hljs-meta-keyword">define</span> eps 1e-8</span><span class="hljs-meta">#<span class="hljs-meta-keyword">define</span> INF 0x3f3f3f3f</span><span class="hljs-meta">#<span class="hljs-meta-keyword">define</span> rep(i,a,n) for(int i=a;i&lt;n;i++)</span><span class="hljs-meta">#<span class="hljs-meta-keyword">define</span> per(i,a,n) for(int i=n-1;i&gt;=a;i--)</span><span class="hljs-keyword">using</span> <span class="hljs-keyword">namespace</span> <span class="hljs-built_in">std</span>;<span class="hljs-keyword">const</span> <span class="hljs-keyword">int</span> maxn=<span class="hljs-number">1e8</span>+<span class="hljs-number">2</span>;<span class="hljs-keyword">typedef</span> <span class="hljs-keyword">long</span> <span class="hljs-keyword">long</span> ll;ll dp[<span class="hljs-number">22</span>][<span class="hljs-number">22</span>];<span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">solve</span><span class="hljs-params">()</span></span>&#123;<span class="hljs-built_in">memset</span>(dp,<span class="hljs-number">0</span>,<span class="hljs-keyword">sizeof</span>(dp));dp[<span class="hljs-number">0</span>][<span class="hljs-number">0</span>]=<span class="hljs-number">1</span>;<span class="hljs-keyword">for</span>(<span class="hljs-keyword">int</span> i=<span class="hljs-number">0</span>;i&lt;=<span class="hljs-number">21</span>;i++)&#123;<span class="hljs-keyword">for</span>(<span class="hljs-keyword">int</span> j=<span class="hljs-number">0</span>;j&lt;=<span class="hljs-number">21</span>;j++)&#123;<span class="hljs-keyword">if</span>(i==<span class="hljs-number">0</span>) dp[i][j]=<span class="hljs-number">1</span>;<span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span>(j==<span class="hljs-number">0</span>) dp[i][j]=<span class="hljs-number">0</span>;<span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span>(j==<span class="hljs-number">1</span>) dp[i][j]=<span class="hljs-number">1</span>;<span class="hljs-keyword">else</span> &#123;<span class="hljs-keyword">if</span>(i&lt;j) dp[i][j]=dp[i][i];<span class="hljs-keyword">else</span> dp[i][j]=dp[i][j<span class="hljs-number">-1</span>]+dp[i-j][j];&#125;&#125;&#125;&#125;<span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span>&#123;<span class="hljs-keyword">int</span> t;solve();<span class="hljs-keyword">while</span>(<span class="hljs-built_in">cin</span>&gt;&gt;t)&#123;<span class="hljs-keyword">int</span> m,n;rep(i,<span class="hljs-number">0</span>,t)&#123;<span class="hljs-built_in">cin</span>&gt;&gt;m&gt;&gt;n;<span class="hljs-built_in">cout</span>&lt;&lt;dp[m][n]&lt;&lt;<span class="hljs-built_in">endl</span>;&#125;&#125;&#125;</code></pre><h1 id="收获与反思"><a href="#收获与反思" class="headerlink" title="收获与反思"></a>收获与反思</h1><p>注意边界情况的考量</p>]]></content>
    
    
    <categories>
      
      <category>Computer Science</category>
      
      <category>ACM</category>
      
      <category>POJ</category>
      
    </categories>
    
    
    <tags>
      
      <tag>ACM</tag>
      
      <tag>POJ</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>【HDU-2050】解题报告（递推，几何）</title>
    <link href="/post/38f8b110.html"/>
    <url>/post/38f8b110.html</url>
    
    <content type="html"><![CDATA[<h1 id="原始题目"><a href="#原始题目" class="headerlink" title="原始题目"></a>原始题目</h1><h2 id="折线分割平面"><a href="#折线分割平面" class="headerlink" title="折线分割平面"></a>折线分割平面</h2><ul><li>Time Limit: 2000/1000 MS (Java/Others)</li><li>Memory Limit: 65536/32768 K (Java/Others)</li><li>Total Submission(s): 37773</li><li>Accepted Submission(s): 25282</li></ul><h3 id="Problem-Description"><a href="#Problem-Description" class="headerlink" title="Problem Description"></a>Problem Description</h3><p>我们看到过很多直线分割平面的题目，今天的这个题目稍微有些变化，我们要求的是n条折线分割平面的最大数目。比如，一条折线可以将平面分成两部分，两条折线最多可以将平面分成7部分，具体如下所示。</p><p><img src="https://eddyblog.oss-cn-shenzhen.aliyuncs.com/%E3%80%90HDU-2050%E3%80%91%E8%A7%A3%E9%A2%98%E6%8A%A5%E5%91%8A%EF%BC%88%E9%80%92%E6%8E%A8%EF%BC%8C%E5%87%A0%E4%BD%95%EF%BC%89/1.jpg" srcset="/img/loading.gif" alt="1.jpg"></p> <a id="more"></a><h3 id="Input"><a href="#Input" class="headerlink" title="Input"></a>Input</h3><p>输入数据的第一行是一个整数$C$,表示测试实例的个数，然后是$C$ 行数据，每行包含一个整数$n ( 0 &lt; n \le 10000)$,表示折线的数量。</p><h3 id="Output"><a href="#Output" class="headerlink" title="Output"></a>Output</h3><p>对于每个测试实例，请输出平面的最大分割数，每个实例的输出占一行。</p><h3 id="Sample-Input"><a href="#Sample-Input" class="headerlink" title="Sample Input"></a>Sample Input</h3><pre><code>212</code></pre><h3 id="Sample-Output"><a href="#Sample-Output" class="headerlink" title="Sample Output"></a>Sample Output</h3><pre><code>27</code></pre><h3 id="Author"><a href="#Author" class="headerlink" title="Author"></a>Author</h3><p>lcy</p><h3 id="Source"><a href="#Source" class="headerlink" title="Source"></a>Source</h3><p>递推求解专题练习（For Beginner）</p><h3 id="Recommend"><a href="#Recommend" class="headerlink" title="Recommend"></a>Recommend</h3><p>lcy</p><h1 id="题目大意"><a href="#题目大意" class="headerlink" title="题目大意"></a>题目大意</h1><p>如题</p><h1 id="解题思路"><a href="#解题思路" class="headerlink" title="解题思路"></a>解题思路</h1><p>折线类题目思路：</p><ul><li>dp[i]=dp[i-1]+新增交点数+1</li></ul><p>题目数据过大则先手算通项公式。<br>数据小可以直接递推</p><h1 id="解题代码"><a href="#解题代码" class="headerlink" title="解题代码"></a>解题代码</h1><ul><li>递推写法</li></ul><pre><code class="hljs C++"><span class="hljs-meta">#<span class="hljs-meta-keyword">include</span> <span class="hljs-meta-string">&lt;cstdio&gt;</span></span><span class="hljs-meta">#<span class="hljs-meta-keyword">include</span> <span class="hljs-meta-string">&lt;cstring&gt;</span></span><span class="hljs-meta">#<span class="hljs-meta-keyword">include</span> <span class="hljs-meta-string">&lt;iostream&gt;</span></span><span class="hljs-meta">#<span class="hljs-meta-keyword">include</span> <span class="hljs-meta-string">&lt;set&gt;</span></span><span class="hljs-meta">#<span class="hljs-meta-keyword">include</span> <span class="hljs-meta-string">&lt;algorithm&gt;</span></span><span class="hljs-meta">#<span class="hljs-meta-keyword">include</span> <span class="hljs-meta-string">&lt;queue&gt;</span></span><span class="hljs-meta">#<span class="hljs-meta-keyword">include</span> <span class="hljs-meta-string">&lt;map&gt;</span></span><span class="hljs-meta">#<span class="hljs-meta-keyword">include</span> <span class="hljs-meta-string">&lt;string&gt;</span></span><span class="hljs-meta">#<span class="hljs-meta-keyword">define</span> eps 1e-8</span><span class="hljs-meta">#<span class="hljs-meta-keyword">define</span> INF 0x3f3f3f3f</span><span class="hljs-meta">#<span class="hljs-meta-keyword">define</span> rep(i,a,n) for(int i=a;i&lt;n;i++)</span><span class="hljs-meta">#<span class="hljs-meta-keyword">define</span> per(i,a,n) for(int i=n-1;i&gt;=a;i--)</span><span class="hljs-keyword">using</span> <span class="hljs-keyword">namespace</span> <span class="hljs-built_in">std</span>;<span class="hljs-keyword">const</span> <span class="hljs-keyword">int</span> maxn=<span class="hljs-number">1e5</span>+<span class="hljs-number">5</span>;<span class="hljs-keyword">typedef</span> <span class="hljs-keyword">long</span> <span class="hljs-keyword">long</span> ll;ll dp[maxn];<span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">solve</span><span class="hljs-params">()</span></span>&#123;<span class="hljs-built_in">memset</span>(dp,<span class="hljs-number">0</span>,<span class="hljs-keyword">sizeof</span>(dp));dp[<span class="hljs-number">1</span>]=<span class="hljs-number">1</span>;dp[<span class="hljs-number">2</span>]=<span class="hljs-number">2</span>;rep(i,<span class="hljs-number">3</span>,<span class="hljs-number">50</span>)&#123;dp[i]=dp[i<span class="hljs-number">-1</span>]+dp[i<span class="hljs-number">-2</span>];&#125; &#125;<span class="hljs-keyword">using</span> <span class="hljs-keyword">namespace</span> <span class="hljs-built_in">std</span>;<span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span>&#123;<span class="hljs-keyword">int</span> t;solve();<span class="hljs-keyword">while</span>(<span class="hljs-built_in">cin</span>&gt;&gt;t)&#123;rep(i,<span class="hljs-number">0</span>,t)&#123;ll a;<span class="hljs-built_in">cin</span>&gt;&gt;a;<span class="hljs-built_in">cout</span>&lt;&lt;dp[a]&lt;&lt;<span class="hljs-built_in">endl</span>;&#125;&#125;&#125;</code></pre><ul><li>通项写法</li></ul><pre><code class="hljs C++"><span class="hljs-meta">#<span class="hljs-meta-keyword">include</span> <span class="hljs-meta-string">&lt;cstdio&gt;</span></span><span class="hljs-meta">#<span class="hljs-meta-keyword">include</span> <span class="hljs-meta-string">&lt;cstring&gt;</span></span><span class="hljs-meta">#<span class="hljs-meta-keyword">include</span> <span class="hljs-meta-string">&lt;iostream&gt;</span></span><span class="hljs-meta">#<span class="hljs-meta-keyword">include</span> <span class="hljs-meta-string">&lt;set&gt;</span></span><span class="hljs-meta">#<span class="hljs-meta-keyword">include</span> <span class="hljs-meta-string">&lt;algorithm&gt;</span></span><span class="hljs-meta">#<span class="hljs-meta-keyword">include</span> <span class="hljs-meta-string">&lt;queue&gt;</span></span><span class="hljs-meta">#<span class="hljs-meta-keyword">include</span> <span class="hljs-meta-string">&lt;map&gt;</span></span><span class="hljs-meta">#<span class="hljs-meta-keyword">include</span> <span class="hljs-meta-string">&lt;string&gt;</span></span><span class="hljs-meta">#<span class="hljs-meta-keyword">define</span> eps 1e-8</span><span class="hljs-meta">#<span class="hljs-meta-keyword">define</span> INF 0x3f3f3f3f</span><span class="hljs-meta">#<span class="hljs-meta-keyword">define</span> rep(i,a,n) for(int i=a;i&lt;n;i++)</span><span class="hljs-meta">#<span class="hljs-meta-keyword">define</span> per(i,a,n) for(int i=n-1;i&gt;=a;i--)</span><span class="hljs-keyword">using</span> <span class="hljs-keyword">namespace</span> <span class="hljs-built_in">std</span>;<span class="hljs-keyword">const</span> <span class="hljs-keyword">int</span> maxn=<span class="hljs-number">1e5</span>+<span class="hljs-number">5</span>;<span class="hljs-keyword">typedef</span> <span class="hljs-keyword">long</span> <span class="hljs-keyword">long</span> ll;<span class="hljs-keyword">using</span> <span class="hljs-keyword">namespace</span> <span class="hljs-built_in">std</span>;<span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span>&#123;<span class="hljs-keyword">int</span> t;<span class="hljs-keyword">while</span>(<span class="hljs-built_in">cin</span>&gt;&gt;t)&#123;rep(i,<span class="hljs-number">0</span>,t)&#123;ll a;<span class="hljs-built_in">cin</span>&gt;&gt;a;<span class="hljs-comment">//cout&lt;&lt;dp[a]&lt;&lt;endl;</span><span class="hljs-built_in">cout</span>&lt;&lt;(<span class="hljs-number">2</span>*a+<span class="hljs-number">1</span>)*(a<span class="hljs-number">-1</span>)+<span class="hljs-number">2</span>&lt;&lt;<span class="hljs-built_in">endl</span>;&#125;&#125;&#125;</code></pre><h1 id="收获与反思"><a href="#收获与反思" class="headerlink" title="收获与反思"></a>收获与反思</h1><ul><li>Z形线拓展</li></ul>]]></content>
    
    
    <categories>
      
      <category>Computer Science</category>
      
      <category>ACM</category>
      
      <category>HDU</category>
      
    </categories>
    
    
    <tags>
      
      <tag>ACM</tag>
      
      <tag>HDU</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>【HDU-2044】解题报告（递推，水题）</title>
    <link href="/post/52730f61.html"/>
    <url>/post/52730f61.html</url>
    
    <content type="html"><![CDATA[<h1 id="原始题目"><a href="#原始题目" class="headerlink" title="原始题目"></a>原始题目</h1><h2 id="一只小蜜蜂…"><a href="#一只小蜜蜂…" class="headerlink" title="一只小蜜蜂…"></a>一只小蜜蜂…</h2><ul><li>Time Limit: 2000/1000 MS (Java/Others)</li><li>Memory Limit: 65536/32768 K (Java/Others)</li><li>Total Submission(s): 93384</li><li>Accepted Submission(s): 33247</li></ul><h2 id="Problem-Description"><a href="#Problem-Description" class="headerlink" title="Problem Description"></a>Problem Description</h2><p>有一只经过训练的蜜蜂只能爬向右侧相邻的蜂房，不能反向爬行。请编程计算蜜蜂从蜂房a爬到蜂房b的可能路线数。<br>其中，蜂房的结构如下所示。</p><p><img src="https://eddyblog.oss-cn-shenzhen.aliyuncs.com/%E3%80%90HDU-2044%E3%80%91%E8%A7%A3%E9%A2%98%E6%8A%A5%E5%91%8A%EF%BC%88%E9%80%92%E6%8E%A8%EF%BC%8C%E6%B0%B4%E9%A2%98%EF%BC%89/1.jpg" srcset="/img/loading.gif" alt="1.jpg"></p><a id="more"></a><h3 id="Input"><a href="#Input" class="headerlink" title="Input"></a>Input</h3><p>输入数据的第一行是一个整数N,表示测试实例的个数，然后是N 行数据，每行包含两个整数a和b(0&lt;a&lt;b&lt;50)。</p><h3 id="Output"><a href="#Output" class="headerlink" title="Output"></a>Output</h3><p>对于每个测试实例，请输出蜜蜂从蜂房a爬到蜂房b的可能路线数，每个实例的输出占一行。</p><h3 id="Sample-Input"><a href="#Sample-Input" class="headerlink" title="Sample Input"></a>Sample Input</h3><pre><code>21 23 6</code></pre><h3 id="Sample-Output"><a href="#Sample-Output" class="headerlink" title="Sample Output"></a>Sample Output</h3><pre><code>13</code></pre><h3 id="Author"><a href="#Author" class="headerlink" title="Author"></a>Author</h3><p>lcy</p><h2 id="Source"><a href="#Source" class="headerlink" title="Source"></a>Source</h2><p>递推求解专题练习（For Beginner）</p><h3 id="Recommend"><a href="#Recommend" class="headerlink" title="Recommend"></a>Recommend</h3><p>lcy</p><h1 id="题目大意"><a href="#题目大意" class="headerlink" title="题目大意"></a>题目大意</h1><p>如题</p><h1 id="解题思路"><a href="#解题思路" class="headerlink" title="解题思路"></a>解题思路</h1><p>递推，dp初步，$dp[i]=dp[i-1]+dp[i-2]$</p><h1 id="解题代码"><a href="#解题代码" class="headerlink" title="解题代码"></a>解题代码</h1><pre><code class="hljs C++"><span class="hljs-meta">#<span class="hljs-meta-keyword">include</span> <span class="hljs-meta-string">&lt;cstdio&gt;</span></span><span class="hljs-meta">#<span class="hljs-meta-keyword">include</span> <span class="hljs-meta-string">&lt;cstring&gt;</span></span><span class="hljs-meta">#<span class="hljs-meta-keyword">include</span> <span class="hljs-meta-string">&lt;iostream&gt;</span></span><span class="hljs-meta">#<span class="hljs-meta-keyword">include</span> <span class="hljs-meta-string">&lt;set&gt;</span></span><span class="hljs-meta">#<span class="hljs-meta-keyword">include</span> <span class="hljs-meta-string">&lt;algorithm&gt;</span></span><span class="hljs-meta">#<span class="hljs-meta-keyword">include</span> <span class="hljs-meta-string">&lt;queue&gt;</span></span><span class="hljs-meta">#<span class="hljs-meta-keyword">include</span> <span class="hljs-meta-string">&lt;map&gt;</span></span><span class="hljs-meta">#<span class="hljs-meta-keyword">include</span> <span class="hljs-meta-string">&lt;string&gt;</span></span><span class="hljs-meta">#<span class="hljs-meta-keyword">define</span> eps 1e-8</span><span class="hljs-meta">#<span class="hljs-meta-keyword">define</span> INF 0x3f3f3f3f</span><span class="hljs-meta">#<span class="hljs-meta-keyword">define</span> rep(i,a,n) for(int i=a;i&lt;n;i++)</span><span class="hljs-meta">#<span class="hljs-meta-keyword">define</span> per(i,a,n) for(int i=n-1;i&gt;=a;i--)</span><span class="hljs-keyword">using</span> <span class="hljs-keyword">namespace</span> <span class="hljs-built_in">std</span>;<span class="hljs-keyword">const</span> <span class="hljs-keyword">int</span> maxn=<span class="hljs-number">1e5</span>+<span class="hljs-number">5</span>;<span class="hljs-keyword">typedef</span> <span class="hljs-keyword">long</span> <span class="hljs-keyword">long</span> ll;ll dp[<span class="hljs-number">100</span>][<span class="hljs-number">100</span>];<span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span>&#123;ll t;<span class="hljs-built_in">memset</span>(dp,<span class="hljs-number">0</span>,<span class="hljs-keyword">sizeof</span>(dp));dp[<span class="hljs-number">0</span>][<span class="hljs-number">0</span>]=dp[<span class="hljs-number">1</span>][<span class="hljs-number">1</span>]=<span class="hljs-number">0</span>;<span class="hljs-keyword">for</span>(ll i=<span class="hljs-number">1</span>;i&lt;=<span class="hljs-number">50</span><span class="hljs-number">-1</span>;i++)&#123;<span class="hljs-keyword">for</span>(ll j=<span class="hljs-number">1</span>;j&lt;=<span class="hljs-number">50</span>;j++)&#123;<span class="hljs-keyword">if</span>(i==j)dp[i][j]=<span class="hljs-number">0</span>;<span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span>(j==i+<span class="hljs-number">1</span>) dp[i][j]=<span class="hljs-number">1</span>;<span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span>(j==i+<span class="hljs-number">2</span>) dp[i][j]=<span class="hljs-number">2</span>;<span class="hljs-keyword">else</span> dp[i][j]=dp[i][j<span class="hljs-number">-1</span>]+dp[i][j<span class="hljs-number">-2</span>];<span class="hljs-comment">//cout&lt;&lt;i&lt;&lt;" "&lt;&lt;j&lt;&lt;endl;</span>&#125;&#125; <span class="hljs-keyword">while</span>(<span class="hljs-built_in">cin</span>&gt;&gt;t)&#123;ll a,b;rep(i,<span class="hljs-number">0</span>,t)&#123;<span class="hljs-built_in">cin</span>&gt;&gt;a&gt;&gt;b;<span class="hljs-built_in">cout</span>&lt;&lt;dp[a][b]&lt;&lt;<span class="hljs-built_in">endl</span>;&#125;&#125;&#125;</code></pre><h1 id="收获与反思"><a href="#收获与反思" class="headerlink" title="收获与反思"></a>收获与反思</h1><p>没啥</p>]]></content>
    
    
    <categories>
      
      <category>Computer Science</category>
      
      <category>ACM</category>
      
      <category>HDU</category>
      
    </categories>
    
    
    <tags>
      
      <tag>ACM</tag>
      
      <tag>HDU</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>【POJ-3111】解题报告（二分，牛顿迭代，最大化平均值）</title>
    <link href="/post/8f9cfad3.html"/>
    <url>/post/8f9cfad3.html</url>
    
    <content type="html"><![CDATA[<h1 id="原始题目"><a href="#原始题目" class="headerlink" title="原始题目"></a>原始题目</h1><h2 id="K-Best"><a href="#K-Best" class="headerlink" title="K Best"></a>K Best</h2><ul><li>Time Limit: 8000MS        </li><li>Memory Limit: 65536K</li><li>Total Submissions: 13510        </li><li>Accepted: 3466</li><li>Case Time Limit: 2000MS        </li><li>Special Judge</li></ul><h3 id="Description"><a href="#Description" class="headerlink" title="Description"></a>Description</h3><p>Demy has $n$ jewels. Each of her jewels has some value $v_i$ and weight $w_i$.</p><a id="more"></a><p>Since her husband John got broke after recent financial crises, Demy has decided to sell some jewels. She has decided that she would keep k best jewels for herself. She decided to keep such jewels that their specific value is as large as possible. That is, denote the specific value of some set of jewels S = {i1, i2, …, ik} as</p><p>Demy would like to select such k jewels that their specific value is maximal possible. Help her to do so.</p><h3 id="Input"><a href="#Input" class="headerlink" title="Input"></a>Input</h3><p>The first line of the input file contains $n$ — the number of jewels Demy got, and $k$ — the number of jewels she would like to keep $(1 ≤ k ≤ n ≤ 100 000)$.</p><p>The following $n$ lines contain two integer numbers each — $v_i$ and $w_i$ $(0 ≤ v_i ≤ 10^6, 1 ≤ w_i ≤ 10^6$, both the sum of all $v_i$ and the sum of all $w_i$ do not exceed $10^7$).</p><h3 id="Output"><a href="#Output" class="headerlink" title="Output"></a>Output</h3><p>Output $k$ numbers — the numbers of jewels Demy must keep. If there are several solutions, output any one.</p><h3 id="Sample-Input"><a href="#Sample-Input" class="headerlink" title="Sample Input"></a>Sample Input</h3><pre><code>3 21 11 21 3</code></pre><h3 id="Sample-Output"><a href="#Sample-Output" class="headerlink" title="Sample Output"></a>Sample Output</h3><pre><code>1 2</code></pre><h3 id="Source"><a href="#Source" class="headerlink" title="Source"></a>Source</h3><p>Northeastern Europe 2005, Northern Subregion</p><h1 id="题目大意"><a href="#题目大意" class="headerlink" title="题目大意"></a>题目大意</h1><p>给定 $n$ 个珍珠的价值和重量，要求取其中 $k$ 个并使这 $k$ 个珍珠的平均单位重量价值最大。</p><h1 id="解题思路"><a href="#解题思路" class="headerlink" title="解题思路"></a>解题思路</h1><ul><li>对平均单位重量价值二分（二分答案），每一次更新每个珍珠 $r_i=v_i-k*w_i$ 即对平均单位重量价值的差值。</li><li>排序后取差值最大的3个珍珠，若差值之和大于零（说明平均单位重量价值还不够大），left=mid，否则right=mid。逐渐逼近答案</li></ul><h1 id="解题代码"><a href="#解题代码" class="headerlink" title="解题代码"></a>解题代码</h1><pre><code class="hljs C++"><span class="hljs-meta">#<span class="hljs-meta-keyword">include</span> <span class="hljs-meta-string">&lt;cstdio&gt;</span></span><span class="hljs-meta">#<span class="hljs-meta-keyword">include</span> <span class="hljs-meta-string">&lt;cstring&gt;</span></span><span class="hljs-meta">#<span class="hljs-meta-keyword">include</span> <span class="hljs-meta-string">&lt;iostream&gt;</span></span><span class="hljs-meta">#<span class="hljs-meta-keyword">include</span> <span class="hljs-meta-string">&lt;set&gt;</span></span><span class="hljs-meta">#<span class="hljs-meta-keyword">include</span> <span class="hljs-meta-string">&lt;algorithm&gt;</span></span><span class="hljs-meta">#<span class="hljs-meta-keyword">include</span> <span class="hljs-meta-string">&lt;queue&gt;</span></span><span class="hljs-meta">#<span class="hljs-meta-keyword">include</span> <span class="hljs-meta-string">&lt;map&gt;</span></span><span class="hljs-meta">#<span class="hljs-meta-keyword">include</span> <span class="hljs-meta-string">&lt;string&gt;</span></span><span class="hljs-meta">#<span class="hljs-meta-keyword">define</span> eps 1e-8</span><span class="hljs-meta">#<span class="hljs-meta-keyword">define</span> INF 0x3f3f3f3f</span><span class="hljs-meta">#<span class="hljs-meta-keyword">define</span> rep(i,a,n) for(int i=a;i&lt;n;i++)</span><span class="hljs-meta">#<span class="hljs-meta-keyword">define</span> per(i,a,n) for(int i=n-1;i&gt;=a;i--)</span><span class="hljs-keyword">using</span> <span class="hljs-keyword">namespace</span> <span class="hljs-built_in">std</span>;<span class="hljs-keyword">const</span> <span class="hljs-keyword">int</span> maxn=<span class="hljs-number">1e5</span>+<span class="hljs-number">5</span>;<span class="hljs-keyword">double</span> l,r,mid;<span class="hljs-keyword">int</span> n,k;<span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">jewl</span>&#123;</span><span class="hljs-keyword">int</span> id;<span class="hljs-keyword">double</span> vi,wi,ri;&#125;jewls[maxn];<span class="hljs-function"><span class="hljs-keyword">bool</span> <span class="hljs-title">cmp</span><span class="hljs-params">(jewl a,jewl b)</span></span>&#123;<span class="hljs-keyword">return</span> a.ri&gt;b.ri;&#125;<span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span>&#123;<span class="hljs-keyword">while</span>(~<span class="hljs-built_in">scanf</span>(<span class="hljs-string">"%d%d"</span>,&amp;n,&amp;k))&#123;rep(i,<span class="hljs-number">1</span>,n+<span class="hljs-number">1</span>)&#123;<span class="hljs-built_in">scanf</span>(<span class="hljs-string">"%lf%lf"</span>,&amp;jewls[i].vi,&amp;jewls[i].wi);jewls[i].id=i;&#125;l=<span class="hljs-number">0</span>;r=INF;<span class="hljs-comment">//开始二分寻找答案</span><span class="hljs-keyword">while</span>(r-l&gt;eps)&#123;mid=(l+r)/<span class="hljs-number">2</span>;rep(i,<span class="hljs-number">1</span>,n+<span class="hljs-number">1</span>)&#123;jewls[i].ri=jewls[i].vi-mid*jewls[i].wi;&#125;sort(jewls+<span class="hljs-number">1</span>,jewls+n+<span class="hljs-number">1</span>,cmp);<span class="hljs-comment">//寻找最大的k个</span><span class="hljs-keyword">double</span> sum=<span class="hljs-number">0</span>;rep(i,<span class="hljs-number">1</span>,k+<span class="hljs-number">1</span>)&#123;sum+=jewls[i].ri; &#125;<span class="hljs-keyword">if</span>(sum&gt;=<span class="hljs-number">0</span>) l=mid; <span class="hljs-keyword">else</span> r=mid;  &#125; rep(i,<span class="hljs-number">1</span>,k+<span class="hljs-number">1</span>)&#123;<span class="hljs-keyword">if</span>(i==<span class="hljs-number">1</span>) <span class="hljs-built_in">printf</span>(<span class="hljs-string">"%d"</span>,jewls[i].id);<span class="hljs-keyword">else</span> <span class="hljs-built_in">printf</span>(<span class="hljs-string">" %d"</span>,jewls[i].id); &#125;<span class="hljs-built_in">printf</span>(<span class="hljs-string">"\n"</span>);&#125;&#125;</code></pre><h1 id="收获与反思"><a href="#收获与反思" class="headerlink" title="收获与反思"></a>收获与反思</h1><ul><li>浮点数二分</li><li>最大化平均值经典题。</li></ul>]]></content>
    
    
    <categories>
      
      <category>Computer Science</category>
      
      <category>ACM</category>
      
      <category>POJ</category>
      
    </categories>
    
    
    <tags>
      
      <tag>ACM</tag>
      
      <tag>POJ</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>【POJ-2785】解题报告（二分水题）</title>
    <link href="/post/16b5efde.html"/>
    <url>/post/16b5efde.html</url>
    
    <content type="html"><![CDATA[<h1 id="原始题目"><a href="#原始题目" class="headerlink" title="原始题目"></a>原始题目</h1><h2 id="4-Values-whose-Sum-is-0"><a href="#4-Values-whose-Sum-is-0" class="headerlink" title="4 Values whose Sum is 0"></a>4 Values whose Sum is 0</h2><ul><li>Time Limit: 15000MS        </li><li>Memory Limit: 228000K</li><li>Total Submissions: 28507        </li><li>Accepted: 8591</li><li>Case Time Limit: 5000MS</li></ul><h3 id="Description"><a href="#Description" class="headerlink" title="Description"></a>Description</h3><p>The SUM problem can be formulated as follows: given four lists A, B, C, D of integer values, compute how many quadruplet (a, b, c, d ) ∈ A x B x C x D are such that a + b + c + d = 0 . In the following, we assume that all lists have the same size n .</p><h3 id="Input"><a href="#Input" class="headerlink" title="Input"></a>Input</h3><p>The first line of the input file contains the size of the lists n (this value can be as large as 4000). We then have n lines containing four integer values (with absolute value as large as $2^{28}$ ) that belong respectively to A, B, C and D .</p><h3 id="Output"><a href="#Output" class="headerlink" title="Output"></a>Output</h3><p>For each input file, your program has to write the number quadruplets whose sum is zero.</p><h3 id="Sample-Input"><a href="#Sample-Input" class="headerlink" title="Sample Input"></a>Sample Input</h3><pre><code>6-45 22 42 -16-41 -27 56 30-36 53 -37 77-36 30 -75 -4626 -38 -10 62-32 -54 -6 45</code></pre><h3 id="Sample-Output"><a href="#Sample-Output" class="headerlink" title="Sample Output"></a>Sample Output</h3><pre><code>5</code></pre><h3 id="Hint"><a href="#Hint" class="headerlink" title="Hint"></a>Hint</h3><p>Sample Explanation: Indeed, the sum of the five following quadruplets is zero: (-45, -27, 42, 30), (26, 30, -10, -46), (-32, 22, 56, -46),(-32, 30, -75, 77), (-32, -54, 56, 30).</p><h3 id="Source"><a href="#Source" class="headerlink" title="Source"></a>Source</h3><p>Southwestern Europe 2005</p><h1 id="题目大意"><a href="#题目大意" class="headerlink" title="题目大意"></a>题目大意</h1><p>给定四个长度为n的数列，从每一个数列中抽取一个数，问和为零的共有多少种可能。</p><h1 id="解题思路"><a href="#解题思路" class="headerlink" title="解题思路"></a>解题思路</h1><ul><li>预处理出前两个数列的和sum1与后两个数列的和sum2。</li><li>对sum1排序，二分查找sum2中每个元素的相反数，累加输出</li><li>注意不要用binary_search函数，而应该用upper_bound - lower_bound ，因为可能sum1数列中有多个元素值均为 -sum2[i] 。如果用binary_search 只能得到是否有，计数会少计。</li></ul><h1 id="解题代码"><a href="#解题代码" class="headerlink" title="解题代码"></a>解题代码</h1><pre><code class="hljs C++"><span class="hljs-meta">#<span class="hljs-meta-keyword">include</span> <span class="hljs-meta-string">&lt;cstdio&gt;</span></span><span class="hljs-meta">#<span class="hljs-meta-keyword">include</span> <span class="hljs-meta-string">&lt;cstdlib&gt;</span></span><span class="hljs-meta">#<span class="hljs-meta-keyword">include</span> <span class="hljs-meta-string">&lt;iostream&gt;</span></span><span class="hljs-meta">#<span class="hljs-meta-keyword">include</span> <span class="hljs-meta-string">&lt;cstring&gt;</span></span><span class="hljs-meta">#<span class="hljs-meta-keyword">include</span> <span class="hljs-meta-string">&lt;algorithm&gt;</span></span><span class="hljs-meta">#<span class="hljs-meta-keyword">include</span> <span class="hljs-meta-string">&lt;stack&gt;</span></span><span class="hljs-meta">#<span class="hljs-meta-keyword">include</span> <span class="hljs-meta-string">&lt;vector&gt;</span></span><span class="hljs-meta">#<span class="hljs-meta-keyword">include</span> <span class="hljs-meta-string">&lt;set&gt;</span></span><span class="hljs-meta">#<span class="hljs-meta-keyword">include</span> <span class="hljs-meta-string">&lt;map&gt;</span></span><span class="hljs-keyword">using</span> <span class="hljs-keyword">namespace</span> <span class="hljs-built_in">std</span>;<span class="hljs-meta">#<span class="hljs-meta-keyword">define</span> rep(i,a,n) for (int i=a;i&lt;n;i++)</span><span class="hljs-meta">#<span class="hljs-meta-keyword">define</span> per(i,a,n) for (int i=n-1;i&gt;=a;i--)</span><span class="hljs-comment">//#define pb push_back</span><span class="hljs-comment">//#define mp make_pair</span><span class="hljs-comment">//#define np next_permutation</span><span class="hljs-comment">//#define all(x) x.begin(),x.end()</span><span class="hljs-comment">//#define fi first</span><span class="hljs-comment">//#define se second</span><span class="hljs-comment">//#define SZ(x) ((int)(x).size()) </span><span class="hljs-comment">//typedef vector &lt;int&gt; vi;</span><span class="hljs-keyword">typedef</span> <span class="hljs-keyword">long</span> <span class="hljs-keyword">long</span> ll;<span class="hljs-comment">//typedef pair &lt;int,int&gt; pii;</span><span class="hljs-keyword">const</span> <span class="hljs-keyword">int</span> mod=<span class="hljs-number">1e9</span>+<span class="hljs-number">7</span>;<span class="hljs-keyword">const</span> <span class="hljs-keyword">int</span> maxn=<span class="hljs-number">4100</span>;ll sum1[maxn*maxn],sum2[maxn*maxn];ll a[maxn],b[maxn],c[maxn],d[maxn];<span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span>&#123;<span class="hljs-keyword">int</span> n;<span class="hljs-keyword">while</span>(~<span class="hljs-built_in">scanf</span>(<span class="hljs-string">"%d"</span>,&amp;n))&#123;rep(i,<span class="hljs-number">0</span>,n)&#123;<span class="hljs-built_in">scanf</span>(<span class="hljs-string">"%lld %lld %lld %lld"</span>,&amp;a[i],&amp;b[i],&amp;c[i],&amp;d[i]);&#125;rep(i,<span class="hljs-number">0</span>,n)&#123;rep(j,<span class="hljs-number">0</span>,n)&#123;sum1[i*n+j]=a[i]+b[j];sum2[i*n+j]=c[i]+d[j];&#125;&#125;sort(sum1,sum1+n*n);ll ans=<span class="hljs-number">0</span>;rep(i,<span class="hljs-number">0</span>,n*n)&#123;ans+=(upper_bound(sum1,sum1+n*n,-sum2[i])-lower_bound(sum1,sum1+n*n,-sum2[i]));&#125; <span class="hljs-built_in">printf</span>(<span class="hljs-string">"%lld\n"</span>,ans);&#125;&#125;</code></pre><h1 id="收获与反思"><a href="#收获与反思" class="headerlink" title="收获与反思"></a>收获与反思</h1><ul><li>加深STL里三个函数应用和相互区别。</li></ul>]]></content>
    
    
    <categories>
      
      <category>Computer Science</category>
      
      <category>ACM</category>
      
      <category>POJ</category>
      
    </categories>
    
    
    <tags>
      
      <tag>ACM</tag>
      
      <tag>POJ</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>【CodeForces-348A】解题报告（直接或二分）</title>
    <link href="/post/dea65d58.html"/>
    <url>/post/dea65d58.html</url>
    
    <content type="html"><![CDATA[<h1 id="原始题目"><a href="#原始题目" class="headerlink" title="原始题目"></a>原始题目</h1><h2 id="A-Mafia"><a href="#A-Mafia" class="headerlink" title="A. Mafia"></a>A. Mafia</h2><ul><li>time limit per test2 seconds</li><li>memory limit per test256 megabytes</li><li>input：standard input</li><li>output：standard output</li></ul><p>One day n friends gathered together to play “Mafia”. During each round of the game some player must be the supervisor and other n - 1 people take part in the game. For each person we know in how many rounds he wants to be a player, not the supervisor: the i-th person wants to play ai rounds. What is the minimum number of rounds of the “Mafia” game they need to play to let each person play at least as many rounds as they want?</p><a id="more"></a><h3 id="Input"><a href="#Input" class="headerlink" title="Input"></a>Input</h3><p>The first line contains integer $n (3 ≤ n ≤ 10^5)$. The second line contains $n$ space-separated integers $a_1, a_2  \cdots a_n (1 ≤ a_i ≤ 10^9)$ — the i-th number in the list is the number of rounds the i-th person wants to play.</p><h3 id="Output"><a href="#Output" class="headerlink" title="Output"></a>Output</h3><p>In a single line print a single integer — the minimum number of game rounds the friends need to let the i-th person play at least ai rounds.</p><p>Please, do not use the %lld specifier to read or write 64-bit integers in С++. It is preferred to use the cin, cout streams or the %I64d specifier.</p><h3 id="Examples"><a href="#Examples" class="headerlink" title="Examples"></a>Examples</h3><h4 id="input"><a href="#input" class="headerlink" title="input"></a>input</h4><pre><code>33 2 2</code></pre><h4 id="output"><a href="#output" class="headerlink" title="output"></a>output</h4><pre><code>4</code></pre><h4 id="input-1"><a href="#input-1" class="headerlink" title="input"></a>input</h4><pre><code>42 2 2 2</code></pre><h4 id="output-1"><a href="#output-1" class="headerlink" title="output"></a>output</h4><pre><code>3</code></pre><h3 id="Note"><a href="#Note" class="headerlink" title="Note"></a>Note</h3><p>You don’t need to know the rules of “Mafia” to solve this problem. If you’re curious, it’s a game Russia got from the Soviet times: <a href="http://en.wikipedia.org/wiki/Mafia_(party_game" target="_blank" rel="noopener">http://en.wikipedia.org/wiki/Mafia_(party_game</a>).</p><h1 id="题目大意"><a href="#题目大意" class="headerlink" title="题目大意"></a>题目大意</h1><p>$n$ 个人进行游戏，每局游戏需要1人监管，剩下 $n-1$ 人参与游戏，现在给出 $n$ 人每人想至少参与游戏的此数，求满足每个人要求的最少游戏盘数。</p><h1 id="解题思路"><a href="#解题思路" class="headerlink" title="解题思路"></a>解题思路</h1><p>水题，可以直接解或者二分</p><h1 id="解题代码"><a href="#解题代码" class="headerlink" title="解题代码"></a>解题代码</h1><pre><code class="hljs C++"><span class="hljs-meta">#<span class="hljs-meta-keyword">include</span> <span class="hljs-meta-string">&lt;iostream&gt;</span></span><span class="hljs-meta">#<span class="hljs-meta-keyword">include</span> <span class="hljs-meta-string">&lt;cstdio&gt;</span></span><span class="hljs-meta">#<span class="hljs-meta-keyword">include</span> <span class="hljs-meta-string">&lt;cstdlib&gt;</span></span><span class="hljs-meta">#<span class="hljs-meta-keyword">include</span> <span class="hljs-meta-string">&lt;algorithm&gt;</span></span><span class="hljs-meta">#<span class="hljs-meta-keyword">include</span> <span class="hljs-meta-string">&lt;cstring&gt;</span></span><span class="hljs-meta">#<span class="hljs-meta-keyword">include</span> <span class="hljs-meta-string">&lt;cmath&gt;</span></span><span class="hljs-keyword">using</span> <span class="hljs-keyword">namespace</span> <span class="hljs-built_in">std</span>;<span class="hljs-keyword">long</span> <span class="hljs-keyword">long</span>  a[<span class="hljs-number">200010</span>];<span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span>&#123;<span class="hljs-keyword">int</span> n;<span class="hljs-keyword">long</span> <span class="hljs-keyword">long</span> sum=<span class="hljs-number">0</span>,MAX=<span class="hljs-number">0</span>;<span class="hljs-built_in">scanf</span>(<span class="hljs-string">"%d"</span>,&amp;n);<span class="hljs-keyword">for</span>(<span class="hljs-keyword">int</span> i=<span class="hljs-number">1</span>;i&lt;=n;i++) &#123;<span class="hljs-built_in">scanf</span>(<span class="hljs-string">"%I64d"</span>,a+i);sum+=a[i]; MAX=max(a[i],MAX);&#125;<span class="hljs-keyword">long</span> <span class="hljs-keyword">long</span> ans;<span class="hljs-keyword">if</span>(sum%(n<span class="hljs-number">-1</span>)==<span class="hljs-number">0</span>) ans=sum/(n<span class="hljs-number">-1</span>);<span class="hljs-keyword">else</span> ans=sum/(n<span class="hljs-number">-1</span>)+<span class="hljs-number">1</span>;ans=max(MAX,ans);<span class="hljs-built_in">printf</span>(<span class="hljs-string">"%I64d\n"</span>,ans);&#125;</code></pre><h1 id="收获与反思"><a href="#收获与反思" class="headerlink" title="收获与反思"></a>收获与反思</h1><ul><li>二分做法，下界为数列最大值，上界为数列总和，做下面划分<pre><code class="hljs C++"><span class="hljs-keyword">if</span>(mid*(n<span class="hljs-number">-1</span>)&gt;=sum) ri=mid;<span class="hljs-keyword">else</span> le=mid+<span class="hljs-number">1</span>;</code></pre></li></ul>]]></content>
    
    
    <categories>
      
      <category>Computer Science</category>
      
      <category>ACM</category>
      
      <category>CodeForces</category>
      
    </categories>
    
    
    <tags>
      
      <tag>ACM</tag>
      
      <tag>CodeForces</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>【CodeForces-600B】解题报告（二分，stl二分函数应用）</title>
    <link href="/post/5aa5290d.html"/>
    <url>/post/5aa5290d.html</url>
    
    <content type="html"><![CDATA[<h1 id="原始题目"><a href="#原始题目" class="headerlink" title="原始题目"></a>原始题目</h1><h2 id="B-Queries-about-less-or-equal-elements"><a href="#B-Queries-about-less-or-equal-elements" class="headerlink" title="B. Queries about less or equal elements"></a>B. Queries about less or equal elements</h2><ul><li>time limit per test2 seconds</li><li>memory limit per test256 megabytes</li><li>input：standard input</li><li>output：standard output</li></ul><p>You are given two arrays of integers $a$ and $b$. For each element of the second array $b_j$ you should find the number of elements in array $a$ that are less than or equal to the value $b_j$.<br><a id="more"></a></p><h3 id="Input"><a href="#Input" class="headerlink" title="Input"></a>Input</h3><p>The first line contains two integers $n, m (1 ≤ n, m ≤ 2·10^5)$ — the sizes of arrays $a$ and $b$.</p><p>The second line contains n integers — the elements of array $a ( - 10^9 ≤ ai ≤ 10^9)$.</p><p>The third line contains m integers — the elements of array $b ( - 10^9 ≤ bj ≤ 10^9)$.</p><h3 id="Output"><a href="#Output" class="headerlink" title="Output"></a>Output</h3><p>Print m integers, separated by spaces: the j-th of which is equal to the number of such elements in array $a$ that are less than or equal to the value $b_j$.</p><h3 id="Examples"><a href="#Examples" class="headerlink" title="Examples"></a>Examples</h3><h4 id="input"><a href="#input" class="headerlink" title="input"></a>input</h4><pre><code>5 41 3 5 7 96 4 2 8</code></pre><h4 id="output"><a href="#output" class="headerlink" title="output"></a>output</h4><pre><code>3 2 1 4</code></pre><h4 id="input-1"><a href="#input-1" class="headerlink" title="input"></a>input</h4><pre><code>5 51 2 1 2 53 1 4 1 5</code></pre><h4 id="output-1"><a href="#output-1" class="headerlink" title="output"></a>output</h4><pre><code>4 2 4 2 5</code></pre><h1 id="题目大意"><a href="#题目大意" class="headerlink" title="题目大意"></a>题目大意</h1><p>给定$a,b$两个数列，对$b$中每一项$b_i$，求$a$中小于等于$b_i$的项的个数。</p><h1 id="解题思路"><a href="#解题思路" class="headerlink" title="解题思路"></a>解题思路</h1><ul><li>排序后二分，由于寻找小于等于$b_i$的个数，使用stl里的upper_bound函数。</li></ul><h1 id="解题代码"><a href="#解题代码" class="headerlink" title="解题代码"></a>解题代码</h1><pre><code class="hljs C++"><span class="hljs-meta">#<span class="hljs-meta-keyword">include</span> <span class="hljs-meta-string">&lt;bits/stdc++.h&gt;</span></span><span class="hljs-keyword">using</span> <span class="hljs-keyword">namespace</span> <span class="hljs-built_in">std</span>;<span class="hljs-meta">#<span class="hljs-meta-keyword">define</span> rep(i,a,n) for (int i=a;i&lt;n;i++)</span><span class="hljs-meta">#<span class="hljs-meta-keyword">define</span> per(i,a,n) for (int i=n-1;i&gt;=a;i--)</span><span class="hljs-meta">#<span class="hljs-meta-keyword">define</span> pb push_back</span><span class="hljs-meta">#<span class="hljs-meta-keyword">define</span> mp make_pair</span><span class="hljs-meta">#<span class="hljs-meta-keyword">define</span> np next_permutation</span><span class="hljs-meta">#<span class="hljs-meta-keyword">define</span> all(x) x.begin(),x.end()</span><span class="hljs-meta">#<span class="hljs-meta-keyword">define</span> fi first</span><span class="hljs-meta">#<span class="hljs-meta-keyword">define</span> se second</span><span class="hljs-meta">#<span class="hljs-meta-keyword">define</span> SZ(x) (int(x).size())</span><span class="hljs-keyword">typedef</span> <span class="hljs-keyword">long</span> <span class="hljs-keyword">long</span> ll;<span class="hljs-keyword">typedef</span> <span class="hljs-built_in">vector</span> &lt;<span class="hljs-keyword">int</span>&gt; vi;<span class="hljs-keyword">typedef</span> pair&lt;<span class="hljs-keyword">int</span>,<span class="hljs-keyword">int</span>&gt; pii;<span class="hljs-keyword">const</span> <span class="hljs-keyword">int</span> maxn=<span class="hljs-number">2e5</span>+<span class="hljs-number">5</span>; <span class="hljs-built_in">vector</span> &lt;ll&gt; va,vb;ll pa,pb;ll n,m;<span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span>&#123;<span class="hljs-keyword">while</span>(~<span class="hljs-built_in">scanf</span>(<span class="hljs-string">"%lld%lld"</span>,&amp;n,&amp;m))&#123;va.clear();<span class="hljs-keyword">for</span>(ll i=<span class="hljs-number">1</span>;i&lt;=n;i++)&#123;<span class="hljs-built_in">scanf</span>(<span class="hljs-string">"%lld"</span>,&amp;pa);va.pb(pa);&#125;sort(all(va));<span class="hljs-keyword">for</span>(ll i=<span class="hljs-number">1</span>;i&lt;=m;i++)&#123;<span class="hljs-keyword">if</span>(i!=<span class="hljs-number">1</span>) <span class="hljs-built_in">printf</span>(<span class="hljs-string">" "</span>);<span class="hljs-built_in">scanf</span>(<span class="hljs-string">"%lld"</span>,&amp;pb);<span class="hljs-keyword">if</span>(pb&gt;=*(--va.end())) <span class="hljs-built_in">printf</span>(<span class="hljs-string">"%lld"</span>,n);<span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span>(pb&lt;*(va.begin())) <span class="hljs-built_in">printf</span>(<span class="hljs-string">"0"</span>);<span class="hljs-keyword">else</span>&#123;ll c=upper_bound(all(va),pb)-va.begin();<span class="hljs-built_in">printf</span>(<span class="hljs-string">"%lld"</span>,c);&#125;&#125;<span class="hljs-built_in">printf</span>(<span class="hljs-string">"\n"</span>); &#125;&#125;</code></pre><h1 id="收获与反思"><a href="#收获与反思" class="headerlink" title="收获与反思"></a>收获与反思</h1><ul><li>二分思想练习</li><li><p>upper_bound 与 lower_bound 使用的一些注意</p><ol><li>前提：<ul><li>数组是一个非降序列</li></ul></li><li><p>参数：</p><p>一个数组元素的地址（或者数组名来表示这个数组的首地址，用来表示这个数组的开头比较的元素的地址，不一定要是首地址，只是用于比较的“首”地址），</p><p>一个数组元素的地址（对应的这个数组里边任意一个元素的地址，表示这个二分里边的比较的”结尾’地址），</p><p>一个你要二分查找的那个数。  </p></li><li><p>返回值：</p><ul><li>是地址，不是指那个要查找的数的下标，所以就注定了在这个函数的后边就要减去一个尾巴，那就是这个数组用来比较的头地址。</li><li>upper_bound 返回的是键值为i的元素可以插入的最后一个位置（上界） </li><li>lowe_bound 返回的是键值为i的元素可以插入的位置的第一个位置（下界）。</li><li><p>举例在升序的set里面：</p><p>  set里没有元素i的时候，两个元素的返回值是一样的。<br>  1 2 4 5 这个序列，upp（3）和low（3）都返回位置2（下标）</p><p>  如果只有一个元素i，low返回那个元素的位置，而upp返回那个元素的位置的后一个位置。<br>  1 2 4 5 这个序列upp（2）返回下标2而low（2）返回下标1</p><p>  多个元素i，low返回那个元素的位置，upp返回那多个元素中的最后一个的后一个位置。<br>  1 2 2 4 5 这个序列 upp（2）返回下标3的位置，low（2）返回下标1的位置。</p></li></ul></li><li>不存在时的情况：<ul><li>特别注意：在一个升序的容器里，如果所有元素都大于i则，upp和low都返回begin。都小于i则返回end（越界了）。</li></ul></li></ol></li></ul>]]></content>
    
    
    <categories>
      
      <category>Computer Science</category>
      
      <category>ACM</category>
      
      <category>CodeForces</category>
      
    </categories>
    
    
    <tags>
      
      <tag>ACM</tag>
      
      <tag>CodeForces</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>【CSU-2092】解题报告（模拟，物理）</title>
    <link href="/post/15db1cd9.html"/>
    <url>/post/15db1cd9.html</url>
    
    <content type="html"><![CDATA[<h1 id="原始题目"><a href="#原始题目" class="headerlink" title="原始题目"></a>原始题目</h1><h2 id="2092-Space-Golf"><a href="#2092-Space-Golf" class="headerlink" title="2092: Space Golf"></a>2092: Space Golf</h2><ul><li>Time Limit: 1 Sec</li><li>Memory Limit: 512 Mb</li><li>Submitted: 77</li><li>Solved: 35</li><li>SpecialJudge</li></ul><h3 id="Description"><a href="#Description" class="headerlink" title="Description"></a>Description</h3><a id="more"></a><p>You surely have never heard of this new planet surface exploration scheme, as it is being carried out in a project with utmost secrecy. The scheme is expected to cut costs of conventional rover-type mobile explorers considerably, using projected-type equipment nicknamed “observation bullets”.</p><p>Bullets do not have any active mobile abilities of their own, which is the main reason of their cost-efficiency. Each of the bullets, after being shot out on a launcher given its initial velocity, makes a parabolic trajectory until it touches down. It bounces on the surface and makes another parabolic trajectory. This will be repeated virtually infinitely.</p><p>We want each of the bullets to bounce precisely at the respective spot of interest on the planet surface, adjusting its initial velocity. A variety of sensors in the bullet can gather valuable data at this instant of bounce, and send them to the observation base. Although this may sound like a conventional target shooting practice, there are several issues that make the problem more difficult.</p><ul><li><p>There may be some obstacles between the launcher and the target spot. The obstacles stand upright and are very thin that we can ignore their widths. Once the bullet touches any of the obstacles, we cannot be sure of its trajectory thereafter. So we have to plan launches to avoid these obstacles.</p></li><li><p>Launching the bullet almost vertically in a speed high enough, we can easily make it hit the target without touching any of the obstacles, but giving a high initial speed is energy-consuming. Energy is extremely precious in space exploration, and the initial speed of the bullet should be minimized. Making the bullet bounce a number of times may make the bullet reach the target with lower initial speed.</p></li><li><p>The bullet should bounce, however, no more than a given number of times. Although the body of the bullet is made strong enough, some of the sensors inside may not stand repetitive shocks. The allowed numbers of bounces vary on the type of the observation bullets.</p></li></ul><p>You are summoned engineering assistance to this project to author a smart program that tells the minimum required initial speed of the bullet to accomplish the mission.</p><p>Figure D.1 gives a sketch of a situation, roughly corresponding to the situation of the Sample Input 4 given below.</p><p><img src="https://eddyblog.oss-cn-shenzhen.aliyuncs.com/%E3%80%90CSU-2092%E3%80%91%E8%A7%A3%E9%A2%98%E6%8A%A5%E5%91%8A%EF%BC%88%E6%A8%A1%E6%8B%9F%EF%BC%8C%E7%89%A9%E7%90%86%EF%BC%89/P1.jpg" srcset="/img/loading.gif" alt="P1.jpg"></p><p>Figure D.1. A sample situation</p><p>You can assume the following.</p><ul><li>The atmosphere of the planet is so thin that atmospheric resistance can be ignored.</li><li>The planet is large enough so that its surface can be approximated to be a completely flat plane.</li><li>The gravity acceleration can be approximated to be constant up to the highest points a bullet can reach.</li></ul><p>These mean that the bullets fly along a perfect parabolic trajectory.</p><p>You can also assume the following.</p><ul><li>The surface of the planet and the bullets are made so hard that bounces can be approximated as elastic collisions. In other words, loss of kinetic energy on bounces can be ignored. As we can also ignore the atmospheric resistance, the velocity of a bullet immediately after a bounce is equal to the velocity immediately after its launch.</li><li>The bullets are made compact enough to ignore their sizes.</li><li>The launcher is also built compact enough to ignore its height.</li></ul><p>You, a programming genius, may not be an expert in physics. Let us review basics of rigid-body dynamics.</p><p>We will describe here the velocity of the bullet $v$ with its horizontal and vertical components $v_x$ and $v_y$ (positive meaning upward). The initial velocity has the components $v_{ix}$ and $v_{iy}$, that is, immediately after the launch of the bullet, $v_x = v_ix$ and $v_y = v_iy$ hold. We denote the horizontal distance of the bullet from the launcher as $x$ and its altitude as $y$ at time $t$.</p><ul><li>The horizontal velocity component of the bullet is kept constant during its flight when atmospheric resistance is ignored. Thus the horizontal distance from the launcher is proportional to the time elapsed.</li></ul><script type="math/tex; mode=display">x=v_{ix}t \tag{1}</script><ul><li>The vertical velocity component vy is gradually decelerated by the gravity. With the gravity acceleration of g, the following differential equation holds during the flight.</li></ul><script type="math/tex; mode=display">\frac{d{v_y}}{dt}=-g \tag{2}</script><p>Solving this with the initial conditions of vy = viy and y = 0 when t = 0, we obtain the following.</p><script type="math/tex; mode=display">\begin{eqnarray}  y&=&-\frac{1}{2}gt^2+v_{iy}t \tag{3} \\  &=&-(\frac{1}{2}gt-v_{iy})t \tag{4}   \end{eqnarray}</script><p>The equation (4) tells that the bullet reaches the ground again when $t = \frac{2v_{iy}}{g}$. Thus, the distance of the point of the bounce from the launcher is $\frac{2v_{ix}v_{iy}}{g}$. In other words, to make the bullet fly the distance of l, the two components of the initial velocity should satisfy $2v_{ix}v_{iy}= lg$.</p><ul><li>Eliminating the parameter t from the simultaneous equations above, we obtain the following equation that escribes the parabolic trajectory of the bullet.</li></ul><script type="math/tex; mode=display">y=-(\frac{g}{2v_{ix}^2})x^2+(\frac{v_{iy}}{v_{ix}})x \tag{5}</script><p>For ease of computation, a special unit system is used in this project, according to which the gravity acceleration g of the planet is exactly 1.0.</p><h3 id="Input"><a href="#Input" class="headerlink" title="Input"></a>Input</h3><p>The input consists of several tests case with the following format.</p><script type="math/tex; mode=display">d\ n\ b \\p_1\ h_1 \\p_2\ h_2 \\\vdots \\p_n\ h_n \\</script><p>For each test, the first line contains three integers, $d$, $n$, and $b$. Here, $d$ is the distance from the launcher to the target spot $(1 ≤ d ≤ 10000)$, $n$ is the number of obstacles $(1 ≤ n ≤ 10)$, and $b$ is the maximum number of bounces allowed, not including the bounce at the target spot $(0 ≤ b ≤ 15)$.</p><p>Each of the following $n$ lines has two integers. In the k-th line, $pk$ is the position of the k-th obstacle, its distance from the launcher, and hk is its height from the ground level. You can assume that 0 &lt; p1, pk &lt; pk + 1 for $k = 1,\cdots, n − 1$, and $pn &lt; d$. You can also assume that $1 ≤ hk ≤ 10000$ for $k = 1,\cdots, n$.</p><h3 id="Output"><a href="#Output" class="headerlink" title="Output"></a>Output</h3><p>Output the smallest possible initial speed vi that makes the bullet reach the target. The initial speed vi of the bullet is defined as follows.</p><script type="math/tex; mode=display">v_i=\sqrt{v_{ix}^2+v_{iy}^2}</script><p>The output should not contain an error greater than 0.0001.</p><h3 id="Sample-Input"><a href="#Sample-Input" class="headerlink" title="Sample Input"></a>Sample Input</h3><pre><code>100 1 050 10010 1 04 2100 4 320 1030 1040 1050 10343 3 256 42190 27286 34</code></pre><h3 id="Sample-Output"><a href="#Sample-Output" class="headerlink" title="Sample Output"></a>Sample Output</h3><pre><code>14.577383.162287.7817511.08710</code></pre><h3 id="Hint"><a href="#Hint" class="headerlink" title="Hint"></a>Hint</h3><h3 id="Source"><a href="#Source" class="headerlink" title="Source"></a>Source</h3><p>Asia Regional Contest, Tokyo, 2014</p><h1 id="题目大意"><a href="#题目大意" class="headerlink" title="题目大意"></a>题目大意</h1><p>一道物理题，给定终点和起点的距离$d$，以及$n$个距离起点坐标不同的障碍物（板子）。<br>一颗子弹从起点做抛物线运动，可以撞击地面再弹起$b$次（忽略能量损失），求可以越过障碍物恰好达到终点的初始速度值大小的最小值。</p><h1 id="解题思路"><a href="#解题思路" class="headerlink" title="解题思路"></a>解题思路</h1><ul><li>模拟+贪心（不知道可不可以叫贪心）</li><li>转化一下，由于撞击地面弹起能量无损失。所以可以将撞击前后的两段转化为一段。对每个可能的距离更新最小值。</li></ul><script type="math/tex; mode=display">d_i=\frac{d}{i} (i=1,2,3 \cdots b-1)</script><ul><li>对于每个$d_i$，先行判断45度（即$v_y=v_x$时）是否满足条件，若满足直接更新最小值。若不满足则根据轨迹方程不断更新直至能越过最高点。</li></ul><h1 id="解题代码"><a href="#解题代码" class="headerlink" title="解题代码"></a>解题代码</h1><pre><code class="hljs C++"><span class="hljs-meta">#<span class="hljs-meta-keyword">include</span> <span class="hljs-meta-string">&lt;cstdio&gt;</span></span><span class="hljs-meta">#<span class="hljs-meta-keyword">include</span> <span class="hljs-meta-string">&lt;cmath&gt;</span></span><span class="hljs-meta">#<span class="hljs-meta-keyword">include</span> <span class="hljs-meta-string">&lt;cstring&gt;</span></span><span class="hljs-meta">#<span class="hljs-meta-keyword">include</span> <span class="hljs-meta-string">&lt;string&gt;</span></span><span class="hljs-meta">#<span class="hljs-meta-keyword">define</span> INF 0x3f3f3f3f</span><span class="hljs-meta">#<span class="hljs-meta-keyword">define</span> EPS 1e-8</span><span class="hljs-keyword">using</span> <span class="hljs-keyword">namespace</span> <span class="hljs-built_in">std</span>;<span class="hljs-keyword">int</span> n,b;<span class="hljs-keyword">double</span> d,dis,vx,vy;<span class="hljs-comment">//障碍物</span><span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">obstacles</span>&#123;</span><span class="hljs-keyword">double</span> h,x; &#125;ob[<span class="hljs-number">20</span>];<span class="hljs-keyword">double</span> x[<span class="hljs-number">20</span>]; <span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">cal</span><span class="hljs-params">(<span class="hljs-keyword">double</span> x,<span class="hljs-keyword">double</span> h)</span></span>&#123;vx=<span class="hljs-built_in">sqrt</span>((dis*x/<span class="hljs-number">2.0</span>-x*x/<span class="hljs-number">2.0</span>)/h);vy=dis/<span class="hljs-number">2.0</span>/vx;&#125;<span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">judge</span><span class="hljs-params">()</span></span>&#123;  <span class="hljs-comment">//判断是否可以跨过所有障碍物 </span>    <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> i = <span class="hljs-number">0</span>; i &lt; n; i++)&#123;   <span class="hljs-keyword">double</span> h = vy*x[i] / vx - <span class="hljs-number">0.5</span>*x[i]*x[i] / (vx*vx);   <span class="hljs-keyword">if</span> (ob[i].h-h &gt;= EPS) <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;    &#125;    <span class="hljs-keyword">return</span> <span class="hljs-number">1</span>;&#125;<span class="hljs-function"><span class="hljs-keyword">double</span> <span class="hljs-title">solve</span><span class="hljs-params">(<span class="hljs-keyword">int</span> cnt)</span></span>&#123;dis = d/cnt; <span class="hljs-comment">//划分段</span><span class="hljs-keyword">for</span>(<span class="hljs-keyword">int</span> i=<span class="hljs-number">0</span>;i&lt;n;i++) x[i]=<span class="hljs-built_in">fmod</span>(ob[i].x,dis);  <span class="hljs-comment">//浮点数取模</span>vy=vx=<span class="hljs-built_in">sqrt</span>(dis/<span class="hljs-number">2</span>); <span class="hljs-comment">//先检测vy=vx时候</span><span class="hljs-keyword">if</span>(judge()) <span class="hljs-keyword">return</span> vx*<span class="hljs-built_in">sqrt</span>(<span class="hljs-number">2.0</span>);<span class="hljs-keyword">double</span> ans=INF;<span class="hljs-keyword">for</span>(<span class="hljs-keyword">int</span> i=<span class="hljs-number">0</span>;i&lt;n;i++)&#123;cal(x[i],ob[i].h); <span class="hljs-comment">//根据x[i],ob[i]初的障碍物更新vx vy的值。 </span><span class="hljs-keyword">if</span>(judge()) ans=min(ans,<span class="hljs-built_in">sqrt</span>(vx*vx+vy*vy));&#125; <span class="hljs-keyword">return</span> ans; &#125;<span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span>&#123;<span class="hljs-keyword">while</span>(~<span class="hljs-built_in">scanf</span>(<span class="hljs-string">"%lf %d %d"</span>, &amp;d, &amp;n, &amp;b))    &#123;<span class="hljs-built_in">memset</span>(ob,<span class="hljs-number">0</span>,<span class="hljs-keyword">sizeof</span>(ob));<span class="hljs-built_in">memset</span>(x,<span class="hljs-number">0</span>,<span class="hljs-keyword">sizeof</span>(x));    <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> i = <span class="hljs-number">0</span>; i &lt; n; i++) <span class="hljs-built_in">scanf</span> (<span class="hljs-string">"%lf %lf"</span>, &amp;ob[i].x, &amp;ob[i].h);    <span class="hljs-keyword">double</span> ans = INF;    <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> i = <span class="hljs-number">1</span>; i &lt;= b+<span class="hljs-number">1</span>; i++) ans = min(ans, solve(i));    <span class="hljs-built_in">printf</span> (<span class="hljs-string">"%.8f\n"</span>, ans);&#125;&#125;</code></pre><h1 id="收获与反思"><a href="#收获与反思" class="headerlink" title="收获与反思"></a>收获与反思</h1><ul><li>从简单开始考虑，无障碍物的时候45度最远</li><li>将多段跳跃等效为一段。</li><li>浮点数取模函数<ul><li>fmod 函数计算 x 除以 y 的 f 浮点余数，这样 x = i*y + f，其中 i 是整数，f 和 x 有相同的符号，而且 f 的绝对值小于 y 的绝对值。</li></ul></li></ul><pre><code class="hljs C++">result=<span class="hljs-built_in">fmod</span>(x,y);<span class="hljs-built_in">printf</span>(<span class="hljs-string">"10.0%%-3.0= %f/n"</span>,result); <span class="hljs-comment">//1.0</span>result=<span class="hljs-built_in">fmod</span>(y,x);<span class="hljs-built_in">printf</span>(<span class="hljs-string">"-3.0%%10.0= %f/n"</span>,result); <span class="hljs-comment">//-3.0</span></code></pre>]]></content>
    
    
    <categories>
      
      <category>Computer Science</category>
      
      <category>ACM</category>
      
      <category>CSU</category>
      
    </categories>
    
    
    <tags>
      
      <tag>ACM</tag>
      
      <tag>CSU</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>【HDU-6301】解题报告（贪心，预处理）</title>
    <link href="/post/c293d2b3.html"/>
    <url>/post/c293d2b3.html</url>
    
    <content type="html"><![CDATA[<h1 id="原始题目"><a href="#原始题目" class="headerlink" title="原始题目"></a>原始题目</h1><h2 id="Distinct-Values"><a href="#Distinct-Values" class="headerlink" title="Distinct Values"></a>Distinct Values</h2><ul><li>Time Limit: 4000/2000 MS (Java/Others)</li><li>Memory Limit: 32768/32768 K (Java/Others)</li><li>Total Submission(s): 3168</li><li>Accepted Submission(s): 1017</li></ul><h2 id="Problem-Description"><a href="#Problem-Description" class="headerlink" title="Problem Description"></a>Problem Description</h2><p>Chiaki has an array of $n$ positive integers. You are told some facts about the array: for every two elements $a_i$ and $a_j$ in the subarray $a_{l \cdots r} (l≤i&lt;j≤r)$, $a_i≠a_j$ holds.</p><a id="more"></a><p>Chiaki would like to find a lexicographically minimal array which meets the facts.</p><h3 id="Input"><a href="#Input" class="headerlink" title="Input"></a>Input</h3><p>There are multiple test cases. The first line of input contains an integer $T$, indicating the number of test cases. For each test case:</p><p>The first line contains two integers $n$ and $m (1≤n,m≤105)$ — the length of the array and the number of facts. Each of the next $m$ lines contains two integers $l_i$ and $r_i$ $(1≤li≤ri≤n)$.</p><p>It is guaranteed that neither the sum of all $n$ nor the sum of all $m$ exceeds 106.</p><h3 id="Output"><a href="#Output" class="headerlink" title="Output"></a>Output</h3><p>For each test case, output $n$ integers denoting the lexicographically minimal array. Integers should be separated by a single space, and no extra spaces are allowed at the end of lines.</p><h3 id="Sample-Input"><a href="#Sample-Input" class="headerlink" title="Sample Input"></a>Sample Input</h3><pre><code>32 11 24 21 23 45 21 32 4</code></pre><h3 id="Sample-Output"><a href="#Sample-Output" class="headerlink" title="Sample Output"></a>Sample Output</h3><pre><code>1 21 2 1 21 2 3 1 1</code></pre><h3 id="Source"><a href="#Source" class="headerlink" title="Source"></a>Source</h3><p>2018 Multi-University Training Contest 1</p><h3 id="Recommend"><a href="#Recommend" class="headerlink" title="Recommend"></a>Recommend</h3><p>liuyiding</p><h1 id="题目大意"><a href="#题目大意" class="headerlink" title="题目大意"></a>题目大意</h1><p>对于一个数列，已知其 m 个子区间，每个子区间内数列的项两两不同，求复合条件的字典序最小的数列。</p><h1 id="解题思路"><a href="#解题思路" class="headerlink" title="解题思路"></a>解题思路</h1><ul><li><p>要求字典序最小，算法就是从前贪心的让每一位都是当前可使用数的最小值（从 1 开始）。</p></li><li><p>那么如何处理出第 i 位可用数字的最小值？</p><ul><li>预处理出$pre[i]$（包含第 i 位线段的最小左端点，即与第 i 位不相同的最早位置）</li><li>用 set 维护当前可使用的数，$pt$指向当前可用最小数的位置，</li><li>求每一位的$ans[i]$时，先检查，当$pt&lt;pre[i]$时，说明$pt$到$pre[i]$位置间使用过的数可以再次使用，所以开始向 set 容器里补充$pt$位置的数，<br>直至$pt=pre[i]$，再取 set 容器中的最小值付给$ans[i]$</li></ul></li><li><p>如何与处理出$pre[i]$（见下图）</p></li></ul><h1 id="解题代码"><a href="#解题代码" class="headerlink" title="解题代码"></a>解题代码</h1><pre><code class="hljs C++"><span class="hljs-meta">#<span class="hljs-meta-keyword">include</span> <span class="hljs-meta-string">&lt;bits/stdc++.h&gt;</span></span><span class="hljs-keyword">using</span> <span class="hljs-keyword">namespace</span> <span class="hljs-built_in">std</span>;<span class="hljs-meta">#<span class="hljs-meta-keyword">define</span> rep(i,a,n) for (int i=a;i&lt;n;i++)</span><span class="hljs-meta">#<span class="hljs-meta-keyword">define</span> per(i,a,n) for (int i=n-1;i&gt;=a;i--)</span><span class="hljs-meta">#<span class="hljs-meta-keyword">define</span> pb push_back</span><span class="hljs-meta">#<span class="hljs-meta-keyword">define</span> mp make_pair</span><span class="hljs-meta">#<span class="hljs-meta-keyword">define</span> np next_permutation</span><span class="hljs-meta">#<span class="hljs-meta-keyword">define</span> all(x) x.begin(),x.end()</span><span class="hljs-meta">#<span class="hljs-meta-keyword">define</span> fi first</span><span class="hljs-meta">#<span class="hljs-meta-keyword">define</span> se second</span><span class="hljs-meta">#<span class="hljs-meta-keyword">define</span> SZ(x) ((int)(x).size())</span><span class="hljs-keyword">typedef</span> <span class="hljs-built_in">vector</span>&lt;<span class="hljs-keyword">int</span>&gt; vi;<span class="hljs-keyword">typedef</span> <span class="hljs-keyword">long</span> <span class="hljs-keyword">long</span> ll;<span class="hljs-keyword">typedef</span> pair&lt;<span class="hljs-keyword">int</span>,<span class="hljs-keyword">int</span>&gt; pii;<span class="hljs-keyword">const</span> <span class="hljs-keyword">int</span> mod=<span class="hljs-number">1e9</span>+<span class="hljs-number">7</span>;<span class="hljs-keyword">const</span> <span class="hljs-keyword">int</span> maxn=<span class="hljs-number">2e5</span>+<span class="hljs-number">5</span>;<span class="hljs-built_in">set</span> &lt;<span class="hljs-keyword">int</span>&gt; s;<span class="hljs-keyword">int</span> pre[maxn],n,m,ans[maxn];   <span class="hljs-comment">//预处理出不可相同的区间前端点。</span><span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span>&#123;<span class="hljs-keyword">int</span> t;<span class="hljs-built_in">scanf</span>(<span class="hljs-string">"%d"</span>,&amp;t);<span class="hljs-keyword">while</span>(t--)&#123;s.clear();<span class="hljs-built_in">scanf</span>(<span class="hljs-string">"%d%d"</span>,&amp;n,&amp;m);rep(i,<span class="hljs-number">1</span>,n+<span class="hljs-number">1</span>)&#123;pre[i]=i; <span class="hljs-comment">//没有限制条件，前端点都是自身</span>s.insert(i);&#125;rep(i,<span class="hljs-number">1</span>,m+<span class="hljs-number">1</span>)&#123;<span class="hljs-keyword">int</span> l,r;<span class="hljs-built_in">scanf</span>(<span class="hljs-string">"%d%d"</span>,&amp;l,&amp;r);pre[r]=min(l,pre[r]); <span class="hljs-comment">//有可能多个区间右端点相同。</span><span class="hljs-comment">//易错写成 pre[r]=l;忘记更新</span>&#125;per(i,<span class="hljs-number">1</span>,n) pre[i]=min(pre[i],pre[i+<span class="hljs-number">1</span>]);  <span class="hljs-comment">//易错写成n+1</span><span class="hljs-comment">//处理完毕</span><span class="hljs-comment">//初始set均可用</span><span class="hljs-keyword">int</span> pt=<span class="hljs-number">1</span>;<span class="hljs-comment">//pt记录当前不可用线段开头</span>rep(i,<span class="hljs-number">1</span>,n+<span class="hljs-number">1</span>)&#123;<span class="hljs-comment">//开头更替，则往set里补充可用最小值</span><span class="hljs-comment">//cout&lt;&lt;"pt="&lt;&lt;pt&lt;&lt;"  pre[i]="&lt;&lt;pre[i]&lt;&lt;endl;</span><span class="hljs-keyword">while</span>(pt&lt;pre[i])&#123;s.insert(ans[pt++]);&#125;ans[i]=*s.begin();s.erase(*s.begin());&#125;rep(i,<span class="hljs-number">1</span>,n+<span class="hljs-number">1</span>)&#123;<span class="hljs-keyword">if</span>(i==<span class="hljs-number">1</span>) <span class="hljs-built_in">printf</span>(<span class="hljs-string">"%d"</span>,ans[i]);<span class="hljs-keyword">else</span> <span class="hljs-built_in">printf</span>(<span class="hljs-string">" %d"</span>,ans[i]);&#125;<span class="hljs-built_in">printf</span>(<span class="hljs-string">"\n"</span>);&#125;&#125;</code></pre><h1 id="收获与反思"><a href="#收获与反思" class="headerlink" title="收获与反思"></a>收获与反思</h1><ul><li>预处理出线段的左端点。</li><li>贪心的考虑每一位的最小值。</li></ul>]]></content>
    
    
    <categories>
      
      <category>Computer Science</category>
      
      <category>ACM</category>
      
      <category>HDU</category>
      
    </categories>
    
    
    <tags>
      
      <tag>ACM</tag>
      
      <tag>HDU</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>【HDU-6300】解题报告（简单几何贪心）</title>
    <link href="/post/7fe193be.html"/>
    <url>/post/7fe193be.html</url>
    
    <content type="html"><![CDATA[<h1 id="原始题目"><a href="#原始题目" class="headerlink" title="原始题目"></a>原始题目</h1><h2 id="Triangle-Partition"><a href="#Triangle-Partition" class="headerlink" title="Triangle Partition"></a>Triangle Partition</h2><ul><li>Time Limit: 2000/1000 MS (Java/Others)    </li><li>Memory Limit: 132768/132768 K (Java/Others)</li><li>Total Submission(s): 1054    </li><li>Accepted Submission(s): 533</li><li>Special Judge</li></ul><h3 id="Problem-Description"><a href="#Problem-Description" class="headerlink" title="Problem Description"></a>Problem Description</h3><p>Chiaki has $3n$ points $p_1,p_2,…,p_{3n}$. It is guaranteed that no three points are collinear.</p><p>Chiaki would like to construct $n$ disjoint triangles where each vertex comes from the $3n$ points.</p><a id="more"></a><h3 id="Input"><a href="#Input" class="headerlink" title="Input"></a>Input</h3><p>There are multiple test cases. The first line of input contains an integer $T$, indicating the number of test cases. For each test case:</p><p>The first line contains an integer $n (1≤n≤1000)$ — the number of triangle to construct.</p><p>Each of the next 3n lines contains two integers $x_i$ and $y_i (−109≤x_i,y_i≤109)$.</p><p>It is guaranteed that the sum of all $n$ does not exceed 10000.</p><h3 id="Output"><a href="#Output" class="headerlink" title="Output"></a>Output</h3><p>For each test case, output $n$ lines contain three integers $a_i,b_i,c_i (1≤a_i,b_i,c_i≤3n)$ each denoting the indices of points the i-th triangle use. If there are multiple solutions, you can output any of them.</p><h3 id="Sample-Input"><a href="#Sample-Input" class="headerlink" title="Sample Input"></a>Sample Input</h3><pre><code>111 22 33 5</code></pre><h3 id="Sample-Output"><a href="#Sample-Output" class="headerlink" title="Sample Output"></a>Sample Output</h3><pre><code>1 2 3</code></pre><h3 id="Source"><a href="#Source" class="headerlink" title="Source"></a>Source</h3><p>2018 Multi-University Training Contest 1</p><h3 id="Recommend"><a href="#Recommend" class="headerlink" title="Recommend"></a>Recommend</h3><p>liuyiding</p><h1 id="题目大意"><a href="#题目大意" class="headerlink" title="题目大意"></a>题目大意</h1><p>给出$3n$个点，且任意三点军部贡献，要求按顺序给出$n$个三角形的三个顶点坐标，要求$n$个三角形两两不相交（不共点）。</p><h1 id="解题思路"><a href="#解题思路" class="headerlink" title="解题思路"></a>解题思路</h1><p>反向理解 若两条线相交（如下图）</p><p>假设我们连三角形时先连A线再连，B线，若出现A2&gt;B1，则有可能会出现两线相交。</p><p>考虑到题目给出任意三点不共线，即人以三点都可以构成一个三角形。我们只要找到一种方法逐个连接出不相交的三角形就行。</p><p>按x轴将所有点排序，从小到大每次找三个点即可。</p><h1 id="解题代码"><a href="#解题代码" class="headerlink" title="解题代码"></a>解题代码</h1><pre><code class="hljs C++"><span class="hljs-meta">#<span class="hljs-meta-keyword">include</span> <span class="hljs-meta-string">&lt;bits/stdc++.h&gt;</span></span><span class="hljs-keyword">using</span> <span class="hljs-keyword">namespace</span> <span class="hljs-built_in">std</span>;<span class="hljs-meta">#<span class="hljs-meta-keyword">define</span> rep(i,a,n) for (int i=a;i&lt;n;i++)</span><span class="hljs-meta">#<span class="hljs-meta-keyword">define</span> per(i,a,n) for (int i=n-1;i&gt;=a;i--)</span><span class="hljs-meta">#<span class="hljs-meta-keyword">define</span> pb push_back</span><span class="hljs-meta">#<span class="hljs-meta-keyword">define</span> mp make_pair</span><span class="hljs-meta">#<span class="hljs-meta-keyword">define</span> np next_permutation</span><span class="hljs-meta">#<span class="hljs-meta-keyword">define</span> all(x) x.begin(),x.end()</span><span class="hljs-meta">#<span class="hljs-meta-keyword">define</span> fi first</span><span class="hljs-meta">#<span class="hljs-meta-keyword">define</span> se second</span><span class="hljs-meta">#<span class="hljs-meta-keyword">define</span> SZ(x) ((int)(x).size()) </span><span class="hljs-keyword">typedef</span> <span class="hljs-built_in">vector</span>&lt;<span class="hljs-keyword">int</span>&gt; vi;<span class="hljs-keyword">typedef</span> <span class="hljs-keyword">long</span> <span class="hljs-keyword">long</span> ll;<span class="hljs-keyword">typedef</span> pair&lt;<span class="hljs-keyword">int</span>,<span class="hljs-keyword">int</span>&gt; pii;<span class="hljs-keyword">const</span> <span class="hljs-keyword">int</span> mod=<span class="hljs-number">1e9</span>+<span class="hljs-number">7</span>;<span class="hljs-keyword">const</span> <span class="hljs-keyword">int</span> maxn=<span class="hljs-number">1e4</span>+<span class="hljs-number">5</span>;<span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">node</span>&#123;</span><span class="hljs-keyword">int</span> index;pii point;&#125;a[maxn];ll t,n,m;<span class="hljs-function"><span class="hljs-keyword">bool</span> <span class="hljs-title">cmp</span><span class="hljs-params">(node a, node b)</span></span>&#123;<span class="hljs-keyword">if</span>(a.point.first==b.point.first) <span class="hljs-keyword">return</span> a.point.second&lt;b.point.second;<span class="hljs-keyword">else</span> <span class="hljs-keyword">return</span> a.point.first&lt;b.point.first;&#125;<span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span>&#123;ios::sync_with_stdio(<span class="hljs-literal">false</span>);<span class="hljs-built_in">cin</span>&gt;&gt;t;<span class="hljs-keyword">while</span>(t--)&#123;<span class="hljs-built_in">cin</span>&gt;&gt;n;rep(i,<span class="hljs-number">1</span>,<span class="hljs-number">3</span>*n+<span class="hljs-number">1</span>)&#123;a[i].index=i;<span class="hljs-built_in">cin</span>&gt;&gt;a[i].point.first&gt;&gt;a[i].point.second;&#125;sort(a+<span class="hljs-number">1</span>,a+<span class="hljs-number">1</span>+<span class="hljs-number">3</span>*n,cmp);<span class="hljs-comment">//rep(i,1,3*n+1)&#123;</span><span class="hljs-comment">//cout&lt;&lt;a[i].point.fi&lt;&lt;" "&lt;&lt;a[i].point.se&lt;&lt;endl;</span><span class="hljs-comment">//&#125;</span>rep(i,<span class="hljs-number">1</span>,<span class="hljs-number">3</span>*n+<span class="hljs-number">1</span>)&#123;<span class="hljs-keyword">if</span>(i==<span class="hljs-number">1</span>) <span class="hljs-built_in">cout</span>&lt;&lt;a[i].index;<span class="hljs-keyword">else</span> <span class="hljs-built_in">cout</span>&lt;&lt;<span class="hljs-string">" "</span>&lt;&lt;a[i].index;&#125;<span class="hljs-built_in">cout</span>&lt;&lt;<span class="hljs-built_in">endl</span>;&#125;&#125;</code></pre><h1 id="收获与反思"><a href="#收获与反思" class="headerlink" title="收获与反思"></a>收获与反思</h1><ul><li>简单的几何贪心，考虑两线相交的条件拓展即可。</li></ul>]]></content>
    
    
    <categories>
      
      <category>Computer Science</category>
      
      <category>ACM</category>
      
      <category>HDU</category>
      
    </categories>
    
    
    <tags>
      
      <tag>ACM</tag>
      
      <tag>HDU</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>【HDU-6298】解题报告（数论，整除）</title>
    <link href="/post/60850415.html"/>
    <url>/post/60850415.html</url>
    
    <content type="html"><![CDATA[<h1 id="原始题目"><a href="#原始题目" class="headerlink" title="原始题目"></a>原始题目</h1><h2 id="Maximum-Multiple"><a href="#Maximum-Multiple" class="headerlink" title="Maximum Multiple"></a>Maximum Multiple</h2><ul><li>Time Limit: 4000/2000 MS (Java/Others)    </li><li>Memory Limit: 32768/32768 K (Java/Others)</li><li>Total Submission(s): 1503    </li><li>Accepted Submission(s): 653</li></ul><h3 id="Problem-Description"><a href="#Problem-Description" class="headerlink" title="Problem Description"></a>Problem Description</h3><p>Given an integer $n$, Chiaki would like to find three positive integers $x$, $y$ and $z$ such that: $n=x+y+z$, $x∣n$, $y∣n$, $z∣n$ and $xyz$ is maximum.</p><a id="more"></a><h3 id="Input"><a href="#Input" class="headerlink" title="Input"></a>Input</h3><p>There are multiple test cases. The first line of input contains an integer $T (1≤T≤106)$, indicating the number of test cases. For each test case:<br>The first line contains an integer $n (1≤n≤106)$.</p><h3 id="Output"><a href="#Output" class="headerlink" title="Output"></a>Output</h3><p>For each test case, output an integer denoting the maximum xyz. If there no such integers, output −1 instead.</p><h3 id="Sample-Input"><a href="#Sample-Input" class="headerlink" title="Sample Input"></a>Sample Input</h3><pre><code>3123</code></pre><h3 id="Sample-Output"><a href="#Sample-Output" class="headerlink" title="Sample Output"></a>Sample Output</h3><pre><code>-1-11</code></pre><h3 id="Source"><a href="#Source" class="headerlink" title="Source"></a>Source</h3><p>   2018 Multi-University Training Contest 1</p><h3 id="Recommend"><a href="#Recommend" class="headerlink" title="Recommend"></a>Recommend</h3><p>   liuyiding</p><h1 id="题目大意"><a href="#题目大意" class="headerlink" title="题目大意"></a>题目大意</h1><p>已知三个数的和为$n$，且三个数均能整除$n$，求三个数乘积的最大值。</p><h1 id="解题思路"><a href="#解题思路" class="headerlink" title="解题思路"></a>解题思路</h1><p>数论问题</p><p>不妨设$a=\frac{n}{x},b=\frac{n}{y},c=\frac{n}{z}$。<br>由题目条件可以得到</p><script type="math/tex; mode=display">\frac{1}{a}+\frac{1}{b}+\frac{1}{c}=1</script><p>由于$a,b,c$均为整数（正整数）。<br>所以该方程共有三组解。<br>分别为$a=3,b=3,c=3,xyz=\frac{n^3}{27}$或者$a=2,b=4,c=4,xyz=\frac{n^3}{32}$或者$a=2,b=3,c=6,xyz=\frac{n^3}{36}$</p><p>故判断$n|3,n|4$整除即可。又因为若第三组解成立，则必有第三组解，而且第一组解对应的$xyz$值更大，故不考虑第三组。</p><h1 id="解题代码"><a href="#解题代码" class="headerlink" title="解题代码"></a>解题代码</h1><pre><code class="hljs C++"><span class="hljs-meta">#<span class="hljs-meta-keyword">include</span> <span class="hljs-meta-string">&lt;bits/stdc++.h&gt;</span></span><span class="hljs-keyword">using</span> <span class="hljs-keyword">namespace</span> <span class="hljs-built_in">std</span>;<span class="hljs-meta">#<span class="hljs-meta-keyword">define</span> rep(i,a,n) for (int i=a;i&lt;n;i++)</span><span class="hljs-meta">#<span class="hljs-meta-keyword">define</span> per(i,a,n) for (int i=n-1;i&gt;=a;i--)</span><span class="hljs-meta">#<span class="hljs-meta-keyword">define</span> pb push_back</span><span class="hljs-meta">#<span class="hljs-meta-keyword">define</span> mp make_pair</span><span class="hljs-meta">#<span class="hljs-meta-keyword">define</span> np next_permutation</span><span class="hljs-meta">#<span class="hljs-meta-keyword">define</span> all(x) x.begin(),x.end()</span><span class="hljs-meta">#<span class="hljs-meta-keyword">define</span> fi first</span><span class="hljs-meta">#<span class="hljs-meta-keyword">define</span> se second</span><span class="hljs-meta">#<span class="hljs-meta-keyword">define</span> SZ(x) ((int)(x).size()) </span><span class="hljs-keyword">typedef</span> <span class="hljs-built_in">vector</span>&lt;<span class="hljs-keyword">int</span>&gt; vi;<span class="hljs-keyword">typedef</span> <span class="hljs-keyword">long</span> <span class="hljs-keyword">long</span> ll;<span class="hljs-keyword">typedef</span> pair&lt;<span class="hljs-keyword">int</span>,<span class="hljs-keyword">int</span>&gt; pii;<span class="hljs-keyword">const</span> <span class="hljs-keyword">int</span> mod=<span class="hljs-number">1e9</span>+<span class="hljs-number">7</span>;<span class="hljs-keyword">const</span> <span class="hljs-keyword">int</span> maxn=<span class="hljs-number">1e5</span>+<span class="hljs-number">5</span>;ll t,n,m;<span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span>&#123;ios::sync_with_stdio(<span class="hljs-literal">false</span>);<span class="hljs-built_in">cin</span>&gt;&gt;t;<span class="hljs-keyword">while</span>(t--)&#123;<span class="hljs-built_in">cin</span>&gt;&gt;n;<span class="hljs-keyword">if</span>(!(n%<span class="hljs-number">3</span>)) <span class="hljs-built_in">cout</span>&lt;&lt;<span class="hljs-number">1l</span>l*n*n*n/<span class="hljs-number">27</span>&lt;&lt;<span class="hljs-built_in">endl</span>;<span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span>(!(n%<span class="hljs-number">4</span>)) <span class="hljs-built_in">cout</span>&lt;&lt;<span class="hljs-number">1l</span>l*n*n*n/<span class="hljs-number">32</span>&lt;&lt;<span class="hljs-built_in">endl</span>;<span class="hljs-keyword">else</span> <span class="hljs-built_in">cout</span>&lt;&lt;<span class="hljs-string">"-1"</span>&lt;&lt;<span class="hljs-built_in">endl</span>;&#125;&#125;</code></pre><h1 id="收获与反思"><a href="#收获与反思" class="headerlink" title="收获与反思"></a>收获与反思</h1><ul><li>寻找条件的关系</li><li>数论学习</li></ul>]]></content>
    
    
    <categories>
      
      <category>Computer Science</category>
      
      <category>ACM</category>
      
      <category>HDU</category>
      
    </categories>
    
    
    <tags>
      
      <tag>ACM</tag>
      
      <tag>HDU</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>【HDU-6165】解题报告（BFS，搜索优化）</title>
    <link href="/post/76485a7.html"/>
    <url>/post/76485a7.html</url>
    
    <content type="html"><![CDATA[<h1 id="原始题目"><a href="#原始题目" class="headerlink" title="原始题目"></a>原始题目</h1><h2 id="FFF-at-Valentine"><a href="#FFF-at-Valentine" class="headerlink" title="FFF at Valentine"></a>FFF at Valentine</h2><ul><li>Time Limit: 6000/3000 MS (Java/Others)    </li><li>Memory Limit: 65536/65536 K (Java/Others)</li><li>Total Submission(s): 1703    </li><li>Accepted Submission(s): 722</li></ul><h3 id="Problem-Description"><a href="#Problem-Description" class="headerlink" title="Problem Description"></a>Problem Description</h3><a id="more"></a><p>At Valentine’s eve, Shylock and Lucar were enjoying their time as any other couples. Suddenly, LSH, Boss of FFF Group caught both of them, and locked them into two separate cells of the jail randomly. But as the saying goes: There is always a way out , the lovers made a bet with LSH: if either of them can reach the cell of the other one, then LSH has to let them go.</p><p>The jail is formed of several cells and each cell has some special portals connect to a specific cell. One can be transported to the connected cell by the portal, but be transported back is impossible. There will not be a portal connecting a cell and itself, and since the cost of a portal is pretty expensive, LSH would not tolerate the fact that two portals connect exactly the same two cells.</p><p>As an enthusiastic person of the FFF group, YOU are quit curious about whether the lovers can survive or not. So you get a map of the jail and decide to figure it out.</p><h3 id="Input"><a href="#Input" class="headerlink" title="Input"></a>Input</h3><ul><li>Input starts with an integer $T (T≤120)$, denoting the number of test cases.</li><li><p>For each case,</p><ul><li>First line is two number $n$ and $m$, the total number of cells and portals in the jail.$(2≤n≤1000,m≤6000)$</li><li>Then next $m$ lines each contains two integer $u$ and $v$, which indicates a portal from $u$ to $v$.</li></ul></li></ul><h3 id="Output"><a href="#Output" class="headerlink" title="Output"></a>Output</h3><p>If the couple can survive, print “I love you my love and our love save us!”</p><p>Otherwise, print “Light my fire!”</p><h3 id="Sample-Input"><a href="#Sample-Input" class="headerlink" title="Sample Input"></a>Sample Input</h3><pre><code>35 51 22 32 43 54 53 31 22 33 15 51 22 33 13 44 5</code></pre><h3 id="Sample-Output"><a href="#Sample-Output" class="headerlink" title="Sample Output"></a>Sample Output</h3><pre><code>Light my fire!I love you my love and our love save us!I love you my love and our love save us!</code></pre><h3 id="Source"><a href="#Source" class="headerlink" title="Source"></a>Source</h3><p>2017 Multi-University Training Contest - Team 9</p><h3 id="Recommend"><a href="#Recommend" class="headerlink" title="Recommend"></a>Recommend</h3><p>liuyiding</p><h1 id="题目大意"><a href="#题目大意" class="headerlink" title="题目大意"></a>题目大意</h1><p>给定一个有向图，问任意两点之间是否连通</p><h1 id="解题思路"><a href="#解题思路" class="headerlink" title="解题思路"></a>解题思路</h1><p>暂时没有其他（正常）想法，SHL写了一个暴力BFS+优化，拿来学习一下。</p><h1 id="解题代码"><a href="#解题代码" class="headerlink" title="解题代码"></a>解题代码</h1><pre><code class="hljs C++"><span class="hljs-meta">#<span class="hljs-meta-keyword">include</span><span class="hljs-meta-string">&lt;bits/stdc++.h&gt;</span></span><span class="hljs-keyword">using</span> <span class="hljs-keyword">namespace</span> <span class="hljs-built_in">std</span>;<span class="hljs-built_in">vector</span>&lt;<span class="hljs-keyword">int</span>&gt; v[<span class="hljs-number">1010</span>];<span class="hljs-keyword">int</span> Flag[<span class="hljs-number">1010</span>][<span class="hljs-number">1010</span>],vis[<span class="hljs-number">1010</span>];<span class="hljs-keyword">int</span> ans;<span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">bfs</span><span class="hljs-params">(<span class="hljs-keyword">int</span> st)</span></span>&#123;    <span class="hljs-built_in">queue</span>&lt;<span class="hljs-keyword">int</span>&gt; q;    <span class="hljs-keyword">while</span>(!q.empty())        q.pop();    q.push(st);    <span class="hljs-built_in">memset</span>(vis,<span class="hljs-number">0</span>,<span class="hljs-keyword">sizeof</span> vis);    vis[st] = <span class="hljs-number">1</span>;    <span class="hljs-keyword">while</span>(!q.empty())    &#123;        <span class="hljs-keyword">int</span> u = q.front();q.pop();        <span class="hljs-keyword">for</span>(<span class="hljs-keyword">int</span> i = <span class="hljs-number">0</span>; i &lt; v[u].size(); i++)        &#123;            <span class="hljs-keyword">if</span>(vis[v[u][i]] == <span class="hljs-number">0</span>)            &#123;                vis[v[u][i]] = <span class="hljs-number">1</span>;                q.push(v[u][i]);                <span class="hljs-keyword">if</span>(Flag[st][v[u][i]] == <span class="hljs-number">0</span>)                &#123;                    Flag[st][v[u][i]] = Flag[v[u][i]][st] = <span class="hljs-number">1</span>;                    ans++;                &#125;            &#125;        &#125;    &#125;&#125;<span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">Init</span><span class="hljs-params">()</span></span>&#123;<span class="hljs-keyword">for</span>(<span class="hljs-keyword">int</span> i=<span class="hljs-number">0</span>;i&lt;<span class="hljs-number">1010</span>;i++) v[i].clear();<span class="hljs-built_in">memset</span>(Flag,<span class="hljs-number">0</span>,<span class="hljs-keyword">sizeof</span> Flag);    ans=<span class="hljs-number">0</span>;&#125;<span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span>&#123;    <span class="hljs-keyword">int</span> T,n,m;<span class="hljs-built_in">cin</span>&gt;&gt;T;    <span class="hljs-keyword">while</span>(T--)    &#123;    Init();        <span class="hljs-built_in">scanf</span>(<span class="hljs-string">"%d%d"</span>,&amp;n,&amp;m);        <span class="hljs-keyword">while</span>(m--)        &#123;            <span class="hljs-keyword">int</span> x,y;            <span class="hljs-built_in">scanf</span>(<span class="hljs-string">"%d%d"</span>,&amp;x,&amp;y);            v[x].push_back(y);        &#125;        <span class="hljs-keyword">for</span>(<span class="hljs-keyword">int</span> i = <span class="hljs-number">1</span>; i &lt;= n; i++)            bfs(i);        <span class="hljs-keyword">if</span>(ans == n*(n<span class="hljs-number">-1</span>)/<span class="hljs-number">2</span>)            <span class="hljs-built_in">printf</span>(<span class="hljs-string">"I love you my love and our love save us!\n"</span>);        <span class="hljs-keyword">else</span>            <span class="hljs-built_in">printf</span>(<span class="hljs-string">"Light my fire!\n"</span>);    &#125;    <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;&#125;</code></pre><h1 id="收获与反思"><a href="#收获与反思" class="headerlink" title="收获与反思"></a>收获与反思</h1><p>待补充</p>]]></content>
    
    
    <categories>
      
      <category>Computer Science</category>
      
      <category>ACM</category>
      
      <category>HDU</category>
      
    </categories>
    
    
    <tags>
      
      <tag>ACM</tag>
      
      <tag>HDU</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>【HDU-6168】解题报告（数学，规律，分组）</title>
    <link href="/post/d9083bc4.html"/>
    <url>/post/d9083bc4.html</url>
    
    <content type="html"><![CDATA[<h1 id="原始题目"><a href="#原始题目" class="headerlink" title="原始题目"></a>原始题目</h1><h2 id="Numbers"><a href="#Numbers" class="headerlink" title="Numbers"></a>Numbers</h2><ul><li>Time Limit: 4000/2000 MS (Java/Others)    </li><li>Memory Limit: 131072/131072 K (Java/Others)</li><li>Total Submission(s): 1466    </li><li>Accepted Submission(s): 692</li></ul><h3 id="Problem-Description"><a href="#Problem-Description" class="headerlink" title="Problem Description"></a>Problem Description</h3><p>zk has n numbers a1,a2,…,an. For each (i,j) satisfying 1≤i&lt;j≤n, zk generates a new number (ai+aj). These new numbers could make up a new sequence b1，b2,…,bn(n−1)/2.</p><a id="more"></a><p>LsF wants to make some trouble. While zk is sleeping, Lsf mixed up sequence a and b with random order so that zk can’t figure out which numbers were in a or b. “I’m angry!”, says zk.</p><p>Can you help zk find out which n numbers were originally in a?</p><h3 id="Input"><a href="#Input" class="headerlink" title="Input"></a>Input</h3><p>   Multiple test cases(not exceed 10).<br>   For each test case:<br>   ∙The first line is an integer m(0≤m≤125250), indicating the total length of a and b. It’s guaranteed m can be formed as n(n+1)/2.<br>   ∙The second line contains m numbers, indicating the mixed sequence of a and b.<br>   Each ai is in [1,10^9]</p><h3 id="Output"><a href="#Output" class="headerlink" title="Output"></a>Output</h3><p>   For each test case, output two lines.<br>   The first line is an integer n, indicating the length of sequence a;<br>   The second line should contain n space-seprated integers a1,a2,…,an(a1≤a2≤…≤an). These are numbers in sequence a.<br>   It’s guaranteed that there is only one solution for each case.</p><h3 id="Sample-Input"><a href="#Sample-Input" class="headerlink" title="Sample Input"></a>Sample Input</h3><pre><code>62 2 2 4 4 4211 2 3 3 4 4 5 5 5 6 6 6 7 7 7 8 8 9 9 10 11</code></pre><h3 id="Sample-Output"><a href="#Sample-Output" class="headerlink" title="Sample Output"></a>Sample Output</h3><pre><code>32 2 261 2 3 4 5 6</code></pre><h3 id="Source"><a href="#Source" class="headerlink" title="Source"></a>Source</h3><p>   2017 Multi-University Training Contest - Team 9</p><h3 id="Recommend"><a href="#Recommend" class="headerlink" title="Recommend"></a>Recommend</h3><p>   liuyiding</p><h1 id="题目大意"><a href="#题目大意" class="headerlink" title="题目大意"></a>题目大意</h1><p>已知一个数列由a，b两个数列构成，b数列中的每一项都是a数列中某两项的和，求原数列a</p><h1 id="解题思路"><a href="#解题思路" class="headerlink" title="解题思路"></a>解题思路</h1><p>首先可以确定的几点是</p><ul><li>数列$a$有$n$项，则数列$b$有$\frac{n(n-1)}{2}$项，则给定的$c$数列有$\frac{n(n+1)}{2}$项，</li><li>由于$a$中任意一项均&gt;=1（即，$a$为正数数列），所以$c$中的最小项极为$a$中的最小项。</li><li>也可以推得，$c$中第二小项也为$a$中第二小项。</li></ul><p>再往后推</p><ul><li>$c$项中第三小的可能是$a$中第三小的项，也可能是b项中第一小的项（即${a_1}+{a_2}$)。</li><li>由于$c$由$a$和$b$全部项构成，所以${b_1}={a_1}+{a_2}$必然在$c$中。</li></ul><p>由此我们想到筛数的方法。</p><ul><li>$c$中去掉${a_1}+{a_2}$的一项后剩下的最小项必然为$a_3$。</li><li>再从$c$中去掉${a_1}+{a_3}$，${a_2}+{a_3}$，剩下的最小项必然为$a_4$。</li></ul><h1 id="解题代码"><a href="#解题代码" class="headerlink" title="解题代码"></a>解题代码</h1><pre><code class="hljs C++"><span class="hljs-meta">#<span class="hljs-meta-keyword">include</span> <span class="hljs-meta-string">&lt;cstdio&gt;</span></span><span class="hljs-meta">#<span class="hljs-meta-keyword">include</span> <span class="hljs-meta-string">&lt;cstring&gt;</span></span><span class="hljs-meta">#<span class="hljs-meta-keyword">include</span> <span class="hljs-meta-string">&lt;string&gt;</span></span><span class="hljs-meta">#<span class="hljs-meta-keyword">include</span> <span class="hljs-meta-string">&lt;iostream&gt;</span></span><span class="hljs-meta">#<span class="hljs-meta-keyword">include</span> <span class="hljs-meta-string">&lt;set&gt;</span></span><span class="hljs-meta">#<span class="hljs-meta-keyword">include</span> <span class="hljs-meta-string">&lt;algorithm&gt;</span></span><span class="hljs-meta">#<span class="hljs-meta-keyword">include</span> <span class="hljs-meta-string">&lt;iomanip&gt;</span></span><span class="hljs-meta">#<span class="hljs-meta-keyword">include</span> <span class="hljs-meta-string">&lt;vector&gt;</span></span><span class="hljs-meta">#<span class="hljs-meta-keyword">include</span> <span class="hljs-meta-string">&lt;map&gt;</span></span><span class="hljs-meta">#<span class="hljs-meta-keyword">include</span> <span class="hljs-meta-string">&lt;queue&gt;</span></span><span class="hljs-keyword">using</span> <span class="hljs-keyword">namespace</span> <span class="hljs-built_in">std</span>;<span class="hljs-keyword">const</span> <span class="hljs-keyword">int</span> maxn=<span class="hljs-number">1e5</span>+<span class="hljs-number">5</span>;<span class="hljs-keyword">int</span> n,m;<span class="hljs-built_in">vector</span> &lt;<span class="hljs-keyword">int</span>&gt; a,b,c,ans;<span class="hljs-built_in">map</span> &lt;<span class="hljs-keyword">int</span>,<span class="hljs-keyword">int</span>&gt; num;<span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span>&#123;<span class="hljs-keyword">while</span>(~<span class="hljs-built_in">scanf</span>(<span class="hljs-string">"%d"</span>,&amp;n))&#123;a.clear();b.clear();c.clear();ans.clear();num.clear();<span class="hljs-keyword">int</span> temp;<span class="hljs-keyword">for</span>(<span class="hljs-keyword">int</span> i=<span class="hljs-number">0</span>;i&lt;n;i++)&#123;<span class="hljs-built_in">scanf</span>(<span class="hljs-string">"%d"</span>,&amp;temp);a.push_back(temp);<span class="hljs-keyword">if</span>(num[temp]==<span class="hljs-number">0</span>) num[temp]=<span class="hljs-number">1</span>;<span class="hljs-keyword">else</span> num[temp]++; <span class="hljs-comment">//记录次数 </span>&#125;sort(a.begin(),a.end());ans.push_back(a[<span class="hljs-number">0</span>]); <span class="hljs-comment">//初始装进一个最小a1</span>num[a[<span class="hljs-number">0</span>]]--;<span class="hljs-keyword">for</span>(<span class="hljs-keyword">int</span> i=<span class="hljs-number">1</span>;i&lt;n;i++)&#123;<span class="hljs-keyword">if</span>(!num[a[i]]) <span class="hljs-keyword">continue</span>;<span class="hljs-keyword">for</span>(<span class="hljs-keyword">int</span> j=<span class="hljs-number">0</span>;j&lt;ans.size();j++)&#123;num[a[i]+ans[j]]--;&#125;ans.push_back(a[i]);num[a[i]]--;&#125;  <span class="hljs-built_in">printf</span>(<span class="hljs-string">"%d\n"</span>,ans.size());<span class="hljs-built_in">vector</span> &lt;<span class="hljs-keyword">int</span>&gt; ::iterator it;<span class="hljs-keyword">for</span>(it=ans.begin();it!=ans.end();it++)&#123;<span class="hljs-keyword">if</span>(it==ans.begin()) <span class="hljs-built_in">cout</span>&lt;&lt;*it;<span class="hljs-keyword">else</span> <span class="hljs-built_in">cout</span>&lt;&lt;<span class="hljs-string">" "</span>&lt;&lt;*it;&#125;<span class="hljs-built_in">cout</span>&lt;&lt;<span class="hljs-built_in">endl</span>; &#125;&#125;</code></pre><h1 id="收获与反思"><a href="#收获与反思" class="headerlink" title="收获与反思"></a>收获与反思</h1><ul><li>有序数列的构成注意寻找规律。</li><li>分组后更新数列状态。</li></ul>]]></content>
    
    
    <categories>
      
      <category>Computer Science</category>
      
      <category>ACM</category>
      
      <category>HDU</category>
      
    </categories>
    
    
    <tags>
      
      <tag>ACM</tag>
      
      <tag>HDU</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>【HDU-6170】解题报告（字符串，正则匹配，dp）</title>
    <link href="/post/1eeab2ee.html"/>
    <url>/post/1eeab2ee.html</url>
    
    <content type="html"><![CDATA[<h1 id="原始题目"><a href="#原始题目" class="headerlink" title="原始题目"></a>原始题目</h1><h2 id="Two-strings"><a href="#Two-strings" class="headerlink" title="Two strings"></a>Two strings</h2><ul><li>Time Limit: 2000/1000 MS (Java/Others)    </li><li>Memory Limit: 65536/65536 K (Java/Others)</li><li>Total Submission(s): 2511    </li><li>Accepted Submission(s): 891</li></ul><h3 id="Problem-Description"><a href="#Problem-Description" class="headerlink" title="Problem Description"></a>Problem Description</h3><p>Giving two strings and you should judge if they are matched.</p><ul><li><p>The first string contains lowercase letters and uppercase letters.</p></li><li><p>The second string contains lowercase letters, uppercase letters, and special symbols: “.” and “*”.. can match any letter, and * means the front character can appear any times. </p><a id="more"></a><p>For example, “a.b” can match “acb” or “abb”, “a<em>” can match “a”, “aa” and even empty string. ( “\</em>” will not appear in the front of the string, and there will not be two consecutive “*”.</p></li></ul><h3 id="Input"><a href="#Input" class="headerlink" title="Input"></a>Input</h3><p>The first line contains an integer T implying the number of test cases. (T≤15)<br>For each test case, there are two lines implying the two strings (The length of the two strings is less than 2500).</p><h3 id="Output"><a href="#Output" class="headerlink" title="Output"></a>Output</h3><p>For each test case, print “yes” if the two strings are matched, otherwise print “no”.</p><h3 id="Sample-Input"><a href="#Sample-Input" class="headerlink" title="Sample Input"></a>Sample Input</h3><pre><code>3aaa*abba.*abbaab</code></pre><h3 id="Sample-Output"><a href="#Sample-Output" class="headerlink" title="Sample Output"></a>Sample Output</h3><pre><code>yesyesno</code></pre><h3 id="Source"><a href="#Source" class="headerlink" title="Source"></a>Source</h3><p>2017 Multi-University Training Contest - Team 9</p><h3 id="Recommend"><a href="#Recommend" class="headerlink" title="Recommend"></a>Recommend</h3><p>liuyiding</p><h1 id="题目大意"><a href="#题目大意" class="headerlink" title="题目大意"></a>题目大意</h1><p>给定 $a$，$b$ 两个字符串。$a$字符串只由字母构成，$b$字符串由字母和”.“，”*“两种符号组合成。<br>有如下规则。</p><ul><li>“符号可以匹配任意一个字母。</li><li>“*“符号可以匹配0个或多个上一字母，且不会出现在开头。<br>判断$a$，$b$两字符串能否匹配。</li></ul><h1 id="解题思路"><a href="#解题思路" class="headerlink" title="解题思路"></a>解题思路</h1><p>改变了”*“规则的正则匹配。可以用C++正则匹配的库做，也可以使用dp做。</p><p>dp思路：bool型dp二维数组，$dp[i][j]$表示$a$字符串第i位和$b$字符串第j位能否匹配。</p><p>状态转移方程：</p><ul><li>当$b_j$为”.“时，$dp[i][j]=dp[i-1][j-1]$。</li><li>当$b_j$为字母时，若$a_i=b_j$，则$dp[i][j]=dp[i-1][j-1]$。否则$dp[i][j]=0$。</li><li>当$b_j$为”*“时，根据”*“的规则。上一个字母出现次数为$n$。<ul><li>当$n=0$时，匹配为上一个字母没有出现过，可从$dp[i][j-2]$转移过来。</li><li>当$n=1$时，匹配为上一个字母出现一次，可从$dp[i][j-1]$转移过来。</li><li>当$n=2$时，匹配为上一个字母出现两次，故若$a_i=a_{i-1}$时，可从$dp[i-1][j-1]$转移过来。否则$dp[i][j]=0$。</li><li>当$n&gt;2$时，匹配为上一个出现$n$次，若$a_i=a_{i-1}$时，$dp[i-1][j]$转移过来，可以不断回退直到到上一情况。</li></ul></li></ul><h1 id="解题代码"><a href="#解题代码" class="headerlink" title="解题代码"></a>解题代码</h1><ol><li>正则匹配法</li></ol><pre><code class="hljs C++"><span class="hljs-meta">#<span class="hljs-meta-keyword">include</span> <span class="hljs-meta-string">&lt;iostream&gt;</span></span><span class="hljs-meta">#<span class="hljs-meta-keyword">include</span> <span class="hljs-meta-string">&lt;algorithm&gt;</span></span><span class="hljs-meta">#<span class="hljs-meta-keyword">include</span> <span class="hljs-meta-string">&lt;cstdio&gt;</span></span><span class="hljs-meta">#<span class="hljs-meta-keyword">include</span> <span class="hljs-meta-string">&lt;cmath&gt;</span></span><span class="hljs-meta">#<span class="hljs-meta-keyword">include</span> <span class="hljs-meta-string">&lt;cstring&gt;</span></span><span class="hljs-meta">#<span class="hljs-meta-keyword">include</span> <span class="hljs-meta-string">&lt;string&gt;</span></span><span class="hljs-meta">#<span class="hljs-meta-keyword">include</span> <span class="hljs-meta-string">&lt;string.h&gt;</span></span><span class="hljs-meta">#<span class="hljs-meta-keyword">include</span> <span class="hljs-meta-string">&lt;map&gt;</span></span><span class="hljs-meta">#<span class="hljs-meta-keyword">include</span> <span class="hljs-meta-string">&lt;set&gt;</span></span><span class="hljs-meta">#<span class="hljs-meta-keyword">include</span> <span class="hljs-meta-string">&lt;queue&gt;</span></span><span class="hljs-meta">#<span class="hljs-meta-keyword">include</span> <span class="hljs-meta-string">&lt;deque&gt;</span></span><span class="hljs-meta">#<span class="hljs-meta-keyword">include</span> <span class="hljs-meta-string">&lt;list&gt;</span></span><span class="hljs-meta">#<span class="hljs-meta-keyword">include</span> <span class="hljs-meta-string">&lt;bitset&gt;</span></span><span class="hljs-meta">#<span class="hljs-meta-keyword">include</span> <span class="hljs-meta-string">&lt;stack&gt;</span></span><span class="hljs-meta">#<span class="hljs-meta-keyword">include</span> <span class="hljs-meta-string">&lt;stdlib.h&gt;</span></span><span class="hljs-meta">#<span class="hljs-meta-keyword">include</span> <span class="hljs-meta-string">&lt;regex&gt;</span></span><span class="hljs-meta">#<span class="hljs-meta-keyword">define</span> lowbit(x) (x&amp;-x)</span><span class="hljs-meta">#<span class="hljs-meta-keyword">define</span> e exp(1.0)</span><span class="hljs-meta">#<span class="hljs-meta-keyword">define</span> eps 1e-8</span><span class="hljs-comment">//ios::sync_with_stdio(false);</span><span class="hljs-comment">//    auto start = clock();</span><span class="hljs-comment">//    cout &lt;&lt; (clock() - start) / (double)CLOCKS_PER_SEC;</span><span class="hljs-keyword">typedef</span> <span class="hljs-keyword">long</span> <span class="hljs-keyword">long</span> ll;<span class="hljs-keyword">using</span> <span class="hljs-keyword">namespace</span> <span class="hljs-built_in">std</span>; <span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span>&#123;    ios::sync_with_stdio(<span class="hljs-literal">false</span>);    <span class="hljs-keyword">int</span> T;    <span class="hljs-built_in">cin</span>&gt;&gt;T;    <span class="hljs-keyword">while</span>(T--)    &#123;        <span class="hljs-built_in">string</span> a,b;        <span class="hljs-built_in">cin</span>&gt;&gt;a&gt;&gt;b;        b=regex_replace(b,regex(<span class="hljs-string">"\\.\\*"</span>),<span class="hljs-string">"(.)\\1*"</span>);        regex_match(a,regex(b))?<span class="hljs-built_in">cout</span>&lt;&lt;<span class="hljs-string">"yes"</span>&lt;&lt;<span class="hljs-built_in">endl</span>:<span class="hljs-built_in">cout</span>&lt;&lt;<span class="hljs-string">"no"</span>&lt;&lt;<span class="hljs-built_in">endl</span>;    &#125;    <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;&#125;</code></pre><ol><li>dp<pre><code class="hljs C++"><span class="hljs-meta">#<span class="hljs-meta-keyword">include</span> <span class="hljs-meta-string">&lt;bits/stdc++.h&gt;</span></span><span class="hljs-keyword">using</span> <span class="hljs-keyword">namespace</span> <span class="hljs-built_in">std</span>;<span class="hljs-meta">#<span class="hljs-meta-keyword">define</span> rep(i,a,n) for (int i=a;i&lt;n;i++)</span><span class="hljs-meta">#<span class="hljs-meta-keyword">define</span> per(i,a,n) for (int i=n-1;i&gt;=a;i--)</span><span class="hljs-meta">#<span class="hljs-meta-keyword">define</span> pb push_back</span><span class="hljs-meta">#<span class="hljs-meta-keyword">define</span> mp make_pair</span><span class="hljs-meta">#<span class="hljs-meta-keyword">define</span> np next_permutation</span><span class="hljs-meta">#<span class="hljs-meta-keyword">define</span> all(x) x.begin(),x.end()</span><span class="hljs-meta">#<span class="hljs-meta-keyword">define</span> fi first</span><span class="hljs-meta">#<span class="hljs-meta-keyword">define</span> se second</span><span class="hljs-meta">#<span class="hljs-meta-keyword">define</span> INF Ox3f3f3f3f</span><span class="hljs-meta">#<span class="hljs-meta-keyword">define</span> SZ(x) ((int)(x).size()) </span><span class="hljs-comment">//ios::sync_with_stdio(false);</span><span class="hljs-comment">//    auto start = clock();</span><span class="hljs-comment">//    cout &lt;&lt; (clock() - start) / (double)CLOCKS_PER_SEC;</span><span class="hljs-keyword">const</span> <span class="hljs-keyword">int</span> maxn=<span class="hljs-number">2510</span>;<span class="hljs-keyword">char</span> a[maxn],b[maxn];<span class="hljs-keyword">bool</span> dp[maxn][maxn];<span class="hljs-keyword">int</span> n,m;<span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span>&#123;<span class="hljs-keyword">int</span> TT,T=<span class="hljs-number">0</span>;<span class="hljs-built_in">scanf</span>(<span class="hljs-string">"%d"</span>,&amp;TT);<span class="hljs-keyword">while</span>(TT--)&#123;<span class="hljs-built_in">scanf</span>(<span class="hljs-string">"%s"</span>,a+<span class="hljs-number">1</span>);        <span class="hljs-built_in">scanf</span>(<span class="hljs-string">"%s"</span>,b+<span class="hljs-number">1</span>);        n=<span class="hljs-built_in">strlen</span>(a+<span class="hljs-number">1</span>);        m=<span class="hljs-built_in">strlen</span>(b+<span class="hljs-number">1</span>);        <span class="hljs-built_in">memset</span>(dp,<span class="hljs-number">0</span>,<span class="hljs-keyword">sizeof</span>(dp));        dp[<span class="hljs-number">0</span>][<span class="hljs-number">0</span>]=<span class="hljs-number">1</span>; <span class="hljs-keyword">if</span> (b[<span class="hljs-number">2</span>]==<span class="hljs-string">'*'</span>) dp[<span class="hljs-number">0</span>][<span class="hljs-number">2</span>]=<span class="hljs-number">1</span>;         <span class="hljs-keyword">for</span>(<span class="hljs-keyword">int</span> i=<span class="hljs-number">1</span>;i&lt;=n;i++)&#123;        <span class="hljs-keyword">for</span>(<span class="hljs-keyword">int</span> j=<span class="hljs-number">1</span>;j&lt;=m;j++)&#123;        <span class="hljs-comment">//字母情况 </span>        <span class="hljs-keyword">if</span>(b[j]!=<span class="hljs-string">'.'</span>&amp;&amp;b[j]!=<span class="hljs-string">'*'</span>)&#123;        dp[i][j]=(a[i]==b[j]?dp[i<span class="hljs-number">-1</span>][j<span class="hljs-number">-1</span>]:<span class="hljs-number">0</span>);&#125;<span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span>(b[j]==<span class="hljs-string">'.'</span>)&#123;dp[i][j]=dp[i<span class="hljs-number">-1</span>][j<span class="hljs-number">-1</span>];&#125;<span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span>(b[j]==<span class="hljs-string">'*'</span>)&#123;dp[i][j]=dp[i][j<span class="hljs-number">-1</span>]|dp[i][j<span class="hljs-number">-2</span>];<span class="hljs-keyword">if</span>(a[i]==a[i<span class="hljs-number">-1</span>]&amp;&amp;!dp[i][j]) dp[i][j]=dp[i<span class="hljs-number">-1</span>][j<span class="hljs-number">-1</span>]|dp[i<span class="hljs-number">-1</span>][j]; <span class="hljs-comment">//注意此处!dp[i][j] 否则会将状态由1更新为0，诸如 bb  bba*就会出错 </span>&#125;&#125;&#125;<span class="hljs-keyword">if</span>(dp[n][m]) <span class="hljs-built_in">printf</span>(<span class="hljs-string">"yes\n"</span>);<span class="hljs-keyword">else</span> <span class="hljs-built_in">printf</span>(<span class="hljs-string">"no\n"</span>);&#125;<span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;&#125;<span class="hljs-comment">//1</span><span class="hljs-comment">//bb</span><span class="hljs-comment">//bba*</span></code></pre></li></ol><h1 id="收获与反思"><a href="#收获与反思" class="headerlink" title="收获与反思"></a>收获与反思</h1><ul><li>C++正则匹配regex库，涨姿势。</li><li>字符串dp，状态转移的思考需要学习一下。</li></ul>]]></content>
    
    
    <categories>
      
      <category>Computer Science</category>
      
      <category>ACM</category>
      
      <category>HDU</category>
      
    </categories>
    
    
    <tags>
      
      <tag>ACM</tag>
      
      <tag>HDU</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>【CSU-1005】解题报告（数据结构，树入门，2018暑选入门B题）</title>
    <link href="/post/19e79191.html"/>
    <url>/post/19e79191.html</url>
    
    <content type="html"><![CDATA[<h1 id="原始题目"><a href="#原始题目" class="headerlink" title="原始题目"></a>原始题目</h1><h2 id="1005-Binary-Search-Tree-analog"><a href="#1005-Binary-Search-Tree-analog" class="headerlink" title="1005: Binary Search Tree analog"></a>1005: Binary Search Tree analog</h2><p>Time Limit: 1 Sec<br>Memory Limit: 128 Mb<br>Submitted: 1630<br>Solved: 473    </p><h3 id="Description"><a href="#Description" class="headerlink" title="Description"></a>Description</h3><p>Binary Search Tree, abbreviated as BST, is a kind of binary tree maintains the following property:<br><a id="more"></a></p><ul><li>Each node has a Key value, which can be used to compare with each other.</li><li>For every node in the tree, every Key value in its left subtree is smaller than its own Key value.</li><li>For every node in the tree, every Key value in its right subtree is equal to or larger than its own Key value.</li></ul><p>Now we need to analog a BST, we only require one kind of operation: inserting.</p><p>First, we have an empty BST. Input is a sequence of numbers. We need to insert them one by one flowing the rules below:</p><p>If the inserted value is smaller than the root’s value, insert it to the left subtree.</p><p>If the inserted value is larger than or equal to the value of the root’s value, insert it to the right subtree.</p><p>After each input, we need to output the preorder, inorder, postorder traversal sequences.</p><p>About tree traversal, the following is from Wikipedia:</p><blockquote><p>Depth-first Traversal<br>To traverse a non-empty binary tree in preorder, perform the following operations recursively at each node, starting with the root node:</p><ul><li>Visit the root.</li><li>Traverse the left subtree.</li><li>Traverse the right subtree.</li></ul><p>To traverse a non-empty binary tree in inorder (symmetric), perform the following operations recursively at each node:</p><ul><li>Traverse the left subtree.</li><li>Visit the root.</li><li>Traverse the right subtree.</li></ul><p>To traverse a non-empty binary tree in postorder, perform the following operations recursively at each node:</p><ul><li>Traverse the left subtree.</li><li>Traverse the right subtree.</li><li>Visit the root.</li></ul></blockquote><p>Look at the folowing example:</p><p>Intput is a sequence of 5 integers: 3 6 9 5 1</p><p>After each integer inserted the structure of the tree is illustrated in the flowing:</p><pre><code>   3 /   \1      6     /  \    5     9</code></pre><h3 id="Input"><a href="#Input" class="headerlink" title="Input"></a>Input</h3><p>The first integer of the input is T, the number of test cases. Each test case has two lines. The first line contain an integer N,(1≤N≤1000), the number of numbers need to be inserted into the BST. The second line contain N integers separated by space, each integer is in the range of [0,230].</p><h3 id="Output"><a href="#Output" class="headerlink" title="Output"></a>Output</h3><p>Each test case, output must contain three lines: the preorder, inorder and postorder traversal sequence. The numbers in each line should be separated by a single space and you should not output anything at the end of the line! Output a blank line after each case.</p><h3 id="Sample-Input"><a href="#Sample-Input" class="headerlink" title="Sample Input"></a>Sample Input</h3><pre><code>1   53 6 9 5 1</code></pre><h3 id="Sample-Output"><a href="#Sample-Output" class="headerlink" title="Sample Output"></a>Sample Output</h3><pre><code>3 1 6 5 91 3 5 6 91 5 9 6 3</code></pre><h3 id="Hint"><a href="#Hint" class="headerlink" title="Hint"></a>Hint</h3><h3 id="Source"><a href="#Source" class="headerlink" title="Source"></a>Source</h3><p>中南大学第五届大学生程序设计竞赛-热身赛</p><h1 id="题目大意"><a href="#题目大意" class="headerlink" title="题目大意"></a>题目大意</h1><p>构建二叉搜索树，然后将树按前序，中序，后序输出。</p><h1 id="解题思路"><a href="#解题思路" class="headerlink" title="解题思路"></a>解题思路</h1><p>构建二叉树，写函数三种序输出即可。树入门题。</p><h1 id="解题代码"><a href="#解题代码" class="headerlink" title="解题代码"></a>解题代码</h1><pre><code class="hljs C++"><span class="hljs-meta">#<span class="hljs-meta-keyword">include</span> <span class="hljs-meta-string">&lt;cstdio&gt;</span></span><span class="hljs-meta">#<span class="hljs-meta-keyword">include</span> <span class="hljs-meta-string">&lt;cstring&gt;</span></span><span class="hljs-meta">#<span class="hljs-meta-keyword">include</span> <span class="hljs-meta-string">&lt;iostream&gt;</span></span><span class="hljs-meta">#<span class="hljs-meta-keyword">include</span> <span class="hljs-meta-string">&lt;set&gt;</span></span><span class="hljs-meta">#<span class="hljs-meta-keyword">include</span> <span class="hljs-meta-string">&lt;queue&gt;</span></span><span class="hljs-meta">#<span class="hljs-meta-keyword">include</span> <span class="hljs-meta-string">&lt;map&gt;</span></span><span class="hljs-meta">#<span class="hljs-meta-keyword">include</span> <span class="hljs-meta-string">&lt;algorithm&gt;</span></span><span class="hljs-keyword">using</span> <span class="hljs-keyword">namespace</span> <span class="hljs-built_in">std</span>;<span class="hljs-keyword">typedef</span> <span class="hljs-keyword">long</span> <span class="hljs-keyword">long</span> ll;<span class="hljs-keyword">const</span> <span class="hljs-keyword">int</span> maxn=<span class="hljs-number">1e5</span>+<span class="hljs-number">5</span>;<span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">node</span>&#123;</span><span class="hljs-keyword">int</span> x;<span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">node</span> *<span class="hljs-title">left</span>,*<span class="hljs-title">right</span>;</span>&#125;<span class="hljs-built_in">list</span>[maxn];<span class="hljs-keyword">int</span> t,i,n,x,flag1=<span class="hljs-number">1</span>;<span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">node</span> <span class="hljs-title">root</span>,*<span class="hljs-title">p</span>;</span><span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">Insert</span><span class="hljs-params">(struct node *r,struct node *p)</span></span>&#123;<span class="hljs-keyword">if</span>(!r) <span class="hljs-keyword">return</span>;<span class="hljs-keyword">if</span>(r-&gt;x&gt;p-&gt;x)&#123;<span class="hljs-keyword">if</span>(r-&gt;left) Insert(r-&gt;left,p);<span class="hljs-keyword">else</span> r-&gt;left=p;&#125;<span class="hljs-keyword">else</span>&#123;<span class="hljs-keyword">if</span>(r-&gt;right) Insert(r-&gt;right,p);<span class="hljs-keyword">else</span> r-&gt;right=p;&#125;&#125;<span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">pretral</span><span class="hljs-params">(struct node *p)</span></span>&#123;<span class="hljs-keyword">if</span>(!p) <span class="hljs-keyword">return</span>;<span class="hljs-keyword">if</span>(flag1) <span class="hljs-built_in">printf</span>(<span class="hljs-string">"%d"</span>,p-&gt;x),flag1=<span class="hljs-number">0</span>;<span class="hljs-keyword">else</span> <span class="hljs-built_in">printf</span>(<span class="hljs-string">" %d"</span>,p-&gt;x);pretral(p-&gt;left);pretral(p-&gt;right);&#125;<span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">intral</span><span class="hljs-params">(struct node *p)</span></span>&#123;<span class="hljs-keyword">if</span>(!p) <span class="hljs-keyword">return</span>;intral(p-&gt;left);<span class="hljs-keyword">if</span>(flag1) <span class="hljs-built_in">printf</span>(<span class="hljs-string">"%d"</span>,p-&gt;x),flag1=<span class="hljs-number">0</span>;<span class="hljs-keyword">else</span> <span class="hljs-built_in">printf</span>(<span class="hljs-string">" %d"</span>,p-&gt;x);intral(p-&gt;right);&#125;<span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">postod</span><span class="hljs-params">(struct node *p)</span></span>&#123;<span class="hljs-keyword">if</span>(!p) <span class="hljs-keyword">return</span>;postod(p-&gt;left);postod(p-&gt;right);<span class="hljs-keyword">if</span>(flag1) <span class="hljs-built_in">printf</span>(<span class="hljs-string">"%d"</span>,p-&gt;x),flag1=<span class="hljs-number">0</span>;<span class="hljs-keyword">else</span> <span class="hljs-built_in">printf</span>(<span class="hljs-string">" %d"</span>,p-&gt;x);&#125;<span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span>&#123;<span class="hljs-built_in">scanf</span>(<span class="hljs-string">"%d"</span>,&amp;t);<span class="hljs-keyword">while</span>(t--)&#123;<span class="hljs-built_in">scanf</span>(<span class="hljs-string">"%d"</span>,&amp;n);<span class="hljs-built_in">scanf</span>(<span class="hljs-string">"%d"</span>,&amp;root.x);root.left=root.right=<span class="hljs-number">0</span>;<span class="hljs-keyword">for</span>(i=<span class="hljs-number">0</span>;i&lt;n<span class="hljs-number">-1</span>;i++)&#123;<span class="hljs-built_in">scanf</span>(<span class="hljs-string">"%d"</span>,&amp;x);p=&amp;<span class="hljs-built_in">list</span>[i];p-&gt;x=x;p-&gt;left=p-&gt;right=<span class="hljs-number">0</span>;Insert(&amp;root,p);&#125;flag1=<span class="hljs-number">1</span>;pretral(&amp;root);<span class="hljs-built_in">printf</span>(<span class="hljs-string">"\n"</span>);flag1=<span class="hljs-number">1</span>;intral(&amp;root);<span class="hljs-built_in">printf</span>(<span class="hljs-string">"\n"</span>);flag1=<span class="hljs-number">1</span>;postod(&amp;root);<span class="hljs-built_in">printf</span>(<span class="hljs-string">"\n"</span>);<span class="hljs-built_in">printf</span>(<span class="hljs-string">"\n"</span>);&#125;&#125;</code></pre><h1 id="收获与反思"><a href="#收获与反思" class="headerlink" title="收获与反思"></a>收获与反思</h1><p>数据结构入门，二叉树熟悉，水题。</p>]]></content>
    
    
    <categories>
      
      <category>Computer Science</category>
      
      <category>ACM</category>
      
      <category>CSU</category>
      
    </categories>
    
    
    <tags>
      
      <tag>ACM</tag>
      
      <tag>CSU</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>【CSU-1224】解题报告（BFS，水题，2018暑选入门A题）</title>
    <link href="/post/fb5efb9c.html"/>
    <url>/post/fb5efb9c.html</url>
    
    <content type="html"><![CDATA[<h1 id="原始题目"><a href="#原始题目" class="headerlink" title="原始题目"></a>原始题目</h1><h2 id="1224-ACM小组的古怪象棋"><a href="#1224-ACM小组的古怪象棋" class="headerlink" title="1224: ACM小组的古怪象棋"></a>1224: ACM小组的古怪象棋</h2><p>Time Limit: 1 Sec<br>Memory Limit: 128 Mb<br>Submitted: 851<br>Solved: 347    </p><a id="more"></a><h3 id="Description"><a href="#Description" class="headerlink" title="Description"></a>Description</h3><p>ACM小组的Samsara和Staginner对中国象棋特别感兴趣，尤其对马（可能是因为这个棋子的走法比较多吧）的使用进行深入研究。今天他们又在 构思一个古怪的棋局:假如Samsara只有一个马了，而Staginner又只剩下一个将，两个棋子都在棋盘的一边，马不能出这一半棋盘的范围，另外这 一半棋盘的大小很奇特(n行m列)。Samsara想知道他的马最少需要跳几次才能吃掉Staginner的将(我们假定其不会移动)。当然这个光荣的任 务就落在了会编程的你的身上了。</p><h3 id="Input"><a href="#Input" class="headerlink" title="Input"></a>Input</h3><p>每组数据一行，分别为六个用空格分隔开的正整数$n,m,x1,y1,x2,y2$分别代表棋盘的大小$n,m$以及将的坐标和马的坐标。<br>$(1 \le x1,x2  \le n \le 20 ,1 \le y1,y2 \le m \le 20)$ ，将和马的坐标不相同。</p><h3 id="Output"><a href="#Output" class="headerlink" title="Output"></a>Output</h3><p>输出对应也有若干行，请输出最少的移动步数,如果不能吃掉将则输出“-1”(不包括引号)。</p><h3 id="Sample-Input"><a href="#Sample-Input" class="headerlink" title="Sample Input"></a>Sample Input</h3><pre><code>8 8 5 1 4 5</code></pre><h3 id="Sample-Output"><a href="#Sample-Output" class="headerlink" title="Sample Output"></a>Sample Output</h3><pre><code>3</code></pre><h3 id="Hint"><a href="#Hint" class="headerlink" title="Hint"></a>Hint</h3><h3 id="Source"><a href="#Source" class="headerlink" title="Source"></a>Source</h3><p>CSU Monthly 2011 Dec.</p><h1 id="题目大意"><a href="#题目大意" class="headerlink" title="题目大意"></a>题目大意</h1><p>如题</p><h1 id="解题思路"><a href="#解题思路" class="headerlink" title="解题思路"></a>解题思路</h1><p>马的坐标为单入口BFS，如果搜索不到输出-1.</p><h1 id="解题代码"><a href="#解题代码" class="headerlink" title="解题代码"></a>解题代码</h1><pre><code class="hljs C++"><span class="hljs-meta">#<span class="hljs-meta-keyword">include</span> <span class="hljs-meta-string">&lt;queue&gt;</span></span><span class="hljs-meta">#<span class="hljs-meta-keyword">include</span> <span class="hljs-meta-string">&lt;cstdio&gt;</span></span><span class="hljs-meta">#<span class="hljs-meta-keyword">include</span> <span class="hljs-meta-string">&lt;cstring&gt;</span></span><span class="hljs-meta">#<span class="hljs-meta-keyword">include</span> <span class="hljs-meta-string">&lt;cstdlib&gt;</span></span><span class="hljs-meta">#<span class="hljs-meta-keyword">define</span> maxn 35</span><span class="hljs-keyword">using</span> <span class="hljs-keyword">namespace</span> <span class="hljs-built_in">std</span>; <span class="hljs-keyword">int</span> n,m,x1,y1,x2,y2;<span class="hljs-keyword">bool</span> vis[maxn][maxn];<span class="hljs-keyword">int</span> dir[<span class="hljs-number">8</span>][<span class="hljs-number">2</span>]=&#123;&#123;<span class="hljs-number">-2</span>,<span class="hljs-number">1</span>&#125;,&#123;<span class="hljs-number">-2</span>,<span class="hljs-number">-1</span>&#125;,&#123;<span class="hljs-number">-1</span>,<span class="hljs-number">2</span>&#125;,&#123;<span class="hljs-number">-1</span>,<span class="hljs-number">-2</span>&#125;,&#123;<span class="hljs-number">1</span>,<span class="hljs-number">2</span>&#125;,&#123;<span class="hljs-number">1</span>,<span class="hljs-number">-2</span>&#125;,&#123;<span class="hljs-number">2</span>,<span class="hljs-number">1</span>&#125;,&#123;<span class="hljs-number">2</span>,<span class="hljs-number">-1</span>&#125;&#125;;<span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">State</span> // <span class="hljs-title">BFS</span> 队列中的状态数据结构&#123;</span><span class="hljs-keyword">int</span> x,y;<span class="hljs-keyword">int</span> Step_Counter; <span class="hljs-comment">// 搜索步数统计器</span>&#125;;<span class="hljs-comment">//State a[maxn];</span><span class="hljs-keyword">int</span> ans[maxn];<span class="hljs-function"><span class="hljs-keyword">bool</span> <span class="hljs-title">CheckState</span><span class="hljs-params">(State next)</span> <span class="hljs-comment">// 约束条件检验</span></span>&#123;<span class="hljs-keyword">if</span>(next.x&gt;=<span class="hljs-number">1</span>&amp;&amp;next.x&lt;=n&amp;&amp;next.y&gt;=<span class="hljs-number">1</span>&amp;&amp;next.y&lt;=m&amp;&amp;!vis[next.x][next.y]) <span class="hljs-comment">// 满足条件</span>&#123;<span class="hljs-comment">//printf("next x=%d y=%d\n",next.x,next.y);</span><span class="hljs-keyword">return</span> <span class="hljs-number">1</span>;&#125;<span class="hljs-keyword">else</span> <span class="hljs-comment">// 约束条件冲突</span><span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;&#125;<span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">bfs</span><span class="hljs-params">(State st)</span></span>&#123;<span class="hljs-keyword">int</span> flag=<span class="hljs-number">0</span>;<span class="hljs-built_in">queue</span> &lt;State&gt; q; <span class="hljs-comment">// BFS 队列</span>State now,next; <span class="hljs-comment">// 定义2个状态，当前和下一个</span>st.Step_Counter=<span class="hljs-number">0</span>; <span class="hljs-comment">// 计数器清零</span>q.push(st); <span class="hljs-comment">// 入队</span>vis[st.x][st.y]=<span class="hljs-number">1</span>; <span class="hljs-comment">// 访问标记</span><span class="hljs-keyword">while</span>(!q.empty())&#123;now=q.front(); <span class="hljs-comment">// 取队首元素进行扩展</span><span class="hljs-comment">//a[now.i].Step_Counter=++circle;</span><span class="hljs-keyword">if</span>(now.x==x1&amp;&amp;now.y==y1) &#123;flag=<span class="hljs-number">1</span>;<span class="hljs-built_in">printf</span>(<span class="hljs-string">"%d\n"</span>,now.Step_Counter);<span class="hljs-keyword">return</span> ;&#125;<span class="hljs-keyword">for</span>(<span class="hljs-keyword">int</span> i=<span class="hljs-number">0</span>;i&lt;<span class="hljs-number">8</span>;i++)&#123;next.x=now.x+dir[i][<span class="hljs-number">0</span>];next.y=now.y+dir[i][<span class="hljs-number">1</span>]; next.Step_Counter=now.Step_Counter+<span class="hljs-number">1</span>; <span class="hljs-comment">// 计数器加1</span><span class="hljs-keyword">if</span>(CheckState(next)) <span class="hljs-comment">// 如果状态满足约束条件则入队</span>&#123;q.push(next);<span class="hljs-comment">//printf("insert x=%d y=%d\n",next.x,next.y);</span>vis[next.x][next.y]=<span class="hljs-number">1</span>; <span class="hljs-comment">//访问标记</span>&#125;&#125;q.pop(); <span class="hljs-comment">// 队首元素出队</span>&#125;<span class="hljs-built_in">printf</span>(<span class="hljs-string">"-1\n"</span>); <span class="hljs-keyword">return</span>;&#125;<span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span>&#123;<span class="hljs-keyword">while</span>(~<span class="hljs-built_in">scanf</span>(<span class="hljs-string">"%d%d%d%d%d%d"</span>,&amp;n,&amp;m,&amp;x1,&amp;y1,&amp;x2,&amp;y2))&#123;<span class="hljs-built_in">memset</span>(vis,<span class="hljs-number">0</span>,<span class="hljs-keyword">sizeof</span>(vis));State start;start.x=x2;start.y=y2;bfs(start);&#125;<span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;&#125;</code></pre><h1 id="收获与反思"><a href="#收获与反思" class="headerlink" title="收获与反思"></a>收获与反思</h1><p>bfs，可以考虑将模板改为bool型。</p>]]></content>
    
    
    <categories>
      
      <category>Computer Science</category>
      
      <category>ACM</category>
      
      <category>CSU</category>
      
    </categories>
    
    
    <tags>
      
      <tag>ACM</tag>
      
      <tag>CSU</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>《解忧杂货店》读书笔记</title>
    <link href="/post/5555df5.html"/>
    <url>/post/5555df5.html</url>
    
    <content type="html"><![CDATA[<h1 id="内容摘录"><a href="#内容摘录" class="headerlink" title="内容摘录"></a>内容摘录</h1><h2 id="第一章-回答在牛奶箱里"><a href="#第一章-回答在牛奶箱里" class="headerlink" title="第一章 回答在牛奶箱里"></a>第一章 回答在牛奶箱里</h2><blockquote><p>P49 “让深爱的人放弃梦想，这比死还让我痛苦。即使分隔两地，我们的心也会永远在一起。你不要有任何顾虑，我希望你无怨无悔地去追寻梦想。”</p></blockquote><h2 id="第三章-在思域车上等到天亮"><a href="#第三章-在思域车上等到天亮" class="headerlink" title="第三章 在思域车上等到天亮"></a>第三章 在思域车上等到天亮</h2><blockquote><p>P101 “不管是骚扰还是恶作剧，写这些信给浪失杂货店的人，和普通的咨询者再本质上是一样的。他们都是内心破了个洞，重要的东西正从那个破洞逐渐流失。”</p><p>P106 “这么多年咨询信看下来，让我逐渐明白了一件事。很多时候，咨询的人心里已经有了答案，来咨询只是想确认自己的决定是对的。”</p><p>P107 “或许雄治留恋的不是杂货店，二十烦恼咨询。他觉得一旦关了店离开这里，就不会有人来找他咨询了。”</p><p>P175 “人与人之间情断义绝，并不需要什么具体的理由，就算表面上有，也很可能只是心已经离开的结果，事后才编造出的借口而已。因为倘若心没有离开，当将会导致关系破裂的事态发生时，理应有人努力去挽救。如果没有，说明其实关系早已破裂。所以那四个人谁也没有挽救披头士乐队，就像看客一般，眼睁睁看着船只沉没。”</p></blockquote><p>Last page “我衷心的祈祷你可以相信你自己，无悔地燃烧自己的人生。”</p>]]></content>
    
    
    <categories>
      
      <category>Life</category>
      
      <category>阅读</category>
      
    </categories>
    
    
    <tags>
      
      <tag>阅读</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>《如何阅读一本书》读书笔记</title>
    <link href="/post/3c57c5dc.html"/>
    <url>/post/3c57c5dc.html</url>
    
    <content type="html"><![CDATA[<h1 id="内容摘录"><a href="#内容摘录" class="headerlink" title="内容摘录"></a>内容摘录</h1><h2 id="第一篇-阅读的层次"><a href="#第一篇-阅读的层次" class="headerlink" title="第一篇 阅读的层次"></a>第一篇 阅读的层次</h2><h3 id="第一章-阅读的活力与艺术"><a href="#第一章-阅读的活力与艺术" class="headerlink" title="第一章 阅读的活力与艺术"></a>第一章 阅读的活力与艺术</h3><blockquote><p>P9 “‘阅读的人’（readers），是指那些今天仍然习惯于从书写文字中汲取大量资讯，以增进对世界了解的人。”</p><p>P10 “太多的咨询就如童太少的资讯一样，都是一种对理解力的阻碍。换句话说，现代的媒体正以压倒性的泛滥资讯阻碍了我们的理解力。”</p></blockquote><a id="more"></a><blockquote><p>P11 “听众或读者的‘接收’，应该像是棒球赛中的捕手才对。……我们可以把这个类比的概念往前推。捕手的艺术就在能接住任何球的技巧——快速球、曲线球、变化球、慢速球等等。同样地，阅读的艺术也在尽可能掌握住每一种讯息的技巧。”</p><p>P18 “蒙田说：‘初学者的无知在于未学’，而学者的无知在于学后。”</p><p>P19 “倾听是从一位出现在你眼前的老师学习——一位活生生的老师——而阅读却是跟一位缺席的老师学习。如果你问一位活生生的老师一个问题，他可能会回答你。如果你还是不懂他的说的话，你可以再问他问题，省下自己思考的时间。然而如果你问一本书一个问题，你就必须自己回答这个问题。在这样的情况下，这本书就跟自然或世界一样。当你提出问题时，只有等你自己作了思考与分析之后，才会在书本上找到答案。”</p><p>P22 “我们要懂得如何让书本来教导我们。事实上，这就是这本书最主要的目的。”</p></blockquote><h3 id="第二章-阅读的层次"><a href="#第二章-阅读的层次" class="headerlink" title="第二章 阅读的层次"></a>第二章 阅读的层次</h3><ul><li>阅读的四个层次，我们称之为基础阅读，检视阅读，分析阅读，主题阅读，这四个层次是渐进的。</li></ul><blockquote><p>P26 “如果说检视阅读是在涌现的时间内，最好也最完整的阅读，那么分析阅读就是在无限的时间里，最好也最完整的阅读。”</p><p>P27 “弗兰西斯·培根曾今说过：‘有些书可以浅尝辄止，有些书是要生吞活剥，只有少数的书是要咀嚼与消化的。’分析阅读就是要咀嚼与消化一本书。”</p><p>P27 “在做主题阅读时，阅读者会越读很多书，而不是一本书，并列举出这些书之间相关之处，提出一个所有的书都谈到的主题。但只是书本里字里行间的比较还不够。主题阅读涉及的远不止此。借助他所阅读的书籍，主题阅读这要能够架构出一个可能在哪一本书里都没提过的主题分析。”</p></blockquote><h3 id="第三章-阅读的第一个层次：基础阅读"><a href="#第三章-阅读的第一个层次：基础阅读" class="headerlink" title="第三章 阅读的第一个层次：基础阅读"></a>第三章 阅读的第一个层次：基础阅读</h3><blockquote><p>P37 “我们的历史一直强调，无限制的受教育机会是一个社会能够提供给人民最有价值的服务——或说得正确一点，只有当一个人的自我期许，能力与需要受限制时，教育机会才会受到限制。我们还没有办法提供这种机会之前，不表示我们就有理由要放弃尝试。”</p></blockquote><h3 id="第四章-阅读的第二个层次：检视阅读"><a href="#第四章-阅读的第二个层次：检视阅读" class="headerlink" title="第四章 阅读的第二个层次：检视阅读"></a>第四章 阅读的第二个层次：检视阅读</h3><blockquote><p>P39 “略读的i管应该用不着花太多时间，下面是要如何去做的一些建议：（1）先看书名页，然后如果有序就先看序。（2）研究目录页。（3）如果书中富有索引，也要检阅一下。（4）不妨读一下出版者的介绍。（5）开始挑几个看起来跟主题息息相关的篇章来看。（6）最后一步，把书打开翻看，有时候连续读几页，但不要太多。”</p><p>P47 “拍摄下来的眼睛在活动时的影片，显示年轻或未受过训练的阅读者，在阅读一行字的时候会在五六个地方发生‘逗留’（fixate）现象。（眼睛在移动时看不见，只有停下来时才能看见。）因此，他们在读这一行字的时候，只能间隔着看到一个个单字或最多两三个字的组合。更糟的是，这些不熟练的阅读这在看过每两三行后，眼睛就自然地‘倒退’（regress）到原点——也就是说，他们又会倒退到先前读过的句子与那一行去了。所有这些习惯不但浪费而且显然降低了阅读的的速度。之所以说是浪费，因为我们的头脑跟眼睛不一样，并不需要一次只‘读’一个字或一个句子。我们的头脑是个惊人的工具，可以在‘一瞥’之间掌握住一个句子或段落——只要眼睛能提供足够资讯。”</p><p>P50 “在阅读一本书的时候，慢不该慢到不值得，快不该快到有损于满足与理解。不论怎么说，阅读的速度，不论是快还是慢，只不过是阅读问题一个微笑的部分而已。”</p><p>P51 “在第一次阅读一本很难得书时，不要企图了解每一个子句。这是最最重要的一个规则。这也是检视阅读的基本概念。不要害怕，或是但又自己似乎读得很肤浅。就算是最难读的书也快快地读一遍。当你再度第二次时，你就已经准备好要读这本书了。”</p></blockquote><h3 id="第五章-如何做一个自我要求的读者"><a href="#第五章-如何做一个自我要求的读者" class="headerlink" title="第五章 如何做一个自我要求的读者"></a>第五章 如何做一个自我要求的读者</h3><blockquote><p>P52 “在阅读的时候想要保持清醒，或昏昏入睡，主要看你的阅读目标是什么。如果你的月度目标是获得利益——不论是心灵或精神上的成长——你就得保持清醒。这也意味着在阅读时要尽可能地保持主动，同时还要做一番努力——而这番努力是会有回馈的。”</p><p>P53 “关于一本书，你一定要提出四个主要的问题。（1）整体来说，这本书到底在谈些什么？（2）作者细部说了什么，怎么说的？（3）这本书说得有道理吗？是全部有道理。还是部分有道理（4）这本书跟你有什么关系？”</p><p>P60 “所谓艺术或技巧，只属于哪个能养成习惯，而且能依照规则来运作的人。这也是艺术家或任何领域的工匠与众不同之处。”</p></blockquote><h2 id="第二篇-阅读的第三个层次：分析阅读"><a href="#第二篇-阅读的第三个层次：分析阅读" class="headerlink" title="第二篇 阅读的第三个层次：分析阅读"></a>第二篇 阅读的第三个层次：分析阅读</h2><h3 id="第六章-一本书的分类"><a href="#第六章-一本书的分类" class="headerlink" title="第六章 一本书的分类"></a>第六章 一本书的分类</h3><ul><li>实用性vs.理论性作品，理论——是什么，实用——怎么做。</li></ul><blockquote><p>P74 “实用是与某种有效的做法有关，不管是立即或长程的功效。而理论所关注的却是去明白或了解某件事。”</p><p>P74 “纯科学于应用科学的区别，或是像通常非常粗糙的那种说法，也就是科学与科技之间的区别。有些书或有些老师，只对他们要传达的知识本身感兴趣。这并不是说他们否定知识的实用性，或是他们坚持只该为知识而知识。他们知识将自己限制在某一种沟通或教学方式中，而让其他人去用别的方式。其他这些人的兴趣则在追求知识本身以外的事上，他们关切的是哪些知识能帮忙解决的人生问题。他们也传递知识，但永远带着一种强调知识的实际应用的观点。”</p><p>P78 “质疑某件事的有效性是理论，而质疑任何事的目的，却是实用。”</p><p>P75 “要让知识变成有用，就要有操作的规则。我们一定要超越‘知道这是怎么回事’，进而明白‘如果我想做些什么，应该怎么利用它’。”<br>知与行的区别，而本书就是一本告诉我们该怎么做的实用的书。</p><p>P81 “如果一本理论的书所强调的内容，超乎你日常、理性、正常生活的经验，那就是科学的书。否则就是一本哲学的书。”</p></blockquote><h3 id="第七章-透视一本书"><a href="#第七章-透视一本书" class="headerlink" title="第七章 透视一本书"></a>第七章 透视一本书</h3><blockquote><p>P85 “对于‘整体内容’这件事，光是一个模糊的认知是不够的，你必须要确切清楚地了解才行。只有一个方法能知道你是否成功了。你必须能用几句话，告诉你自己，或别人，这整本书在说的是什么。（如果你要说的话太多，表示你还没有将整体的内容看清楚，而只是看到了多样的内容。）”</p><p>P106 “分析阅读的第一阶段，或，找出一本书在谈些什么的四个规则：（1）依照书本的种类与主题作分类。（2）用最简短的句子说出整本书在谈些什么。（3）按照顺序与关系，列出全书的重要部分。将全书的纲要拟出来之后，再将各个部分的纲要也一一列出。（4）找出作者在问的问题，或作者想要解决的问题。”</p></blockquote><h3 id="第八章-与作者找出共通的词义"><a href="#第八章-与作者找出共通的词义" class="headerlink" title="第八章  与作者找出共通的词义"></a>第八章  与作者找出共通的词义</h3><blockquote><p>P116 “就积极面来说，只要熟悉一下哪个领域，你就能找出这些专门的单字；就消极面来说，你只要看到不是平常惯见的单字，就会知道那些字一定是专门用语。”</p><p>P116 “另外一个线索是，作者与其他作者争执的某个用语就是重要的字。”</p><p>P119 “你一定要利用上下文自己已经了解的所有字句，来推敲出你所不了解的那个字的意义。”</p><p>P132 “第五个规则：找出关键字，与作者达成共识。第六个规则可以说是：将一本书中最重要的句子圈起来，找出其中的主旨。第七个规则是：从相关文句的关联中，设法架构出一本书的基本论述。”</p><p>P133 “从一个赌这的观点来看，对你重要的句子就是一些需要花一点努力来诠释的句子，因为你第一眼看到这些句子时并不能完全理解…….最重要的句子就是在整个论述中，阐述作者判断的部分。”</p></blockquote><p>未完待续</p><p>中间换了一个版本，所以页码乱掉了</p>]]></content>
    
    
    <categories>
      
      <category>Life</category>
      
      <category>阅读</category>
      
    </categories>
    
    
    <tags>
      
      <tag>阅读</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>C++运算符重载与无名对象引用问题的一点思考</title>
    <link href="/post/ab4ed95b.html"/>
    <url>/post/ab4ed95b.html</url>
    
    <content type="html"><![CDATA[<h1 id="问题的发现"><a href="#问题的发现" class="headerlink" title="问题的发现"></a>问题的发现</h1><p>今天复习C++运算符重载时候的意外发现：关于类的临时对象以及引用的一些思考。来源于C++程序设计（小红书）上给出了“+”号运算符重载的样例。</p><a id="more"></a><h2 id="基本知识回顾"><a href="#基本知识回顾" class="headerlink" title="基本知识回顾"></a>基本知识回顾</h2><h3 id="重载运算符的习惯"><a href="#重载运算符的习惯" class="headerlink" title="重载运算符的习惯"></a>重载运算符的习惯</h3><ul><li>C++规定，赋值运算符=、下标运算符[]、函数调用运算符()、成员运算符-&gt;必须作为成员函数。</li><li>流插入运算符&lt;&lt; 和流提取运算符 &gt;&gt;、类型转换运算符不能定义为类的成员函数，只能作为友元函数。</li><li>一般将单目运算符和复合运算符重载为成员函数</li><li>一般将双目运算符重载为友元函数。<h2 id="Next"><a href="#Next" class="headerlink" title="Next"></a>Next</h2>So 根据上述的习惯，我对着屏幕敲了书上的样例的类定义的代码。</li></ul><pre><code class="hljs C++">class Complex&#123;    public:        Complex() &#123;            real=0;            imag=0;        &#125;        Complex(double d)&#123;real=d;imag=0;&#125;        Complex(double r,double i)&#123;real =r;imag=i;&#125;friend Complex operator + (Complex &amp;a,Complex &amp;b);friend ostream&amp; operator &lt;&lt; (ostream &amp;,Complex &amp;); private:double real;double imag;&#125;;Complex operator +(Complex &amp;a,Complex &amp;b)&#123;Complex temp;temp.real=a.real+b.real;temp.imag=a.imag+b.imag;return temp;&#125;ostream&amp; operator &lt;&lt; (ostream&amp; output,Complex &amp;a )&#123;cout&lt;&lt;"("&lt;&lt;a.real&lt;&lt;","&lt;&lt;a.imag&lt;&lt;"i)";return output;&#125;int main()&#123;Complex c1(3,4),c2(5,-10),c3;c3=c1+4.0;cout&lt;&lt;c3&lt;&lt;endl;c3=c3+c1;cout &lt;&lt;c3&lt;&lt;endl;&#125;</code></pre><p>写完感觉看着是没什么问题对吧（我真觉的没什么问题）。<br>然而运行了一下就报错了，那…报什么错了？</p><pre><code>[Error] no match for &#39;operator+&#39; (operand types are &#39;Complex&#39; and &#39;double&#39;)[Note] candidates are:[Note] Complex operator+(Complex&amp;, Complex&amp;)[Note] no known conversion for argument 2 from &#39;Complex&#39; to &#39;Complex&amp;&#39;</code></pre><p>哦哦看了下报错，原来是重载函数写的问题，我先去查了一下代码。</p><p>课本上给出的重载运算符声明和定义是：</p><pre><code>friend Complex operator + (Complex a,Complex b);...</code></pre><p>我自己看走眼敲成了：</p><pre><code>friend Complex operator + (Complex &amp;a,Complex &amp;b);...</code></pre><p>看出问题在哪了么？没错就是一个”&amp;”的差别，即形参是Complex类对象的引用还是Complex类对象。</p><h1 id="问题展开与解决"><a href="#问题展开与解决" class="headerlink" title="问题展开与解决"></a>问题展开与解决</h1><p>去掉”&amp;”后程序果然可以正常运行的。不过我考虑了一下程序的实现过程，不对啊，一个简单的相加，我传递一个类对象的引用<br>不应该出现什么问题啊，”+”本身又不会对引用的对象进行什么操作，返回类型是一个Complex类的对象。问题出现在哪里了？</p><h2 id="一些奇葩（正经）的实验"><a href="#一些奇葩（正经）的实验" class="headerlink" title="一些奇葩（正经）的实验"></a>一些奇葩（正经）的实验</h2><p>于是乎我把之前写的简单的”+”重载的程序，函数的形参都改为对象的引用，再运行。结果更奇怪了，除了上述程序，都没有报错。<br>这个程序又独特在哪里了？</p><h3 id="问题点"><a href="#问题点" class="headerlink" title="问题点"></a>问题点</h3><p>再返回去读一读程序，这个样例用到了转换构造函数。</p><pre><code>c3=c1+4.0;</code></pre><p>在保留注释掉以后程序果然可以正常运行了，问题确实出现在这里。既然是转换构造函数的问题，隐式调用（默认执行的）方式不可行，那我试一试显式的</p><pre><code>c3=c1+Complex(4.0);</code></pre><p>然而…报错依旧，只有微小的变化</p><pre><code>[Error] no match for &#39;operator+&#39; (operand types are &#39;Complex&#39; and &#39;Complex&#39;)</code></pre><p>对照之前的</p><pre><code>[Error] no match for &#39;operator+&#39; (operand types are &#39;Complex&#39; and &#39;double&#39;)</code></pre><p>原来最开始的程序并没有成功的调用转换构造函数。编译器没有检测到？<br>看来是哪里出了什么之前没考虑过的问题。</p><h3 id="思考"><a href="#思考" class="headerlink" title="思考"></a>思考</h3><p>（不摔桌！不摔桌！冷静！）如果通过引用进行参数传递，可以免去建立实参的拷贝，空间和时间上都可以得到优化，<br>逻辑推理一下，那这种传参的方式应该被推行啊，相近的例子就是流提取和流插入运算符的重载，第二个参数都是自定义类的引用。</p><p>那…为何”+”的重载不采用这种方式呢？看来是有问题的，结合之前的实验，在不出现转换构造函数调用的情况下，形参为引用是行得通的。<br>看来这个问题和转换构造函数也相关。</p><p>再回过头来看报错信息</p><pre><code>[Error] no match for &#39;operator+&#39; (operand types are &#39;Complex&#39; and &#39;Complex&#39;)[Note] candidates are:[Note] Complex operator+(Complex&amp;, Complex&amp;)[Note] no known conversion for argument 2 from &#39;Complex&#39; to &#39;Complex&amp;&#39;</code></pre><p>最后一句：Complex到Complex&amp;转换出了问题，这个比较稀奇。从类对象到类对象的引用不应该是顺理成章的事情么，别名而已。Emm问题就在这个别名身上</p><h2 id="引用-lt-gt-别名"><a href="#引用-lt-gt-别名" class="headerlink" title="引用&lt;-&gt;别名"></a>引用&lt;-&gt;别名</h2><h3 id="转换构造函数出现的无名对象"><a href="#转换构造函数出现的无名对象" class="headerlink" title="转换构造函数出现的无名对象"></a>转换构造函数出现的无名对象</h3><p>转换构造函数是构造函数的重载，在使用转换构造函数的过程中，我们可以建立一个有名对象，也可以建立一个无名对象。<br>书上中的代码样例</p><pre><code>Complex c1(3.5); //调用转换构造函数建立对象c1Complex(3.6); //调用转换构造函数建立无名对象，合法，但无法使用。</code></pre><p>就是这个无名对象的锅，我们回过头来看最开始发现的问题点：</p><pre><code>c3=c1+Complex(4.0);</code></pre><p>由于Complex(4.0)建立的是一个无名对象，而采用我错误写出的以引用作为形参的 “+”运算符重载，会发生什么？没有名字，自然无法引用啊。<br>这也就解释了报错信息为什么Complex到Complex&amp;转换出了问题。无名的对象无法建立引用（没名字你怎么给它找个别名）。</p><h1 id="事后诸葛亮"><a href="#事后诸葛亮" class="headerlink" title="事后诸葛亮"></a>事后诸葛亮</h1><p>根据简单的实验其实能得到一些结论</p><ul><li>涉及转换构造函数的运算符重载，形参都应该是类对象而不是类对象的引用。</li><li>C++自己实现的”=”应该也是用类对象作形参，因为 c1=Complex(3.6);  这一句是可以正常执行的。</li></ul><p>算作对引用以及构造函数的一个探索吧:)</p>]]></content>
    
    
    <categories>
      
      <category>Computer Science</category>
      
      <category>C++</category>
      
    </categories>
    
    
    <tags>
      
      <tag>C++</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>【CSU-1895】解题报告（数学，矩阵快速幂）</title>
    <link href="/post/7d8e4f2a.html"/>
    <url>/post/7d8e4f2a.html</url>
    
    <content type="html"><![CDATA[<h1 id="原始题目"><a href="#原始题目" class="headerlink" title="原始题目"></a>原始题目</h1><h2 id="1895-Apache-is-late-again"><a href="#1895-Apache-is-late-again" class="headerlink" title="1895: Apache is late again"></a>1895: Apache is late again</h2><ul><li>Time Limit: 1 Sec</li><li>Memory Limit: 128 Mb</li><li>Submitted: 141</li><li>Solved: 45<a id="more"></a></li></ul><h3 id="Description"><a href="#Description" class="headerlink" title="Description"></a>Description</h3><p>Apache is a student of CSU. There is a math class every Sunday morning, but he is a very hard man who learns late every night. Unfortunate, he was late for maths on Monday. Last week the math teacher gave a question to let him answer as a punishment, but he was easily resolved. So the math teacher prepared a problem for him to solve. Although Apache is very smart, but also was stumped. So he wants to ask you to solve the problem. Questions are as follows: You can find a m made (1 + sqrt (2)) ^ n can be decomposed into sqrt (m) + sqrt (m-1), if you can output $m% 100000007$ otherwise output No.</p><h3 id="Input"><a href="#Input" class="headerlink" title="Input"></a>Input</h3><p>There are multiply cases. Each case is a line of $n (|n| \le 10 ^ {18})$</p><h3 id="Output"><a href="#Output" class="headerlink" title="Output"></a>Output</h3><p>Line, if there is no such m output No, otherwise output m% 100,000,007.</p><h3 id="Sample-Input"><a href="#Sample-Input" class="headerlink" title="Sample Input"></a>Sample Input</h3><pre><code>2</code></pre><h3 id="Sample-Output"><a href="#Sample-Output" class="headerlink" title="Sample Output"></a>Sample Output</h3><pre><code>9</code></pre><h3 id="Hint"><a href="#Hint" class="headerlink" title="Hint"></a>Hint</h3><h3 id="Source"><a href="#Source" class="headerlink" title="Source"></a>Source</h3><p>中南大学第十一届大学生程序设计竞赛</p><h1 id="题目大意"><a href="#题目大意" class="headerlink" title="题目大意"></a>题目大意</h1><p>给定 n，若${1 + \sqrt {2}} ^ n$，能表示成$\sqrt {m} + \sqrt {m-1}$，则输出 m，否则输出 No</p><h1 id="解题思路"><a href="#解题思路" class="headerlink" title="解题思路"></a>解题思路</h1><p>当$n&gt;0$时,试着写出前几项</p><p>$(1+\sqrt{2})^1=\sqrt{2}+\sqrt{1}=\sqrt{1^2+1}+\sqrt{1^2}$</p><p>$(1+\sqrt{2})^2=\sqrt{9}+\sqrt{8}=\sqrt{3^2}+\sqrt{3^2-1}$</p><p>$(1+\sqrt{2})^3=\sqrt{50}+\sqrt{49}=\sqrt{7^2+1}+\sqrt{7^2}$</p><p>$(1+\sqrt{2})^4=\sqrt{289}+\sqrt{288}=\sqrt{17^2}+\sqrt{17^2-1}$</p><p>若只观察含有$\sqrt{2}$的项，我们能得到下面的数列</p><script type="math/tex; mode=display">a_1=1,a_2=2,a_3=5,a_4=12,\cdots</script><p>可以看作是一个二阶差分方程，其通项的矩阵表达</p><script type="math/tex; mode=display">a_n \\a_{n-1} \\\end{bmatrix}=\begin{bmatrix} 2&1 \\1&0\end{bmatrix}\begin{bmatrix} a_{n-1}\\ a_{n-2}\end{bmatrix}={\begin{bmatrix} 2&1\\ 1&0\end{bmatrix} }^{n-2}\begin{bmatrix}a_2\\ a_1 \end{bmatrix}</script><p>给定$a_1=1$，$a_2=2$，通过矩阵快速幂计算$a_n$</p><h1 id="解题代码"><a href="#解题代码" class="headerlink" title="解题代码"></a>解题代码</h1><pre><code class="hljs C++"><span class="hljs-meta">#<span class="hljs-meta-keyword">include</span> <span class="hljs-meta-string">&lt;cstdio&gt;</span></span><span class="hljs-meta">#<span class="hljs-meta-keyword">include</span> <span class="hljs-meta-string">&lt;cstring&gt;</span></span><span class="hljs-meta">#<span class="hljs-meta-keyword">include</span> <span class="hljs-meta-string">&lt;iostream&gt;</span></span><span class="hljs-meta">#<span class="hljs-meta-keyword">include</span> <span class="hljs-meta-string">&lt;set&gt;</span></span><span class="hljs-meta">#<span class="hljs-meta-keyword">include</span> <span class="hljs-meta-string">&lt;queue&gt;</span></span><span class="hljs-meta">#<span class="hljs-meta-keyword">define</span> mod 100000007  <span class="hljs-comment">//这里定义模</span></span><span class="hljs-keyword">using</span> <span class="hljs-keyword">namespace</span> <span class="hljs-built_in">std</span>;<span class="hljs-keyword">const</span> <span class="hljs-keyword">int</span> maxn=<span class="hljs-number">1e5</span>+<span class="hljs-number">5</span>;<span class="hljs-keyword">typedef</span> <span class="hljs-keyword">long</span> <span class="hljs-keyword">long</span> ll;<span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">Matrix</span>&#123;</span>ll a[<span class="hljs-number">2</span>][<span class="hljs-number">2</span>];Matrix()&#123;<span class="hljs-built_in">memset</span>(a,<span class="hljs-number">0</span>,<span class="hljs-keyword">sizeof</span>(a));&#125;Matrix <span class="hljs-keyword">operator</span> * (<span class="hljs-keyword">const</span> Matrix y)&#123;        Matrix ans;        <span class="hljs-keyword">for</span>(<span class="hljs-keyword">int</span> i = <span class="hljs-number">0</span>; i &lt; <span class="hljs-number">2</span>; i++)            <span class="hljs-keyword">for</span>(<span class="hljs-keyword">int</span> j = <span class="hljs-number">0</span>; j &lt; <span class="hljs-number">2</span>; j++)                <span class="hljs-keyword">for</span>(<span class="hljs-keyword">int</span> k = <span class="hljs-number">0</span>; k &lt; <span class="hljs-number">2</span>; k++)                    ans.a[i][j] += (a[i][k]*y.a[k][j])%mod;        <span class="hljs-keyword">return</span> ans;    &#125;Matrix <span class="hljs-keyword">operator</span> = (<span class="hljs-keyword">const</span> Matrix y)&#123;<span class="hljs-keyword">for</span>(<span class="hljs-keyword">int</span> i=<span class="hljs-number">0</span>;i&lt;<span class="hljs-number">2</span>;i++)<span class="hljs-keyword">for</span>(<span class="hljs-keyword">int</span> j=<span class="hljs-number">0</span>;j&lt;<span class="hljs-number">2</span>;j++)a[i][j]=y.a[i][j];&#125;Matrix <span class="hljs-keyword">operator</span> *= (<span class="hljs-keyword">const</span> Matrix y)&#123;Matrix ans;<span class="hljs-keyword">for</span>(<span class="hljs-keyword">int</span> i=<span class="hljs-number">0</span>;i&lt;<span class="hljs-number">2</span>;i++)<span class="hljs-keyword">for</span>(<span class="hljs-keyword">int</span> j=<span class="hljs-number">0</span>;j&lt;<span class="hljs-number">2</span>;j++)<span class="hljs-keyword">for</span>(<span class="hljs-keyword">int</span> k=<span class="hljs-number">0</span>;k&lt;<span class="hljs-number">2</span>;k++)ans.a[i][j] += (a[i][k]*y.a[k][j])%mod;<span class="hljs-keyword">for</span>(<span class="hljs-keyword">int</span> i=<span class="hljs-number">0</span>;i&lt;<span class="hljs-number">2</span>;i++)<span class="hljs-keyword">for</span>(<span class="hljs-keyword">int</span> j=<span class="hljs-number">0</span>;j&lt;<span class="hljs-number">2</span>;j++)a[i][j]=ans.a[i][j];&#125;&#125;;<span class="hljs-function">Matrix <span class="hljs-title">qpow</span><span class="hljs-params">(ll x)</span></span>&#123;Matrix ans;ans.a[<span class="hljs-number">0</span>][<span class="hljs-number">0</span>]=ans.a[<span class="hljs-number">1</span>][<span class="hljs-number">1</span>]=<span class="hljs-number">1</span>; <span class="hljs-comment">//单位矩阵</span>Matrix mul;mul.a[<span class="hljs-number">0</span>][<span class="hljs-number">0</span>]=<span class="hljs-number">2</span>;mul.a[<span class="hljs-number">0</span>][<span class="hljs-number">1</span>]=mul.a[<span class="hljs-number">1</span>][<span class="hljs-number">0</span>]=<span class="hljs-number">1</span>;<span class="hljs-keyword">while</span>(x)&#123;<span class="hljs-keyword">if</span>(x&amp;<span class="hljs-number">1</span>)ans *= mul;mul *= mul;x&gt;&gt;=<span class="hljs-number">1</span>;&#125;<span class="hljs-keyword">return</span> ans;&#125;<span class="hljs-function">ll <span class="hljs-title">pow</span><span class="hljs-params">(ll a,ll b)</span></span>&#123;ll ans=<span class="hljs-number">1</span>;<span class="hljs-keyword">while</span>(b)&#123;<span class="hljs-keyword">if</span>(b&amp;<span class="hljs-number">1</span>)ans=(ans*a%mod);a=a*a%mod;b&gt;&gt;=<span class="hljs-number">1</span>;&#125;<span class="hljs-keyword">return</span> ans;&#125;ll n;<span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span>&#123;<span class="hljs-keyword">while</span>(~<span class="hljs-built_in">scanf</span>(<span class="hljs-string">"%lld"</span>,&amp;n))&#123;<span class="hljs-keyword">if</span>(n&lt;<span class="hljs-number">0</span>) <span class="hljs-built_in">printf</span>(<span class="hljs-string">"No\n"</span>);<span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span>(n==<span class="hljs-number">0</span>) <span class="hljs-built_in">printf</span>(<span class="hljs-string">"1\n"</span>);<span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span>(n==<span class="hljs-number">1</span>) <span class="hljs-built_in">printf</span>(<span class="hljs-string">"2\n"</span>);<span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span>(n==<span class="hljs-number">2</span>) <span class="hljs-built_in">printf</span>(<span class="hljs-string">"9\n"</span>);<span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span>(n==<span class="hljs-number">3</span>) <span class="hljs-built_in">printf</span>(<span class="hljs-string">"50\n"</span>);<span class="hljs-keyword">else</span>&#123;Matrix m=qpow(n<span class="hljs-number">-2</span>);ll ans=(m.a[<span class="hljs-number">0</span>][<span class="hljs-number">0</span>]*<span class="hljs-number">2</span>%mod+m.a[<span class="hljs-number">0</span>][<span class="hljs-number">1</span>]%mod)%mod;<span class="hljs-keyword">if</span>(n&amp;<span class="hljs-number">1</span>) <span class="hljs-built_in">printf</span>(<span class="hljs-string">"%lld\n"</span>,ans*ans*<span class="hljs-number">2</span>%mod);<span class="hljs-keyword">else</span> <span class="hljs-built_in">printf</span>(<span class="hljs-string">"%lld\n"</span>,(ans*ans%mod*<span class="hljs-number">2</span>+<span class="hljs-number">1</span>)%mod);&#125;&#125;&#125;</code></pre><h1 id="收获与反思"><a href="#收获与反思" class="headerlink" title="收获与反思"></a>收获与反思</h1><ul><li>矩阵快速幂练习</li><li>注意n&lt;0时候输出No，因为这个T了好几次。<br>$$</li></ul>]]></content>
    
    
    <categories>
      
      <category>Computer Science</category>
      
      <category>ACM</category>
      
      <category>CSU</category>
      
    </categories>
    
    
    <tags>
      
      <tag>ACM</tag>
      
      <tag>CSU</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>【CSU-2138】解题报告（数学，矩阵快速幂）</title>
    <link href="/post/b0d6c7.html"/>
    <url>/post/b0d6c7.html</url>
    
    <content type="html"><![CDATA[<h1 id="原始题目"><a href="#原始题目" class="headerlink" title="原始题目"></a>原始题目</h1><h2 id="2138-Rikka’s-Set"><a href="#2138-Rikka’s-Set" class="headerlink" title="2138: Rikka’s Set"></a>2138: Rikka’s Set</h2><ul><li>Time Limit: 1 Sec     </li><li>Memory Limit: 128 Mb     </li><li>Submitted: 44     </li><li>Solved: 11    </li></ul><h3 id="Description"><a href="#Description" class="headerlink" title="Description"></a>Description</h3><p>Rikka is poor at math. Now she asks you for help.<br><a id="more"></a></p><p>A set is known as extraordinary set when the minimum integer of it is equal to its size.<br>min{x : x ∈ S}=|S|<br>For example, S = {3, 7, 8} is extraordinary.</p><p>gn is the number of extraodinary subsets of {1, 2, …, n}.</p><p>Rikka wants to know the value of gn.</p><h3 id="Input"><a href="#Input" class="headerlink" title="Input"></a>Input</h3><p>Input consists of one integer n(1 ≤ n ≤ 1018)</p><h3 id="Output"><a href="#Output" class="headerlink" title="Output"></a>Output</h3><p>Output a single integer gnmod1000000009</p><h3 id="Sample-Input"><a href="#Sample-Input" class="headerlink" title="Sample Input"></a>Sample Input</h3><pre><code>16</code></pre><h3 id="Sample-Output"><a href="#Sample-Output" class="headerlink" title="Sample Output"></a>Sample Output</h3><pre><code>987</code></pre><h3 id="Hint"><a href="#Hint" class="headerlink" title="Hint"></a>Hint</h3><h3 id="Source"><a href="#Source" class="headerlink" title="Source"></a>Source</h3><h3 id="Author"><a href="#Author" class="headerlink" title="Author"></a>Author</h3><p>xm</p><h1 id="题目大意"><a href="#题目大意" class="headerlink" title="题目大意"></a>题目大意</h1><p>给定一个{1,2,3……n}的集合，问有多少个集合中元素个数等于集合中元素最小值的子集。</p><h1 id="解题思路"><a href="#解题思路" class="headerlink" title="解题思路"></a>解题思路</h1><ul><li><p>对于给定的n，</p><ul><li>n=1，易知为1</li><li>n=2，易知为1</li><li>n&gt;=3，我们很容易根据题目想到答案的表达式<br>Mathjax显示不出来好吧。。。就是 C(n-i,i-1) i从2到n的求和+1。</li></ul></li><li><p>列出前几项，我们发现实际为斐波那契数列（等价证明还没想明白）</p></li><li>运用矩阵快速幂可得到答案。</li></ul><h1 id="解题代码"><a href="#解题代码" class="headerlink" title="解题代码"></a>解题代码</h1><pre><code class="hljs C++"><span class="hljs-meta">#<span class="hljs-meta-keyword">include</span> <span class="hljs-meta-string">&lt;cstdio&gt;</span></span><span class="hljs-meta">#<span class="hljs-meta-keyword">include</span> <span class="hljs-meta-string">&lt;cstring&gt;</span></span><span class="hljs-meta">#<span class="hljs-meta-keyword">include</span> <span class="hljs-meta-string">&lt;iostream&gt;</span></span><span class="hljs-meta">#<span class="hljs-meta-keyword">include</span> <span class="hljs-meta-string">&lt;set&gt;</span></span><span class="hljs-meta">#<span class="hljs-meta-keyword">include</span> <span class="hljs-meta-string">&lt;queue&gt;</span></span><span class="hljs-meta">#<span class="hljs-meta-keyword">define</span> mod 1000000009  <span class="hljs-comment">//这里定义模 </span></span><span class="hljs-keyword">using</span> <span class="hljs-keyword">namespace</span> <span class="hljs-built_in">std</span>;<span class="hljs-keyword">const</span> <span class="hljs-keyword">int</span> maxn=<span class="hljs-number">1e5</span>+<span class="hljs-number">5</span>;<span class="hljs-keyword">typedef</span> <span class="hljs-keyword">long</span> <span class="hljs-keyword">long</span> ll;<span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">Matrix</span>&#123;</span>ll a[<span class="hljs-number">2</span>][<span class="hljs-number">2</span>];Matrix()&#123;<span class="hljs-built_in">memset</span>(a,<span class="hljs-number">0</span>,<span class="hljs-keyword">sizeof</span>(a));&#125;Matrix <span class="hljs-keyword">operator</span> * (<span class="hljs-keyword">const</span> Matrix y) &#123;          Matrix ans;          <span class="hljs-keyword">for</span>(<span class="hljs-keyword">int</span> i = <span class="hljs-number">0</span>; i &lt; <span class="hljs-number">2</span>; i++)              <span class="hljs-keyword">for</span>(<span class="hljs-keyword">int</span> j = <span class="hljs-number">0</span>; j &lt; <span class="hljs-number">2</span>; j++)                    <span class="hljs-keyword">for</span>(<span class="hljs-keyword">int</span> k = <span class="hljs-number">0</span>; k &lt; <span class="hljs-number">2</span>; k++)                        ans.a[i][j] += (a[i][k]*y.a[k][j])%mod;            <span class="hljs-keyword">return</span> ans;      &#125;Matrix <span class="hljs-keyword">operator</span> = (<span class="hljs-keyword">const</span> Matrix y)&#123;<span class="hljs-keyword">for</span>(<span class="hljs-keyword">int</span> i=<span class="hljs-number">0</span>;i&lt;<span class="hljs-number">2</span>;i++)<span class="hljs-keyword">for</span>(<span class="hljs-keyword">int</span> j=<span class="hljs-number">0</span>;j&lt;<span class="hljs-number">2</span>;j++)a[i][j]=y.a[i][j];&#125;Matrix <span class="hljs-keyword">operator</span> *= (<span class="hljs-keyword">const</span> Matrix y)&#123;Matrix ans;<span class="hljs-keyword">for</span>(<span class="hljs-keyword">int</span> i=<span class="hljs-number">0</span>;i&lt;<span class="hljs-number">2</span>;i++)<span class="hljs-keyword">for</span>(<span class="hljs-keyword">int</span> j=<span class="hljs-number">0</span>;j&lt;<span class="hljs-number">2</span>;j++)<span class="hljs-keyword">for</span>(<span class="hljs-keyword">int</span> k=<span class="hljs-number">0</span>;k&lt;<span class="hljs-number">2</span>;k++)ans.a[i][j] += (a[i][k]*y.a[k][j])%mod;<span class="hljs-keyword">for</span>(<span class="hljs-keyword">int</span> i=<span class="hljs-number">0</span>;i&lt;<span class="hljs-number">2</span>;i++)<span class="hljs-keyword">for</span>(<span class="hljs-keyword">int</span> j=<span class="hljs-number">0</span>;j&lt;<span class="hljs-number">2</span>;j++)a[i][j]=ans.a[i][j];&#125;&#125;; <span class="hljs-function">Matrix <span class="hljs-title">qpow</span><span class="hljs-params">(ll x)</span></span>&#123;Matrix ans;ans.a[<span class="hljs-number">0</span>][<span class="hljs-number">0</span>]=ans.a[<span class="hljs-number">1</span>][<span class="hljs-number">1</span>]=<span class="hljs-number">1</span>; <span class="hljs-comment">//单位矩阵 </span>Matrix mul;mul.a[<span class="hljs-number">0</span>][<span class="hljs-number">0</span>]=mul.a[<span class="hljs-number">0</span>][<span class="hljs-number">1</span>]=mul.a[<span class="hljs-number">1</span>][<span class="hljs-number">0</span>]=<span class="hljs-number">1</span>;<span class="hljs-keyword">while</span>(x)&#123;<span class="hljs-keyword">if</span>(x&amp;<span class="hljs-number">1</span>)ans *= mul;mul*=mul;x&gt;&gt;=<span class="hljs-number">1</span>; &#125; <span class="hljs-keyword">return</span> ans;&#125;<span class="hljs-function">ll <span class="hljs-title">pow</span><span class="hljs-params">(ll a,ll b)</span></span>&#123;ll ans=<span class="hljs-number">1</span>;<span class="hljs-keyword">while</span>(b)&#123;<span class="hljs-keyword">if</span>(b&amp;<span class="hljs-number">1</span>)ans=(ans*a%mod);a=a*a%mod;b&gt;&gt;=<span class="hljs-number">1</span>;&#125;<span class="hljs-keyword">return</span> ans;&#125;ll n;<span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span>&#123;<span class="hljs-keyword">while</span>(~<span class="hljs-built_in">scanf</span>(<span class="hljs-string">"%lld"</span>,&amp;n))&#123;<span class="hljs-keyword">if</span>(n==<span class="hljs-number">1</span>)<span class="hljs-built_in">printf</span>(<span class="hljs-string">"1\n"</span>);<span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span>(n==<span class="hljs-number">2</span>) <span class="hljs-built_in">printf</span>(<span class="hljs-string">"1\n"</span>);<span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span>(n==<span class="hljs-number">3</span>) <span class="hljs-built_in">printf</span>(<span class="hljs-string">"2\n"</span>);<span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span>(n==<span class="hljs-number">4</span>) <span class="hljs-built_in">printf</span>(<span class="hljs-string">"3\n"</span>);<span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span>(n==<span class="hljs-number">5</span>) <span class="hljs-built_in">printf</span>(<span class="hljs-string">"5\n"</span>);<span class="hljs-keyword">else</span>&#123;Matrix m=qpow(n<span class="hljs-number">-2</span>);<span class="hljs-built_in">printf</span>(<span class="hljs-string">"%lld\n"</span>,(m.a[<span class="hljs-number">0</span>][<span class="hljs-number">0</span>]+m.a[<span class="hljs-number">0</span>][<span class="hljs-number">1</span>])%mod); &#125; &#125;&#125;</code></pre><h1 id="收获与反思"><a href="#收获与反思" class="headerlink" title="收获与反思"></a>收获与反思</h1><ul><li>多尝试一下前几项，发现规律</li><li>矩阵快速幂练习</li></ul>]]></content>
    
    
    <categories>
      
      <category>Computer Science</category>
      
      <category>ACM</category>
      
      <category>CSU</category>
      
    </categories>
    
    
    <tags>
      
      <tag>ACM</tag>
      
      <tag>CSU</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>【AtCoder-4152】解题报告（数学，进制，贪心）</title>
    <link href="/post/918fcaa1.html"/>
    <url>/post/918fcaa1.html</url>
    
    <content type="html"><![CDATA[<h1 id="原始题目"><a href="#原始题目" class="headerlink" title="原始题目"></a>原始题目</h1><h2 id="C-Strange-Bank"><a href="#C-Strange-Bank" class="headerlink" title="C - Strange Bank"></a>C - Strange Bank</h2><ul><li>Time limit : 2sec </li><li>Memory limit : 256MB</li><li>Score : 300 points</li></ul><h3 id="Problem-Statement"><a href="#Problem-Statement" class="headerlink" title="Problem Statement"></a>Problem Statement</h3><p>To make it difficult to withdraw money, a certain bank allows its customers to withdraw only one of the following amounts in one operation:</p><a id="more"></a><p>1 yen (the currency of Japan)</p><p>6 yen, 62(=36) yen, 63(=216) yen, …</p><p>9 yen, 92(=81) yen, 93(=729) yen, …</p><p>At least how many operations are required to withdraw exactly N yen in total?</p><p>It is not allowed to re-deposit the money you withdrew.</p><h3 id="Constraints"><a href="#Constraints" class="headerlink" title="Constraints"></a>Constraints</h3><p>1≤N≤100000<br>N is an integer.</p><h3 id="Input"><a href="#Input" class="headerlink" title="Input"></a>Input</h3><p>Input is given from Standard Input in the following format:</p><p>N</p><h3 id="Output"><a href="#Output" class="headerlink" title="Output"></a>Output</h3><p>If at least x operations are required to withdraw exactly N yen in total, print x.</p><h4 id="Sample-Input-1"><a href="#Sample-Input-1" class="headerlink" title="Sample Input 1"></a>Sample Input 1</h4><pre><code>127</code></pre><h4 id="Sample-Output-1"><a href="#Sample-Output-1" class="headerlink" title="Sample Output 1"></a>Sample Output 1</h4><pre><code>4</code></pre><ul><li>By withdrawing 1 yen, 9 yen, 36(=62) yen and 81(=92) yen, we can withdraw 127 yen in four operations.</li></ul><h4 id="Sample-Input-2"><a href="#Sample-Input-2" class="headerlink" title="Sample Input 2"></a>Sample Input 2</h4><pre><code>3</code></pre><h4 id="Sample-Output-2"><a href="#Sample-Output-2" class="headerlink" title="Sample Output 2"></a>Sample Output 2</h4><pre><code>3</code></pre><ul><li>By withdrawing 1 yen three times, we can withdraw 3 yen in three operations.</li></ul><h4 id="Sample-Input-3"><a href="#Sample-Input-3" class="headerlink" title="Sample Input 3"></a>Sample Input 3</h4><pre><code>44852</code></pre><h4 id="Sample-Output-3"><a href="#Sample-Output-3" class="headerlink" title="Sample Output 3"></a>Sample Output 3</h4><pre><code>16</code></pre><h1 id="题目大意"><a href="#题目大意" class="headerlink" title="题目大意"></a>题目大意</h1><p>规定三种取钱的方法，一次可以取1元，6^k元或者9^k元  （k&gt;=1） ，问取n元最少的次数是多少。</p><h1 id="解题思路"><a href="#解题思路" class="headerlink" title="解题思路"></a>解题思路</h1><p>将n拆成i和n-i。分别用6和9进制表示，维护系数和最小值即可。</p><h1 id="解题代码"><a href="#解题代码" class="headerlink" title="解题代码"></a>解题代码</h1><pre><code class="hljs C++"><span class="hljs-meta">#<span class="hljs-meta-keyword">include</span> <span class="hljs-meta-string">&lt;cstdio&gt;</span></span><span class="hljs-meta">#<span class="hljs-meta-keyword">include</span> <span class="hljs-meta-string">&lt;iostream&gt; </span></span><span class="hljs-keyword">using</span> <span class="hljs-keyword">namespace</span> <span class="hljs-built_in">std</span>;<span class="hljs-keyword">int</span> n;<span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span>&#123;<span class="hljs-keyword">while</span>(~<span class="hljs-built_in">scanf</span>(<span class="hljs-string">"%d"</span> ,&amp;n))&#123;<span class="hljs-keyword">int</span> res=n; <span class="hljs-comment">//最大情况肯定为n次  全部每次取1元 </span><span class="hljs-keyword">for</span>(<span class="hljs-keyword">int</span> i=<span class="hljs-number">0</span>;i&lt;=n;i++)&#123;<span class="hljs-keyword">int</span> cc=<span class="hljs-number">0</span>;<span class="hljs-keyword">int</span> t=i;<span class="hljs-keyword">while</span>(t) cc+=t%<span class="hljs-number">6</span>,t/=<span class="hljs-number">6</span>;  <span class="hljs-comment">//计算6进制的系数和 </span>t=n-i;<span class="hljs-keyword">while</span>(t) cc+=t%<span class="hljs-number">9</span>,t/=<span class="hljs-number">9</span>;  <span class="hljs-comment">//计算9进制的系数和 </span><span class="hljs-keyword">if</span>(res&gt;cc) res=cc; &#125;<span class="hljs-built_in">printf</span>(<span class="hljs-string">"%d\n"</span>,res);&#125;&#125;</code></pre><h1 id="收获与反思"><a href="#收获与反思" class="headerlink" title="收获与反思"></a>收获与反思</h1><ul><li>理解题意，三种方法算最小值其实就是求一个数用6/9进制混合表达的系数最小值。</li><li>把n拆成两部分，维护系数最小值。</li></ul><pre><code>while(t) cc+=t%k,t/=k;  </code></pre><ul><li>该方法得到的cc为t用k进制表达的系数和。</li></ul>]]></content>
    
    
    <categories>
      
      <category>Computer Science</category>
      
      <category>ACM</category>
      
      <category>AtCoder</category>
      
    </categories>
    
    
    <tags>
      
      <tag>ACM</tag>
      
      <tag>AtCoder</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>【CodeForces-978F】解题报告（二分，排序，数据结构）</title>
    <link href="/post/32dc51f4.html"/>
    <url>/post/32dc51f4.html</url>
    
    <content type="html"><![CDATA[<h1 id="原始题目"><a href="#原始题目" class="headerlink" title="原始题目"></a>原始题目</h1><h2 id="Mentors"><a href="#Mentors" class="headerlink" title="Mentors"></a>Mentors</h2><ul><li>time limit per test3 seconds</li><li>memory limit per test256 megabytes</li><li>inputstandard input</li><li>outputstandard output</li></ul><p>In BerSoft n programmers work, the programmer i is characterized by a skill ri.<br><a id="more"></a></p><p>A programmer a can be a mentor of a programmer b if and only if the skill of the programmer a is strictly greater than the skill of the programmer b (ra&gt;rb) and programmers a and b are not in a quarrel.</p><p>You are given the skills of each programmers and a list of k pairs of the programmers, which are in a quarrel (pairs are unordered). For each programmer i, find the number of programmers, for which the programmer i can be a mentor.</p><h3 id="Input"><a href="#Input" class="headerlink" title="Input"></a>Input</h3><p>The first line contains two integers n and k (2≤n≤2⋅105, 0≤k≤min(2⋅105,n⋅(n−1)2)) — total number of programmers and number of pairs of programmers which are in a quarrel.</p><p>The second line contains a sequence of integers r1,r2,…,rn (1≤ri≤109), where ri equals to the skill of the i-th programmer.</p><p>Each of the following k lines contains two distinct integers x, y (1≤x,y≤n, x≠y) — pair of programmers in a quarrel. The pairs are unordered, it means that if x is in a quarrel with y then y is in a quarrel with x. Guaranteed, that for each pair (x,y) there are no other pairs (x,y) and (y,x) in the input.</p><h3 id="Output"><a href="#Output" class="headerlink" title="Output"></a>Output</h3><p>Print n integers, the i-th number should be equal to the number of programmers, for which the i-th programmer can be a mentor. Programmers are numbered in the same order that their skills are given in the input.</p><h3 id="Examples"><a href="#Examples" class="headerlink" title="Examples"></a>Examples</h3><h4 id="Input-1"><a href="#Input-1" class="headerlink" title="Input"></a>Input</h4><pre><code>4 210 4 10 151 24 3</code></pre><h4 id="Output-1"><a href="#Output-1" class="headerlink" title="Output"></a>Output</h4><pre><code>0 0 1 2 </code></pre><h4 id="Input-2"><a href="#Input-2" class="headerlink" title="Input"></a>Input</h4><pre><code>10 45 4 1 5 4 3 7 1 2 54 62 110 83 5</code></pre><h4 id="Output-2"><a href="#Output-2" class="headerlink" title="Output"></a>Output</h4><pre><code>5 4 0 5 3 3 9 0 2 5 </code></pre><h3 id="Note"><a href="#Note" class="headerlink" title="Note"></a>Note</h3><p>In the first example, the first programmer can not be mentor of any other (because only the second programmer has a skill, lower than first programmer skill, but they are in a quarrel). The second programmer can not be mentor of any other programmer, because his skill is minimal among others. The third programmer can be a mentor of the second programmer. The fourth programmer can be a mentor of the first and of the second programmers. He can not be a mentor of the third programmer, because they are in a quarrel.</p><h1 id="题目大意"><a href="#题目大意" class="headerlink" title="题目大意"></a>题目大意</h1><p>给定n个人员skill值，并给出k个有矛盾的对，对于每个人，可以做skill值比自己小且没有矛盾人的导师。输出每一个人可做多少人的导师。</p><h1 id="解题思路"><a href="#解题思路" class="headerlink" title="解题思路"></a>解题思路</h1><ul><li>排序后对每个人的skill值二分查找，存储到ans[]中。</li><li>对于每个矛盾对，skill值大的ans减1即可。</li></ul><h1 id="解题代码"><a href="#解题代码" class="headerlink" title="解题代码"></a>解题代码</h1><pre><code class="hljs C++"><span class="hljs-meta">#<span class="hljs-meta-keyword">include</span> <span class="hljs-meta-string">&lt;iostream&gt;</span></span><span class="hljs-meta">#<span class="hljs-meta-keyword">include</span> <span class="hljs-meta-string">&lt;cstdio&gt;</span></span><span class="hljs-meta">#<span class="hljs-meta-keyword">include</span> <span class="hljs-meta-string">&lt;iomanip&gt;</span></span><span class="hljs-meta">#<span class="hljs-meta-keyword">include</span> <span class="hljs-meta-string">&lt;cstring&gt;</span></span><span class="hljs-meta">#<span class="hljs-meta-keyword">include</span> <span class="hljs-meta-string">&lt;map&gt;</span></span><span class="hljs-meta">#<span class="hljs-meta-keyword">include</span> <span class="hljs-meta-string">&lt;set&gt;</span></span><span class="hljs-meta">#<span class="hljs-meta-keyword">include</span> <span class="hljs-meta-string">&lt;queue&gt;</span></span><span class="hljs-meta">#<span class="hljs-meta-keyword">include</span> <span class="hljs-meta-string">&lt;algorithm&gt;</span></span><span class="hljs-meta">#<span class="hljs-meta-keyword">define</span> eps 1e-8</span><span class="hljs-meta">#<span class="hljs-meta-keyword">define</span> INF 0x3f3f3f3f</span><span class="hljs-keyword">using</span> <span class="hljs-keyword">namespace</span> <span class="hljs-built_in">std</span>;<span class="hljs-keyword">typedef</span> <span class="hljs-keyword">long</span> <span class="hljs-keyword">long</span> ll;<span class="hljs-keyword">const</span> <span class="hljs-keyword">int</span> maxn=<span class="hljs-number">2e5</span>+<span class="hljs-number">5</span>;ll a[maxn],b[maxn];<span class="hljs-keyword">int</span> ans[maxn],n,t,k;<span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span>&#123;<span class="hljs-keyword">while</span>(~<span class="hljs-built_in">scanf</span>(<span class="hljs-string">"%d%d"</span>,&amp;n,&amp;k))&#123;<span class="hljs-keyword">for</span>(<span class="hljs-keyword">int</span> i=<span class="hljs-number">0</span>;i&lt;n;i++)&#123;<span class="hljs-built_in">scanf</span>(<span class="hljs-string">"%I64d"</span>,&amp;a[i]);b[i]=a[i];&#125;sort(b,b+n);<span class="hljs-keyword">for</span>(<span class="hljs-keyword">int</span> i=<span class="hljs-number">0</span>;i&lt;n;i++)&#123;ans[i]=lower_bound(b,b+n,a[i])-b;<span class="hljs-comment">//printf("--%d--\n",ans[i]);</span>&#125;<span class="hljs-keyword">for</span>(<span class="hljs-keyword">int</span> i=<span class="hljs-number">0</span>;i&lt;k;i++)&#123;<span class="hljs-keyword">int</span> temp1,temp2;<span class="hljs-built_in">scanf</span>(<span class="hljs-string">"%d%d"</span>,&amp;temp1,&amp;temp2);<span class="hljs-keyword">if</span>(a[temp1<span class="hljs-number">-1</span>]&gt;a[temp2<span class="hljs-number">-1</span>]) ans[temp1<span class="hljs-number">-1</span>]--;<span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span>(a[temp2<span class="hljs-number">-1</span>]&gt;a[temp1<span class="hljs-number">-1</span>]) ans[temp2<span class="hljs-number">-1</span>]--;&#125;<span class="hljs-keyword">for</span>(<span class="hljs-keyword">int</span> i=<span class="hljs-number">0</span>;i&lt;n;i++)&#123;<span class="hljs-keyword">if</span>(i==<span class="hljs-number">0</span>) <span class="hljs-built_in">printf</span>(<span class="hljs-string">"%d"</span>,ans[i]);<span class="hljs-keyword">else</span> <span class="hljs-built_in">printf</span>(<span class="hljs-string">" %d"</span>,ans[i]);&#125;<span class="hljs-built_in">printf</span>(<span class="hljs-string">"\n"</span>);&#125;&#125;</code></pre><h1 id="收获与反思"><a href="#收获与反思" class="headerlink" title="收获与反思"></a>收获与反思</h1><ul><li>二分查找 lower_bound的运用。</li><li>注意quarrel列的在线计算。</li></ul>]]></content>
    
    
    <categories>
      
      <category>Computer Science</category>
      
      <category>ACM</category>
      
      <category>CodeForces</category>
      
    </categories>
    
    
    <tags>
      
      <tag>ACM</tag>
      
      <tag>CodeForces</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>【CodeForces-978E】解题报告（暴力，数学）</title>
    <link href="/post/fcb9464d.html"/>
    <url>/post/fcb9464d.html</url>
    
    <content type="html"><![CDATA[<h1 id="原始题目"><a href="#原始题目" class="headerlink" title="原始题目"></a>原始题目</h1><h2 id="Bus-Video-System"><a href="#Bus-Video-System" class="headerlink" title="Bus Video System"></a>Bus Video System</h2><ul><li>time limit per test1 second</li><li>memory limit per test256 megabytes</li><li>inputstandard input</li><li>outputstandard output</li></ul><p>The busses in Berland are equipped with a video surveillance system. The system records information about changes in the number of passengers in a bus after stops.</p><a id="more"></a><p>If x is the number of passengers in a bus just before the current bus stop and y is the number of passengers in the bus just after current bus stop, the system records the number y−x. So the system records show how number of passengers changed.</p><p>The test run was made for single bus and n bus stops. Thus, the system recorded the sequence of integers a1,a2,…,an (exactly one number for each bus stop), where ai is the record for the bus stop i. The bus stops are numbered from 1 to n in chronological order.</p><p>Determine the number of possible ways how many people could be in the bus before the first bus stop, if the bus has a capacity equals to w (that is, at any time in the bus there should be from 0 to w passengers inclusive).</p><h3 id="Input"><a href="#Input" class="headerlink" title="Input"></a>Input</h3><p>The first line contains two integers n and w (1≤n≤1000,1≤w≤109) — the number of bus stops and the capacity of the bus.</p><p>The second line contains a sequence a1,a2,…,an (−106≤ai≤106), where ai equals to the number, which has been recorded by the video system after the i-th bus stop.</p><h3 id="Output"><a href="#Output" class="headerlink" title="Output"></a>Output</h3><p>Print the number of possible ways how many people could be in the bus before the first bus stop, if the bus has a capacity equals to w. If the situation is contradictory (i.e. for any initial number of passengers there will be a contradiction), print 0.</p><h3 id="Examples"><a href="#Examples" class="headerlink" title="Examples"></a>Examples</h3><h4 id="Input-1"><a href="#Input-1" class="headerlink" title="Input"></a>Input</h4><pre><code>3 52 1 -3</code></pre><h4 id="Output-1"><a href="#Output-1" class="headerlink" title="Output"></a>Output</h4><pre><code>3</code></pre><h4 id="Input-2"><a href="#Input-2" class="headerlink" title="Input"></a>Input</h4><pre><code>2 4-1 1</code></pre><h4 id="Output-2"><a href="#Output-2" class="headerlink" title="Output"></a>Output</h4><pre><code>4</code></pre><h4 id="Input-3"><a href="#Input-3" class="headerlink" title="Input"></a>Input</h4><pre><code>4 102 4 1 2</code></pre><h4 id="Output-3"><a href="#Output-3" class="headerlink" title="Output"></a>Output</h4><pre><code>2</code></pre><h3 id="Note"><a href="#Note" class="headerlink" title="Note"></a>Note</h3><p>In the first example initially in the bus could be 0, 1 or 2 passengers.</p><p>In the second example initially in the bus could be 1, 2, 3 or 4 passengers.</p><p>In the third example initially in the bus could be 0 or 1 passenger.</p><h1 id="题目大意"><a href="#题目大意" class="headerlink" title="题目大意"></a>题目大意</h1><p>给定公交车经历的站数和最大容载量，并给出在各个公交站上/下车的人数，求最初车上人数有几种可能。</p><h1 id="解题思路"><a href="#解题思路" class="headerlink" title="解题思路"></a>解题思路</h1><p>初始sum为0，上下车人数，记录最大值和最小值，计算最大差值，ans=m-(mmax-mmin)+1。</p><h1 id="解题代码"><a href="#解题代码" class="headerlink" title="解题代码"></a>解题代码</h1><pre><code class="hljs C++"><span class="hljs-meta">#<span class="hljs-meta-keyword">include</span> <span class="hljs-meta-string">&lt;cstdio&gt;</span></span><span class="hljs-meta">#<span class="hljs-meta-keyword">include</span> <span class="hljs-meta-string">&lt;cstring&gt;</span></span><span class="hljs-meta">#<span class="hljs-meta-keyword">include</span> <span class="hljs-meta-string">&lt;iostream&gt;</span></span><span class="hljs-meta">#<span class="hljs-meta-keyword">include</span> <span class="hljs-meta-string">&lt;set&gt;</span></span><span class="hljs-meta">#<span class="hljs-meta-keyword">include</span> <span class="hljs-meta-string">&lt;queue&gt;</span></span><span class="hljs-meta">#<span class="hljs-meta-keyword">include</span> <span class="hljs-meta-string">&lt;map&gt;</span></span><span class="hljs-meta">#<span class="hljs-meta-keyword">include</span> <span class="hljs-meta-string">&lt;vector&gt;</span></span><span class="hljs-meta">#<span class="hljs-meta-keyword">include</span> <span class="hljs-meta-string">&lt;algorithm&gt;</span></span><span class="hljs-meta">#<span class="hljs-meta-keyword">define</span> eps 1e-8</span><span class="hljs-meta">#<span class="hljs-meta-keyword">define</span> INF 0x3f3f3f3f</span><span class="hljs-keyword">using</span> <span class="hljs-keyword">namespace</span> <span class="hljs-built_in">std</span>;<span class="hljs-keyword">const</span> <span class="hljs-keyword">int</span> maxn=<span class="hljs-number">2e5</span>+<span class="hljs-number">5</span>;<span class="hljs-keyword">typedef</span> <span class="hljs-keyword">long</span> <span class="hljs-keyword">long</span> ll;ll b[maxn],d[maxn],n,m,t,sum,ans;<span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span>&#123;<span class="hljs-keyword">while</span>(~<span class="hljs-built_in">scanf</span>(<span class="hljs-string">"%I64d%I64d"</span>,&amp;n,&amp;m))&#123;sum=<span class="hljs-number">0</span>;ll mmax=<span class="hljs-number">0</span>,mmin=<span class="hljs-number">0</span>;<span class="hljs-keyword">for</span>(<span class="hljs-keyword">int</span> i=<span class="hljs-number">1</span>;i&lt;=n;i++)&#123;<span class="hljs-built_in">scanf</span>(<span class="hljs-string">"%I64d"</span>,&amp;b[i]);sum+=b[i];<span class="hljs-keyword">if</span>(sum&gt;mmax) mmax=sum;<span class="hljs-keyword">if</span>(sum&lt;mmin) mmin=sum;  &#125;<span class="hljs-comment">//printf("%I64d   %I64d\n",mmin,mmax);</span>ll ans=m-(mmax-mmin)+<span class="hljs-number">1</span>;<span class="hljs-keyword">if</span>(ans&lt;=<span class="hljs-number">0</span>) <span class="hljs-built_in">printf</span>(<span class="hljs-string">"0\n"</span>);<span class="hljs-keyword">else</span> <span class="hljs-built_in">printf</span>(<span class="hljs-string">"%I64d\n"</span>,ans);&#125;&#125;</code></pre><h1 id="收获与反思"><a href="#收获与反思" class="headerlink" title="收获与反思"></a>收获与反思</h1><ul><li>简单数学问题</li></ul>]]></content>
    
    
    <categories>
      
      <category>Computer Science</category>
      
      <category>ACM</category>
      
      <category>CodeForces</category>
      
    </categories>
    
    
    <tags>
      
      <tag>ACM</tag>
      
      <tag>CodeForces</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>【CodeForces-978D】解题报告（暴力，数学讨论）</title>
    <link href="/post/44505a5b.html"/>
    <url>/post/44505a5b.html</url>
    
    <content type="html"><![CDATA[<h1 id="原始题目"><a href="#原始题目" class="headerlink" title="原始题目"></a>原始题目</h1><h2 id="Almost-Arithmetic-Progression"><a href="#Almost-Arithmetic-Progression" class="headerlink" title="Almost Arithmetic Progression"></a>Almost Arithmetic Progression</h2><ul><li>time limit per test1 second</li><li>memory limit per test256 megabytes</li><li>inputstandard input</li><li>outputstandard output</li></ul><a id="more"></a><p>Polycarp likes arithmetic progressions. A sequence [a1,a2,…,an] is called an arithmetic progression if for each i (1≤i&lt;n) the value ai+1−ai is the same. For example, the sequences [42], [5,5,5], [2,11,20,29] and [3,2,1,0] are arithmetic progressions, but [1,0,1], [1,3,9] and [2,3,1] are not.</p><p>It follows from the definition that any sequence of length one or two is an arithmetic progression.</p><p>Polycarp found some sequence of positive integers [b1,b2,…,bn]. He agrees to change each element by at most one. In the other words, for each element there are exactly three options: an element can be decreased by 1, an element can be increased by 1, an element can be left unchanged.</p><p>Determine a minimum possible number of elements in b which can be changed (by exactly one), so that the sequence b becomes an arithmetic progression, or report that it is impossible.</p><p>It is possible that the resulting sequence contains element equals 0.</p><h3 id="Input"><a href="#Input" class="headerlink" title="Input"></a>Input</h3><p>The first line contains a single integer n (1≤n≤100000) — the number of elements in b.</p><p>The second line contains a sequence b1,b2,…,bn (1≤bi≤109).</p><h3 id="Output"><a href="#Output" class="headerlink" title="Output"></a>Output</h3><p>If it is impossible to make an arithmetic progression with described operations, print -1. In the other case, print non-negative integer — the minimum number of elements to change to make the given sequence becomes an arithmetic progression. The only allowed operation is to add/to subtract one from an element (can’t use operation twice to the same position).</p><h3 id="Examples"><a href="#Examples" class="headerlink" title="Examples"></a>Examples</h3><h4 id="Input-1"><a href="#Input-1" class="headerlink" title="Input"></a>Input</h4><pre><code>424 21 14 10</code></pre><h4 id="Output-1"><a href="#Output-1" class="headerlink" title="Output"></a>Output</h4><pre><code>3</code></pre><h4 id="Input-2"><a href="#Input-2" class="headerlink" title="Input"></a>Input</h4><pre><code>2500 500</code></pre><h4 id="Output-2"><a href="#Output-2" class="headerlink" title="Output"></a>Output</h4><pre><code>0</code></pre><h4 id="Input-3"><a href="#Input-3" class="headerlink" title="Input"></a>Input</h4><pre><code>314 5 1</code></pre><h4 id="Output-3"><a href="#Output-3" class="headerlink" title="Output"></a>Output</h4><pre><code>-1</code></pre><h4 id="Input-4"><a href="#Input-4" class="headerlink" title="Input"></a>Input</h4><pre><code>51 3 6 9 12</code></pre><h4 id="Output-4"><a href="#Output-4" class="headerlink" title="Output"></a>Output</h4><pre><code>1</code></pre><h3 id="Note"><a href="#Note" class="headerlink" title="Note"></a>Note</h3><p>In the first example Polycarp should increase the first number on 1, decrease the second number on 1, increase the third number on 1, and the fourth number should left unchanged. So, after Polycarp changed three elements by one, his sequence became equals to [25,20,15,10], which is an arithmetic progression.</p><p>In the second example Polycarp should not change anything, because his sequence is an arithmetic progression.</p><p>In the third example it is impossible to make an arithmetic progression.</p><p>In the fourth example Polycarp should change only the first element, he should decrease it on one. After that his sequence will looks like [0,3,6,9,12], which is an arithmetic progression.</p><h1 id="题目大意"><a href="#题目大意" class="headerlink" title="题目大意"></a>题目大意</h1><p>给定一组数，对每一个数可以不操作，或者+1，或者-1（加减记录改变次数），问这一组数是否可以通过操作变为等差数列</p><ul><li>若可以，输出所需改变次数的最小值。</li><li>若不可以，输出-1. </li></ul><h1 id="解题思路"><a href="#解题思路" class="headerlink" title="解题思路"></a>解题思路</h1><p>对每种可能的gap遍历数据，更新需要更改的次数的最小值。<br>gap由前两项a[0],a[1]确定，共有9种可能。确定gap后开始从a[2]开始遍历数组，一旦出现不符合则跳出，全部符合则更新最小操作数。</p><h1 id="解题代码"><a href="#解题代码" class="headerlink" title="解题代码"></a>解题代码</h1><pre><code class="hljs C++"><span class="hljs-meta">#<span class="hljs-meta-keyword">include</span> <span class="hljs-meta-string">&lt;cstdio&gt;</span></span><span class="hljs-meta">#<span class="hljs-meta-keyword">include</span> <span class="hljs-meta-string">&lt;cmath&gt;</span></span><span class="hljs-meta">#<span class="hljs-meta-keyword">include</span> <span class="hljs-meta-string">&lt;cstring&gt;</span></span><span class="hljs-meta">#<span class="hljs-meta-keyword">include</span> <span class="hljs-meta-string">&lt;iostream&gt;</span></span><span class="hljs-meta">#<span class="hljs-meta-keyword">include</span> <span class="hljs-meta-string">&lt;set&gt;</span></span><span class="hljs-meta">#<span class="hljs-meta-keyword">include</span> <span class="hljs-meta-string">&lt;string&gt;</span></span><span class="hljs-meta">#<span class="hljs-meta-keyword">include</span> <span class="hljs-meta-string">&lt;iomanip&gt;</span></span><span class="hljs-meta">#<span class="hljs-meta-keyword">include</span> <span class="hljs-meta-string">&lt;algorithm&gt;</span></span><span class="hljs-meta">#<span class="hljs-meta-keyword">include</span> <span class="hljs-meta-string">&lt;queue&gt;</span></span><span class="hljs-meta">#<span class="hljs-meta-keyword">include</span> <span class="hljs-meta-string">&lt;vector&gt;</span></span><span class="hljs-meta">#<span class="hljs-meta-keyword">include</span> <span class="hljs-meta-string">&lt;map&gt;</span></span><span class="hljs-meta">#<span class="hljs-meta-keyword">define</span> INF 0x3f3f3f3f</span><span class="hljs-meta">#<span class="hljs-meta-keyword">define</span> eps 1e-8</span><span class="hljs-keyword">using</span> <span class="hljs-keyword">namespace</span> <span class="hljs-built_in">std</span>;<span class="hljs-keyword">const</span> <span class="hljs-keyword">int</span> maxn=<span class="hljs-number">1e5</span>+<span class="hljs-number">5</span>;<span class="hljs-keyword">typedef</span> <span class="hljs-keyword">long</span> <span class="hljs-keyword">long</span> ll;ll a[maxn+<span class="hljs-number">10</span>];<span class="hljs-keyword">int</span> ans; <span class="hljs-keyword">int</span> n,m,t;<span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span>&#123;<span class="hljs-keyword">while</span>(~<span class="hljs-built_in">scanf</span>(<span class="hljs-string">"%d"</span>,&amp;n))&#123;ans=INF;<span class="hljs-keyword">for</span>(<span class="hljs-keyword">int</span> i=<span class="hljs-number">0</span>;i&lt;n;i++)<span class="hljs-built_in">scanf</span>(<span class="hljs-string">"%I64d"</span>,&amp;a[i]);<span class="hljs-keyword">if</span>(n==<span class="hljs-number">1</span>)&#123;<span class="hljs-built_in">printf</span>(<span class="hljs-string">"0\n"</span>);<span class="hljs-keyword">continue</span>;&#125;ll gap=a[<span class="hljs-number">1</span>]-a[<span class="hljs-number">0</span>];ll origin0=a[<span class="hljs-number">0</span>],origin1=a[<span class="hljs-number">1</span>],ogap=a[<span class="hljs-number">1</span>]-a[<span class="hljs-number">0</span>];<span class="hljs-comment">//第一种情况</span><span class="hljs-keyword">for</span>(<span class="hljs-keyword">int</span> i=<span class="hljs-number">0</span>;i&lt;<span class="hljs-number">9</span>;i++) &#123;<span class="hljs-keyword">int</span> ccnt=<span class="hljs-number">0</span>;<span class="hljs-keyword">if</span>(i==<span class="hljs-number">0</span>)a[<span class="hljs-number">0</span>]=origin0<span class="hljs-number">-1</span>,a[<span class="hljs-number">1</span>]=origin1<span class="hljs-number">-1</span>,ccnt=<span class="hljs-number">2</span>;<span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span>(i==<span class="hljs-number">1</span>)a[<span class="hljs-number">0</span>]=origin0,a[<span class="hljs-number">1</span>]=origin1<span class="hljs-number">-1</span>,ccnt=<span class="hljs-number">1</span>;<span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span>(i==<span class="hljs-number">2</span>)a[<span class="hljs-number">0</span>]=origin0+<span class="hljs-number">1</span>,a[<span class="hljs-number">1</span>]=origin1<span class="hljs-number">-1</span>,ccnt=<span class="hljs-number">2</span>;<span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span>(i==<span class="hljs-number">3</span>)a[<span class="hljs-number">0</span>]=origin0<span class="hljs-number">-1</span>,a[<span class="hljs-number">1</span>]=origin1,ccnt=<span class="hljs-number">1</span>;<span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span>(i==<span class="hljs-number">4</span>)a[<span class="hljs-number">0</span>]=origin0,a[<span class="hljs-number">1</span>]=origin1,ccnt=<span class="hljs-number">0</span>;<span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span>(i==<span class="hljs-number">5</span>)a[<span class="hljs-number">0</span>]=origin0+<span class="hljs-number">1</span>,a[<span class="hljs-number">1</span>]=origin1,ccnt=<span class="hljs-number">1</span>;<span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span>(i==<span class="hljs-number">6</span>)a[<span class="hljs-number">0</span>]=origin0<span class="hljs-number">-1</span>,a[<span class="hljs-number">1</span>]=origin1+<span class="hljs-number">1</span>,ccnt=<span class="hljs-number">2</span>;<span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span>(i==<span class="hljs-number">7</span>)a[<span class="hljs-number">0</span>]=origin0,a[<span class="hljs-number">1</span>]=origin1+<span class="hljs-number">1</span>,ccnt=<span class="hljs-number">1</span>;<span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span>(i==<span class="hljs-number">8</span>)a[<span class="hljs-number">0</span>]=origin0+<span class="hljs-number">1</span>,a[<span class="hljs-number">1</span>]=origin1+<span class="hljs-number">1</span>,ccnt=<span class="hljs-number">2</span>;gap=a[<span class="hljs-number">1</span>]-a[<span class="hljs-number">0</span>];<span class="hljs-comment">//开始遍历剩余</span><span class="hljs-keyword">int</span> j=<span class="hljs-number">2</span>;ll last=a[<span class="hljs-number">1</span>];<span class="hljs-keyword">for</span>(;j&lt;n;j++)&#123;<span class="hljs-comment">//printf("before a[j]-last=%d\n",a[j]-last); </span><span class="hljs-keyword">if</span>(a[j]-last==gap)&#123;last=a[j];<span class="hljs-keyword">continue</span>;&#125;<span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span>(a[j]-last==gap+<span class="hljs-number">1</span>)&#123;last=a[j]<span class="hljs-number">-1</span>;ccnt++;<span class="hljs-keyword">continue</span>;&#125;<span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span>(a[j]-last==gap<span class="hljs-number">-1</span>)&#123;last=a[j]+<span class="hljs-number">1</span>;ccnt++;<span class="hljs-keyword">continue</span>;&#125;<span class="hljs-keyword">else</span> <span class="hljs-keyword">break</span>;&#125; <span class="hljs-keyword">if</span>(j==n) ans=min(ans,ccnt);&#125;<span class="hljs-keyword">if</span>(ans==INF) <span class="hljs-built_in">printf</span>(<span class="hljs-string">"-1\n"</span>);<span class="hljs-keyword">else</span> <span class="hljs-built_in">printf</span>(<span class="hljs-string">"%d\n"</span>,ans);&#125;&#125;</code></pre><h1 id="收获与反思"><a href="#收获与反思" class="headerlink" title="收获与反思"></a>收获与反思</h1><ul><li>想到可能的等差gap值。</li><li>暴力遍历每种gap的可能。</li></ul>]]></content>
    
    
    <categories>
      
      <category>Computer Science</category>
      
      <category>ACM</category>
      
      <category>CodeForces</category>
      
    </categories>
    
    
    <tags>
      
      <tag>ACM</tag>
      
      <tag>CodeForces</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>【CodeForces-978C】解题报告（水题，前缀和）</title>
    <link href="/post/9c649212.html"/>
    <url>/post/9c649212.html</url>
    
    <content type="html"><![CDATA[<h1 id="原始题目"><a href="#原始题目" class="headerlink" title="原始题目"></a>原始题目</h1><h2 id="Letters"><a href="#Letters" class="headerlink" title="Letters"></a>Letters</h2><ul><li>time limit per test4 seconds</li><li>memory limit per test256 megabytes</li><li>inputstandard input</li><li>outputstandard output</li></ul><p>There are n dormitories in Berland State University, they are numbered with integers from 1 to n. Each dormitory consists of rooms, there are ai rooms in i-th dormitory. The rooms in i-th dormitory are numbered from 1 to ai.</p><a id="more"></a><p>A postman delivers letters. Sometimes there is no specific dormitory and room number in it on an envelope. Instead of it only a room number among all rooms of all n dormitories is written on an envelope. In this case, assume that all the rooms are numbered from 1 to a1+a2+⋯+an and the rooms of the first dormitory go first, the rooms of the second dormitory go after them and so on.</p><p>For example, in case n=2, a1=3 and a2=5 an envelope can have any integer from 1 to 8 written on it. If the number 7 is written on an envelope, it means that the letter should be delivered to the room number 4 of the second dormitory.</p><p>For each of m letters by the room number among all n dormitories, determine the particular dormitory and the room number in a dormitory where this letter should be delivered.</p><h3 id="Input"><a href="#Input" class="headerlink" title="Input"></a>Input</h3><p>The first line contains two integers n and m (1≤n,m≤2⋅105) — the number of dormitories and the number of letters.</p><p>The second line contains a sequence a1,a2,…,an (1≤ai≤1010), where ai equals to the number of rooms in the i-th dormitory. The third line contains a sequence b1,b2,…,bm (1≤bj≤a1+a2+⋯+an), where bj equals to the room number (among all rooms of all dormitories) for the j-th letter. All bj are given in increasing order.</p><h3 id="Output"><a href="#Output" class="headerlink" title="Output"></a>Output</h3><p>Print m lines. For each letter print two integers f and k — the dormitory number f (1≤f≤n) and the room number k in this dormitory (1≤k≤af) to deliver the letter.</p><h3 id="Examples"><a href="#Examples" class="headerlink" title="Examples"></a>Examples</h3><h4 id="Input-1"><a href="#Input-1" class="headerlink" title="Input"></a>Input</h4><pre><code>3 610 15 121 9 12 23 26 37</code></pre><h4 id="Output-1"><a href="#Output-1" class="headerlink" title="Output"></a>Output</h4><pre><code>1 11 92 22 133 13 12</code></pre><h4 id="Input-2"><a href="#Input-2" class="headerlink" title="Input"></a>Input</h4><pre><code>2 35 100000000005 6 9999999999</code></pre><h4 id="Output-2"><a href="#Output-2" class="headerlink" title="Output"></a>Output</h4><pre><code>1 52 12 9999999994</code></pre><h3 id="Note"><a href="#Note" class="headerlink" title="Note"></a>Note</h3><p>In the first example letters should be delivered in the following order:</p><ul><li>the first letter in room 1 of the first dormitory</li><li>the second letter in room 9 of the first dormitory</li><li>the third letter in room 2 of the second dormitory</li><li>the fourth letter in room 13 of the second dormitory</li><li>the fifth letter in room 1 of the third dormitory</li><li>the sixth letter in room 12 of the third dormitory</li></ul><h1 id="题目大意"><a href="#题目大意" class="headerlink" title="题目大意"></a>题目大意</h1><p>给出n个公寓的房间数，给出从第一个房间开始计数的房间号，要求输出按公寓分开后每个房间对应的<br>公寓号码和在本公寓的房间号码</p><h1 id="解题思路"><a href="#解题思路" class="headerlink" title="解题思路"></a>解题思路</h1><p>根据n个公寓的房间数处理出前缀和，顺序遍历前缀和数组，对每个查询求差值即可。</p><h1 id="解题代码"><a href="#解题代码" class="headerlink" title="解题代码"></a>解题代码</h1><pre><code class="hljs C++"><span class="hljs-meta">#<span class="hljs-meta-keyword">include</span> <span class="hljs-meta-string">&lt;cstdio&gt;</span></span><span class="hljs-meta">#<span class="hljs-meta-keyword">include</span> <span class="hljs-meta-string">&lt;cstring&gt;</span></span><span class="hljs-meta">#<span class="hljs-meta-keyword">include</span> <span class="hljs-meta-string">&lt;iostream&gt;</span></span><span class="hljs-meta">#<span class="hljs-meta-keyword">include</span> <span class="hljs-meta-string">&lt;set&gt;</span></span><span class="hljs-meta">#<span class="hljs-meta-keyword">include</span> <span class="hljs-meta-string">&lt;queue&gt;</span></span><span class="hljs-meta">#<span class="hljs-meta-keyword">include</span> <span class="hljs-meta-string">&lt;map&gt;</span></span><span class="hljs-meta">#<span class="hljs-meta-keyword">include</span> <span class="hljs-meta-string">&lt;vector&gt;</span></span><span class="hljs-meta">#<span class="hljs-meta-keyword">include</span> <span class="hljs-meta-string">&lt;algorithm&gt;</span></span><span class="hljs-meta">#<span class="hljs-meta-keyword">define</span> eps 1e-8</span><span class="hljs-meta">#<span class="hljs-meta-keyword">define</span> INF 0x3f3f3f3f</span><span class="hljs-keyword">using</span> <span class="hljs-keyword">namespace</span> <span class="hljs-built_in">std</span>;<span class="hljs-keyword">const</span> <span class="hljs-keyword">int</span> maxn=<span class="hljs-number">2e5</span>+<span class="hljs-number">5</span>;<span class="hljs-keyword">typedef</span> <span class="hljs-keyword">long</span> <span class="hljs-keyword">long</span> ll;<span class="hljs-function">ll <span class="hljs-title">gcd</span><span class="hljs-params">(ll a,ll b)</span></span>&#123;<span class="hljs-keyword">return</span> a?gcd(b%a,a):b;&#125;<span class="hljs-function">ll <span class="hljs-title">lcm</span><span class="hljs-params">(ll a,ll b)</span></span>&#123;<span class="hljs-keyword">return</span> a/gcd(a,b)*b; &#125; ll n,m,vis[maxn],ans[maxn],cnt;ll a[maxn],sum[maxn];<span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span>&#123;<span class="hljs-keyword">while</span>(~<span class="hljs-built_in">scanf</span>(<span class="hljs-string">"%lld%d"</span>,&amp;n,&amp;m))&#123;sum[<span class="hljs-number">0</span>]=<span class="hljs-number">0</span>;<span class="hljs-keyword">for</span>(ll i=<span class="hljs-number">1</span>;i&lt;=n;i++)&#123;<span class="hljs-built_in">scanf</span>(<span class="hljs-string">"%lld"</span>,&amp;sum[i]);sum[i]+=sum[i<span class="hljs-number">-1</span>]; <span class="hljs-comment">//处理前缀和 </span>&#125;ll temp;ll j=<span class="hljs-number">0</span>;<span class="hljs-keyword">for</span>(ll i=<span class="hljs-number">0</span>;i&lt;m;i++)&#123;<span class="hljs-built_in">scanf</span>(<span class="hljs-string">"%I64d"</span>,&amp;temp);<span class="hljs-keyword">while</span>(temp&gt;sum[j]) j++;<span class="hljs-built_in">printf</span>(<span class="hljs-string">"%I64d %I64d\n"</span>,j,temp-sum[j<span class="hljs-number">-1</span>]);&#125;&#125;&#125;</code></pre><h1 id="收获与反思"><a href="#收获与反思" class="headerlink" title="收获与反思"></a>收获与反思</h1><p>前缀和应用。<br>注意如果查询不按顺序的话应该采用二分查找。</p>]]></content>
    
    
    <categories>
      
      <category>Computer Science</category>
      
      <category>ACM</category>
      
      <category>CodeForces</category>
      
    </categories>
    
    
    <tags>
      
      <tag>ACM</tag>
      
      <tag>CodeForces</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>【CodeForces-978B】解题报告（水题，贪心，字符串）</title>
    <link href="/post/5abc6d45.html"/>
    <url>/post/5abc6d45.html</url>
    
    <content type="html"><![CDATA[<h1 id="原始题目"><a href="#原始题目" class="headerlink" title="原始题目"></a>原始题目</h1><h2 id="File-Name"><a href="#File-Name" class="headerlink" title="File Name"></a>File Name</h2><ul><li>time limit per test1 second</li><li>memory limit per test256 megabytes</li><li>inputstandard input</li><li>outputstandard output</li></ul><a id="more"></a><p>You can not just take the file and send it. When Polycarp trying to send a file in the social network “Codehorses”, he encountered an unexpected problem. If the name of the file contains three or more “x” (lowercase Latin letters “x”) in a row, the system considers that the file content does not correspond to the social network topic. In this case, the file is not sent and an error message is displayed.</p><p>Determine the minimum number of characters to remove from the file name so after that the name does not contain “xxx” as a substring. Print 0 if the file name does not initially contain a forbidden substring “xxx”.</p><p>You can delete characters in arbitrary positions (not necessarily consecutive). If you delete a character, then the length of a string is reduced by 1. For example, if you delete the character in the position 2 from the string “exxxii”, then the resulting string is “exxii”.</p><h3 id="Input"><a href="#Input" class="headerlink" title="Input"></a>Input</h3><p>The first line contains integer n (3≤n≤100) — the length of the file name.</p><p>The second line contains a string of length n consisting of lowercase Latin letters only — the file name.</p><h3 id="Output"><a href="#Output" class="headerlink" title="Output"></a>Output</h3><p>Print the minimum number of characters to remove from the file name so after that the name does not contain “xxx” as a substring. If initially the file name dost not contain a forbidden substring “xxx”, print 0.</p><h3 id="Examples"><a href="#Examples" class="headerlink" title="Examples"></a>Examples</h3><h4 id="Input-1"><a href="#Input-1" class="headerlink" title="Input"></a>Input</h4><pre><code>6xxxiii</code></pre><h4 id="Output-1"><a href="#Output-1" class="headerlink" title="Output"></a>Output</h4><pre><code>1</code></pre><h4 id="Input-2"><a href="#Input-2" class="headerlink" title="Input"></a>Input</h4><pre><code>5xxoxx</code></pre><h4 id="Output-2"><a href="#Output-2" class="headerlink" title="Output"></a>Output</h4><pre><code>0</code></pre><h4 id="Input-3"><a href="#Input-3" class="headerlink" title="Input"></a>Input</h4><pre><code>10xxxxxxxxxx</code></pre><h4 id="Output-3"><a href="#Output-3" class="headerlink" title="Output"></a>Output</h4><pre><code>8</code></pre><h3 id="Note"><a href="#Note" class="headerlink" title="Note"></a>Note</h3><p>In the first example Polycarp tried to send a file with name contains number 33, written in Roman numerals. But he can not just send the file, because it name contains three letters “x” in a row. To send the file he needs to remove any one of this letters.</p><h1 id="题目大意"><a href="#题目大意" class="headerlink" title="题目大意"></a>题目大意</h1><p>文件名中超过n个（n&gt;=3）连续的x时需要修改n-2次。</p><h1 id="解题思路"><a href="#解题思路" class="headerlink" title="解题思路"></a>解题思路</h1><p>每次贪心的取最大连续个x值，然后判断累加即可。</p><h1 id="解题代码"><a href="#解题代码" class="headerlink" title="解题代码"></a>解题代码</h1><pre><code class="hljs C++"><span class="hljs-meta">#<span class="hljs-meta-keyword">include</span> <span class="hljs-meta-string">&lt;cstdio&gt;</span></span><span class="hljs-meta">#<span class="hljs-meta-keyword">include</span> <span class="hljs-meta-string">&lt;cstring&gt;</span></span><span class="hljs-meta">#<span class="hljs-meta-keyword">include</span> <span class="hljs-meta-string">&lt;iostream&gt;</span></span><span class="hljs-meta">#<span class="hljs-meta-keyword">include</span> <span class="hljs-meta-string">&lt;set&gt;</span></span><span class="hljs-meta">#<span class="hljs-meta-keyword">include</span> <span class="hljs-meta-string">&lt;queue&gt;</span></span><span class="hljs-meta">#<span class="hljs-meta-keyword">include</span> <span class="hljs-meta-string">&lt;map&gt;</span></span><span class="hljs-meta">#<span class="hljs-meta-keyword">include</span> <span class="hljs-meta-string">&lt;vector&gt;</span></span><span class="hljs-meta">#<span class="hljs-meta-keyword">include</span> <span class="hljs-meta-string">&lt;algorithm&gt;</span></span><span class="hljs-meta">#<span class="hljs-meta-keyword">define</span> eps 1e-8</span><span class="hljs-meta">#<span class="hljs-meta-keyword">define</span> INF 0x3f3f3f3f</span><span class="hljs-keyword">using</span> <span class="hljs-keyword">namespace</span> <span class="hljs-built_in">std</span>;<span class="hljs-keyword">const</span> <span class="hljs-keyword">int</span> maxn=<span class="hljs-number">1e5</span>+<span class="hljs-number">5</span>;<span class="hljs-keyword">typedef</span> <span class="hljs-keyword">long</span> <span class="hljs-keyword">long</span> ll;<span class="hljs-function">ll <span class="hljs-title">gcd</span><span class="hljs-params">(ll a,ll b)</span></span>&#123;<span class="hljs-keyword">return</span> a?gcd(b%a,a):b;&#125;<span class="hljs-function">ll <span class="hljs-title">lcm</span><span class="hljs-params">(ll a,ll b)</span></span>&#123;<span class="hljs-keyword">return</span> a/gcd(a,b)*b; &#125; <span class="hljs-keyword">int</span> n,m,vis[maxn],ans[maxn],cnt;<span class="hljs-keyword">char</span> a[maxn];<span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span>&#123;<span class="hljs-keyword">while</span>(~<span class="hljs-built_in">scanf</span>(<span class="hljs-string">"%d"</span>,&amp;n))&#123;getchar();cnt=<span class="hljs-number">0</span>;<span class="hljs-keyword">int</span> ccnt=<span class="hljs-number">0</span>;<span class="hljs-keyword">char</span> temp;gets(a);<span class="hljs-keyword">for</span>(<span class="hljs-keyword">int</span> i=<span class="hljs-number">0</span>;i&lt;n;i++)&#123;<span class="hljs-keyword">if</span>(a[i]==<span class="hljs-string">'x'</span>) ccnt++;<span class="hljs-keyword">else</span>&#123;<span class="hljs-keyword">if</span>(ccnt&gt;=<span class="hljs-number">3</span>) cnt+=ccnt<span class="hljs-number">-2</span>;ccnt=<span class="hljs-number">0</span>;&#125; &#125;<span class="hljs-keyword">if</span>(ccnt&gt;=<span class="hljs-number">3</span>) cnt+=ccnt<span class="hljs-number">-2</span>;<span class="hljs-built_in">printf</span>(<span class="hljs-string">"%d\n"</span>,cnt);&#125;  &#125;</code></pre><h1 id="收获与反思"><a href="#收获与反思" class="headerlink" title="收获与反思"></a>收获与反思</h1><p>字符串简单贪心</p>]]></content>
    
    
    <categories>
      
      <category>Computer Science</category>
      
      <category>ACM</category>
      
      <category>CodeForces</category>
      
    </categories>
    
    
    <tags>
      
      <tag>ACM</tag>
      
      <tag>CodeForces</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>【CodeForces-978A】解题报告（水题）</title>
    <link href="/post/36e5881d.html"/>
    <url>/post/36e5881d.html</url>
    
    <content type="html"><![CDATA[<h1 id="原始题目"><a href="#原始题目" class="headerlink" title="原始题目"></a>原始题目</h1><h2 id="Remove-Duplicates"><a href="#Remove-Duplicates" class="headerlink" title="Remove Duplicates"></a>Remove Duplicates</h2><ul><li>time limit per test1 second</li><li>memory limit per test256 megabytes</li><li>inputstandard input</li><li>outputstandard output</li></ul><p>Petya has an array a consisting of n integers. He wants to remove duplicate (equal) elements.</p><a id="more"></a><p>Petya wants to leave only the rightmost entry (occurrence) for each element of the array. The relative order of the remaining unique elements should not be changed.</p><h3 id="Input"><a href="#Input" class="headerlink" title="Input"></a>Input</h3><p>The first line contains a single integer n (1≤n≤50) — the number of elements in Petya’s array.</p><p>The following line contains a sequence a1,a2,…,an (1≤ai≤1000) — the Petya’s array.</p><h3 id="Output"><a href="#Output" class="headerlink" title="Output"></a>Output</h3><p>In the first line print integer x — the number of elements which will be left in Petya’s array after he removed the duplicates.</p><p>In the second line print x integers separated with a space — Petya’s array after he removed the duplicates. For each unique element only the rightmost entry should be left.</p><h3 id="Examples"><a href="#Examples" class="headerlink" title="Examples"></a>Examples</h3><h4 id="Input-1"><a href="#Input-1" class="headerlink" title="Input"></a>Input</h4><pre><code>61 5 5 1 6 1</code></pre><h4 id="Output-1"><a href="#Output-1" class="headerlink" title="Output"></a>Output</h4><pre><code>35 6 1 </code></pre><h4 id="Input-2"><a href="#Input-2" class="headerlink" title="Input"></a>Input</h4><pre><code>52 4 2 4 4</code></pre><h4 id="Output-2"><a href="#Output-2" class="headerlink" title="Output"></a>Output</h4><pre><code>22 4 </code></pre><h4 id="Input-3"><a href="#Input-3" class="headerlink" title="Input"></a>Input</h4><pre><code>56 6 6 6 6</code></pre><h4 id="Output-3"><a href="#Output-3" class="headerlink" title="Output"></a>Output</h4><pre><code>16 </code></pre><h3 id="Note"><a href="#Note" class="headerlink" title="Note"></a>Note</h3><p>In the first example you should remove two integers 1, which are in the positions 1 and 4. Also you should remove the integer 5, which is in the position 2.</p><p>In the second example you should remove integer 2, which is in the position 1, and two integers 4, which are in the positions 2 and 4.</p><p>In the third example you should remove four integers 6, which are in the positions 1, 2, 3 and 4.</p><h1 id="题目大意"><a href="#题目大意" class="headerlink" title="题目大意"></a>题目大意</h1><p>给一组数，输出不重复的数个数，按序输出。</p><h1 id="解题思路"><a href="#解题思路" class="headerlink" title="解题思路"></a>解题思路</h1><p>水题</p><h1 id="解题代码"><a href="#解题代码" class="headerlink" title="解题代码"></a>解题代码</h1><pre><code class="hljs C++"><span class="hljs-meta">#<span class="hljs-meta-keyword">include</span> <span class="hljs-meta-string">&lt;cstdio&gt;</span></span><span class="hljs-meta">#<span class="hljs-meta-keyword">include</span> <span class="hljs-meta-string">&lt;cstring&gt;</span></span><span class="hljs-meta">#<span class="hljs-meta-keyword">include</span> <span class="hljs-meta-string">&lt;iostream&gt;</span></span><span class="hljs-meta">#<span class="hljs-meta-keyword">include</span> <span class="hljs-meta-string">&lt;set&gt;</span></span><span class="hljs-meta">#<span class="hljs-meta-keyword">include</span> <span class="hljs-meta-string">&lt;queue&gt;</span></span><span class="hljs-meta">#<span class="hljs-meta-keyword">include</span> <span class="hljs-meta-string">&lt;map&gt;</span></span><span class="hljs-meta">#<span class="hljs-meta-keyword">include</span> <span class="hljs-meta-string">&lt;vector&gt;</span></span><span class="hljs-meta">#<span class="hljs-meta-keyword">include</span> <span class="hljs-meta-string">&lt;algorithm&gt;</span></span><span class="hljs-meta">#<span class="hljs-meta-keyword">define</span> eps 1e-8</span><span class="hljs-meta">#<span class="hljs-meta-keyword">define</span> INF 0x3f3f3f3f</span><span class="hljs-keyword">using</span> <span class="hljs-keyword">namespace</span> <span class="hljs-built_in">std</span>;<span class="hljs-keyword">const</span> <span class="hljs-keyword">int</span> maxn=<span class="hljs-number">1e5</span>+<span class="hljs-number">5</span>;<span class="hljs-keyword">typedef</span> <span class="hljs-keyword">long</span> <span class="hljs-keyword">long</span> ll;<span class="hljs-function">ll <span class="hljs-title">gcd</span><span class="hljs-params">(ll a,ll b)</span></span>&#123;<span class="hljs-keyword">return</span> a?gcd(b%a,a):b;&#125;<span class="hljs-function">ll <span class="hljs-title">lcm</span><span class="hljs-params">(ll a,ll b)</span></span>&#123;<span class="hljs-keyword">return</span> a/gcd(a,b)*b; &#125; <span class="hljs-keyword">int</span> a[maxn],n,m,vis[maxn],ans[maxn],cnt;<span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span>&#123;<span class="hljs-keyword">while</span>(~<span class="hljs-built_in">scanf</span>(<span class="hljs-string">"%d"</span>,&amp;n))&#123;cnt=<span class="hljs-number">0</span>;<span class="hljs-built_in">memset</span>(vis,<span class="hljs-number">0</span>,<span class="hljs-keyword">sizeof</span>(vis));<span class="hljs-keyword">for</span>(<span class="hljs-keyword">int</span> i=<span class="hljs-number">1</span>;i&lt;=n;i++)&#123;<span class="hljs-built_in">scanf</span>(<span class="hljs-string">"%d"</span>,&amp;a[i]);&#125;<span class="hljs-keyword">for</span>(<span class="hljs-keyword">int</span> i=n;i&gt;=<span class="hljs-number">1</span>;i--)&#123;<span class="hljs-comment">//printf("%d",a[i]);</span><span class="hljs-keyword">if</span>(!vis[a[i]])&#123;ans[cnt++]=a[i];vis[a[i]]=<span class="hljs-number">1</span>; &#125; &#125;<span class="hljs-built_in">printf</span>(<span class="hljs-string">"%d\n"</span>,cnt);<span class="hljs-keyword">for</span>(<span class="hljs-keyword">int</span> i=cnt<span class="hljs-number">-1</span>;i&gt;=<span class="hljs-number">0</span>;i--)&#123;<span class="hljs-keyword">if</span>(i==<span class="hljs-number">0</span>) <span class="hljs-built_in">printf</span>(<span class="hljs-string">"%d"</span>,ans[i]);<span class="hljs-keyword">else</span> <span class="hljs-built_in">printf</span>(<span class="hljs-string">"%d "</span>,ans[i]);&#125;<span class="hljs-built_in">printf</span>(<span class="hljs-string">"\n"</span>);&#125;&#125;</code></pre><h1 id="收获与反思"><a href="#收获与反思" class="headerlink" title="收获与反思"></a>收获与反思</h1><p>无，注意细节一遍成功即可。</p>]]></content>
    
    
    <categories>
      
      <category>Computer Science</category>
      
      <category>ACM</category>
      
      <category>CodeForces</category>
      
    </categories>
    
    
    <tags>
      
      <tag>ACM</tag>
      
      <tag>CodeForces</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>【CSU-1023】解题报告（二分）</title>
    <link href="/post/109aa3c8.html"/>
    <url>/post/109aa3c8.html</url>
    
    <content type="html"><![CDATA[<h1 id="原始题目"><a href="#原始题目" class="headerlink" title="原始题目"></a>原始题目</h1><h2 id="1023-修路"><a href="#1023-修路" class="headerlink" title="1023: 修路"></a>1023: 修路</h2><ul><li>Time Limit: 1 Sec</li><li>Memory Limit: 128 Mb</li><li>Submitted: 632</li><li>Solved: 340<h3 id="Description"><a href="#Description" class="headerlink" title="Description"></a>Description</h3>前段时间，某省发生干旱，B山区的居民缺乏生活用水，现在需要从A城市修一条通往B山区的路。假设有A城市通往B山区的路由$m$条连续的路段组成，<br>现在将这m条路段承包给$n$个工程队$(n ≤ m ≤ 300)$。为了修路的便利，每个工程队只能分配到连续的若干条路段（当然也可能只分配到一条路段或未分配到路段）。<br>假设每个工程队修路的效率一样，即每修长度为$1$的路段所需的时间为$1$。现在给出路段的数量$m$，工程队的数量$n$，<br>以及$m$条路段的长度（这$m$条路段的长度是按照从A城市往B山区的方向依次给出，每条路段的长度均小于$1000$），<br>需要你计算出修完整条路所需的最短的时间（即耗时最长的工程队所用的时间）。</li></ul><a id="more"></a><h3 id="Input"><a href="#Input" class="headerlink" title="Input"></a>Input</h3><p>第一行是测试样例的个数T ，接下来是T个测试样例，每个测试样例占2行，第一行是路段的数量m和工程队的数量n，第二行是m条路段的长度。</p><h3 id="Output"><a href="#Output" class="headerlink" title="Output"></a>Output</h3><p>对于每个测试样例，输出修完整条路所需的最短的时间。</p><h3 id="Sample-Input"><a href="#Sample-Input" class="headerlink" title="Sample Input"></a>Sample Input</h3><pre><code>24 3100 200 300 4009 4250 100 150 400 550 200 50 700 300</code></pre><h3 id="Sample-Output"><a href="#Sample-Output" class="headerlink" title="Sample Output"></a>Sample Output</h3><pre><code>400900</code></pre><h3 id="Hint"><a href="#Hint" class="headerlink" title="Hint"></a>Hint</h3><h3 id="Source"><a href="#Source" class="headerlink" title="Source"></a>Source</h3><p>中南大学第四届大学生程序设计竞赛</p><h1 id="解题思路"><a href="#解题思路" class="headerlink" title="解题思路"></a>解题思路</h1><ul><li>每个队伍必须连续修路，每个队伍效率相同（每天都修单位长度）</li><li>可以得到修路的下限和上限，二分修路长度最终得到答案</li></ul><h1 id="解题代码"><a href="#解题代码" class="headerlink" title="解题代码"></a>解题代码</h1><pre><code class="hljs C++"><span class="hljs-meta">#<span class="hljs-meta-keyword">include</span> <span class="hljs-meta-string">&lt;cstdio&gt;</span></span><span class="hljs-meta">#<span class="hljs-meta-keyword">include</span> <span class="hljs-meta-string">&lt;cstring&gt;</span></span><span class="hljs-meta">#<span class="hljs-meta-keyword">include</span> <span class="hljs-meta-string">&lt;iostream&gt;</span></span><span class="hljs-meta">#<span class="hljs-meta-keyword">include</span> <span class="hljs-meta-string">&lt;set&gt;</span></span><span class="hljs-meta">#<span class="hljs-meta-keyword">include</span> <span class="hljs-meta-string">&lt;queue&gt;</span></span><span class="hljs-meta">#<span class="hljs-meta-keyword">include</span> <span class="hljs-meta-string">&lt;algorithm&gt;</span></span><span class="hljs-meta">#<span class="hljs-meta-keyword">include</span> <span class="hljs-meta-string">&lt;queue&gt;</span></span><span class="hljs-keyword">using</span> <span class="hljs-keyword">namespace</span> <span class="hljs-built_in">std</span>;<span class="hljs-keyword">const</span> <span class="hljs-keyword">int</span> maxn=<span class="hljs-number">1e5</span>+<span class="hljs-number">5</span>;<span class="hljs-keyword">int</span> t,n,m;<span class="hljs-keyword">int</span> road[maxn];<span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span>&#123;<span class="hljs-built_in">scanf</span>(<span class="hljs-string">"%d"</span>,&amp;t);<span class="hljs-keyword">while</span>(t--)&#123;<span class="hljs-built_in">memset</span>(road,<span class="hljs-number">0</span>,<span class="hljs-keyword">sizeof</span>(road));<span class="hljs-built_in">scanf</span>(<span class="hljs-string">"%d%d"</span>,&amp;m,&amp;n);<span class="hljs-keyword">int</span> high=<span class="hljs-number">0</span>,low=<span class="hljs-number">0</span>;<span class="hljs-keyword">for</span>(<span class="hljs-keyword">int</span> i=<span class="hljs-number">0</span>;i&lt;m;i++)&#123;<span class="hljs-built_in">scanf</span>(<span class="hljs-string">"%d"</span>,&amp;road[i]);high+=road[i];low=max(road[i],low);&#125;<span class="hljs-keyword">while</span>(low&lt;high) <span class="hljs-comment">//二分修路的长度 </span>&#123;<span class="hljs-keyword">int</span> mid=(high+low)&gt;&gt;<span class="hljs-number">1</span>;<span class="hljs-comment">//printf("now mid=%d\n",mid);</span><span class="hljs-keyword">int</span> tot=n<span class="hljs-number">-1</span>,sum=road[<span class="hljs-number">0</span>]; <span class="hljs-comment">//一共还有n-1个人可以用 </span><span class="hljs-keyword">for</span>(<span class="hljs-keyword">int</span> i=<span class="hljs-number">1</span>;i&lt;m;i++)&#123;<span class="hljs-keyword">if</span>(sum+road[i]&gt;mid)&#123;tot--;sum=road[i];&#125;<span class="hljs-keyword">else</span> sum+=road[i];<span class="hljs-keyword">if</span>(tot&lt;<span class="hljs-number">0</span>) <span class="hljs-keyword">break</span>;&#125;<span class="hljs-keyword">if</span>(tot&lt;<span class="hljs-number">0</span>) low=mid+<span class="hljs-number">1</span>;<span class="hljs-keyword">else</span> high=mid;&#125;<span class="hljs-built_in">printf</span>(<span class="hljs-string">"%d\n"</span>,low);&#125; &#125;</code></pre><h1 id="收获与反思"><a href="#收获与反思" class="headerlink" title="收获与反思"></a>收获与反思</h1><ul><li>二分思维转换</li><li>已知上界下界后利用二分逼近答案</li></ul>]]></content>
    
    
    <categories>
      
      <category>Computer Science</category>
      
      <category>ACM</category>
      
      <category>CSU</category>
      
    </categories>
    
    
    <tags>
      
      <tag>ACM</tag>
      
      <tag>CSU</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>【HDU-1166】解题报告（线段树求和，点维护）</title>
    <link href="/post/454c2118.html"/>
    <url>/post/454c2118.html</url>
    
    <content type="html"><![CDATA[<h1 id="原始题目"><a href="#原始题目" class="headerlink" title="原始题目"></a>原始题目</h1><h2 id="敌兵布阵"><a href="#敌兵布阵" class="headerlink" title="敌兵布阵"></a>敌兵布阵</h2><ul><li>Time Limit: 2000/1000 MS (Java/Others)    </li><li>Memory Limit: 65536/32768 K (Java/Others)</li><li>Total Submission(s): 111269    </li><li>Accepted Submission(s): 46637</li></ul><h3 id="Problem-Description"><a href="#Problem-Description" class="headerlink" title="Problem Description"></a>Problem Description</h3><a id="more"></a> <p>C国的死对头A国这段时间正在进行军事演习，所以C国间谍头子Derek和他手下Tidy又开始忙乎了。A国在海岸线沿直线布置了N个工兵营地,Derek和Tidy的任务就是要监视这些工兵营地的活动情况。由于采取了某种先进的监测手段，所以每个工兵营地的人数C国都掌握的一清二楚,每个工兵营地的人数都有可能发生变动，可能增加或减少若干人手,但这些都逃不过C国的监视。<br>中央情报局要研究敌人究竟演习什么战术,所以Tidy要随时向Derek汇报某一段连续的工兵营地一共有多少人,例如Derek问:“Tidy,马上汇报第3个营地到第10个营地共有多少人!”Tidy就要马上开始计算这一段的总人数并汇报。但敌兵营地的人数经常变动，而Derek每次询问的段都不一样，所以Tidy不得不每次都一个一个营地的去数，很快就精疲力尽了，Derek对Tidy的计算速度越来越不满:”你个死肥仔，算得这么慢，我炒你鱿鱼!”Tidy想：“你自己来算算看，这可真是一项累人的工作!我恨不得你炒我鱿鱼呢!”无奈之下，Tidy只好打电话向计算机专家Windbreaker求救,Windbreaker说：“死肥仔，叫你平时做多点acm题和看多点算法书，现在尝到苦果了吧!”Tidy说：”我知错了。。。”但Windbreaker已经挂掉电话了。Tidy很苦恼，这么算他真的会崩溃的，聪明的读者，你能写个程序帮他完成这项工作吗？不过如果你的程序效率不够高的话，Tidy还是会受到Derek的责骂的.</p><h3 id="Input"><a href="#Input" class="headerlink" title="Input"></a>Input</h3><p>第一行一个整数$T$，表示有$T$组数据。<br>每组数据第一行一个正整数$N(N \le 50000)$,表示敌人有$N$个工兵营地，接下来有$N$个正整数,第$i$个正整数$a_i$代表第$i$个工兵营地里开始时有$a_i$个人$(1 \le ai \le 50)$。<br>接下来每行有一条命令，命令有4种形式：<br>(1) Add i j,i和j为正整数,表示第i个营地增加j个人（j不超过30）<br>(2)Sub i j ,i和j为正整数,表示第i个营地减少j个人（j不超过30）;<br>(3)Query i j ,i和j为正整数,i&lt;=j，表示询问第i到第j个营地的总人数;<br>(4)End 表示结束，这条命令在每组数据最后出现;<br>每组数据最多有$40000$条命令</p><h3 id="Output"><a href="#Output" class="headerlink" title="Output"></a>Output</h3><p>对第i组数据,首先输出“Case i:”和回车,<br>对于每个Query询问，输出一个整数并回车,表示询问的段中的总人数,这个数保持在int以内。</p><h3 id="Sample-Input"><a href="#Sample-Input" class="headerlink" title="Sample Input"></a>Sample Input</h3><pre><code>1101 2 3 4 5 6 7 8 9 10Query 1 3Add 3 6Query 2 7Sub 10 2Add 6 3Query 3 10End </code></pre><h3 id="Sample-Output"><a href="#Sample-Output" class="headerlink" title="Sample Output"></a>Sample Output</h3><pre><code>Case 1:63359</code></pre><h3 id="Author"><a href="#Author" class="headerlink" title="Author"></a>Author</h3><p>Windbreaker</p><h3 id="Recommend"><a href="#Recommend" class="headerlink" title="Recommend"></a>Recommend</h3><p>Eddy</p><h1 id="题目大意"><a href="#题目大意" class="headerlink" title="题目大意"></a>题目大意</h1><p>见中文</p><h1 id="解题思路"><a href="#解题思路" class="headerlink" title="解题思路"></a>解题思路</h1><p>线段树入门题目，点修改（含正负情况），区间询问，注意</p><h1 id="解题代码"><a href="#解题代码" class="headerlink" title="解题代码"></a>解题代码</h1><pre><code class="hljs C++"><span class="hljs-meta">#<span class="hljs-meta-keyword">include</span> <span class="hljs-meta-string">&lt;cstdio&gt;</span></span><span class="hljs-meta">#<span class="hljs-meta-keyword">include</span> <span class="hljs-meta-string">&lt;cstring&gt;</span></span><span class="hljs-meta">#<span class="hljs-meta-keyword">include</span> <span class="hljs-meta-string">&lt;cmath&gt;</span></span><span class="hljs-meta">#<span class="hljs-meta-keyword">include</span> <span class="hljs-meta-string">&lt;iostream&gt;</span></span><span class="hljs-meta">#<span class="hljs-meta-keyword">include</span> <span class="hljs-meta-string">&lt;iomanip&gt;</span></span><span class="hljs-meta">#<span class="hljs-meta-keyword">include</span> <span class="hljs-meta-string">&lt;set&gt;</span></span><span class="hljs-meta">#<span class="hljs-meta-keyword">include</span> <span class="hljs-meta-string">&lt;queue&gt;</span></span><span class="hljs-meta">#<span class="hljs-meta-keyword">include</span> <span class="hljs-meta-string">&lt;map&gt;</span></span><span class="hljs-meta">#<span class="hljs-meta-keyword">include</span> <span class="hljs-meta-string">&lt;vector&gt;</span></span><span class="hljs-meta">#<span class="hljs-meta-keyword">include</span> <span class="hljs-meta-string">&lt;algorithm&gt;</span></span><span class="hljs-meta">#<span class="hljs-meta-keyword">include</span> <span class="hljs-meta-string">&lt;stack&gt;</span></span><span class="hljs-keyword">using</span> <span class="hljs-keyword">namespace</span> <span class="hljs-built_in">std</span>;<span class="hljs-keyword">typedef</span> <span class="hljs-keyword">long</span> <span class="hljs-keyword">long</span> ll;<span class="hljs-keyword">const</span> <span class="hljs-keyword">int</span> maxn=<span class="hljs-number">2e5</span>+<span class="hljs-number">5</span>;<span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">node</span>&#123;</span>ll l,r,sum;&#125;tree[maxn];ll a[maxn];<span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">build</span><span class="hljs-params">(ll k, ll l,ll r)</span></span>&#123;tree[k].l=l;tree[k].r=r; <span class="hljs-keyword">if</span>(tree[k].l==tree[k].r)&#123;tree[k].sum=a[l];<span class="hljs-keyword">return</span> ;&#125;ll mid=(tree[k].l+tree[k].r)&gt;&gt;<span class="hljs-number">1</span>;build(k&lt;&lt;<span class="hljs-number">1</span>,l,mid);build(k&lt;&lt;<span class="hljs-number">1</span>|<span class="hljs-number">1</span>,mid+<span class="hljs-number">1</span>,r);tree[k].sum=tree[k&lt;&lt;<span class="hljs-number">1</span>].sum+tree[k&lt;&lt;<span class="hljs-number">1</span>|<span class="hljs-number">1</span>].sum;<span class="hljs-comment">//printf("k==%lld  k.sum==%lld\n",k,tree[k].sum);</span>&#125;<span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">change</span><span class="hljs-params">(ll k,ll d,ll x)</span></span>&#123;<span class="hljs-keyword">if</span>(tree[k].l==tree[k].r&amp;&amp;tree[k].r==d)&#123;tree[k].sum=tree[k].sum+x;<span class="hljs-keyword">return</span> ;&#125;<span class="hljs-keyword">int</span> mid=(tree[k].l+tree[k].r)&gt;&gt;<span class="hljs-number">1</span>;<span class="hljs-keyword">if</span>(d&gt;=tree[k].l&amp;&amp;d&lt;=mid)change(k&lt;&lt;<span class="hljs-number">1</span>,d,x);<span class="hljs-keyword">else</span>change(k&lt;&lt;<span class="hljs-number">1</span>|<span class="hljs-number">1</span>,d,x);tree[k].sum=tree[k&lt;&lt;<span class="hljs-number">1</span>].sum+tree[k&lt;&lt;<span class="hljs-number">1</span>|<span class="hljs-number">1</span>].sum;&#125;<span class="hljs-function">ll <span class="hljs-title">query</span><span class="hljs-params">(ll k,ll l,ll r)</span></span>&#123;<span class="hljs-keyword">if</span>(tree[k].l==l&amp;&amp;tree[k].r==r)<span class="hljs-keyword">return</span> tree[k].sum;ll mid=(tree[k].l+tree[k].r)&gt;&gt;<span class="hljs-number">1</span>;<span class="hljs-keyword">if</span>(r&lt;=mid)<span class="hljs-keyword">return</span> query(k&lt;&lt;<span class="hljs-number">1</span>,l,r);<span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span>(l&gt;=mid+<span class="hljs-number">1</span>)<span class="hljs-keyword">return</span> query(k&lt;&lt;<span class="hljs-number">1</span>|<span class="hljs-number">1</span>,l,r);<span class="hljs-keyword">else</span> <span class="hljs-keyword">return</span> query(k&lt;&lt;<span class="hljs-number">1</span>,l,mid)+query(k&lt;&lt;<span class="hljs-number">1</span>|<span class="hljs-number">1</span>,mid+<span class="hljs-number">1</span>,r); &#125;<span class="hljs-keyword">char</span> ch[<span class="hljs-number">10</span>];ll t,n,d,x;<span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span> </span>&#123;<span class="hljs-comment">//freopen("in.txt","r",stdin);</span><span class="hljs-comment">//freopen("out.txt","w",stdout);</span><span class="hljs-keyword">while</span>(~<span class="hljs-built_in">scanf</span>(<span class="hljs-string">"%lld"</span>,&amp;t))&#123;<span class="hljs-keyword">int</span> cnt=<span class="hljs-number">0</span>;<span class="hljs-keyword">while</span>(t--)&#123;<span class="hljs-built_in">memset</span>(tree,<span class="hljs-number">0</span>,<span class="hljs-keyword">sizeof</span>(tree));<span class="hljs-built_in">memset</span>(a,<span class="hljs-number">0</span>,<span class="hljs-keyword">sizeof</span>(a));cnt++;<span class="hljs-built_in">printf</span>(<span class="hljs-string">"Case %d:\n"</span>,cnt);<span class="hljs-built_in">scanf</span>(<span class="hljs-string">"%lld"</span>,&amp;n);<span class="hljs-keyword">for</span>(<span class="hljs-keyword">int</span> i=<span class="hljs-number">1</span>;i&lt;=n;i++)<span class="hljs-built_in">scanf</span>(<span class="hljs-string">"%lld"</span>,&amp;a[i]);build(<span class="hljs-number">1</span>,<span class="hljs-number">1</span>,n);<span class="hljs-keyword">while</span>(<span class="hljs-built_in">scanf</span>(<span class="hljs-string">"%s"</span>,ch)&amp;&amp;ch[<span class="hljs-number">0</span>]!=<span class="hljs-string">'E'</span>)&#123;<span class="hljs-keyword">if</span>(ch[<span class="hljs-number">0</span>]==<span class="hljs-string">'Q'</span>)&#123;<span class="hljs-built_in">scanf</span>(<span class="hljs-string">"%lld%lld"</span>,&amp;d,&amp;x);<span class="hljs-built_in">printf</span>(<span class="hljs-string">"%lld\n"</span>,query(<span class="hljs-number">1</span>,d,x));&#125;<span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span>(ch[<span class="hljs-number">0</span>]==<span class="hljs-string">'A'</span>)&#123;<span class="hljs-built_in">scanf</span>(<span class="hljs-string">"%lld%lld"</span>,&amp;d,&amp;x);change(<span class="hljs-number">1</span>,d,x);&#125;<span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span>(ch[<span class="hljs-number">0</span>]==<span class="hljs-string">'S'</span>)&#123;<span class="hljs-built_in">scanf</span>(<span class="hljs-string">"%lld%lld"</span>,&amp;d,&amp;x);change(<span class="hljs-number">1</span>,d,-x);&#125;&#125;&#125;&#125;&#125;</code></pre><h1 id="收获与反思"><a href="#收获与反思" class="headerlink" title="收获与反思"></a>收获与反思</h1><ul><li>Emmm，WA了两次是因为数组开的不够大，这个以为够用了，待分析原因。</li><li>进一步熟悉模板。</li><li>注意long long。</li></ul>]]></content>
    
    
    <categories>
      
      <category>Computer Science</category>
      
      <category>ACM</category>
      
      <category>HDU</category>
      
    </categories>
    
    
    <tags>
      
      <tag>ACM</tag>
      
      <tag>HDU</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>【POJ-3468】解题报告（线段树求和，区间维护）</title>
    <link href="/post/481e8abf.html"/>
    <url>/post/481e8abf.html</url>
    
    <content type="html"><![CDATA[<h1 id="原始题目"><a href="#原始题目" class="headerlink" title="原始题目"></a>原始题目</h1><h2 id="A-Simple-Problem-with-Integers"><a href="#A-Simple-Problem-with-Integers" class="headerlink" title="A Simple Problem with Integers"></a>A Simple Problem with Integers</h2><ul><li>Time Limit: 5000MS        </li><li>Memory Limit: 131072K</li><li>Total Submissions: 129411        </li><li>Accepted: 40139</li><li>Case Time Limit: 2000MS</li></ul><h3 id="Description"><a href="#Description" class="headerlink" title="Description"></a>Description</h3><a id="more"></a><p>You have N integers, A1, A2, … , AN. You need to deal with two kinds of operations. One type of operation is to add some given number to each number in a given interval. The other is to ask for the sum of numbers in a given interval.</p><h3 id="Input"><a href="#Input" class="headerlink" title="Input"></a>Input</h3><p>The first line contains two numbers N and Q. 1 ≤ N,Q ≤ 100000.<br>The second line contains N numbers, the initial values of A1, A2, … , AN. -1000000000 ≤ Ai ≤ 1000000000.<br>Each of the next Q lines represents an operation.<br>“C a b c” means adding c to each of Aa, Aa+1, … , Ab. -10000 ≤ c ≤ 10000.<br>“Q a b” means querying the sum of Aa, Aa+1, … , Ab.</p><h3 id="Output"><a href="#Output" class="headerlink" title="Output"></a>Output</h3><p>You need to answer all Q commands in order. One answer in a line.</p><h3 id="Sample-Input"><a href="#Sample-Input" class="headerlink" title="Sample Input"></a>Sample Input</h3><pre><code>10 51 2 3 4 5 6 7 8 9 10Q 4 4Q 1 10Q 2 4C 3 6 3Q 2 4</code></pre><h3 id="Sample-Output"><a href="#Sample-Output" class="headerlink" title="Sample Output"></a>Sample Output</h3><pre><code>455915</code></pre><h3 id="Hint"><a href="#Hint" class="headerlink" title="Hint"></a>Hint</h3><p>The sums may exceed the range of 32-bit integers.</p><h3 id="Source"><a href="#Source" class="headerlink" title="Source"></a>Source</h3><p>POJ Monthly—2007.11.25, Yang Yi</p><h1 id="题目大意"><a href="#题目大意" class="headerlink" title="题目大意"></a>题目大意</h1><p>对于一组序列A,有两种操作，询问：给出对应区间序列的和，增加：给出对应区间区间内所有点增加固定值。</p><h1 id="解题思路"><a href="#解题思路" class="headerlink" title="解题思路"></a>解题思路</h1><p>线段树模板题，区间询问，区间修改，注意long long即可。</p><h1 id="解题代码"><a href="#解题代码" class="headerlink" title="解题代码"></a>解题代码</h1><pre><code class="hljs C++"><span class="hljs-meta">#<span class="hljs-meta-keyword">include</span> <span class="hljs-meta-string">&lt;cstdio&gt;</span></span><span class="hljs-meta">#<span class="hljs-meta-keyword">include</span> <span class="hljs-meta-string">&lt;cstring&gt;</span></span><span class="hljs-meta">#<span class="hljs-meta-keyword">include</span> <span class="hljs-meta-string">&lt;cmath&gt;</span></span><span class="hljs-meta">#<span class="hljs-meta-keyword">include</span> <span class="hljs-meta-string">&lt;cmath&gt;</span></span><span class="hljs-meta">#<span class="hljs-meta-keyword">include</span> <span class="hljs-meta-string">&lt;iostream&gt;</span></span><span class="hljs-meta">#<span class="hljs-meta-keyword">include</span> <span class="hljs-meta-string">&lt;iomanip&gt;</span></span><span class="hljs-meta">#<span class="hljs-meta-keyword">include</span> <span class="hljs-meta-string">&lt;string&gt;</span></span><span class="hljs-meta">#<span class="hljs-meta-keyword">include</span> <span class="hljs-meta-string">&lt;set&gt;</span></span><span class="hljs-meta">#<span class="hljs-meta-keyword">include</span> <span class="hljs-meta-string">&lt;queue&gt;</span></span><span class="hljs-meta">#<span class="hljs-meta-keyword">include</span> <span class="hljs-meta-string">&lt;vector&gt;</span></span><span class="hljs-meta">#<span class="hljs-meta-keyword">include</span> <span class="hljs-meta-string">&lt;map&gt;</span></span><span class="hljs-keyword">using</span> <span class="hljs-keyword">namespace</span> <span class="hljs-built_in">std</span>;<span class="hljs-keyword">const</span> <span class="hljs-keyword">int</span> maxn=<span class="hljs-number">2e5</span>+<span class="hljs-number">5</span>;<span class="hljs-keyword">typedef</span> <span class="hljs-keyword">long</span> <span class="hljs-keyword">long</span> ll;ll n,m;ll d,x;ll b,e;ll a[maxn];<span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">node</span>&#123;</span>ll l;ll r;ll sum;ll tag;ll maxnum;&#125;tree[maxn&lt;&lt;<span class="hljs-number">2</span>];<span class="hljs-keyword">char</span> ch[<span class="hljs-number">2</span>];<span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">build</span><span class="hljs-params">(ll k,ll l,ll r)</span> <span class="hljs-comment">//k为线段树的角标 </span></span>&#123;tree[k].l=l;tree[k].r=r;<span class="hljs-keyword">if</span>(l==r)&#123;tree[k].sum=a[l]=a[r];  <span class="hljs-comment">//叶子节点，单点的sum即是本身 </span><span class="hljs-keyword">return</span> ; &#125;ll mid=(l+r)&gt;&gt;<span class="hljs-number">1</span>;build(k&lt;&lt;<span class="hljs-number">1</span>,l,mid); <span class="hljs-comment">//递归构建左线段（左子树） </span>build(k&lt;&lt;<span class="hljs-number">1</span>|<span class="hljs-number">1</span>,mid+<span class="hljs-number">1</span>,r);<span class="hljs-comment">//递归构建右线段（右子树） </span>tree[k].sum=tree[k&lt;&lt;<span class="hljs-number">1</span>].sum+tree[k&lt;&lt;<span class="hljs-number">1</span>|<span class="hljs-number">1</span>].sum; <span class="hljs-keyword">return</span> ; &#125;<span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">change1</span><span class="hljs-params">(ll k,ll d,ll x)</span></span>&#123;<span class="hljs-keyword">if</span>(tree[k].l==tree[k].r&amp;&amp;tree[k].r==d) <span class="hljs-comment">//找到索引点 </span>&#123;tree[k].maxnum=x; <span class="hljs-comment">//修改最大值</span><span class="hljs-keyword">return</span> ; <span class="hljs-comment">//修改后再开始回溯 </span>&#125; ll mid=(tree[k].l+tree[k].r)&gt;&gt;<span class="hljs-number">1</span>;<span class="hljs-keyword">if</span>(d&gt;=tree[k].l&amp;&amp;d&lt;=mid) <span class="hljs-comment">//查找点在左子树</span>change1(k&lt;&lt;<span class="hljs-number">1</span>,d,x); <span class="hljs-comment">//k&lt;&lt;1为左子树,</span><span class="hljs-keyword">else</span> <span class="hljs-comment">//查找点在右子树， </span>change1(k&lt;&lt;<span class="hljs-number">1</span>|<span class="hljs-number">1</span>,d,x); <span class="hljs-comment">//k&lt;&lt;1|1为右子树</span>tree[k].maxnum=max(tree[k&lt;&lt;<span class="hljs-number">1</span>].maxnum,tree[k&lt;&lt;<span class="hljs-number">1</span>|<span class="hljs-number">1</span>].maxnum);  <span class="hljs-comment">//递归从新计算非叶结点的值 </span>&#125;<span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">change</span><span class="hljs-params">(ll k)</span> <span class="hljs-comment">//懒惰操作，有标记才操作一次，有记忆性 </span></span>&#123;<span class="hljs-keyword">if</span>(tree[k].l==tree[k].r)tree[k].sum+=tree[k].tag;<span class="hljs-keyword">else</span> &#123;tree[k].sum+=(tree[k].r-tree[k].l+<span class="hljs-number">1</span>)*tree[k].tag;tree[k&lt;&lt;<span class="hljs-number">1</span>].tag+=tree[k].tag;tree[k&lt;&lt;<span class="hljs-number">1</span>|<span class="hljs-number">1</span>].tag+=tree[k].tag; &#125;tree[k].tag=<span class="hljs-number">0</span>; <span class="hljs-comment">//自身标记清零 </span>&#125;<span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">add</span><span class="hljs-params">(ll k,ll l,ll r,ll x)</span></span>&#123;<span class="hljs-keyword">if</span>(tree[k].tag)&#123;<span class="hljs-comment">//printf("--");</span>change(k);&#125;<span class="hljs-keyword">if</span>(tree[k].l==l&amp;&amp;tree[k].r==r)  <span class="hljs-comment">//在固定的区间打标记 </span>&#123;tree[k].tag+=x; <span class="hljs-comment">//向下打标记 </span><span class="hljs-comment">//printf("k=%lld l=%lld r=%lld tag=%lld\n",k ,l,r,tree[k].tag);</span><span class="hljs-keyword">return</span> ; &#125;<span class="hljs-comment">//printf("1  %lld\n",tree[k].sum);</span>tree[k].sum+=(r-l+<span class="hljs-number">1</span>)*x;<span class="hljs-comment">//printf("2  %lld\n",tree[k].sum);</span>ll mid=(tree[k].r+tree[k].l)&gt;&gt;<span class="hljs-number">1</span>;<span class="hljs-keyword">if</span>(r&lt;=mid)add(k&lt;&lt;<span class="hljs-number">1</span>,l,r,x);<span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span>(l&gt;=mid+<span class="hljs-number">1</span>)add(k&lt;&lt;<span class="hljs-number">1</span>|<span class="hljs-number">1</span>,l,r,x);<span class="hljs-keyword">else</span> &#123;add(k&lt;&lt;<span class="hljs-number">1</span>,l,mid,x);add(k&lt;&lt;<span class="hljs-number">1</span>|<span class="hljs-number">1</span>,mid+<span class="hljs-number">1</span>,r,x); &#125;&#125;<span class="hljs-function">ll <span class="hljs-title">query</span><span class="hljs-params">(ll k,ll l,ll r)</span></span>&#123;<span class="hljs-comment">//printf("query %lld .tag=%lld\n",k,tree[k].tag);</span><span class="hljs-keyword">if</span>(tree[k].tag)&#123;<span class="hljs-comment">//printf("$");</span>change(k); &#125;ll mid=(tree[k].l+tree[k].r)&gt;&gt;<span class="hljs-number">1</span>;<span class="hljs-keyword">if</span>(tree[k].l==l&amp;&amp;tree[k].r==r)<span class="hljs-keyword">return</span> tree[k].sum;<span class="hljs-keyword">if</span>(r&lt;=mid)<span class="hljs-keyword">return</span> query(k&lt;&lt;<span class="hljs-number">1</span>,l,r);<span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span>(l&gt;=mid+<span class="hljs-number">1</span>)<span class="hljs-keyword">return</span> query(k&lt;&lt;<span class="hljs-number">1</span>|<span class="hljs-number">1</span>,l,r);<span class="hljs-keyword">else</span> <span class="hljs-keyword">return</span> query(k&lt;&lt;<span class="hljs-number">1</span>,l,mid)+query(k&lt;&lt;<span class="hljs-number">1</span>|<span class="hljs-number">1</span>,mid+<span class="hljs-number">1</span>,r); <span class="hljs-comment">//中线跨区间 </span>&#125;<span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span>&#123;<span class="hljs-keyword">while</span>(~<span class="hljs-built_in">scanf</span>(<span class="hljs-string">"%lld%lld"</span>,&amp;n,&amp;m))&#123;<span class="hljs-built_in">memset</span>(tree,<span class="hljs-number">0</span>,<span class="hljs-keyword">sizeof</span>(tree));<span class="hljs-keyword">for</span>(ll i=<span class="hljs-number">1</span>;i&lt;=n;i++)&#123;<span class="hljs-built_in">scanf</span>(<span class="hljs-string">"%lld"</span>,&amp;a[i]);&#125;build(<span class="hljs-number">1</span>,<span class="hljs-number">1</span>,n);<span class="hljs-keyword">for</span>(ll i=<span class="hljs-number">1</span>;i&lt;=m;i++)&#123;<span class="hljs-built_in">scanf</span>(<span class="hljs-string">"%s"</span>,ch);<span class="hljs-keyword">if</span>(ch[<span class="hljs-number">0</span>]==<span class="hljs-string">'Q'</span>)&#123;<span class="hljs-built_in">scanf</span>(<span class="hljs-string">"%lld%lld"</span>,&amp;b,&amp;e);<span class="hljs-comment">//printf("11");</span><span class="hljs-built_in">printf</span>(<span class="hljs-string">"%lld\n"</span>,query(<span class="hljs-number">1</span>,b,e));&#125;<span class="hljs-keyword">else</span> &#123;<span class="hljs-built_in">scanf</span>(<span class="hljs-string">"%lld%lld%lld"</span>,&amp;b,&amp;e,&amp;x);add(<span class="hljs-number">1</span>,b,e,x);&#125;&#125;&#125;&#125;</code></pre><h1 id="收获与反思"><a href="#收获与反思" class="headerlink" title="收获与反思"></a>收获与反思</h1><ul><li>注意数组不要越界，注意long long。</li><li>写模板注意sum的写法和取最大值的写法略有不同。</li><li>理解lazy（tag）标记，即访问到时才进行一次向下扩展，每次修改并不直接作用于叶子节点。</li></ul>]]></content>
    
    
    <categories>
      
      <category>Computer Science</category>
      
      <category>ACM</category>
      
      <category>POJ</category>
      
    </categories>
    
    
    <tags>
      
      <tag>ACM</tag>
      
      <tag>POJ</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>【HDU-1754】解题报告（线段树最大值，点维护）</title>
    <link href="/post/4e876bc2.html"/>
    <url>/post/4e876bc2.html</url>
    
    <content type="html"><![CDATA[<h1 id="原始题目"><a href="#原始题目" class="headerlink" title="原始题目"></a>原始题目</h1><h2 id="I-Hate-It"><a href="#I-Hate-It" class="headerlink" title="I Hate It"></a>I Hate It</h2><ul><li>Time Limit: 9000/3000 MS (Java/Others)    </li><li>Memory Limit: 32768/32768 K (Java/Others)</li><li>Total Submission(s): 92291    </li><li>Accepted Submission(s): 35036</li></ul><h3 id="Problem-Description"><a href="#Problem-Description" class="headerlink" title="Problem Description"></a>Problem Description</h3><p>很多学校流行一种比较的习惯。老师们很喜欢询问，从某某到某某当中，分数最高的是多少。<br>这让很多学生很反感。</p><p>不管你喜不喜欢，现在需要你做的是，就是按照老师的要求，写一个程序，模拟老师的询问。当然，老师有时候需要更新某位同学的成绩。</p><a id="more"></a> <h3 id="Input"><a href="#Input" class="headerlink" title="Input"></a>Input</h3><p>本题目包含多组测试，请处理到文件结束。<br>在每个测试的第一行，有两个正整数 N 和 M ( 0&lt;N≤200000,0&lt;M&lt;5000 )，分别代表学生的数目和操作的数目。<br>学生ID编号分别从1编到N。<br>第二行包含N个整数，代表这N个学生的初始成绩，其中第i个数代表ID为i的学生的成绩。<br>接下来有M行。每一行有一个字符 C (只取’Q’或’U’) ，和两个正整数A，B。<br>当C为’Q’的时候，表示这是一条询问操作，它询问ID从A到B(包括A,B)的学生当中，成绩最高的是多少。<br>当C为’U’的时候，表示这是一条更新操作，要求把ID为A的学生的成绩更改为B。</p><h3 id="Output"><a href="#Output" class="headerlink" title="Output"></a>Output</h3><p>对于每一次询问操作，在一行里面输出最高成绩。</p><h3 id="Sample-Input"><a href="#Sample-Input" class="headerlink" title="Sample Input"></a>Sample Input</h3><pre><code>5 61 2 3 4 5Q 1 5U 3 6Q 3 4Q 4 5U 2 9Q 1 5</code></pre><h3 id="Sample-Output"><a href="#Sample-Output" class="headerlink" title="Sample Output"></a>Sample Output</h3><pre><code>5659</code></pre><h3 id="Hint"><a href="#Hint" class="headerlink" title="Hint"></a>Hint</h3><p>Huge input,the C function scanf() will work better than cin</p><h3 id="Author"><a href="#Author" class="headerlink" title="Author"></a>Author</h3><p>linle</p><h3 id="Source"><a href="#Source" class="headerlink" title="Source"></a>Source</h3><p>2007省赛集训队练习赛（6）_linle专场</p><h3 id="Recommend"><a href="#Recommend" class="headerlink" title="Recommend"></a>Recommend</h3><p>lcy</p><h1 id="题目大意"><a href="#题目大意" class="headerlink" title="题目大意"></a>题目大意</h1><p>如中文</p><h1 id="解题思路"><a href="#解题思路" class="headerlink" title="解题思路"></a>解题思路</h1><p>线段树模板题，点修改，维护最大值</p><h1 id="解题代码"><a href="#解题代码" class="headerlink" title="解题代码"></a>解题代码</h1><pre><code class="hljs C++"><span class="hljs-meta">#<span class="hljs-meta-keyword">include</span> <span class="hljs-meta-string">&lt;cstdio&gt;</span></span><span class="hljs-meta">#<span class="hljs-meta-keyword">include</span> <span class="hljs-meta-string">&lt;cstring&gt;</span></span><span class="hljs-meta">#<span class="hljs-meta-keyword">include</span> <span class="hljs-meta-string">&lt;cmath&gt;</span></span><span class="hljs-meta">#<span class="hljs-meta-keyword">include</span> <span class="hljs-meta-string">&lt;cmath&gt;</span></span><span class="hljs-meta">#<span class="hljs-meta-keyword">include</span> <span class="hljs-meta-string">&lt;iostream&gt;</span></span><span class="hljs-meta">#<span class="hljs-meta-keyword">include</span> <span class="hljs-meta-string">&lt;iomanip&gt;</span></span><span class="hljs-meta">#<span class="hljs-meta-keyword">include</span> <span class="hljs-meta-string">&lt;string&gt;</span></span><span class="hljs-meta">#<span class="hljs-meta-keyword">include</span> <span class="hljs-meta-string">&lt;set&gt;</span></span><span class="hljs-meta">#<span class="hljs-meta-keyword">include</span> <span class="hljs-meta-string">&lt;queue&gt;</span></span><span class="hljs-meta">#<span class="hljs-meta-keyword">include</span> <span class="hljs-meta-string">&lt;vector&gt;</span></span><span class="hljs-meta">#<span class="hljs-meta-keyword">include</span> <span class="hljs-meta-string">&lt;map&gt;</span></span><span class="hljs-keyword">using</span> <span class="hljs-keyword">namespace</span> <span class="hljs-built_in">std</span>;<span class="hljs-keyword">const</span> <span class="hljs-keyword">int</span> maxn=<span class="hljs-number">2e5</span>+<span class="hljs-number">5</span>;<span class="hljs-keyword">int</span> n,m;<span class="hljs-keyword">int</span> d,x;<span class="hljs-keyword">int</span> a[maxn];<span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">node</span>&#123;</span><span class="hljs-keyword">int</span> l;<span class="hljs-keyword">int</span> r;<span class="hljs-keyword">int</span> maxnum;&#125;tree[maxn&lt;&lt;<span class="hljs-number">2</span>];<span class="hljs-keyword">char</span> ch[<span class="hljs-number">2</span>];<span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">build</span><span class="hljs-params">(<span class="hljs-keyword">int</span> k,<span class="hljs-keyword">int</span> l,<span class="hljs-keyword">int</span> r)</span> <span class="hljs-comment">//k为线段树的角标 </span></span>&#123;tree[k].l=l;tree[k].r=r;<span class="hljs-keyword">if</span>(l==r)&#123;tree[k].maxnum=a[l]=a[r];  <span class="hljs-comment">//叶子节点，单点的max值就是该点的值</span><span class="hljs-keyword">return</span> ; &#125;<span class="hljs-keyword">int</span> mid=(l+r)&gt;&gt;<span class="hljs-number">1</span>;build(k&lt;&lt;<span class="hljs-number">1</span>,l,mid); <span class="hljs-comment">//递归构建左线段（左子树） </span>build(k&lt;&lt;<span class="hljs-number">1</span>|<span class="hljs-number">1</span>,mid+<span class="hljs-number">1</span>,r);<span class="hljs-comment">//递归构建右线段（右子树） </span>tree[k].maxnum=max(tree[k&lt;&lt;<span class="hljs-number">1</span>].maxnum,tree[k&lt;&lt;<span class="hljs-number">1</span>|<span class="hljs-number">1</span>].maxnum); <span class="hljs-comment">//根节点的最大值是左右子树最大值的max </span><span class="hljs-keyword">return</span> ; &#125;<span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">change</span><span class="hljs-params">(<span class="hljs-keyword">int</span> k,<span class="hljs-keyword">int</span> d,<span class="hljs-keyword">int</span> x)</span></span>&#123;<span class="hljs-keyword">if</span>(tree[k].l==tree[k].r&amp;&amp;tree[k].r==d) <span class="hljs-comment">//找到索引点 </span>&#123;tree[k].maxnum=x; <span class="hljs-comment">//修改最大值</span><span class="hljs-keyword">return</span> ; <span class="hljs-comment">//修改后再开始回溯 </span>&#125; <span class="hljs-keyword">int</span> mid=(tree[k].l+tree[k].r)&gt;&gt;<span class="hljs-number">1</span>;<span class="hljs-keyword">if</span>(d&gt;=tree[k].l&amp;&amp;d&lt;=mid) <span class="hljs-comment">//查找点在左子树</span>change(k&lt;&lt;<span class="hljs-number">1</span>,d,x); <span class="hljs-comment">//k&lt;&lt;1为左子树,</span><span class="hljs-keyword">else</span> <span class="hljs-comment">//查找点在右子树， </span>change(k&lt;&lt;<span class="hljs-number">1</span>|<span class="hljs-number">1</span>,d,x); <span class="hljs-comment">//k&lt;&lt;1|1为右子树</span>tree[k].maxnum=max(tree[k&lt;&lt;<span class="hljs-number">1</span>].maxnum,tree[k&lt;&lt;<span class="hljs-number">1</span>|<span class="hljs-number">1</span>].maxnum);  <span class="hljs-comment">//递归从新计算非叶结点的值 </span>&#125;<span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">query</span><span class="hljs-params">(<span class="hljs-keyword">int</span> k,<span class="hljs-keyword">int</span> l,<span class="hljs-keyword">int</span> r)</span></span>&#123;<span class="hljs-keyword">int</span> maxnum;<span class="hljs-keyword">if</span>(tree[k].l==l&amp;&amp;tree[k].r==r)<span class="hljs-keyword">return</span> tree[k].maxnum;<span class="hljs-keyword">int</span> mid=(tree[k].l+tree[k].r)&gt;&gt;<span class="hljs-number">1</span>;<span class="hljs-keyword">if</span>(r&lt;=mid)maxnum=query(k&lt;&lt;<span class="hljs-number">1</span>,l,r);<span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span>(l&gt;=mid+<span class="hljs-number">1</span>)maxnum=query(k&lt;&lt;<span class="hljs-number">1</span>|<span class="hljs-number">1</span>,l,r);<span class="hljs-keyword">else</span> maxnum=max(query(k&lt;&lt;<span class="hljs-number">1</span>,l,mid),query(k&lt;&lt;<span class="hljs-number">1</span>|<span class="hljs-number">1</span>,mid+<span class="hljs-number">1</span>,r)); <span class="hljs-comment">//中线跨区间 </span><span class="hljs-keyword">return</span> maxnum;&#125;<span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span>&#123;<span class="hljs-keyword">while</span>(~<span class="hljs-built_in">scanf</span>(<span class="hljs-string">"%d%d"</span>,&amp;n,&amp;m))&#123;<span class="hljs-built_in">memset</span>(tree,<span class="hljs-number">0</span>,<span class="hljs-keyword">sizeof</span>(tree));<span class="hljs-keyword">for</span>(<span class="hljs-keyword">int</span> i=<span class="hljs-number">1</span>;i&lt;=n;i++)&#123;<span class="hljs-built_in">scanf</span>(<span class="hljs-string">"%d"</span>,&amp;a[i]);&#125;build(<span class="hljs-number">1</span>,<span class="hljs-number">1</span>,n);<span class="hljs-keyword">for</span>(<span class="hljs-keyword">int</span> i=<span class="hljs-number">1</span>;i&lt;=m;i++)&#123;<span class="hljs-built_in">scanf</span>(<span class="hljs-string">"%s%d%d"</span>,ch,&amp;d,&amp;x);<span class="hljs-keyword">if</span>(ch[<span class="hljs-number">0</span>]==<span class="hljs-string">'Q'</span>) <span class="hljs-comment">//查询输入</span>&#123;<span class="hljs-built_in">printf</span>(<span class="hljs-string">"%d\n"</span>,query(<span class="hljs-number">1</span>,d,x)); &#125; <span class="hljs-keyword">else</span> change(<span class="hljs-number">1</span>,d,x);&#125;&#125;&#125;</code></pre><h1 id="收获与反思"><a href="#收获与反思" class="headerlink" title="收获与反思"></a>收获与反思</h1><ul><li>对模板的理解都写在注释里了</li><li>本题是维护最大值，可以用int替换ll</li><li>切记memset数组</li></ul>]]></content>
    
    
    <categories>
      
      <category>Computer Science</category>
      
      <category>ACM</category>
      
      <category>HDU</category>
      
    </categories>
    
    
    <tags>
      
      <tag>ACM</tag>
      
      <tag>HDU</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>【CSU-1977】解题报告（二进制，位运算，读题》</title>
    <link href="/post/4f352d.html"/>
    <url>/post/4f352d.html</url>
    
    <content type="html"><![CDATA[<h1 id="原始题目"><a href="#原始题目" class="headerlink" title="原始题目"></a>原始题目</h1><h2 id="Bit-reversal-Permutation"><a href="#Bit-reversal-Permutation" class="headerlink" title="Bit-reversal Permutation"></a>Bit-reversal Permutation</h2><ul><li>Time Limit: 1 Sec     </li><li>Memory Limit: 128 Mb     </li><li>Submitted: 81     </li><li>Solved: 27</li></ul><h3 id="Description"><a href="#Description" class="headerlink" title="Description"></a>Description</h3><p>A fast Fourier transform (FFT) algorithm computes the discrete Fourier transform (DFT) of a sequence, or its inverse (IFFT). Fourier analysis converts a signal from its original domain (often time or space) to a representation in the frequency domain and vice versa. An FFT rapidly computes such transformations by factorizing the DFT matrix into a product of sparse (mostly zero) factors. As a result, it manages to reduce the complexity of computing the DFT from O(n2), which arises if one simply applies the definition of DFT, to O(nlogn), where n is the data size.    ——From Wikipedia</p><a id="more"></a><p>During this summer holiday, csuxushu feels so bored to learn FFT. Because FFT is a complicated algorithm, he need to apply a bit-reversal permutation to a sequence first before DFT which is a part of FFT.</p><p>In applied mathematics, a bit-reversal permutation is a permutation of a sequence of n items, where n = 2^k is a power of two. It is defined by indexing the elements of the sequence by the numbers from 0 to n − 1 and then reversing the binary representations of each of these numbers (padded so that each of these binary numbers has length exactly k). Each item is then mapped to the new position given by this reversed value.</p><p>Because all fellows in CSU(California State University ) can apply FFT, NTT or even FWT, it is a shame that he even doesn’t know how to take the first step. As one of the best computer programmer in CSU, can you help him?</p><p>You may think this problem is too hard to solve. In fact, it is a piece of cake to you. Remember to see the hint :-)</p><h3 id="Input"><a href="#Input" class="headerlink" title="Input"></a>Input</h3><p>The first line of the input gives the number of test cases T(T≤10); T test cases follow.Each test case contains a number sequence.<br>In each case, the first line is a number N(1≤N≤10^5), the number of elements in the following sequence.The second line is the sequence.Its length may not be exactly a power of two, so you can append some zeros to make it the minimal power of two larger than or equal to N.</p><h3 id="Output"><a href="#Output" class="headerlink" title="Output"></a>Output</h3><p>For each test case, output the sequence from input in bit-reversal order.</p><h3 id="Sample-Input"><a href="#Sample-Input" class="headerlink" title="Sample Input"></a>Sample Input</h3><pre><code>1621 58 96 12 45 65</code></pre><h3 id="Sample-Output"><a href="#Sample-Output" class="headerlink" title="Sample Output"></a>Sample Output</h3><pre><code>21 45 96 0 58 65 12 0</code></pre><h3 id="Hint"><a href="#Hint" class="headerlink" title="Hint"></a>Hint</h3><p>Bit-reverse Order</p><p>（图片待添加）</p><p>中文提示：可以看到，我们最终处理的系数从左至右的编号的二进制形式分别为000,100,010,110,001,101,011,111，若将其二进制反序，可得000,001,010,011,100,101,110,111，这些反序的二进制编码是从小到大排列的。也就是说，我们可以按照每个下标的二进制编码来确定处理系数的顺序。这种方法就称为位逆序置换(Bit-reversal permutation)。</p><h3 id="Source"><a href="#Source" class="headerlink" title="Source"></a>Source</h3><p>2017年8月月赛</p><h3 id="Author"><a href="#Author" class="headerlink" title="Author"></a>Author</h3><p>徐戍</p><h1 id="题目大意"><a href="#题目大意" class="headerlink" title="题目大意"></a>题目大意</h1><p>将给定序列按位反转后的顺序输出</p><h1 id="解题思路"><a href="#解题思路" class="headerlink" title="解题思路"></a>解题思路</h1><p>看中文提示和图示就能不明白，将序列顺序（从0开始）用二进制位表示后位反转，按反转后从小到大顺序输出。</p><h1 id="解题代码"><a href="#解题代码" class="headerlink" title="解题代码"></a>解题代码</h1><pre><code class="hljs C++"><span class="hljs-meta">#<span class="hljs-meta-keyword">include</span> <span class="hljs-meta-string">&lt;cstdio&gt;</span></span><span class="hljs-meta">#<span class="hljs-meta-keyword">include</span> <span class="hljs-meta-string">&lt;cstring&gt;</span></span><span class="hljs-meta">#<span class="hljs-meta-keyword">include</span> <span class="hljs-meta-string">&lt;set&gt;</span></span><span class="hljs-meta">#<span class="hljs-meta-keyword">include</span> <span class="hljs-meta-string">&lt;cmath&gt;</span></span><span class="hljs-meta">#<span class="hljs-meta-keyword">include</span> <span class="hljs-meta-string">&lt;map&gt;</span></span><span class="hljs-meta">#<span class="hljs-meta-keyword">include</span> <span class="hljs-meta-string">&lt;queue&gt;</span></span><span class="hljs-meta">#<span class="hljs-meta-keyword">include</span> <span class="hljs-meta-string">&lt;algorithm&gt;</span></span><span class="hljs-meta">#<span class="hljs-meta-keyword">include</span> <span class="hljs-meta-string">&lt;map&gt;</span></span><span class="hljs-keyword">using</span> <span class="hljs-keyword">namespace</span> <span class="hljs-built_in">std</span>;<span class="hljs-keyword">const</span> <span class="hljs-keyword">int</span> maxn=<span class="hljs-number">2e5</span>+<span class="hljs-number">5</span>;<span class="hljs-keyword">int</span> raw[maxn];<span class="hljs-keyword">int</span> t;<span class="hljs-keyword">int</span> m,n;<span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span>&#123;<span class="hljs-keyword">while</span>(~<span class="hljs-built_in">scanf</span>(<span class="hljs-string">"%d"</span>,&amp;t))&#123;<span class="hljs-keyword">while</span>(t--)&#123;<span class="hljs-built_in">scanf</span>(<span class="hljs-string">"%d"</span>,&amp;m);&#123;n=<span class="hljs-number">0</span>;<span class="hljs-built_in">memset</span>(raw,<span class="hljs-number">0</span>,<span class="hljs-keyword">sizeof</span>(raw));<span class="hljs-keyword">while</span>(<span class="hljs-built_in">pow</span>(<span class="hljs-number">2</span>,n)&lt;m) n++;<span class="hljs-keyword">for</span>(<span class="hljs-keyword">int</span> i=<span class="hljs-number">0</span>;i&lt;m;i++)&#123;<span class="hljs-built_in">scanf</span>(<span class="hljs-string">"%d"</span>,&amp;raw[i]);&#125;<span class="hljs-keyword">int</span> len=<span class="hljs-built_in">pow</span>(<span class="hljs-number">2</span>,n);<span class="hljs-keyword">for</span>(<span class="hljs-keyword">int</span> i=<span class="hljs-number">0</span>;i&lt;len;i++)&#123;<span class="hljs-keyword">int</span> bit=<span class="hljs-number">0</span>,b=i;<span class="hljs-keyword">for</span>(<span class="hljs-keyword">int</span> j=<span class="hljs-number">0</span>;j&lt;n;j++)&#123;bit=bit|(b&amp;<span class="hljs-number">1</span>);b&gt;&gt;=<span class="hljs-number">1</span>;bit&lt;&lt;=<span class="hljs-number">1</span>;&#125;<span class="hljs-comment">//printf("bit=%d\n",bit);</span>bit&gt;&gt;=<span class="hljs-number">1</span>;<span class="hljs-keyword">if</span>(i==<span class="hljs-number">0</span>) <span class="hljs-built_in">printf</span>(<span class="hljs-string">"%d"</span>,raw[bit]);<span class="hljs-keyword">else</span> <span class="hljs-built_in">printf</span>(<span class="hljs-string">" %d"</span>,raw[bit]);&#125;<span class="hljs-built_in">printf</span>(<span class="hljs-string">"\n"</span>);&#125;&#125;&#125;&#125;</code></pre><h1 id="收获与反思"><a href="#收获与反思" class="headerlink" title="收获与反思"></a>收获与反思</h1><p>用二进制计算方法（按位与、按位或、左移右移），来替代pow(2,n)。否则超时<br>比如将序号进行位反转后再十进制化的代码。</p><pre><code>// b为原始序列号 bit为位反转再十进制化的序列号int bit=0,b=i;for(int j=0;j&lt;n;j++){    bit=bit|(b&amp;1);    b&gt;&gt;=1;    bit&lt;&lt;=1;}</code></pre><p>这一过程不要用</p><pre><code>int bit=0,b=i;for(int j=0;j&lt;n;j++){    if(b&amp;1) bit+=pow(n-1-j);    b/=2;}//乘方会慢很多很多</code></pre>]]></content>
    
    
    <categories>
      
      <category>Computer Science</category>
      
      <category>ACM</category>
      
      <category>CSU</category>
      
    </categories>
    
    
    <tags>
      
      <tag>ACM</tag>
      
      <tag>CSU</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>《1Q84》读书笔记</title>
    <link href="/post/280fbdcb.html"/>
    <url>/post/280fbdcb.html</url>
    
    <content type="html"><![CDATA[<h1 id="内容摘录"><a href="#内容摘录" class="headerlink" title="内容摘录"></a>内容摘录</h1><h2 id="第一部"><a href="#第一部" class="headerlink" title="第一部"></a>第一部</h2><blockquote><p>P371 “世界这个东西，青豆啊，就是一种记忆和相反的另一种记忆永无休止的斗争。”</p></blockquote><h2 id="第二部"><a href="#第二部" class="headerlink" title="第二部"></a>第二部</h2><blockquote><p>P262  “人的生命虽然本质上是孤独的存在，却不是孤立的存在。”</p><p>P270  “但店内除了天吾，只有一对像是大学生的青年男女并肩坐在吧台前，正在交头接耳，起劲地说着悄悄话。望着他们，天吾感到了许久不曾有过的深深地寂寞。在这个世界上，自己是孤独的，和谁都没有关联。”</p><p>P274  “我当时看见了月亮。青豆也看见了同一个月亮。浮在下午三点半依然十分明亮的天上的灰色岩块。沉默而孤独的卫星。两人并肩而立，望着那个月亮。但是，那究竟意味着什么？难道月亮会领我去青豆所在的地方吗？”</p><p>P276 “天吾专注着望着月光，心中从远古时代传承下来的记忆般的东西被唤醒了。远在人类获得火、工具和语言之前，月亮就始终不变地是人们的朋友。它作为天赐地灯火，不时照亮黑暗的世界，缓解了人们的恐惧。它地圆缺给了人们时间观念。对月亮这种无偿地感谢之情，纵然在黑暗已从绝大部分地域驱逐的现在，似乎依然牢牢烙印在人类的遗传因子里。作为一种温暖的集体记忆。”</p></blockquote><a id="more"></a> <blockquote><p>P311 “我隔着一条马路看到了她，还因为可能被他拥入怀中而颤抖。虽说只有几分钟，我毕竟也全身心地题为过那种激烈的喜悦和期待。她闭上眼睛，紧攥着滑梯的扶手，咬住嘴唇。”</p><p>P312 “不过这将无所谓。我将为他而死。我不能为自己而活，这种可能性从一开始就被剥夺了。可是，我却能为他而死。这样就够了。我可以微笑着去死。 这不是谎言。”</p><p>P338 “他像被遗弃在风暴逝去后的静谧中，无法在任何事物上集中精神。”</p><p>P341 “父亲依旧纹丝不动，他的双眼被牢牢封闭在那黑暗地深坑底部，望去仿佛在静静地等待降雪，将深坑填成白色。”</p></blockquote><p>Emmm…我喜欢带鼓点的纯音乐，因为在不知哪个关键的时刻，想起的鼓点声总能巧妙地切合这个场景。</p><blockquote><p>P350 “这二十年间，他心里时时刻刻装着这位少女的面容。    青豆，天吾叫出声来。    少女沉在深深的睡眠中。似乎是很深的自然的睡眠，连呼吸都极其微弱。她的心脏也只是轻微地鼓动着，虚幻得传不到人的耳朵里。甚至连抬起眼睑得力量都没有……青豆在遥远的地方听见了这呼唤。天吾君，她在心中念道，还清晰地呼出声来。但这句话却不会掀动躺在空气蛹中少女的嘴唇，也不会传入天吾的耳朵。”</p></blockquote>]]></content>
    
    
    <categories>
      
      <category>Life</category>
      
      <category>阅读</category>
      
    </categories>
    
    
    <tags>
      
      <tag>阅读</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>《黑豹》观后感</title>
    <link href="/post/4255f31a.html"/>
    <url>/post/4255f31a.html</url>
    
    <content type="html"><![CDATA[<p>总的来说，是近几年漫威出的质量比较高的一部电影了，没有过分卖腐，卖情怀。一点点人格之间的矛盾，一点点反思，剧情衔接也很不错，虽然有一点套路，但是在可接受的范围内。</p><a id="more"></a> <p>表弟Killmonger让我想起了铁血孤儿团三日月一众人，还有麦基利斯。悲情么？悲情。可惜么？不可惜。他们的行为注定是孤独的悲情的，但欣慰的是他们的死亡是注入世界的一剂良药，让目睹他们死亡的人能感受到他们心中那一点点不同，然后做出改变（就像黑豹和艾里安议长）。或许人们不会记得他们，但历史会。</p><p>黑豹带表弟去看生命中第一次也是最后一次瓦坎达的日落，是为自己的父亲赎罪，也是对叔叔的缅怀。他将不在时电影开头的那个黑豹，从此，父亲与叔叔的两种感情将汇聚在他一人身上。月型草被一把火烧了个干干净净，或许他死后也不会再去自己父亲那里了吧。</p><p>但是表弟最后嘴里说出的那句“不自由，毋宁死”确实是把原文的意思曲解了。去Google了一下。原句是这样的 “Bury me in the ocean with my ancestors who jumped from ships, cause they knew death was better than bondage,”  我个人更倾向于表弟想表达的是：不愿意在此处与瓦坎达独享安宁（在他眼里是一种绑架，被历史、被先祖的传统绑架），的不自由（矛盾的焦点不在于他们是否拥有走出瓦坎达的边境的freedom，而在于是否应该向外输出自己的科技，武装世界其他角落受压迫的黑人对）。而且，“不自由，毋宁死.”这一句本是美国独立战争时期，Patrick Henry在弗吉尼亚议会演讲的最后一句“Give me liberty or give me death.”的翻译。</p><p>忙里偷闲独自看一场电影，还不错。</p>]]></content>
    
    
    <categories>
      
      <category>Life</category>
      
      <category>影视</category>
      
    </categories>
    
    
    <tags>
      
      <tag>影视</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>《亲爱的安德烈》读书笔记</title>
    <link href="/post/fd581850.html"/>
    <url>/post/fd581850.html</url>
    
    <content type="html"><![CDATA[<h1 id="内容摘录"><a href="#内容摘录" class="headerlink" title="内容摘录"></a>内容摘录</h1><h3 id="认识一个十八岁的人"><a href="#认识一个十八岁的人" class="headerlink" title="认识一个十八岁的人"></a>认识一个十八岁的人</h3><blockquote><p>P4 “虽然心中有爱，但是爱，冻结在经年累月的沉默里，好像一个疼痛的伤口，没有纱布可绑。”</p><p>P5 “我们是两代人，中间隔个三十年。我们也是两国人，中间隔个东西文化。我们原来也可能再他十八岁那年，就像水上浮萍一样各自荡开，从此天涯淡泊。    日后的人生旅程，当然还是要漂萍离散——人生哪有恒长的厮守？但是三年的海上旗语，茹月色满怀，我还奢求什么呢。”</p></blockquote><h3 id="第1封信-十八岁那一年"><a href="#第1封信-十八岁那一年" class="headerlink" title="第1封信 十八岁那一年"></a>第1封信 十八岁那一年</h3><blockquote><p>P13 “那‘愚昧无知’的渔村，确实没有给我知识，但是给了我一种能力，悲悯同情的能力。”</p><p>P14 “你们这一代‘定锚’的价值是什么？终极的关怀是什么？你认为美丽的热带鱼游泳也要在P乎方向吗？或者，你要挑衅地说，这是一个无谓的问题，因为热带鱼只为自己而活？”</p></blockquote><h3 id="第3封信-逃避国家"><a href="#第3封信-逃避国家" class="headerlink" title="第3封信 逃避国家"></a>第3封信 逃避国家</h3><blockquote><p>P21 “觉得德国是个不错得国家这种感觉是没有人敢显露，大家都要藏起来的。”</p><p>P25 “如果是五十个德国人在街上大喊‘德国第一；’德国万岁‘，会把人给吓死，第二天可以上《纽约时报》了，对吧？”</p></blockquote><a id="more"></a> <h3 id="第5封信-对玫瑰花的反抗"><a href="#第5封信-对玫瑰花的反抗" class="headerlink" title="第5封信 对玫瑰花的反抗"></a>第5封信 对玫瑰花的反抗</h3><blockquote><p>P37 “玩，可以说是天地间学问的根本。”</p></blockquote><h3 id="第6封信-一切都是小小地"><a href="#第6封信-一切都是小小地" class="headerlink" title="第6封信 一切都是小小地"></a>第6封信 一切都是小小地</h3><blockquote><p>P41 “每个人都在走自己的路，每个人都在选择自己的品味， 搞自己的游戏，设定自己的对和错的标准，一切都是小小的、个人的，因为，我们的时代已经不在有’伟大‘的任何特征。”</p></blockquote><h3 id="第7封信-有没有时间革命？"><a href="#第7封信-有没有时间革命？" class="headerlink" title="第7封信 有没有时间革命？"></a>第7封信 有没有时间革命？</h3><blockquote><p>P48 “这世上/没有真实世界这回事/只有谎言/迫使你设法穿越”</p></blockquote><h3 id="第8封信-我是个百分之百的混蛋"><a href="#第8封信-我是个百分之百的混蛋" class="headerlink" title="第8封信 我是个百分之百的混蛋"></a>第8封信 我是个百分之百的混蛋</h3><blockquote><p>P56 “世界上那么多不公正的存在，怎么可能没有‘反叛’的需要？所差的只不过在于你是否愿意看见，是否愿意站起来，行动不行动而已”</p><p>P56 “至少，我清楚看见自己的生存状态，而且至少，我并不以我的生存状态为荣。”</p></blockquote><h3 id="第9封信-两种道德"><a href="#第9封信-两种道德" class="headerlink" title="第9封信 两种道德"></a>第9封信 两种道德</h3><blockquote><p>P63 “这些国家里的人民，准许，或说要求，他们的政府把大量的钱，花在离他们很遥远但是贫病交迫的人们身上。”</p></blockquote><h3 id="第11封信-阳光照进你的路"><a href="#第11封信-阳光照进你的路" class="headerlink" title="第11封信 阳光照进你的路"></a>第11封信 阳光照进你的路</h3><blockquote><p>P79  “对美的迷恋可以打败任何智者自以为是的心得报告。我只能让你跌倒，看着你跌倒，只能希望你会在跌倒的地方爬起来，希望阳光照过来，照亮你藏着忧伤的心，照亮你眼前看不见尽头的路。”</p></blockquote><h3 id="第13封信-向左走，向右走"><a href="#第13封信-向左走，向右走" class="headerlink" title="第13封信 向左走，向右走"></a>第13封信 向左走，向右走</h3><blockquote><p>P93 “然而母亲想念成长的孩子，总是单向的；充满青春活力的孩子奔向他人生的愿景，眼睛热切望着前方，母亲只能在后头张望他越来越小的背影，揣摩，那地平线有多远，有多长，怎么一下子，就看不见了。”</p></blockquote><h3 id="第14封信-秘密的、私己的美学"><a href="#第14封信-秘密的、私己的美学" class="headerlink" title="第14封信 秘密的、私己的美学"></a>第14封信 秘密的、私己的美学</h3><blockquote><p>P101 “流行文化经过时间的筛子，泥沙被淘汰，金块被留下，留下的就叫做经典或古典……” （文化，大浪淘沙）</p></blockquote><h3 id="第16封信-藏在心中的小镇"><a href="#第16封信-藏在心中的小镇" class="headerlink" title="第16封信 藏在心中的小镇"></a>第16封信 藏在心中的小镇</h3><blockquote><p>P112 “所以我坐在这阳台上，细细回想我们共有的美好时光，把回忆拥在心里，是得往前走，但是直到我从哪里来。”</p></blockquote><h3 id="第17封信-你是哪国人？"><a href="#第17封信-你是哪国人？" class="headerlink" title="第17封信 你是哪国人？"></a>第17封信 你是哪国人？</h3><blockquote><p>P116 “‘逃民’被时代的一把剑切断了她和土地、和传统、和宗族友群的连结韧带，她漂浮，她悬在半空中，因为，她也许对这个世界看得特别透彻，因为她不在友群里，视线不被挡住，但是她处在一种灵魂的孤独中。”</p><p>P116 “她不要你和她一样，做一个灵魂的漂泊者——那也许是文学的美好境界，却是生活的苦楚。”</p><p>P118 “可是不管国家这种单位发生了什么根本的变化，有了或没了，兴盛了或灭亡了，变大了或变小了，安德烈，小镇不会变。泥土和记忆不会变。    我很欢喜你心中有一个小镇，在你驶向大海远走高飞之前。”</p></blockquote><h3 id="第20封信-在一个没有咖啡馆的城市里"><a href="#第20封信-在一个没有咖啡馆的城市里" class="headerlink" title="第20封信 在一个没有咖啡馆的城市里"></a>第20封信 在一个没有咖啡馆的城市里</h3><blockquote><p>P134 “酒吧跟咖啡馆，在欧洲，其实就是社区文化。朋友跟街坊邻居习惯去那里聊天，跟老板及侍者也像老友。香港却显得很‘浅’——不知道这个词用得对不对。这里没有咖啡馆，只有蹩脚的连锁店星巴克和太平洋咖啡，要不然就是贵的要死其实根本不值得的大饭店。”</p><p>P135 “人跟人之间愿意花时间交流，坐下来为了喝咖啡而喝咖啡，为了聊天而聊天，在欧洲是生活很大的一部分，是很重要得一种生活艺术。香港没有这样的生活艺术。”</p></blockquote><h3 id="第21封信-文化，因为逗留"><a href="#第21封信-文化，因为逗留" class="headerlink" title="第21封信 文化，因为逗留"></a>第21封信 文化，因为逗留</h3><p>香港印象</p><blockquote><p>P144 “那天很热，我背着很重的书，一条街一条街寻找，以为和台北一样，转个弯一定可以看到。可是没有。真的没有。去茶餐厅吧，可是那是一个油腻腻、甜滋滋得地方，匆忙拥挤而喧嚣，有人硬是站在你旁边瞅着你的位子。去星巴克或太平洋吧，可是你带着对跨国企业垄断得不满，疑惧他们对本土产业的消灭。不情愿在那里消费。”</p><p>P145 “我们在谈的这个所谓‘咖啡馆’，当然不只是一个卖咖啡得的地方，它是一个‘个人’开的小馆<br>，意思是，老板不是一个你看不见摸不着的抽象财团，因此小馆里处处洋溢着小店主人的气质和个性；它是社区的公共‘客厅’，是一个荒凉的大城市里最温暖的小据点。来喝咖啡的人彼此面熟，老板的绰号人人知道。如果因缘际会，来这里的人多半是创作者——作家、导演、学者、反对运动家……那么咖啡馆就是这个城市的文化舞台。”</p><p>P146 “这个城市，连群众示威的大广场都没有。群众示威，和咖啡馆酒吧里的彻夜闲聊一样，是培养社区共识的行为，对加深文化认同多么关键。示威游行，绝对是极其重要的一种‘逗留文化’。但是，香港是个没有闲人，‘请勿逗留’的城市。”</p></blockquote><h3 id="第22封信-谁说香港没文化？"><a href="#第22封信-谁说香港没文化？" class="headerlink" title="第22封信 谁说香港没文化？"></a>第22封信 谁说香港没文化？</h3><blockquote><p>P156 （读者来信）“在你们的文章中，一再提到咖啡馆，并说明欧洲的咖啡馆出过多少名人。我想来想去，的确想不出，中国历史上这么多著名的文人学者，有谁是在咖啡馆完成大作的。但，他们就因为没有在咖啡馆沉思过，就不能获得你们的认同吗？今天和今后，东方的咖啡馆还是无法和西方咖啡馆相比，但东方的文化今天的成就与未来，就肯定将因此而逊色和不被看好吗？”<br>（个人感触：龙应台先生和安德烈先生来往信件中提到的咖啡馆，代表这一类能给人以文化气息，静下来逗留的场所。既然台北和香港都属于东方地域中受西方文化影响最为深远的城市，作为西方许多文化甚至文明诞生发展的一大影响因素，分布在各个城市角落里的这些充满个人气息的“咖啡厅”，理应也被吸纳进两个城市的发展洪流中。然而事实是，并没有。不知道是怎样的一种过滤方式，这些文明根源的事物就这么被无情的抛掉了，不禁令人遗憾和惋惜。诸子百家以及之后几百年内的各个中国古代先贤，自然不是在咖啡厅里完成自己的大作的，可以是旷野的星空下，可以是周游马车上，但无疑，他们需要这样一个与他人，或者与自我，静下来，慢慢交流咀嚼的契机。西方的工业革命把生产力水平不知翻了多少倍，人们的生活节奏也自然被迫推着加速着，加速着。但是就是这么神奇，历史的车轮再快，也巧妙地避开了城市地一个个咖啡厅，保留了这一份每个人奢求地文化角落，这种保留是奢侈的，也是必要的。）</p></blockquote><h3 id="第26封信-孩子，你喝哪瓶奶？"><a href="#第26封信-孩子，你喝哪瓶奶？" class="headerlink" title="第26封信 孩子，你喝哪瓶奶？"></a>第26封信 孩子，你喝哪瓶奶？</h3><blockquote><p>P177 “你从坏的吃起，到明天，那好的也逐渐变坏了，结果你就一路在追赶那坏的，你永远在吃那不新鲜的苹果。你为什么不能就直接享受那最好的呢？”</p><p>P179 “请问品味是什么？它不就是细致的分辨、性格的突出，以及独立个体的呈现吗？每一件，都正好是贫穷所吝啬给你的，也是威权政治所剥夺于你的。”</p><p>P180 “如果太好的环境赋予了你美感和品味，那么它剥夺了你些什么？你的一切，是否其实有另一种的‘贫穷’？”</p></blockquote><h3 id="第28封信-给河马刷牙"><a href="#第28封信-给河马刷牙" class="headerlink" title="第28封信 给河马刷牙"></a>第28封信 给河马刷牙</h3><blockquote><p>P195 “对我最重要的，安德烈，不是你有否成就，而是你是否快乐。而在现代的生活架构里，什么样的工作比较可能给你快了？第一，它给你意义；第二，它给你时间。你的工作是你觉得有意义的，你的工作不绑架你使你成为工作的俘虏，容许你去充分体验生活，你就比较可能是快乐的。至于金钱和名声，哪里是快乐的核心元素呢？假定说，横在你眼前的选择，是到华尔街做银行经理或者到动物园做照顾狮子、河马的管理员，而你是一个喜欢动物研究的人，我就完全不认为银行经理比较有成就，或者狮子、河马的管理员‘平庸’。每天为钱的数字起伏而紧张而斗争，很可能不如每天给大象洗澡，给河马刷牙。”</p><p>P195 “当你的工作在你心目中有意义，你就有成就感。当你的工作给你时间，不剥夺你的生活，你就有尊严。成就感和尊严，给你快乐。”</p><p>P195 “我怕你变成画长颈鹿的提摩，不是因为他没钱没名，而是因为他找不到意义。我也要求你读书用功，不是因为我要你跟别人比成就，而是因为，我希望你将来会拥有选择的权利，选择有意义、有时间的工作，而不是被迫谋生。”</p><p>P195 “如果我们不是在跟别人比名比利，而只是为自己找心灵安适之所在，那么连‘平庸’这个词都不太有意义了。‘平庸’是跟别人比，心灵的安适是跟自己比。我们最终极的负责对象，安德烈，千山万水走到最后，还是‘自己’二字。因此，你当然更没有理由去跟你的上一代比，或者为了符合上一代对你的想象而活。”</p></blockquote><h3 id="第29封信-第二颗眼泪"><a href="#第29封信-第二颗眼泪" class="headerlink" title="第29封信 第二颗眼泪"></a>第29封信 第二颗眼泪</h3><blockquote><p>Kitsch让两颗眼泪快速出场。第一颗眼泪说：孩子在草地上跑，太感动了！第二颗眼泪说，孩子在草地上跑，被感动的感觉实在太棒了。跟全人类一起被感动，尤其棒！<br>使Kitsch成为Kitsch的，使那第二颗眼泪。——《生命中不能承受之轻》</p><p>“还好昆德拉说，那第一颗眼泪不是，第二颗才是Kitsch。”</p></blockquote><h3 id="第31封信-两只老虎跑得慢、跑得快"><a href="#第31封信-两只老虎跑得慢、跑得快" class="headerlink" title="第31封信 两只老虎跑得慢、跑得快"></a>第31封信 两只老虎跑得慢、跑得快</h3><blockquote><p>“‘你以后一定不能忍受城乡差距、贫富不均所带来的不公平。’也就是说，‘失败启蒙’给我的教训，不是打入‘成功者’的行列，而是，你要去挑战，去质疑‘成功者’的定义。”</p></blockquote><h3 id="第33封信-人生诘问"><a href="#第33封信-人生诘问" class="headerlink" title="第33封信 人生诘问"></a>第33封信 人生诘问</h3><blockquote><p>“安德烈：我想知道，你怎么面对人家总是期待你有思想、有智慧这个现实？    安德烈，一半的人在赞美我的同时，总有另外一半的人在批判我。我有充分机会学习如何‘宠辱不惊’。至于人们的‘期待’，那是一种你自己必须学会去‘抵御’的东西，因为那个东西是最容易把你绑死的圈套。不知道就不要说话，傻就不假装聪明。你现在明白为何我推掉几乎所有的演讲、座谈、上电视的邀请吧？我本来就没那么多知识和智能可以天天去讲。”</p></blockquote><h3 id="第35封信-独立宣言"><a href="#第35封信-独立宣言" class="headerlink" title="第35封信 独立宣言"></a>第35封信 独立宣言</h3><blockquote><p>不繁文缛节，却也不失礼貌，给人以必要的人格尊重，这就是你要做的。</p></blockquote><h3 id="在时光里"><a href="#在时光里" class="headerlink" title="在时光里"></a>在时光里</h3><blockquote><p>“‘马克·吐温说，’安德烈伸手拿起一粒绿色的橄榄，放在嘴里，似乎在品尝，然后慢条斯理地说，‘我评判一个人的品格，不看他如何对待比他地位高地人，我看他如何对待比他地位低地人。’”</p></blockquote>]]></content>
    
    
    <categories>
      
      <category>Life</category>
      
      <category>阅读</category>
      
    </categories>
    
    
    <tags>
      
      <tag>阅读</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>《岛上书店》读书笔记</title>
    <link href="/post/11246bdd.html"/>
    <url>/post/11246bdd.html</url>
    
    <content type="html"><![CDATA[<h1 id="书中书目"><a href="#书中书目" class="headerlink" title="书中书目"></a>书中书目</h1><ul><li>P97《白鲸》 赫尔曼·麦尔维尔</li><li>P99《古拉格群岛》 索尔仁尼琴</li><li>P99《纳尼亚传奇》系列 C.S.刘易斯</li><li>P107 《洛城机密》詹姆斯·埃尔罗伊 犯罪小说</li><li>P119 《真爱如血》电视剧</li><li>P132 《好人难寻》弗兰纳里·奥康纳</li><li>P135 《卡拉维拉显驰名的跳蛙》 马克吐温</li></ul><a id="more"></a><ul><li>P135 《所罗门之歌》 托妮·莫里森</li><li>P135 《奥丽芙·基特里奇》 伊丽莎白·斯特鲁特</li><li>P183 《与父亲的对话》 格蕾斯·佩利</li><li>P197 《逮香蕉鱼的最佳日子》 J.D.塞林格（A.J.谈到对玛雅作品的建议，移情，为什么人们会做他们想做的事？</li><li>P209 《泄密的心》 埃德加·爱伦·坡</li><li>P213 《我们的小镇》 桑顿·怀尔德</li><li>P216 《德伯家的苔丝》《约翰尼上战场》《永别了，武器》《为欧文·米尼起到》《呼啸山庄》《织工马南》《他们眼望上苍》《我们的秘密城堡》</li><li>P223 《铁头》 艾梅·本德</li><li>P235 《追忆似水年华》 马塞尔·普鲁斯特</li><li>P246 《尘雾家园》 安德烈·迪比三世</li><li>P249 《当我们谈论爱情时我们再谈论什么》 雷蒙德·卡佛</li><li>P257 《书店老板》 罗尔德·达尔</li><li>P269 《美国众神》尼尔·盖曼</li></ul><p>因为从心底害怕自己不值得被爱，我们独来独往，<br>然而就是因为独来独往，才让我们以为自己不值得被爱。<br>有一天，你不知道是什么时候，你会驱车上路。<br>有一天，你不知道是什么时候，你会遇到他（她）。<br>你会被爱，因为你今生第一次真正不再孤单。<br>你会选择不在孤单下去。</p><h1 id="内容摘录"><a href="#内容摘录" class="headerlink" title="内容摘录"></a>内容摘录</h1><blockquote><p>P210 “一个地方如果没有一家书店，就算不上个地方了。” （AJ 和妮可）</p><p>P266 “没有书店的地方算不上是个地方。”（兰比亚斯和伊斯梅）</p><p>P261</p></blockquote><pre><code>他会再试试，他永远不会放弃尝试。“玛雅，我们会成为我们所爱的那样。是爱成就了我们。”玛雅在摇头。“爸爸，对不起，我听不明白。”“我们不是我们所收集的、得到的、所读的东西，只要我们还或者，我们就是爱，我们所爱的事物，我们所爱的人。所有这些，我认为真的会存活下去。”她还在摇头。“我听不懂你的话，爸爸。我希望我能。你想让我找艾米吗？要么也许你可以打出来？”他在冒汗。交谈不再是有趣的，以前曾经很容易。好吧，他想。如果必须用一个单词，那就必须用一个单词吧。”爱？”他问。他祈祷自己说得对。她皱起眉头，努力去辨读他的表情。“手套？”她问，“是你的手冷吗，爸爸？”她点点头。她把她的手放在她手里。他的手本来冷，这时暖和了，他想好了今天说的够接近了。也许明天，他就能知道该怎么说了。</code></pre>]]></content>
    
    
    <categories>
      
      <category>Life</category>
      
      <category>阅读</category>
      
    </categories>
    
    
    <tags>
      
      <tag>阅读</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>《1988：我想和这个世界谈谈》读书笔记</title>
    <link href="/post/fdc06f3f.html"/>
    <url>/post/fdc06f3f.html</url>
    
    <content type="html"><![CDATA[<h1 id="内容摘录"><a href="#内容摘录" class="headerlink" title="内容摘录"></a>内容摘录</h1><blockquote><p>P45 “我说，丁丁哥哥，你去做什么啊？<br>    丁丁哥哥说，我去和他们谈谈。<br>    我说，你和谁谈谈啊？<br>    丁丁哥哥唇边露出微笑，急切地说，这个世界。”</p><p>P62 “这样的旅行在我年少时曾经幻想过无数次，夜晚的国道李，我等待着自己梦寐以求的女子，开着自己梦寐以求的车，去往未知旅程的终点。未知旅程怎么会有终点，旅途上没有疲劳和困意，我们聊着电影和音乐，穿越群山和丛林，最终停在一泓无人的湖水旁边，有一个没有任何经济头脑的人开的酒店，干净便宜。”</p><p>P86 “混乱的地面道路是最好的地方。1988就像我周围的人，国道就像这个杂乱的世界，在越无序的地方，我越能寻觅到安全感。这安全感的代价就是你要时刻集中精神，否则你就会被庞大的交通工具碾过。”</p><p>P87 “生活它不是深渊，它是你走过的平原和你想登上的高山，它就像我们睡过的每一张床，你从来不会陷下去，也许它不属于我们，但它一定属于你，你觉得它在往下，是因为引力，它绝不会把你拖下深渊，它指向让你伏在地上，听听它的声音，当你休息好了，听够了，你随时可以站起来，你懂吗？”</p></blockquote><a id="more"></a> <blockquote><p>P97 “小学的离别，那是最不能知道你身边的人未来将变成一个什么样的人的时刻。” 这句话是后面很多故事开展的一个引子。</p><p>P98 “在一个陌生的环境里，我可以重新塑造一遍我自己，没有什么事不会改变的，我上一个角色已经演完了，这是我接的新戏。”</p><p>P124 “我说：‘……但难道就没有人正儿八经的做新闻么？’    朋友说，都有，每一拨李都有那么几个。    我说，那那些在哪里？    朋友说，辞退了。”</p><p>P124 “我坚信邪恶不能压倒正义……嗯。但是他们可以定义正义和邪恶。”</p><p>P126 “你相信么，在这样一个世界里，你用脑子想过的事情，你总是以为你已经做过了，”</p><p>P127 “其实温水煮青蛙是一个错误的俗语，温水煮不了青蛙的……不要拿青蛙给现实改变自己找借口，温水是煮不了青蛙的，青蛙没有那么蠢，这就是现实。”不是显示改变了自己，你很强，你没有跳出来，只是你自己不想，事你自己屈服，自己变了。</p><p>P141 “我早就想通了，人们埋怨一成不变，但也埋怨居无定所，人其实都无所谓，只要是给日子找点岔子而已，似乎只有违背现在的生活，才真正懂得了生活，生活就是一个婊子、一个戏子。一个你能想到的一切，你所有的比喻就在里面扔吧，你总是对的。因为生活太强大了，最强者总是懒得跟你反驳，甚至任你修饰，然后悄悄地把锅盖盖住。”</p><p>P163 “当我的生命力只能讲一个故事的时候，我愿将这个故事说出来，这个故事平淡无奇，平铺直叙，既没有曲折，也没有高潮，也就是寻找，相识，分开，就如同走在路上看见一盏红绿灯一样稀松平常，但若驻足，你会发现，它永远闪着黄灯。我就一直看着这盏信号灯，在灯下等了很久，始终不知道黄灯结束以后将要亮起的是红色还是绿色，一直等成了一个红绿色盲。”</p><p>P164 “我不知道是否有一种很奇怪的感情，它深到你想去结束它，或者冰封它。只因为它出现在错误的时间里，于是你要去等待一个正确时间重启它，而不是让错误的时间去消耗它。少则一天，多则一生。”</p><p>P177 “移动着的人永远比固定着的人更</p></blockquote>]]></content>
    
    
    <categories>
      
      <category>Life</category>
      
      <category>阅读</category>
      
    </categories>
    
    
    <tags>
      
      <tag>阅读</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>《水滴直播，让你我的隐私再也不滴水不漏》</title>
    <link href="/post/75794199.html"/>
    <url>/post/75794199.html</url>
    
    <content type="html"><![CDATA[<p>无意间从朋友圈里看到了一条说说，主体内容是一段搬运自微博：“嘻哈公社”的自媒体采访视频，很短，但简单，却很现实。不知道是不是因为上了大学，看新闻的时间少了，还是真的社会已经适应了这种“直播”的存在，而我成了另类？</p><p>抛开直播圈的其他乱象不说（你们都懂，某平台的某些知名主播的蛇皮操作，各种公关闹剧简直是一出年末大戏），我一直以为直播和生活的界限还是分的很开的。直播归直播，那是镜头上的人物，是在表演，可以有感情的虚假，可以有套路，可以有剧本，起码和“生活”总隔着一个界限。这个界限，你说不出是个怎样的存在，但都能感觉到它在这里，真实的在这里。</p><p>我也依稀记得斗鱼之前有过一个户外板块（不知道现在是否还存在），专门供主播分享户外生活的点点滴滴，直播里自然会出现其他“路人”，不过“路人”们都清楚的明白，有一个手持的直播设备在对着自己，无论愿意还是不愿意，至少，他们都是知情者，清楚自己已经穿过那条“界限”，站在这个直播平台提供的“舞台”上，成为了万千观众眼中的表演者。</p><p>然而，我从未想到过，我会被剥夺这份知情权，被永远剥夺。</p><a id="more"></a> <p>某天，你打开某上市公司的直播平台</p><p>你会惊奇的发现</p><pre><code>镜头上表情呆滞的自己，柜台前输入密码的自己，和密友讨论私事的自己，表演出丑后尴尬的自己，买东西犹豫不决的自己，和那个他/她亲热的自己，失恋后酒吧买醉的自己，</code></pre><p>而且，不仅有你自己，还有无数磕着瓜子吃着西瓜，以单身不知多少年的手速敲击键盘，享受着这种360度全方位无死角的窥屏狂魔们。你生活的一切横截面，无论你想或不向，都会成为这些人的娱乐自我的资源。</p><p><strong>我从不认为有错的技术，只有错的人与错误的利用方式。</strong></p><p>谢谢水滴直播，谢谢周总，让我明白《楚门的世界》有机会成为现实。</p><p>谢谢水滴直播，谢谢周总，让我知道天网监控对个人隐私的侵害是多么的彻底。</p><p>谢谢水滴直播，谢谢周总，让我知道删掉360不仅是对电脑的保护，更是对自我的保护。</p><p>谢谢水滴直播，谢谢周总，让我知道身边的一切private things是多么的宝贵。</p>]]></content>
    
    
    <categories>
      
      <category>Life</category>
      
      <category>随笔</category>
      
    </categories>
    
    
    <tags>
      
      <tag>随笔</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>读《还好我不是新加坡人》有感（转）</title>
    <link href="/post/662b8b80.html"/>
    <url>/post/662b8b80.html</url>
    
    <content type="html"><![CDATA[<h1 id="读《还好我不是新加坡人》有感（转）"><a href="#读《还好我不是新加坡人》有感（转）" class="headerlink" title="读《还好我不是新加坡人》有感（转）"></a>读《还好我不是新加坡人》有感（转）</h1><p><a href="http://blog.sina.com.cn/s/blog_ad01bc3a0101dq35.html" target="_blank" rel="noopener">原始地址</a></p><p>作者龙应台是台湾著名社会批评家，八十年代她在宝岛“放火”，一时间名声大噪，那本《野火集》让她从此广为人知。而上世纪九十年代，她又在新加坡“放火”,写下了这么一篇极具争议性的文章。</p><a id="more"></a><p>龙应台一向以文笔犀利老辣，说话微言大义而出名，这篇文章显然也有这一特点。细细读来，这篇杂文和她的大多数作品一样，都是着一时事或是小事出发，从而牵引出一个相当大的命题。在本文中她先是提出对新加坡外长在国际会议上以亚洲人代表自居，将狮城文化等同于亚洲文化的不满，在此基础上，她开始批判新加坡的某些法律条文和政府政策。其中最一针见血的要属那句：“给我再高的经济成长，再好的治安，再效率十足的政府，对不起，我也不愿意放弃我那一点个人自由与尊严。”</p><p>意料之中的，这篇短文遭到一片骂名。龙应台觉得委屈，另外发文称自己将主要火力放在了外长未经其它亚洲人考据和同意就把自己、乃至把新加坡当作亚洲代表这一点上，她不满外长以亚洲之名发出新加坡人的声音。然而，令那些愤怒的新加坡人真正不满的却是她在文章最后对于狮城的举例讽刺与挖苦。</p><p>在我想来，在这场唇舌交战中无论作者还是读者都有点小题大做的嫌疑。众所皆知，一篇好的批判性文章必须夺人眼球，因此，这篇文章的标题和结尾必须令人眼前一亮。龙应台不满自己的亚洲人身份“被代表”，这体现了她尊重人权、支持自由的一面，当然这与她的身份和多年留洋经历是分不开的。而想想新加坡文化与西亚文化、印度文化的巨大差别，让它来代表亚洲人说话的确有点名不正而言不顺。但实际上，我们也必须承认，在特定场合里，让新加坡代表亚洲人说法也未尝不可，本来这就是个多民族的国家，它的文化融合了中华文化、马来回教文化、印度文化，作为亚洲文化的大熔炉，在非正式场合把自己当代表那还是有点说服力的，我们不也常常理直气壮地说“我们亚洲如何如何”吗？但鉴于那是在国际官方会议上的讲话，加之明明知道事后会被西方媒体大肆渲染一番，这为代表实在不合适。</p><p>再看那最令狮城人民不满的部分，即龙应台对狮城政策的批判，说真的这部分占全文的比例并不大，又何以一石惊起千层浪呢并且几无附和龙文之音呢?对此龙应台的解释是：一是新加坡人确实比较满意于现状，乐于接受由权威政府领导的生活方式；或者，在权威的笼罩之中，不同基调的声音根本还不敢冒出来。”我觉得这两个原因都有可能。的确，新加坡这个蕞尔小国近几年的发展倍受瞩目，亚洲四小龙之一的实力实在不容小觑。有很多人都在羡慕“花园城市”的廉政与洁净。短短几十年就有了如此大的进步和成就，狮城人民很有可能是对政府十分满意甚至是充满感恩的。当然，这并不代表这个国家就没有问题，但是很明显这种政体、甚至是这份普遍的感激都极有可能成为“敢怒而不敢言者”沉默的原因。所以说，第二个假设也可以成立。</p><p>这么说来，是龙应台恶意赚取噱头，鸡蛋里挑骨头了？当然不是。我们必须承认她的出发点是善意的，甚至可以说是极具理想化的，事实上无论在哪一个国家，知识分子愿意为社会的鸡毛蒜皮小事而生气、而发出批判之声，这是一件很幸运的事情，何况和她当年批判台湾相比，这篇文章已经很客气。正因我们身处于这样不够完美的社会与时代，我们才应该对小事看不顺眼、对琐事斤斤计较—只要我们都是为了让这个社会变得更好。批评，让学者们慎思、明辨。也正因如此，当今不少学者都认为，将眼下大热的龙应台和周国平放在一起，两者固然没什么可比性，但是对青年人而言，读多一点龙应台也许会对这个国家更有益。如果硬要就新加坡到底好不好来说，或许只能是：子非鱼安知鱼之乐。</p><p>读罢这篇杂文，我想这其中还有很多东西值得我们深思：同是一个多民族国家，新加坡何以拥有这么强的核心凝聚力？再者，如果连这般清廉、法制完善的新加坡都被人这样批评，我们正在崛起的中国又该何去何从？换句话说，如果现在让龙应台来批判中国大陆，她又会有多少文章可作？</p><p>一番深思熟虑后，我想我最欣赏的还要属新加坡《联合早报》，它居然胆敢在本国报纸上刊登这么一篇必将刺痛人民神经的文章。我也钦佩龙应台，她居然胆敢在自己的文集里放进这么多批评自己的文字。看似是拿自己的手打了自己的脸，但为何此时此刻，我有种回到百家争鸣时代的错觉呢?</p>]]></content>
    
    
    <categories>
      
      <category>Life</category>
      
      <category>阅读</category>
      
    </categories>
    
    
    <tags>
      
      <tag>阅读</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>《野火集》读书笔记</title>
    <link href="/post/a4efe87.html"/>
    <url>/post/a4efe87.html</url>
    
    <content type="html"><![CDATA[<h1 id="内容摘录"><a href="#内容摘录" class="headerlink" title="内容摘录"></a>内容摘录</h1><blockquote><p>P10 “说穿了，龙应台所传承、传递的野火，其实就是一种乌托邦的想象。教导我们在现代的荒原上培养价值的火种，批判的火种，或点灯或放火，在众多的小天地和大天地，边缘和中间之间，找到一种新的文化串联的策略……”《野火集》中野火的多层含义，一方面是指如同普罗米修斯为人类带来神火，龙应台给台湾带来思想与意识观念的”野火“，她这个”盗火的玉娇龙“，背负着维护古典价值的使命，在哪个时代挂起漫野的星星之火。</p><p>P11 “如福柯所说，我们一再发现自己处于开始的位置；因为这样，我们更应该一起思索未来，以新的火焰挑战者、文化挑战者为己任，化被动为主动，大力叩问个体生命的意义，将我们共同的困境，化成一场戏剧性的自我追寻，扩张梦想的蓝图和坐标，脚踢东西文明，甚至期待有一天，将龙应台的野火放回西方去。”</p><p>P24 “……倒觉得八零年代就是太近的昨天，时间很长，路却走得不十分远。”</p><p>P28 “八零年代，我从台北走到北京，在从莫斯科走到东伯里的大街上，秋色萧萧，已是年代末了。我看见作家在对群众演说，群众在对天空呐喊，天空，默然下起了冷雨，雨水冲洗着人们脸上悲愤激情的泪水。 那是一个最坏也最好的时代，最黑暗也最光明的时代。因为黑暗，所以人们充满了追求光明的力气和反抗黑暗的激情，而且黑白分明，奋斗的目标多么明确。力气、激情、目标明确——八零年代是理想主义风起云涌的时代。只有在得到”光明“之后，在”光明“中面对个人自我的黑暗，发现那黑暗更深不可测，我们才进入了疑惑不安的九零年代，世纪之末。”</p></blockquote><a id="more"></a><blockquote><p>P31 “个人要从民意的强大束缚中解放出来，要向民意的平庸统治争取不同流俗的权利。极权瓦解之后，压迫着个人的是无数个个人所结成的集体，’民意’.”</p><p>P31 “梁启超在七十年前说过的话，更令我惊诧其早熟：‘……岂独裁军阀财阀的专横可憎可恨，就是工团的同盟抵抗乃至社会革命还不是同一种强权作用！只不过从前强权，在那一班少数人手里，往后的强权，移在这一班多数人手里罢了。’”</p><p>P33 “个人，当他是反对者的时候，她不被捕杀就是圣洁的英雄。当他不再是反对者，严酷的测验就来了：他是否能抵挡权力腐化，他是否能承担责任，他是否能容忍异己。许多事实表明：那打破了专制的英雄们竟是无数个专制的个人。个人，才是黑暗的真正来源。”</p><p>P62 “我爱惜我的学生；像努力迎取阳光的黄色向日葵，他们聪慧、纯洁、奋发，对老师尤其一片真情。但是，他们也是典型的中国学生：缺乏独立自主的个性，盲目服从权威，更严重的，他们没有——完全没有——独立思考的能力。 错在学生吗？ 当然不是。学生是一抔混沌的黏土，在教育者的手中揉搓成形。从小学到大专联考这个漫长过程中的种种问题，暂且不谈，让我们看看这些‘不敢’、‘泪眼汪汪’、‘没有意见’的大学生正在接受什么样的高等教育…….我一直以为大学校长是高瞻远瞩，指导学术与教育大方向的决策人，而不是管馒头稀饭的保姆，但这也暂且不提。这一类型的教育者的用心，毋庸置疑，当然是善意的，问题是，我们论‘事’的时候，用心如何根本不重要，重要的是实际的后果，而教育的后果和其严重！这种喂哺式、育婴式的大学教育刚好吻合心理学家 Levy 早在一九四三年给所谓‘过度保护’（Overprotection）所作的诠释：第一，给予过多的接触——‘有任何问题，随时来找我’；第二，禁止他独立自主——‘你不许……’；第三，将他‘婴儿化’——‘乖，早睡早起。’；第四，把自己的价值取向加诸其身——‘你听我的……’在这种过度呵护的幼稚教育下成长的大学生，遇事时，除了‘泪眼汪汪’之外又能做什么呢？”</p></blockquote><h2 id="1984，奥威尔的台湾"><a href="#1984，奥威尔的台湾" class="headerlink" title="1984，奥威尔的台湾"></a>1984，奥威尔的台湾</h2><blockquote><p>P117 “要出书时，书稿要送印刷厂了，出版人和我面对面发愁，这一篇，收不收进书里？收进去，可能使整个书被查禁销毁，前功尽弃；不收进去，唉，龙应台实在，实在不甘心！ 夜很深了，我抬起头，说：‘收。’”</p><p>P120 “那么我们要不要言论自由？这个问题本身大概就是一个忌讳——我们对外号称‘自由’，当然本来就有言论自由，而且是宪法保障的，问‘要不要’简直是自打耳光。可是自打耳光总比等着让别人来打要好得多。”</p><p>P121 “一方面鼓励学生去努力追求真理，真相。一方面有用各种手段防止学生得到某种知识——学生难道是智能不足。我们希冀他不会发现这两种态度间的严重冲突？这种掩藏式的做法不仅暴露出执政者及教育者的虚伪。而且更可笑的，他根本行不通！思考是追求真理的工具，学生一旦获得这个工具，我们就不可能对他说：你去治学问，但不要碰政治。譬如说一个有能力深思经济问题，文学问题的人，他一定也有能力分析政治问题。反过来说，如果我们执意不让学生在政治问题上刨根问底，唯一的办法就是根本不教他追求真理的原则与方法，不给他‘思考’那个刨根问底的工具——但是这样一来，我们还谈什么教育？”</p></blockquote><p>麦尔教授的老鼠实验——“以不变应万变”的古板愚蠢，甚至还在一代代的加重，“遗传”给后人。</p><blockquote><p>P126 “一个国家，又何尝不是个精神可能崩溃的老鼠？！……如何能不受制于旧习惯、旧观念、就方法，如何不搞‘拧’了去老撞一闪没有乳酪的门而撞得鼻青脸肿，需要的是弹性与智慧。 智慧布政使人之所以为人，鼠之所以为鼠的差别吗？”</p><p>P131 “在台湾革新很难，一方面固然是由于许多制度的僵化……另外还有保守的执政单位对社会自觉运动的移惧。一个更大的障碍，确实民众本身的缺乏动力。”</p><p>P142 “‘野火’只有一个简单的要求：撕掉蒙眼布。对‘野火’狂热的反响或许也就传达了那么一个简单但迫切、坚决的讯息：我们不要蒙眼布！让子女，学生，人民都用自己的眼睛去看。自己的头脑去想。”</p><p>P166 “脱法行为频繁，公权力低落，有一个更根本的原因：执法者与执政者同体……执法者虽然有心执法，但是因为与执政者通体，执法起来就难免背上‘迫害’的大帽子。为了避嫌，只好让法律放个假。”</p></blockquote><h2 id="我的台湾意识"><a href="#我的台湾意识" class="headerlink" title="我的台湾意识"></a>我的台湾意识</h2><blockquote><p>P169 “战前的日本，跟目前的中国台湾一样，所有的教科书都由政府统一编制……把教育作为一种政治手段，就是家永一类的学者所惧怕的，他们害怕历史的大悲剧重演。战后的日本和多数欧美国家一样，教科书由民间自行编制，政府只能审核品质，但是不能操纵它的内容。这种做法的目的，当然在避免一个政府有计划、有系统地制造易于统治的顺民。”</p></blockquote><h2 id="寒食节"><a href="#寒食节" class="headerlink" title="寒食节"></a>寒食节</h2><blockquote><blockquote><p>P205 “唐朝时，中国的文化到达空前的高峰，是当时世界上最强盛的国家。我们对唐文化的了解有限，尤其是唐朝的节日。 唐人很重视的节日是寒食，设定在冬至后的一百零五日，大约在清明节前的一日。这天全长安城的炉灶内都不能有火，人们吃冷粥及冷饼，等到第二天一早，由大明宫内传出薪火，到家家户户的灶内。 这是一个充满了象征意义的节日，而且非常严厉地执行，寒食日仍起火者，要处以死刑的。”</p></blockquote></blockquote>]]></content>
    
    
    <categories>
      
      <category>Life</category>
      
      <category>阅读</category>
      
    </categories>
    
    
    <tags>
      
      <tag>阅读</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>《天幕红尘》读后感</title>
    <link href="/post/772fc02c.html"/>
    <url>/post/772fc02c.html</url>
    
    <content type="html"><![CDATA[<h1 id="《天幕红尘》读后感"><a href="#《天幕红尘》读后感" class="headerlink" title="《天幕红尘》读后感"></a>《天幕红尘》读后感</h1><p>转自豆瓣 <a href="https://book.douban.com/subject/24748615/" target="_blank" rel="noopener">原文地址</a></p><p>数年前，看电视剧《天道》的时候，面对剧尾的那一场诉讼，我佩服得五体投地，于是，给某人出了一道题：如果一个农村家庭作坊被人谴责为滥用童工，怎么辩护？<br>彼时，还算是民商法才子的某人给了一个答案。但是，我依然觉得是电视剧中的辩护词更赞。</p><a id="more"></a><p>电视剧中，中年的农民大叔说，农村的孩子，谁不是从小就帮着家里干活的呢？难道这也是用童工？<br>其实，当时我转述问题的时候也有所遗漏。但是，不管怎么样，《天道》惊艳了我，豆豆也惊艳了我。<br>只是，豆豆创作的小说数量并不多。而我，又属于那种心理洁癖者，很少在看完电视剧以后再看原著小说或者在看完原著小说后又去看电视剧的。所以，我并没有读过《天道》的原著小说《遥远的救世主》，我读了《背叛》。<br>豆豆的小说有着明显的 style，就像是大树的年轮，早已融于自身，无法消除。</p><p>豆豆的男主，都是有着绝顶的智慧的，就像是罗贯中笔下羽扇纶巾的诸葛亮，对方的一举一动、事态的发展，皆在自己的预料之中。无论是宋一坤，还是丁元英，抑或是叶子农，都是那种其貌不扬，扔在人堆里就找不到的主儿，但是，却具有翻手为云覆手为雨的能力。<br>而他们的这种操纵乾坤的智慧和能力，在小说里，则体现为游走于法律的边缘。这句话，用通俗的说法叫做“打法律的擦边球”。<br>无论是丁元英设计的“劫富济贫”，还是叶子农策划的“劳务输出”，较了真，其实都是违法行为。</p><p>但是，叶子农则认为自己的这种行为并非钻法律的空子，因为他的所思所想所作所为，均在法律认可的范围以内，既然法律没有明确禁止，那就是合法的。呵，这个人，倒是懂得将私法上的“法无禁止即自由”的思想应用于实践。<br>“情深不寿，慧极必伤。”善于谋划，并且算无遗策的人，是一种“只可远观”的神话；从某种程度上来讲，他们的存在对于他人来说也是一种“危害”。这样的人，要么屹立于社会之巅，操纵着芸芸众生；要么，注定无法容于世。<br>所以，天神一般的神机妙算的诸葛亮只是罗贯中在正统思想下塑造出来的“演义”。</p><p>所以，宋一坤用鲜血来洗刷自己的罪孽；所以，丁元英孤独终老；所以，叶子农倒在了异国他乡。</p><p>作品中，人物身上的种种智慧，事实上，都是作者自身智慧的投影。</p>]]></content>
    
    
    <categories>
      
      <category>Life</category>
      
      <category>阅读</category>
      
    </categories>
    
    
    <tags>
      
      <tag>阅读</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>2018-02-03武汉游记</title>
    <link href="/post/4f8fe65a.html"/>
    <url>/post/4f8fe65a.html</url>
    
    <content type="html"><![CDATA[<h1 id="第一天-2-3-号。"><a href="#第一天-2-3-号。" class="headerlink" title="第一天 2.3 号。"></a>第一天 2.3 号。</h1><p>原本打算集训完直接回家的，临走前两天打开携程，下一站并不是石家庄，而是武汉。脑子里突然想起了那个“一时冲动”。哈，虽然不像自己的风格，但是既然买了票，那就一去吧</p><a id="more"></a><p>2.2 集训完，晚上收拾寝室+整理行李就鼓捣到了 2 点多，拜托馨馨没睡的话 6 点钟把我叫起来，不过好在重要的事情自己心里也都有个谱，虽然睡眠时间不多，第二天一早还是自然醒了。把计划好的事情一件件做完，还了宁哥的电车钥匙，把没吃完的枇杷送给宿管阿姨，拎着强行塞下的行李箱和电脑包，地铁来到了长沙南站，本想着高铁一路还能看看南方这边郊外的风景，不过也许是前一天晚上收拾得有些晚了，上了高铁倒头就睡，一觉醒来已经是“列车即将到达武汉站“。精神迷糊得导致我下车时候应该把我仅带得一本小说《月亮与六便士》落在了座位上，可能是真的不打算让我读完它了哈哈哈（这可是我仅带的一本小说啊）。下了高铁在武汉站里吃了热干面，听了一个好心大姐的建议，在吃饭的地方换了些零钱然后买了一张城市交通一卡通（后来事实证明它发挥了无比巨大的作用）。午饭过后，乘地铁到了户部巷附近，入住如家，由于是内宾，光线不是很好，得，困意再次袭来，我一个午睡足足睡到了 7 点钟。还因此错过了我妈的电话，搞得她老人家着急了一番（生怕我这个一米八几的人在武汉被拐了）。</p><p>好好的休息了一番后，我便开始了晚上的自由行程，先是户部巷吃了些小吃（热干面，鸭架，哦对那个糊米酒不错，少数我能吃得惯的酒酿产品。。），有意思的是，户部巷里排队最长的竟然是长沙的臭豆腐和大香肠，哇，我这半个长沙人心里也莫名有了几分自豪。顺着巷子走，尽头是一个不起眼的藏酸奶，再一拐面前就是沿江大道了，时间已经过了八点，人并不是很多，江风阵阵，江堤边有不同用处的码头，还有供行人夜赏江景的平台。自小在北方长大的我一直很向往这种有水伴城的感觉，与家乡的人工水系最大的不同，这里是”水养人“，而非”人养水“，面朝江河，或是风平浪静、波澜不惊，亦或是怒浪卷云、波涛汹涌，自然的表现从不因你的喜恶而改变，或者更严谨的说，其内蕴之博大更难凭你一人的感情去左右。如此，无论自己有什么烦恼，跑到江边，去听，去感受，你总会静下来，与人不一样，它无需承诺，无论你在或不在，它总在那里，不怨，不悔，不念，不恼，它的存在，对我自己而言，已是一种终不可达的傲然姿态，对它的这种敬佩，是心底里的。</p><p>步行了一段时间，我搭上了来往过武汉长江大桥的公交，回来的时候应该恰好是末班吧。下了车能望到夜里灯光装饰的黄鹤楼，照旧，不喜自拍，但不想错过景致，拍了几张照，走回了旅店，这一小段路也顺便摸清了明早跑步的路线，晚上和三五好友聊了些天，睡觉时候好像也不早了（似乎自己上了大学后一直没有早睡过）。</p><h1 id="第二天-2-4-号。"><a href="#第二天-2-4-号。" class="headerlink" title="第二天 2.4 号。"></a>第二天 2.4 号。</h1><p>前一天睡得不早，不过今天早晨还是兴致勃勃的 7 点钟起来了，既然拿了跑步的衣服，又有如此兴致（PS 重点是我竟然起来了），当然要粗发啦，还能留个纪念。</p><p>半个小时 4.5km 跑了武汉长江大桥一个来回，新成就 get 哈哈，回来的时候看到了纪念碑，上面有毛主席所写的”一桥飞架南北，天堑变通途“。当然，希望自己今后和村上春树先生一样，能坚定的做自己爱干的事业，同时还能坚定的做一个跑者。上午抓紧时间把武昌有文化存留的这一个区域都逛了一遍，黄鹤楼景区无论是火爆的还是冷门的景点都看了一遍，不曾想除了语文书中所提到的崔颢创作《黄鹤楼》，以及李白搁笔的故事，这座”天下江山第一楼“还与诸多历史名人有着千丝万缕的联系。过费祎亭，知晓了传说费祎死后登仙，每乘黄鹤于此憩驾。学了些历史知识，南朝刘宋就三国孙权所建夏口城扩建而成郢州城，地理位置就位于武汉市武昌蛇山，也就是黄鹤楼所在的这一片区域，而此处在宋朝时就是岳飞抗金作战的前线，而岳飞在郢州驻军时间最久，黄鹤楼景区内也有岳飞这一历史名将的雕塑，供后人瞻仰。哦对还有一点，黄鹤楼多次被毁重修，如今的黄鹤楼实际上是建国后重新修建的，清光绪十年（1884 年）大火，留下来的只有黄鹤楼东侧的古铜顶。</p><p>游完黄鹤楼景区，旁边的首义公园是旧武汉省图书馆所在，但是现在已是危房，修缮中并没有对外开放。我便乘公交，过武昌路隧道，向北，到了沿江边的红色景点区，包括毛泽东旧居，中共五大会议旧址，革命时代的记忆，因为没有相似的经历，所以看革命先辈抛头颅，洒热血，更多的是敬佩，为信仰而奋斗，无需其他理由。之后又回户部巷，到老字号蔡林记吃的武汉正宗热干面。嗯对顺便尝了下恩施小土豆。看了看日期，今天是星期日，想起来多数博物馆都是周一闭馆，作为一个博物馆狂人，赶紧下午麻溜的跑到湖北省博物馆，先把最出名的看了再说，剩下的。。总之以后还会到武汉来的嘛。</p><p>博物馆的镇馆之宝应该就是曾侯乙编钟和越王勾践剑了，听了 app 上的讲解（竟然不是免费的，还很难用，差评），这两件文物以及相关历史和考古知识讲解的都比较仔细，剩下的，知识的系统性和文物的丰富性并比不上陕西历史博物馆等。但凡是参观博物馆，多看看，有收获就是好的。出了博物馆，这时旁边的湖北省美术馆已经关门了，好吧虽然有些可惜，不过还算留下了再来武汉游玩的决心。回去的路上经过现在的武汉省图书馆，不得不说比家乡的河北省图书馆要大好多啊。。外部造型和内部构造以及环境氛围都很让人有静下心来读书的赶脚，进馆的每个人也都很自觉地压低了自己的声音，总之氛围很好。</p><p>回到如家拿上行李，准备开拔到民宿的小姐姐家，公交到了楚河汉街附近，也是她强烈安利的，em 或许不是因为这个，我也不会选择这边的民宿吧，哈。楚河汉街处于武汉中央文化区，地理位置相当于武汉市的几何中心，官方说明为”万达集团投资 500 亿元人民币，倾力打造的以文化为核心，兼具旅游、商业、商务、居住功能的世界级文化旅游项目“。晚上一个人走了个来回，哈确实不同的人总会找到不同的吸引点，购物达人-&gt;时装品牌，美食博主-&gt;小吃街，文艺青年-&gt;文创书店，都有适合你的那一个。我吃了点小吃然后就在文华书城看了会儿书，重点是，里！面！有!3D-JP！拼图店！突然回忆起了那段和拼图斗智斗勇，哦不，只有斗智的时光。</p><h1 id="第三天-2-5-号。"><a href="#第三天-2-5-号。" class="headerlink" title="第三天 2.5 号。"></a>第三天 2.5 号。</h1><p>emm 早晨睡了个懒觉，今天是公交车上的一天哈哈。上车坐公交坐错方向了，不过正好公交线路正好是沿着东湖走一圈，干脆一不做二不休，坐到了终点站再坐回来（不愧是时间多），音乐与东湖美景相伴，这一趟值了。经过武汉长江二桥，我来到了汉阳，听了天骄的安利想着去看一下江汉关博物馆，不过么，确实博物馆周一都不开，江汉关也不例外。不过呐，以江汉关博物馆作为东头，恰巧是汉口地区最出名的文化购物一条街（一条街上足足有三四个阿迪达斯的专卖店。。），建筑都是民国风的，当然，这里不同于汉街，有不少是“真民国”，比如上海银行汉口分行旧址（现在在这里是工商银行的地界了），三段式立面，中段采用爱奥尼双柱巨柱式，还有四明银行旧址（现在是 OCE 的专卖店），以及不知道是不是真民国遗存的中国银行（看得挺像得），闲逛一小圈后，我又搭乘地铁来到了琴台附近，先去东边得汉阳造文化创意产业园游览了一番，这里的工作氛围并不像大型公司那样紧凑忙碌充满商业气息，相反，一股“文新”感觉扑面而来，作为比较小众的景点，步行游览的人也有，但并不多，三三两两，时而有看着像因公来此处的轿车出入，靠近入口的知音书店或许是和我的生活相交最多了吧，在门口张望了一阵子，书店里的灯透过帘子隐约感觉韩式亮的，但是并没有看到里面有人在的迹象，我还是被好奇心驱使着推开门进了这家书店，少往里一拐，一个年纪比我稍长几岁的姐姐还在吧台读着书，确实没有其他客人，不过看到我来还是很热情的走来欢迎。环顾书店，并不大，中间整齐的放置着六张木制桌椅，很复古，再往里还有一个“国学讲坛”，整体风格相较于现代的书咖更传统些，书籍也是很规则的摆放在两边靠墙的书架上。一杯海盐咖啡，一本 1Q84 陪着我度过了一个下午，在这里工作的姐姐并没有怎么打扰我，难以言说的“温暖孤独”。</p><p>傍晚时分来到了西边的古琴台，这里规划成了一个集成剧院和音乐厅的休闲公园，地图上标记为“月湖风景区”，一个北方人，看到水和湖，又是一脸羡慕的表情，景色还是蛮不错的，公园还很贴心的规划了步行推荐路线，我也确实见到几个在附近居住的武汉市民在这里步行健身。</p><p>晚上在光谷逛了一番，emm 规划的很大，不过整体的感觉有点杂乱，看看时间已经十年了，再一想，十年！十年前武汉这么靠东的地方就有这样规格的购物广场了，确实发展步伐要快很多啊。比较有意思的小插曲就是晚上部门培训，哇花着全国流量举着手机看了一路（怕是被路人误当成追剧少年了哈哈哈）。</p><p>归途，返程。</p>]]></content>
    
    
    <categories>
      
      <category>Life</category>
      
      <category>旅行</category>
      
    </categories>
    
    
    <tags>
      
      <tag>旅行</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>【POJ-1458】解题报告（DP，最长相同子序列）</title>
    <link href="/post/104a4c5d.html"/>
    <url>/post/104a4c5d.html</url>
    
    <content type="html"><![CDATA[<h1 id="原始题目"><a href="#原始题目" class="headerlink" title="原始题目"></a>原始题目</h1><h2 id="Common-Subsequence"><a href="#Common-Subsequence" class="headerlink" title="Common Subsequence"></a>Common Subsequence</h2><ul><li>Time Limit: 1000MS</li><li>Memory Limit: 10000K</li><li>Total Submissions: 56895</li><li>Accepted: 23740</li></ul><h3 id="Problem-Description"><a href="#Problem-Description" class="headerlink" title="Problem Description"></a>Problem Description</h3><a id="more"></a> <p>A subsequence of a given sequence is the given sequence with some elements (possible none) left out. Given a sequence X = &lt; x1, x2, …, xm &gt; another sequence Z = &lt; z1, z2, …, zk &gt; is a subsequence of X if there exists a strictly increasing sequence &lt; i1, i2, …, ik &gt; of indices of X such that for all j = 1,2,…,k, xij = zj. For example, Z = &lt; a, b, f, c &gt; is a subsequence of X = &lt; a, b, c, f, b, c &gt; with index sequence &lt; 1, 2, 4, 6 &gt;. Given two sequences X and Y the problem is to find the length of the maximum-length common subsequence of X and Y.</p><h3 id="Input"><a href="#Input" class="headerlink" title="Input"></a>Input</h3><p>The program input is from the std input. Each data set in the input contains two strings representing the given sequences. The sequences are separated by any number of white spaces. The input data are correct.</p><h3 id="Output"><a href="#Output" class="headerlink" title="Output"></a>Output</h3><p>For each set of data the program prints on the standard output the length of the maximum-length common subsequence from the beginning of a separate line.</p><h3 id="Sample-Input"><a href="#Sample-Input" class="headerlink" title="Sample Input"></a>Sample Input</h3><pre><code>abcfbc         abfcabprogramming    contest abcd           mnp</code></pre><h3 id="Sample-Output"><a href="#Sample-Output" class="headerlink" title="Sample Output"></a>Sample Output</h3><pre><code>420</code></pre><h3 id="Source"><a href="#Source" class="headerlink" title="Source"></a>Source</h3><p>Southeastern Europe 2003</p><h1 id="题目大意"><a href="#题目大意" class="headerlink" title="题目大意"></a>题目大意</h1><p>给定两个字符串，求最长相同子序列的长度。</p><h1 id="解题思路"><a href="#解题思路" class="headerlink" title="解题思路"></a>解题思路</h1><p>入门dp，状态转移方程为：dp[i][j]={dp[i-1][j-1]+1(a[i]=a[j]),  max(dp[i-1][j],dp[i][j-1])(a[i]!=a[j]}</p><h1 id="解题代码"><a href="#解题代码" class="headerlink" title="解题代码"></a>解题代码</h1><pre><code class="hljs C++"><span class="hljs-meta">#<span class="hljs-meta-keyword">include</span> <span class="hljs-meta-string">&lt;cstring&gt;</span></span><span class="hljs-meta">#<span class="hljs-meta-keyword">include</span> <span class="hljs-meta-string">&lt;cstdio&gt;</span></span><span class="hljs-meta">#<span class="hljs-meta-keyword">include</span> <span class="hljs-meta-string">&lt;algorithm&gt;</span></span><span class="hljs-keyword">using</span> <span class="hljs-keyword">namespace</span> <span class="hljs-built_in">std</span>;<span class="hljs-keyword">const</span> <span class="hljs-keyword">int</span> maxn=<span class="hljs-number">1005</span>;<span class="hljs-keyword">int</span> len1,len2;<span class="hljs-keyword">char</span> s1[maxn],s2[maxn];<span class="hljs-keyword">int</span> dp[maxn][maxn];<span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">solve</span><span class="hljs-params">()</span></span>&#123;<span class="hljs-keyword">for</span>(<span class="hljs-keyword">int</span> i=<span class="hljs-number">0</span>;i&lt;len1;i++)&#123;<span class="hljs-keyword">for</span>(<span class="hljs-keyword">int</span> j=<span class="hljs-number">0</span>;j&lt;len2;j++)&#123;<span class="hljs-keyword">if</span>(s1[i]==s2[j]) dp[i][j]=dp[i<span class="hljs-number">-1</span>][j<span class="hljs-number">-1</span>]+<span class="hljs-number">1</span>;<span class="hljs-keyword">else</span> dp[i][j]=max(dp[i<span class="hljs-number">-1</span>][j],dp[i][j<span class="hljs-number">-1</span>]);&#125;&#125;&#125;<span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span>&#123;<span class="hljs-keyword">while</span>(~<span class="hljs-built_in">scanf</span>(<span class="hljs-string">"%s%s"</span>,s1,s2))&#123;<span class="hljs-built_in">memset</span>(dp,<span class="hljs-number">0</span>,<span class="hljs-keyword">sizeof</span>(dp));len1=<span class="hljs-built_in">strlen</span>(s1),len2=<span class="hljs-built_in">strlen</span>(s2);solve();<span class="hljs-built_in">printf</span>(<span class="hljs-string">"%d\n"</span>,dp[len1<span class="hljs-number">-1</span>][len2<span class="hljs-number">-1</span>]);&#125;<span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;&#125;</code></pre><h1 id="收获与反思"><a href="#收获与反思" class="headerlink" title="收获与反思"></a>收获与反思</h1><p>熟悉格式。</p>]]></content>
    
    
    <categories>
      
      <category>Computer Science</category>
      
      <category>ACM</category>
      
      <category>POJ</category>
      
    </categories>
    
    
    <tags>
      
      <tag>ACM</tag>
      
      <tag>POJ</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>【HDU-1518】解题报告（DFS，极易TLE，剪枝）</title>
    <link href="/post/3d8072b.html"/>
    <url>/post/3d8072b.html</url>
    
    <content type="html"><![CDATA[<h1 id="原始题目"><a href="#原始题目" class="headerlink" title="原始题目"></a>原始题目</h1><h2 id="Square"><a href="#Square" class="headerlink" title="Square"></a>Square</h2><ul><li><p>Time Limit: 10000/5000 MS (Java/Others)</p></li><li><p>Memory Limit: 65536/32768 K (Java/Others)</p></li><li><p>Total Submission(s): 17274    </p></li><li><p>Accepted Submission(s): 5409</p></li></ul><h3 id="Problem-Description"><a href="#Problem-Description" class="headerlink" title="Problem Description"></a>Problem Description</h3><p>Given a set of sticks of various lengths, is it possible to join them end-to-end to form a square?</p><a id="more"></a> <h3 id="Input"><a href="#Input" class="headerlink" title="Input"></a>Input</h3><p>The first line of input contains N, the number of test cases. Each test case begins with an integer 4 ≤ M ≤ 20, the number of sticks. M integers follow; each gives the length of a stick - an integer between 1 and 10,000.</p><h3 id="Output"><a href="#Output" class="headerlink" title="Output"></a>Output</h3><p>For each case, output a line containing “yes” if is is possible to form a square; otherwise output “no”.</p><h3 id="Sample-Input"><a href="#Sample-Input" class="headerlink" title="Sample Input"></a>Sample Input</h3><pre><code>3 4 1 1 1 1 5 10 20 30 40 50 8 1 7 2 6 4 4 3 5</code></pre><h3 id="Sample-Output"><a href="#Sample-Output" class="headerlink" title="Sample Output"></a>Sample Output</h3><pre><code>yes no yes</code></pre><h3 id="Source"><a href="#Source" class="headerlink" title="Source"></a>Source</h3><p>University of Waterloo Local Contest 2002.09.21</p><h3 id="Recommend"><a href="#Recommend" class="headerlink" title="Recommend"></a>Recommend</h3><p>LL</p><h1 id="题目大意"><a href="#题目大意" class="headerlink" title="题目大意"></a>题目大意</h1><p>给定M个小木棍的长度，问能否组成一个正方形。</p><h1 id="解题思路"><a href="#解题思路" class="headerlink" title="解题思路"></a>解题思路</h1><p>题目很简单啊，思路也很简单啊，但是写出来就TLE了啊。。。如此可见dfs剪枝是多么的重要。</p><h1 id="解题代码"><a href="#解题代码" class="headerlink" title="解题代码"></a>解题代码</h1><pre><code class="hljs C++">#include &lt;queue&gt;#include &lt;cstdio&gt;#include &lt;cstring&gt;#include &lt;cmath&gt;#include &lt;cstdlib&gt;#include &lt;algorithm&gt;using namespace std;//dfsconst int maxn=25;int stick[maxn]; bool vis[maxn];int M,T,sum,len,flag,mmax,mmin; bool cmp(int a, int b)&#123;return a&gt;b?1:0;&#125;void dfs(int count,int now,int index)&#123;if(flag) return;if(count==4)&#123;flag=1;return;&#125;if(now==0)&#123;dfs(count+1,len,M-1);if(flag)return;&#125;else if(now&lt;mmin) return;for(int i=index;i&gt;=0;i--) //剪枝1：从index开始遍历 &#123;if(!vis[i]&amp;&amp;now&gt;=stick[i])&#123;vis[i]=1;dfs(count,now-stick[i],i-1);//i已经使用过 if(flag) return;vis[i]=0;if(index==M-1)&lt;span class="space" style="white-space:pre;display:inline-block;text-indent:2em;line-height:inherit;"&gt;//剪枝2（重要剪枝）：由于每一边长度都相等，一边不能利用最长木棍的话，那么肯定这组数据肯定过不了，不需要检测了。&lt;/span&gt;&#123;return;&#125;//相同的忽略 while(stick[i]==stick[i-1])&lt;span class="space" style="white-space:pre;display:inline-block;text-indent:2em;line-height:inherit;"&gt; //剪枝3：同样长度的都过不了，无需再走一遍&lt;/span&gt;&#123;//printf("!1");i--;&#125;&#125;&#125;return ;&#125;int main()&#123;//freopen("in.txt","r",stdin);scanf("%d",&amp;T); while(T--)&#123;memset(vis,0,sizeof(vis));scanf("%d",&amp;M);flag=sum=0;for(int i=0;i&lt;M;i++)&#123;scanf("%d",&amp;stick[i]);sum+=stick[i];&#125;sort(stick,stick+M);mmax=stick[M-1],mmin=stick[0];len=sum/4;if(sum%4||mmax&gt;len) printf("no\n");else&#123;dfs(0,len,M-1);if(flag) printf("yes\n");else printf("no\n");&#125;&#125;return 0; &#125;</code></pre><h1 id="收获与反思"><a href="#收获与反思" class="headerlink" title="收获与反思"></a>收获与反思</h1><p>跟TLE斗智斗勇了一下午，慢慢嚼代码，想剪枝，确定剪枝的效果。<br>（等待补图）</p>]]></content>
    
    
    <categories>
      
      <category>Computer Science</category>
      
      <category>ACM</category>
      
      <category>HDU</category>
      
    </categories>
    
    
    <tags>
      
      <tag>ACM</tag>
      
      <tag>HDU</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>【CodeForces-455A】解题报告（DP，long long）</title>
    <link href="/post/a1fc03d8.html"/>
    <url>/post/a1fc03d8.html</url>
    
    <content type="html"><![CDATA[<h1 id="原始题目"><a href="#原始题目" class="headerlink" title="原始题目"></a>原始题目</h1><h2 id="A-Boredom"><a href="#A-Boredom" class="headerlink" title="A. Boredom"></a>A. Boredom</h2><ul><li>time limit per test 1 second</li><li>memory limit per test 256 megabytes</li><li>input standard input</li><li>output standard output</li></ul><a id="more"></a> <p>Alex doesn’t like boredom. That’s why whenever he gets bored, he comes up with games. One long winter evening he came up with a game and decided to play it.</p><p>Given a sequence a consisting of n integers. The player can make several steps. In a single step he can choose an element of the sequence (let’s denote it ak) and delete it, at that all elements equal to ak + 1 and ak - 1 also must be deleted from the sequence. That step brings ak points to the player.</p><p>Alex is a perfectionist, so he decided to get as many points as possible. Help him.</p><h3 id="Input"><a href="#Input" class="headerlink" title="Input"></a>Input</h3><p>The first line contains integer n (1 ≤ n ≤ 105) that shows how many numbers are in Alex’s sequence.</p><p>The second line contains n integers a1, a2, …, an (1 ≤ ai ≤ 105).</p><h3 id="Output"><a href="#Output" class="headerlink" title="Output"></a>Output</h3><p>Print a single integer — the maximum number of points that Alex can earn.</p><h3 id="Examples"><a href="#Examples" class="headerlink" title="Examples"></a>Examples</h3><h4 id="input"><a href="#input" class="headerlink" title="input"></a>input</h4><pre><code>21 2</code></pre><h4 id="output"><a href="#output" class="headerlink" title="output"></a>output</h4><pre><code>2</code></pre><h4 id="input-1"><a href="#input-1" class="headerlink" title="input"></a>input</h4><pre><code>31 2 3</code></pre><h4 id="output-1"><a href="#output-1" class="headerlink" title="output"></a>output</h4><pre><code>4</code></pre><h4 id="input-2"><a href="#input-2" class="headerlink" title="input"></a>input</h4><pre><code>91 2 1 3 2 2 2 2 3</code></pre><h3 id="output-2"><a href="#output-2" class="headerlink" title="output"></a>output</h3><pre><code>10</code></pre><h3 id="Note"><a href="#Note" class="headerlink" title="Note"></a>Note</h3><p>Consider the third test example. At first step we need to choose any element equal to 2. After that step our sequence looks like this [2, 2, 2, 2]. Then we do 4 steps, on each step we choose any element equals to 2. In total we earn 10 points.</p><h1 id="题目大意"><a href="#题目大意" class="headerlink" title="题目大意"></a>题目大意</h1><p>给出一个数列a1,a2,a3…ai…an。每次选定一个数ai，并且所有与ai-1，ai+1相等的数全部消去，这样消去一次得分为ai。最终把数列全部消去完，问最终最高得分是多少。</p><h1 id="解题思路"><a href="#解题思路" class="headerlink" title="解题思路"></a>解题思路</h1><p>dp，数组A[ai]表示ai出现的次数，并且记录最大值mmax，从0到mmax走一遍dp。</p><p>状态转移方程为dp[i]=max(dp[i-1],dp[i-2]+A[i]*i)，即从小到大消去到ai=i时的最高得分为：消去到i-1的最高得分（因为消去i-1时所有i=i-1+1全部被消去）与消去到i-2的最高得分加上消去A[i]个i的得分（即跳过i-1不消去）。</p><p>由于涉及求和，ai乘上出现次数会超int范围，故使用long long。</p><h1 id="解题代码"><a href="#解题代码" class="headerlink" title="解题代码"></a>解题代码</h1><pre><code class="hljs C++"><span class="hljs-meta">#<span class="hljs-meta-keyword">include</span> <span class="hljs-meta-string">&lt;queue&gt;</span></span><span class="hljs-meta">#<span class="hljs-meta-keyword">include</span> <span class="hljs-meta-string">&lt;cstdio&gt;</span></span><span class="hljs-meta">#<span class="hljs-meta-keyword">include</span> <span class="hljs-meta-string">&lt;cstring&gt;</span></span><span class="hljs-meta">#<span class="hljs-meta-keyword">include</span> <span class="hljs-meta-string">&lt;cmath&gt;</span></span><span class="hljs-meta">#<span class="hljs-meta-keyword">include</span> <span class="hljs-meta-string">&lt;cstdlib&gt;</span></span><span class="hljs-meta">#<span class="hljs-meta-keyword">include</span> <span class="hljs-meta-string">&lt;algorithm&gt;</span></span><span class="hljs-comment">//dp[i]=max(dp[i-1],dp[i-2]+a[i]*i)</span><span class="hljs-keyword">using</span> <span class="hljs-keyword">namespace</span> <span class="hljs-built_in">std</span>;<span class="hljs-keyword">const</span> <span class="hljs-keyword">int</span> maxn=<span class="hljs-number">100100</span>;<span class="hljs-keyword">long</span> <span class="hljs-keyword">long</span> dp[maxn],a[maxn];<span class="hljs-keyword">long</span> <span class="hljs-keyword">long</span> n,t,mmax;<span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">solve</span><span class="hljs-params">()</span></span>&#123;<span class="hljs-comment">//0不出现，初始化 1 </span>dp[<span class="hljs-number">1</span>]=a[<span class="hljs-number">1</span>];<span class="hljs-keyword">for</span>(<span class="hljs-keyword">long</span> <span class="hljs-keyword">long</span> i=<span class="hljs-number">2</span>;i&lt;=mmax;i++)&#123;dp[i]=max(dp[i<span class="hljs-number">-1</span>],dp[i<span class="hljs-number">-2</span>]+a[i]*i);&#125;<span class="hljs-built_in">printf</span>(<span class="hljs-string">"%lld\n"</span>,dp[mmax]);&#125;<span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span>&#123;<span class="hljs-keyword">while</span>(~<span class="hljs-built_in">scanf</span>(<span class="hljs-string">"%lld"</span>,&amp;n))&#123;<span class="hljs-built_in">memset</span>(dp,<span class="hljs-number">0</span>,<span class="hljs-keyword">sizeof</span>(dp));<span class="hljs-built_in">memset</span>(a,<span class="hljs-number">0</span>,<span class="hljs-keyword">sizeof</span>(a));<span class="hljs-keyword">long</span> <span class="hljs-keyword">long</span> maxx=<span class="hljs-number">0</span>;<span class="hljs-keyword">for</span>(<span class="hljs-keyword">long</span> <span class="hljs-keyword">long</span> i=<span class="hljs-number">1</span>;i&lt;=n;i++)&#123;<span class="hljs-built_in">scanf</span>(<span class="hljs-string">"%lld"</span>,&amp;t);<span class="hljs-keyword">if</span>(t&gt;mmax) mmax=t;a[t]++;&#125;<span class="hljs-comment">//for(long long i=1;i&lt;=n;i++)</span><span class="hljs-comment">//printf("a[%d]=%d\n",i,a[i]);</span>solve();&#125;<span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;&#125;</code></pre><h1 id="收获与反思"><a href="#收获与反思" class="headerlink" title="收获与反思"></a>收获与反思</h1><p>建立好状态转移方程就好，注意long long。</p>]]></content>
    
    
    <categories>
      
      <category>Computer Science</category>
      
      <category>ACM</category>
      
      <category>CodeForces</category>
      
    </categories>
    
    
    <tags>
      
      <tag>ACM</tag>
      
      <tag>CodeForces</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>【AtCoder-3881】解题报告（简单DP）</title>
    <link href="/post/fbf7f335.html"/>
    <url>/post/fbf7f335.html</url>
    
    <content type="html"><![CDATA[<h2 id="原始题目"><a href="#原始题目" class="headerlink" title="原始题目"></a>原始题目</h2><h3 id="C-Candies"><a href="#C-Candies" class="headerlink" title="C - Candies"></a>C - Candies</h3><ul><li><p>Time limit : 2sec </p></li><li><p>Memory limit : 256MB</p></li><li><p>Score : 300 points</p></li></ul><h3 id="Problem-Statement"><a href="#Problem-Statement" class="headerlink" title="Problem Statement"></a>Problem Statement</h3><p> We have a 2×N grid. We will denote the square at the i-th row and j-th column (1≤i≤2, 1≤j≤N) as (i,j).</p><p> You are initially in the top-left square, (1,1). You will travel to the bottom-right square, (2,N), by repeatedly moving right or down.</p><p> The square (i,j) contains Ai,j candies. You will collect all the candies you visit during the travel. The top-left and bottom-right squares also contain candies, and you will also collect them.</p><p> At most how many candies can you collect when you choose the best way to travel?<br><a id="more"></a> </p><h3 id="Constraints"><a href="#Constraints" class="headerlink" title="Constraints"></a>Constraints</h3><ul><li>1≤N≤100</li><li><p>1≤Ai,j≤100 (1≤i≤2, 1≤j≤N)</p><h3 id="Input"><a href="#Input" class="headerlink" title="Input"></a>Input</h3><p>Input is given from Standard Input in the following format:</p><p> N<br> A1,1 A1,2 … A1,N<br> A2,1 A2,2 … A2,N</p><h3 id="Output"><a href="#Output" class="headerlink" title="Output"></a>Output</h3><p>Print the maximum number of candies that can be collected.</p><h3 id="Sample-Input-1"><a href="#Sample-Input-1" class="headerlink" title="Sample Input 1"></a>Sample Input 1</h3><p> 5<br> 3 2 2 4 1<br> 1 2 2 2 1</p><h3 id="Sample-Output-1"><a href="#Sample-Output-1" class="headerlink" title="Sample Output 1"></a>Sample Output 1</h3><p> 14<br>The number of collected candies will be maximized when you:</p><p>move right three times, then move down once, then move right once.</p><h3 id="Sample-Input-2"><a href="#Sample-Input-2" class="headerlink" title="Sample Input 2"></a>Sample Input 2</h3><p> 4<br> 1 1 1 1<br> 1 1 1 1</p><h3 id="Sample-Output-2"><a href="#Sample-Output-2" class="headerlink" title="Sample Output 2"></a>Sample Output 2</h3><p> 5</p><p>You will always collect the same number of candies, regardless of how you travel.</p><h3 id="Sample-Input-3"><a href="#Sample-Input-3" class="headerlink" title="Sample Input 3"></a>Sample Input 3</h3><p> 7<br> 3 3 4 5 4 5 3<br> 5 3 4 4 2 3 2</p><h3 id="Sample-Output-3"><a href="#Sample-Output-3" class="headerlink" title="Sample Output 3"></a>Sample Output 3</h3><p> 29</p><h3 id="Sample-Input-4"><a href="#Sample-Input-4" class="headerlink" title="Sample Input 4"></a>Sample Input 4</h3><p> 1<br> 2<br> 3</p><h3 id="Sample-Output-4"><a href="#Sample-Output-4" class="headerlink" title="Sample Output 4"></a>Sample Output 4</h3><p> 5</p><h1 id="题目大意"><a href="#题目大意" class="headerlink" title="题目大意"></a>题目大意</h1><p>2*N个格子，每个格子里均含有不同数量的蜡烛。每一次只能向右或者向下走，问从（1，1）走到（2，N）最多能收集多少根蜡烛（包括首尾）。</p><h1 id="解题思路"><a href="#解题思路" class="headerlink" title="解题思路"></a>解题思路</h1><p>入门DP，简化成2*N了，状态转移方程：dp[i][j]=max(dp[i-1][j],dp[i][j-1])+a[i][j]</p><h1 id="解题代码"><a href="#解题代码" class="headerlink" title="解题代码"></a>解题代码</h1></li></ul><pre><code class="hljs C++"><span class="hljs-meta">#<span class="hljs-meta-keyword">include</span> <span class="hljs-meta-string">&lt;cstdio&gt;</span></span><span class="hljs-meta">#<span class="hljs-meta-keyword">include</span> <span class="hljs-meta-string">&lt;cstring&gt;</span></span><span class="hljs-meta">#<span class="hljs-meta-keyword">include</span> <span class="hljs-meta-string">&lt;cmath&gt;</span></span><span class="hljs-meta">#<span class="hljs-meta-keyword">include</span> <span class="hljs-meta-string">&lt;iostream&gt;</span></span><span class="hljs-meta">#<span class="hljs-meta-keyword">include</span> <span class="hljs-meta-string">&lt;iomanip&gt;</span></span><span class="hljs-meta">#<span class="hljs-meta-keyword">include</span> <span class="hljs-meta-string">&lt;set&gt;</span></span><span class="hljs-meta">#<span class="hljs-meta-keyword">include</span> <span class="hljs-meta-string">&lt;queue&gt;</span></span><span class="hljs-meta">#<span class="hljs-meta-keyword">include</span> <span class="hljs-meta-string">&lt;stack&gt;</span></span><span class="hljs-meta">#<span class="hljs-meta-keyword">include</span> <span class="hljs-meta-string">&lt;vector&gt;</span></span><span class="hljs-meta">#<span class="hljs-meta-keyword">include</span> <span class="hljs-meta-string">&lt;string&gt;</span></span><span class="hljs-meta">#<span class="hljs-meta-keyword">include</span> <span class="hljs-meta-string">&lt;sstream&gt;</span></span><span class="hljs-meta">#<span class="hljs-meta-keyword">include</span> <span class="hljs-meta-string">&lt;bits/stdc++.h&gt;</span></span><span class="hljs-meta">#<span class="hljs-meta-keyword">define</span> rep(i,a,n) for(int i=a;i&lt;n;++i)</span><span class="hljs-meta">#<span class="hljs-meta-keyword">define</span> per(i,a,n) for(int i=n-1;i&gt;=a;--i);</span><span class="hljs-meta">#<span class="hljs-meta-keyword">define</span> ms(x,a) memset((x),a,sizeof((x))) </span><span class="hljs-meta">#<span class="hljs-meta-keyword">define</span> INF 0x3f3f3f3f</span><span class="hljs-meta">#<span class="hljs-meta-keyword">define</span> eps 1e-8</span><span class="hljs-meta">#<span class="hljs-meta-keyword">define</span> fi first</span><span class="hljs-meta">#<span class="hljs-meta-keyword">define</span> se second</span><span class="hljs-meta">#<span class="hljs-meta-keyword">define</span> mp make_pair</span><span class="hljs-meta">#<span class="hljs-meta-keyword">define</span> pb push_back</span><span class="hljs-meta">#<span class="hljs-meta-keyword">define</span> np next_permutation</span><span class="hljs-meta">#<span class="hljs-meta-keyword">define</span> gapline cout&lt;&lt;<span class="hljs-meta-string">"##======================##"</span>&lt;&lt;endl</span><span class="hljs-keyword">using</span> <span class="hljs-keyword">namespace</span> <span class="hljs-built_in">std</span>;<span class="hljs-keyword">const</span> <span class="hljs-keyword">int</span> maxn=<span class="hljs-number">300</span>;<span class="hljs-keyword">const</span> <span class="hljs-keyword">int</span> maxl=<span class="hljs-number">26</span>;<span class="hljs-keyword">const</span> <span class="hljs-keyword">int</span> maxm=<span class="hljs-number">1e5</span>+<span class="hljs-number">5</span>;<span class="hljs-keyword">typedef</span> <span class="hljs-keyword">long</span> <span class="hljs-keyword">long</span> ll;<span class="hljs-keyword">typedef</span> <span class="hljs-keyword">unsigned</span> <span class="hljs-keyword">long</span> <span class="hljs-keyword">long</span> ull;<span class="hljs-keyword">typedef</span> <span class="hljs-built_in">vector</span>&lt;<span class="hljs-keyword">int</span>&gt; vi;<span class="hljs-keyword">typedef</span> pair&lt;<span class="hljs-keyword">int</span>,<span class="hljs-keyword">int</span>&gt; pii;<span class="hljs-keyword">int</span> n,m;<span class="hljs-keyword">int</span> dp[maxn][maxn],a[maxn][maxn];<span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">solve</span><span class="hljs-params">()</span></span>&#123;rep(i,<span class="hljs-number">1</span>,n+<span class="hljs-number">1</span>)&#123;rep(j,<span class="hljs-number">1</span>,m+<span class="hljs-number">1</span>)&#123;dp[i][j]=max(dp[i<span class="hljs-number">-1</span>][j],dp[i][j<span class="hljs-number">-1</span>])+a[i][j];&#125;&#125;&#125; <span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span>&#123;ios::sync_with_stdio(<span class="hljs-literal">false</span>);<span class="hljs-keyword">while</span>(<span class="hljs-built_in">cin</span>&gt;&gt;m)&#123;ms(dp,<span class="hljs-number">0</span>);n=<span class="hljs-number">2</span>;rep(i,<span class="hljs-number">1</span>,n+<span class="hljs-number">1</span>)&#123;rep(j,<span class="hljs-number">1</span>,m+<span class="hljs-number">1</span>) <span class="hljs-built_in">cin</span>&gt;&gt;a[i][j];&#125;solve();<span class="hljs-built_in">cout</span>&lt;&lt;dp[<span class="hljs-number">2</span>][m]&lt;&lt;<span class="hljs-built_in">endl</span>;&#125;&#125;</code></pre><h1 id="收获与反思"><a href="#收获与反思" class="headerlink" title="收获与反思"></a>收获与反思</h1><ul><li>第一次小比赛实战应用dp，看了看大神们也都是dp秒出说明思路是正确的。能写好状态转移方程就行。</li><li>2018.8.23更新 代码优化，利用dp外围空白。 </li></ul>]]></content>
    
    
    <categories>
      
      <category>Computer Science</category>
      
      <category>ACM</category>
      
      <category>AtCoder</category>
      
    </categories>
    
    
    <tags>
      
      <tag>ACM</tag>
      
      <tag>AtCoder</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>【SCU-1114】解题报告（DP，路径，DFS）</title>
    <link href="/post/f4bfd16b.html"/>
    <url>/post/f4bfd16b.html</url>
    
    <content type="html"><![CDATA[<h1 id="原始题目"><a href="#原始题目" class="headerlink" title="原始题目"></a>原始题目</h1><p>下图是个数字三角，请编写一个程序计算从顶部至底部某处一条路径，使得该路径所经过的数字总和最大。</p><p>7</p><p>3  8</p><p>8  1  0</p><p>2  7  4  4</p><a id="more"></a> <ol><li><p>每一步可沿左斜线向下或右斜线向下走；</p></li><li><p>1≤三角形行数≤100</p></li><li><p>三角形中的数字为整数 0，1，……，99。</p></li><li><p>如果有多种情况结果都最大，任意输出一种即可。</p></li></ol><h3 id="输入："><a href="#输入：" class="headerlink" title="输入："></a>输入：</h3><p>第一行一个整数N，代表三角形的行数。</p><p>接下来N行，描述了一个数字三角。</p><h3 id="输出："><a href="#输出：" class="headerlink" title="输出："></a>输出：</h3><p>第一行一个整数，代表路径所经过底数字总和。</p><p>第二行N个数，代表所经过的数字。</p><h3 id="样例："><a href="#样例：" class="headerlink" title="样例："></a>样例：</h3><h3 id="输入：-1"><a href="#输入：-1" class="headerlink" title="输入："></a>输入：</h3><pre><code>4 73 88 1 02 7 4 4</code></pre><h3 id="输出：-1"><a href="#输出：-1" class="headerlink" title="输出："></a>输出：</h3><pre><code>25 7 3 8 7</code></pre><h1 id="解题思路"><a href="#解题思路" class="headerlink" title="解题思路"></a>解题思路</h1><p>入门dp，状态转移方程为dp[i][j]=max(dp[i+1][j],dp[i+1][j+1])+a[i][j]; dp[i][j]表示i行j列（即第i行j个数字到底部的最大和）。根据该状态转移方程递归实现即可。</p><p>本题不仅需要记录最终的和，还需要记录路径，这时候就需要根据dp的表再用dfs走一遍。</p><h1 id="解题代码"><a href="#解题代码" class="headerlink" title="解题代码"></a>解题代码</h1><pre><code class="hljs C++"><span class="hljs-meta">#<span class="hljs-meta-keyword">include</span> <span class="hljs-meta-string">&lt;cstdio&gt;</span></span><span class="hljs-meta">#<span class="hljs-meta-keyword">include</span> <span class="hljs-meta-string">&lt;cstring&gt;</span></span><span class="hljs-meta">#<span class="hljs-meta-keyword">include</span> <span class="hljs-meta-string">&lt;cstdlib&gt;</span></span><span class="hljs-meta">#<span class="hljs-meta-keyword">include</span> <span class="hljs-meta-string">&lt;cmath&gt;</span></span><span class="hljs-keyword">using</span> <span class="hljs-keyword">namespace</span> <span class="hljs-built_in">std</span>;<span class="hljs-keyword">const</span> <span class="hljs-keyword">int</span> maxn=<span class="hljs-number">1e2</span>+<span class="hljs-number">10</span>; <span class="hljs-keyword">int</span> n,m;<span class="hljs-comment">//n行，m列 </span><span class="hljs-keyword">int</span> a[maxn][maxn];<span class="hljs-keyword">int</span> f[maxn][maxn];<span class="hljs-keyword">int</span> ans[maxn];<span class="hljs-keyword">int</span> flag;<span class="hljs-comment">//f[i,j]=max(f[i+1,j],f[i+1,j+1])+a[i,j]</span><span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">max</span><span class="hljs-params">(<span class="hljs-keyword">int</span> a,<span class="hljs-keyword">int</span> b)</span></span>&#123;<span class="hljs-keyword">return</span> a&gt;b?a:b;&#125;<span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">dp</span><span class="hljs-params">(<span class="hljs-keyword">int</span> i,<span class="hljs-keyword">int</span> j)</span><span class="hljs-comment">//递归实现 </span></span>&#123;<span class="hljs-keyword">int</span> t;<span class="hljs-keyword">if</span>(i==n)<span class="hljs-comment">//到底部</span>&#123;t=a[i][j];<span class="hljs-keyword">return</span> f[i][j]=t;&#125;<span class="hljs-keyword">else</span>&#123;t=max(dp(i+<span class="hljs-number">1</span>,j),dp(i+<span class="hljs-number">1</span>,j+<span class="hljs-number">1</span>))+a[i][j];<span class="hljs-keyword">return</span> f[i][j]=t;&#125; &#125;<span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">dfs</span><span class="hljs-params">(<span class="hljs-keyword">int</span> i,<span class="hljs-keyword">int</span> j,<span class="hljs-keyword">int</span> tot,<span class="hljs-keyword">int</span> n)</span>  </span>&#123;      <span class="hljs-comment">//cout&lt;&lt;i&lt;&lt;" "&lt;&lt;j&lt;&lt;endl;  </span>    <span class="hljs-keyword">if</span>(flag)          <span class="hljs-keyword">return</span>;      <span class="hljs-keyword">if</span>(i==n)      &#123;          <span class="hljs-keyword">for</span>(<span class="hljs-keyword">int</span> i=<span class="hljs-number">1</span>;i&lt;n;i++)              <span class="hljs-built_in">printf</span>(<span class="hljs-string">"%d "</span>,ans[i]);          <span class="hljs-built_in">printf</span>(<span class="hljs-string">"%d\n"</span>,ans[n]);          flag=<span class="hljs-number">1</span>;      &#125;      <span class="hljs-keyword">int</span> tmp=tot-a[i][j];      <span class="hljs-keyword">if</span>(tmp==f[i+<span class="hljs-number">1</span>][j])      &#123;          ans[i+<span class="hljs-number">1</span>]=a[i+<span class="hljs-number">1</span>][j];          dfs(i+<span class="hljs-number">1</span>,j,tmp,n);      &#125;      <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span>(tmp==f[i+<span class="hljs-number">1</span>][j+<span class="hljs-number">1</span>])      &#123;          ans[i+<span class="hljs-number">1</span>]=a[i+<span class="hljs-number">1</span>][j+<span class="hljs-number">1</span>];          dfs(i+<span class="hljs-number">1</span>,j+<span class="hljs-number">1</span>,tmp,n);      &#125;  &#125;  <span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span>&#123;<span class="hljs-keyword">while</span>(~<span class="hljs-built_in">scanf</span>(<span class="hljs-string">"%d"</span>,&amp;n))&#123;<span class="hljs-built_in">memset</span>(a,<span class="hljs-number">0</span>,<span class="hljs-keyword">sizeof</span>(a));<span class="hljs-built_in">memset</span>(f,<span class="hljs-number">0</span>,<span class="hljs-keyword">sizeof</span>(f));<span class="hljs-keyword">for</span>(<span class="hljs-keyword">int</span> i=<span class="hljs-number">1</span>;i&lt;=n;i++)&#123;<span class="hljs-keyword">for</span>(<span class="hljs-keyword">int</span> j=<span class="hljs-number">1</span>;j&lt;=i;j++)&#123;<span class="hljs-built_in">scanf</span>(<span class="hljs-string">"%d"</span>,&amp;a[i][j]);&#125;&#125;dp(<span class="hljs-number">1</span>,<span class="hljs-number">1</span>);<span class="hljs-built_in">printf</span>(<span class="hljs-string">"%d\n"</span>,f[<span class="hljs-number">1</span>][<span class="hljs-number">1</span>]);flag=<span class="hljs-number">0</span>;dfs(<span class="hljs-number">0</span>,<span class="hljs-number">0</span>,f[<span class="hljs-number">1</span>][<span class="hljs-number">1</span>],n);&#125;<span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;&#125;</code></pre><h1 id="收获与反思"><a href="#收获与反思" class="headerlink" title="收获与反思"></a>收获与反思</h1><p>开始在怎么寻找路径这里卡住了，学到的东西得反复看啊。。不然真的不会用。</p>]]></content>
    
    
    <categories>
      
      <category>Computer Science</category>
      
      <category>ACM</category>
      
      <category>SCU</category>
      
    </categories>
    
    
    <tags>
      
      <tag>ACM</tag>
      
      <tag>SCU</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>【HDU-2717】解题报告（BFS）</title>
    <link href="/post/5c86d06a.html"/>
    <url>/post/5c86d06a.html</url>
    
    <content type="html"><![CDATA[<h1 id="原始题目"><a href="#原始题目" class="headerlink" title="原始题目"></a>原始题目</h1><h2 id="Catch-That-Cow"><a href="#Catch-That-Cow" class="headerlink" title="Catch That Cow"></a>Catch That Cow</h2><ul><li>Time Limit: 5000/2000 MS (Java/Others)</li><li>Memory Limit: 32768/32768 K (Java/Others)</li><li>Total Submission(s): 17820</li><li>Accepted Submission(s): 5260</li></ul><h3 id="Problem-Description"><a href="#Problem-Description" class="headerlink" title="Problem Description"></a>Problem Description</h3><a id="more"></a> <p>Farmer John has been informed of the location of a fugitive cow and wants to catch her immediately. He starts at a point N (0 ≤ N ≤ 100,000) on a number line and the cow is at a point K (0 ≤ K ≤ 100,000) on the same number line. Farmer John has two modes of transportation: walking and teleporting.</p><ul><li><p>Walking: FJ can move from any point X to the points X - 1 or X + 1 in a single minute</p></li><li><p>Teleporting: FJ can move from any point X to the point 2 × X in a single minute.</p></li></ul><p>If the cow, unaware of its pursuit, does not move at all, how long does it take for Farmer John to retrieve it?</p><h3 id="Input"><a href="#Input" class="headerlink" title="Input"></a>Input</h3><p>Line 1: Two space-separated integers: N and K</p><h3 id="Output"><a href="#Output" class="headerlink" title="Output"></a>Output</h3><p>Line 1: The least amount of time, in minutes, it takes for Farmer John to catch the fugitive cow.</p><h3 id="Sample-Input"><a href="#Sample-Input" class="headerlink" title="Sample Input"></a>Sample Input</h3><pre><code>5 17</code></pre><h3 id="Sample-Output"><a href="#Sample-Output" class="headerlink" title="Sample Output"></a>Sample Output</h3><pre><code>4</code></pre><h3 id="Hint"><a href="#Hint" class="headerlink" title="Hint"></a>Hint</h3><p>The fastest way for Farmer John to reach the fugitive cow is to move along the following path: 5-10-9-18-17, which takes 4 minutes.</p><h3 id="Source"><a href="#Source" class="headerlink" title="Source"></a>Source</h3><p>USACO 2007 Open Silver</p><h3 id="Recommend"><a href="#Recommend" class="headerlink" title="Recommend"></a>Recommend</h3><p>teddy</p><h1 id="题目大意"><a href="#题目大意" class="headerlink" title="题目大意"></a>题目大意</h1><p>一个人想用最短的时间去抓住一头牛，牛不会动，人的移动规则是：下一次移动可以移动到X+1位置，X-1位置，或者2*X位置（X为当前位置坐标），现在给定人和牛的坐标，求人抓到牛所需要的最短时间（次数）</p><h1 id="解题思路"><a href="#解题思路" class="headerlink" title="解题思路"></a>解题思路</h1><p>很直接的广搜，搜索规则可以理解成三个direction，+1，-1，*2；最后可以加上一点处理（不知道算不算剪枝）因为坐标横大于0，那么若牛的初始坐标值小于人，那么无需广搜可以得到最短次数即坐标值之差（每次左移一个单位），另由于广搜深度增加，每次搜索的量会很大，可以加入判断搜索到结果时立即跳脱循环。</p><h1 id="解题代码"><a href="#解题代码" class="headerlink" title="解题代码"></a>解题代码</h1><pre><code class="hljs C++"><span class="hljs-meta">#<span class="hljs-meta-keyword">include</span> <span class="hljs-meta-string">&lt;queue&gt;</span></span><span class="hljs-meta">#<span class="hljs-meta-keyword">include</span> <span class="hljs-meta-string">&lt;cstdio&gt;</span></span><span class="hljs-meta">#<span class="hljs-meta-keyword">include</span> <span class="hljs-meta-string">&lt;cstring&gt;</span></span><span class="hljs-meta">#<span class="hljs-meta-keyword">include</span> <span class="hljs-meta-string">&lt;cmath&gt;</span></span><span class="hljs-meta">#<span class="hljs-meta-keyword">include</span> <span class="hljs-meta-string">&lt;cstdlib&gt;</span></span><span class="hljs-meta">#<span class="hljs-meta-keyword">include</span><span class="hljs-meta-string">&lt;algorithm&gt;</span></span><span class="hljs-keyword">using</span> <span class="hljs-keyword">namespace</span> <span class="hljs-built_in">std</span>;<span class="hljs-keyword">const</span> <span class="hljs-keyword">int</span> maxn=<span class="hljs-number">100001</span>;  <span class="hljs-keyword">int</span> n,m; <span class="hljs-keyword">bool</span> vis[maxn]; <span class="hljs-comment">// 访问标记</span><span class="hljs-keyword">int</span> dir[<span class="hljs-number">3</span>]; <span class="hljs-comment">//struct State // BFS 队列中的状态数据结构</span><span class="hljs-comment">//&#123;</span><span class="hljs-comment">//int x;</span><span class="hljs-comment">//int Step_Counter; // 搜索步数统计器</span><span class="hljs-comment">//&#125;;</span><span class="hljs-built_in">queue</span> &lt;<span class="hljs-keyword">int</span>&gt; q;<span class="hljs-keyword">int</span> step[maxn];<span class="hljs-function"><span class="hljs-keyword">bool</span> <span class="hljs-title">CheckState</span><span class="hljs-params">(<span class="hljs-keyword">int</span> X)</span> <span class="hljs-comment">// 约束条件检验</span></span>&#123;<span class="hljs-comment">//int X=now.x;</span><span class="hljs-keyword">if</span>(X&gt;=<span class="hljs-number">0</span>&amp;&amp;X&lt;=<span class="hljs-number">100000</span>&amp;&amp;!vis[X]) <span class="hljs-comment">// 满足条件</span>&#123;<span class="hljs-comment">//printf("next X=%d, step=%d\n",X,now.Step_Counter+1);</span><span class="hljs-keyword">return</span> <span class="hljs-number">1</span>;&#125;<span class="hljs-keyword">else</span> <span class="hljs-comment">// 约束条件冲突</span><span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;&#125;<span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">bfs</span><span class="hljs-params">(<span class="hljs-keyword">int</span> st)</span></span>&#123;<span class="hljs-keyword">int</span> now,next; <span class="hljs-comment">// 定义2个状态，当前和下一个</span>q.push(st);step[st]=<span class="hljs-number">0</span>;vis[st]=<span class="hljs-literal">true</span>; <span class="hljs-comment">// 访问标记</span><span class="hljs-keyword">while</span>(!q.empty())&#123;now=q.front(); <span class="hljs-comment">// 取队首元素进行扩展</span><span class="hljs-keyword">if</span>(now==m) <span class="hljs-comment">// 出现目标态，此时为Step_Counter 的最小值，可以退出即可</span>&#123;<span class="hljs-built_in">printf</span>(<span class="hljs-string">"%d\n"</span>,step[now]);<span class="hljs-keyword">return</span>;&#125;<span class="hljs-comment">//按照规则搜索下一组数</span><span class="hljs-comment">//两种形式，一种左右，一种倍乘。 </span>dir[<span class="hljs-number">0</span>]=<span class="hljs-number">-1</span>;dir[<span class="hljs-number">1</span>]=<span class="hljs-number">1</span>;dir[<span class="hljs-number">2</span>]=now;<span class="hljs-keyword">int</span> flag=<span class="hljs-number">0</span>; <span class="hljs-keyword">for</span>(<span class="hljs-keyword">int</span> i=<span class="hljs-number">0</span>;i&lt;<span class="hljs-number">3</span>;i++)&#123;next=now+dir[i];<span class="hljs-comment">//printf("check X=%d, step=%d\n",next,step[now]+1); </span><span class="hljs-keyword">if</span>(next==m)<span class="hljs-comment">//剪枝，立即跳出循环</span>&#123;<span class="hljs-keyword">while</span>(!q.empty()) q.pop();step[next]=step[now]+<span class="hljs-number">1</span>;q.push(now);q.push(next);<span class="hljs-keyword">break</span>;&#125;<span class="hljs-keyword">if</span>(CheckState(next))&#123;step[next]=step[now]+<span class="hljs-number">1</span>;vis[next]=<span class="hljs-literal">true</span>;<span class="hljs-comment">//不要忘了标记已访问</span>q.push(next);&#125;&#125;q.pop(); <span class="hljs-comment">// 队首元素出队</span>&#125; <span class="hljs-keyword">return</span>;&#125;<span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span>&#123;<span class="hljs-comment">//freopen("in.txt","r",stdin);</span><span class="hljs-keyword">while</span>(~<span class="hljs-built_in">scanf</span>(<span class="hljs-string">"%d%d"</span>,&amp;n,&amp;m))&#123;<span class="hljs-keyword">while</span>(!q.empty()) q.pop();<span class="hljs-built_in">memset</span>(vis,<span class="hljs-number">0</span>,<span class="hljs-keyword">sizeof</span>(vis));<span class="hljs-built_in">memset</span>(step,<span class="hljs-number">0</span>,<span class="hljs-keyword">sizeof</span>(step));<span class="hljs-keyword">if</span>(n&gt;=m) <span class="hljs-built_in">printf</span>(<span class="hljs-string">"%d\n"</span>,n-m);<span class="hljs-keyword">else</span> bfs(n);&#125;&#125;</code></pre><h1 id="收获与反思"><a href="#收获与反思" class="headerlink" title="收获与反思"></a>收获与反思</h1><p>使用模板里的结构时出现了两次MLE，不知道是什么个情况，有待检查。</p>]]></content>
    
    
    <categories>
      
      <category>Computer Science</category>
      
      <category>ACM</category>
      
      <category>HDU</category>
      
    </categories>
    
    
    <tags>
      
      <tag>ACM</tag>
      
      <tag>HDU</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>【POJ-3126】解题报告（BFS，换门牌号，素数筛）</title>
    <link href="/post/409dbc1a.html"/>
    <url>/post/409dbc1a.html</url>
    
    <content type="html"><![CDATA[<h1 id="原始题目"><a href="#原始题目" class="headerlink" title="原始题目"></a>原始题目</h1><h2 id="Prime-Path"><a href="#Prime-Path" class="headerlink" title="Prime Path"></a>Prime Path</h2><ul><li>Time Limit: 1000MS</li><li>Memory Limit: 65536K</li><li>Total Submissions: 24280</li><li>Accepted: 13417</li></ul><h2 id="Problem-Description"><a href="#Problem-Description" class="headerlink" title="Problem Description"></a>Problem Description</h2><a id="more"></a> <p>The ministers of the cabinet were quite upset by the message from the Chief of Security stating that they would all have to change the four-digit room numbers on their offices. </p><p>— It is a matter of security to change such things every now and then, to keep the enemy in the dark. </p><p>— But look, I have chosen my number 1033 for good reasons. I am the Prime minister, you know! </p><p>— I know, so therefore your new number 8179 is also a prime. You will just have to paste four new digits over the four old ones on your office door. </p><p>— No, it’s not that simple. Suppose that I change the first digit to an 8, then the number will read 8033 which is not a prime! </p><p>— I see, being the prime minister you cannot stand having a non-prime number on your door even for a few seconds. </p><p>— Correct! So I must invent a scheme for going from 1033 to 8179 by a path of prime numbers where only one digit is changed from one prime to the next prime. </p><p>Now, the minister of finance, who had been eavesdropping, intervened. </p><p>— No unnecessary expenditure, please! I happen to know that the price of a digit is one pound. </p><p>— Hmm, in that case I need a computer program to minimize the cost. You don’t know some very cheap software gurus, do you? </p><p>— In fact, I do. You see, there is this programming contest going on… Help the prime minister to find the cheapest prime path between any two given four-digit primes! The first digit must be nonzero, of course. Here is a solution in the case above. </p><p>1033</p><p>1733</p><p>3733</p><p>3739</p><p>3779</p><p>8779</p><p>8179</p><p>The cost of this solution is 6 pounds. Note that the digit 1 which got pasted over in step 2 can not be reused in the last step – a new 1 must be purchased.</p><h3 id="Input"><a href="#Input" class="headerlink" title="Input"></a>Input</h3><p>One line with a positive number: the number of test cases (at most 100). Then for each test case, one line with two numbers separated by a blank. Both numbers are four-digit primes (without leading zeros).</p><h3 id="Output"><a href="#Output" class="headerlink" title="Output"></a>Output</h3><p>One line for each case, either with a number stating the minimal cost or containing the word Impossible.</p><h3 id="Sample-Input"><a href="#Sample-Input" class="headerlink" title="Sample Input"></a>Sample Input</h3><pre><code>31033 81791373 80171033 1033</code></pre><h3 id="Sample-Output"><a href="#Sample-Output" class="headerlink" title="Sample Output"></a>Sample Output</h3><pre><code>670</code></pre><h3 id="Source"><a href="#Source" class="headerlink" title="Source"></a>Source</h3><p>Northwestern Europe 2006</p><h1 id="题目大意"><a href="#题目大意" class="headerlink" title="题目大意"></a>题目大意</h1><p>换门牌号，要求每次只能更换一位，且更换完之后的新数字要是素数，问更换到指定号码的最少步数是多少。</p><h1 id="解题思路"><a href="#解题思路" class="headerlink" title="解题思路"></a>解题思路</h1><p>按个十百千位广搜，&lt;40入口，搜索的规则是，该数没有被搜索过，且该数为素数。由于是BFS，所以第一次搜索到最终更改的门牌号时一定是最少步数，输出该值即可。如果广搜入口全部遍历一编还是未能搜索到最终更改的门牌号，即为不可能，输出Impossible。</p><p>要点：</p><ol><li><p>由于要求是素数，所以个位只需要搜索奇数即可，以及千位避开0；</p></li><li><p>涉及素数，可以用最基础的素数判断（即从2开始逐个除，若有因子则返回false），或者使用素数筛先建立素数表然后直接查表（待补充）</p></li></ol><h1 id="解题代码"><a href="#解题代码" class="headerlink" title="解题代码"></a>解题代码</h1><ul><li>素数传统判断</li></ul><pre><code class="hljs C++"><span class="hljs-meta">#<span class="hljs-meta-keyword">include</span> <span class="hljs-meta-string">&lt;queue&gt;</span></span><span class="hljs-meta">#<span class="hljs-meta-keyword">include</span> <span class="hljs-meta-string">&lt;cstdio&gt;</span></span><span class="hljs-meta">#<span class="hljs-meta-keyword">include</span> <span class="hljs-meta-string">&lt;cstring&gt;</span></span><span class="hljs-meta">#<span class="hljs-meta-keyword">include</span> <span class="hljs-meta-string">&lt;cmath&gt;</span></span><span class="hljs-meta">#<span class="hljs-meta-keyword">include</span> <span class="hljs-meta-string">&lt;cstdlib&gt;</span></span><span class="hljs-meta">#<span class="hljs-meta-keyword">include</span><span class="hljs-meta-string">&lt;algorithm&gt;</span></span><span class="hljs-meta">#<span class="hljs-meta-keyword">define</span> maxn 10100</span><span class="hljs-keyword">using</span> <span class="hljs-keyword">namespace</span> <span class="hljs-built_in">std</span>;<span class="hljs-keyword">int</span> n,m; <span class="hljs-keyword">bool</span> vis[maxn]; <span class="hljs-comment">// 访问标记</span><span class="hljs-comment">//int dir[4][2]=&#123;0,1,0,-1,1,0,-1,0&#125;; // 方向向量</span><span class="hljs-comment">//int dir[8][2]=&#123;&#123;1,1&#125;,&#123;1,0&#125;,&#123;1,-1&#125;,&#123;0,1&#125;,&#123;0,-1&#125;,&#123;-1,1&#125;,&#123;-1,0&#125;,&#123;-1,-1&#125;&#125; ;</span><span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">State</span> // <span class="hljs-title">BFS</span> 队列中的状态数据结构&#123;</span><span class="hljs-keyword">int</span> x;<span class="hljs-keyword">int</span> Step_Counter; <span class="hljs-comment">// 搜索步数统计器</span>&#125;;<span class="hljs-function"><span class="hljs-keyword">bool</span> <span class="hljs-title">isPrime</span><span class="hljs-params">(<span class="hljs-keyword">int</span> x)</span></span>&#123;<span class="hljs-keyword">if</span>(x==<span class="hljs-number">0</span>||x==<span class="hljs-number">1</span>)<span class="hljs-keyword">return</span> <span class="hljs-literal">false</span>;<span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span>(x==<span class="hljs-number">2</span>||x==<span class="hljs-number">3</span>)<span class="hljs-keyword">return</span> <span class="hljs-literal">true</span>;<span class="hljs-keyword">else</span>&#123;<span class="hljs-keyword">for</span>(<span class="hljs-keyword">int</span> i=<span class="hljs-number">2</span>;i&lt;=(<span class="hljs-keyword">int</span>)<span class="hljs-built_in">sqrt</span>(x);i++)&#123;<span class="hljs-keyword">if</span>(x%i==<span class="hljs-number">0</span>)<span class="hljs-keyword">return</span> <span class="hljs-literal">false</span>;&#125;<span class="hljs-keyword">return</span> <span class="hljs-literal">true</span>;&#125;&#125; State a[maxn];<span class="hljs-function"><span class="hljs-keyword">bool</span> <span class="hljs-title">CheckState</span><span class="hljs-params">(<span class="hljs-keyword">int</span> s,State now)</span> <span class="hljs-comment">// 约束条件检验</span></span>&#123;<span class="hljs-keyword">if</span>(s!=now.x&amp;&amp;!vis[s]&amp;&amp;isPrime(s)) <span class="hljs-comment">// 满足条件</span>&#123;<span class="hljs-comment">//printf("next s=%d, step=%d\n",s,now.Step_Counter+1);</span><span class="hljs-keyword">return</span> <span class="hljs-number">1</span>;&#125;<span class="hljs-keyword">else</span> <span class="hljs-comment">// 约束条件冲突</span><span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;&#125;<span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">bfs</span><span class="hljs-params">(State st)</span></span>&#123;<span class="hljs-built_in">queue</span> &lt;State&gt; q;State now,next; <span class="hljs-comment">// 定义2个状态，当前和下一个</span>st.Step_Counter=<span class="hljs-number">0</span>; <span class="hljs-comment">// 计数器清零</span>q.push(st); <span class="hljs-comment">// 入队</span>vis[st.x]=<span class="hljs-number">1</span>; <span class="hljs-comment">// 访问标记</span><span class="hljs-keyword">while</span>(!q.empty())&#123;now=q.front(); <span class="hljs-comment">// 取队首元素进行扩展</span><span class="hljs-keyword">if</span>(now.x==m) <span class="hljs-comment">// 出现目标态，此时为Step_Counter 的最小值，可以退出即可</span>&#123;<span class="hljs-built_in">printf</span>(<span class="hljs-string">"%d\n"</span>,now.Step_Counter);<span class="hljs-keyword">return</span>;&#125;<span class="hljs-comment">//按照规则搜索下一组数</span><span class="hljs-keyword">for</span>(<span class="hljs-keyword">int</span> i=<span class="hljs-number">1</span>;i&lt;=<span class="hljs-number">9</span>;i+=<span class="hljs-number">2</span>)&#123;<span class="hljs-keyword">int</span> s=now.x/<span class="hljs-number">10</span>*<span class="hljs-number">10</span>+i;<span class="hljs-keyword">if</span>(CheckState(s,now))&#123;vis[s]=<span class="hljs-number">1</span>;next.x=s;next.Step_Counter=now.Step_Counter+<span class="hljs-number">1</span>;q.push(next); &#125;&#125;<span class="hljs-keyword">for</span>(<span class="hljs-keyword">int</span> i=<span class="hljs-number">0</span>;i&lt;=<span class="hljs-number">9</span>;i++)&#123;<span class="hljs-keyword">int</span> s = now.x / <span class="hljs-number">100</span> * <span class="hljs-number">100</span> + i * <span class="hljs-number">10</span> + now.x % <span class="hljs-number">10</span>;<span class="hljs-keyword">if</span>(CheckState(s,now))&#123;vis[s]=<span class="hljs-number">1</span>;next.x=s;next.Step_Counter=now.Step_Counter+<span class="hljs-number">1</span>;q.push(next);&#125;&#125;<span class="hljs-keyword">for</span>(<span class="hljs-keyword">int</span> i=<span class="hljs-number">0</span>;i&lt;=<span class="hljs-number">9</span>;i++)&#123;<span class="hljs-keyword">int</span> s=now.x/<span class="hljs-number">1000</span>*<span class="hljs-number">1000</span>+i*<span class="hljs-number">100</span>+now.x%<span class="hljs-number">100</span>;<span class="hljs-keyword">if</span>(CheckState(s,now))&#123;vis[s]=<span class="hljs-number">1</span>;next.x=s;next.Step_Counter=now.Step_Counter+<span class="hljs-number">1</span>;q.push(next);&#125;&#125;<span class="hljs-keyword">for</span>(<span class="hljs-keyword">int</span> i=<span class="hljs-number">1</span>;i&lt;=<span class="hljs-number">9</span>;i++)&#123;<span class="hljs-keyword">int</span> s=i*<span class="hljs-number">1000</span>+now.x%<span class="hljs-number">1000</span>;<span class="hljs-keyword">if</span>(CheckState(s,now))&#123;vis[s]=<span class="hljs-number">1</span>;next.x=s;next.Step_Counter=now.Step_Counter+<span class="hljs-number">1</span>;q.push(next); &#125; &#125;q.pop(); <span class="hljs-comment">// 队首元素出队</span>&#125;<span class="hljs-built_in">printf</span>(<span class="hljs-string">"Impossible\n"</span>); <span class="hljs-keyword">return</span>;&#125;<span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span>&#123;<span class="hljs-keyword">int</span> t;<span class="hljs-built_in">scanf</span>(<span class="hljs-string">"%d"</span>,&amp;t);<span class="hljs-keyword">for</span>(<span class="hljs-keyword">int</span> i=<span class="hljs-number">0</span>;i&lt;t;i++)&#123;<span class="hljs-comment">//printf("%d  %d\n",t,n);</span><span class="hljs-comment">//while(!q.empty()) q.pop();</span><span class="hljs-built_in">memset</span>(vis,<span class="hljs-number">0</span>,<span class="hljs-keyword">sizeof</span>(vis));<span class="hljs-built_in">scanf</span>(<span class="hljs-string">"%d%d"</span>,&amp;n,&amp;m);<span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">State</span> <span class="hljs-title">tmp</span>;</span>tmp.x=n;tmp.Step_Counter=<span class="hljs-number">0</span>;bfs(tmp);&#125;<span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;&#125;</code></pre><ul><li>非线性埃式素数筛</li></ul><pre><code class="hljs C++"><span class="hljs-meta">#<span class="hljs-meta-keyword">include</span> <span class="hljs-meta-string">&lt;queue&gt;</span></span><span class="hljs-meta">#<span class="hljs-meta-keyword">include</span> <span class="hljs-meta-string">&lt;cstdio&gt;</span></span><span class="hljs-meta">#<span class="hljs-meta-keyword">include</span> <span class="hljs-meta-string">&lt;cstring&gt;</span></span><span class="hljs-meta">#<span class="hljs-meta-keyword">include</span> <span class="hljs-meta-string">&lt;cmath&gt;</span></span><span class="hljs-meta">#<span class="hljs-meta-keyword">include</span> <span class="hljs-meta-string">&lt;cstdlib&gt;</span></span><span class="hljs-meta">#<span class="hljs-meta-keyword">include</span><span class="hljs-meta-string">&lt;algorithm&gt;</span></span><span class="hljs-meta">#<span class="hljs-meta-keyword">define</span> maxn 10100</span><span class="hljs-keyword">using</span> <span class="hljs-keyword">namespace</span> <span class="hljs-built_in">std</span>;<span class="hljs-keyword">int</span> n,m; <span class="hljs-keyword">bool</span> vis[maxn]; <span class="hljs-comment">// 访问标记</span><span class="hljs-comment">//int dir[4][2]=&#123;0,1,0,-1,1,0,-1,0&#125;; // 方向向量</span><span class="hljs-comment">//int dir[8][2]=&#123;&#123;1,1&#125;,&#123;1,0&#125;,&#123;1,-1&#125;,&#123;0,1&#125;,&#123;0,-1&#125;,&#123;-1,1&#125;,&#123;-1,0&#125;,&#123;-1,-1&#125;&#125; ;</span><span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">State</span> // <span class="hljs-title">BFS</span> 队列中的状态数据结构&#123;</span><span class="hljs-keyword">int</span> x;<span class="hljs-keyword">int</span> Step_Counter; <span class="hljs-comment">// 搜索步数统计器</span>&#125;;<span class="hljs-keyword">bool</span> isPrime[maxn]; <span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">solvePrime</span><span class="hljs-params">()</span>  <span class="hljs-comment">//埃式素数筛 </span></span>&#123;<span class="hljs-built_in">memset</span>(isPrime,<span class="hljs-number">1</span>,<span class="hljs-keyword">sizeof</span>(isPrime));isPrime[<span class="hljs-number">0</span>]=isPrime[<span class="hljs-number">1</span>]=<span class="hljs-literal">false</span>;<span class="hljs-keyword">for</span>(<span class="hljs-keyword">int</span> i=<span class="hljs-number">2</span>;i&lt;=maxn;i++)&#123;<span class="hljs-keyword">if</span>(isPrime[i])&#123;<span class="hljs-keyword">for</span>(<span class="hljs-keyword">int</span> j=i*i;j&lt;=maxn;j+=i)&#123;isPrime[j]=<span class="hljs-literal">false</span>;&#125;&#125;&#125;&#125;State a[maxn];<span class="hljs-function"><span class="hljs-keyword">bool</span> <span class="hljs-title">CheckState</span><span class="hljs-params">(<span class="hljs-keyword">int</span> s,State now)</span> <span class="hljs-comment">// 约束条件检验</span></span>&#123;<span class="hljs-keyword">if</span>(s!=now.x&amp;&amp;!vis[s]&amp;&amp;isPrime[s]) <span class="hljs-comment">// 满足条件</span>&#123;<span class="hljs-comment">//printf("next s=%d, step=%d\n",s,now.Step_Counter+1);</span><span class="hljs-keyword">return</span> <span class="hljs-number">1</span>;&#125;<span class="hljs-keyword">else</span> <span class="hljs-comment">// 约束条件冲突</span><span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;&#125;<span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">bfs</span><span class="hljs-params">(State st)</span></span>&#123;<span class="hljs-built_in">queue</span> &lt;State&gt; q;State now,next; <span class="hljs-comment">// 定义2个状态，当前和下一个</span>st.Step_Counter=<span class="hljs-number">0</span>; <span class="hljs-comment">// 计数器清零</span>q.push(st); <span class="hljs-comment">// 入队</span>vis[st.x]=<span class="hljs-number">1</span>; <span class="hljs-comment">// 访问标记</span><span class="hljs-keyword">while</span>(!q.empty())&#123;now=q.front(); <span class="hljs-comment">// 取队首元素进行扩展</span><span class="hljs-keyword">if</span>(now.x==m) <span class="hljs-comment">// 出现目标态，此时为Step_Counter 的最小值，可以退出即可</span>&#123;<span class="hljs-built_in">printf</span>(<span class="hljs-string">"%d\n"</span>,now.Step_Counter);<span class="hljs-keyword">return</span>;&#125;<span class="hljs-comment">//按照规则搜索下一组数</span><span class="hljs-keyword">for</span>(<span class="hljs-keyword">int</span> i=<span class="hljs-number">1</span>;i&lt;=<span class="hljs-number">9</span>;i+=<span class="hljs-number">2</span>)&#123;<span class="hljs-keyword">int</span> s=now.x/<span class="hljs-number">10</span>*<span class="hljs-number">10</span>+i;<span class="hljs-keyword">if</span>(CheckState(s,now))&#123;vis[s]=<span class="hljs-number">1</span>;next.x=s;next.Step_Counter=now.Step_Counter+<span class="hljs-number">1</span>;q.push(next); &#125;&#125;<span class="hljs-keyword">for</span>(<span class="hljs-keyword">int</span> i=<span class="hljs-number">0</span>;i&lt;=<span class="hljs-number">9</span>;i++)&#123;<span class="hljs-keyword">int</span> s = now.x / <span class="hljs-number">100</span> * <span class="hljs-number">100</span> + i * <span class="hljs-number">10</span> + now.x % <span class="hljs-number">10</span>;<span class="hljs-keyword">if</span>(CheckState(s,now))&#123;vis[s]=<span class="hljs-number">1</span>;next.x=s;next.Step_Counter=now.Step_Counter+<span class="hljs-number">1</span>;q.push(next);&#125;&#125;<span class="hljs-keyword">for</span>(<span class="hljs-keyword">int</span> i=<span class="hljs-number">0</span>;i&lt;=<span class="hljs-number">9</span>;i++)&#123;<span class="hljs-keyword">int</span> s=now.x/<span class="hljs-number">1000</span>*<span class="hljs-number">1000</span>+i*<span class="hljs-number">100</span>+now.x%<span class="hljs-number">100</span>;<span class="hljs-keyword">if</span>(CheckState(s,now))&#123;vis[s]=<span class="hljs-number">1</span>;next.x=s;next.Step_Counter=now.Step_Counter+<span class="hljs-number">1</span>;q.push(next);&#125;&#125;<span class="hljs-keyword">for</span>(<span class="hljs-keyword">int</span> i=<span class="hljs-number">1</span>;i&lt;=<span class="hljs-number">9</span>;i++)&#123;<span class="hljs-keyword">int</span> s=i*<span class="hljs-number">1000</span>+now.x%<span class="hljs-number">1000</span>;<span class="hljs-keyword">if</span>(CheckState(s,now))&#123;vis[s]=<span class="hljs-number">1</span>;next.x=s;next.Step_Counter=now.Step_Counter+<span class="hljs-number">1</span>;q.push(next); &#125; &#125;q.pop(); <span class="hljs-comment">// 队首元素出队</span>&#125;<span class="hljs-built_in">printf</span>(<span class="hljs-string">"Impossible\n"</span>); <span class="hljs-keyword">return</span>;&#125;<span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span>&#123;solvePrime();<span class="hljs-keyword">int</span> t;<span class="hljs-built_in">scanf</span>(<span class="hljs-string">"%d"</span>,&amp;t);<span class="hljs-keyword">for</span>(<span class="hljs-keyword">int</span> i=<span class="hljs-number">0</span>;i&lt;t;i++)&#123;<span class="hljs-comment">//printf("%d  %d\n",t,n);</span><span class="hljs-comment">//while(!q.empty()) q.pop();</span><span class="hljs-built_in">memset</span>(vis,<span class="hljs-number">0</span>,<span class="hljs-keyword">sizeof</span>(vis));<span class="hljs-built_in">scanf</span>(<span class="hljs-string">"%d%d"</span>,&amp;n,&amp;m);<span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">State</span> <span class="hljs-title">tmp</span>;</span>tmp.x=n;tmp.Step_Counter=<span class="hljs-number">0</span>;bfs(tmp);&#125;<span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;&#125;</code></pre><h1 id="收获与反思"><a href="#收获与反思" class="headerlink" title="收获与反思"></a>收获与反思</h1><p>题目本身没什么问题，两次TLE都是因为输入输出格式的问题最后一直等待输入，需要再细心一点。</p><p>对于素数筛知识的补充。</p><ol><li><p>传统方法：根据是否有大于1小于本身的因子来判断，复杂度为O(nlognlogn) （虽然还不会证明）。</p></li><li><p>素数筛方法</p><p> 埃式筛法，即埃拉托斯特尼筛法，本题采用。原理就是排除0，1，从2开始当前未筛去的数最小的数即为素数</p><p>改进前后两次的时间对比（图待补充）</p><p>另外还有欧拉筛法（线性）有待学习。</p></li></ol>]]></content>
    
    
    <categories>
      
      <category>Computer Science</category>
      
      <category>ACM</category>
      
      <category>POJ</category>
      
    </categories>
    
    
    <tags>
      
      <tag>ACM</tag>
      
      <tag>POJ</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>【CodeForces-689B】解题报告（BFS）</title>
    <link href="/post/454c2358.html"/>
    <url>/post/454c2358.html</url>
    
    <content type="html"><![CDATA[<h1 id="原始题目"><a href="#原始题目" class="headerlink" title="原始题目"></a>原始题目</h1><h2 id="B-Mike-and-Shortcuts"><a href="#B-Mike-and-Shortcuts" class="headerlink" title="B. Mike and Shortcuts"></a>B. Mike and Shortcuts</h2><ul><li><p>time limit per test 3 seconds</p></li><li><p>memory limit per test 256 megabytes</p></li><li><p>input standard input</p></li><li><p>output standard output</p></li></ul><a id="more"></a> <p>Recently, Mike was very busy with studying for exams and contests. Now he is going to chill a bit by doing some sight seeing in the city.</p><p>City consists of n intersections numbered from 1 to n. Mike starts walking from his house located at the intersection number 1 and goes along some sequence of intersections. Walking from intersection number i to intersection j requires |i - j| units of energy. The total energyspent by Mike to visit a sequence of intersections p1 = 1, p2, …, pk is equal to  units of energy.</p><p>Of course, walking would be boring if there were no shortcuts. A shortcut is a special path that allows Mike walking from one intersection to another requiring only 1 unit of energy. There are exactly n shortcuts in Mike’s city, the ith of them allows walking from intersection i to intersection ai (i ≤ ai ≤ ai + 1) (but not in the opposite direction), thus there is exactly one shortcut starting at each intersection. Formally, if Mike chooses a sequence p1 = 1, p2, …, pk then for each 1 ≤ i &lt; k satisfying pi + 1 = api and api ≠ pi Mike will spend only 1 unit of energy instead of |pi - pi + 1| walking from the intersection pi to intersection pi + 1. For example, if Mike chooses a sequence p1 = 1, p2 = ap1, p3 = ap2, …, pk = apk - 1, he spends exactly k - 1 units of total energy walking around them.</p><p>Before going on his adventure, Mike asks you to find the minimum amount of energy required to reach each of the intersections from his home. Formally, for each 1 ≤ i ≤ n Mike is interested in finding minimum possible total energy of some sequence p1 = 1, p2, …, pk = i.</p><h3 id="Input"><a href="#Input" class="headerlink" title="Input"></a>Input</h3><p>The first line contains an integer n (1 ≤ n ≤ 200 000) — the number of Mike’s city intersection.</p><p>The second line contains n integers a1, a2, …, an (i ≤ ai ≤ n , , describing shortcuts of Mike’s city, allowing to walk from intersection i to intersection ai using only 1 unit of energy. Please note that the shortcuts don’t allow walking in opposite directions (from ai to i).</p><h3 id="Output"><a href="#Output" class="headerlink" title="Output"></a>Output</h3><p>In the only line print n integers m1, m2, …, mn, where mi denotes the least amount of total energy required to walk from intersection 1 to intersection i.</p><h3 id="Examples"><a href="#Examples" class="headerlink" title="Examples"></a>Examples</h3><h4 id="input"><a href="#input" class="headerlink" title="input"></a>input</h4><pre><code>32 2 3</code></pre><h4 id="output"><a href="#output" class="headerlink" title="output"></a>output</h4><pre><code>0 1 2 </code></pre><h4 id="input-1"><a href="#input-1" class="headerlink" title="input"></a>input</h4><pre><code>51 2 3 4 5</code></pre><h4 id="output-1"><a href="#output-1" class="headerlink" title="output"></a>output</h4><pre><code>0 1 2 3 4 </code></pre><h4 id="input-2"><a href="#input-2" class="headerlink" title="input"></a>input</h4><pre><code>74 4 4 4 7 7 7</code></pre><h4 id="output-2"><a href="#output-2" class="headerlink" title="output"></a>output</h4><pre><code>0 1 2 1 2 3 3 </code></pre><h3 id="Note"><a href="#Note" class="headerlink" title="Note"></a>Note</h3><p>In the first sample case desired sequences are:</p><blockquote><p>1: 1; m1 = 0;</p><p>2: 1, 2; m2 = 1;</p><p>3: 1, 3; m3 = |3 - 1| = 2.</p></blockquote><p>In the second sample case the sequence for any intersection 1 &lt; i is always 1, i and mi = |1 - i|.</p><p>In the third sample case — consider the following intersection sequences:</p><blockquote><p>1: 1; m1 = 0;</p><p>2: 1, 2; m2 = |2 - 1| = 1;</p><p>3: 1, 4, 3; m3 = 1 + |4 - 3| = 2;</p><p>4: 1, 4; m4 = 1;</p><p>5: 1, 4, 5; m5 = 1 + |4 - 5| = 2;</p><p>6: 1, 4, 6; m6 = 1 + |4 - 6| = 3;</p><p>7: 1, 4, 5, 7; m7 = 1 + |4 - 5| + 1 = 3.</p></blockquote><h1 id="题目大意"><a href="#题目大意" class="headerlink" title="题目大意"></a>题目大意</h1><p>给出n个点，如果直接从a1点到an点，耗费|xn-x1|的能量，不过每个点都存在一个到另一个点的“快速路径”，消耗能量为1，现在求从第一个点开始到每一个点消耗能量的最小值。</p><h1 id="解题思路"><a href="#解题思路" class="headerlink" title="解题思路"></a>解题思路</h1><p>广搜，下一次搜索的规则是，左右相邻的点和该点快速路径到达的点（即消耗能量均为1的点），三个方向，这样一层一层往下搜索，第一次到达ai点时消耗的能量（计数器)即为从第一个点到该点消耗的最小能量。</p><h1 id="解题代码"><a href="#解题代码" class="headerlink" title="解题代码"></a>解题代码</h1><pre><code class="hljs C++"><span class="hljs-meta">#<span class="hljs-meta-keyword">include</span> <span class="hljs-meta-string">&lt;queue&gt;</span></span><span class="hljs-meta">#<span class="hljs-meta-keyword">include</span> <span class="hljs-meta-string">&lt;cstdio&gt;</span></span><span class="hljs-meta">#<span class="hljs-meta-keyword">include</span> <span class="hljs-meta-string">&lt;cstring&gt;</span></span><span class="hljs-meta">#<span class="hljs-meta-keyword">include</span> <span class="hljs-meta-string">&lt;cmath&gt;</span></span><span class="hljs-meta">#<span class="hljs-meta-keyword">include</span> <span class="hljs-meta-string">&lt;cstdlib&gt;</span></span><span class="hljs-meta">#<span class="hljs-meta-keyword">define</span> maxn 200010</span><span class="hljs-keyword">using</span> <span class="hljs-keyword">namespace</span> <span class="hljs-built_in">std</span>;<span class="hljs-keyword">int</span> n;<span class="hljs-comment">//个数 </span><span class="hljs-keyword">bool</span> vis[maxn]; <span class="hljs-comment">// 访问标记</span><span class="hljs-comment">//int dir[4][2]=&#123;0,1,0,-1,1,0,-1,0&#125;; // 方向向量</span><span class="hljs-comment">//int dir[8][2]=&#123;&#123;1,1&#125;,&#123;1,0&#125;,&#123;1,-1&#125;,&#123;0,1&#125;,&#123;0,-1&#125;,&#123;-1,1&#125;,&#123;-1,0&#125;,&#123;-1,-1&#125;&#125; ;</span><span class="hljs-keyword">int</span> dir[<span class="hljs-number">3</span>];<span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">State</span> // <span class="hljs-title">BFS</span> 队列中的状态数据结构&#123;</span><span class="hljs-keyword">int</span> i;<span class="hljs-keyword">int</span> ai;<span class="hljs-keyword">int</span> Step_Counter; <span class="hljs-comment">// 搜索步数统计器</span><span class="hljs-keyword">bool</span> first;<span class="hljs-keyword">int</span> min;&#125;;State a[maxn];<span class="hljs-keyword">int</span> ans[maxn];<span class="hljs-function"><span class="hljs-keyword">bool</span> <span class="hljs-title">CheckState</span><span class="hljs-params">(State next)</span> <span class="hljs-comment">// 约束条件检验</span></span>&#123;<span class="hljs-keyword">if</span>(next.i&gt;<span class="hljs-number">0</span>&amp;&amp;next.i&lt;=n&amp;&amp;!vis[next.i]) <span class="hljs-comment">// 满足条件</span>&#123;<span class="hljs-comment">//printf("next %d %d\n",next.i,next.ai);</span><span class="hljs-keyword">return</span> <span class="hljs-number">1</span>;&#125;<span class="hljs-keyword">else</span> <span class="hljs-comment">// 约束条件冲突</span><span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;&#125;<span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">bfs</span><span class="hljs-params">(State st)</span></span>&#123;<span class="hljs-built_in">queue</span> &lt;State&gt; q; <span class="hljs-comment">// BFS 队列</span>State now,next; <span class="hljs-comment">// 定义2个状态，当前和下一个</span>st.Step_Counter=<span class="hljs-number">0</span>; <span class="hljs-comment">// 计数器清零</span>q.push(st); <span class="hljs-comment">// 入队</span>vis[st.i]=<span class="hljs-number">1</span>; <span class="hljs-comment">// 访问标记</span><span class="hljs-keyword">int</span> circle=<span class="hljs-number">0</span>;<span class="hljs-keyword">while</span>(!q.empty())&#123;now=q.front(); <span class="hljs-comment">// 取队首元素进行扩展</span><span class="hljs-comment">//a[now.i].Step_Counter=++circle;</span><span class="hljs-keyword">if</span>(a[now.i].first) <span class="hljs-comment">// 出现目标态，此时为Step_Counter 的最小值，可以退出即可</span>&#123; <span class="hljs-comment">// 做相关处理</span><span class="hljs-comment">//printf("first visit i=%d, min=%d\n",now.i,now.Step_Counter);</span>a[now.i].min=now.Step_Counter;a[now.i].first=<span class="hljs-literal">false</span>;<span class="hljs-comment">//return;</span>&#125;<span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span>(a[now.i].min&lt;now.Step_Counter)a[now.i].min=now.Step_Counter;dir[<span class="hljs-number">0</span>]=now.i<span class="hljs-number">-1</span>;dir[<span class="hljs-number">1</span>]=now.i+<span class="hljs-number">1</span>;dir[<span class="hljs-number">2</span>]=now.ai;<span class="hljs-comment">//生成下一组方向 </span><span class="hljs-keyword">for</span>(<span class="hljs-keyword">int</span> i=<span class="hljs-number">0</span>;i&lt;<span class="hljs-number">3</span>;i++)&#123;next.i=dir[i];<span class="hljs-comment">// 按照规则生成下一个状态</span>next.ai=a[dir[i]].ai;next.Step_Counter=now.Step_Counter+<span class="hljs-number">1</span>; <span class="hljs-comment">// 计数器加1</span><span class="hljs-keyword">if</span>(CheckState(next)) <span class="hljs-comment">// 如果状态满足约束条件则入队</span>&#123;q.push(next);<span class="hljs-comment">//printf("insert i=%d ai=%d\n",next.i,next.ai);</span>vis[next.i]=<span class="hljs-number">1</span>; <span class="hljs-comment">//访问标记</span>&#125;&#125;q.pop(); <span class="hljs-comment">// 队首元素出队</span>&#125; <span class="hljs-keyword">return</span>;&#125;<span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span>&#123;<span class="hljs-keyword">while</span>(~<span class="hljs-built_in">scanf</span>(<span class="hljs-string">"%d"</span>,&amp;n))&#123;<span class="hljs-built_in">memset</span>(vis,<span class="hljs-number">0</span>,<span class="hljs-keyword">sizeof</span>(vis));<span class="hljs-keyword">for</span>(<span class="hljs-keyword">int</span> j=<span class="hljs-number">1</span>;j&lt;=n;j++)&#123;a[j].i=j;a[j].first=<span class="hljs-literal">true</span>;<span class="hljs-built_in">scanf</span>(<span class="hljs-string">"%d"</span>,&amp;a[j].ai);&#125;bfs(a[<span class="hljs-number">1</span>]);<span class="hljs-keyword">int</span> flag=<span class="hljs-number">1</span>; <span class="hljs-keyword">for</span>(<span class="hljs-keyword">int</span> j=<span class="hljs-number">1</span>;j&lt;=n;j++)&#123;<span class="hljs-keyword">if</span>(flag)&#123;<span class="hljs-built_in">printf</span>(<span class="hljs-string">"%d"</span>,a[j].min);flag=<span class="hljs-number">0</span>;&#125;<span class="hljs-keyword">else</span><span class="hljs-built_in">printf</span>(<span class="hljs-string">" %d"</span>,a[j].min);&#125;<span class="hljs-built_in">printf</span>(<span class="hljs-string">"\n"</span>);&#125;<span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;&#125;</code></pre><h1 id="收获与反思"><a href="#收获与反思" class="headerlink" title="收获与反思"></a>收获与反思</h1><p>思路清楚的话还是比较好写的，这里没有绝对的目标状态，所以全部遍历一遍每一个都打上Step值，然后输出就行。</p>]]></content>
    
    
    <categories>
      
      <category>Computer Science</category>
      
      <category>ACM</category>
      
      <category>CodeForces</category>
      
    </categories>
    
    
    <tags>
      
      <tag>ACM</tag>
      
      <tag>CodeForces</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>【ZOJ-1709】解题报告（BFS）</title>
    <link href="/post/42a619f7.html"/>
    <url>/post/42a619f7.html</url>
    
    <content type="html"><![CDATA[<h1 id="原始题目"><a href="#原始题目" class="headerlink" title="原始题目"></a>原始题目</h1><h2 id="Oil-Deposits"><a href="#Oil-Deposits" class="headerlink" title="Oil Deposits"></a>Oil Deposits</h2><ul><li>Time Limit: 2 Seconds</li><li>Memory Limit: 65536 KB</li></ul><a id="more"></a><p>The GeoSurvComp geologic survey company is responsible for detecting underground oil deposits. GeoSurvComp works with one large rectangular region of land at a time, and creates a grid that divides the land into numerous square plots. It then analyzes each plot separately, using sensing equipment to determine whether or not the plot contains oil. A plot containing oil is called a pocket. If two pockets are adjacent, then they are part of the same oil deposit. Oil deposits can be quite large and may contain numerous pockets. Your job is to determine how many different oil deposits are contained in a grid.</p><h3 id="Input"><a href="#Input" class="headerlink" title="Input"></a>Input</h3><p>The input file contains one or more grids. Each grid begins with a line containing m and n, the number of rows and columns in the grid, separated by a single space. If m = 0 it signals the end of the input; otherwise 1 ≤ m ≤ 100 and 1 ≤ n ≤ 100. Following this are m lines of n characters each (not counting the end-of-line characters). Each character corresponds to one plot, and is either ‘*‘, representing the absence of oil, or ‘@’, representing an oil pocket.</p><h3 id="Output"><a href="#Output" class="headerlink" title="Output"></a>Output</h3><p>For each grid, output the number of distinct oil deposits. Two different pockets are part of the same oil deposit if they are adjacent horizontally, vertically, or diagonally. An oil deposit will not contain more than 100 pockets.</p><h3 id="Sample-Input"><a href="#Sample-Input" class="headerlink" title="Sample Input"></a>Sample Input</h3><pre><code>1 1*3 5*@*@***@***@*@*1 8@@****@*5 5****@*@@*@*@**@@@@*@@@**@0 0</code></pre><h3 id="Sample-Output"><a href="#Sample-Output" class="headerlink" title="Sample Output"></a>Sample Output</h3><pre><code>0122</code></pre><h3 id="Source"><a href="#Source" class="headerlink" title="Source"></a>Source</h3><p>Mid-Central USA 1997</p><h1 id="题目大意"><a href="#题目大意" class="headerlink" title="题目大意"></a>题目大意</h1><p>给定一个用*和@标记的油田，找出不连续的油田总数。</p><h1 id="解题思路"><a href="#解题思路" class="headerlink" title="解题思路"></a>解题思路</h1><p>每一个点入口 BFS，搜索过的标记，最后记录广搜的总次数就行。</p><h1 id="解题代码"><a href="#解题代码" class="headerlink" title="解题代码"></a>解题代码</h1><pre><code class="hljs C++"><span class="hljs-meta">#<span class="hljs-meta-keyword">include</span> <span class="hljs-meta-string">&lt;queue&gt;</span></span><span class="hljs-meta">#<span class="hljs-meta-keyword">include</span> <span class="hljs-meta-string">&lt;cstdio&gt;</span></span><span class="hljs-meta">#<span class="hljs-meta-keyword">include</span> <span class="hljs-meta-string">&lt;cstring&gt;</span></span><span class="hljs-meta">#<span class="hljs-meta-keyword">include</span> <span class="hljs-meta-string">&lt;cstdlib&gt;</span></span><span class="hljs-meta">#<span class="hljs-meta-keyword">define</span> maxn 105</span><span class="hljs-keyword">using</span> <span class="hljs-keyword">namespace</span> <span class="hljs-built_in">std</span>;<span class="hljs-keyword">char</span> <span class="hljs-built_in">map</span>[maxn][maxn];<span class="hljs-comment">//图</span><span class="hljs-keyword">int</span> n,m;<span class="hljs-comment">//n为行数，m为列数</span><span class="hljs-keyword">bool</span> vis[maxn][maxn]; <span class="hljs-comment">// 访问标记</span><span class="hljs-comment">//int dir[4][2]=&#123;0,1,0,-1,1,0,-1,0&#125;; // 方向向量</span><span class="hljs-keyword">int</span> dir[<span class="hljs-number">8</span>][<span class="hljs-number">2</span>]=&#123;&#123;<span class="hljs-number">1</span>,<span class="hljs-number">1</span>&#125;,&#123;<span class="hljs-number">1</span>,<span class="hljs-number">0</span>&#125;,&#123;<span class="hljs-number">1</span>,<span class="hljs-number">-1</span>&#125;,&#123;<span class="hljs-number">0</span>,<span class="hljs-number">1</span>&#125;,&#123;<span class="hljs-number">0</span>,<span class="hljs-number">-1</span>&#125;,&#123;<span class="hljs-number">-1</span>,<span class="hljs-number">1</span>&#125;,&#123;<span class="hljs-number">-1</span>,<span class="hljs-number">0</span>&#125;,&#123;<span class="hljs-number">-1</span>,<span class="hljs-number">-1</span>&#125;&#125; ;<span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">State</span> // <span class="hljs-title">BFS</span> 队列中的状态数据结构&#123;</span>    <span class="hljs-keyword">int</span> x,y; <span class="hljs-comment">// 坐标位置</span>    <span class="hljs-keyword">int</span> Step_Counter; <span class="hljs-comment">// 搜索步数统计器</span>&#125;;State a[maxn];<span class="hljs-function"><span class="hljs-keyword">bool</span> <span class="hljs-title">CheckState</span><span class="hljs-params">(State s)</span> <span class="hljs-comment">// 约束条件检验</span></span>&#123;    <span class="hljs-keyword">if</span>(s.x&gt;=<span class="hljs-number">0</span>&amp;&amp;s.x&lt;m&amp;&amp;s.y&gt;=<span class="hljs-number">0</span>&amp;&amp;s.y&lt;n&amp;&amp;<span class="hljs-built_in">map</span>[s.x][s.y]&amp;&amp;!vis[s.x][s.y]) <span class="hljs-comment">// 满足条件</span>    &#123;<span class="hljs-comment">//        printf("next %d %d\n",s.x,s.y);</span>    <span class="hljs-keyword">return</span> <span class="hljs-number">1</span>;&#125;<span class="hljs-keyword">else</span> <span class="hljs-comment">// 约束条件冲突</span><span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;&#125;<span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">bfs</span><span class="hljs-params">(State st)</span></span>&#123;<span class="hljs-built_in">queue</span> &lt;State&gt; q; <span class="hljs-comment">// BFS 队列</span>State now,next; <span class="hljs-comment">// 定义2个状态，当前和下一个</span>st.Step_Counter=<span class="hljs-number">0</span>; <span class="hljs-comment">// 计数器清零</span>q.push(st); <span class="hljs-comment">// 入队</span>vis[st.x][st.y]=<span class="hljs-number">1</span>; <span class="hljs-comment">// 访问标记</span><span class="hljs-keyword">while</span>(!q.empty())&#123;now=q.front(); <span class="hljs-comment">// 取队首元素进行扩展</span><span class="hljs-comment">//if(now==G) // 出现目标态，此时为Step_Counter 的最小值，可以退出即可</span><span class="hljs-comment">//&#123;</span><span class="hljs-comment">//...... // 做相关处理</span><span class="hljs-comment">//return;</span><span class="hljs-comment">//&#125;</span><span class="hljs-keyword">for</span>(<span class="hljs-keyword">int</span> i=<span class="hljs-number">0</span>;i&lt;<span class="hljs-number">8</span>;i++)&#123;next.x=now.x+dir[i][<span class="hljs-number">0</span>]; <span class="hljs-comment">// 按照规则生成下一个状态</span>next.y=now.y+dir[i][<span class="hljs-number">1</span>];<span class="hljs-comment">//printf("insert %d %d\n",next.x,next.y);</span>next.Step_Counter=now.Step_Counter+<span class="hljs-number">1</span>; <span class="hljs-comment">// 计数器加1</span><span class="hljs-keyword">if</span>(CheckState(next)) <span class="hljs-comment">// 如果状态满足约束条件则入队</span>&#123;q.push(next);<span class="hljs-comment">//printf("insert %d %d\n",next.x,next.y);</span>vis[next.x][next.y]=<span class="hljs-number">1</span>; <span class="hljs-comment">//访问标记</span>&#125;&#125;q.pop(); <span class="hljs-comment">// 队首元素出队</span>&#125;<span class="hljs-keyword">return</span>;&#125;<span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span>&#123;<span class="hljs-keyword">while</span>(~<span class="hljs-built_in">scanf</span>(<span class="hljs-string">"%d%d"</span>,&amp;m,&amp;n)&amp;&amp;m+n)&#123;<span class="hljs-built_in">memset</span>(vis,<span class="hljs-number">0</span>,<span class="hljs-keyword">sizeof</span>(vis));<span class="hljs-keyword">for</span>(<span class="hljs-keyword">int</span> i=<span class="hljs-number">0</span>;i&lt;m;i++)&#123;<span class="hljs-built_in">scanf</span>(<span class="hljs-string">"%s"</span>,<span class="hljs-built_in">map</span>[i]);<span class="hljs-keyword">for</span>(<span class="hljs-keyword">int</span> j=<span class="hljs-number">0</span>;j&lt;n;j++)&#123;<span class="hljs-keyword">if</span>(<span class="hljs-built_in">map</span>[i][j]==<span class="hljs-string">'*'</span>) <span class="hljs-built_in">map</span>[i][j]=<span class="hljs-number">0</span>;<span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span>(<span class="hljs-built_in">map</span>[i][j]==<span class="hljs-string">'@'</span>) <span class="hljs-built_in">map</span>[i][j]=<span class="hljs-number">1</span>;&#125;&#125;<span class="hljs-keyword">int</span> count=<span class="hljs-number">0</span>;<span class="hljs-keyword">for</span>(<span class="hljs-keyword">int</span> i=<span class="hljs-number">0</span>;i&lt;m;i++)&#123;<span class="hljs-keyword">for</span>(<span class="hljs-keyword">int</span> j=<span class="hljs-number">0</span>;j&lt;n;j++)&#123;<span class="hljs-keyword">if</span>(<span class="hljs-built_in">map</span>[i][j]&amp;&amp;!vis[i][j])<span class="hljs-comment">//此区域有油&amp;&amp;没有被访问过</span>&#123;count++;State curst;curst.x=i;curst.y=j;<span class="hljs-comment">//printf("search %d %d\n",i,j);</span>bfs(curst);<span class="hljs-comment">//BFS搜索</span>&#125;&#125;&#125;<span class="hljs-built_in">printf</span>(<span class="hljs-string">"%d\n"</span>,count);&#125;<span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;&#125;</code></pre><h1 id="收获与反思"><a href="#收获与反思" class="headerlink" title="收获与反思"></a>收获与反思</h1><p>第一次使用模板，对于这种图表示的还比较顺手，如何按照规则查找出下一个状态是广搜的关键。</p><p>PS：注意一些细节，比如 1 和 i 的区别，一点打错了要 debug 半天真的伤不起啊。</p>]]></content>
    
    
    <categories>
      
      <category>Computer Science</category>
      
      <category>ACM</category>
      
      <category>ZOJ</category>
      
    </categories>
    
    
    <tags>
      
      <tag>ACM</tag>
      
      <tag>ZOJ</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>【CodeForces-600C】解题报告（贪心，字符串）</title>
    <link href="/post/265c0f5.html"/>
    <url>/post/265c0f5.html</url>
    
    <content type="html"><![CDATA[<h1 id="原始题目"><a href="#原始题目" class="headerlink" title="原始题目"></a>原始题目</h1><h2 id="C-Make-Palindrome"><a href="#C-Make-Palindrome" class="headerlink" title="C. Make Palindrome"></a>C. Make Palindrome</h2><ul><li>time limit per test 2 seconds</li><li>memory limit per test 256 megabytes</li><li>input standard input</li><li>output standard output</li></ul><h3 id="Problem-Description"><a href="#Problem-Description" class="headerlink" title="Problem Description"></a>Problem Description</h3><a id="more"></a> <p>A string is called palindrome if it reads the same from left to right and from right to left. For example “kazak”, “oo”, “r” and “mikhailrubinchikkihcniburliahkim” are palindroms, but strings “abb” and “ij” are not.</p><p>You are given string s consisting of lowercase Latin letters. At once you can choose any position in the string and change letter in that position to any other lowercase letter. So after each changing the length of the string doesn’t change. At first you can change some letters in s. Then you can permute the order of letters as you want. Permutation doesn’t count as changes.</p><p>You should obtain palindrome with the minimal number of changes. If there are several ways to do that you should get the lexicographically (alphabetically) smallest palindrome. So firstly you should minimize the number of changes and then minimize the palindrome lexicographically.</p><h3 id="Input"><a href="#Input" class="headerlink" title="Input"></a>Input</h3><p>The only line contains string s (1 ≤ |s| ≤ 2·105) consisting of only lowercase Latin letters.</p><h3 id="Output"><a href="#Output" class="headerlink" title="Output"></a>Output</h3><p>Print the lexicographically smallest palindrome that can be obtained with the minimal number of changes.</p><h3 id="Examples"><a href="#Examples" class="headerlink" title="Examples"></a>Examples</h3><h4 id="input"><a href="#input" class="headerlink" title="input"></a>input</h4><pre><code>aabc</code></pre><h4 id="output"><a href="#output" class="headerlink" title="output"></a>output</h4><pre><code>abba</code></pre><h4 id="input-1"><a href="#input-1" class="headerlink" title="input"></a>input</h4><pre><code>aabcd</code></pre><h4 id="output-1"><a href="#output-1" class="headerlink" title="output"></a>output</h4><pre><code>abcba</code></pre><h1 id="题目大意"><a href="#题目大意" class="headerlink" title="题目大意"></a>题目大意</h1><p>任意输入一串字符，要求输出改动次数最少（移动交换位置不算做改动）且字典序最小的回文串。</p><h1 id="解题思路"><a href="#解题思路" class="headerlink" title="解题思路"></a>解题思路</h1><p>贪心的想法比较直观。<br>由于移动交换位置不算改动。贪心的从两端对称输出典序最小的字母，如果该字母出现次数位奇数，则从字典序最大的字母开始搜索，直至找到第一个出现个数也为奇数的字母（当然也是最大的），大字母的个数-1，小字母个数+1（即用小替换大），偶数个数会调整全部字母出现次数为偶数然后结束，奇数个数的话则需要额外判断，如果搜索到的字母和原字母相同，则说明该字母是中间字母（不一定该字母都在中间！）<br>易错点：把中间字母单独提出来然后相邻的放到中间。</p><blockquote><p>比如aabbhhwwhwwhhbbaa输入本应该原样输出，但是却输出了aabbwwhhhhhwwbbaa，这样会使字典序增大，需要对中间字母特殊处理（正常左右两端输出，只不过最后留一个在中间打印就行。）</p></blockquote><h1 id="解题代码"><a href="#解题代码" class="headerlink" title="解题代码"></a>解题代码</h1><pre><code class="hljs C++"><span class="hljs-meta">#<span class="hljs-meta-keyword">include</span> <span class="hljs-meta-string">&lt;cstdio&gt;</span></span><span class="hljs-meta">#<span class="hljs-meta-keyword">include</span> <span class="hljs-meta-string">&lt;iostream&gt;</span></span><span class="hljs-meta">#<span class="hljs-meta-keyword">include</span> <span class="hljs-meta-string">&lt;cstring&gt;</span></span><span class="hljs-meta">#<span class="hljs-meta-keyword">include</span> <span class="hljs-meta-string">&lt;cmath&gt;</span></span><span class="hljs-meta">#<span class="hljs-meta-keyword">include</span> <span class="hljs-meta-string">&lt;algorithm&gt;</span></span><span class="hljs-meta">#<span class="hljs-meta-keyword">define</span> maxn 200100</span><span class="hljs-keyword">using</span> <span class="hljs-keyword">namespace</span> <span class="hljs-built_in">std</span>;<span class="hljs-keyword">char</span> s[maxn];<span class="hljs-keyword">char</span> outs[maxn];<span class="hljs-comment">//int alpha[26];</span><span class="hljs-keyword">bool</span> mark[<span class="hljs-number">26</span>];<span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">node</span>&#123;</span><span class="hljs-keyword">char</span> letter;<span class="hljs-keyword">int</span> times;&#125;alpha[<span class="hljs-number">26</span>];<span class="hljs-function"><span class="hljs-keyword">bool</span> <span class="hljs-title">cmp</span><span class="hljs-params">(struct node n1,struct node n2)</span></span>&#123;<span class="hljs-keyword">return</span> n1.letter&gt;n2.letter;&#125;<span class="hljs-function"><span class="hljs-keyword">bool</span> <span class="hljs-title">cmp1</span><span class="hljs-params">(struct node n1,struct node n2)</span></span>&#123;<span class="hljs-keyword">return</span> n1.letter&lt;n2.letter;&#125;<span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">odd</span><span class="hljs-params">(<span class="hljs-keyword">int</span> len)</span></span>&#123;<span class="hljs-comment">//printf("in odd\n");</span><span class="hljs-keyword">for</span>(<span class="hljs-keyword">int</span> i=<span class="hljs-number">0</span>;i&lt;len;i++)&#123;alpha[s[i]<span class="hljs-number">-97</span>].times++;&#125;sort(alpha,alpha+<span class="hljs-number">26</span>,cmp);<span class="hljs-comment">//for(int i=0;i&lt;26;i++)</span><span class="hljs-comment">//&#123;</span><span class="hljs-comment">//printf("%d  %c %d\n",i,alpha[i].letter,alpha[i].times);</span><span class="hljs-comment">//&#125;</span><span class="hljs-keyword">int</span> point=<span class="hljs-number">0</span>,target=<span class="hljs-number">0</span>;<span class="hljs-keyword">for</span>(<span class="hljs-keyword">int</span> i=<span class="hljs-number">0</span>;i&lt;<span class="hljs-number">26</span>;i++)&#123;<span class="hljs-keyword">if</span>(!(alpha[i].times%<span class="hljs-number">2</span>)) <span class="hljs-keyword">continue</span>;<span class="hljs-keyword">else</span>&#123;target=i;<span class="hljs-keyword">int</span> j;<span class="hljs-keyword">for</span>(j=target,point=<span class="hljs-number">0</span>;j&lt;<span class="hljs-number">26</span>;j++)&#123;<span class="hljs-keyword">if</span>(!(alpha[j].times%<span class="hljs-number">2</span>)) <span class="hljs-keyword">continue</span>;<span class="hljs-keyword">else</span> point=j;&#125;<span class="hljs-keyword">if</span>(point==<span class="hljs-number">0</span>) <span class="hljs-keyword">break</span>;<span class="hljs-keyword">else</span>&#123;alpha[point].times++;alpha[target].times--;&#125;&#125;&#125;<span class="hljs-comment">//for(int i=0;i&lt;26;i++)</span><span class="hljs-comment">//&#123;</span><span class="hljs-comment">//printf("%d  %c %d\n",i,alpha[i].letter,alpha[i].times);</span><span class="hljs-comment">//&#125;</span><span class="hljs-keyword">char</span> c=alpha[target].letter;<span class="hljs-keyword">char</span> t=alpha[target].times;<span class="hljs-comment">//printf("target=%c\n",c);</span><span class="hljs-comment">//target 中间单值</span><span class="hljs-keyword">int</span> count=<span class="hljs-number">0</span>;<span class="hljs-keyword">int</span> leftlen=len-alpha[target].times;sort(alpha,alpha+<span class="hljs-number">26</span>,cmp1);<span class="hljs-comment">//printf("now len=%d\n",leftlen);</span><span class="hljs-keyword">for</span>(<span class="hljs-keyword">int</span> i=<span class="hljs-number">0</span>;count&lt;(len<span class="hljs-number">-1</span>)/<span class="hljs-number">2</span>;i++)&#123;<span class="hljs-keyword">if</span>(alpha[i].letter==c) <span class="hljs-keyword">for</span>(<span class="hljs-keyword">int</span> j=<span class="hljs-number">0</span>;j&lt;(alpha[i].times<span class="hljs-number">-1</span>)/<span class="hljs-number">2</span>;j++)outs[count++]=alpha[i].letter;<span class="hljs-keyword">else</span> <span class="hljs-keyword">for</span>(<span class="hljs-keyword">int</span> j=<span class="hljs-number">0</span>;j&lt;alpha[i].times/<span class="hljs-number">2</span>;j++)outs[count++]=alpha[i].letter;&#125;<span class="hljs-keyword">int</span> i;<span class="hljs-keyword">for</span>(i=<span class="hljs-number">0</span>;i&lt;count;i++)&#123;<span class="hljs-built_in">printf</span>(<span class="hljs-string">"%c"</span>,outs[i]);&#125;<span class="hljs-built_in">printf</span>(<span class="hljs-string">"%c"</span>,c);<span class="hljs-keyword">for</span>(i=count<span class="hljs-number">-1</span>;i&gt;=<span class="hljs-number">0</span>;i--)&#123;<span class="hljs-built_in">printf</span>(<span class="hljs-string">"%c"</span>,outs[i]);&#125;<span class="hljs-built_in">printf</span>(<span class="hljs-string">"\n"</span>);&#125;<span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">even</span><span class="hljs-params">(<span class="hljs-keyword">int</span> len)</span></span>&#123;<span class="hljs-comment">//printf("in even\n");</span><span class="hljs-keyword">for</span>(<span class="hljs-keyword">int</span> i=<span class="hljs-number">0</span>;i&lt;len;i++)&#123;alpha[s[i]<span class="hljs-number">-97</span>].times++;&#125;sort(alpha,alpha+<span class="hljs-number">26</span>,cmp);<span class="hljs-comment">//for(int i=0;i&lt;26;i++)</span><span class="hljs-comment">//&#123;</span><span class="hljs-comment">//printf("%d  %c %d\n",i,alpha[i].letter,alpha[i].times);</span><span class="hljs-comment">//&#125;</span><span class="hljs-keyword">int</span> point=<span class="hljs-number">0</span>,target=<span class="hljs-number">0</span>;<span class="hljs-keyword">for</span>(<span class="hljs-keyword">int</span> i=<span class="hljs-number">0</span>;i&lt;<span class="hljs-number">26</span>;i++)&#123;<span class="hljs-comment">//if(i==25 ) printf("YOO\n");</span><span class="hljs-keyword">if</span>(!(alpha[i].times%<span class="hljs-number">2</span>)) <span class="hljs-keyword">continue</span>;<span class="hljs-keyword">else</span>&#123;target=i;<span class="hljs-keyword">int</span> j;<span class="hljs-keyword">for</span>(j=target,point=<span class="hljs-number">0</span>;j&lt;<span class="hljs-number">26</span>;j++)&#123;<span class="hljs-keyword">if</span>(!(alpha[j].times%<span class="hljs-number">2</span>)) <span class="hljs-keyword">continue</span>;<span class="hljs-keyword">else</span> point=j;&#125;<span class="hljs-keyword">if</span>(point==<span class="hljs-number">0</span>) <span class="hljs-keyword">break</span>;<span class="hljs-keyword">else</span>&#123;alpha[point].times++;alpha[target].times--;&#125;&#125;&#125;<span class="hljs-comment">//char c=alpha[target].letter;</span><span class="hljs-comment">//char t=alpha[target].times;</span><span class="hljs-comment">//printf("target=%c\n",c);</span><span class="hljs-comment">////target 中间单值</span><span class="hljs-keyword">int</span> count=<span class="hljs-number">0</span>;<span class="hljs-comment">//int leftlen=len-alpha[target].times;</span>sort(alpha,alpha+<span class="hljs-number">26</span>,cmp1);<span class="hljs-comment">//printf("now len=%d\n",leftlen);</span><span class="hljs-keyword">for</span>(<span class="hljs-keyword">int</span> i=<span class="hljs-number">0</span>;count&lt;len/<span class="hljs-number">2</span>;i++)&#123;<span class="hljs-keyword">for</span>(<span class="hljs-keyword">int</span> j=<span class="hljs-number">0</span>;j&lt;alpha[i].times/<span class="hljs-number">2</span>;j++)outs[count++]=alpha[i].letter;&#125;<span class="hljs-keyword">int</span> i;<span class="hljs-keyword">for</span>(i=<span class="hljs-number">0</span>;i&lt;count;i++)&#123;<span class="hljs-built_in">printf</span>(<span class="hljs-string">"%c"</span>,outs[i]);&#125;<span class="hljs-keyword">for</span>(i=count<span class="hljs-number">-1</span>;i&gt;=<span class="hljs-number">0</span>;i--)&#123;<span class="hljs-built_in">printf</span>(<span class="hljs-string">"%c"</span>,outs[i]);&#125;<span class="hljs-built_in">printf</span>(<span class="hljs-string">"\n"</span>);&#125;<span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span>&#123;<span class="hljs-comment">//freopen("in.txt", "r", stdin);//其实in.txt是可以修改成其他名字的  比如“输入.txt”，都是可以的，这里只是为了方便起见，下同； </span><span class="hljs-comment">//    freopen("outmy.txt", "w", stdout);</span><span class="hljs-keyword">while</span>(~<span class="hljs-built_in">scanf</span>(<span class="hljs-string">"%s"</span>,s))&#123;<span class="hljs-built_in">memset</span>(alpha,<span class="hljs-number">0</span>,<span class="hljs-keyword">sizeof</span>(alpha));<span class="hljs-keyword">for</span>(<span class="hljs-keyword">int</span> i=<span class="hljs-number">0</span>;i&lt;<span class="hljs-number">26</span>;i++)&#123;alpha[i].letter=<span class="hljs-string">'a'</span>+i;alpha[i].times=<span class="hljs-number">0</span>;&#125;<span class="hljs-keyword">int</span> len=<span class="hljs-built_in">strlen</span>(s);<span class="hljs-keyword">if</span>(len%<span class="hljs-number">2</span>)<span class="hljs-comment">//Odd</span>odd(len);<span class="hljs-keyword">else</span> even(len); &#125;<span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;&#125;</code></pre><h1 id="收获与反思"><a href="#收获与反思" class="headerlink" title="收获与反思"></a>收获与反思</h1><p>（第一次写贪心，由于开始理解有偏差，改了很多次，代码也很丑陋= =而且太冗长= =，好在最后AC了，需要后面再优化下。）</p>]]></content>
    
    
    <categories>
      
      <category>Computer Science</category>
      
      <category>ACM</category>
      
      <category>CodeForces</category>
      
    </categories>
    
    
    <tags>
      
      <tag>ACM</tag>
      
      <tag>CodeForces</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>【HDU-1716】解题报告（排列STL）</title>
    <link href="/post/e3e37943.html"/>
    <url>/post/e3e37943.html</url>
    
    <content type="html"><![CDATA[<h1 id="原始题目"><a href="#原始题目" class="headerlink" title="原始题目"></a>原始题目</h1><h2 id="排列2"><a href="#排列2" class="headerlink" title="排列2"></a>排列2</h2><ul><li>Time Limit: 1000/1000 MS (Java/Others)    </li><li>Memory Limit: 32768/32768 K (Java/Others)</li><li>Total Submission(s): 9524    </li><li>Accepted Submission(s): 3467</li></ul><h3 id="Problem-Description"><a href="#Problem-Description" class="headerlink" title="Problem Description"></a>Problem Description</h3><p>Ray又对数字的列产生了兴趣：<br>现有四张卡片，用这四张卡片能排列出很多不同的4位数，要求按从小到大的顺序输出这些4位数。</p><a id="more"></a> <h3 id="Input"><a href="#Input" class="headerlink" title="Input"></a>Input</h3><p>每组数据占一行，代表四张卡片上的数字（0≤数字≤9），如果四张卡片都是0，则输入结束。</p><h3 id="Output"><a href="#Output" class="headerlink" title="Output"></a>Output</h3><p>对每组卡片按从小到大的顺序输出所有能由这四张卡片组成的4位数，千位数字相同的在同一行，同一行中每个四位数间用空格分隔。<br>每组输出数据间空一行，最后一组数据后面没有空行。</p><h3 id="Sample-Input"><a href="#Sample-Input" class="headerlink" title="Sample Input"></a>Sample Input</h3><pre><code>1 2 3 41 1 2 30 1 2 30 0 0 0</code></pre><h3 id="Sample-Output"><a href="#Sample-Output" class="headerlink" title="Sample Output"></a>Sample Output</h3><pre><code>1234 1243 1324 1342 1423 14322134 2143 2314 2341 2413 24313124 3142 3214 3241 3412 34214123 4132 4213 4231 4312 43211123 1132 1213 1231 1312 13212113 2131 23113112 3121 32111023 1032 1203 1230 1302 13202013 2031 2103 2130 2301 23103012 3021 3102 3120 3201 3210</code></pre><h1 id="解题思路"><a href="#解题思路" class="headerlink" title="解题思路"></a>解题思路</h1><p>先利用sort排序，然后利用C++STL中的next_permutation()函数将符合要求的排列逐个输出，本题需要注意输出格式有以下几点要求：</p><ul><li><p>需要检测千位发生变化时换行（同一个数的排列每一行打印的四位数个数不一定相等）</p></li><li><p>含0的序列0不做首位（但是却经历这些排列，注意换行和空格的问题）</p></li><li><p>老样子，每一行最后一个四位数后没有空格，没有空格，没有空格（输出格式经常出的问题）。</p></li><li><p>除最后一行之外均有空行。</p></li></ul><h1 id="解题代码"><a href="#解题代码" class="headerlink" title="解题代码"></a>解题代码</h1><pre><code class="hljs C++"><span class="hljs-meta">#<span class="hljs-meta-keyword">include</span> <span class="hljs-meta-string">&lt;cstdio&gt;</span></span><span class="hljs-meta">#<span class="hljs-meta-keyword">include</span> <span class="hljs-meta-string">&lt;cstring&gt;</span></span><span class="hljs-meta">#<span class="hljs-meta-keyword">include</span> <span class="hljs-meta-string">&lt;cmath&gt;</span></span><span class="hljs-meta">#<span class="hljs-meta-keyword">include</span> <span class="hljs-meta-string">&lt;algorithm&gt;</span></span><span class="hljs-keyword">using</span> <span class="hljs-keyword">namespace</span> <span class="hljs-built_in">std</span>;<span class="hljs-keyword">int</span> a[<span class="hljs-number">4</span>];<span class="hljs-function"><span class="hljs-keyword">bool</span> <span class="hljs-title">cmp</span><span class="hljs-params">(<span class="hljs-keyword">int</span> a,<span class="hljs-keyword">int</span> b)</span></span>&#123;<span class="hljs-keyword">return</span> a&lt;b;&#125;<span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span>&#123;<span class="hljs-comment">//freopen("in.txt", "r", stdin);</span><span class="hljs-comment">//  freopen("out.txt", "w", stdout);</span><span class="hljs-keyword">int</span> i,count=<span class="hljs-number">0</span>,num=<span class="hljs-number">0</span>;<span class="hljs-keyword">for</span>(i=<span class="hljs-number">0</span>;i&lt;<span class="hljs-number">4</span>;i++)&#123;<span class="hljs-keyword">int</span> c;<span class="hljs-built_in">scanf</span>(<span class="hljs-string">"%d"</span>,&amp;c);a[count++]=c;<span class="hljs-comment">//printf("i=%d  a[i]=%d\n",i,a[i]);</span>&#125;sort(a,a+count,cmp);<span class="hljs-keyword">while</span>(a[<span class="hljs-number">0</span>]||a[<span class="hljs-number">1</span>]||a[<span class="hljs-number">2</span>]||a[<span class="hljs-number">3</span>])&#123;<span class="hljs-keyword">int</span> circle=<span class="hljs-number">0</span>;<span class="hljs-keyword">int</span> qian=a[<span class="hljs-number">0</span>];<span class="hljs-keyword">if</span>(qian&amp;&amp;num) <span class="hljs-built_in">printf</span>(<span class="hljs-string">"\n"</span>);<span class="hljs-keyword">int</span> sum=<span class="hljs-number">0</span>;<span class="hljs-keyword">do</span>&#123;<span class="hljs-keyword">int</span> j;<span class="hljs-keyword">if</span>(a[<span class="hljs-number">0</span>]==<span class="hljs-number">0</span>) <span class="hljs-keyword">continue</span>;<span class="hljs-comment">//跳过0开头的排列 </span><span class="hljs-keyword">if</span>(a[<span class="hljs-number">0</span>]!=qian)<span class="hljs-comment">//换行判定 </span>&#123;qian=a[<span class="hljs-number">0</span>];<span class="hljs-built_in">printf</span>(<span class="hljs-string">"\n%d"</span>,a[<span class="hljs-number">0</span>]);&#125; <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span>(sum) <span class="hljs-built_in">printf</span>(<span class="hljs-string">" %d"</span>,a[<span class="hljs-number">0</span>]);<span class="hljs-comment">//sum标记第一个数，sum非零四位数前均打印一个空格 </span><span class="hljs-keyword">else</span> <span class="hljs-built_in">printf</span>(<span class="hljs-string">"%d"</span>,a[<span class="hljs-number">0</span>]); <span class="hljs-keyword">for</span>(j=<span class="hljs-number">1</span>;j&lt;count<span class="hljs-number">-1</span>;j++)&#123;<span class="hljs-built_in">printf</span>(<span class="hljs-string">"%d"</span>,a[j]);&#125;<span class="hljs-built_in">printf</span>(<span class="hljs-string">"%d"</span>,a[j]);sum++;&#125;<span class="hljs-keyword">while</span>(next_permutation(a,a+count)); <span class="hljs-comment">//使用do while 先打印一次再变为下个排列 </span><span class="hljs-built_in">printf</span>(<span class="hljs-string">"\n"</span>);num++;count=<span class="hljs-number">0</span>,i=<span class="hljs-number">0</span>;<span class="hljs-keyword">for</span>(i=<span class="hljs-number">0</span>;i&lt;<span class="hljs-number">4</span>;i++)&#123;<span class="hljs-keyword">int</span> c;<span class="hljs-built_in">scanf</span>(<span class="hljs-string">"%d"</span>,&amp;c);<span class="hljs-comment">//if(c)</span><span class="hljs-comment">//&#123;</span>a[count++]=c;<span class="hljs-comment">//&#125;</span><span class="hljs-comment">//printf("i=%d  a[i]=%d\n",i,a[i]);</span>&#125;sort(a,a+count,cmp);&#125;<span class="hljs-keyword">return</span> <span class="hljs-number">0</span>; &#125;</code></pre><h1 id="收获与反思"><a href="#收获与反思" class="headerlink" title="收获与反思"></a>收获与反思</h1><p>再次运用next_permutation函数，加深印象，以及对于输出格式的严格控制。</p>]]></content>
    
    
    <categories>
      
      <category>Computer Science</category>
      
      <category>ACM</category>
      
      <category>HDU</category>
      
    </categories>
    
    
    <tags>
      
      <tag>ACM</tag>
      
      <tag>HDU</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>【POJ-2260】解题报告（模拟，图论引申）</title>
    <link href="/post/88e8ae98.html"/>
    <url>/post/88e8ae98.html</url>
    
    <content type="html"><![CDATA[<h1 id="原始题目"><a href="#原始题目" class="headerlink" title="原始题目"></a>原始题目</h1><h2 id="Error-Correction"><a href="#Error-Correction" class="headerlink" title="Error Correction"></a>Error Correction</h2><ul><li>Time Limit: 1000MS         </li><li>Memory Limit: 65536K</li><li>Total Submissions: 6820         </li><li>Accepted: 4286</li></ul><h3 id="Problem-Description"><a href="#Problem-Description" class="headerlink" title="Problem Description"></a>Problem Description</h3><a id="more"></a> <p>A boolean matrix has the parity property when each row and each column has an even sum, i.e. contains an even number of bits which are set. Here’s a 4 x 4 matrix which has the parity property: </p><pre><code>1 0 1 00 0 0 0    1 1 1 10 1 0 1</code></pre><p>The sums of the rows are 2, 0, 4 and 2. The sums of the columns are 2, 2, 2 and 2.<br>Your job is to write a program that reads in a matrix and checks if it has the parity property. If not, your program should check if the parity property can be established by changing only one bit. If this is not possible either, the matrix should be classified as corrupt. </p><h3 id="Input"><a href="#Input" class="headerlink" title="Input"></a>Input</h3><p>The input will contain one or more test cases. The first line of each test case contains one integer n (n&lt;100), representing the size of the matrix. On the next n lines, there will be n integers per line. No other integers than 0 and 1 will occur in the matrix. Input will be terminated by a value of 0 for n.</p><h3 id="Output"><a href="#Output" class="headerlink" title="Output"></a>Output</h3><p>For each matrix in the input file, print one line. If the matrix already has the parity property, print “OK”. If the parity property can be established by changing one bit, print “Change bit (i,j)” where i is the row and j the column of the bit to be changed. Otherwise, print “Corrupt”.</p><h3 id="Sample-Input"><a href="#Sample-Input" class="headerlink" title="Sample Input"></a>Sample Input</h3><pre><code>41 0 1 00 0 0 01 1 1 10 1 0 141 0 1 00 0 1 01 1 1 10 1 0 1 41 0 1 00 1 1 01 1 1 10 1 0 10</code></pre><h3 id="Sample-Output"><a href="#Sample-Output" class="headerlink" title="Sample Output"></a>Sample Output</h3><pre><code>OKChange bit (2,3)Corrupt</code></pre><h3 id="Source"><a href="#Source" class="headerlink" title="Source"></a>Source</h3><p>Ulm Local 1998</p><h1 id="题目大意"><a href="#题目大意" class="headerlink" title="题目大意"></a>题目大意</h1><p>给定一个n*n的由0/1构成的boolean矩阵，判断是否各行各列和均为偶数。</p><p>若是输出OK，若不是，可否更改其中一点的位置使行列均为偶数。输出这个点，若不可以，输出Corrupt</p><h1 id="解题思路"><a href="#解题思路" class="headerlink" title="解题思路"></a>解题思路</h1><p>改一个点即可的充要条件为行和列之中存在且仅有一行与一列的各自的和为奇数。</p><p>或者利用邻接矩阵的知识转化为有向图+深度优先搜索？？学姐讲的图论知识，还没有深入学习。 </p>]]></content>
    
    
    <categories>
      
      <category>Computer Science</category>
      
      <category>ACM</category>
      
      <category>POJ</category>
      
    </categories>
    
    
    <tags>
      
      <tag>ACM</tag>
      
      <tag>POJ</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>【POJ-1328】解题报告（二维转一维，贪心）</title>
    <link href="/post/cea184b4.html"/>
    <url>/post/cea184b4.html</url>
    
    <content type="html"><![CDATA[<h1 id="原始题目"><a href="#原始题目" class="headerlink" title="原始题目"></a>原始题目</h1><h2 id="Radar-Installation"><a href="#Radar-Installation" class="headerlink" title="Radar Installation"></a>Radar Installation</h2><ul><li>Time Limit: 1000MS         </li><li>Memory Limit: 10000K</li><li>Total Submissions: 96097         </li><li>Accepted: 21364</li></ul><h3 id="Problem-Description"><a href="#Problem-Description" class="headerlink" title="Problem Description"></a>Problem Description</h3><a id="more"></a> <p>Assume the coasting is an infinite straight line. Land is in one side of coasting, sea in the other. Each small island is a point locating in the sea side. And any radar installation, locating on the coasting, can only cover d distance, so an island in the sea can be covered by a radius installation, if the distance between them is at most d. </p><p>We use Cartesian coordinate system, defining the coasting is the x-axis. The sea side is above x-axis, and the land side below. Given the position of each island in the sea, and given the distance of the coverage of the radar installation, your task is to write a program to find the minimal number of radar installations to cover all the islands. Note that the position of an island is represented by its x-y coordinates. </p><p>Figure A Sample Input of Radar Installations</p><h3 id="Input"><a href="#Input" class="headerlink" title="Input"></a>Input</h3><p>The input consists of several test cases. The first line of each case contains two integers $n (1 \le n \le 1000)$ and d, where n is the number of islands in the sea and d is the distance of coverage of the radar installation. This is followed by n lines each containing two integers representing the coordinate of the position of each island. Then a blank line follows to separate the cases. </p><p>The input is terminated by a line containing pair of zeros </p><h3 id="Output"><a href="#Output" class="headerlink" title="Output"></a>Output</h3><p>For each test case output one line consisting of the test case number followed by the minimal number of radar installations needed. “-1” installation means no solution for that case.</p><h3 id="Sample-Input"><a href="#Sample-Input" class="headerlink" title="Sample Input"></a>Sample Input</h3><pre><code>3 21 2-3 12 11 20 20 0</code></pre><h3 id="Sample-Output"><a href="#Sample-Output" class="headerlink" title="Sample Output"></a>Sample Output</h3><pre><code>Case 1: 2Case 2: 1</code></pre><h3 id="Source"><a href="#Source" class="headerlink" title="Source"></a>Source</h3><p>Beijing 2002</p><h1 id="题目大意"><a href="#题目大意" class="headerlink" title="题目大意"></a>题目大意</h1><p>给定二维平面N个点的坐标作为小岛坐标，给定雷达辐射半径，求坐标轴上放置雷达的最少个数。</p><h1 id="解题思路"><a href="#解题思路" class="headerlink" title="解题思路"></a>解题思路</h1><p>将小岛在二维平面钟的坐标转化为一维坐标轴上的线段也即数轴上的闭区间。两个闭区间的交集表示可以同时辐射到这两个小岛的雷达可放置的区域。</p><p>由此，要使放置雷达的个数最少。将线段按左端点递增排序，采用贪心策略，对于下一个小岛能利用之前的雷达就利用，条件为，下一条线段的左端点小于公用范围（线段）右边界。否则雷达+1，并以该线段作为新雷达的公用范围。</p><p>注意：1.共用范围（线段）是不断减小的，后一条线段的有端点大于共用范围右端，则无影响，若小于右端，则新右边界变为该线段的右端点。</p><h1 id="解题代码"><a href="#解题代码" class="headerlink" title="解题代码"></a>解题代码</h1><pre><code class="hljs C++"><span class="hljs-meta">#<span class="hljs-meta-keyword">include</span> <span class="hljs-meta-string">&lt;cstdio&gt;</span></span><span class="hljs-meta">#<span class="hljs-meta-keyword">include</span> <span class="hljs-meta-string">&lt;cstring&gt;</span></span><span class="hljs-meta">#<span class="hljs-meta-keyword">include</span> <span class="hljs-meta-string">&lt;cmath&gt;</span></span><span class="hljs-meta">#<span class="hljs-meta-keyword">include</span> <span class="hljs-meta-string">&lt;algorithm&gt;</span></span><span class="hljs-meta">#<span class="hljs-meta-keyword">include</span> <span class="hljs-meta-string">&lt;queue&gt;</span></span><span class="hljs-meta">#<span class="hljs-meta-keyword">define</span> maxn 10010</span><span class="hljs-keyword">using</span> <span class="hljs-keyword">namespace</span> <span class="hljs-built_in">std</span>;<span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">line</span>&#123;</span><span class="hljs-keyword">double</span> left;<span class="hljs-keyword">double</span> right;&#125;island[<span class="hljs-number">10002</span>];<span class="hljs-function"><span class="hljs-keyword">bool</span> <span class="hljs-title">cmp</span><span class="hljs-params">(struct line s1,struct line s2)</span></span>&#123;<span class="hljs-keyword">return</span> s1.left&lt;s2.left;&#125;<span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span>&#123;<span class="hljs-comment">//freopen("in.txt", "r", stdin);</span><span class="hljs-comment">//    freopen("out.txt", "w", stdout);</span><span class="hljs-keyword">int</span> ni,nd;<span class="hljs-built_in">scanf</span>(<span class="hljs-string">"%d%d"</span>,&amp;ni,&amp;nd);<span class="hljs-keyword">int</span> count=<span class="hljs-number">0</span>;<span class="hljs-keyword">while</span>(ni||nd)&#123;<span class="hljs-keyword">bool</span> flag=<span class="hljs-literal">false</span>;<span class="hljs-keyword">for</span>(<span class="hljs-keyword">int</span> i=<span class="hljs-number">0</span>;i&lt;ni;i++)&#123;<span class="hljs-keyword">double</span> x,y;<span class="hljs-built_in">scanf</span>(<span class="hljs-string">"%lf%lf"</span>,&amp;x,&amp;y);<span class="hljs-keyword">if</span>(y&gt;nd)flag=<span class="hljs-literal">true</span>;<span class="hljs-comment">//printf("x=%lf y=%lf\n",x,y);</span>island[i].left=x-<span class="hljs-built_in">sqrt</span>(nd*nd-y*y);island[i].right=x+<span class="hljs-built_in">sqrt</span>(nd*nd-y*y);&#125;<span class="hljs-keyword">if</span>(flag)&#123;<span class="hljs-built_in">printf</span>(<span class="hljs-string">"Case %d: -1\n"</span>,++count);<span class="hljs-built_in">scanf</span>(<span class="hljs-string">"%d%d"</span>,&amp;ni,&amp;nd);&#125;<span class="hljs-keyword">else</span>&#123;sort(island,island+ni,cmp);<span class="hljs-comment">//for(int i=0;i&lt;ni;i++)</span><span class="hljs-comment">//printf("island[%d] left=%lf right=%lf\n",i,island[i].left,island[i].right);</span><span class="hljs-keyword">int</span> num=<span class="hljs-number">1</span>;<span class="hljs-keyword">double</span> minright=island[<span class="hljs-number">0</span>].right;<span class="hljs-keyword">for</span>(<span class="hljs-keyword">int</span> i=<span class="hljs-number">0</span>;i+<span class="hljs-number">1</span>&lt;ni;i++)&#123;<span class="hljs-keyword">if</span>(island[i+<span class="hljs-number">1</span>].left&lt;=minright)&#123;<span class="hljs-keyword">if</span>(island[i+<span class="hljs-number">1</span>].right&lt;minright)&#123;minright=island[i+<span class="hljs-number">1</span>].right;&#125;&#125;<span class="hljs-keyword">else</span>&#123;num++;<span class="hljs-comment">//printf("num++\n");</span>minright=island[i+<span class="hljs-number">1</span>].right;&#125;&#125;<span class="hljs-built_in">printf</span>(<span class="hljs-string">"Case %d: %d\n"</span>,++count,num);<span class="hljs-built_in">scanf</span>(<span class="hljs-string">"%d%d"</span>,&amp;ni,&amp;nd);&#125;&#125;<span class="hljs-comment">//fclose(stdin);//关闭文件  </span><span class="hljs-comment">//    fclose(stdout);//关闭文件 </span><span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;&#125;</code></pre><h1 id="收获与反思"><a href="#收获与反思" class="headerlink" title="收获与反思"></a>收获与反思</h1><p>二维问题转一维，学习一下。</p>]]></content>
    
    
    <categories>
      
      <category>Computer Science</category>
      
      <category>ACM</category>
      
      <category>POJ</category>
      
    </categories>
    
    
    <tags>
      
      <tag>ACM</tag>
      
      <tag>POJ</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>【CodeForces-825B】解题报告（模拟，五子棋）</title>
    <link href="/post/74479d01.html"/>
    <url>/post/74479d01.html</url>
    
    <content type="html"><![CDATA[<h1 id="原始题目"><a href="#原始题目" class="headerlink" title="原始题目"></a>原始题目</h1><h2 id="B-Five-In-a-Row"><a href="#B-Five-In-a-Row" class="headerlink" title="B. Five-In-a-Row"></a>B. Five-In-a-Row</h2><ul><li><p>time limit per test 1 second</p></li><li><p>memory limit per test 256 megabytes</p></li><li><p>input standard input</p></li><li><p>output standard output</p></li></ul><a id="more"></a> <p>Alice and Bob play 5-in-a-row game. They have a playing field of size 10 × 10. In turns they put either crosses or noughts, one at a time. Alice puts crosses and Bob puts noughts.</p><p>In current match they have made some turns and now it’s Alice’s turn. She wonders if she can put cross in such empty cell that she wins immediately.</p><p>Alice wins if some crosses in the field form line of length not smaller than 5. This line can be horizontal, vertical and diagonal.</p><h3 id="Input"><a href="#Input" class="headerlink" title="Input"></a>Input</h3><p>You are given matrix 10 × 10 (10 lines of 10 characters each) with capital Latin letters ‘X’ being a cross, letters ‘O’ being a nought and ‘.’ being an empty cell. The number of ‘X’ cells is equal to the number of ‘O’ cells and there is at least one of each type. There is at least one empty cell.</p><p>It is guaranteed that in the current arrangement nobody has still won.</p><h3 id="Output"><a href="#Output" class="headerlink" title="Output"></a>Output</h3><p>Print ‘YES’ if it’s possible for Alice to win in one turn by putting cross in some empty cell. Otherwise print ‘NO’.</p><h3 id="Examples"><a href="#Examples" class="headerlink" title="Examples"></a>Examples</h3><h4 id="input"><a href="#input" class="headerlink" title="input"></a>input</h4><pre><code>XX.XX..........OOOO.................................................................................</code></pre><h4 id="output"><a href="#output" class="headerlink" title="output"></a>output</h4><pre><code>YES</code></pre><h4 id="input-1"><a href="#input-1" class="headerlink" title="input"></a>input</h4><pre><code>XXOXX.....OO.O......................................................................................</code></pre><h4 id="output-1"><a href="#output-1" class="headerlink" title="output"></a>output</h4><pre><code>NO</code></pre><h1 id="题目大意"><a href="#题目大意" class="headerlink" title="题目大意"></a>题目大意</h1><p>给定一个五子棋棋盘，判断X棋一步之后能否胜利。</p><h1 id="解题思路"><a href="#解题思路" class="headerlink" title="解题思路"></a>解题思路</h1><p>没什么，自己写模拟。遍历每个可下的点判断横竖和斜方向上能否实现大于等于五子相连。</p><p>注意边界问题，可以采用左右上下各拓展4行4列。</p><h1 id="解题代码"><a href="#解题代码" class="headerlink" title="解题代码"></a>解题代码</h1><pre><code class="hljs C++"><span class="hljs-meta">#<span class="hljs-meta-keyword">include</span> <span class="hljs-meta-string">&lt;cstdio&gt;</span></span><span class="hljs-meta">#<span class="hljs-meta-keyword">include</span> <span class="hljs-meta-string">&lt;cstring&gt;</span></span><span class="hljs-meta">#<span class="hljs-meta-keyword">include</span> <span class="hljs-meta-string">&lt;cmath&gt;</span></span><span class="hljs-meta">#<span class="hljs-meta-keyword">include</span> <span class="hljs-meta-string">&lt;algorithm&gt;</span></span><span class="hljs-meta">#<span class="hljs-meta-keyword">include</span> <span class="hljs-meta-string">&lt;queue&gt;</span></span><span class="hljs-meta">#<span class="hljs-meta-keyword">define</span> maxn 10010</span><span class="hljs-keyword">using</span> <span class="hljs-keyword">namespace</span> <span class="hljs-built_in">std</span>;<span class="hljs-keyword">char</span> <span class="hljs-built_in">map</span>[<span class="hljs-number">20</span>][<span class="hljs-number">20</span>];<span class="hljs-function"><span class="hljs-keyword">bool</span> <span class="hljs-title">check</span><span class="hljs-params">(<span class="hljs-keyword">int</span> a,<span class="hljs-keyword">int</span> b)</span></span>&#123;<span class="hljs-built_in">map</span>[a][b]=<span class="hljs-number">1</span>;<span class="hljs-comment">//printf("begin check %d %d\n",a,b);</span><span class="hljs-keyword">int</span> conti,i,j;<span class="hljs-keyword">for</span>(conti=<span class="hljs-number">0</span>,i=a<span class="hljs-number">-4</span>;i&lt;=a+<span class="hljs-number">4</span>;i++) <span class="hljs-comment">//横向判断 </span>&#123;<span class="hljs-keyword">if</span>(<span class="hljs-built_in">map</span>[i][b]==<span class="hljs-number">1</span>) &#123;conti++;<span class="hljs-keyword">if</span>(conti&gt;<span class="hljs-number">4</span>) <span class="hljs-keyword">return</span> <span class="hljs-literal">true</span>;&#125;<span class="hljs-keyword">else</span>&#123;conti=<span class="hljs-number">0</span>;<span class="hljs-keyword">continue</span>;&#125;&#125; <span class="hljs-keyword">for</span>(conti=<span class="hljs-number">0</span>,j=b<span class="hljs-number">-4</span>;j&lt;=b+<span class="hljs-number">4</span>;j++) <span class="hljs-comment">//纵向判断 </span>&#123;<span class="hljs-keyword">if</span>(<span class="hljs-built_in">map</span>[a][j]==<span class="hljs-number">1</span>) &#123;conti++;<span class="hljs-keyword">if</span>(conti&gt;<span class="hljs-number">4</span>) <span class="hljs-keyword">return</span> <span class="hljs-literal">true</span>;&#125;<span class="hljs-keyword">else</span>&#123;conti=<span class="hljs-number">0</span>;<span class="hljs-keyword">continue</span>;&#125;&#125; <span class="hljs-keyword">for</span>(conti=<span class="hljs-number">0</span>,i=a<span class="hljs-number">-4</span>,j=b<span class="hljs-number">-4</span>;i&lt;=a+<span class="hljs-number">4</span>;i++,j++) <span class="hljs-comment">//斜向判断1 </span>&#123;<span class="hljs-keyword">if</span>(<span class="hljs-built_in">map</span>[i][j]==<span class="hljs-number">1</span>)&#123;conti++;<span class="hljs-keyword">if</span>(conti&gt;<span class="hljs-number">4</span>) <span class="hljs-keyword">return</span> <span class="hljs-literal">true</span>;&#125;<span class="hljs-keyword">else</span> &#123;conti=<span class="hljs-number">0</span>;<span class="hljs-keyword">continue</span>;&#125;&#125;<span class="hljs-keyword">for</span>(conti=<span class="hljs-number">0</span>,i=a<span class="hljs-number">-4</span>,j=b+<span class="hljs-number">4</span>;i&lt;=a+<span class="hljs-number">4</span>;i++,j--) <span class="hljs-comment">//斜向判断1 </span>&#123;<span class="hljs-keyword">if</span>(<span class="hljs-built_in">map</span>[i][j]==<span class="hljs-number">1</span>)&#123;conti++;<span class="hljs-keyword">if</span>(conti&gt;<span class="hljs-number">4</span>) <span class="hljs-keyword">return</span> <span class="hljs-literal">true</span>;&#125;<span class="hljs-keyword">else</span> &#123;conti=<span class="hljs-number">0</span>;<span class="hljs-keyword">continue</span>;&#125;&#125;<span class="hljs-built_in">map</span>[a][b]=<span class="hljs-number">0</span>;<span class="hljs-keyword">return</span> <span class="hljs-literal">false</span>; &#125;<span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span>&#123;<span class="hljs-comment">//freopen("in.txt", "r", stdin);//其实in.txt是可以修改成其他名字的  比如“输入.txt”，都是可以的，这里只是为了方便起见，下同； </span><span class="hljs-keyword">for</span>(<span class="hljs-keyword">int</span> i=<span class="hljs-number">0</span>+<span class="hljs-number">4</span>;i&lt;<span class="hljs-number">10</span>+<span class="hljs-number">4</span>;i++)&#123;<span class="hljs-built_in">scanf</span>(<span class="hljs-string">"%s"</span>,<span class="hljs-built_in">map</span>[i]+<span class="hljs-number">4</span>);&#125;<span class="hljs-keyword">for</span>(<span class="hljs-keyword">int</span> i=<span class="hljs-number">0</span>+<span class="hljs-number">4</span>;i&lt;<span class="hljs-number">10</span>+<span class="hljs-number">4</span>;i++)&#123;<span class="hljs-keyword">for</span>(<span class="hljs-keyword">int</span> j=<span class="hljs-number">0</span>+<span class="hljs-number">4</span>;j&lt;<span class="hljs-number">10</span>+<span class="hljs-number">4</span>;j++)&#123;<span class="hljs-keyword">switch</span>(<span class="hljs-built_in">map</span>[i][j])&#123;<span class="hljs-keyword">case</span> <span class="hljs-string">'X'</span>: <span class="hljs-built_in">map</span>[i][j]=<span class="hljs-number">1</span>;<span class="hljs-keyword">break</span>;<span class="hljs-keyword">case</span> <span class="hljs-string">'O'</span>: <span class="hljs-built_in">map</span>[i][j]=<span class="hljs-number">2</span>;<span class="hljs-keyword">break</span>;<span class="hljs-keyword">case</span> <span class="hljs-string">'.'</span>: <span class="hljs-built_in">map</span>[i][j]=<span class="hljs-number">0</span>;<span class="hljs-keyword">break</span>;&#125;<span class="hljs-comment">//printf("%d ",map[i][j]);</span>&#125;<span class="hljs-comment">//printf("\n");</span>&#125;<span class="hljs-keyword">int</span> flag=<span class="hljs-number">0</span>;<span class="hljs-keyword">for</span>(<span class="hljs-keyword">int</span> i=<span class="hljs-number">0</span>+<span class="hljs-number">4</span>;i&lt;<span class="hljs-number">10</span>+<span class="hljs-number">4</span>;i++)&#123;<span class="hljs-keyword">for</span>(<span class="hljs-keyword">int</span> j=<span class="hljs-number">0</span>+<span class="hljs-number">4</span>;j&lt;<span class="hljs-number">10</span>+<span class="hljs-number">4</span>;j++)&#123;<span class="hljs-keyword">if</span>(<span class="hljs-built_in">map</span>[i][j]||!<span class="hljs-built_in">map</span>[i<span class="hljs-number">-1</span>][j]&amp;&amp;!<span class="hljs-built_in">map</span>[i+<span class="hljs-number">1</span>][j]&amp;&amp;!<span class="hljs-built_in">map</span>[i][j<span class="hljs-number">-1</span>]&amp;&amp;!<span class="hljs-built_in">map</span>[i][j+<span class="hljs-number">1</span>]&amp;&amp;!<span class="hljs-built_in">map</span>[i<span class="hljs-number">-1</span>][j<span class="hljs-number">-1</span>]&amp;&amp;!<span class="hljs-built_in">map</span>[i+<span class="hljs-number">1</span>][j+<span class="hljs-number">1</span>]&amp;&amp;!<span class="hljs-built_in">map</span>[i<span class="hljs-number">-1</span>][j+<span class="hljs-number">1</span>]&amp;&amp;!<span class="hljs-built_in">map</span>[i+<span class="hljs-number">1</span>][j<span class="hljs-number">-1</span>]) <span class="hljs-keyword">continue</span>;<span class="hljs-keyword">else</span> flag=check(i,j);<span class="hljs-keyword">if</span>(flag)&#123;<span class="hljs-comment">//printf("%d %d \n",i-4,j-4);</span><span class="hljs-keyword">break</span>;&#125;&#125;<span class="hljs-keyword">if</span>(flag)<span class="hljs-keyword">break</span>;&#125;<span class="hljs-keyword">if</span>(flag)<span class="hljs-built_in">printf</span>(<span class="hljs-string">"YES\n"</span>);<span class="hljs-keyword">else</span> <span class="hljs-built_in">printf</span>(<span class="hljs-string">"NO\n"</span>);<span class="hljs-comment">//fclose(stdin);</span><span class="hljs-comment">//fclose(stdout);</span><span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;&#125;</code></pre><h1 id="总结与反思"><a href="#总结与反思" class="headerlink" title="总结与反思"></a>总结与反思</h1><p>模拟的时候要注意细节，尽量不要返工。</p><p>能简化的简化（后面会学到剪纸），比如判定周围一圈没有棋子可以直接continue跳过该循环。</p>]]></content>
    
    
    <categories>
      
      <category>Computer Science</category>
      
      <category>ACM</category>
      
      <category>CodeForces</category>
      
    </categories>
    
    
    <tags>
      
      <tag>ACM</tag>
      
      <tag>CodeForces</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>【HDU-1027】解题报告（排列STL）</title>
    <link href="/post/a4c66bf4.html"/>
    <url>/post/a4c66bf4.html</url>
    
    <content type="html"><![CDATA[<h1 id="原始题目"><a href="#原始题目" class="headerlink" title="原始题目"></a>原始题目</h1><h2 id="Ignatius-and-the-Princess-II"><a href="#Ignatius-and-the-Princess-II" class="headerlink" title="Ignatius and the Princess II"></a>Ignatius and the Princess II</h2><ul><li>Time Limit: 2000/1000 MS (Java/Others)    </li><li>Memory Limit: 65536/32768 K (Java/Others)</li><li>Total Submission(s): 9305    </li><li>Accepted Submission(s): 5446</li></ul><h3 id="Problem-Description"><a href="#Problem-Description" class="headerlink" title="Problem Description"></a>Problem Description</h3><a id="more"></a> <p>Now our hero finds the door to the BEelzebub feng5166. He opens the door and finds feng5166 is about to kill our pretty Princess. But now the BEelzebub has to beat our hero first. feng5166 says, “I have three question for you, if you can work them out, I will release the Princess, or you will be my dinner, too.” Ignatius says confidently, “OK, at last, I will save the Princess.”</p><p>“Now I will show you the first problem.” feng5166 says, “Given a sequence of number 1 to N, we define that 1,2,3…N-1,N is the smallest sequence among all the sequence which can be composed with number 1 to N(each number can be and should be use only once in this problem). So it’s easy to see the second smallest sequence is 1,2,3…N,N-1. Now I will give you two numbers, N and M. You should tell me the Mth smallest sequence which is composed with number 1 to N. It’s easy, isn’t is? Hahahahaha……”<br>Can you help Ignatius to solve this problem?</p><h3 id="Input"><a href="#Input" class="headerlink" title="Input"></a>Input</h3><p>The input contains several test cases. Each test case consists of two numbers, $N$ and $M$ (1 \le N \le 1000, 1 \le M \le 10000). You may assume that there is always a sequence satisfied the BEelzebub’s demand. The input is terminated by the end of file.</p><h3 id="Output"><a href="#Output" class="headerlink" title="Output"></a>Output</h3><p>For each test case, you only have to output the sequence satisfied the BEelzebub’s demand. When output a sequence, you should print a space between two numbers, but do not output any spaces after the last number.</p><h3 id="Sample-Input"><a href="#Sample-Input" class="headerlink" title="Sample Input"></a>Sample Input</h3><pre><code>6 411 8</code></pre><h3 id="Sample-Output"><a href="#Sample-Output" class="headerlink" title="Sample Output"></a>Sample Output</h3><pre><code>1 2 3 5 6 41 2 3 4 5 6 7 9 8 11 10</code></pre><h3 id="Author"><a href="#Author" class="headerlink" title="Author"></a>Author</h3><p>Ignatius.L</p><h1 id="题目大意"><a href="#题目大意" class="headerlink" title="题目大意"></a>题目大意</h1><p>定义排列逆序，输出对应编号的排列</p><h1 id="解题思路"><a href="#解题思路" class="headerlink" title="解题思路"></a>解题思路</h1><p>利用C++STL中的next_permutation()函数实现对数组排列，调用m-1次该函数然后按格式输出即可。</p><h1 id="解题代码"><a href="#解题代码" class="headerlink" title="解题代码"></a>解题代码</h1><pre><code class="hljs C++"><span class="hljs-meta">#<span class="hljs-meta-keyword">include</span> <span class="hljs-meta-string">&lt;iostream&gt; </span></span><span class="hljs-meta">#<span class="hljs-meta-keyword">include</span> <span class="hljs-meta-string">&lt;algorithm&gt;</span></span><span class="hljs-meta">#<span class="hljs-meta-keyword">include</span> <span class="hljs-meta-string">&lt;string&gt;</span></span><span class="hljs-meta">#<span class="hljs-meta-keyword">include</span> <span class="hljs-meta-string">&lt;stack&gt;</span></span><span class="hljs-meta">#<span class="hljs-meta-keyword">include</span> <span class="hljs-meta-string">&lt;vector&gt;</span></span><span class="hljs-meta">#<span class="hljs-meta-keyword">define</span> maxn 100010</span><span class="hljs-keyword">using</span> <span class="hljs-keyword">namespace</span> <span class="hljs-built_in">std</span>;<span class="hljs-keyword">int</span> a[maxn];<span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span>&#123;<span class="hljs-keyword">int</span> n,m;<span class="hljs-keyword">while</span>(<span class="hljs-built_in">cin</span>&gt;&gt;n&gt;&gt;m)<span class="hljs-comment">//cin&gt;&gt;n&gt;&gt;m;</span>&#123;<span class="hljs-keyword">for</span>(<span class="hljs-keyword">int</span> i=<span class="hljs-number">0</span>;i&lt;n;i++)&#123;a[i]=i+<span class="hljs-number">1</span>;&#125;<span class="hljs-comment">//vector&lt;int&gt; v1(a,a+n);没有利用上vector 待补充 </span><span class="hljs-comment">//vector&lt;int&gt;::iterator p=v1.begin();</span><span class="hljs-keyword">int</span> count=m<span class="hljs-number">-1</span>;<span class="hljs-comment">//设置计数器 </span><span class="hljs-keyword">do</span><span class="hljs-comment">//注意使用dowhile </span>&#123;<span class="hljs-comment">//for(int j=0;j&lt;n;j++)</span><span class="hljs-comment">//cout&lt;&lt;a[j]&lt;&lt;" ";</span><span class="hljs-comment">//cout&lt;&lt;endl; </span>count--;&#125;<span class="hljs-keyword">while</span>(next_permutation(a,a+n)&amp;&amp;count);<span class="hljs-keyword">for</span>(<span class="hljs-keyword">int</span> j=<span class="hljs-number">0</span>;j&lt;n<span class="hljs-number">-1</span>;j++)<span class="hljs-built_in">cout</span>&lt;&lt;a[j]&lt;&lt;<span class="hljs-string">" "</span>;<span class="hljs-built_in">cout</span>&lt;&lt;a[n<span class="hljs-number">-1</span>]&lt;&lt;<span class="hljs-built_in">endl</span>; <span class="hljs-comment">//输出格式最后一个数后面没有空格 </span>&#125;<span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;&#125;</code></pre><h1 id="收获与反思"><a href="#收获与反思" class="headerlink" title="收获与反思"></a>收获与反思</h1><p>图片待添加</p>]]></content>
    
    
    <categories>
      
      <category>Computer Science</category>
      
      <category>ACM</category>
      
      <category>HDU</category>
      
    </categories>
    
    
    <tags>
      
      <tag>ACM</tag>
      
      <tag>HDU</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>《乌合之众——群体心理研究》读后感</title>
    <link href="/post/94c9baee.html"/>
    <url>/post/94c9baee.html</url>
    
    <content type="html"><![CDATA[<h1 id="内容摘录"><a href="#内容摘录" class="headerlink" title="内容摘录"></a>内容摘录</h1><blockquote><p>P51 影响大众想象力的不是是事实本身，而是他所扩展和传播的方式。</p><p>P56 群体的所有信仰都采取宗教形式，对群体来说，必须有个神，否则什么都谈不上。</p><p>P92 理性从来就不曾指导过群体，这值得后悔吗？我们不敢这么说。理性把人类带向了文明之路，但缺乏幻觉所激起的那种热情和勇敢。这些幻觉也许是必要的，它们是支配我们的无意识造成的。</p><p>P100 第二种领导，意志持久……他们聪明过人，还是智慧有限，这不重要。世界将永远属于他们。他们所拥有的持久意志是一种十分罕见而强大的能力，能战胜一切。</p><p>P160 （议会制）它反映了一种心理上错误但被普遍认同的观点，即对某个问题，许多人聚在一起比一小部分人更能做出明智而独立的决定。</p></blockquote><a id="more"></a><blockquote><p>P177 随着古老理想的彻底丧失，种族将最终完全失去自己的灵魂，成了一群独处的个人，回到了起点：群体，表现出一切短时间的特征，步调不一，没有前途。文明失去了稳定性，只能随风飘散。民众掌握了至高无上的大权，社会变得越来越野蛮。文明似乎还能辉煌一段时间，因为它扔拥有漫长历史所建的外墙，但那其实是一座已经被虫蛀空的大厦，支撑不了多久，暴风雨一来就会倒塌。<br>从野蛮到文明，一路追逐着梦想，而当这种梦想失去了力量，便开始衰落，走向死亡，这就是一个民族的生命周期。</p></blockquote>]]></content>
    
    
    <categories>
      
      <category>Life</category>
      
      <category>阅读</category>
      
    </categories>
    
    
    <tags>
      
      <tag>阅读</tag>
      
    </tags>
    
  </entry>
  
  
  
  
</search>
