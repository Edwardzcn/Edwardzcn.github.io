

<!DOCTYPE html>
<html lang="zh-CN" data-default-color-scheme=&#34;auto&#34;>



<head>
  <!-- hexo-inject:begin --><!-- hexo-inject:end --><meta charset="UTF-8">
  <link rel="apple-touch-icon" sizes="76x76" href="https://eddyblog.oss-cn-shenzhen.aliyuncs.com/Blog/favicon.jpg">
  <link rel="icon" href="https://eddyblog.oss-cn-shenzhen.aliyuncs.com/Blog/favicon.jpg">
  <meta name="viewport"
        content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=no, shrink-to-fit=no">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  
  <meta name="theme-color" content="#2f4154">
  <meta name="description" content="数字图像基础对应梁老师课件第二章，着重掌握基本概念。
图像的获取略
图像的采样与量化
大多数传感器的输出是连续电压波形
为了产生一幅数字图像，需要把连续的感知数据转化为数字形式
这包括两种处理：采样和量化

采样
图像空间坐标的数字化（离散化）
决定了图像的空间分辨率
行采样像素$M$个，列采样$N$个构成$M \times N$的实数矩阵
为编程方便采用矩阵坐标系


量化
图像像素灰度值的数字">
  <meta name="author" content="Edwardzcn">
  <meta name="keywords" content="Edward&#39;s blog">
  
  <title>数字图像处理——章节总复习 - Edward&#39;s blog</title>

  <link  rel="stylesheet" href="https://cdn.jsdelivr.net/npm/bootstrap@4.5.3/dist/css/bootstrap.min.css" />


  <link  rel="stylesheet" href="https://cdn.jsdelivr.net/npm/github-markdown-css@4.0.0/github-markdown.min.css" />
  <link  rel="stylesheet" href="/lib/hint/hint.min.css" />

  
    
    
      
      <link  rel="stylesheet" href="https://cdn.jsdelivr.net/npm/highlight.js@10.6.0/styles/github-gist.min.css" />
    
  

  
    <link  rel="stylesheet" href="https://cdn.jsdelivr.net/npm/@fancyapps/fancybox@3.5.7/dist/jquery.fancybox.min.css" />
  



<!-- 主题依赖的图标库，不要自行修改 -->

<link rel="stylesheet" href="//at.alicdn.com/t/font_1749284_ba1fz6golrf.css">



<link rel="stylesheet" href="//at.alicdn.com/t/font_1736178_kmeydafke9r.css">


<link  rel="stylesheet" href="/css/main.css" />

<!-- 自定义样式保持在最底部 -->

  
<link rel="stylesheet" href="/css/iconfont.css">



  <script id="fluid-configs">
    var Fluid = window.Fluid || {};
    var CONFIG = {"hostname":"www.edwardzcn98yx.com","root":"/","version":"1.8.10","typing":{"enable":true,"typeSpeed":70,"cursorChar":"_","loop":false},"anchorjs":{"enable":true,"element":"h1,h2,h3,h4,h5,h6","placement":"right","visible":"hover","icon":""},"progressbar":{"enable":true,"height_px":3,"color":"#29d","options":{"showSpinner":false,"trickleSpeed":100}},"copy_btn":true,"image_zoom":{"enable":true,"img_url_replace":["",""]},"toc":{"enable":true,"headingSelector":"h1,h2,h3,h4,h5,h6","collapseDepth":0},"lazyload":{"enable":true,"loading_img":"/img/loading.gif","onlypost":false,"offset_factor":2},"web_analytics":{"enable":false,"baidu":null,"google":null,"gtag":null,"tencent":{"sid":null,"cid":null},"woyaola":null,"cnzz":null,"leancloud":{"app_id":null,"app_key":null,"server_url":null}}};
  </script>
  <script  src="/js/utils.js" ></script>
  <script  src="/js/color-schema.js" ></script>
<meta name="generator" content="Hexo 5.2.0"><!-- hexo-inject:begin --><!-- hexo-inject:end --></head>


<body>
  <!-- hexo-inject:begin --><!-- hexo-inject:end --><header style="height: 70vh;">
    <nav id="navbar" class="navbar fixed-top  navbar-expand-lg navbar-dark scrolling-navbar">
  <div class="container">
    <a class="navbar-brand"
       href="/">&nbsp;<strong>Edwardzcn</strong>&nbsp;</a>

    <button id="navbar-toggler-btn" class="navbar-toggler" type="button" data-toggle="collapse"
            data-target="#navbarSupportedContent"
            aria-controls="navbarSupportedContent" aria-expanded="false" aria-label="Toggle navigation">
      <div class="animated-icon"><span></span><span></span><span></span></div>
    </button>

    <!-- Collapsible content -->
    <div class="collapse navbar-collapse" id="navbarSupportedContent">
      <ul class="navbar-nav ml-auto text-center">
        
          
          
          
          
            <li class="nav-item">
              <a class="nav-link" href="/">
                <i class="iconfont icon-home-fill"></i>
                首页
              </a>
            </li>
          
        
          
          
          
          
            <li class="nav-item">
              <a class="nav-link" href="/categories/">
                <i class="iconfont icon-category-fill"></i>
                分类
              </a>
            </li>
          
        
          
          
          
          
            <li class="nav-item dropdown">
              <a class="nav-link dropdown-toggle" target="_self" role="button"
                 data-toggle="dropdown" aria-haspopup="true" aria-expanded="false">
                <i class="iconfont icon-bookmark"></i>
                select
              </a>
              <div class="dropdown-menu" aria-labelledby="navbarDropdown">
                
                  
                  
                  
                  <a class="dropdown-item" href="/categories/Computer-Science/">
                    <i class="iconfont icon-codeforces"></i>
                    Computer Science
                  </a>
                
                  
                  
                  
                  <a class="dropdown-item" href="/categories/Life/%E9%98%85%E8%AF%BB/">
                    <i class="iconfont icon-bookmark-fill"></i>
                    Life Reading
                  </a>
                
                  
                  
                  
                  <a class="dropdown-item" href="/categories/Life/%E9%9A%8F%E7%AC%94/">
                    <i class="iconfont icon-note"></i>
                    Life Essay
                  </a>
                
                  
                  
                  
                  <a class="dropdown-item" href="/categories/Research/Report/">
                    <i class="iconfont icon-clipcheck"></i>
                    Weekly Report
                  </a>
                
              </div>
            </li>
          
        
          
          
          
          
            <li class="nav-item">
              <a class="nav-link" href="/tags/">
                <i class="iconfont icon-tags-fill"></i>
                标签
              </a>
            </li>
          
        
          
          
          
          
            <li class="nav-item">
              <a class="nav-link" href="/about/">
                <i class="iconfont icon-user-fill"></i>
                关于
              </a>
            </li>
          
        
          
          
          
          
            <li class="nav-item">
              <a class="nav-link" href="/links/">
                <i class="iconfont icon-link-fill"></i>
                友链
              </a>
            </li>
          
        
          
          
          
          
            <li class="nav-item">
              <a class="nav-link" href="/photos">
                <i class="iconfont icon-image"></i>
                gallery
              </a>
            </li>
          
        
          
          
          
          
            <li class="nav-item">
              <a class="nav-link" target="_blank" rel="noopener" href="https://www.instagram.com/edwardzcn/">
                <i class="iconfont icon-instagram"></i>
                ins
              </a>
            </li>
          
        
        
          <li class="nav-item" id="search-btn">
            <a class="nav-link" target="_self" data-toggle="modal" data-target="#modalSearch">&nbsp;<i
                class="iconfont icon-search"></i>&nbsp;</a>
          </li>
        
        
          <li class="nav-item" id="color-toggle-btn">
            <a class="nav-link" target="_self">&nbsp;<i
                class="iconfont icon-dark" id="color-toggle-icon"></i>&nbsp;</a>
          </li>
        
      </ul>
    </div>
  </div>
</nav>

    <div class="banner" id="banner" parallax=true
         style="background: url('https://eddyblog.oss-cn-shenzhen.aliyuncs.com/Blog/bg2.jpg') no-repeat center center;
           background-size: cover;">
      <div class="full-bg-img">
        <div class="mask flex-center" style="background-color: rgba(0, 0, 0, 0.3)">
          <div class="page-header text-center fade-in-up">
            <span class="h2" id="subtitle" title="数字图像处理——章节总复习">
              
            </span>

            
              <div class="mt-3">
  
    <span class="post-meta mr-2">
      <i class="iconfont icon-author" aria-hidden="true"></i>
      Edwardzcn
    </span>
  
  
    <span class="post-meta">
      <i class="iconfont icon-date-fill" aria-hidden="true"></i>
      <time datetime="2019-12-23 12:33" pubdate>
        2019年12月23日 下午
      </time>
    </span>
  
</div>

<div class="mt-1">
  
    
    <span class="post-meta mr-2">
      <i class="iconfont icon-chart"></i>
      11.7k 字
    </span>
  

  
    
    <span class="post-meta mr-2">
      <i class="iconfont icon-clock-fill"></i>
      
      
      152
       分钟
    </span>
  

  
  
</div>

            
          </div>

          
        </div>
      </div>
    </div>
  </header>

  <main>
    
      

<div class="container-fluid nopadding-x">
  <div class="row nomargin-x">
    <div class="d-none d-lg-block col-lg-2"></div>
    <div class="col-lg-8 nopadding-x-md">
      <div class="container nopadding-x-md" id="board-ctn">
        <div class="py-5" id="board">
          <article class="post-content mx-auto">
            <!-- SEO header -->
            <h1 style="display: none">数字图像处理——章节总复习</h1>
            
            <div class="markdown-body">
              <h1 id="数字图像基础"><a href="#数字图像基础" class="headerlink" title="数字图像基础"></a>数字图像基础</h1><p>对应梁老师课件第二章，着重掌握基本概念。</p>
<h2 id="图像的获取"><a href="#图像的获取" class="headerlink" title="图像的获取"></a>图像的获取</h2><p>略</p>
<h2 id="图像的采样与量化"><a href="#图像的采样与量化" class="headerlink" title="图像的采样与量化"></a>图像的采样与量化</h2><ul>
<li>大多数传感器的输出是连续电压波形</li>
<li>为了产生一幅数字图像，需要把连续的感知数据转化为数字形式</li>
<li>这包括两种处理：采样和量化</li>
</ul>
<h3 id="采样"><a href="#采样" class="headerlink" title="采样"></a>采样</h3><ul>
<li>图像空间坐标的数字化（离散化）</li>
<li>决定了图像的空间分辨率</li>
<li>行采样像素$M$个，列采样$N$个构成$M \times N$的实数矩阵</li>
<li>为编程方便采用矩阵坐标系</li>
<li><img src="https://eddyblog.oss-cn-shenzhen.aliyuncs.com/ImageProcess/Review/Review_1.JPG" srcset="/img/loading.gif" lazyload alt="1"></li>
</ul>
<h3 id="量化"><a href="#量化" class="headerlink" title="量化"></a>量化</h3><ul>
<li>图像像素灰度值的数字化（离散化）</li>
<li>从模拟量到数字量（离散量）</li>
<li>决定了图像的幅度（灰度级）分辨率</li>
</ul>
<h3 id="采样点数和量化级数的关系"><a href="#采样点数和量化级数的关系" class="headerlink" title="采样点数和量化级数的关系"></a>采样点数和量化级数的关系</h3><p>对一幅图像，当量化级数一定时，采样点数对图像质量有着显著的影响。采样点数越多，图像质量越好； 当采样点数减少时，图上的块状效应就逐渐明显。</p>
<p>同理，当图像的采样点数一定时，采用不同量化级数的图像质量也不一样。量化级数越多，图像质量越好，当量化级数越少时，图像质量越差，量化级数最小的极端情况就是二值图像，图像出现假轮廓。</p>
<h2 id="像素间基本关系"><a href="#像素间基本关系" class="headerlink" title="像素间基本关系"></a>像素间基本关系</h2><h3 id="通路"><a href="#通路" class="headerlink" title="通路"></a>通路</h3><p><img src="https://eddyblog.oss-cn-shenzhen.aliyuncs.com/ImageProcess/Review/Review_2.JPG" srcset="/img/loading.gif" lazyload alt="2"></p>
<h3 id="距离"><a href="#距离" class="headerlink" title="距离"></a>距离</h3><p><img src="https://eddyblog.oss-cn-shenzhen.aliyuncs.com/ImageProcess/Review/Review_3.JPG" srcset="/img/loading.gif" lazyload alt="3"></p>
<p>主要区分$D_e$欧式距离，$D_4$距离和$D_8$距离。</p>
<p><img src="https://eddyblog.oss-cn-shenzhen.aliyuncs.com/ImageProcess/Review/Review_4.JPG" srcset="/img/loading.gif" lazyload alt="4"></p>
<p><img src="https://eddyblog.oss-cn-shenzhen.aliyuncs.com/ImageProcess/Review/Review_5.JPG" srcset="/img/loading.gif" lazyload alt="5"></p>
<p><img src="https://eddyblog.oss-cn-shenzhen.aliyuncs.com/ImageProcess/Review/Review_6.JPG" srcset="/img/loading.gif" lazyload alt="6"></p>
<h2 id="图像类型"><a href="#图像类型" class="headerlink" title="图像类型"></a>图像类型</h2><ul>
<li><p>二值图像(Binary images)</p>
<ul>
<li>二值图像也叫黑白图像，编程实现中就指是图像象素只存在 0,1 两个值的逻辑数组。</li>
</ul>
</li>
<li><p>亮度图像(Intensity images)</p>
<ul>
<li>亮度图像是包含亮度级的图像，如 64 级，256 级等。</li>
<li>如当亮度图像像素用 unit8 或 unit16 表示时，每个像素的整数取值范围分别是[0,255]和[0,65535]。</li>
<li>如当亮度图像像素用 double 表示时，则像素的取值为浮点数，规定双精度归一化亮度图像的取值范围为[0,1]。</li>
</ul>
</li>
<li><p>索引图像(Indexed images)</p>
<ul>
<li>索引图像把像素值直接作为索引颜色的序号。</li>
<li>根据索引颜色的序号就可以找到该像素的实际颜色。</li>
<li>当把索引图像读入计算机时，索引颜色将被存储到调色板中。</li>
</ul>
</li>
<li><p>RGB 图像(RGB images)</p>
<ul>
<li>一副 RGB 图像就是彩色像素的一个 M×N×3 数组，其中每一个彩色像素点都是在特定空间位置的彩色图像对应的红、绿、蓝三个分量。也可视为由三幅灰度图像形成的“堆”。</li>
<li>这类图像不使用单独的调色板，每一个像素的颜色由存储在相应位置的红，绿，蓝颜色分量共同决定。</li>
<li>RGB 图像是 24 位图像，红绿蓝分量分别占用 8 位，理论上可以包含 16M 种不同的颜色。</li>
</ul>
</li>
</ul>
<a id="more"></a>
<h1 id="空间域图像处理"><a href="#空间域图像处理" class="headerlink" title="空间域图像处理"></a>空间域图像处理</h1><p>对应梁老师课件第三章，王老师第二、三、四单元。着重掌握二值化，gamma 矫正，直方图均衡/匹配。</p>
<h2 id="点运算"><a href="#点运算" class="headerlink" title="点运算"></a>点运算</h2><p>空间域增强：$g(x,y) = T [ f(x,y )]$</p>
<p>若将邻域限制为$1 \times 1$，则可简化为$s=T(r)$即点运算。</p>
<ul>
<li>点运算将输入图象映射为输出图象，输出图象每个象素点的灰度值仅由对应的输入象素点的值决定。<ul>
<li>常用于改变图象的灰度范围及分布</li>
<li>也称为对比度增强、对比度拉伸或灰度变换；</li>
</ul>
</li>
<li>点运算可以是线性的，也可以是平方的,对数的,或其它任意单调函数的灰度变换；</li>
<li>点运算可以利用一个 LUT（Look-up table）容易实现（或在彩色至少 R、G、B 三个 LUT）。</li>
</ul>
<h3 id="基本的变换"><a href="#基本的变换" class="headerlink" title="基本的变换"></a>基本的变换</h3><ul>
<li>图像反转<ul>
<li>$s = L-1-r$</li>
</ul>
</li>
<li>对数运算<ul>
<li>$s = c \log(1+r)$</li>
<li>有时原图的动态范围太大，超出某些显示设备的允许动态范围，如直接使用原图，则一部分细节可能丢失。</li>
<li>解决办法是对原图进行灰度压缩，如对数变换</li>
</ul>
</li>
<li>幂次变换<ul>
<li>$s = cr^\gamma$</li>
<li>$\gamma=1$等幂变换与原图像相同。</li>
<li>$\gamma&gt;1$用于过亮图像变暗。</li>
<li>$\gamma&lt;1$用于过暗图像变亮。</li>
<li>伽马矫正</li>
</ul>
</li>
<li>对比拉伸<ul>
<li>单调增函数保证灰度值变化保序。</li>
<li>将需要提升差值的部分拉大灰度值极差从而达到提高对比度的效果。</li>
</ul>
</li>
<li>灰度切割<ul>
<li>提高图像中特定灰度范围的亮度</li>
</ul>
</li>
<li>位图切割</li>
</ul>
<h3 id="gamma-矫正和二值化的代码实现"><a href="#gamma-矫正和二值化的代码实现" class="headerlink" title="gamma 矫正和二值化的代码实现"></a>gamma 矫正和二值化的代码实现</h3><ul>
<li><p>gamma 矫正</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><code class="hljs python">  <span class="hljs-comment"># 建表以后LUT</span><br><span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">GammaTable</span>(<span class="hljs-params">gamma</span>):</span><br>  invGamma = <span class="hljs-number">1.0</span> / gamma<br>  table = np.array([((i / <span class="hljs-number">255.0</span>) ** invGamma) * <span class="hljs-number">255</span><br>                    <span class="hljs-keyword">for</span> i <span class="hljs-keyword">in</span> np.arange(<span class="hljs-number">0</span>, <span class="hljs-number">256</span>)]).astype(<span class="hljs-string">&quot;uint8&quot;</span>)<br>  <span class="hljs-keyword">return</span> table<br><span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">LUT</span>(<span class="hljs-params">image , lutTable</span>):</span><br>  <span class="hljs-comment"># image: grayscale or RGB color image</span><br>  <span class="hljs-comment"># luTable: [255,] 1D numpy array mapping 0-255 values to ohter values</span><br>  lut = <span class="hljs-keyword">lambda</span> x: lutTable[x]<br>  <span class="hljs-keyword">return</span> lut(image)<br>  <span class="hljs-comment"># 直接伽马函数映射</span><br><span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">DirectGammaFunc</span>(<span class="hljs-params">image,gamma</span>):</span><br>  invGamma = <span class="hljs-number">1.0</span>/gamma<br>  fuc =  <span class="hljs-keyword">lambda</span> x: ((x/<span class="hljs-number">255.0</span>)**invGamma)*<span class="hljs-number">255</span><br>  <span class="hljs-keyword">return</span> fuc(image).astype(<span class="hljs-string">&quot;uint8&quot;</span>)<br>  <span class="hljs-comment"># R为单通道灰度图</span><br>  <span class="hljs-comment"># 调用</span><br>  R_crrt = LUT(R,GammaTable(<span class="hljs-number">1.5</span>))<br>  R_crrt = DirectGammaFunc(R,<span class="hljs-number">1.5</span>)<br></code></pre></td></tr></table></figure>
</li>
<li><p>二值化（三种写法，见注释）</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-comment"># 朴素循环</span><br><span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">ImThresh</span>(<span class="hljs-params">im, minv, maxv</span>):</span><br>    BinImg = np.zeros(im.shape, dtype=im.dtype)<br>    <span class="hljs-keyword">for</span> i <span class="hljs-keyword">in</span> <span class="hljs-built_in">range</span>(im.shape[<span class="hljs-number">0</span>]):<br>        <span class="hljs-keyword">for</span> j <span class="hljs-keyword">in</span> <span class="hljs-built_in">range</span>(im.shape[<span class="hljs-number">1</span>]):<br>            <span class="hljs-keyword">if</span> im[i,j]&gt;=minv <span class="hljs-keyword">and</span> im[i,j]&lt;=maxv:<br>                BinImg[i,j]=<span class="hljs-number">1</span><br>            <span class="hljs-keyword">else</span>:<br>                BinImg[i,j]=<span class="hljs-number">0</span><br>    <span class="hljs-keyword">return</span> BinImg<br><br><span class="hljs-comment"># 向量运算</span><br><span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">ImThreshv2</span>(<span class="hljs-params">image, minv, maxv</span>):</span><br>    <span class="hljs-keyword">assert</span>(<span class="hljs-built_in">len</span>(image.shape)==<span class="hljs-number">2</span>)<br>    <span class="hljs-comment"># 二值逻辑</span><br>    group1 = image &gt;= minv<br>    group2 = image &lt;= maxv<br>    <span class="hljs-comment"># 与操作 即要求满足 像素值&gt;=minv 又要 &lt;=maxv</span><br>    <span class="hljs-keyword">return</span> (group1*group2).astype(np.uint8)<br><br><span class="hljs-comment"># 杰哥的写法（也是向量运算）</span><br><span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">ImThreshv3</span>(<span class="hljs-params">image, minv, maxv</span>):</span><br>    <span class="hljs-keyword">assert</span>(<span class="hljs-built_in">len</span>(image.shape)==<span class="hljs-number">2</span>)<br>    <span class="hljs-comment"># 只是这里用的非逻辑值，数字化为0，1（uint8类型）</span><br>    newimg = np.copy(image)<br>    newimg[newimg &gt; maxv] = <span class="hljs-number">0</span><br>    newimg[newimg &lt; minv] = <span class="hljs-number">0</span><br>    newimg[newimg != <span class="hljs-number">0</span>] = <span class="hljs-number">1</span><br>    <span class="hljs-keyword">return</span> newimg.astype(np.uint8)<br><br><span class="hljs-comment"># 调用</span><br>Threshimg = Imthresh(R,<span class="hljs-number">120</span>,<span class="hljs-number">256</span>)<br>Threshimg2  = Imthreshv2(R,<span class="hljs-number">120</span>,<span class="hljs-number">256</span>)<br></code></pre></td></tr></table></figure>
</li>
</ul>
<h2 id="直方图均衡"><a href="#直方图均衡" class="headerlink" title="直方图均衡"></a>直方图均衡</h2><h3 id="直方图"><a href="#直方图" class="headerlink" title="直方图"></a>直方图</h3><ul>
<li>定义：将所收集的测定值或数据之全距分为几个相等的区间作为横轴,并将各区间内之测定值所出现次数累积而成的面积,用柱子排起来的图形；</li>
<li>表示图像中具有某种属性（如灰度、颜色等）的像素的个数,反映了图像中每种属性级出现的频率,是图像的基本统计特征之一。</li>
</ul>
<h3 id="均衡"><a href="#均衡" class="headerlink" title="均衡"></a>均衡</h3><ul>
<li>直方图均衡化是通过灰度变换将一幅图象转换为另一幅具有均衡直方图，即在每个灰度级上都具有相同（离散情况下是相近）的象素点数的过程。这样就增加了像素灰度值的动态范围，从而达到增强图像整体对比度的效果</li>
<li>使用的方法是灰度级变换：$s = T(r)$</li>
</ul>
<h3 id="为什么概率累计曲线可以用来实现直方图均衡化的效果"><a href="#为什么概率累计曲线可以用来实现直方图均衡化的效果" class="headerlink" title="为什么概率累计曲线可以用来实现直方图均衡化的效果"></a>为什么概率累计曲线可以用来实现直方图均衡化的效果</h3><h4 id="概率论基础（问题基础）"><a href="#概率论基础（问题基础）" class="headerlink" title="概率论基础（问题基础）"></a>概率论基础（问题基础）</h4><p>根据课本 P74 页，$p_r(r)$和$p_s(s)$分别表示随机变量$r$和$s$的概率密度函数，<strong>概率论的一个基本结果是，如果$p_r(r)$和$T(r)$已知且$s = T(r)$具备单调性，在感兴趣的值域上是连续且可微的，则变换后的变量$s$的概率密度函数可由下面的简单公式得到：</strong></p>
<script type="math/tex; mode=display">p_s(s) = p_r(r) \left| \frac{\mathrm{d}r}{\mathrm{d}s} \right|</script><p>这个式子怎么推导的呢？实际上我们就是在求一个<strong>随机变量函数的概率分布</strong>，概率论是学过的，这里回忆一下给出推导。</p>
<p>设$r$为随机变量，其概率分布符合$p_r(r)$，另有一单调的函数（变换）$s = T(r)$，现在求$s$的概率分布，设$r$值域均为$[0,L-1]$。</p>
<p>由分布函数公式</p>
<script type="math/tex; mode=display">F(x) = \int_{0}^{x} p(m) \mathrm{d}m</script><p>得$r$得分布函数</p>
<script type="math/tex; mode=display">F_r(r) = \int_{0}^{r} p_r(m) \mathrm{d}m</script><p>又因为$s = T(r)$为单调函数，存在反函数$r = T^{-1}(s)$</p>
<script type="math/tex; mode=display">F_s(s) = F_r(T^{-1}(s)) = \int_{0}^{ T^{-1}(s) } p_r(m) \mathrm{d}m</script><p>概率密度函数为分布函数的导数</p>
<script type="math/tex; mode=display">p_s(s) = \left| \frac{\mathrm{d} F_s(s)}{\mathrm{d}s} \right|</script><p>应用链式求导法则</p>
<script type="math/tex; mode=display">p_s(s) = \left| \frac{\mathrm{d}F_s(s)}{\mathrm{d}s} \right|</script><script type="math/tex; mode=display">p_s(s) = \frac{\mathrm{d}F_r(r)}{\mathrm{d}r} \left| \frac{ \mathrm{d} r}{ \mathrm{d}s}  \right|</script><script type="math/tex; mode=display">p_s(s) = p_r(r) \left| \frac{ \mathrm{d} r}{ \mathrm{d}s}  \right|</script><p>则得到了书本上的公式。</p>
<h4 id="均衡变换（回答问题）"><a href="#均衡变换（回答问题）" class="headerlink" title="均衡变换（回答问题）"></a>均衡变换（回答问题）</h4><p>问题即为，<strong>为何任何随机变量的概率分布函数，若变换为累积分布函数，则变换后的随机变量的概率分布为均匀分布</strong>？这实际上是累积分布函数的一个特殊的性质，下面给出证明。</p>
<ol>
<li><p>若$T(r)$恰为$r$的分布函数，则</p>
<script type="math/tex; mode=display">s = T(r) = \int_{0}^{r} p_r(m) \mathrm{d}m</script><script type="math/tex; mode=display">\frac{\mathrm{d}s}{\mathrm{d}r} = p_r(r)</script><script type="math/tex; mode=display">p_s(s) = p_r(r) \left| \frac{ \mathrm{d} r}{ \mathrm{d}s}  \right| = p_r(r) \frac{1}{p_r(r)} = 1</script><p>则$s$为均匀分布$s \in [0,1]$ 且$p_s(s)$值恒为$1$</p>
</li>
<li><p>若$T(r)$为$r$分布函数映射到$[0,L-1]$，则</p>
<script type="math/tex; mode=display">s = T(r) = (L-1) \int_{0}^{r} p_r(m) \mathrm{d}m</script><script type="math/tex; mode=display">p_s(s) = p_r(r) \frac{1}{(L-1) p_r(r)} = \frac{1}{L-1}</script><p>则$s$为均匀分布，且$p_s(s)=\frac{1}{L-1}$</p>
</li>
</ol>
<p>这便是我们想要的函数变换，<strong>无论$p_r(r)$分布如何</strong>，经过这种类分布函数的函数变换，得到的$p_s(s)$就是一个<strong>均匀分布</strong>。</p>
<h3 id="直方图均衡化代码实现"><a href="#直方图均衡化代码实现" class="headerlink" title="直方图均衡化代码实现"></a>直方图均衡化代码实现</h3><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">CaculateHistogram</span>(<span class="hljs-params">input_image</span>):</span><br>    <span class="hljs-comment"># 参数1. 图像</span><br>    <span class="hljs-comment"># 输出1. 总像素值</span><br>    <span class="hljs-comment"># 输出2. 灰度值分布计数</span><br>    <span class="hljs-comment"># 输出3. 灰度值分布前缀和（用来做后续直方图平局奴化）</span><br>    <span class="hljs-comment"># 区分单通道还是三通道图像</span><br>    <span class="hljs-keyword">if</span> <span class="hljs-built_in">len</span>(np.shape(input_image)) == <span class="hljs-number">3</span>:<br>           height,width,level = np.shape(input_image)<br>           summ = height*width*level<br>    <span class="hljs-keyword">else</span> :<br>           height,width = np.shape(input_image)<br>           summ = height*width<br>    caculate_num,index_x = np.histogram(input_image,np.arange(<span class="hljs-number">0</span>,<span class="hljs-number">256</span>))<br>    caculate_num = np.append(caculate_num,<span class="hljs-number">1</span>)<br>    <span class="hljs-comment"># 前缀和</span><br>    sum_num = np.copy(caculate_num)<br>    <span class="hljs-keyword">for</span> i <span class="hljs-keyword">in</span> <span class="hljs-built_in">range</span>(<span class="hljs-number">1</span>,<span class="hljs-number">256</span>):<br>        sum_num[i] = sum_num[i<span class="hljs-number">-1</span>] + sum_num[i]<br>    <span class="hljs-keyword">return</span> summ,caculate_num,sum_num<br><br><span class="hljs-comment"># 计算直方图数组</span><br><span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">cumsum</span>(<span class="hljs-params">img, bins</span>):</span><br>    histogram = np.zeros(bins)<br>    <span class="hljs-keyword">for</span> pixel <span class="hljs-keyword">in</span> np.arange(<span class="hljs-number">0</span>, bins, <span class="hljs-number">1</span>):<br>        <span class="hljs-comment"># 向量化计算像素值为piexel的像素数量</span><br>        histogram[pixel] += <span class="hljs-built_in">len</span>(img[img==pixel])<br>    <span class="hljs-keyword">return</span> histogram<br><br><span class="hljs-comment"># 直方图均衡接口函数，利用了LUT</span><br><span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">HistogramEqualizationLUT</span>(<span class="hljs-params">input_image</span>):</span><br>    size,data,data_sum = CaculateHistogram(input_image)<br>    fxy  = <span class="hljs-keyword">lambda</span> x: (<span class="hljs-number">255</span>*data_sum[x])//size<br>    table = np.array([fxy(i) <span class="hljs-keyword">for</span> i <span class="hljs-keyword">in</span> <span class="hljs-built_in">range</span>(<span class="hljs-number">256</span>)])<br>    lut = <span class="hljs-keyword">lambda</span> x: table[x]<br>    <span class="hljs-keyword">return</span> lut(input_image),table<br></code></pre></td></tr></table></figure>
<h2 id="直方图匹配"><a href="#直方图匹配" class="headerlink" title="直方图匹配"></a>直方图匹配</h2><p>方法：求两图均衡化，有逆函数存在，可实现匹配。</p>
<h3 id="证明"><a href="#证明" class="headerlink" title="证明"></a>证明</h3><p>我们易知$s$服从均匀分布，我们寻找一个$z$随机变量符合另一特殊分布$p_z(z)$，易知存在一函数（变换）：</p>
<script type="math/tex; mode=display">s = G(z) = (L-1) \int_{0}^{z} p_z(m) \mathrm{d}m</script><p>由于$G(z)$为累积分布函数，单调，故存在反函数$G^{-1}(z)$，则有新变换 $N = G^{-1} \cdot T$，使得$r$随机变量经$N$变换后符合$z$的分布特征。</p>
<script type="math/tex; mode=display">z = G^{-1}(s) = G^{-1}(T(r)) = N(r)</script><p>由此，我们找到了某值域内求从<strong>某一分布</strong>随机变量$r$变换到<strong>指定分布</strong>随机变量$z$的方法。</p>
<h2 id="空间域滤波基础"><a href="#空间域滤波基础" class="headerlink" title="空间域滤波基础"></a>空间域滤波基础</h2><p>书本 P93 页有详细概念。</p>
<p><img src="https://eddyblog.oss-cn-shenzhen.aliyuncs.com/ImageProcess/Review/Review_7.PNG" srcset="/img/loading.gif" lazyload alt="7"></p>
<p><img src="https://eddyblog.oss-cn-shenzhen.aliyuncs.com/ImageProcess/Review/Review_8.PNG" srcset="/img/loading.gif" lazyload alt="8"></p>
<h2 id="平滑和锐化"><a href="#平滑和锐化" class="headerlink" title="平滑和锐化"></a>平滑和锐化</h2><p>公式太多就贴 PPT 了</p>
<p><img src="https://eddyblog.oss-cn-shenzhen.aliyuncs.com/ImageProcess/Review/Review_9.PNG" srcset="/img/loading.gif" lazyload alt="9"></p>
<p><img src="https://eddyblog.oss-cn-shenzhen.aliyuncs.com/ImageProcess/Review/Review_10.PNG" srcset="/img/loading.gif" lazyload alt="10"></p>
<p><img src="https://eddyblog.oss-cn-shenzhen.aliyuncs.com/ImageProcess/Review/Review_11.PNG" srcset="/img/loading.gif" lazyload alt="11"></p>
<p><img src="https://eddyblog.oss-cn-shenzhen.aliyuncs.com/ImageProcess/Review/Review_12.PNG" srcset="/img/loading.gif" lazyload alt="12"></p>
<p><img src="https://eddyblog.oss-cn-shenzhen.aliyuncs.com/ImageProcess/Review/Review_13.PNG" srcset="/img/loading.gif" lazyload alt="13"></p>
<p><img src="https://eddyblog.oss-cn-shenzhen.aliyuncs.com/ImageProcess/Review/Review_14.PNG" srcset="/img/loading.gif" lazyload alt="14"></p>
<p><img src="https://eddyblog.oss-cn-shenzhen.aliyuncs.com/ImageProcess/Review/Review_15.PNG" srcset="/img/loading.gif" lazyload alt="15"></p>
<p><img src="https://eddyblog.oss-cn-shenzhen.aliyuncs.com/ImageProcess/Review/Review_16.PNG" srcset="/img/loading.gif" lazyload alt="16"></p>
<p>梯度算子</p>
<p><img src="https://eddyblog.oss-cn-shenzhen.aliyuncs.com/ImageProcess/Review/Review_17.PNG" srcset="/img/loading.gif" lazyload alt="17"></p>
<p><img src="https://eddyblog.oss-cn-shenzhen.aliyuncs.com/ImageProcess/Review/Review_18.PNG" srcset="/img/loading.gif" lazyload alt="18"></p>
<h3 id="添加噪声代码实现"><a href="#添加噪声代码实现" class="headerlink" title="添加噪声代码实现"></a>添加噪声代码实现</h3><p>注意椒盐</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-comment"># 参考资料上的</span><br><span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">noisy</span>(<span class="hljs-params">noise_typ,image</span>):</span><br>    <span class="hljs-keyword">if</span> noise_typ == <span class="hljs-string">&quot;gauss&quot;</span>:<br>        row,col,ch= image.shape<br>        mean = <span class="hljs-number">0</span><br>        var = <span class="hljs-number">0.1</span><br>        sigma = var**<span class="hljs-number">0.5</span><br>        gauss = np.random.normal(mean,sigma,(row,col,ch))<br>        gauss = gauss.reshape(row,col,ch)<br>        noisy = image + gauss<br>        <span class="hljs-keyword">return</span> noisy<br>    <span class="hljs-keyword">elif</span> noise_typ == <span class="hljs-string">&quot;s&amp;p&quot;</span>:<br>        row,col,ch = image.shape<br>        s_vs_p = <span class="hljs-number">0.5</span><br>        amount = <span class="hljs-number">0.004</span><br>        out = np.copy(image)<br>        <span class="hljs-comment"># Salt mode</span><br>        num_salt = np.ceil(amount * image.size * s_vs_p)<br>        coords = [np.random.randint(<span class="hljs-number">0</span>, i - <span class="hljs-number">1</span>, <span class="hljs-built_in">int</span>(num_salt)) <span class="hljs-keyword">for</span> i <span class="hljs-keyword">in</span> image.shape]<br>        out[coords] = <span class="hljs-number">1</span><br>        <span class="hljs-comment"># Pepper mode</span><br>        num_pepper = np.ceil(amount* image.size * (<span class="hljs-number">1.</span> - s_vs_p))<br>        coords = [np.random.randint(<span class="hljs-number">0</span>, i - <span class="hljs-number">1</span>, <span class="hljs-built_in">int</span>(num_pepper)) <span class="hljs-keyword">for</span> i <span class="hljs-keyword">in</span> image.shape]<br>        out[coords] = <span class="hljs-number">0</span><br>        <span class="hljs-keyword">return</span> out<br>    <span class="hljs-keyword">elif</span> noise_typ == <span class="hljs-string">&quot;poisson&quot;</span>:<br>        vals = <span class="hljs-built_in">len</span>(np.unique(image))<br>        vals = <span class="hljs-number">2</span> ** np.ceil(np.log2(vals))<br>        noisy = np.random.poisson(image * vals) / <span class="hljs-built_in">float</span>(vals)<br>        <span class="hljs-keyword">return</span> noisy<br>    <span class="hljs-keyword">elif</span> noise_typ ==<span class="hljs-string">&quot;speckle&quot;</span>:<br>        row,col,ch = image.shape<br>        gauss = np.random.randn(row,col,ch)<br>        gauss = gauss.reshape(row,col,ch)<br>        noisy = image + image * gauss<br>        <span class="hljs-keyword">return</span> noisy<br><br><span class="hljs-comment"># 自己写的</span><br><span class="hljs-comment"># 生成随机椒盐噪点</span><br><span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">MakeNoise</span>(<span class="hljs-params">input_image,number_of_noise=<span class="hljs-number">1000</span></span>):</span><br>    res_image = np.copy(input_image)<br>    row,column = np.shape(input_image)<br><span class="hljs-comment">#     还可以加对三通道的特判</span><br>    <span class="hljs-keyword">for</span> i <span class="hljs-keyword">in</span> <span class="hljs-built_in">range</span>(number_of_noise):<br>        x = np.random.randint(<span class="hljs-number">0</span>,row)<br>        y = np.random.randint(<span class="hljs-number">0</span>,column)<br>        borw = np.random.randint(<span class="hljs-number">0</span>,<span class="hljs-number">2</span>)<br>        <span class="hljs-keyword">if</span> borw == <span class="hljs-number">0</span>:<br>            res_image[x][y] = <span class="hljs-number">0</span><br>        <span class="hljs-keyword">else</span>:<br>            res_image[x][y] = <span class="hljs-number">255</span><br>    <span class="hljs-keyword">return</span> res_image<br></code></pre></td></tr></table></figure>
<h3 id="均值滤波代码实现"><a href="#均值滤波代码实现" class="headerlink" title="均值滤波代码实现"></a>均值滤波代码实现</h3><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">Smooth</span>(<span class="hljs-params">input_image,kernal_size = <span class="hljs-number">3</span></span>):</span><br>    ans = input_image.copy()<br>    border = np.uint8(kernal_size/<span class="hljs-number">2</span>)<br>    <span class="hljs-comment"># 根据核大小扩充边界</span><br>    addBorder = cv2.copyMakeBorder(input_image,border,border,border,border,cv2.BORDER_REFLECT_101)<br>    filWin = np.ones((kernal_size,kernal_size),dtype=np.int64)<br>    row,column = np.shape(addBorder)<br>    <span class="hljs-keyword">for</span> i <span class="hljs-keyword">in</span> <span class="hljs-built_in">range</span>(border,row-border):<br>        <span class="hljs-keyword">for</span> j <span class="hljs-keyword">in</span> <span class="hljs-built_in">range</span>(border,column-border):<br>            <span class="hljs-comment"># 以图像i,j为中心，大小为2border+1的区域</span><br>            temp = addBorder[i-border:i+border+<span class="hljs-number">1</span>,j-border:j+border+<span class="hljs-number">1</span>]<br>            temp_sum = np.<span class="hljs-built_in">sum</span>(temp*filWin)<br>            ans[i-border][j-border] = temp_sum/(kernal_size**<span class="hljs-number">2</span>)<br>    <span class="hljs-keyword">return</span> ans<br></code></pre></td></tr></table></figure>
<h3 id="Laplace-锐化滤波代码实现"><a href="#Laplace-锐化滤波代码实现" class="headerlink" title="Laplace 锐化滤波代码实现"></a>Laplace 锐化滤波代码实现</h3><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">Laplace</span>(<span class="hljs-params">input_image,lap_template</span>):</span><br>    x,y = np.shape(lap_template)<br>    <span class="hljs-keyword">if</span>(x!=y):<br>        print(<span class="hljs-string">&quot;Shape of Laplace template wrong!&quot;</span>)<br>        <span class="hljs-keyword">pass</span><br><br>    print(<span class="hljs-string">&quot;The Laplace template is: &quot;</span>)<br>    print(lap_template)<br>    border = x//<span class="hljs-number">2</span><br>    ans = np.zeros(np.shape(input_image), dtype = np.int64)<br><br>    <span class="hljs-comment"># 扩充边界</span><br>    addBorder = cv2.copyMakeBorder(input_image,border,border,border,border,cv2.BORDER_REFLECT_101)<br><br>    row,column = np.shape(addBorder)<br>    <span class="hljs-keyword">for</span> i <span class="hljs-keyword">in</span> <span class="hljs-built_in">range</span>(border,row-border):<br>        <span class="hljs-keyword">for</span> j <span class="hljs-keyword">in</span> <span class="hljs-built_in">range</span>(border,column-border):<br>            ans[i-border][j-border] = np.<span class="hljs-built_in">sum</span>(lap_template*addBorder[i-border:i+border+<span class="hljs-number">1</span> , j-border: j+border+<span class="hljs-number">1</span>])<br>    <span class="hljs-keyword">return</span> ans<br><br><span class="hljs-comment"># Laplace 常用算子 [[-1,-1,-1],[-1,8,-1],[-1,-1,-1]]</span><br>laplace_template_4 = np.array([[<span class="hljs-number">0</span>,<span class="hljs-number">-1</span>,<span class="hljs-number">0</span>],[<span class="hljs-number">-1</span>,<span class="hljs-number">4</span>,<span class="hljs-number">-1</span>],[<span class="hljs-number">0</span>,<span class="hljs-number">-1</span>,<span class="hljs-number">0</span>]])<br>laplace_template_8 = np.array([[<span class="hljs-number">-1</span>,<span class="hljs-number">-1</span>,<span class="hljs-number">-1</span>],[<span class="hljs-number">-1</span>,<span class="hljs-number">8</span>,<span class="hljs-number">-1</span>],[<span class="hljs-number">-1</span>,<span class="hljs-number">-1</span>,<span class="hljs-number">-1</span>]])<br><br><br>lap_img_4 = Laplace(im,laplace_template_4)<br></code></pre></td></tr></table></figure>
<h1 id="频率域图像处理"><a href="#频率域图像处理" class="headerlink" title="频率域图像处理"></a>频率域图像处理</h1><h2 id="频率域分析基础"><a href="#频率域分析基础" class="headerlink" title="频率域分析基础"></a>频率域分析基础</h2><p>这次课，我们首次接触了“频率域分析”方法。我们从高数中学习过的“无穷级数”概念切入，讲到基于三角函数的傅里叶级数。其中的关键思路是：任意周期函数都可以用傅里叶级数展开，而傅里叶级数的基函数是频率各异的三角函数；也就是说任意周期函数都可以用一组频率各异的三角函数的线性组合来表示。而线性组合系数，即基函数的加权系数，就可以解读为原函数在基函数上的“投影系数”（或坐标，或两者的相似度）。</p>
<p>如果能够求出傅里叶级数中的加权系数，那么就可以实现对原函数的“频域分解”，即原函数主要可以由哪些频率的三角函数叠加而成，也可以解读为原函数主要包含哪些频率的分量。而“频率”对于图像而言是有直观意义的。一般而言，低频成分对应图像中的总体形状和总体色彩和明暗分布；而高频成分对应图像中的细节和边缘信息。如果我们把图像看作是二维函数，并能够将其进行频域分解，那么增强其低频分量就是相当于平滑操作，增强其高频分量就相当于锐化操作。这就是我们除了前几章学习的“空间域分析”方法之外，又多了一个全新的视角和全新的方法。</p>
<p>傅里叶变换就是求解傅里叶级数中的加权系数的方法。其思路很简单，由于加权系数对应原函数与基函数的相似程度，我们可以用两者的离散采样点组成的向量的点积来估计二者的相似程度。因为向量的点积与向量的夹角的余弦成正比，夹角越小代表两个向量越相似，其余弦值就越大。工程上有一种名为“快速傅里叶变换”（FFT）的数值运算方法，可以快速求解傅里叶变换。但对于图像而言，它要求图像的长宽为 2 的整数次幂。</p>
<p>傅里叶逆变换是运用傅里叶级数来重构原函数的方法。其表达式就是傅里叶级数的表达式。有了基函数和加权系数，进行傅里叶逆变换是很直接的。</p>
<p>在工程上，傅里叶变换（FT）一般是对离散数据进行处理的，故名为离散傅里叶变换(DFT)。又因为常用快速傅里叶变换算法来求解，所以常用快速傅里叶变换(FFT)表示，其逆变换为 iFFT。无论是 FFT 还是 iFFT 都有现成的高度优化过的软件包使用，一般不用你自己实现。在 Python 语言中的 Numpy 包中就有相关实现，在 C++语言中也有 OpenCV 包中的对应实现。</p>
<p>我们在讲解了上述原理后，就尝试对一张图像（黑色背景的中央有个白色长方形）进行了傅里叶变换，对变换系数矩阵组成的图像进行了对数化（压缩值的分布，以便看清楚微弱的分布细节），观察了图像的频率域分解效果。然后我们分别演示了基于频率域分析的图像平滑（将 FFT 系数矩阵的边缘区域置零，再逆变换回空间域）和图像锐化（将 FFT 系数矩阵的中央区域置零，再逆变换回空间域，得到边缘图，再与原图进行叠加以便锐化图像）。这部分的演示，请看附件中的代码。</p>
<h2 id="使用-OpenCV-实现-DFT"><a href="#使用-OpenCV-实现-DFT" class="headerlink" title="使用 OpenCV 实现 DFT"></a>使用 OpenCV 实现 DFT</h2><p>OpenCV 也提供的工具用于实现离散傅里叶变换，分别是<code>cv2.dft()</code>和<code>cv2.idft()</code>函数。返回有两个通道，第一个通道是结果的实部，第二个通道是结果的虚部。所以在计算其幅度的时候需要先手动转化一次。</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-comment">## Magnitude spectrum</span><br><br><br><span class="hljs-comment">## 使用Numpy实现DFT</span><br><span class="hljs-comment">## 进行二维DFT变换</span><br>f_img1 = np.fft.fft2(img1)<br><span class="hljs-comment">## 对换象限</span><br>fshift_img1 = np.fft.fftshift(f_img1)<br><span class="hljs-comment">## 幅度谱 对数化？</span><br>manitude_img1 = <span class="hljs-number">20</span>*np.log(np.<span class="hljs-built_in">abs</span>(fshift_img1))<br><span class="hljs-comment">## img2图像也做相同的处理</span><br>f_img2 = np.fft.fft2(img2)<br>fshift_img2 = np.fft.fftshift(f_img2)<br>manitude_img2 = <span class="hljs-number">20</span>*np.log(np.<span class="hljs-built_in">abs</span>(fshift_img2))<br><br><span class="hljs-comment">## 使用OpenCV实现DFT</span><br>f_img3 = cv2.dft(np.float32(img3), flags = cv2.DFT_COMPLEX_OUTPUT)<br>fshift_img3 = np.fft.fftshift(f_img3)<br><span class="hljs-comment"># manitude_img3 = 20*np.log(np.abs(fshift_img3))</span><br><span class="hljs-comment"># 手动转化计算magnitude</span><br>manitude_img3 = <span class="hljs-number">20</span>*np.log(cv2.magnitude(fshift_img3[:,:,<span class="hljs-number">0</span>],fshift_img3[:,:,<span class="hljs-number">1</span>])+<span class="hljs-number">1e-15</span>)<br><br><br><span class="hljs-comment">## 使用OpenCV实现DFT</span><br>f_img4 = cv2.dft(np.float32(img4), flags = cv2.DFT_COMPLEX_OUTPUT)<br>fshift_img4 = np.fft.fftshift(f_img4)<br>manitude_img4 = <span class="hljs-number">20</span>*np.log(cv2.magnitude(fshift_img4[:,:,<span class="hljs-number">0</span>],fshift_img4[:,:,<span class="hljs-number">1</span>]))<br></code></pre></td></tr></table></figure>
<h2 id="理想滤波器"><a href="#理想滤波器" class="headerlink" title="理想滤波器"></a>理想滤波器</h2><p>所谓”理想”是指无法通过硬件实现的硬截断</p>
<h3 id="理想低通滤波器-ILPF"><a href="#理想低通滤波器-ILPF" class="headerlink" title="理想低通滤波器 ILPF"></a>理想低通滤波器 ILPF</h3><p>在圆外“阻断”所有频率，而在圆内无衰减的通过所有频率，这种二维低通滤波器称为理想低通滤波器（ILPF），由下面的函数确定</p>
<script type="math/tex; mode=display">
H_{ILPF}(u,v) = \left \{
\begin{aligned}
1, & D(u,v) \le D_0 \\
0, & D(u,b) > D_0
\end{aligned}
\right.</script><p>其中$D_0$是一个正常数，$D(u,v)$表示频率域中的点$(u,v)$距离频率域中心$(\frac{P}{2},\frac{Q}{2})$的距离。</p>
<h3 id="理想高通滤波器-IHPF"><a href="#理想高通滤波器-IHPF" class="headerlink" title="理想高通滤波器 IHPF"></a>理想高通滤波器 IHPF</h3><p>与低通类似，高通是将阈值的圆内“阻断”所有频率，而在圆外无衰减的通过所有频率，描述如下</p>
<script type="math/tex; mode=display">
H_{IHPF}(u,v) = \left \{
\begin{aligned}
0, & D(u,v) \le D_0 \\
1, & D(u,b) > D_0
\end{aligned}
\right.</script><h3 id="代码实现"><a href="#代码实现" class="headerlink" title="代码实现"></a>代码实现</h3><p>代码实现低通滤波器并展示其频率域透视图、频率域图像显示、空间域图像显示和径向剖面图。</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-comment"># 获得指定大小的理想滤波器</span><br><span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">getIdealMask</span>(<span class="hljs-params">mask_shape, filter_d0,hl_type</span>):</span><br>    <span class="hljs-keyword">assert</span> hl_type <span class="hljs-keyword">in</span> (<span class="hljs-string">&quot;lpf&quot;</span>,<span class="hljs-string">&quot;hpf&quot;</span>)<br>    rows,cols = mask_shape[<span class="hljs-number">0</span>],mask_shape[<span class="hljs-number">1</span>]<br>    crow = rows/<span class="hljs-number">2</span><br>    ccol = cols/<span class="hljs-number">2</span><br>    mask = np.zeros((rows,cols))<br>    <span class="hljs-keyword">for</span> i <span class="hljs-keyword">in</span> <span class="hljs-built_in">range</span>(rows):<br>        <span class="hljs-keyword">for</span> j <span class="hljs-keyword">in</span> <span class="hljs-built_in">range</span>(cols):<br>            dis = sqrt((i-crow)**<span class="hljs-number">2</span> + (j-ccol)**<span class="hljs-number">2</span>)<br>            <span class="hljs-keyword">if</span> hl_type == <span class="hljs-string">&quot;lpf&quot;</span>:<br>                <span class="hljs-keyword">if</span> dis &lt;= filter_d0:<br>                    mask[i,j] = <span class="hljs-number">1</span><br>                <span class="hljs-keyword">else</span>:<br>                    mask[i,j] = <span class="hljs-number">0</span><br>            <span class="hljs-keyword">elif</span> hl_type == <span class="hljs-string">&quot;hpf&quot;</span>:<br>                <span class="hljs-keyword">if</span> dis &lt;= filter_d0:<br>                    mask[i,j] = <span class="hljs-number">0</span><br>                <span class="hljs-keyword">else</span>:<br>                    mask[i,j] = <span class="hljs-number">1</span><br>    <span class="hljs-keyword">return</span> mask<br><br><span class="hljs-comment"># 测试ILPF</span><br><span class="hljs-comment"># 参数设置</span><br>mask_shape = (<span class="hljs-number">100</span>,<span class="hljs-number">100</span>)<br>d = <span class="hljs-number">20</span><br>filter_type = <span class="hljs-string">&quot;lpf&quot;</span><br><span class="hljs-comment"># 获得滤波器</span><br>myfilter = getIdealMask(mask_shape,d,filter_type)<br><span class="hljs-comment"># 绘图</span><br>plt.figure(figsize=(<span class="hljs-number">12</span>,<span class="hljs-number">12</span>))<br>ax1=plt.subplot(<span class="hljs-number">221</span>,projection = <span class="hljs-string">&quot;3d&quot;</span>)<br>ax2=plt.subplot(<span class="hljs-number">222</span>)<br>ax3=plt.subplot(<span class="hljs-number">223</span>)<br>ax4=plt.subplot(<span class="hljs-number">224</span>)<br>drawPerspective(ax1,myfilter,title = <span class="hljs-string">&quot;ILPF Perspective Axes3D&quot;</span>, cmap = <span class="hljs-string">&quot;gray&quot;</span>)<br><span class="hljs-comment"># 不想进行列表解析,需要调用frompyfunc构建np可以用的分段函数</span><br>ufunc1 = np.frompyfunc(<span class="hljs-keyword">lambda</span> x: <span class="hljs-number">0</span> <span class="hljs-keyword">if</span> (x-d)&gt;<span class="hljs-number">0</span> <span class="hljs-keyword">else</span> <span class="hljs-number">1</span>, <span class="hljs-number">1</span>, <span class="hljs-number">1</span>)<br>drawCurv(ax2,[ufunc1],[<span class="hljs-string">&quot;ILPF&quot;</span>],d,title = <span class="hljs-string">&quot;ILPF Curv&quot;</span>)<br>drawPanel(ax3,myfilter,title = <span class="hljs-string">&quot;ILPF Frequency Panel Axes2D&quot;</span>)<br>spatial_myfilter = frequencyToSpatial(myfilter)<br>drawPanel(ax4,spatial_myfilter,title = <span class="hljs-string">&quot;ILPF Spatial Panel Axes2D&quot;</span>)<br>plt.show()<br><br><span class="hljs-comment"># 测试IHPF</span><br>d = <span class="hljs-number">20</span><br>filter_type = <span class="hljs-string">&quot;hpf&quot;</span><br>myfilter = getIdealMask(mask_shape,d,filter_type)<br>plt.figure(figsize=(<span class="hljs-number">12</span>,<span class="hljs-number">12</span>))<br>ax1=plt.subplot(<span class="hljs-number">221</span>,projection = <span class="hljs-string">&quot;3d&quot;</span>)<br>ax2=plt.subplot(<span class="hljs-number">222</span>)<br>ax3=plt.subplot(<span class="hljs-number">223</span>)<br>ax4=plt.subplot(<span class="hljs-number">224</span>)<br>drawPerspective(ax1,myfilter,title = <span class="hljs-string">&quot;IHPF Perspective Axes3D&quot;</span>, cmap = <span class="hljs-string">&quot;gray&quot;</span>)<br><span class="hljs-comment"># 不想进行列表解析,需要调用frompyfunc构建np可以用的分段函数</span><br>ufunc1 = np.frompyfunc(<span class="hljs-keyword">lambda</span> x: <span class="hljs-number">1</span> <span class="hljs-keyword">if</span> (x-d)&gt;<span class="hljs-number">0</span> <span class="hljs-keyword">else</span> <span class="hljs-number">0</span>, <span class="hljs-number">1</span>, <span class="hljs-number">1</span>)<br>drawCurv(ax2,[ufunc1],[<span class="hljs-string">&quot;IHPF&quot;</span>],d,title = <span class="hljs-string">&quot;Curv&quot;</span>)<br>drawPanel(ax3,myfilter,title = <span class="hljs-string">&quot;IHPF Frequency Panel Axes2D&quot;</span>)<br>spatial_myfilter = frequencyToSpatial(myfilter)<br>drawPanel(ax4,spatial_myfilter,title = <span class="hljs-string">&quot;IHPF Spatial Panel Axes2D&quot;</span>)<br>plt.show()<br><br></code></pre></td></tr></table></figure>
<p>理想低通 ILPF 结果四图</p>
<p><img src="https://eddyblog.oss-cn-shenzhen.aliyuncs.com/ImageProcess/TypeOfFilter/3.png" srcset="/img/loading.gif" lazyload alt="png"></p>
<p>理想高通 IHPF 结果四图</p>
<p><img src="https://eddyblog.oss-cn-shenzhen.aliyuncs.com/ImageProcess/TypeOfFilter/4.png" srcset="/img/loading.gif" lazyload alt="png"></p>
<h2 id="布特沃斯滤波器"><a href="#布特沃斯滤波器" class="headerlink" title="布特沃斯滤波器"></a>布特沃斯滤波器</h2><p>可通过硬件实现，可以通过阶数进行控制，一些资料中又称之为“巴特沃斯滤波器”。</p>
<h3 id="布特沃斯低通滤波器-BLPF"><a href="#布特沃斯低通滤波器-BLPF" class="headerlink" title="布特沃斯低通滤波器 BLPF"></a>布特沃斯低通滤波器 BLPF</h3><p>截止频率位于距原点$D_0$的$n$阶布特沃斯滤波器（BLPF）的传递函数定义为：</p>
<script type="math/tex; mode=display">H_{BLPF}(u,v) = \dfrac{1}{ 1 + {[ \dfrac {D(u,v)}{D_0} ]}^{2n} }</script><h3 id="布特沃斯高通滤波器-BHPF"><a href="#布特沃斯高通滤波器-BHPF" class="headerlink" title="布特沃斯高通滤波器 BHPF"></a>布特沃斯高通滤波器 BHPF</h3><p>对应的传递函数定义为：</p>
<script type="math/tex; mode=display">H_{BHPF}(u,v) = \dfrac{1}{ 1 + {[ \dfrac {D_0}{D_(u,v)} ]}^{2n} }</script><p>（分母分子颠倒）</p>
<p>两式中$n$对应了即阶参数，下面的代码给出巴特沃斯滤波器的实现，其频率域透视图、频率域图像显示、空间域图像显示和径向剖面图，曲线图绘制出不同阶下的取值。</p>
<h3 id="代码实现-1"><a href="#代码实现-1" class="headerlink" title="代码实现"></a>代码实现</h3><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-comment"># 获得指定大小的布特沃斯滤波器</span><br><span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">getButterworthMask</span>(<span class="hljs-params">mask_shape,filter_d0,hl_type,butter_n = <span class="hljs-number">1</span></span>):</span><br>    <span class="hljs-keyword">assert</span> hl_type <span class="hljs-keyword">in</span> (<span class="hljs-string">&quot;lpf&quot;</span>,<span class="hljs-string">&quot;hpf&quot;</span>)<br>    rows,cols = mask_shape[<span class="hljs-number">0</span>],mask_shape[<span class="hljs-number">1</span>]<br>    crow = rows/<span class="hljs-number">2</span><br>    ccol = cols/<span class="hljs-number">2</span><br>    mask = np.zeros((rows,cols))<br>    <span class="hljs-keyword">for</span> i <span class="hljs-keyword">in</span> <span class="hljs-built_in">range</span>(rows):<br>        <span class="hljs-keyword">for</span> j <span class="hljs-keyword">in</span> <span class="hljs-built_in">range</span>(cols):<br>            dis = sqrt((i-crow)**<span class="hljs-number">2</span> + (j-ccol)**<span class="hljs-number">2</span>)<br>            <span class="hljs-keyword">if</span> hl_type == <span class="hljs-string">&quot;lpf&quot;</span>:<br>                mask[i,j] = <span class="hljs-number">1.0</span>/(<span class="hljs-number">1</span>+(dis/filter_d0)**(<span class="hljs-number">2</span>*butter_n))<br>            <span class="hljs-keyword">elif</span> hl_type == <span class="hljs-string">&quot;hpf&quot;</span>:<br>                <span class="hljs-comment"># 除以0情况特判一下</span><br>                <span class="hljs-keyword">if</span> np.<span class="hljs-built_in">abs</span>(dis)&lt;eps:<br>                    mask[i,j] = <span class="hljs-number">0</span><br>                <span class="hljs-keyword">else</span>:<br>                    mask[i,j] = <span class="hljs-number">1.0</span>/(<span class="hljs-number">1</span>+(filter_d0/dis)**(<span class="hljs-number">2</span>*butter_n))<br><br>    <span class="hljs-keyword">return</span> mask<br><br><span class="hljs-comment"># 测试BLPF</span><br><span class="hljs-comment"># 参数设置</span><br>mask_shape = (<span class="hljs-number">100</span>,<span class="hljs-number">100</span>)<br>d = <span class="hljs-number">20</span><br>filter_type = <span class="hljs-string">&quot;lpf&quot;</span><br><span class="hljs-comment"># 获得滤波器</span><br>myfilter = getButterworthMask(mask_shape,d,filter_type, butter_n=<span class="hljs-number">2</span>)<br><span class="hljs-comment"># 绘图</span><br>plt.figure(figsize=(<span class="hljs-number">12</span>,<span class="hljs-number">12</span>))<br>ax1=plt.subplot(<span class="hljs-number">221</span>,projection = <span class="hljs-string">&quot;3d&quot;</span>)<br>ax2=plt.subplot(<span class="hljs-number">222</span>)<br>ax3=plt.subplot(<span class="hljs-number">223</span>)<br>ax4=plt.subplot(<span class="hljs-number">224</span>)<br>drawPerspective(ax1,myfilter,title = <span class="hljs-string">&quot;BLPF(n=2) Perspective Axes3D&quot;</span>, cmap = <span class="hljs-string">&quot;gray&quot;</span>)<br>funcs = []<br>labels = []<br><span class="hljs-keyword">for</span> i <span class="hljs-keyword">in</span> <span class="hljs-built_in">range</span>(<span class="hljs-number">1</span>,<span class="hljs-number">6</span>):<br>    labels.append(<span class="hljs-string">&quot;BLPF &quot;</span>+<span class="hljs-string">&quot;n=&quot;</span>+<span class="hljs-built_in">str</span>(i))<br>funcs.append(<span class="hljs-keyword">lambda</span> x:<span class="hljs-number">1.0</span>/(<span class="hljs-number">1</span>+(x/d)**(<span class="hljs-number">2</span>*<span class="hljs-number">1</span>)))<br>funcs.append(<span class="hljs-keyword">lambda</span> x:<span class="hljs-number">1.0</span>/(<span class="hljs-number">1</span>+(x/d)**(<span class="hljs-number">2</span>*<span class="hljs-number">2</span>)))<br>funcs.append(<span class="hljs-keyword">lambda</span> x:<span class="hljs-number">1.0</span>/(<span class="hljs-number">1</span>+(x/d)**(<span class="hljs-number">2</span>*<span class="hljs-number">3</span>)))<br>funcs.append(<span class="hljs-keyword">lambda</span> x:<span class="hljs-number">1.0</span>/(<span class="hljs-number">1</span>+(x/d)**(<span class="hljs-number">2</span>*<span class="hljs-number">4</span>)))<br>funcs.append(<span class="hljs-keyword">lambda</span> x:<span class="hljs-number">1.0</span>/(<span class="hljs-number">1</span>+(x/d)**(<span class="hljs-number">2</span>*<span class="hljs-number">5</span>)))<br><br>drawCurv(ax2,funcs,labels,d,title = <span class="hljs-string">&quot;BLPF(n=1,2,3,4,5) Curv&quot;</span>)<br>drawPanel(ax3,myfilter,title = <span class="hljs-string">&quot;BLPF(n=2) Frequency Panel Axes2D&quot;</span>)<br>spatial_myfilter = frequencyToSpatial(myfilter)<br>drawPanel(ax4,spatial_myfilter,title = <span class="hljs-string">&quot;BLPF(n=2) Spatial Panel Axes2D&quot;</span>)<br>plt.show()<br><br><span class="hljs-comment"># 测试BHPF</span><br>d = <span class="hljs-number">20</span><br>filter_type = <span class="hljs-string">&quot;hpf&quot;</span><br>myfilter = getButterworthMask(mask_shape,d,filter_type, butter_n=<span class="hljs-number">1</span>)<br>plt.figure(figsize=(<span class="hljs-number">12</span>,<span class="hljs-number">12</span>))<br>ax1=plt.subplot(<span class="hljs-number">221</span>,projection = <span class="hljs-string">&quot;3d&quot;</span>)<br>ax2=plt.subplot(<span class="hljs-number">222</span>)<br>ax3=plt.subplot(<span class="hljs-number">223</span>)<br>ax4=plt.subplot(<span class="hljs-number">224</span>)<br>drawPerspective(ax1,myfilter,title = <span class="hljs-string">&quot;BHPF(n=2) Perspective Axes3D&quot;</span>, cmap = <span class="hljs-string">&quot;gray&quot;</span>)<br>funcs = []<br>labels = []<br><span class="hljs-keyword">for</span> i <span class="hljs-keyword">in</span> <span class="hljs-built_in">range</span>(<span class="hljs-number">1</span>,<span class="hljs-number">6</span>):<br><span class="hljs-comment">#     funcs.append(lambda x:1.0/(1+(d/x)**(2*i)))</span><br><span class="hljs-comment">#     ufunc = np.frompyfunc(lambda x: 0 if np.abs(x)&lt;eps else 1.0/(1+(d/x)**(2*i)), 1, 1)</span><br><span class="hljs-comment">#     funcs.append(ufunc)</span><br>    labels.append(<span class="hljs-string">&quot;BHPF &quot;</span>+<span class="hljs-string">&quot;n=&quot;</span>+<span class="hljs-built_in">str</span>(i))<br>ufunc1 = np.frompyfunc(<span class="hljs-keyword">lambda</span> x: <span class="hljs-number">0</span> <span class="hljs-keyword">if</span> np.<span class="hljs-built_in">abs</span>(x)&lt;eps <span class="hljs-keyword">else</span> <span class="hljs-number">1.0</span>/(<span class="hljs-number">1</span>+(d/x)**(<span class="hljs-number">2</span>*<span class="hljs-number">1</span>)), <span class="hljs-number">1</span>, <span class="hljs-number">1</span>)<br>ufunc2 = np.frompyfunc(<span class="hljs-keyword">lambda</span> x: <span class="hljs-number">0</span> <span class="hljs-keyword">if</span> np.<span class="hljs-built_in">abs</span>(x)&lt;eps <span class="hljs-keyword">else</span> <span class="hljs-number">1.0</span>/(<span class="hljs-number">1</span>+(d/x)**(<span class="hljs-number">2</span>*<span class="hljs-number">2</span>)), <span class="hljs-number">1</span>, <span class="hljs-number">1</span>)<br>ufunc3 = np.frompyfunc(<span class="hljs-keyword">lambda</span> x: <span class="hljs-number">0</span> <span class="hljs-keyword">if</span> np.<span class="hljs-built_in">abs</span>(x)&lt;eps <span class="hljs-keyword">else</span> <span class="hljs-number">1.0</span>/(<span class="hljs-number">1</span>+(d/x)**(<span class="hljs-number">2</span>*<span class="hljs-number">3</span>)), <span class="hljs-number">1</span>, <span class="hljs-number">1</span>)<br>ufunc4 = np.frompyfunc(<span class="hljs-keyword">lambda</span> x: <span class="hljs-number">0</span> <span class="hljs-keyword">if</span> np.<span class="hljs-built_in">abs</span>(x)&lt;eps <span class="hljs-keyword">else</span> <span class="hljs-number">1.0</span>/(<span class="hljs-number">1</span>+(d/x)**(<span class="hljs-number">2</span>*<span class="hljs-number">4</span>)), <span class="hljs-number">1</span>, <span class="hljs-number">1</span>)<br>ufunc5 = np.frompyfunc(<span class="hljs-keyword">lambda</span> x: <span class="hljs-number">0</span> <span class="hljs-keyword">if</span> np.<span class="hljs-built_in">abs</span>(x)&lt;eps <span class="hljs-keyword">else</span> <span class="hljs-number">1.0</span>/(<span class="hljs-number">1</span>+(d/x)**(<span class="hljs-number">2</span>*<span class="hljs-number">5</span>)), <span class="hljs-number">1</span>, <span class="hljs-number">1</span>)<br>funcs.append(ufunc1)<br>funcs.append(ufunc2)<br>funcs.append(ufunc3)<br>funcs.append(ufunc4)<br>funcs.append(ufunc5)<br><br><br>drawCurv(ax2,funcs,labels,d,title = <span class="hljs-string">&quot;BHPF(n=1,2,3,4,5) Curv&quot;</span>)<br>drawPanel(ax3,myfilter,title = <span class="hljs-string">&quot;BHPF(n=2) Frequency Panel Axes2D&quot;</span>)<br>spatial_myfilter = frequencyToSpatial(myfilter)<br>drawPanel(ax4,spatial_myfilter,title = <span class="hljs-string">&quot;BHPF(n=2) Spatial Panel Axes2D&quot;</span>)<br>plt.show()<br><br></code></pre></td></tr></table></figure>
<p>布特沃斯低通 BLPF 结果四图</p>
<p><img src="https://eddyblog.oss-cn-shenzhen.aliyuncs.com/ImageProcess/TypeOfFilter/5.png" srcset="/img/loading.gif" lazyload alt="png"></p>
<p>布特沃斯高通 BHPF 结果四图</p>
<p><img src="https://eddyblog.oss-cn-shenzhen.aliyuncs.com/ImageProcess/TypeOfFilter/6.png" srcset="/img/loading.gif" lazyload alt="png"></p>
<!--more-->
<h3 id="高斯低通滤波器-GLPF"><a href="#高斯低通滤波器-GLPF" class="headerlink" title="高斯低通滤波器 GLPF"></a>高斯低通滤波器 GLPF</h3><p>高斯低通滤波器二维形式由下式给处：</p>
<script type="math/tex; mode=display">H_{GLPF}(u,v) = e^{\dfrac{-D^2(u,v)}{2 \sigma^2}}</script><p>$\sigma$描述了中心的扩散速度，和其他滤波器描述式统一，通过令$\sigma = D_0$，可以用表示其他滤波器的方法表示高斯滤波器。</p>
<script type="math/tex; mode=display">H_{GLPF}(u,v) = e^{\dfrac{-D^2(u,v)}{2 D_0^2}}</script><h3 id="高斯高通滤波器-GHPF"><a href="#高斯高通滤波器-GHPF" class="headerlink" title="高斯高通滤波器 GHPF"></a>高斯高通滤波器 GHPF</h3><p>如下：</p>
<script type="math/tex; mode=display">H_{GHPF}(u,v) =1 - e^{\dfrac{-D^2(u,v)}{2 D_0^2}}</script><h3 id="代码实现-2"><a href="#代码实现-2" class="headerlink" title="代码实现"></a>代码实现</h3><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-comment"># 获得指定大小的高斯滤波器</span><br><span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">getGaussianMask</span>(<span class="hljs-params">mask_shape,filter_d0,hl_type</span>):</span><br>    <span class="hljs-keyword">assert</span> hl_type <span class="hljs-keyword">in</span> (<span class="hljs-string">&quot;lpf&quot;</span>,<span class="hljs-string">&quot;hpf&quot;</span>)<br>    rows,cols = mask_shape[<span class="hljs-number">0</span>],mask_shape[<span class="hljs-number">1</span>]<br>    crow = rows/<span class="hljs-number">2</span><br>    ccol = cols/<span class="hljs-number">2</span><br>    mask = np.zeros((rows,cols))<br>    <span class="hljs-keyword">for</span> i <span class="hljs-keyword">in</span> <span class="hljs-built_in">range</span>(rows):<br>        <span class="hljs-keyword">for</span> j <span class="hljs-keyword">in</span> <span class="hljs-built_in">range</span>(cols):<br>            dis = sqrt((i-crow)**<span class="hljs-number">2</span> + (j-ccol)**<span class="hljs-number">2</span>)<br>            <span class="hljs-keyword">if</span> hl_type == <span class="hljs-string">&quot;hpf&quot;</span>:<br>                mask[i,j] = <span class="hljs-number">1</span>-np.exp(-(dis**<span class="hljs-number">2</span>) / (<span class="hljs-number">2</span>*(filter_d0**<span class="hljs-number">2</span>)))<br>            <span class="hljs-keyword">elif</span> hl_type == <span class="hljs-string">&quot;lpf&quot;</span>:<br>                mask[i,j] = np.exp(-(dis**<span class="hljs-number">2</span>)/(<span class="hljs-number">2</span>*(filter_d0**<span class="hljs-number">2</span>)))<br>    <span class="hljs-keyword">return</span> mask<br><br><span class="hljs-comment"># 测试GLPF</span><br><span class="hljs-comment"># 参数设置</span><br>mask_shape = (<span class="hljs-number">200</span>,<span class="hljs-number">200</span>)<br>d = <span class="hljs-number">20</span><br>filter_type = <span class="hljs-string">&quot;lpf&quot;</span><br><span class="hljs-comment"># 获得滤波器</span><br>myfilter = getGaussianMask(mask_shape,d,filter_type)<br><span class="hljs-comment"># 绘图</span><br>plt.figure(figsize=(<span class="hljs-number">12</span>,<span class="hljs-number">12</span>))<br>ax1=plt.subplot(<span class="hljs-number">221</span>,projection = <span class="hljs-string">&quot;3d&quot;</span>)<br>ax2=plt.subplot(<span class="hljs-number">222</span>)<br>ax3=plt.subplot(<span class="hljs-number">223</span>)<br>ax4=plt.subplot(<span class="hljs-number">224</span>)<br>drawPerspective(ax1,myfilter,title = <span class="hljs-string">&quot;GLPF Perspective Axes3D&quot;</span>, cmap = <span class="hljs-string">&quot;gray&quot;</span>)<br>drawCurv(ax2,[<span class="hljs-keyword">lambda</span> x:np.exp(-(x**<span class="hljs-number">2</span>)/(<span class="hljs-number">2</span>*(d**<span class="hljs-number">2</span>)))],[<span class="hljs-string">&quot;GLPF&quot;</span>],d,title = <span class="hljs-string">&quot;GLPF Curv&quot;</span>)<br>drawPanel(ax3,myfilter,title = <span class="hljs-string">&quot;GLPF Frequency Panel Axes2D&quot;</span>)<br>spatial_myfilter = frequencyToSpatial(myfilter)<br>drawPanel(ax4,spatial_myfilter,title = <span class="hljs-string">&quot;GLPF Spatial Panel Axes2D&quot;</span>)<br>plt.show()<br><br><span class="hljs-comment"># 测试GHPF</span><br>d = <span class="hljs-number">20</span><br>filter_type = <span class="hljs-string">&quot;hpf&quot;</span><br>myfilter = getGaussianMask(mask_shape,d,filter_type)<br>plt.figure(figsize=(<span class="hljs-number">12</span>,<span class="hljs-number">12</span>))<br>ax1=plt.subplot(<span class="hljs-number">221</span>,projection = <span class="hljs-string">&quot;3d&quot;</span>)<br>ax2=plt.subplot(<span class="hljs-number">222</span>)<br>ax3=plt.subplot(<span class="hljs-number">223</span>)<br>ax4=plt.subplot(<span class="hljs-number">224</span>)<br>drawPerspective(ax1,myfilter,title = <span class="hljs-string">&quot;GLPF Perspective Axes3D&quot;</span>, cmap = <span class="hljs-string">&quot;gray&quot;</span>)<br>drawCurv(ax2,[<span class="hljs-keyword">lambda</span> x:<span class="hljs-number">1</span>-np.exp(-(x**<span class="hljs-number">2</span>)/(<span class="hljs-number">2</span>*(d**<span class="hljs-number">2</span>)))],[<span class="hljs-string">&quot;GHPF&quot;</span>],d,title = <span class="hljs-string">&quot;GLPF Curv&quot;</span>)<br>drawPanel(ax3,myfilter,title = <span class="hljs-string">&quot;GLPF Frequency Panel Axes2D&quot;</span>)<br>spatial_myfilter = frequencyToSpatial(myfilter)<br>drawPanel(ax4,spatial_myfilter,title = <span class="hljs-string">&quot;GLPF Spatial Panel Axes2D&quot;</span>)<br>plt.show()<br></code></pre></td></tr></table></figure>
<p>高斯低通 GLPF 结果四图</p>
<p><img src="https://eddyblog.oss-cn-shenzhen.aliyuncs.com/ImageProcess/TypeOfFilter/7.png" srcset="/img/loading.gif" lazyload alt="png"></p>
<p>高斯高通 GHPF 结果四图</p>
<p><img src="https://eddyblog.oss-cn-shenzhen.aliyuncs.com/ImageProcess/TypeOfFilter/8.png" srcset="/img/loading.gif" lazyload alt="png"></p>
<h2 id="滤波器对比总结"><a href="#滤波器对比总结" class="headerlink" title="滤波器对比总结"></a>滤波器对比总结</h2><p>在规定滤波器为 100x100，阈值为 20 时，可以明显观察到，理想滤波器-&gt;高阶布特沃斯滤波器-&gt;低阶布特沃斯滤波器-&gt;高斯滤波器，可以由函数 Curv 看出对应的过渡。</p>
<p>我们同时也发现理想滤波器确实会存在<strong>振铃特性</strong>，这个将在后面的文章中再做分析学习。</p>
<h2 id="振铃特性"><a href="#振铃特性" class="headerlink" title="振铃特性"></a>振铃特性</h2><p>理想低通滤波器实验中，我们也可以很明显的发现<strong>振铃现象</strong>，间隙处原本统一的纹理由于模糊变得有明暗起伏。而随着被滤去的高频内容的数量的减少，图像的纹理变得越来越好，甚至我们仔细看第三幅图，也能发现振铃现象的纹理，课本是这么评价振铃现象和 ILPF 的。</p>
<blockquote>
<p>这种振铃现象是理想滤波器的一种特性，从这个例子我们可以清楚地看到，理想低通滤波器并不是非常实用。然而，作为滤波概念发展的一部分，研究这种滤波器的特性非常有用。</p>
</blockquote>
<h3 id="振铃现象的一些见解"><a href="#振铃现象的一些见解" class="headerlink" title="振铃现象的一些见解"></a>振铃现象的一些见解</h3><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-comment"># 绘制空间域表示图和水平线灰度剖面图</span><br><br><span class="hljs-keyword">for</span> d <span class="hljs-keyword">in</span> d_list:<br>    fre_mask=getIdealMask((<span class="hljs-number">688</span>,<span class="hljs-number">688</span>),d,<span class="hljs-string">&quot;lpf&quot;</span>)<br>    spa_mask=frequencyToSpatial(fre_mask)<br>    X = [i <span class="hljs-keyword">for</span> i <span class="hljs-keyword">in</span> <span class="hljs-built_in">range</span>(spa_mask.shape[<span class="hljs-number">0</span>])]<br>    Y = spa_mask[spa_mask.shape[<span class="hljs-number">0</span>]//<span class="hljs-number">2</span>]<br>    plt.figure(figsize=(<span class="hljs-number">8</span>,<span class="hljs-number">4</span>))<br>    ax1 = plt.subplot(<span class="hljs-number">121</span>)<br>    ax2 = plt.subplot(<span class="hljs-number">122</span>)<br>    ax1.set_title(<span class="hljs-string">f&quot;Spatial Img with $D_0 = <span class="hljs-subst">&#123;d&#125;</span>$&quot;</span>)<br>    ax2.set_title(<span class="hljs-string">f&quot;Grayscale with $D_0 = <span class="hljs-subst">&#123;d&#125;</span>$&quot;</span>)<br>    ax1.imshow(spa_mask,cmap = <span class="hljs-string">&quot;gray&quot;</span>)<br>    ax2.plot(X,Y)<br>    ax2.spines[<span class="hljs-string">&#x27;left&#x27;</span>].set_color(<span class="hljs-string">&#x27;none&#x27;</span>)<br>    ax2.spines[<span class="hljs-string">&#x27;top&#x27;</span>].set_color(<span class="hljs-string">&#x27;none&#x27;</span>)<br>    ax2.spines[<span class="hljs-string">&#x27;right&#x27;</span>].set_color(<span class="hljs-string">&#x27;none&#x27;</span>)<br>    ax2.set_yticks([])<br>    ax2.set_yticklabels([])<br></code></pre></td></tr></table></figure>
<p><img src="https://eddyblog.oss-cn-shenzhen.aliyuncs.com/ImageProcess/IdealFilter/6.png" srcset="/img/loading.gif" lazyload alt="png"></p>
<p><img src="https://eddyblog.oss-cn-shenzhen.aliyuncs.com/ImageProcess/IdealFilter/7.png" srcset="/img/loading.gif" lazyload alt="png"></p>
<p><img src="https://eddyblog.oss-cn-shenzhen.aliyuncs.com/ImageProcess/IdealFilter/8.png" srcset="/img/loading.gif" lazyload alt="png"></p>
<p><img src="https://eddyblog.oss-cn-shenzhen.aliyuncs.com/ImageProcess/IdealFilter/9.png" srcset="/img/loading.gif" lazyload alt="png"></p>
<p><img src="https://eddyblog.oss-cn-shenzhen.aliyuncs.com/ImageProcess/IdealFilter/10.png" srcset="/img/loading.gif" lazyload alt="png"></p>
<p>分别对应了上面的阈值，观察其滤波器的空间与表示，在$D_0$较小的时候有很明显的波动函数形状。</p>
<blockquote>
<p>ILPF 的模糊和振铃特性可用卷积定理来解释。由于 ILPF 在频率域的剖面图类似于盒状滤波器，因此可以预料相应空间滤波器具有 sinc 函数形状。空间域滤波可通过$h(x,y)$于图像卷积来实现。讲图像中的每个像素想象为一个离散冲击，它的强度与所在位置的灰度成正比。一个 sinc 函数与一个冲激卷积就是在冲激处复制这个 sinc 函数。<strong>sinc 函数的中心波瓣是引起模糊的主因，而外侧较小的波瓣是造成振铃的主要原因。sinc 函数“展开度”与$H(u,v)$半径成反比，所以$D_0$越大，空间 sinc 函数就趋近于一个卷积时不会导致模糊但也不会产生振铃的冲激</strong>。</p>
</blockquote>
<h1 id="图像去模糊（图像复原）"><a href="#图像去模糊（图像复原）" class="headerlink" title="图像去模糊（图像复原）"></a>图像去模糊（图像复原）</h1><h2 id="引言"><a href="#引言" class="headerlink" title="引言"></a>引言</h2><p>前面所接触的图像增强是一个，已知原图像，经处理后，得到增强图像的一个过程，而这一章将要深入的图像复原（重建），则是希望从（被污染）过的图像，经处理后，得到原图像的过程，是以<strong>预先确定的目标</strong>来改善图像。图像复原试图利用退化现象的某种<strong>先验知识</strong>来复原被退化的图像。因而，复原技术时面向退化模型的，并且采用相反的过程进行处理，以便恢复出原图像。虽然图像增强和图像复原两者在覆盖的领域和使用的技术栈有所重叠，其中还是有几点区别我们还是要提起注意的。</p>
<ul>
<li><p>形象化的描述</p>
<p>图像增强主要是一个主观的过程，而图像复原大部分是一个客观的过程。</p>
</li>
<li><p>已知与未知的区别</p>
<p>图像增强已知原始图像与变换（卷积核或者其频率域的谱），对于增强效果是未知且非预先确定的（只有一个大概方向，比如模糊还是锐化），而图像复原则已知污染图像，且对原始图像是预先确定的（测试条件下甚至是有标准比对的原始图像，是已知的），对于复原变换（污染变换的逆）常常是未知的，这就要求我们在做图像处理时常常需要“估计”我们的复原变换。</p>
</li>
<li><p>期望与探索的区别<br>由于两者已知和未知上的差距，这就导致图像复原通常会涉及设立一个<strong>最佳准则</strong>来产生期望结果的最佳估计。相比之下，图像增强技术基本上是一个<strong>探索性过程</strong>，即根据人类视觉系统的生理特点来设计改善图像的方法。</p>
</li>
</ul>
<h2 id="背景知识"><a href="#背景知识" class="headerlink" title="背景知识"></a>背景知识</h2><h3 id="线性系统"><a href="#线性系统" class="headerlink" title="线性系统"></a>线性系统</h3><p>可加性，$x_1(t)+x_2(t) = y_1(t)+y_2(t)$，从而有$a \times x_1(t) = a \times y_1(t)$</p>
<p>平移不变性</p>
<h3 id="卷积"><a href="#卷积" class="headerlink" title="卷积"></a>卷积</h3><p>卷积、离散二维卷积</p>
<p>从而可以利用卷积这个工具。</p>
<p>冲激响应：输入为一个脉冲信号，输出是一个冲激响应$h(x)$，实际上可以就是之前接触过的卷积核。</p>
<h3 id="图形复原"><a href="#图形复原" class="headerlink" title="图形复原"></a>图形复原</h3><p>复原</p>
<ul>
<li>试图利用退化过程的先验知识使已退化的图像恢复本来面目</li>
<li>根据退化的原因，分析引起退化的环境因素</li>
<li>建立相应的数学模型</li>
<li>沿着使图像降质的逆过程回复图像</li>
</ul>
<p>原因</p>
<ul>
<li>由于对焦不准导致的图像模糊是很常见的</li>
<li>此时，物体的外观信息并未丢失，而是被分散叠加显示了</li>
<li>如果能够把分散叠加的信息彼此分离，就可能去除模糊</li>
</ul>
<p>目的</p>
<ul>
<li>在于消除或减轻退化的影响</li>
</ul>
<p>方法</p>
<ul>
<li>由于退化系统是黑盒的，盲复原往往很困难，噪声干扰也为复原过程带来了困难和不确定性</li>
<li>图像复原是寻求在一定优化准则下的原始图象的最有估计。因此，不同的优化准则会获得不同的图像复原。评价指标的选择目前也是研究的方向之一，如峰值信号比等。</li>
</ul>
<h2 id="图像退化-复原过程模型"><a href="#图像退化-复原过程模型" class="headerlink" title="图像退化/复原过程模型"></a>图像退化/复原过程模型</h2><p>退化过程（污染过程）的描述：建模为一个退化函数和一个加性噪声项，对于输入图像（原图像）$f(x,y)$进行处理，产生一副退化后的图像$g(x,y)$，图像复原目的就是已知$g(x,y)$的前提下，希望得到原图像的一个估计，这个估计越接近原始输入图像越好。空间域中的退化图像可由下式给出：</p>
<script type="math/tex; mode=display">g(x,y) = h(x,y)  \star f(x,y) + \eta(x,y)</script><p>上式中$h(x,y)$是退化函数的空间表示，由第四章内容，我们可以将上式的模型写成等价的频率域表示：</p>
<script type="math/tex; mode=display">g(u,v) = H(u,v) F(u,v) + N(u,v)</script><p>这两个式子是本章后面大部分复原内容的基础。</p>
<h2 id="采用频率域滤波图像复原的原因"><a href="#采用频率域滤波图像复原的原因" class="headerlink" title="采用频率域滤波图像复原的原因"></a>采用频率域滤波图像复原的原因</h2><p>在频率域滤波进行图像复原主要在两个方面效果较好，其一是利用频率域滤波消除周期噪声，另一个是利用频率域做退化函数的逆滤波。</p>
<p>为什么要在频率域做逆滤波？观察之前退化模型的两个式子，我们不难发现：</p>
<script type="math/tex; mode=display">g(x,y) = h(x,y) \star f(x,y) + \eta(x,y) \tag 1</script><script type="math/tex; mode=display">g(u,v) = H(u,v) F(u,v) + N(u,v) \tag 2</script><p>对(1)式空间域来说，想要从$g(x,y)$恢复$f(x,y)$，避不开的是“卷积”的逆运算，这在定义和实现的复杂上都比较困难，而转化到频率域，从(2)式我们或许可以通过一个“除法”来实现逆滤波，结合之前噪声模型相关内容，我们尝试在频率域上对仅退化函数影响的图像，和更复杂一些的，退化函数和加性噪声双重影响的图像进行复原。</p>
<h2 id="逆滤波"><a href="#逆滤波" class="headerlink" title="逆滤波"></a>逆滤波</h2><p>退化函数已给出，或者由上面退化函数的估计方法获得后，最简单的复原方法是直接做逆滤波，即：</p>
<script type="math/tex; mode=display">\hat{F}(u,v) = \dfrac{G(u,v)}{H(u,v)}</script><p>然而根据前述我们知道，在噪声的影响下，$\hat{F}(u,v)$和$F(u,v)$仍有差别，即</p>
<script type="math/tex; mode=display">\hat{F}(u,v) = F(u,v) \dfrac{N(u,v)}{H(u,v)}</script><p>这个式子两点启发：</p>
<ol>
<li>知道退化函数也不能完全复原未退化图像，因为噪声函数未知。</li>
<li>如果退化函数是零或是非常小的值，那么噪声影响会被放大</li>
</ol>
<h2 id="最小均方误差（维纳）滤波"><a href="#最小均方误差（维纳）滤波" class="headerlink" title="最小均方误差（维纳）滤波"></a>最小均方误差（维纳）滤波</h2><p>实际上维纳滤波是在这里是相对逆滤波来说的，而并非指特别的滤波函数，且不仅应用在运动模糊滤波中。</p>
<script type="math/tex; mode=display">\hat{F}(u,v) =[\dfrac{1}{H(u,v)} \dfrac{ {|H(u,v)|}^2 }{ {|H(u,v)|}^2+ S_{\eta}(u,v)/S_f(u,v) }] G(u,v)</script><p>$S_{\eta}(u,v)$为噪声的功率谱而$S_f(u,v)$是未退化图像的功率谱，比值为噪信比。而由于谱${|N(u,v)|}^2$是一个常数，这大大简化了处理。我们常用下面的表达式来近似。</p>
<script type="math/tex; mode=display">\hat{F}(u,v) =[\dfrac{1}{H(u,v)} \dfrac{ {|H(u,v)|}^2 }{ {|H(u,v)|}^2+ K }] G(u,v)</script><p>理解与启发：</p>
<ul>
<li>当频域某处没有噪声时， 𝑁/𝑆 的值为 0，方括号中表达式的值为 1，表示此时不需要对 𝐺/𝐻 修正。（回到逆滤波）</li>
<li>当频域某处噪声大时， 𝑁/𝑆 的值比较大，方括号表达式的值小于 1，相当于对此处 𝐺/𝐻 的值进行抑制，以降低噪声的影响。</li>
</ul>
<p>实现：</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">wienerFiltering</span>(<span class="hljs-params">input_img, h, NSR ,htype = <span class="hljs-string">&quot;frequency&quot;</span></span>):</span><br>    <span class="hljs-keyword">assert</span> htype <span class="hljs-keyword">in</span> (<span class="hljs-string">&quot;frequency&quot;</span>,<span class="hljs-string">&quot;spatial&quot;</span>)<br>    <span class="hljs-comment"># 输入图像的傅里叶变换</span><br>    input_img_fft = np.fft.fft2(input_img)<br>    input_img_fft = np.fft.ifftshift(input_img_fft)<br><br>    <span class="hljs-keyword">if</span>(htype == <span class="hljs-string">&quot;spatial&quot;</span>):<br>        <span class="hljs-comment"># 模糊化函数的傅里叶变换</span><br>        h_fft = np.fft.fft2(h)<br>    <span class="hljs-keyword">else</span> :<br>        h_fft = h<br>    <span class="hljs-comment"># 退化函数模值的平方</span><br>    h_abs_square = np.<span class="hljs-built_in">abs</span>(h_fft)**<span class="hljs-number">2</span><br>    <span class="hljs-comment"># 维纳滤波</span><br>    <span class="hljs-comment"># 使用的是 共轭/模方+NSR的形式，并非 9 10 式</span><br>    output_image_fft = np.conj(h_fft) / (h_abs_square + NSR)<br><br>    <span class="hljs-comment"># 输出图像傅里叶反变换</span><br>    output_image = np.fft.ifft2(output_image_fft * input_img_fft)<br>    output_image = np.<span class="hljs-built_in">abs</span>(np.fft.fftshift(output_image))<br>    <span class="hljs-keyword">return</span> output_image<br></code></pre></td></tr></table></figure>
<h1 id="多重曝光融合"><a href="#多重曝光融合" class="headerlink" title="多重曝光融合"></a>多重曝光融合</h1><ul>
<li>曝光程度对照片质量有影响</li>
<li>不同曝光程度的照片中都包含有用场景信息</li>
</ul>
<h2 id="成像质量计算"><a href="#成像质量计算" class="headerlink" title="成像质量计算"></a>成像质量计算</h2><p><img src="https://eddyblog.oss-cn-shenzhen.aliyuncs.com/ImageProcess/Review/Review_19.PNG" srcset="/img/loading.gif" lazyload alt="19"></p>
<h2 id="为什么不直接用直方图均衡化来解决过曝光和欠曝光问题"><a href="#为什么不直接用直方图均衡化来解决过曝光和欠曝光问题" class="headerlink" title="为什么不直接用直方图均衡化来解决过曝光和欠曝光问题"></a>为什么不直接用直方图均衡化来解决过曝光和欠曝光问题</h2><p>过曝光和曝光不足是完全丧失了信息，而多重曝光得到的多幅图像则保留了这部分信息。举曝光不足的例子。比如黑色背景和灰色城堡，在曝光不足的情况下灰度值均为 0，显示为相同的黑色，实际上已经丢失了城堡和背景区分的信息，即便使用直方图均衡，可预知的结果是城堡和背景灰度值增加但是仍保持相同，无法区分两者。所以直方图均衡无法解决此类信息彻底丢失的问题。多重曝光则有多幅原始图像，可以对局部选择信息保留的部分进行融合。过曝光同理</p>
<h2 id="计算问题"><a href="#计算问题" class="headerlink" title="计算问题"></a>计算问题</h2><p>直接按下式进行加权融合会出现问题</p>
<p>$𝒑=𝒘^′∗𝒑^′+𝒘^{′′}∗𝒑^{′′}+𝒘^{′′′}∗𝒑^{′′′}$</p>
<p>解决办法</p>
<ul>
<li><p>基于原图边缘信息的图像融合</p>
<ul>
<li>用照片的边缘图把质量系数矩阵中的边缘过滤掉</li>
<li>Laplace 边缘图*成像系数矩阵</li>
</ul>
</li>
<li><p>基于多尺度边缘信息的图像融合</p>
<ul>
<li>单个 Laplacian 边缘图只包含图像中某个尺度的边缘信息</li>
<li>所以将图像缩放，计算多尺度的边缘图，进行融合</li>
</ul>
</li>
</ul>
<h1 id="图像压缩"><a href="#图像压缩" class="headerlink" title="图像压缩"></a>图像压缩</h1><h2 id="三种冗余"><a href="#三种冗余" class="headerlink" title="三种冗余"></a>三种冗余</h2><p>P335，编码冗余、空间和时间冗余、不相关信息</p>
<h2 id="一些基本的压缩方法"><a href="#一些基本的压缩方法" class="headerlink" title="一些基本的压缩方法"></a>一些基本的压缩方法</h2><p>哈夫曼编码、算术编码、LZW 编码（课本 P348-P350）</p>
<h2 id="LZW-编码步骤"><a href="#LZW-编码步骤" class="headerlink" title="LZW 编码步骤"></a>LZW 编码步骤</h2><ul>
<li>在词典中搜索与输入字符串的当前位置形成最大匹配的词汇 w；</li>
<li>输出 w 的索引值；</li>
<li>把 wa 输入词典，其中 a 是最大匹配后面的字符</li>
<li>可用字典树加速查询最大匹配</li>
</ul>
<h3 id="代码实现-3"><a href="#代码实现-3" class="headerlink" title="代码实现"></a>代码实现</h3><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br></pre></td><td class="code"><pre><code class="hljs Go"><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-params">(c *Encoder)</span> <span class="hljs-title">Circle</span><span class="hljs-params">()</span></span> &#123;<br>	fmt.Println(<span class="hljs-string">&quot;Start Encode Circle!&quot;</span>)<br>	<span class="hljs-keyword">for</span> key, char := <span class="hljs-keyword">range</span> c.befComp &#123;<br>		outIndex, addflag, _ := c.Digest(char)<br>		<span class="hljs-keyword">if</span> addflag == <span class="hljs-literal">true</span> &#123;<br>			c.preString = []<span class="hljs-keyword">byte</span>&#123;&#125;<br>			c.preString = <span class="hljs-built_in">append</span>(c.preString, char)<br>			c.aftComp = <span class="hljs-built_in">append</span>(c.aftComp, outIndex)<br>			<span class="hljs-keyword">if</span> key == <span class="hljs-built_in">len</span>(c.befComp)<span class="hljs-number">-1</span> &#123;<br>				c.aftComp = <span class="hljs-built_in">append</span>(c.aftComp, char)<br>			&#125;<br>		&#125; <span class="hljs-keyword">else</span> &#123;<br>			<span class="hljs-comment">// 在末尾的时候特判</span><br>			<span class="hljs-keyword">if</span> key == <span class="hljs-built_in">len</span>(c.befComp)<span class="hljs-number">-1</span> &#123;<br>				<span class="hljs-comment">// c.preString = []byte&#123;&#125;</span><br>				c.aftComp = <span class="hljs-built_in">append</span>(c.aftComp, outIndex)<br>			&#125;<br>		&#125;<br>	&#125;<br>	<span class="hljs-comment">// fmt.Println(&quot;Test print:&quot;)</span><br>	<span class="hljs-comment">// fmt.Println(&quot;before compression: &quot;, c.befComp)</span><br>	<span class="hljs-comment">// fmt.Println(&quot;after compression: &quot;, c.aftComp)</span><br>&#125;<br><br><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-params">(c *Encoder)</span> <span class="hljs-title">Digest</span><span class="hljs-params">(scanChar <span class="hljs-keyword">byte</span>)</span> <span class="hljs-params">(outIndex <span class="hljs-keyword">byte</span>, flag <span class="hljs-keyword">bool</span>, err error)</span></span> &#123;<br>	<span class="hljs-comment">// 将Pre字符串和扫描的字符组合成为checkString</span><br>	checkString := <span class="hljs-built_in">append</span>(c.preString, scanChar)<br>	<span class="hljs-comment">// 这列可以换成 lastroot 有待改进</span><br>	nowPtr, isFind := c.FindTreeptr(checkString, c.root)<br>	<span class="hljs-keyword">if</span> isFind == <span class="hljs-literal">true</span> &#123;<br>		<span class="hljs-comment">// 变更pre continue</span><br>		<span class="hljs-comment">// 不做输出</span><br>		c.preString = checkString<br>		<span class="hljs-keyword">return</span> <span class="hljs-keyword">byte</span>(nowPtr.index), <span class="hljs-literal">false</span>, <span class="hljs-literal">nil</span><br>	&#125; <span class="hljs-keyword">else</span> &#123;<br>		<span class="hljs-comment">// 加入新结点</span><br>		outIndex, err := c.AddTreeptr(nowPtr, scanChar)<br>		<span class="hljs-comment">// 先输出</span><br>		<span class="hljs-keyword">return</span> outIndex, <span class="hljs-literal">true</span>, err<br>	&#125;<br><br>&#125;<br><br><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-params">(c *Encoder)</span> <span class="hljs-title">FindTreeptr</span><span class="hljs-params">(leftString []<span class="hljs-keyword">byte</span>, treeRoot *TreeNode)</span> <span class="hljs-params">(addptr *TreeNode, flag <span class="hljs-keyword">bool</span>)</span></span> &#123;<br>	tempChar := leftString[<span class="hljs-number">0</span>]<br>	<span class="hljs-keyword">if</span> treeRoot.childNode[tempChar] != <span class="hljs-literal">nil</span> &#123;<br>		<span class="hljs-comment">// 已经有节点</span><br>		<span class="hljs-keyword">if</span> <span class="hljs-built_in">len</span>(leftString) == <span class="hljs-number">1</span> &#123;<br>			<span class="hljs-comment">// 返回本结点</span><br>			<span class="hljs-keyword">return</span> treeRoot.childNode[tempChar], <span class="hljs-literal">true</span><br>		&#125; <span class="hljs-keyword">else</span> &#123;<br>			<span class="hljs-comment">// 递归</span><br>			<span class="hljs-keyword">return</span> c.FindTreeptr(leftString[<span class="hljs-number">1</span>:], treeRoot.childNode[tempChar])<br>		&#125;<br>	&#125; <span class="hljs-keyword">else</span> &#123;<br>		<span class="hljs-comment">// 未有节点</span><br>		<span class="hljs-comment">// 返回父亲结点（输出过程需要知道index）</span><br>		<span class="hljs-keyword">return</span> treeRoot, <span class="hljs-literal">false</span><br>	&#125;<br>&#125;<br><br><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-params">(c *Encoder)</span> <span class="hljs-title">AddTreeptr</span><span class="hljs-params">(faptr *TreeNode, addchar <span class="hljs-keyword">byte</span>)</span> <span class="hljs-params">(outIndex <span class="hljs-keyword">byte</span>, err error)</span></span> &#123;<br>	outIndex = <span class="hljs-keyword">byte</span>(faptr.index)<br>	<span class="hljs-keyword">if</span> c.capacity &gt;= <span class="hljs-number">256</span> &#123;<br>		<span class="hljs-keyword">return</span> outIndex, errors.New(<span class="hljs-string">&quot;Dictionary Full!&quot;</span>)<br>	&#125;<br>	<span class="hljs-comment">// 由于获取父结点index需要所以这么操作</span><br>	faptr.childNode[addchar] = <span class="hljs-built_in">new</span>(TreeNode)<br>	faptr.childNode[addchar].index = <span class="hljs-keyword">int</span>(c.capacity)<br>	c.capacity++<br>	<span class="hljs-comment">// c.dict[newIndex] =</span><br>	<span class="hljs-keyword">return</span> outIndex, <span class="hljs-literal">nil</span><br>&#125;<br></code></pre></td></tr></table></figure>
<h2 id="LZW-解码步骤"><a href="#LZW-解码步骤" class="headerlink" title="LZW 解码步骤"></a>LZW 解码步骤</h2><ul>
<li>解码步骤</li>
<li>初始化词典；</li>
<li>翻译首个索引值为 w，输出 w；</li>
<li>把 w？放入词典，其中？为待定字符；</li>
</ul>
<h3 id="代码实现-4"><a href="#代码实现-4" class="headerlink" title="代码实现"></a>代码实现</h3><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br></pre></td><td class="code"><pre><code class="hljs Go"><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-params">(c *Decoder)</span> <span class="hljs-title">Circle</span><span class="hljs-params">()</span></span> &#123;<br>	fmt.Println(<span class="hljs-string">&quot;Start Decoder Circle!&quot;</span>)<br>	<span class="hljs-keyword">for</span> _, value := <span class="hljs-keyword">range</span> c.befComp &#123;<br>		<span class="hljs-keyword">if</span> <span class="hljs-built_in">len</span>(c.storeString) == <span class="hljs-number">0</span> &#123;<br>			c.aftComp = <span class="hljs-built_in">append</span>(c.aftComp, value)<br>			<span class="hljs-comment">// 第一个 特判 变更storeString</span><br>			c.storeString = <span class="hljs-built_in">append</span>(c.storeString, value)<br>			<span class="hljs-keyword">continue</span><br>		&#125;<br>		<span class="hljs-comment">// 其他情况</span><br>		<span class="hljs-comment">// (错误)写： aftComp是byte切片   storeString 也是byte切片</span><br>		<span class="hljs-comment">// 先从字典获取现在值对应的字符串</span><br>		lookUpString := c.dict[value]<br>		<span class="hljs-comment">// 加入输出</span><br>		c.aftComp = <span class="hljs-built_in">append</span>(c.aftComp, []<span class="hljs-keyword">byte</span>(lookUpString)...)<br><br>		<span class="hljs-comment">// XX? 变成XXX</span><br>		<span class="hljs-comment">// 把查到的字典加进来</span><br>		<span class="hljs-keyword">if</span> flag := c.CheckDicFull(); flag == <span class="hljs-literal">true</span> &#123;<br>			<span class="hljs-keyword">continue</span><br>		&#125; <span class="hljs-keyword">else</span> &#123;<br><br>			c.StoreDic(c.storeString, lookUpString)<br>			<span class="hljs-comment">// 将storeString 转化为当前 XX？</span><br>			c.storeString = []<span class="hljs-keyword">byte</span>(lookUpString)<br>		&#125;<br><br>	&#125;<br>&#125;<br><br><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-params">(c *Decoder)</span> <span class="hljs-title">CheckDicFull</span><span class="hljs-params">()</span> <span class="hljs-params">(flag <span class="hljs-keyword">bool</span>)</span></span> &#123;<br>	<span class="hljs-keyword">if</span> <span class="hljs-built_in">len</span>(c.dict) == <span class="hljs-number">256</span> &#123;<br>		<span class="hljs-keyword">return</span> <span class="hljs-literal">true</span><br>	&#125;<br>	<span class="hljs-keyword">return</span> <span class="hljs-literal">false</span><br>&#125;<br><br><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-params">(c *Decoder)</span> <span class="hljs-title">StoreDic</span><span class="hljs-params">(original []<span class="hljs-keyword">byte</span>, prefix <span class="hljs-keyword">string</span>)</span></span> &#123;<br>	<span class="hljs-comment">// 原始+这次扫描的第一个byte（）</span><br>	newcontent := <span class="hljs-built_in">append</span>(original, prefix[<span class="hljs-number">0</span>])<br>	length := <span class="hljs-built_in">len</span>(c.dict)<br>	fmt.Println(length, <span class="hljs-keyword">string</span>(newcontent))<br>	c.dict[<span class="hljs-keyword">byte</span>(length)] = <span class="hljs-keyword">string</span>(newcontent)<br>&#125;<br></code></pre></td></tr></table></figure>
<h3 id="阶段总结"><a href="#阶段总结" class="headerlink" title="阶段总结"></a>阶段总结</h3><ul>
<li>行程编码是利用数据的稀疏分布特点进行编码</li>
<li>词典编码是根据词典将输入字符转换为对应词条的索引输出</li>
<li>LZW 方法在编码时根据输入的字符串动态生成词典</li>
<li>LZW 方法在解码时根据编码值和待定字符法进行词典的复原</li>
</ul>
<h2 id="LZ77-编码图解"><a href="#LZ77-编码图解" class="headerlink" title="LZ77 编码图解"></a>LZ77 编码图解</h2><p><img src="https://eddyblog.oss-cn-shenzhen.aliyuncs.com/ImageProcess/Review/Review_20.png" srcset="/img/loading.gif" lazyload alt="20"></p>
<ul>
<li>搜索缓存区远大于编码缓存区(32KB v.s. 258 Bytes)</li>
<li>成块地读取字符以减轻 I/O 负担</li>
<li>编码完成后采用哈夫曼法对三元组进行再编码</li>
<li>编码质量一般优于 LZW 法<ul>
<li>LZW 法的词典中存在没有使用的词汇</li>
<li>在 LZW 法中已经扫描过的字符不能重组为词汇</li>
</ul>
</li>
<li>应用非常广泛(zip, rar, gzip, png, arj)</li>
</ul>
<h3 id="阶段总结-1"><a href="#阶段总结-1" class="headerlink" title="阶段总结"></a>阶段总结</h3><ul>
<li>LZ77 是隐式词典法</li>
<li>LZ77 存储隐式词典增大后，编码效率降低的问题</li>
<li>窗口 LZ77 编码法同时限制隐式词典的大小和搜索缓冲区的大小，进而保证编码效率</li>
<li>LZ77 法的编码值是三元组，具有不随着词典增大而增大的优点</li>
<li>窗口 LZ77 编码的三元组定义具有特殊性</li>
</ul>
<h2 id="其他课件内容"><a href="#其他课件内容" class="headerlink" title="其他课件内容"></a>其他课件内容</h2><h3 id="DCT-相关"><a href="#DCT-相关" class="headerlink" title="DCT 相关"></a>DCT 相关</h3><p><img src="https://eddyblog.oss-cn-shenzhen.aliyuncs.com/ImageProcess/Review/Review_21.PNG" srcset="/img/loading.gif" lazyload alt="21"></p>
<p><img src="https://eddyblog.oss-cn-shenzhen.aliyuncs.com/ImageProcess/Review/Review_22.PNG" srcset="/img/loading.gif" lazyload alt="22"></p>
<p><img src="https://eddyblog.oss-cn-shenzhen.aliyuncs.com/ImageProcess/Review/Review_23.PNG" srcset="/img/loading.gif" lazyload alt="23"></p>
<p><img src="https://eddyblog.oss-cn-shenzhen.aliyuncs.com/ImageProcess/Review/Review_24.PNG" srcset="/img/loading.gif" lazyload alt="24"></p>
<p><img src="https://eddyblog.oss-cn-shenzhen.aliyuncs.com/ImageProcess/Review/Review_25.PNG" srcset="/img/loading.gif" lazyload alt="25"></p>
<p><img src="https://eddyblog.oss-cn-shenzhen.aliyuncs.com/ImageProcess/Review/Review_26.PNG" srcset="/img/loading.gif" lazyload alt="26"></p>
<p><img src="https://eddyblog.oss-cn-shenzhen.aliyuncs.com/ImageProcess/Review/Review_27.PNG" srcset="/img/loading.gif" lazyload alt="27"></p>
<p><img src="https://eddyblog.oss-cn-shenzhen.aliyuncs.com/ImageProcess/Review/Review_28.PNG" srcset="/img/loading.gif" lazyload alt="28"></p>
<h3 id="常见压缩思路"><a href="#常见压缩思路" class="headerlink" title="常见压缩思路"></a>常见压缩思路</h3><ul>
<li>二值图像压缩思路：行程编码</li>
<li>灰度值图像压缩思路：<ul>
<li>设置阈值转换为 n 幅二值图像，分别用游程编码压缩</li>
<li>用预测编码法，降低图像的信息熵，如简单的 yt+1=yt</li>
<li>变换编码法（如离散余弦变换 DCT）</li>
</ul>
</li>
<li>真彩色图像的压缩思路：RGB 分为三幅灰度图像转灰度图像压缩。</li>
</ul>
<h3 id="常见图片压缩格式实现思路"><a href="#常见图片压缩格式实现思路" class="headerlink" title="常见图片压缩格式实现思路"></a>常见图片压缩格式实现思路</h3><p><img src="https://eddyblog.oss-cn-shenzhen.aliyuncs.com/ImageProcess/Review/Review_29.PNG" srcset="/img/loading.gif" lazyload alt="29"></p>
<p><img src="https://eddyblog.oss-cn-shenzhen.aliyuncs.com/ImageProcess/Review/Review_30.PNG" srcset="/img/loading.gif" lazyload alt="30"></p>
<p><img src="https://eddyblog.oss-cn-shenzhen.aliyuncs.com/ImageProcess/Review/Review_31.PNG" srcset="/img/loading.gif" lazyload alt="31"></p>
<p><img src="https://eddyblog.oss-cn-shenzhen.aliyuncs.com/ImageProcess/Review/Review_32.PNG" srcset="/img/loading.gif" lazyload alt="32"></p>
<p><img src="https://eddyblog.oss-cn-shenzhen.aliyuncs.com/ImageProcess/Review/Review_33.PNG" srcset="/img/loading.gif" lazyload alt="33"></p>
<p><img src="https://eddyblog.oss-cn-shenzhen.aliyuncs.com/ImageProcess/Review/Review_34.PNG" srcset="/img/loading.gif" lazyload alt="34"></p>
<p><img src="https://eddyblog.oss-cn-shenzhen.aliyuncs.com/ImageProcess/Review/Review_35.PNG" srcset="/img/loading.gif" lazyload alt="35"></p>
<h1 id="图像形态学"><a href="#图像形态学" class="headerlink" title="图像形态学"></a>图像形态学</h1><h2 id="概述"><a href="#概述" class="headerlink" title="概述"></a>概述</h2><ul>
<li>形态学一般指生物学中研究动物和植物结构的一个分支</li>
<li>用数学形态学（也称图像代数）表示以形态为基础对图像进行分析的数学工具</li>
<li>基本思想是用具有一定形态的结构元素去度量和提取图像中的对应形状以达到对图像分析和识别的目的</li>
<li>形态学图像处理的数学基础和所用语言是集合论</li>
<li>形态学图像处理的应用可以简化图像数据，保持它们基本的形状特性，并除去不相干的结构</li>
<li>形态学图像处理的主要运算有 4 个：膨胀、腐蚀、开操作和闭操作</li>
</ul>
<h2 id="四种运算"><a href="#四种运算" class="headerlink" title="四种运算"></a>四种运算</h2><p><img src="https://eddyblog.oss-cn-shenzhen.aliyuncs.com/ImageProcess/Review/Review_36.PNG" srcset="/img/loading.gif" lazyload alt="36"></p>
<p><img src="https://eddyblog.oss-cn-shenzhen.aliyuncs.com/ImageProcess/Review/Review_37.PNG" srcset="/img/loading.gif" lazyload alt="37"></p>
<p><img src="https://eddyblog.oss-cn-shenzhen.aliyuncs.com/ImageProcess/Review/Review_38.PNG" srcset="/img/loading.gif" lazyload alt="38"></p>
<p><img src="https://eddyblog.oss-cn-shenzhen.aliyuncs.com/ImageProcess/Review/Review_39.PNG" srcset="/img/loading.gif" lazyload alt="39"></p>
<p><img src="https://eddyblog.oss-cn-shenzhen.aliyuncs.com/ImageProcess/Review/Review_40.PNG" srcset="/img/loading.gif" lazyload alt="40"></p>
<ul>
<li>开操作的 3 条性质<ul>
<li>AoB 是 A 的子集合</li>
<li>如果 C 是 D 的子集，则 CoB 是 DoB 的子集</li>
<li>(AoB)oB= AoB</li>
</ul>
</li>
<li>闭操作的 3 条性质<ul>
<li>A 是 A•B 的子集合</li>
<li>如果 C 是 D 的子集，则 C•B 是 D•B 的子集</li>
<li>(A•B)•B= A•B</li>
</ul>
</li>
</ul>
<h2 id="形态学主要应用"><a href="#形态学主要应用" class="headerlink" title="形态学主要应用"></a>形态学主要应用</h2><p>边界提取：B 先对 A 腐蚀，A 减去腐蚀得到边界</p>
<p>区域填充：</p>
<p>联通分量提取</p>
<h1 id="图像分割"><a href="#图像分割" class="headerlink" title="图像分割"></a>图像分割</h1><h2 id="概述-1"><a href="#概述-1" class="headerlink" title="概述"></a>概述</h2><p>分割的目的：将图像<strong>划分</strong>为不同<strong>区域</strong>。</p>
<p>三大类方法：</p>
<ul>
<li>根据区域间灰度不连续搜寻区域之间的边界，在间断检测、边缘连接和边界检测介绍</li>
<li>以像素性质的分布进行阈值处理，在阈值处理介绍</li>
<li>直接搜寻区域进行分割，在基于区域的分割中介绍</li>
</ul>
<p>Q&amp;A：多尺度的边缘检测仍然需要选择确定的尺度，不能智能辨识。</p>
<h3 id="间断检测类型"><a href="#间断检测类型" class="headerlink" title="间断检测类型"></a>间断检测类型</h3><p>点检测、线检测、边缘检测</p>
<p>差分、数值微分：$\partial$ 一阶对应线检测、二阶对应点检测</p>
<h3 id="间断检测：拉普拉斯算子"><a href="#间断检测：拉普拉斯算子" class="headerlink" title="间断检测：拉普拉斯算子"></a>间断检测：拉普拉斯算子</h3><script type="math/tex; mode=display">∇^2f ＝4z_5 - (z_2 + z_4 + z_6 + z_8)</script><script type="math/tex; mode=display">∇^2f ＝8z_5 - (z_1 + z_2 + z_3 + z_4 + z_5 + z_6 + z_7 + z_8 + z_9)</script><ul>
<li>缺点：<ul>
<li>拉普拉斯算子对噪声具有敏感性</li>
<li>拉普拉斯算子的幅值产生双边缘</li>
<li>拉普拉斯算子不能检测边缘的方向</li>
</ul>
</li>
<li>优点：<ul>
<li>可以利用零交叉的性质进行边缘定位</li>
<li>可以确定一个像素是在边缘暗的一边还是亮的一边</li>
</ul>
</li>
</ul>
<p>Derivative of Gaussian Filter</p>
<p>根据交换律，先进性高斯模糊核与边缘提取核先计算，从而减少整体的计算量。</p>
<p>课后探索：边缘提取：Canny 算法 Mask-RCNN</p>
<h1 id="彩色图像"><a href="#彩色图像" class="headerlink" title="彩色图像"></a>彩色图像</h1><h2 id="色彩的本质"><a href="#色彩的本质" class="headerlink" title="色彩的本质"></a>色彩的本质</h2><p>人对色彩的感知：视杆细胞，视锥细胞</p>
<p>色彩空间（英语：Color space）是对色彩的组织方式。借助色彩空间和针对物理设备的测试，可以得到色彩的固定模拟和数字表示。色彩空间可以只通过任意挑选一些颜色来定义，比如像彩通系统就只是把一组特定的颜色作为样本，然后给每个颜色定义名字和代码；也可以是基于严谨的数学定义，比如 Adobe RGB、sRGB。</p>
<p>CIE 1931 xyz 是第一次人眼对色彩感知度量建立色彩空间的尝试，几乎所有其它色彩空间的基础。有一些变体。</p>
<ul>
<li>CIELUV</li>
<li>CIE L*A*B* 基于人眼</li>
</ul>
<p>RGB 加法混色法，从暗处叠加产生颜色（sRGB，Adobe RGB）</p>
<p>CMYK 减法混色法</p>
<p>HSV 艺术家们常用，使用色相饱和度和明度<br>HSL 用亮度（Lightness）代替明度（Value/Brightness）</p>
<h1 id="其他讨论区问题"><a href="#其他讨论区问题" class="headerlink" title="其他讨论区问题"></a>其他讨论区问题</h1><h2 id="调研-C-C-语言中-main-函数的两个常见参数的意义和用法，将调研结果写在下面的讨论区"><a href="#调研-C-C-语言中-main-函数的两个常见参数的意义和用法，将调研结果写在下面的讨论区" class="headerlink" title="调研 C/C++语言中 main 函数的两个常见参数的意义和用法，将调研结果写在下面的讨论区"></a>调研 C/C++语言中 main 函数的两个常见参数的意义和用法，将调研结果写在下面的讨论区</h2><p>主函数程序应当含有一个名为 main 的全局函数，它被指定为程序的启动点。它应当有下列形式之一：</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs C++"><span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">main</span> <span class="hljs-params">()</span> </span>&#123; body &#125; (<span class="hljs-number">1</span>)<br><span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">main</span> <span class="hljs-params">(<span class="hljs-keyword">int</span> argc, <span class="hljs-keyword">char</span> _argv[])</span> </span>&#123; body &#125; (<span class="hljs-number">2</span>)<br><span class="hljs-comment">// 其他由实现定义的形式，返回类型为 int (3)</span><br></code></pre></td></tr></table></figure>
<ul>
<li>argc - 非负数，表示从程序运行的环境传递给程序的实参个数。</li>
<li><p>argv - 指针，指向包含 argc + 1 个指针的数组的首元素。数组末元素为空指针，若其前面有任何元素，则它们指向空终止多字节字符串，表示从执行环境传递给程序的若干参数。若 argv[0] 不是空指针，或等价地 argc &gt; 0 ，则它指向表示用于调用程序的名称的字符串，或空字符串。</p>
</li>
<li><p>body - 主函数的函数体<br>名字 argc 和 argv 是任取的，而且形参的类型的表示方式也是：int main(int ac, char** av) 同样合法。</p>
</li>
</ul>
<p>main() 的一种常见的由实现定义的形式还有（除 argc 和 argv 之外的）第三个参数，类型为 char*[] ，指向指向执行环境变量的指针数组。</p>

            </div>
            <hr>
            <div>
              <div class="post-metas mb-3">
                
                  <div class="post-meta mr-3">
                    <i class="iconfont icon-category"></i>
                    
                      <a class="hover-with-bg" href="/categories/Computer-Science/">Computer Science</a>
                    
                      <a class="hover-with-bg" href="/categories/Computer-Science/%E6%95%B0%E5%AD%97%E5%9B%BE%E5%83%8F%E5%A4%84%E7%90%86/">数字图像处理</a>
                    
                  </div>
                
                
                  <div class="post-meta">
                    <i class="iconfont icon-tags"></i>
                    
                      <a class="hover-with-bg" href="/tag/%E6%95%B0%E5%AD%97%E5%9B%BE%E5%83%8F%E5%A4%84%E7%90%86/">数字图像处理</a>
                    
                  </div>
                
              </div>
              
                <p class="note note-warning">
                  
                    本博客所有文章除特别声明外，均采用 <a target="_blank" href="https://creativecommons.org/licenses/by-sa/4.0/deed.zh" rel="nofollow noopener noopener">CC BY-SA 4.0 协议</a> ，转载请注明出处！
                  
                </p>
              
              
                <div class="post-prevnext">
                  <article class="post-prev col-6">
                    
                    
                      <a href="/post/68340cec.html">
                        <i class="iconfont icon-arrowleft"></i>
                        <span class="hidden-mobile">Linux操作系统——Linux复习</span>
                        <span class="visible-mobile">上一篇</span>
                      </a>
                    
                  </article>
                  <article class="post-next col-6">
                    
                    
                      <a href="/post/2af9aa70.html">
                        <span class="hidden-mobile">数字图像处理——色彩</span>
                        <span class="visible-mobile">下一篇</span>
                        <i class="iconfont icon-arrowright"></i>
                      </a>
                    
                  </article>
                </div>
              
            </div>

            
              <!-- Comments -->
              <article class="comments" id="comments" lazyload>
                
                  
                
                
<div class="cusdis"></div>
<div id="cusdis_thread" data-host="https://cusdis.com" data-app-id="3d66d51c-fa21-442d-9efa-c1b9acfeb762"
  data-page-id="99372ce5a6856aa90f5269e47071e61f" data-page-url="post/572ecb4f.html" data-page-title="数字图像处理——章节总复习">
  <script type="text/javascript">
    var src = 'https://cusdis.com/js/widget/lang/' + 'zh-cn' + '.js'
    Fluid.utils.createScript(src)

  </script>
  <script type="text/javascript">
    Fluid.utils.loadComments('#cusdis_thread', function () {
      Fluid.utils.createScript("https://cusdis.com/js/cusdis.es.js");
    });

  </script>
</div>

<noscript>Please enable JavaScript to view the comments</noscript>


              </article>
            
          </article>
        </div>
      </div>
    </div>
    
      <div class="d-none d-lg-block col-lg-2 toc-container" id="toc-ctn">
        <div id="toc">
  <p class="toc-header"><i class="iconfont icon-list"></i>&nbsp;目录</p>
  <div class="toc-body" id="toc-body"></div>
</div>

      </div>
    
  </div>
</div>

<!-- Custom -->


    

    
      <a id="scroll-top-button" href="#" role="button">
        <i class="iconfont icon-arrowup" aria-hidden="true"></i>
      </a>
    

    
      <div class="modal fade" id="modalSearch" tabindex="-1" role="dialog" aria-labelledby="ModalLabel"
     aria-hidden="true">
  <div class="modal-dialog modal-dialog-scrollable modal-lg" role="document">
    <div class="modal-content">
      <div class="modal-header text-center">
        <h4 class="modal-title w-100 font-weight-bold">搜索</h4>
        <button type="button" id="local-search-close" class="close" data-dismiss="modal" aria-label="Close">
          <span aria-hidden="true">&times;</span>
        </button>
      </div>
      <div class="modal-body mx-3">
        <div class="md-form mb-5">
          <input type="text" id="local-search-input" class="form-control validate">
          <label data-error="x" data-success="v"
                 for="local-search-input">关键词</label>
        </div>
        <div class="list-group" id="local-search-result"></div>
      </div>
    </div>
  </div>
</div>
    

    
  </main>

  <footer class="text-center mt-5 py-3">
  <div class="footer-content">
     <a href="https://hexo.io" target="_blank" rel="nofollow noopener"><span>Hexo</span></a> <i class="iconfont icon-love"></i> <a href="https://github.com/fluid-dev/hexo-theme-fluid" target="_blank" rel="nofollow noopener"><span>Fluid</span></a> 
  </div>
  

  

  
</footer>


  <!-- SCRIPTS -->
  
  <script  src="https://cdn.jsdelivr.net/npm/nprogress@0.2.0/nprogress.min.js" ></script>
  <link  rel="stylesheet" href="https://cdn.jsdelivr.net/npm/nprogress@0.2.0/nprogress.min.css" />

  <script>
    NProgress.configure({"showSpinner":false,"trickleSpeed":100})
    NProgress.start()
    window.addEventListener('load', function() {
      NProgress.done();
    })
  </script>


<script  src="https://cdn.jsdelivr.net/npm/jquery@3.6.0/dist/jquery.min.js" ></script>
<script  src="https://cdn.jsdelivr.net/npm/bootstrap@4.5.3/dist/js/bootstrap.min.js" ></script>
<script  src="/js/events.js" ></script>
<script  src="/js/plugins.js" ></script>

<!-- Plugins -->


  
    <script  src="/js/img-lazyload.js" ></script>
  



  



  <script  src="https://cdn.jsdelivr.net/npm/tocbot@4.12.2/dist/tocbot.min.js" ></script>



  <script  src="https://cdn.jsdelivr.net/npm/@fancyapps/fancybox@3.5.7/dist/jquery.fancybox.min.js" ></script>



  <script  src="https://cdn.jsdelivr.net/npm/anchor-js@4.3.0/anchor.min.js" ></script>



  <script defer src="https://cdn.jsdelivr.net/npm/clipboard@2.0.8/dist/clipboard.min.js" ></script>






  <script  src="https://cdn.jsdelivr.net/npm/typed.js@2.0.11/lib/typed.min.js" ></script>
  <script>
    (function (window, document) {
      var typing = Fluid.plugins.typing;
      var title = document.getElementById('subtitle').title;
      
      typing(title)
      
    })(window, document);
  </script>



  <script  src="/js/local-search.js" ></script>
  <script>
    (function () {
      var path = "/local-search.xml";
      $('#local-search-input').on('click', function() {
        searchFunc(path, 'local-search-input', 'local-search-result');
      });
      $('#modalSearch').on('shown.bs.modal', function() {
        $('#local-search-input').focus();
      });
    })()
  </script>





  

  
    <!-- MathJax -->
    <script>
      MathJax = {
        tex: {
          inlineMath: [['$', '$'], ['\\(', '\\)']]
        },
        options: {
          renderActions: {
            findScript: [10, doc => {
              document.querySelectorAll('script[type^="math/tex"]').forEach(node => {
                const display = !!node.type.match(/; *mode=display/);
                const math = new doc.options.MathItem(node.textContent, doc.inputJax[0], display);
                const text = document.createTextNode('');
                node.parentNode.replaceChild(text, node);
                math.start = { node: text, delim: '', n: 0 };
                math.end = { node: text, delim: '', n: 0 };
                doc.math.push(math);
              });
            }, '', false],
            insertedScript: [200, () => {
              document.querySelectorAll('mjx-container').forEach(node => {
                let target = node.parentNode;
                if (target.nodeName.toLowerCase() === 'li') {
                  target.parentNode.classList.add('has-jax');
                }
              });
            }, '', false]
          }
        }
      };
    </script>

    <script async src="https://cdn.jsdelivr.net/npm/mathjax@3.1.2/es5/tex-svg.js" ></script>

  











<!-- 主题的启动项 保持在最底部 -->
<script  src="/js/boot.js" ></script><!-- hexo-inject:begin --><!-- hexo-inject:end -->


</body>
</html>
